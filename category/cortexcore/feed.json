{
    "version": "https://jsonfeed.org/version/1",
    "title": "Oikiou's Blog • All posts by \"cortexcore\" category",
    "description": "Blog",
    "home_page_url": "https://www.oikiou.top",
    "items": [
        {
            "id": "https://www.oikiou.top/2021/da01e608/",
            "url": "https://www.oikiou.top/2021/da01e608/",
            "title": "Cortex-A7 基础",
            "date_published": "2021-07-02T08:33:15.000Z",
            "content_html": "<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>Cortex-A7 MPCore </p>\n<ul>\n<li><p>1-4core</p>\n</li>\n<li><p>Cortex-A15(big)+Cortex-A7(LITTLE)</p>\n</li>\n<li><p>L1 Cache 8,16,32,64KB</p>\n</li>\n<li><p>L2 Choice</p>\n</li>\n</ul>\n<p>Cortex-A7 MPCore 基于 ARMv7-A</p>\n<ul>\n<li>SIMDv2 扩展整形和浮点向量</li>\n<li>VFPv4 高性能单双精度浮点指令</li>\n<li>LPAE 40bit寻址 最大1TB内存</li>\n<li>硬件虚拟化</li>\n<li>NEON 多媒体、信号处理加速</li>\n</ul>\n<h1 id=\"运行模式\"><a href=\"#运行模式\" class=\"headerlink\" title=\"运行模式\"></a>运行模式</h1><p>Cortex-A7处理器有 9种处理模式，除了 User(USR)用户模式以外，其它 8 种运行模式都是特权模式。  </p>\n<table>\n<thead>\n<tr>\n<th>模式</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>User(USR)</td>\n<td>用户模式，非特权大部分程序运行的时候就处于此。</td>\n</tr>\n<tr>\n<td>FIQ</td>\n<td>快速中断模式，进入 FIQ 中断异常</td>\n</tr>\n<tr>\n<td>IRQ</td>\n<td>一般中断模式。</td>\n</tr>\n<tr>\n<td>Supervisor(SVC)</td>\n<td>超级管理员模式，特权模式，供操作系统使用。</td>\n</tr>\n<tr>\n<td>Monitor(MON)</td>\n<td>这个模式用于安全扩展模式。</td>\n</tr>\n<tr>\n<td>Abort(ABT)</td>\n<td>数据访问终止模式，用于虚拟存储以及存储保护。</td>\n</tr>\n<tr>\n<td>Hyp(HYP)</td>\n<td>用于虚拟化扩展。</td>\n</tr>\n<tr>\n<td>Undef(UND)</td>\n<td>未定义指令终止模式。</td>\n</tr>\n<tr>\n<td>System(SYS)</td>\n<td>系统模式，用于运行特权级的操作系统任务</td>\n</tr>\n</tbody></table>\n<h1 id=\"寄存器\"><a href=\"#寄存器\" class=\"headerlink\" title=\"寄存器\"></a>寄存器</h1><p><img src=\"/2021/da01e608/image-20210702163336723.png\" alt=\"image-20210702163336723\"></p>\n<ul>\n<li>暗色代表没有物理寄存器</li>\n</ul>\n<p><img src=\"/2021/da01e608/image-20210702163355713.png\" alt=\"image-20210702163355713\"></p>\n<h2 id=\"CPSR\"><a href=\"#CPSR\" class=\"headerlink\" title=\"CPSR\"></a>CPSR</h2><p>CPSR 是当前程序状态寄存器，该寄存器包含了条件标志位、中断禁止位、当前处理器模式标志<br>等一些状态位以及一些控制位。  </p>\n<p>SPSR(备份程序状态寄存器)  备份CPSR的</p>\n<p><img src=\"/2021/da01e608/image-20210702164501790.png\" alt=\"image-20210702164501790\"></p>\n<ul>\n<li><p>N(bit31)：当两个补码表示的 有符号整数运算的时候， N&#x3D;1 表示运算对的结果为负数， N&#x3D;0表示结果为正数。</p>\n</li>\n<li><p>Z(bit30)： Z&#x3D;1 表示运算结果为零， Z&#x3D;0 表示运算结果不为零，对于 CMP 指令， Z&#x3D;1 表示进行比较的两个数大小相等。</p>\n</li>\n<li><p>C(bit29)：在加法指令中，当结果产生了进位，则 C&#x3D;1，表示无符号数运算发生上溢，其它情况下 C&#x3D;0。在减法指令中，当运算中发生借位，则 C&#x3D;0，表示无符号数运算发生下溢，其它情况下 C&#x3D;1。对于包含移位操作的非加&#x2F;减法运算指令， C 中包含最后一次溢出的位的数值，对于其它非加&#x2F;减运算指令， C 位的值通常不受影响。</p>\n</li>\n<li><p>V(bit28)： 对于加&#x2F;减法运算指令，当操作数和运算结果表示为二进制的补码表示的带符号数时， V&#x3D;1 表示符号位溢出，通常其他位不影响 V 位。</p>\n</li>\n<li><p>Q(bit27)： 仅 ARM v5TE_J 架构支持，表示饱和状态， Q&#x3D;1 表示累积饱和， Q&#x3D;0 表示累积不饱和。</p>\n</li>\n<li><p>IT[1:0].(bit26:25)： 和 IT[7:2].(bit15:bit10)一起组成 IT[7:0]，作为 IF-THEN 指令执行状态。</p>\n</li>\n<li><p>J(bit24)： 仅 ARM_v5TE-J 架构支持， J&#x3D;1 表示处于 Jazelle 状态，此位通常和 T(bit5)位一起表示当前所使用的指令集：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>J</th>\n<th>T</th>\n<th>bref</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>0</td>\n<td>ARM</td>\n</tr>\n<tr>\n<td>0</td>\n<td>1</td>\n<td>Thumb</td>\n</tr>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>ThumbEE</td>\n</tr>\n<tr>\n<td>1</td>\n<td>0</td>\n<td>Jazelle</td>\n</tr>\n</tbody></table>\n<ul>\n<li><p>GE[3:0].(bit19:16)： SIMD 指令有效，大于或等于。</p>\n</li>\n<li><p>IT[7:2].(bit15:10)： 参考 IT[1:0]。</p>\n</li>\n<li><p>E(bit9)： 大小端控制位， E&#x3D;1 表示大端模式， E&#x3D;0 表示小端模式。</p>\n</li>\n<li><p>A(bit8)： 禁止异步中断位， A&#x3D;1 表示禁止异步中断。</p>\n</li>\n<li><p>I(bit7)： I&#x3D;1 禁止 IRQ， I&#x3D;0 使能 IRQ。</p>\n</li>\n<li><p>F(bit6)： F&#x3D;1 禁止 FIQ， F&#x3D;0 使能 FIQ。</p>\n</li>\n<li><p>T(bit5)： 控制指令执行状态，表明本指令是 ARM 指令还是 Thumb 指令，通常和 J(bit24)一起表明指令类型，参考 J(bit24)位。</p>\n</li>\n<li><p>M[4:0]： 处理器模式控制位：</p>\n<table>\n<thead>\n<tr>\n<th>M[4:0]</th>\n<th>CPU Mode</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>10000</td>\n<td>User 模式</td>\n</tr>\n<tr>\n<td>10001</td>\n<td>FIQ 模式</td>\n</tr>\n<tr>\n<td>10010</td>\n<td>IRQ 模式</td>\n</tr>\n<tr>\n<td>10011</td>\n<td>Supervisor(SVC)模式</td>\n</tr>\n<tr>\n<td>10110</td>\n<td>Monitor(MON)模式</td>\n</tr>\n<tr>\n<td>10111</td>\n<td>Abort(ABT)模式</td>\n</tr>\n<tr>\n<td>11010</td>\n<td>Hyp(HYP)模式</td>\n</tr>\n<tr>\n<td>11011</td>\n<td>Undef(UND)模式</td>\n</tr>\n<tr>\n<td>11111</td>\n<td>System(SYS)模式</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<p>​    </p>\n",
            "tags": [
                "cortex-a7"
            ]
        },
        {
            "id": "https://www.oikiou.top/2020/2651f4ca/",
            "url": "https://www.oikiou.top/2020/2651f4ca/",
            "title": "Cortex-M3基础",
            "date_published": "2020-10-30T11:08:15.000Z",
            "content_html": "<h1 id=\"Cortex-M3基础\"><a href=\"#Cortex-M3基础\" class=\"headerlink\" title=\"Cortex-M3基础\"></a>Cortex-M3基础</h1><h2 id=\"寄存器组\"><a href=\"#寄存器组\" class=\"headerlink\" title=\"寄存器组\"></a>寄存器组</h2><p><img src=\"/2020/2651f4ca/image-20201030190843098.png\" alt=\"image-20201030190843098\"></p>\n<h3 id=\"堆栈指针\"><a href=\"#堆栈指针\" class=\"headerlink\" title=\"堆栈指针\"></a>堆栈指针</h3><ul>\n<li><p>R13在同一时间只有一个可见，这就是所谓的“banked”寄存器。R13 作为堆栈指针寄存器 (Stack Pointer，SP)。</p>\n</li>\n<li><p>主堆栈指针（MSP）：复位后缺省使用的堆栈指针，用于操作系统内核以及异常处理例程（包<br>括中断服务例程）</p>\n</li>\n<li><p>进程堆栈指针（PSP）：由用户的应用程序代码使用。</p>\n</li>\n</ul>\n<h3 id=\"连接寄存器\"><a href=\"#连接寄存器\" class=\"headerlink\" title=\"连接寄存器\"></a>连接寄存器</h3><p>R14 作为连接寄存器 (Link Register，LR)，当呼叫(调用)一个子程序时，由R14 存储返回地址。</p>\n<h3 id=\"程序计数寄存器\"><a href=\"#程序计数寄存器\" class=\"headerlink\" title=\"程序计数寄存器\"></a>程序计数寄存器</h3><p>R15 作为程序计数器 (Program Counter，PC)，指向当前的程序地址。如果修改它的值，就能改变程序的执行流。</p>\n<h2 id=\"特殊功能寄存器\"><a href=\"#特殊功能寄存器\" class=\"headerlink\" title=\"特殊功能寄存器\"></a>特殊功能寄存器</h2><p><img src=\"/2020/2651f4ca/image-20201030192111032.png\" alt=\"image-20201030192111032\"></p>\n<table>\n<thead>\n<tr>\n<th>寄存器</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>xPSR</td>\n<td>记录ALU 标志（0 标志，进位标志，负数标志，溢出标志），执行状态，<strong>以及当前正服务的中断号</strong>。(保存算术与逻辑标志，例如负数标志，零结果标志，溢出标志等等)</td>\n</tr>\n<tr>\n<td>PRIMASK</td>\n<td>除能所有的中断，不可屏蔽中断（NMI）不受影响。</td>\n</tr>\n<tr>\n<td>FAULTMASK</td>\n<td>除能所有的fault——NMI 依然不受影响，而且被除能的faults 会“上访”，见后续章节的叙述。</td>\n</tr>\n<tr>\n<td>BASEPRI</td>\n<td>除能所有优先级不高于某个具体数值的中断。</td>\n</tr>\n<tr>\n<td>CONTROL</td>\n<td>定义特权状态（见后续章节对特权的叙述），并且决定使用哪一个堆栈指针。(如果是具有浮点单元的 Cortex-M4 或者 Cortex-M7，控制寄存器也用来指示浮点单元当前是否在使用)</td>\n</tr>\n</tbody></table>\n<h3 id=\"xPSR\"><a href=\"#xPSR\" class=\"headerlink\" title=\"xPSR\"></a>xPSR</h3><p>程序状态寄存器在其内部又被分为三个子状态寄存器：</p>\n<ul>\n<li>应用程序 PSR（APSR）</li>\n<li>中断号 PSR（IPSR）</li>\n<li>执行 PSR（EPSR）<br><img src=\"/2020/2651f4ca/image-20201217154557648.png\" alt=\"image-20201217154557648\"></li>\n</ul>\n<h3 id=\"PRIMASK，FAULTMASK-，BASEPRI\"><a href=\"#PRIMASK，FAULTMASK-，BASEPRI\" class=\"headerlink\" title=\"PRIMASK，FAULTMASK ，BASEPRI\"></a>PRIMASK，FAULTMASK ，BASEPRI</h3><p>CM3 page.41</p>\n<h3 id=\"CONTROL-控制寄存器\"><a href=\"#CONTROL-控制寄存器\" class=\"headerlink\" title=\"CONTROL 控制寄存器\"></a>CONTROL 控制寄存器</h3><table>\n<thead>\n<tr>\n<th>位</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>CONTROL[1]</td>\n<td>堆栈指针选择<br/>0&#x3D;选择主堆栈指针MSP（复位后缺省值）<br/>1&#x3D;选择进程堆栈指针PSP<br/>在线程或基础级（没有在响应异常——译注），可以使用PSP。在handler 模式下，<br/>只允许使用MSP，所以此时不得往该位写1。</td>\n</tr>\n<tr>\n<td>CONTROL[0]</td>\n<td>0&#x3D;特权级的线程模式<br/>1&#x3D;用户级的线程模式<br/>Handler 模式永远都是特权级的。</td>\n</tr>\n</tbody></table>\n<h2 id=\"操作模式和特权模式\"><a href=\"#操作模式和特权模式\" class=\"headerlink\" title=\"操作模式和特权模式\"></a>操作模式和特权模式</h2><p>Cortex-M 引入了操作模式(handler mode、thread mode)和特权级别(特权级和用户级)的概念，如果进入异常或中断处理则进入handler mode，其他情况则为thread mode。</p>\n<p><img src=\"/2020/2651f4ca/image-20201030193232853.png\" alt=\"image-20201030193232853\"></p>\n<p><strong>handler mode总是使用 MSP 作为堆栈</strong>，<strong>thread mode可以选择使用 MSP 或 PSP 作为堆栈</strong>，同样通过CONTROL 特殊寄存器控制。复位后，Cortex-M 默认进入线程模式、特权级、使用 MSP 堆栈。</p>\n<p><img src=\"/2020/2651f4ca/image-20201030193654568.png\" alt=\"image-20201030193654568\"></p>\n<p>这可以提供一种存储器访问的保护机制，使得普通的用户程序代码不能意外地，甚至是恶意地执行涉及到要害的操作。处理器支持两种特权级，这也是一个基本的安全模型。</p>\n<p>举例来说，操作系统的内核通常都在特权级下执行，所有没有被MPU 禁掉的存储器都可以访问。在操作系统开启了一个用户程序后，通常都会让它在用户级下执行，从而使系统不会因某个程序的崩溃或恶意破坏而受损。</p>\n<h2 id=\"内建的嵌套向量中断控制器-NVIC\"><a href=\"#内建的嵌套向量中断控制器-NVIC\" class=\"headerlink\" title=\"内建的嵌套向量中断控制器(NVIC)\"></a>内建的嵌套向量中断控制器(NVIC)</h2><h2 id=\"SVC和PendSV\"><a href=\"#SVC和PendSV\" class=\"headerlink\" title=\"SVC和PendSV\"></a>SVC和PendSV</h2><h3 id=\"SVC（系统服务调用，系统调用）\"><a href=\"#SVC（系统服务调用，系统调用）\" class=\"headerlink\" title=\"SVC（系统服务调用，系统调用）\"></a>SVC（系统服务调用，系统调用）</h3><p>例如，操作系统不让用户程序直接访问硬件，而是通过提供一些系统服务函数，用户程序使用SVC 发出对系统服务函数的呼叫请求，以这种方法调用它们来间接访问硬件。因此，当用户程序想要控制特定的硬件时，它就会产生一个SVC 异常，然后操作系统提供的SVC 异常服务例程得到执行，它再调用相关的操作系统函数，后者完成用户程序请求的服务。</p>\n<p>优势：</p>\n<ul>\n<li>第一，它使用户程序从控制硬件的繁文缛节中解脱出来，而是由OS 负责控制具体的硬件。</li>\n<li>第二，OS 的代码可以经过充分的测试，从而能使系统更加健壮和可靠。</li>\n<li>第三，它使用户程序无需在特权级下执行，用户程序无需承担因误操作而瘫痪整个系统的风险。</li>\n<li>第四，通过SVC 的机制，还让用户程序变得与硬件无关，因此在开发应用程序时无需了解硬件的操作细节，从而简化了开发的难度和繁琐度，并且使应用程序跨硬件平台移植成为可能。</li>\n</ul>\n<h3 id=\"PendSV（可悬起系统调用）\"><a href=\"#PendSV（可悬起系统调用）\" class=\"headerlink\" title=\"PendSV（可悬起系统调用）\"></a>PendSV（可悬起系统调用）</h3><p>PendSV ，它是可以像普通的中断一样被悬起的（不像SVC 那样会上访）。OS 可以利用它“缓期执行”一个异常——直到其它重要的任务完成后才执行动作。悬起PendSV 的方法是：手工往NVIC 的PendSV 悬起寄存器中写1。悬起后，如果优先级不够高，则将缓期等待执行。</p>\n<p>PendSV 的典型使用场合是在上下文切换时（在不同任务之间切换）。例如发生中断时产生线程唤醒，中断会引发一个PendSV，在中断运行结束后，会进入PendSV在里面进行线程唤醒（线程切换）。</p>\n<h1 id=\"一些总结和个人笔记\"><a href=\"#一些总结和个人笔记\" class=\"headerlink\" title=\"一些总结和个人笔记\"></a>一些总结和个人笔记</h1><h2 id=\"中断的入栈出栈\"><a href=\"#中断的入栈出栈\" class=\"headerlink\" title=\"中断的入栈出栈\"></a>中断的入栈出栈</h2><ol>\n<li>进入异常服务例程时，自动压栈R0‐R3, R12, LR, PSR 和PC。</li>\n<li>进入异常服务程序后，LR的值被自动更新为特殊的EXC_RETURN。</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>数值</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0xFFFF_FFF1</td>\n<td>返回handler模式</td>\n</tr>\n<tr>\n<td>0xFFFF_FFF9</td>\n<td>返回线程模式，并使用主堆栈(SP&#x3D;MSP)</td>\n</tr>\n<tr>\n<td>0xFFFF_FFFD</td>\n<td>返回线程模式，并使用线程堆栈(SP&#x3D;PSP)</td>\n</tr>\n</tbody></table>\n<ul>\n<li><p>如果主程序在线程模式下运行， 并且在使用MSP 时被中断， 则在服务例程中LR&#x3D;0xFFFF_FFF9（主程序被打断前的LR已被自动入栈）。</p>\n</li>\n<li><p>如果主程序在线程模式下运行， 并且在使用PSP 时被中断， 则在服务例程中LR&#x3D;0xFFFF_FFFD（主程序被打断前的LR已被自动入栈）。</p>\n</li>\n</ul>\n<ol start=\"3\">\n<li>进入函数调用时也会压栈Rxxx寄存器作为传入参数。</li>\n<li>R0作为函数的返回值。</li>\n</ol>\n",
            "tags": [
                "cortex-m3"
            ]
        }
    ]
}
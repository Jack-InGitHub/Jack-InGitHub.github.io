{
    "version": "https://jsonfeed.org/version/1",
    "title": "Oikiou's Blog • All posts by \"blog\" category",
    "description": "Blog",
    "home_page_url": "https://www.oikiou.top",
    "items": [
        {
            "id": "https://www.oikiou.top/2023/79891ac1/",
            "url": "https://www.oikiou.top/2023/79891ac1/",
            "title": "License差异对比",
            "date_published": "2023-02-02T06:23:05.000Z",
            "content_html": "<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://spdx.org/licenses/\">SPDX License List</a></p>\n<p>使用 <strong>SPDX 短格式标识符</strong> 以简单、高效、便携和机器可读的方式 传达 FOSS 许可证信息</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-regexp\">//</span> SPDX-License-Identifier: MIT<br><span class=\"hljs-regexp\">/* SPDX-License-Identifier: MIT OR Apache-2.0 */</span><br><span class=\"hljs-comment\"># SPDX-License-Identifier: GPL-2.0-or-later</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"术语\"><a href=\"#术语\" class=\"headerlink\" title=\"术语\"></a>术语</h1><h2 id=\"什么是“分发”？\"><a href=\"#什么是“分发”？\" class=\"headerlink\" title=\"什么是“分发”？\"></a>什么是“分发”？</h2><p>许可证授予的权利，允许你自由使用、修改、复制，但是<strong>在“分发”时就必须遵守许可证的约束</strong>。换言之，如果不”分发”，就不需要遵守。</p>\n<p>分发就是指将版权作品从一个人转移到另一个人。这意味着，如果你是自己使用，不提供给他人，就没有分发。另外，这里的”人”也指”法人”，因此如果使用方是公司，且只在公司内部使用，也不需要遵守许可证[]。</p>\n<p>其中AGPL有个特例：AGPL定义，如果你使用开源软件<strong>提供网络交互服务，那么该行为也定义为“分发”</strong>，即图中的“网络使用即分发”</p>\n<h2 id=\"什么是“传染性”？\"><a href=\"#什么是“传染性”？\" class=\"headerlink\" title=\"什么是“传染性”？\"></a>什么是“传染性”？</h2><p>传染性来源于GPL，GPL的支持者确信自由软件世界应具有自我保护能力和可持续发展性——为了确保自由软件的演绎作品同样“自由”，所以要求只要使用了GPL的代码，那么整个项目都必须以GPL方式公开源代码</p>\n<p>LGPL 在这方面要求就没GPL那么严格，如果只是子系统&#x2F;模块用了，那么只需要子系统&#x2F;模块开源，整个工程不用开源；如果是以动态链接调用LGPL许可证的库，那么项目也不用开源。</p>\n<p>MPL 在这个方面就更宽松，哪个文件用了该许可证的代码，只需要这些文件开源即可，其他文件不受影响</p>\n<p>所以，GPL v2&#x2F;v3、AGPL 属于工程级别的强传染性；LGPL属于库级别的若传染性；MPL 就是文件级别的，传染性可以忽略不计了</p>\n<h2 id=\"GPL-系列的协议有何区别？\"><a href=\"#GPL-系列的协议有何区别？\" class=\"headerlink\" title=\"GPL 系列的协议有何区别？\"></a>GPL 系列的协议有何区别？</h2><p><strong>AGPL 和 GPL 的区别：</strong></p>\n<p>AGPL明确了GPL 2.0&#x2F;3.0关于提供网络服务也属于分发限制的说明：使用GPL的自由软件，但是并不发布与网络之中，则可以自由的使用GPL协议确不开源自己私有的解决方案。AGPL则增加了对此做法的约束。比如使用了AGPL代码的软件是一个网络应用，那么这个软件的所有源码和修改代码也必须开源</p>\n<p><strong>GPL v2 和 GPL v3的主要差异：</strong></p>\n<p>a) GPLv3包含了明确的专利许可</p>\n<p>b) 添加了对数字版权管理和加密签名的限制，不仅要求用户公开源码，还要求公布相关硬件及必要的安装信息。</p>\n<p><strong>GPL 和LGPL的区别：</strong></p>\n<p>主要区别在于传染性方面，GPL是工程级别的强传染，LGPL是库级别的弱传染</p>\n<h2 id=\"违反开源项目许可有何风险？\"><a href=\"#违反开源项目许可有何风险？\" class=\"headerlink\" title=\"违反开源项目许可有何风险？\"></a>违反开源项目许可有何风险？</h2><p>1.被许可人在违反许可证设定的义务时会构成合同违约</p>\n<p>2.开源软件受著作权保护，著作权法著作权法，但是开源许可证本质却是走在了版权保护的对立面，所以其法律效力并没有被明确认可，是否侵权可能需要法院视具体情况而定</p>\n<p>3.在中国，侵权责任和违约责任不能同时主张</p>\n<p>4.在中国，过往的判例都没有涉及开源软件许可证本身</p>\n<p>5.除了面临法律诉讼风险，违反许可证的行为会导致自由软件者和开源社区的排斥，某种程度上会影响违约公司的商业信誉</p>\n<h1 id=\"差异\"><a href=\"#差异\" class=\"headerlink\" title=\"差异\"></a>差异</h1><p><img src=\"/2023/79891ac1/v2-3a460a2dad345fe0c2e0e79b626aacc9_720w.webp\" alt=\"img\"></p>\n",
            "tags": [
                "license"
            ]
        },
        {
            "id": "https://www.oikiou.top/2023/e7fefe87/",
            "url": "https://www.oikiou.top/2023/e7fefe87/",
            "title": "Let’s Encrypt SSL 证书申请",
            "date_published": "2023-01-12T04:08:08.000Z",
            "content_html": "<h1 id=\"Let’s-Encrypt-SSL-证书申请\"><a href=\"#Let’s-Encrypt-SSL-证书申请\" class=\"headerlink\" title=\"Let’s Encrypt SSL 证书申请\"></a>Let’s Encrypt SSL 证书申请</h1><h1 id=\"为什么申请？\"><a href=\"#为什么申请？\" class=\"headerlink\" title=\"为什么申请？\"></a>为什么申请？</h1><blockquote>\n<h2 id=\"HTTP：未实施数据加密\"><a href=\"#HTTP：未实施数据加密\" class=\"headerlink\" title=\"HTTP：未实施数据加密\"></a>HTTP：未实施数据加密</h2><p>  每个以 HTTP 开头的 URL 链接都使用一种基本类型的“超文本传输协议”。由 Tim Berners-Lee 于 1990 年代初创建，当时互联网仍处于起步阶段，该网络协议标准允许 Web 浏览器和服务器通过数据交换进行通信。</p>\n<p>  HTTP 也被称为“无状态系统”，这意味着它可以按需连接。您单击一个链接，请求连接，您的 Web 浏览器将此请求发送到服务器，服务器通过打开页面进行响应。连接越快，数据呈现给您的速度就越快。</p>\n<p>  作为一种“应用层协议”，HTTP 仍然专注于呈现信息，但不太关心这些信息从一个地方传播到另一个地方的方式。不幸的是，这意味着 HTTP 可能会<a href=\"https://www.globalsign.com/en/blog/what-is-a-man-in-the-middle-attack\">被拦截并可能被更改</a>，从而使信息和信息接收者（即您）都容易受到攻击。</p>\n<h2 id=\"HTTPS：加密连接\"><a href=\"#HTTPS：加密连接\" class=\"headerlink\" title=\"HTTPS：加密连接\"></a>HTTPS：加密连接</h2><p>  HTTPS 不是 HTTP 的对立面，而是它的表弟。两者本质上是相同的，因为它们都指的是相同的“超文本传输协议”，该协议使请求的 Web 数据能够显示在您的屏幕上。但是，HTTPS 仍然略有不同，更先进，也更安全。</p>\n<p>  简单的说，HTTPS协议是HTTP的扩展。缩写中的“S”来自 Secure 一词，它由传输层安全性 (TLS) [<a href=\"https://www.globalsign.com/en/ssl-information-center/what-is-ssl/\">安全套接字层 (SSL)</a>的后继者] 提供支持，这是一种在 Web 服务器和服务器之间建立加密连接的标准安全技术。浏览器。</p>\n<p>  如果没有 HTTPS，您输入网站的任何数据（例如您的用户名&#x2F;密码、信用卡或银行详细信息、任何其他表单提交数据等）都将以明文形式发送，因此容易被拦截或窃听。因此，在输入任何信息之前，您应该始终检查站点是否使用 HTTPS。</p>\n<p>  除了加密服务器和您的浏览器之间传输的数据外，TLS 还验证您正在连接的服务器并保护传输的数据不被篡改。</p>\n<p>  这有助于我这样思考——HTTPS 中的 HTTP 相当于一个目的地，而 SSL 相当于一个旅程。第一个负责将数据显示到屏幕上，第二个负责管理数据到达那里的方式。通过联合力量，他们以安全的方式移动数据。  </p>\n<p>  <a href=\"https://www.globalsign.com/en/blog/the-difference-between-http-and-https\">What’s the difference between HTTP and HTTPS?</a></p>\n</blockquote>\n<p>HTTPS 有助于确保网络安全。毫无疑问，它是比 HTTP 更好的网络协议解决方案。</p>\n<p>将网站开启HTTPS的服务是需要SSL的证书的，我们来看一下如何在Let’s Encrypt上申请免费的SSL证书。</p>\n<blockquote>\n<p>  Let’s Encrypt 是免费、开放和自动化的证书颁发机构。由非盈利组织<a href=\"https://www.abetterinternet.org/\">互联网安全研究小组（ISRG）</a>运营。</p>\n</blockquote>\n<h1 id=\"申请的前提条件\"><a href=\"#申请的前提条件\" class=\"headerlink\" title=\"申请的前提条件\"></a>申请的前提条件</h1><p>我们申请SSL证书的前提条件有下面这几个</p>\n<ol>\n<li>拥有域名，能够自主配置DNS。或者提供Web服务器做验证，在网站目录下放一个文件。</li>\n<li>获取证书的环境要能访问DNS服务器，因为会需要做DNS解析校验。</li>\n<li>需要有远程主机的权限，会需要更新和安装组件。</li>\n</ol>\n<h1 id=\"申请步骤\"><a href=\"#申请步骤\" class=\"headerlink\" title=\"申请步骤\"></a>申请步骤</h1><p>Let’s Encrypt 的证书申请除去手动申请常见的主要有下面这几种</p>\n<ul>\n<li><code>acme.sh</code>的方式<em>（我当时选取了这个方式）</em></li>\n<li>docker 镜像获取</li>\n<li><code>certbot</code>方式获取证书<em>（官网建议使用这种方式获取证书，可以在不下线的状态下自动执行证书颁发和安装）</em></li>\n</ul>\n<h2 id=\"acme-sh脚本\"><a href=\"#acme-sh脚本\" class=\"headerlink\" title=\"acme.sh脚本\"></a><code>acme.sh</code>脚本</h2><p><a href=\"https://github.com/acmesh-official/acme.sh\">Github链接：An ACME Shell script: acme.sh</a></p>\n<p>Github的README其实介绍的其实很全面，这里copy一下。</p>\n<blockquote>\n<p>  <strong>acme.sh</strong> 实现了 <code>acme</code> 协议, 可以从 letsencrypt 生成免费的证书.</p>\n<p>  主要步骤:</p>\n<ol>\n<li>安装 <strong>acme.sh</strong></li>\n<li>生成证书</li>\n<li>copy 证书到 nginx&#x2F;apache 或者其他服务</li>\n<li>更新证书</li>\n<li>更新 <strong>acme.sh</strong></li>\n<li>出错怎么办, 如何调试</li>\n</ol>\n<p>  下面详细介绍.</p>\n<h1 id=\"1-安装-acme-sh\"><a href=\"#1-安装-acme-sh\" class=\"headerlink\" title=\"1. 安装 acme.sh\"></a>1. 安装 <strong>acme.sh</strong></h1><p>  安装很简单, 一个命令:</p>\n<blockquote>\n<p>  这里输入你的邮箱，这个邮箱有什么用倒是不太清楚</p>\n</blockquote>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">curl https://get.acme.sh | sh -s email=my@example.com<br></code></pre></td></tr></table></figure>\n\n<p>  普通用户和 root 用户都可以安装使用. 安装过程进行了以下几步:</p>\n<ol>\n<li>把 acme.sh 安装到你的 <strong>home</strong> 目录下:</li>\n</ol>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">~/.acme.sh/<br></code></pre></td></tr></table></figure>\n\n<p>  并创建 一个 shell 的 alias, 例如 .bashrc，方便你的使用: <code>alias acme.sh=~/.acme.sh/acme.sh</code></p>\n<ol start=\"2\">\n<li>自动为你创建 cronjob, 每天 0:00 点自动检测所有的证书, 如果快过期了, 需要更新, 则会自动更新证书.</li>\n</ol>\n<p>  更高级的安装选项请参考: <a href=\"https://github.com/Neilpang/acme.sh/wiki/How-to-install\">https://github.com/Neilpang/acme.sh/wiki/How-to-install</a></p>\n<p>  <strong>安装过程不会污染已有的系统任何功能和文件</strong>, 所有的修改都限制在安装目录中: <code>~/.acme.sh/</code></p>\n<h1 id=\"2-生成证书\"><a href=\"#2-生成证书\" class=\"headerlink\" title=\"2. 生成证书\"></a>2. 生成证书</h1><p>  <strong>acme.sh</strong> 实现了 <strong>acme</strong> 协议支持的所有验证协议. 一般有两种方式验证: http 和 dns 验证.</p>\n<h3 id=\"1-http-方式需要在你的网站根目录下放置一个文件-来验证你的域名所有权-完成验证-然后就可以生成证书了\"><a href=\"#1-http-方式需要在你的网站根目录下放置一个文件-来验证你的域名所有权-完成验证-然后就可以生成证书了\" class=\"headerlink\" title=\"1. http 方式需要在你的网站根目录下放置一个文件, 来验证你的域名所有权,完成验证. 然后就可以生成证书了.\"></a>1. http 方式需要在你的网站根目录下放置一个文件, 来验证你的域名所有权,完成验证. 然后就可以生成证书了.</h3>  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">acme.sh --issue -d mydomain.com -d www.mydomain.com --webroot /home/wwwroot/mydomain.com/<br></code></pre></td></tr></table></figure>\n\n<p>  只需要指定域名, 并指定域名所在的网站根目录. <strong>acme.sh</strong> 会全自动的生成验证文件, 并放到网站的根目录, 然后自动完成验证. 最后会聪明的删除验证文件. 整个过程没有任何副作用.</p>\n<p>  如果你用的 <strong>apache</strong>服务器, <strong>acme.sh</strong> 还可以智能的从 <strong>apache</strong>的配置中自动完成验证, 你不需要指定网站根目录:</p>\n  <figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">acme<span class=\"hljs-selector-class\">.sh</span> <span class=\"hljs-attr\">--issue</span> -d mydomain<span class=\"hljs-selector-class\">.com</span> <span class=\"hljs-attr\">--apache</span><br></code></pre></td></tr></table></figure>\n\n<p>  如果你用的 <strong>nginx</strong>服务器, 或者反代, <strong>acme.sh</strong> 还可以智能的从 <strong>nginx</strong>的配置中自动完成验证, 你不需要指定网站根目录:</p>\n  <figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">acme<span class=\"hljs-selector-class\">.sh</span> <span class=\"hljs-attr\">--issue</span> -d mydomain<span class=\"hljs-selector-class\">.com</span> <span class=\"hljs-attr\">--nginx</span><br></code></pre></td></tr></table></figure>\n\n<p>  <strong>注意, 无论是 apache 还是 nginx 模式, acme.sh在完成验证之后, 会恢复到之前的状态, 都不会私自更改你本身的配置. 好处是你不用担心配置被搞坏, 也有一个缺点, 你需要自己配置 ssl 的配置, 否则只能成功生成证书, 你的网站还是无法访问https. 但是为了安全, 你还是自己手动改配置吧.</strong></p>\n<p>  如果你还没有运行任何 web 服务, <strong>80</strong> 端口是空闲的, 那么 <strong>acme.sh</strong> 还能假装自己是一个webserver, 临时听在<strong>80</strong> 端口, 完成验证:</p>\n  <figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">acme<span class=\"hljs-selector-class\">.sh</span> <span class=\"hljs-attr\">--issue</span> -d mydomain<span class=\"hljs-selector-class\">.com</span> <span class=\"hljs-attr\">--standalone</span><br></code></pre></td></tr></table></figure>\n\n<p>  更高级的用法请参考: <a href=\"https://github.com/Neilpang/acme.sh/wiki/How-to-issue-a-cert\">https://github.com/Neilpang/acme.sh/wiki/How-to-issue-a-cert</a></p>\n<h3 id=\"2-手动-dns-方式-手动在域名上添加一条-txt-解析记录-验证域名所有权\"><a href=\"#2-手动-dns-方式-手动在域名上添加一条-txt-解析记录-验证域名所有权\" class=\"headerlink\" title=\"2. 手动 dns 方式, 手动在域名上添加一条 txt 解析记录, 验证域名所有权.\"></a>2. 手动 dns 方式, 手动在域名上添加一条 txt 解析记录, 验证域名所有权.</h3><p>  这种方式的好处是, 你不需要任何服务器, 不需要任何公网 ip, 只需要 dns 的解析记录即可完成验证. 坏处是，如果不同时配置 Automatic DNS API，使用这种方式 acme.sh 将无法自动更新证书，每次都需要手动再次重新解析验证域名所有权。</p>\n  <figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">acme<span class=\"hljs-selector-class\">.sh</span> <span class=\"hljs-attr\">--issue</span> <span class=\"hljs-attr\">--dns</span> -d mydomain<span class=\"hljs-selector-class\">.com</span> \\<br> <span class=\"hljs-attr\">--yes-I-know-dns-manual-mode-enough-go-ahead-please</span><br></code></pre></td></tr></table></figure>\n\n<p>  然后, <strong>acme.sh</strong> 会生成相应的解析记录显示出来, 你只需要在你的域名管理面板中添加这条 txt 记录即可.</p>\n<p>  等待解析完成之后, 重新生成证书:</p>\n  <figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">acme<span class=\"hljs-selector-class\">.sh</span> <span class=\"hljs-attr\">--renew</span> -d mydomain<span class=\"hljs-selector-class\">.com</span> \\<br>  <span class=\"hljs-attr\">--yes-I-know-dns-manual-mode-enough-go-ahead-please</span><br></code></pre></td></tr></table></figure>\n\n<p>  注意第二次这里用的是 <code>--renew</code></p>\n<p>  dns 方式的真正强大之处在于可以使用域名解析商提供的 api 自动添加 txt 记录完成验证.</p>\n<p>  <strong>acme.sh</strong> 目前支持 cloudflare, dnspod, cloudxns, godaddy 以及 ovh 等数十种解析商的自动集成.</p>\n<p>  以 dnspod 为例, 你需要先登录到 dnspod 账号, 生成你的 api id 和 api key, 都是免费的. 然后:</p>\n  <figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\"><span class=\"hljs-built_in\">export</span> <span class=\"hljs-attribute\">DP_Id</span>=<span class=\"hljs-string\">&quot;1234&quot;</span><br><br><span class=\"hljs-built_in\">export</span> <span class=\"hljs-attribute\">DP_Key</span>=<span class=\"hljs-string\">&quot;sADDsdasdgdsf&quot;</span><br><br>acme.sh --issue --dns dns_dp -d aa.com -d www.aa.com<br></code></pre></td></tr></table></figure>\n\n<p>  证书就会自动生成了. 这里给出的 api id 和 api key 会被自动记录下来, 将来你在使用 dnspod api 的时候, 就不需要再次指定了. 直接生成就好了:</p>\n  <figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">acme<span class=\"hljs-selector-class\">.sh</span> <span class=\"hljs-attr\">--issue</span> -d mydomain2<span class=\"hljs-selector-class\">.com</span> <span class=\"hljs-attr\">--dns</span>  dns_dp<br></code></pre></td></tr></table></figure>\n\n<p>  更详细的 api 用法: <a href=\"https://github.com/Neilpang/acme.sh/blob/master/dnsapi/README.md\">https://github.com/Neilpang/acme.sh/blob/master/dnsapi/README.md</a></p>\n<h1 id=\"3-copy-x2F-安装-证书\"><a href=\"#3-copy-x2F-安装-证书\" class=\"headerlink\" title=\"3. copy&#x2F;安装 证书\"></a>3. copy&#x2F;安装 证书</h1><p>  前面证书生成以后, 接下来需要把证书 copy 到真正需要用它的地方.</p>\n<p>  注意, 默认生成的证书都放在安装目录下: <code>~/.acme.sh/</code>, <strong>请不要直接使用此目录下的文件,</strong> 例如: 不要直接让 nginx&#x2F;apache 的配置文件使用这下面的文件. 这里面的文件都是内部使用, 而且目录结构可能会变化.</p>\n<p>  正确的使用方法是使用 <code>--install-cert</code> 命令,并指定目标位置, 然后证书文件会被copy到相应的位置, 例如:</p>\n<h2 id=\"Apache-example\"><a href=\"#Apache-example\" class=\"headerlink\" title=\"Apache example:\"></a>Apache example:</h2>  <figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gradle\">acme.sh --install-cert -d example.com \\<br>--cert-<span class=\"hljs-keyword\">file</span>      <span class=\"hljs-regexp\">/path/</span>to<span class=\"hljs-regexp\">/certfile/i</span>n<span class=\"hljs-regexp\">/apache/</span>cert.pem  \\<br>--key-<span class=\"hljs-keyword\">file</span>       <span class=\"hljs-regexp\">/path/</span>to<span class=\"hljs-regexp\">/keyfile/i</span>n<span class=\"hljs-regexp\">/apache/</span>key.pem  \\<br>--fullchain-<span class=\"hljs-keyword\">file</span> <span class=\"hljs-regexp\">/path/</span>to<span class=\"hljs-regexp\">/fullchain/</span>certfile<span class=\"hljs-regexp\">/apache/</span>fullchain.pem \\<br>--reloadcmd     <span class=\"hljs-string\">&quot;service apache2 force-reload&quot;</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Nginx-example\"><a href=\"#Nginx-example\" class=\"headerlink\" title=\"Nginx example:\"></a>Nginx example:</h2>  <figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gradle\">acme.sh --install-cert -d example.com \\<br>--key-<span class=\"hljs-keyword\">file</span>       <span class=\"hljs-regexp\">/path/</span>to<span class=\"hljs-regexp\">/keyfile/i</span>n<span class=\"hljs-regexp\">/nginx/</span>key.pem  \\<br>--fullchain-<span class=\"hljs-keyword\">file</span> <span class=\"hljs-regexp\">/path/</span>to<span class=\"hljs-regexp\">/fullchain/</span>nginx/cert.pem \\<br>--reloadcmd     <span class=\"hljs-string\">&quot;service nginx force-reload&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>  (一个小提醒, 这里用的是 <code>service nginx force-reload</code>, 不是 <code>service nginx reload</code>, 据测试, <code>reload</code> 并不会重新加载证书, 所以用的 <code>force-reload</code>)</p>\n<blockquote>\n<p>  我当时使用这个命令的时候发现用 <code>service nginx force-reload</code>  报没有权限，然后是将当前用户</p>\n</blockquote>\n<p>  Nginx 的配置 <code>ssl_certificate</code> 使用 <code>/etc/nginx/ssl/fullchain.cer</code> ，而非 <code>/etc/nginx/ssl/&lt;domain&gt;.cer</code> ，否则 <a href=\"https://www.ssllabs.com/ssltest/\">SSL Labs</a> 的测试会报 <code>Chain issues Incomplete</code> 错误。</p>\n<p>  <code>--install-cert</code>命令可以携带很多参数, 来指定目标文件. 并且可以指定 reloadcmd, 当证书更新以后, reloadcmd会被自动调用,让服务器生效.</p>\n<p>  详细参数请参考: <a href=\"https://github.com/Neilpang/acme.sh#3-install-the-issued-cert-to-apachenginx-etc\">https://github.com/Neilpang/acme.sh#3-install-the-issued-cert-to-apachenginx-etc</a></p>\n<p>  值得注意的是, 这里指定的所有参数都会被自动记录下来, 并在将来证书自动更新以后, 被再次自动调用.</p>\n<h1 id=\"4-查看已安装证书信息\"><a href=\"#4-查看已安装证书信息\" class=\"headerlink\" title=\"4. 查看已安装证书信息\"></a>4. 查看已安装证书信息</h1>  <figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">acme.sh --<span class=\"hljs-built_in\">info</span> -d example.com<br><span class=\"hljs-comment\"># 会输出如下内容：</span><br><span class=\"hljs-attribute\">DOMAIN_CONF</span>=/root/.acme.sh/example.com/example.com.conf<br><span class=\"hljs-attribute\">Le_Domain</span>=example.com<br><span class=\"hljs-attribute\">Le_Alt</span>=<span class=\"hljs-literal\">no</span><br><span class=\"hljs-attribute\">Le_Webroot</span>=dns_ali<br>Le_PreHook=<br>Le_PostHook=<br>Le_RenewHook=<br><span class=\"hljs-attribute\">Le_API</span>=https://acme-v02.api.letsencrypt.org/directory<br>Le_Keylength=<br><span class=\"hljs-attribute\">Le_OrderFinalize</span>=https://acme-v02.api.letsencrypt.org/acme/finalize/23xxxx150/781xxxx4310<br><span class=\"hljs-attribute\">Le_LinkOrder</span>=https://acme-v02.api.letsencrypt.org/acme/order/233xxx150/781xxxx4310<br><span class=\"hljs-attribute\">Le_LinkCert</span>=https://acme-v02.api.letsencrypt.org/acme/cert/04cbd28xxxxxx349ecaea8d07<br><span class=\"hljs-attribute\">Le_CertCreateTime</span>=1649358725<br><span class=\"hljs-attribute\">Le_CertCreateTimeStr</span>=Thu Apr  7 19:12:05 UTC 2022<br><span class=\"hljs-attribute\">Le_NextRenewTimeStr</span>=Mon Jun  6 19:12:05 UTC 2022<br><span class=\"hljs-attribute\">Le_NextRenewTime</span>=1654456325<br>Le_RealCertPath=<br>Le_RealCACertPath=<br><span class=\"hljs-attribute\">Le_RealKeyPath</span>=/etc/acme/example.com/privkey.pem<br><span class=\"hljs-attribute\">Le_ReloadCmd</span>=service nginx force-reload<br><span class=\"hljs-attribute\">Le_RealFullChainPath</span>=/etc/acme/example.com/chain.pem<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"5-更新证书\"><a href=\"#5-更新证书\" class=\"headerlink\" title=\"5. 更新证书\"></a>5. 更新证书</h1><p>  目前证书在 60 天以后会自动更新, 你无需任何操作. 今后有可能会缩短这个时间, 不过都是自动的, 你不用关心.</p>\n<p>  请确保 cronjob 正确安装, 看起来是类似这样的:</p>\n  <figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gradle\">crontab  -l<br><br><span class=\"hljs-number\">56</span> * * * * <span class=\"hljs-string\">&quot;/root/.acme.sh&quot;</span><span class=\"hljs-regexp\">/acme.sh --cron --home &quot;/</span>root<span class=\"hljs-regexp\">/.acme.sh&quot; &gt; /</span>dev/<span class=\"hljs-keyword\">null</span><br></code></pre></td></tr></table></figure>\n\n<h1 id=\"6-关于修改ReloadCmd\"><a href=\"#6-关于修改ReloadCmd\" class=\"headerlink\" title=\"6. 关于修改ReloadCmd\"></a>6. 关于修改ReloadCmd</h1><p>  目前修改<code>ReloadCmd</code>没有专门的命令，可以通过重新安装证书来实现修改<code>reloadCmd</code>的目的。 此外，安装证书后，相关信息是保存在<code>~/.acme.sh/example.com/example.conf</code>文件下的，内容就是<code>acme.sh --info -d example.com</code>输出的信息，不过<code>ReloadCmd</code>在文件中使用了Base64编码。理论上可以通过直接修改该文件来修改<code>ReloadCmd</code>，且修改时，无需Base64编码，直接写命令原文<code>acme.sh</code>也可以识别。 不过，<code>example.conf</code>文件的位置和内容格式以后可能会改变！<code>example.conf</code>一直都是内部使用, 后面有可能会改为用 sqlite 或者mysql 格式存储. 所以一般不建议自己修改。</p>\n<h1 id=\"7-更新-acme-sh\"><a href=\"#7-更新-acme-sh\" class=\"headerlink\" title=\"7. 更新 acme.sh\"></a>7. 更新 acme.sh</h1><p>  目前由于 acme 协议和 letsencrypt CA 都在频繁的更新, 因此 acme.sh 也经常更新以保持同步.</p>\n<p>  升级 acme.sh 到最新版 :</p>\n  <figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">acme<span class=\"hljs-selector-class\">.sh</span> <span class=\"hljs-attr\">--upgrade</span><br></code></pre></td></tr></table></figure>\n\n<p>  如果你不想手动升级, 可以开启自动升级:</p>\n  <figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">acme<span class=\"hljs-selector-class\">.sh</span> <span class=\"hljs-attr\">--upgrade</span> <span class=\"hljs-attr\">--auto-upgrade</span><br></code></pre></td></tr></table></figure>\n\n<p>  之后, acme.sh 就会自动保持更新了.</p>\n<p>  你也可以随时关闭自动更新:</p>\n  <figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">acme<span class=\"hljs-selector-class\">.sh</span> <span class=\"hljs-attr\">--upgrade</span> <span class=\"hljs-attr\">--auto-upgrade</span>  <span class=\"hljs-number\">0</span><br></code></pre></td></tr></table></figure>\n\n<h1 id=\"8-出错怎么办：\"><a href=\"#8-出错怎么办：\" class=\"headerlink\" title=\"8. 出错怎么办：\"></a>8. 出错怎么办：</h1><p>  如果出错, 请添加 debug log：</p>\n  <figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jboss-cli\">acme.sh <span class=\"hljs-params\">--issue</span>  <span class=\"hljs-string\">.....</span>  <span class=\"hljs-params\">--debug</span> <br></code></pre></td></tr></table></figure>\n\n<p>  或者：</p>\n  <figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jboss-cli\">acme.sh <span class=\"hljs-params\">--issue</span>  <span class=\"hljs-string\">.....</span>  <span class=\"hljs-params\">--debug</span>  2<br></code></pre></td></tr></table></figure>\n\n<p>  请参考： <a href=\"https://github.com/Neilpang/acme.sh/wiki/How-to-debug-acme.sh\">https://github.com/Neilpang/acme.sh/wiki/How-to-debug-acme.sh</a></p>\n<p>  最后, 本文并非完全的使用说明, 还有很多高级的功能, 更高级的用法请参看其他 wiki 页面.</p>\n<p>  <a href=\"https://github.com/Neilpang/acme.sh/wiki\">https://github.com/Neilpang/acme.sh/wiki</a></p>\n</blockquote>\n<h2 id=\"Docker\"><a href=\"#Docker\" class=\"headerlink\" title=\"Docker\"></a>Docker</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker run --rm  -itd  \\<br>  -v &quot;$(pwd)/out&quot;:/acme.sh  \\<br>  -e Ali_Key=&quot;xxxxxx&quot; \\<br>  -e Ali_Secret=&quot;xxxx&quot; \\<br>  neilpang/acme.sh  --issue --dns dns_ali -d domain.cn -d *.domain.cn<br></code></pre></td></tr></table></figure>\n\n<p>详细用法，可以参考：<a href=\"https://github.com/Neilpang/acme.sh/wiki/Run-acme.sh-in-docker\">传送门</a></p>\n<blockquote>\n<h1 id=\"acme-sh-💕-docker\"><a href=\"#acme-sh-💕-docker\" class=\"headerlink\" title=\"acme.sh 💕 docker\"></a>acme.sh 💕 docker</h1><p>  作为 docker 的忠实粉丝之一，我知道我们讨厌在 docker 主机上安装任何东西，即使它只是复制一个 shell 脚本。</p>\n<p>  用于 letsencrypt ssl 证书的带有 acme.sh 的自动化 nginx 反向代理 docker 图像： https: <a href=\"https://github.com/Neilpang/letsproxy\">&#x2F;&#x2F;github.com&#x2F;Neilpang&#x2F;letsproxy</a></p>\n<p>  部署到 docker 容器并重新加载它：<a href=\"https://github.com/Neilpang/acme.sh/wiki/deploy-to-docker-containers\">https :&#x2F;&#x2F;github.com&#x2F;Neilpang&#x2F;acme.sh&#x2F;wiki&#x2F;deploy-to-docker-containers</a></p>\n<p>  所以，这里出现了“docker 中的 acme.sh”。</p>\n<ol>\n<li>基于<strong>alpine</strong>，只有 5MB 大小。</li>\n<li>作为可执行文件运行或作为守护进程运行</li>\n<li>支持所有命令行参数。</li>\n</ol>\n<h1 id=\"1-说“Hello-World”\"><a href=\"#1-说“Hello-World”\" class=\"headerlink\" title=\"1.说“Hello World”\"></a>1.说“Hello World”</h1>  <figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dockerfile\">docker <span class=\"hljs-keyword\">run</span><span class=\"language-bash\"> --<span class=\"hljs-built_in\">rm</span> neilpang/acme.sh</span><br></code></pre></td></tr></table></figure>\n\n<h1 id=\"2-用作可执行文件：\"><a href=\"#2-用作可执行文件：\" class=\"headerlink\" title=\"2.用作可执行文件：\"></a>2.用作可执行文件：</h1>  <figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">docker run <span class=\"hljs-attr\">--rm</span>  -it  \\<br>  -v <span class=\"hljs-string\">&quot;$(pwd)/out&quot;</span>:/acme<span class=\"hljs-selector-class\">.sh</span>  \\<br>  <span class=\"hljs-attr\">--net</span>=host \\<br>  neilpang/acme<span class=\"hljs-selector-class\">.sh</span>  <span class=\"hljs-attr\">--issue</span> -d example<span class=\"hljs-selector-class\">.com</span>  <span class=\"hljs-attr\">--standalone</span><br></code></pre></td></tr></table></figure>\n\n<p>  您可以在此处使用<strong>acme.sh</strong>支持的<strong>任何命令</strong>，其他示例：</p>\n  <figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-selector-id\">#revoke</span> <span class=\"hljs-selector-tag\">a</span> cert<br>docker run <span class=\"hljs-attr\">--rm</span>  -it  \\<br>  -v <span class=\"hljs-string\">&quot;$(pwd)/out&quot;</span>:/acme<span class=\"hljs-selector-class\">.sh</span>  \\<br>  <span class=\"hljs-attr\">--net</span>=host \\<br>  neilpang/acme<span class=\"hljs-selector-class\">.sh</span>  <span class=\"hljs-attr\">--revoke</span> -d example<span class=\"hljs-selector-class\">.com</span><br><span class=\"hljs-selector-id\">#use</span> dns mode<br>docker run <span class=\"hljs-attr\">--rm</span>  -it  \\<br>  -v <span class=\"hljs-string\">&quot;$(pwd)/out&quot;</span>:/acme<span class=\"hljs-selector-class\">.sh</span>  \\<br>  neilpang/acme<span class=\"hljs-selector-class\">.sh</span>  <span class=\"hljs-attr\">--issue</span> <span class=\"hljs-attr\">--dns</span> -d example<span class=\"hljs-selector-class\">.com</span><br><span class=\"hljs-selector-id\">#run</span> cron job<br>docker run <span class=\"hljs-attr\">--rm</span>  -it  \\<br>  -v <span class=\"hljs-string\">&quot;$(pwd)/out&quot;</span>:/acme<span class=\"hljs-selector-class\">.sh</span>  \\<br>  <span class=\"hljs-attr\">--net</span>=host \\<br>  neilpang/acme<span class=\"hljs-selector-class\">.sh</span>  <span class=\"hljs-attr\">--cron</span><br></code></pre></td></tr></table></figure>\n\n<p>  无论如何，您可以像调用真正的 shell 脚本一样调用<strong>neilpang&#x2F;acme.sh。</strong></p>\n<h1 id=\"3-将-acme-sh-作为-docker-守护进程运行。\"><a href=\"#3-将-acme-sh-作为-docker-守护进程运行。\" class=\"headerlink\" title=\"3. 将 acme.sh 作为 docker 守护进程运行。\"></a>3. 将 acme.sh 作为 docker 守护进程运行。</h1><ol>\n<li>将 acme.sh 作为 docker 守护进程运行，以便它可以自动处理更新 cronjob。</li>\n</ol>\n  <figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">docker <span class=\"hljs-built_in\">run</span> --rm  -itd  \\<br>  -v <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$(pwd)</span>/out&quot;</span>:/acme.sh  \\<br>  <span class=\"hljs-attribute\">--net</span>=host \\<br>  <span class=\"hljs-attribute\">--name</span>=acme.sh \\<br>  neilpang/acme.sh daemon<br></code></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>然后你就可以使用<code>docker exec</code>来执行任何acme.sh 命令了。</li>\n</ol>\n  <figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">docker  exec  acme<span class=\"hljs-selector-class\">.sh</span> <span class=\"hljs-attr\">--help</span><br>docker  exec  acme<span class=\"hljs-selector-class\">.sh</span> <span class=\"hljs-attr\">--issue</span> -d example<span class=\"hljs-selector-class\">.com</span>  <span class=\"hljs-attr\">--standalone</span><br></code></pre></td></tr></table></figure>\n\n<p>  是的，再次强调，您可以在此处使用<strong>acme.sh</strong>支持的<strong>任何命令</strong>。</p>\n</blockquote>\n<h2 id=\"Certbot\"><a href=\"#Certbot\" class=\"headerlink\" title=\"Certbot\"></a>Certbot</h2><p><a href=\"https://certbot.eff.org/\">https://certbot.eff.org/</a></p>\n",
            "tags": [
                "ssl",
                "https"
            ]
        },
        {
            "id": "https://www.oikiou.top/2022/d911b12b/",
            "url": "https://www.oikiou.top/2022/d911b12b/",
            "title": "Zsh 安装 配置",
            "date_published": "2022-12-12T14:57:15.000Z",
            "content_html": "<h1 id=\"zsh\"><a href=\"#zsh\" class=\"headerlink\" title=\"zsh\"></a>zsh</h1><p><strong>Zsh</strong>是一个为交互使用而设计的shell，它也是一种强大的脚本语言。<em>bash</em>、ksh 和 <em>tcsh</em> 的许多有用特性都被合并到 <em>zsh</em> 中; 添加了许多原始功能。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">Ubuntu</span> <br>sudo apt-get install zsh<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>  zsh非常强大，同时它的配置也是较为繁杂，所以我们使用“oh my zsh”这个框架来简化我们的配置流程。</p>\n</blockquote>\n<p><code>cat /etc/shells</code> 查看当前系统有哪些shell版本<br><code>echo @SHELL</code> 查看当前使用的shell版本</p>\n<p>安装完成后会在<code>~</code>目录下产生一个<code>.zshrc</code>这个跟<code>.bashrc</code>是一样的文件，只是配置的对象不一样。<code>rc</code>就是启动的意思，启动zsh读取的配置就是这个文件。</p>\n<h1 id=\"Oh-My-Zsh\"><a href=\"#Oh-My-Zsh\" class=\"headerlink\" title=\"Oh My Zsh\"></a>Oh My Zsh</h1><p><a href=\"https://ohmyz.sh/\">官网</a></p>\n<p>Oh My Zsh 是一个令人愉快的、开源的、社区驱动的框架，用于管理你的 Zsh 配置。它捆绑了数千个有用的功能、助手、插件、主题和一些东西 让你大喊大叫… “Oh My ZSH!”</p>\n<h2 id=\"安装-1\"><a href=\"#安装-1\" class=\"headerlink\" title=\"安装\"></a>安装</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">sh -c &quot;$(wget https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)&quot;<br></code></pre></td></tr></table></figure>\n\n<p>安装完成后发现<code>~</code>目录下会有一个<code>.oh-my-zsh</code>文件夹，文件夹内的一些文件主要用处</p>\n<ul>\n<li><code>themes</code> 一些主题文件</li>\n<li><code>plugins</code> 插件，我们的插件就下载放在这个文件夹里面</li>\n</ul>\n<p>Powerlevel10k 是用于 Zsh 美化的一个非常酷的主题，它强调速度、 灵活性和开箱即用的体验。</p>\n<h2 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h2><h3 id=\"zsh-syntax-highlighting-语法高亮\"><a href=\"#zsh-syntax-highlighting-语法高亮\" class=\"headerlink\" title=\"zsh-syntax-highlighting 语法高亮\"></a>zsh-syntax-highlighting 语法高亮</h3><p>插件功能：这个包为<code>shell zsh</code>提供语法突出显示。它允许高亮显示在<code>zsh</code>提示符下输入到交互式终端的命令。这有助于在运行命令之前检查它们，特别是在捕获语法错误方面。<br>例：在你输入某个命令时，如果该命令不存在，那么它显示为红色；否则，它会变成绿色。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting<br></code></pre></td></tr></table></figure>\n\n<p>将 <code>zsh-syntax-highlighting</code> 添加到 <code>~/.zshrc</code> 中</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">plugins=(--other-- zsh-syntax-highlighting)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"zsh-autosuggestions-自动补全\"><a href=\"#zsh-autosuggestions-自动补全\" class=\"headerlink\" title=\"zsh-autosuggestions 自动补全\"></a>zsh-autosuggestions 自动补全</h3><p>插件功能：输入命令时可提示自动补全（灰色部分），按tab键（→ ）即可补全。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions<br></code></pre></td></tr></table></figure>\n\n<p>将 <code>zsh-autosuggestions</code> 添加到 <code>~/.zshrc</code> 中</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\"><span class=\"hljs-attribute\">plugins</span><span class=\"hljs-operator\">=</span>(--other-- zsh-autosuggestions)<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"Powerlevel10k\"><a href=\"#Powerlevel10k\" class=\"headerlink\" title=\"Powerlevel10k\"></a>Powerlevel10k</h1><p><a href=\"https://github.com/romkatv/powerlevel10k\">https://github.com/romkatv/powerlevel10k</a></p>\n<h2 id=\"安装-2\"><a href=\"#安装-2\" class=\"headerlink\" title=\"安装\"></a>安装</h2><h3 id=\"安装字体\"><a href=\"#安装字体\" class=\"headerlink\" title=\"安装字体\"></a>安装字体</h3><blockquote>\n<p>  powerlevel10k里面使用了很多的图标，而这些图标只有一些特定的字体才能显示，所以我们需要安装这些字体这样才能正常显示，我们称这些有很多图标的字体为<code>Nerd Fonts</code>。</p>\n</blockquote>\n<p>首先我们需要先安装一下字体，我们先下载官方推荐的<code>MesloLGS NF</code>字体来配置。</p>\n<ul>\n<li>Download these four ttf files:<ul>\n<li>[MesloLGS NF Regular.ttf](<a href=\"https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS\">https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS</a> NF Regular.ttf)</li>\n<li>[MesloLGS NF Bold.ttf](<a href=\"https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS\">https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS</a> NF Bold.ttf)</li>\n<li>[MesloLGS NF Italic.ttf](<a href=\"https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS\">https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS</a> NF Italic.ttf)</li>\n<li>[MesloLGS NF Bold Italic.ttf](<a href=\"https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS\">https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS</a> NF Bold Italic.ttf)</li>\n</ul>\n</li>\n<li>Double-click on each file and click “Install”. This will make <code>MesloLGS NF</code> font available to all applications on your system.</li>\n</ul>\n<blockquote>\n<p>  我们如果是在ssh配置远程主机的时候，是在本地的主机上安装这个字体。</p>\n<p>  字体影响的是显示，ssh显示是在本地渲染的，所以肯定是在本地主机上安装字体。</p>\n</blockquote>\n<h4 id=\"其他的Nerd-Fonts字体\"><a href=\"#其他的Nerd-Fonts字体\" class=\"headerlink\" title=\"其他的Nerd Fonts字体\"></a>其他的<code>Nerd Fonts</code>字体</h4><p><a href=\"https://github.com/ryanoasis/nerd-fonts\">https://github.com/ryanoasis/nerd-fonts</a></p>\n<p>我们可以在这里下载一些打过补丁的热门字体。</p>\n<h3 id=\"安装Powerlevel10k\"><a href=\"#安装Powerlevel10k\" class=\"headerlink\" title=\"安装Powerlevel10k\"></a>安装Powerlevel10k</h3><p>官方的README文档提出了几种安装方式，它推荐使用手动安装方式。</p>\n<h4 id=\"Manual\"><a href=\"#Manual\" class=\"headerlink\" title=\"Manual\"></a>Manual</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ~/powerlevel10k<br>echo &#x27;source ~/powerlevel10k/powerlevel10k.zsh-theme&#x27; &gt;&gt;~/.zshrc<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"Oh-My-Zsh-1\"><a href=\"#Oh-My-Zsh-1\" class=\"headerlink\" title=\"Oh My Zsh\"></a>Oh My Zsh</h4><ol>\n<li><p>Clone the repository:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">git clone --depth=1 https://github.com/romkatv/powerlevel10k.git $&#123;ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom&#125;/themes/powerlevel10k<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>在<code>~/.zshrc</code>文件中，设置<code>ZSH_THEME=&quot;powerlevel10k/powerlevel10k&quot;</code></p>\n</li>\n</ol>\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p>安装好后我们启动zsh，在zsh环境下输入<code>p10k configure</code>用于配置p10k</p>\n<blockquote>\n<p>  这一步我在<code>MobaXterm</code>下进行，发现可配置的选项缺失很多，后面在<code>Windows Terminal</code>重新配置发现显示是正常的。</p>\n<p>  <code>MobaXterm</code>下<code>Fira Code</code>字体似乎显示也有些问题，<code>MesloLGS NF</code>就是正常的。</p>\n</blockquote>\n",
            "tags": [
                "linux",
                "zsh",
                "shell"
            ]
        },
        {
            "id": "https://www.oikiou.top/2022/4dd4ea8a/",
            "url": "https://www.oikiou.top/2022/4dd4ea8a/",
            "title": "Ip 转换成 Location 的Api",
            "date_published": "2022-11-08T15:24:15.000Z",
            "content_html": "<h1 id=\"ip-to-location\"><a href=\"#ip-to-location\" class=\"headerlink\" title=\"ip to location\"></a>ip to location</h1><h2 id=\"ipwhois\"><a href=\"#ipwhois\" class=\"headerlink\" title=\"ipwhois\"></a>ipwhois</h2><p>IPWHOIS.IO的IP地理定位API的URL格式很简单。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">http://ipwhois.app/json/&#123;IP&#125;<br></code></pre></td></tr></table></figure>\n\n<p>例如，我们可以用以下IP地址发出API请求：47.9.123.84。</p>\n<p><img src=\"/2022/4dd4ea8a/ipwhois-api.png\" alt=\"img\"></p>\n<p><strong>参考链接:</strong></p>\n<ul>\n<li><a href=\"https://webdamn.com/ip-geolocation-api/\">IP Geolocation API – IPWHOIS.IO</a></li>\n<li><a href=\"https://webdamn.com/how-to-integrate-ip-geolocation-api-with-php/\">How to Integrate IP Geolocation API with PHP</a></li>\n<li><a href=\"https://webdamn.com/scrape-search-result-data-using-serpapi-with-python/\">Scrape Search Result Data using SerpApi with Python</a></li>\n<li><a href=\"https://webdamn.com/get-geocoding-using-positionstack-api-with-php/\">Get Geocoding using Positionstack API with PHP</a></li>\n<li><a href=\"https://webdamn.com/flight-data-using-aviationstack-api-with-php/\">Flight Data using Aviationstack API with PHP</a></li>\n<li><a href=\"https://webdamn.com/get-address-information-using-geocode-api-with-php/\">Get Address Information using Geocode API with PHP</a></li>\n<li><a href=\"https://webdamn.com/review-scraping-using-reviewapi-with-php/\">Review Scraping using ReviewAPI with PHP</a></li>\n<li><a href=\"https://webdamn.com/simple-web-scraping-with-zenscrape-api-using-php/\">Simple Web Scraping with Zenscrape API using PHP</a></li>\n<li><a href=\"https://webdamn.com/scrape-search-result-with-zenserp-api-using-php/\">Scrape Search Result with Zenserp API using PHP</a></li>\n<li><a href=\"https://webdamn.com/build-user-agent-lookup-system-using-userstack-api-with-php/\">Build User Agent Lookup System using Userstack API with PHP</a></li>\n<li><a href=\"https://webdamn.com/build-ip-lookup-website-using-ipapi-with-php/\">Build IP Lookup Website using ipapi with PHP</a></li>\n<li><a href=\"https://webdamn.com/build-weather-website-with-weatherstack-api-using-php/\">Build Weather Website with Weatherstack API using PHP</a></li>\n<li><a href=\"https://webdamn.com/get-website-visitors-info-using-ipstack-api-with-php/\">Get Website Visitors Info using IPStack API with PHP</a></li>\n<li><a href=\"https://webdamn.com/scrape-serp-data-using-serpstack-api-with-python/\">Scrape SERP Data using SerpStack API with Python</a></li>\n</ul>\n",
            "tags": [
                "ip",
                "location",
                "api"
            ]
        },
        {
            "id": "https://www.oikiou.top/2022/3db44d04/",
            "url": "https://www.oikiou.top/2022/3db44d04/",
            "title": "Android 文件传输模式 电脑无法识别",
            "date_published": "2022-10-10T14:57:15.000Z",
            "content_html": "<h1 id=\"android-文件传输模式-电脑无法识别\"><a href=\"#android-文件传输模式-电脑无法识别\" class=\"headerlink\" title=\"android 文件传输模式 电脑无法识别\"></a>android 文件传输模式 电脑无法识别</h1><p>最近android手机连接电脑选择传输文件模式，电脑不再识别手机。选择照片模式就没有问题。</p>\n<p>手机选择文件传输模式后 选择自动搜索驱动程序 安装后会 提示“这个inf中的服务安装段落无效”。</p>\n<h2 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h2><ol>\n<li><p>按“Win+X” 点击 “设备管理器”</p>\n</li>\n<li><p>在设备管理器中找到你的手机，名字可能是你的手机型号，可能是未知设备 ，</p>\n</li>\n<li><p>右键选择更新驱动程序.</p>\n</li>\n<li><p>选择 “浏览计算机以查找驱动程序软件”</p>\n</li>\n<li><p>选择 “让我从计算机上的可用驱动程序列表中选取”</p>\n</li>\n<li><p>在列表里面找到“便携设备” (可能没有这一步操作)</p>\n</li>\n<li><p>选择 “MTP USB 设备”</p>\n<p><img src=\"/2022/3db44d04/1636599848857.png\" alt=\"win10系统识别不了USB设备解决方法介绍-Win10系统识别不了USB设备怎么办-53系统之家\"></p>\n</li>\n<li><p>点击 “下一步”</p>\n</li>\n<li><p>回到设备管理器看到设备已经可用正确运作了</p>\n</li>\n</ol>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://developer.android.com/studio/run/oem-usb\">安装原始设备制造商 (OEM) USB 驱动程序</a></p>\n<p><a href=\"https://developer.android.com/studio/run/win-usb\">获取 Google USB 驱动程序</a></p>\n",
            "tags": [
                "pc",
                "windows",
                "android",
                "mtp",
                "driver"
            ]
        },
        {
            "id": "https://www.oikiou.top/2022/bc4a75ff/",
            "url": "https://www.oikiou.top/2022/bc4a75ff/",
            "title": "JPEG JPEG2000 WebP PNG GIF对比",
            "date_published": "2022-09-18T05:47:15.000Z",
            "content_html": "<h1 id=\"图像的显示原理\"><a href=\"#图像的显示原理\" class=\"headerlink\" title=\"图像的显示原理\"></a>图像的显示原理</h1><h2 id=\"有损-x2F-无损压缩\"><a href=\"#有损-x2F-无损压缩\" class=\"headerlink\" title=\"有损&#x2F;无损压缩\"></a>有损&#x2F;无损压缩</h2><p>图片文件格式有可能会对图片的文件大小进行不同程度的压缩，图片的压缩分为有损压缩和无损压缩两种。</p>\n<h3 id=\"有损压缩\"><a href=\"#有损压缩\" class=\"headerlink\" title=\"有损压缩\"></a>有损压缩</h3><p>对图像本身的改变，在保存图像时保留了较多的亮度信息，而将色相和色纯度的信息和周围的像素进行合并，合并的比例不同，压缩的比例也不同，由于信息量减少了，所以压缩比可以很高，图像质量也会相应的下降。并且这种损失是不可逆的，我们不可能从有一个有损压缩过的图片中恢复出全来的图片。常见的有损压缩手段，是按照一定的算法将临近的像素点进行合并。<br><strong>有损压缩的原理：</strong> <em>删除景物边缘的某些颜色部分，当人们在屏幕上观看这个场景图片，大脑会利用在景物上看到的颜色填补所丢失的颜色部分。</em><br><strong>有损压缩的优缺点：</strong> <em>是保持颜色的逐渐变化，删除图像中颜色的突然变化。生物学中的大量实验证明，人类大脑会利用与附近最接近的颜色来填补所丢失的颜色。例如，对于蓝色天空背景上的一朵白云，有损压缩的方法就是删除图像中景物边缘的某些颜色部分。当在·屏幕上看这幅图时，大脑会利用在景物上看到的颜色填补所丢失的颜色部分。利用有损压缩技术，某些数据被有意地删除了，而被取消的数据也不再恢复。 无可否认，利用有损压缩技术可以大大地压缩文件的数据，但是会影响图像质量。如果使用了有损压缩的图像仅在屏幕上显示，可能对图像质量影响不太大，至少对于人类眼睛的识别程度来说区别不大。可是，如果要把一幅经过有损压缩技术处理的图像用高分辨率打印机打印出来，那么图像质量就会有明显的受损痕迹。</em></p>\n<h3 id=\"无损压缩\"><a href=\"#无损压缩\" class=\"headerlink\" title=\"无损压缩\"></a>无损压缩</h3><p>无损压缩的基本原理是相同的颜色信息只需保存一次。压缩图像的软件首先会确定图像中哪些区域是相同的，哪些是不同的。包括了重复数据的图像(如蓝天) 就可以被压缩，只有蓝天的起始点和终结点需要被记录下来。但是蓝色可能还会有不同的深浅，天空有时也可能被树木、山峰或其他的对象掩盖，这些就需要另外记录。从本质上看，无损压缩的方法可以删除一些重复数据，大大减少要在磁盘上保存的图像尺寸。但是，无损压缩的方法并不能减少图像的内存占用量，这是因为，当从磁盘上读取图像时，软件又会把丢失的像素用适当的颜色信息填充进来。如果要减少图像占用内存的容量，就必须使用有损压缩方法。<br><strong>无损压缩的特点：</strong> <em>相同的颜色信息只需保存一次。</em><br><strong>无损压缩的原理：</strong> <em>首先辨别出相同颜色的区域，然后把这些相同的数据信息进行压缩记录，也就是记录它的颜色信息、起始和终止位置。</em></p>\n<h2 id=\"索引色-x2F-直接色\"><a href=\"#索引色-x2F-直接色\" class=\"headerlink\" title=\"索引色&#x2F;直接色\"></a>索引色&#x2F;直接色</h2><p>计算机在表示颜色的时候，有两种形式，一种称作索引颜色(Index Color)，一种称作直接颜色(Direct Color)。</p>\n<h3 id=\"索引色。\"><a href=\"#索引色。\" class=\"headerlink\" title=\"索引色。\"></a>索引色。</h3><p>是一种以有限的方式管理数字图像颜色的技术，以节省计算机内存和文件存储，同时加速显示刷新和文件传输。即用一个数字来代表（索引）一种颜色，在存储图片的时候，存储一个数字的组合，同时存储数字到图片颜色的映射。这种方式只能存储有限种颜色，通常是256种颜色，对应到计算机系统中，使用一个字节的数字来索引一种颜色。</p>\n<h3 id=\"直接色。\"><a href=\"#直接色。\" class=\"headerlink\" title=\"直接色。\"></a>直接色。</h3><p>使用四个数字来代表一种颜色，这四个数字分别代表这个颜色中红色、绿色、蓝色以及透明度（即rgba）。现在流行的显示设备可以在这四个维度分别支持256种变化，所以直接色可以表示2的32次方种颜色。当然并非所有的直接色都支持这么多种，为压缩空间使用，有可能只有表达红、绿、蓝的三个数字，每个数字也可能不支持256种变化之多</p>\n<h2 id=\"位图-x2F-矢量图\"><a href=\"#位图-x2F-矢量图\" class=\"headerlink\" title=\"位图&#x2F;矢量图\"></a>位图&#x2F;矢量图</h2><h3 id=\"位图。\"><a href=\"#位图。\" class=\"headerlink\" title=\"位图。\"></a>位图。</h3><p>位图也叫做点阵图，栅格图像，像素图。简单的说，就是最小单位由像素构成的图，缩放会失真。构成位图的最小单位是像素，位图就是由像素阵列的排列来实现其显示效果的，每个像素有自己的颜色信息，在对位图图像进行编辑操作的时候，可操作的对象是每个像素，我们可以改变图像的色相、饱和度、明度，从而改变图像的显示效果。举个例子来说，位图图像就好比在巨大的沙盘上画好的画，当你从远处看的时候，画面细腻多彩，但是当你靠的非常近的时候，你就能看到组成画面的每粒沙子以及每个沙粒单纯的不可变化颜色。</p>\n<h3 id=\"矢量图，\"><a href=\"#矢量图，\" class=\"headerlink\" title=\"矢量图，\"></a>矢量图，</h3><p>也叫做向量图。矢量图并不纪录画面上每一点的信息，而是纪录了元素形状及颜色的算法，当你打开一付矢量图的时候，软件对图形象对应的函数进行运算，将运算结果[图形的形状和颜色]显示给你看。无论显示画面是大还是小，画面上的对象对应的算法是不变的，所以，即使对画面进行倍数相当大的缩放，其显示效果仍然相同(不失真)。</p>\n<h1 id=\"JPEG-JPEG2000-WebP\"><a href=\"#JPEG-JPEG2000-WebP\" class=\"headerlink\" title=\"JPEG JPEG2000 WebP\"></a>JPEG JPEG2000 WebP</h1><blockquote>\n<p>  摘录自知乎: </p>\n<p>  原文: <a href=\"https://zhuanlan.zhihu.com/p/19586108\">https://zhuanlan.zhihu.com/p/19586108</a></p>\n<p>  作者: <a href=\"https://www.zhihu.com/people/xhacker\">柳东原</a> This Xhacker has super Big Cat power.</p>\n</blockquote>\n<p><strong>压缩性能综合看来，WebP 略好于 JPEG2000，而这两者都明显好于 JPEG。</strong></p>\n<p>前段时间测试了一下这三种有损图像压缩算法的质量。（WebP 也能支持无损，不过这里只测试有损。）</p>\n<p>测试结果（<a href=\"https://link.zhihu.com/?target=http://en.wikipedia.org/wiki/Structural_similarity\">SSIM Index</a> 可理解为图片与原图片的相似度）：</p>\n<p><img src=\"/2022/bc4a75ff/6dd37790364b1a5e709f8e67adab81d3_r.jpg\" alt=\"img\"></p>\n<p><img src=\"/2022/bc4a75ff/868c8f801447ee85c0867556cdb1f705_r.jpg\" alt=\"img\"></p>\n<p><img src=\"/2022/bc4a75ff/85ab2ef874126a10072e4669d9cd7c90_720w.jpg\" alt=\"img\"></p>\n<p><img src=\"/2022/bc4a75ff/ea62d92a63b45aa121eb0ccfce4a97fd_720w.jpg\" alt=\"img\"></p>\n<p><img src=\"/2022/bc4a75ff/6cdab6a9efdf3df3fba2657314d81734_720w.jpg\" alt=\"img\"></p>\n<p><img src=\"/2022/bc4a75ff/323465387e562470441127b8f0cc992e_720w.jpg\" alt=\"img\"></p>\n<p>测试细节：对于 JPEG 使用 libjpeg 压缩，JPEG 2000 使用 OpenJPEG，WebP 使用 libwebp。</p>\n<h1 id=\"JPEG-PNG-GIF-WEBP\"><a href=\"#JPEG-PNG-GIF-WEBP\" class=\"headerlink\" title=\"JPEG PNG GIF WEBP\"></a>JPEG PNG GIF WEBP</h1><p><strong>综合看来</strong></p>\n<ul>\n<li>PNG 可以保存透明信息, 比较适合颜色单一, 主要是纯色的图像, ( logo&#x2F;icon&#x2F;透明图 )</li>\n<li>JPEG 适用颜色种类多样 且颜色变化明显的图片 ( 一般照片 )</li>\n<li>GIF 支持动画,透明, 只有8位颜色 ( 动图 )</li>\n<li>WEBP 文件小, 支持透明, 有损无损压缩, 支持动画, 兼容性不好 ( 网页图像 )</li>\n</ul>\n<h2 id=\"JPEG\"><a href=\"#JPEG\" class=\"headerlink\" title=\"JPEG\"></a>JPEG</h2><p>JPEG是有损的、采用直接色的、位图。JPEG也是一种针对照片影像而广泛使用的有损压缩标准方法。JPEG图片格式的设计目标，是在不影响人类可分辨的图片质量的前提下，尽可能的压缩文件大小。这意味着JPEG去掉了一部分图片的原始信息，也即是进行了有损压缩。JPEG的图片的优点，是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，用来表达更生动的图像效果，比如颜色渐变。</p>\n<ul>\n<li>特性：适用于存储色彩丰富、层次分明的图片，不适合于线条绘图（drawing）和其他文字或图标（iconic）的图形，因为它的压缩方法用在这些类型的图形上，得到的结果并不好(PNG和GIF通常是用来存储这类的图形)</li>\n</ul>\n<h2 id=\"PNG\"><a href=\"#PNG\" class=\"headerlink\" title=\"PNG\"></a>PNG</h2><p>便携式网络图形是一种无损压缩的位图图形格式，支持索引、灰度、RGB三种颜色方案以及Alpha通道等特性</p>\n<ul>\n<li>特性：如果保存文本，线条或类似的边缘清晰，有大块相同颜色区域的图像，PNG格式的压缩效果就要比JPEG好很多，并且不会出现JPEG那样的高对比度区域的图像有损。如果图像既有清晰边缘，又有照片图像的特点，就需要在这两种格式之间权衡一下了。JPEG不支持透明度。<br>PNG格式有8位、24位、32位三种形式,其中8位PNG支持两种不同 的透明形式（索引透明和alpha透明）,24位PNG不支持透明,32位 PNG 在24位基础上增加了8位透明通道（32-24&#x3D;&#x3D;&#x3D;8）,因此可展现256级透明程度。</li>\n</ul>\n<h3 id=\"PNG8\"><a href=\"#PNG8\" class=\"headerlink\" title=\"PNG8\"></a>PNG8</h3><p>PNG8是<strong>无损的、使用索引色的、点阵图</strong>,支持不透明、索引透明、Alpha透明，都最多只能展示256（2的8次方）种颜色，所以“PNG8”格式更适合那些颜色比较单一的图像，例如纯色、logo、图标等；因为颜色数量少，所以图片的体积也会更小；</p>\n<ul>\n<li><p>PNG8(不透明),默认PNG8</p>\n</li>\n<li><p>PNG8(索引色透明),简单说可以理解为静态的GIF<br>指定一个像素点是不是透明<br>但是PNG由于算法的优势,体积比较少<br>所以,静态GIF完全可用PNG8取代</p>\n</li>\n<li><p>PNG8(Alpha透明),牛逼在可指定像素点的透明度,例如50%透明度<br>这种优点在于比PNG24&#x2F;32体积小,因为也只有256色嘛<br>缺点在于IE6支持不好,会把半透明的像素点显示成全透明</p>\n</li>\n</ul>\n<h3 id=\"PNG24\"><a href=\"#PNG24\" class=\"headerlink\" title=\"PNG24\"></a>PNG24</h3><p>是PNG的直接色版本。PNG24是<strong>无损的、使用直接色的、点阵图</strong>,支持2的24次方种颜色，表现为不透明。用三个8bits分别去表示 R（红）、G（绿）、B（蓝）。R(0255),G(0255),B(0~255)，可以表达256乘以256乘以256&#x3D;16777216种颜色的图片，这样PNG24就能比PNG8表示色彩更丰富的图片,图片的清晰度也会更好，图片质量更高，当然图片的大小也会相应增加，所以“PNG24”的图片比较适合像摄影作品之类颜色比较丰富的图片<br>PNG24与JPG一样能表达丰富的图片细节，但并不能替代JPG。图片存储为PNG24比存储为JPG，文件大小至少是JPG的5倍，但在图片品质上的提升却微乎其微。所以除非对品质的要求极高，否则色彩丰富的网络图片还是推荐使用JPG</p>\n<h3 id=\"PNG32\"><a href=\"#PNG32\" class=\"headerlink\" title=\"PNG32\"></a>PNG32</h3><p>支持2的32次方种颜色，32位是我们最常使用的格式，它是在PNG在24位的PNG基础上增加了8位的透明信息，支持不同程度的半透效果</p>\n<h3 id=\"PNG8-PNG24-PNG32三者的区别在于：\"><a href=\"#PNG8-PNG24-PNG32三者的区别在于：\" class=\"headerlink\" title=\"PNG8\\PNG24\\PNG32三者的区别在于：\"></a>PNG8\\PNG24\\PNG32三者的区别在于：</h3><ul>\n<li>PNG-32每个像素的深度为32bits，其中RGBA四个通道各占8bits。所谓的RGBA四个通道，就是红，绿，蓝，透明 这四种色值各自的大小，都用8bits来表示（0～255）。</li>\n<li>PNG-24的像素深度为24bits，其中RGB三个通道各占8bits。</li>\n<li>PNG-8则是使用8位的索引色。</li>\n</ul>\n<h2 id=\"GIF\"><a href=\"#GIF\" class=\"headerlink\" title=\"GIF\"></a>GIF</h2><p>GIF是一种<strong>无损、使用于索引色的、位图</strong>。由于采用了无损压缩，相比古老的bmp格式，尺寸较小，而且支持透明和动画。缺点是由于gif只存储8位索引（也就是最多能表达2^8&#x3D;256种颜色），色彩复杂、细节丰富的图片不适合保存为gif格式。色彩简单的logo、icon、线框图适合采用gif格式。</p>\n<p>静态GIF完全可用PNG8取代</p>\n<h2 id=\"WEBP\"><a href=\"#WEBP\" class=\"headerlink\" title=\"WEBP\"></a>WEBP</h2><p>WebP图片是一种同时提供了<strong>有损压缩与无损压缩、使用直接色的、位图</strong>，由Google开发。与png、jpg相比，相同的视觉体验下，WebP图像的尺寸缩小了大约30％。另外，WebP图像格式还支持有损压缩、无损压缩、透明和动画。理论上完全可以替代png、jpg、gif等图片格式，当然目前webp的还没有得到全面的支持。</p>\n<p>WEBP与PNG压缩对比</p>\n<p><img src=\"/2022/bc4a75ff/formatpng.png\" alt=\"img\"></p>\n<p>可以得出结论：</p>\n<blockquote>\n<p>  PNG 转 WebP 的压缩率要高于 PNG 原图压缩率，同样支持有损与无损压缩<br>  转换后的 WebP 体积大幅减少，图片质量也得到保障（同时肉眼几乎无法看出差异）<br>  转换后的 WebP 支持 Alpha 透明和 24-bit 颜色数，不存在 PNG8 色彩不够丰富和在浏览器中可能会出现毛边的问题</p>\n</blockquote>\n",
            "tags": [
                "jpeg",
                "webp",
                "jpeg2000",
                "image"
            ]
        },
        {
            "id": "https://www.oikiou.top/2022/631793c8/",
            "url": "https://www.oikiou.top/2022/631793c8/",
            "title": "文件后缀与文件",
            "date_published": "2022-09-15T09:47:15.000Z",
            "content_html": "<h1 id=\"文件后缀与文件\"><a href=\"#文件后缀与文件\" class=\"headerlink\" title=\"文件后缀与文件\"></a>文件后缀与文件</h1><table>\n<thead>\n<tr>\n<th>后缀</th>\n<th>名称描述</th>\n<th>简述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>.DS_Store</code></td>\n<td>Desktop Services Store</td>\n<td>Mac OS X操作系统所创造的隐藏文件，类似<code>desktop.ini</code></td>\n</tr>\n</tbody></table>\n<h2 id=\"编辑历史\"><a href=\"#编辑历史\" class=\"headerlink\" title=\"编辑历史\"></a>编辑历史</h2><table>\n<thead>\n<tr>\n<th>date</th>\n<th>note</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>2022.9.15</td>\n<td>First Version</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"DS-Store\"><a href=\"#DS-Store\" class=\"headerlink\" title=\".DS_Store\"></a>.DS_Store</h2><blockquote>\n<p>  DS_Store，英文全称是 Desktop Services Store（桌面服务存储），开头的 DS 是 Desktop Services（桌面服务） 的缩写。它是一种由macOS系统自动创建的隐藏文件，存在于每一个用「Finder」打开过的文件夹下面。</p>\n<p>  <code>.DS_Store</code> 是一种由苹果公司的Mac OS X操作系统所创造的隐藏文件，目的在于存贮目录的自定义属性，例如文件们的图标位置或者是背景色的选择。该文件由<code>Finder</code>创建并维护，类似于<code>Microsoft Windows</code>中的<code>desktop.ini</code>文件。</p>\n</blockquote>\n<h2 id=\"RTF\"><a href=\"#RTF\" class=\"headerlink\" title=\".RTF\"></a>.RTF</h2><blockquote>\n<p>  <strong>富文本格式</strong>（<strong>Rich Text Format</strong>）即<strong>RTF格式</strong>，又称<strong>多文本格式</strong>，是由<a href=\"https://zh.wikipedia.org/wiki/%E5%BE%AE%E8%BD%AF\">微软</a>公司开发的跨平台<a href=\"https://zh.wikipedia.org/wiki/%E6%96%87%E6%A1%A3\">文档</a>格式。大多数的<a href=\"https://zh.wikipedia.org/wiki/%E6%96%87%E5%AD%97%E5%A4%84%E7%90%86\">文字处理</a>软件都能读取和保存RTF文档。</p>\n<h2 id=\"支持软件\"><a href=\"#支持软件\" class=\"headerlink\" title=\"支持软件\"></a>支持软件</h2><ul>\n<li><a href=\"https://zh.wikipedia.org/wiki/WordPad\">WordPad</a>（<a href=\"https://zh.wikipedia.org/wiki/Microsoft_Windows\">Microsoft Windows</a>）&#x2F; <a href=\"https://zh.wikipedia.org/wiki/%E6%96%87%E5%AD%97%E7%B7%A8%E8%BC%AF_(%E6%87%89%E7%94%A8%E7%A8%8B%E5%BC%8F)\">文本编辑</a>（<a href=\"https://zh.wikipedia.org/wiki/Mac_OS\">Mac OS</a>）</li>\n<li><a href=\"https://zh.wikipedia.org/wiki/Microsoft_Word\">Microsoft Word</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/Apache_OpenOffice\">Apache OpenOffice</a> &#x2F; <a href=\"https://zh.wikipedia.org/wiki/LibreOffice\">LibreOffice</a></li>\n<li><a href=\"https://zh.wikipedia.org/zh-cn/WPS_Office\">WPS Office</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/EIOffice\">EIOffice</a></li>\n</ul>\n</blockquote>\n",
            "tags": [
                "DS_Store",
                "rtf",
                "后缀"
            ]
        },
        {
            "id": "https://www.oikiou.top/2022/613d8edd/",
            "url": "https://www.oikiou.top/2022/613d8edd/",
            "title": "Zip Gzip Bzip2 Tar 的区别和差异",
            "date_published": "2022-09-14T16:20:15.000Z",
            "content_html": "<h1 id=\"zip-gzip-bzip2-tar-命令的区别和差异\"><a href=\"#zip-gzip-bzip2-tar-命令的区别和差异\" class=\"headerlink\" title=\"zip gzip bzip2 tar 命令的区别和差异\"></a>zip gzip bzip2 tar 命令的区别和差异</h1><ul>\n<li><code>gzip</code> 和 <code>bzip2</code>用于压缩单个文件。bzip2 比 gzip 具有更高的压缩率，同样的也会需要<strong>更多更多更多</strong>时间来进行压缩。</li>\n<li><code>tar</code>格式的包只是将文件归档在一起, 并不会有任何压缩。</li>\n<li><code>zip</code> 和 <code>tar</code> 命令用于压缩和归档文件夹。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>zip</td>\n<td><code>.zip</code></td>\n<td>可以压缩目录</td>\n<td>源文件会保留</td>\n<td>专门的压缩命令</td>\n</tr>\n<tr>\n<td>gzip</td>\n<td><code>.gz</code></td>\n<td>只能压缩文件</td>\n<td>压缩后源文件会被删除</td>\n<td></td>\n</tr>\n<tr>\n<td>bzip2</td>\n<td><code>.bz2</code></td>\n<td>只能压缩文件</td>\n<td>加<code>-k</code>参数源文件可以保留</td>\n<td></td>\n</tr>\n<tr>\n<td>tar</td>\n<td><code>.tar</code></td>\n<td>可以压缩目录</td>\n<td>源文件会保留</td>\n<td>linux包大多是这形态<br>将目录打包成一个文件<code>Tape archive</code></td>\n</tr>\n<tr>\n<td>xz</td>\n<td><code>.xz</code></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"zip\"><a href=\"#zip\" class=\"headerlink\" title=\"zip\"></a>zip</h2><h2 id=\"gzip\"><a href=\"#gzip\" class=\"headerlink\" title=\"gzip\"></a>gzip</h2><p>该<code>gzip</code>程序用于压缩一个或多个文件。执行时，它将原始文件替换为原始文件的压缩版本。使用 gzip 压缩的文件具有扩展名<code>.gz</code></p>\n<h2 id=\"bzip2\"><a href=\"#bzip2\" class=\"headerlink\" title=\"bzip2\"></a>bzip2</h2><p>该<code>bzip2</code>命令类似于 gzip，但使用不同的压缩算法，以牺牲压缩速度为代价归档更高级别的压缩。使用 bzip2 压缩的文件具有扩展名<code>.bz2</code></p>\n<h2 id=\"tar\"><a href=\"#tar\" class=\"headerlink\" title=\"tar\"></a>tar</h2><p><code>tar</code>命令，首字母缩略词<em><strong>Tape archive</strong></em>用于创建存档文件。tar 存档可以由单独的文件、一个或多个目录层次结构或两者的混合组成。tar 文件有扩展名<code>.tar</code></p>\n<h2 id=\"xz\"><a href=\"#xz\" class=\"headerlink\" title=\"xz\"></a>xz</h2><p><code>xz</code>是一个通用的数据压缩工具，命令行语法类似于 gzip 和 bzip2 。它根据选择的操作模式压缩或解压缩每个文件。用 xz 压缩的文件具有扩展名<code>.xz</code></p>\n<h1 id=\"Zip-和-Unzip\"><a href=\"#Zip-和-Unzip\" class=\"headerlink\" title=\"Zip 和 Unzip\"></a>Zip 和 Unzip</h1><h2 id=\"zip-1\"><a href=\"#zip-1\" class=\"headerlink\" title=\"zip\"></a>zip</h2><p><strong>命令格式</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">zip [-r] [压缩后文件名] [文件或目录]<br></code></pre></td></tr></table></figure>\n\n<p><strong>命令描述</strong></p>\n<ul>\n<li><code>zip</code>命令用来对文件进行打包操作。zip是个使用广泛的压缩程序，文件经它压缩后会另外产生具有“.zip”扩展名的压缩文件；</li>\n<li>在linux压缩后的文件，基本都可以在Windows系统中解压；Windows中压缩的文件，在Linux中不一定可用，但是zip格式的压缩文件，可以做到可用；</li>\n<li>zip的压缩比不是很高；</li>\n</ul>\n<p><strong>示例</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 压缩文件</span><br>$ zip a.zip a.txt<br><span class=\"hljs-comment\"># 查看压缩后的文件</span><br>$ <span class=\"hljs-built_in\">ls</span><br>a.txt  a.zip  <br><br><span class=\"hljs-comment\"># 2. -r：压缩文件夹</span><br>$ zip -r test.zip testDir/<br>$ <span class=\"hljs-built_in\">ls</span><br>testDir  test.zip<br><br><span class=\"hljs-comment\"># 3. -x 排除文件</span><br>$ zip -r test2.zip testDir/ -x <span class=\"hljs-string\">&quot;testDir/hello*&quot;</span> -x <span class=\"hljs-string\">&quot;testDir/dir/*&quot;</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"unzip-解压\"><a href=\"#unzip-解压\" class=\"headerlink\" title=\"unzip 解压\"></a>unzip 解压</h2><p><strong>命令格式</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">unzip [选项] 文件名<br></code></pre></td></tr></table></figure>\n\n<p><strong>命令描述</strong></p>\n<p><code>unzip</code>命令用于解压缩由zip命令压缩的“.zip”压缩包。</p>\n<p><strong>选项</strong></p>\n<ul>\n<li>-n：解压缩时不要覆盖原有的文件；</li>\n<li>-o：不必先询问用户，unzip执行后覆盖原有的文件；</li>\n<li>-d &lt;目录&gt;：指定文件解压缩后所要存储的目录(不指定目录，默认解压到当前目录)</li>\n</ul>\n<p><strong>示例</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 解压文件到家目录</span><br>$ unzip test.zip -d ~<br></code></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"Gzip-和-Gunzip\"><a href=\"#Gzip-和-Gunzip\" class=\"headerlink\" title=\"Gzip 和 Gunzip\"></a>Gzip 和 Gunzip</h1><h2 id=\"gzip-1\"><a href=\"#gzip-1\" class=\"headerlink\" title=\"gzip\"></a><strong>gzip</strong></h2><p><strong>命令格式</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">gzip [文件]<br></code></pre></td></tr></table></figure>\n\n<p><strong>命令描述</strong></p>\n<p><code>gzip</code>命令 用来压缩文件。gzip是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多处“<code>.gz</code>”扩展名。<code>gzip</code>只能压缩文件，不能压缩文件夹，压缩后原文件会被删除</p>\n<p><code>gzip</code>是在Linux系统中经常使用的一个对文件进行压缩和解压缩的命令，既方便又好用。gzip不仅可以用来压缩大的、较少使用的文件以节省磁盘空间，还可以和tar命令一起构成Linux操作系统中比较流行的压缩文件格式。据统计，gzip命令对文本文件有60%～70%的压缩率。减少文件大小有两个明显的好处，一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间。</p>\n<p><strong>示例</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 压缩文件</span><br>$ gzip a.txt<br><span class=\"hljs-comment\"># 查看压缩后的文件，源文件被删除</span><br>$ <span class=\"hljs-built_in\">ls</span><br>a.txt.gz<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"gunzip-解压\"><a href=\"#gunzip-解压\" class=\"headerlink\" title=\"gunzip 解压\"></a>gunzip 解压</h2><p><strong>命令格式</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">gzip [文件]<br></code></pre></td></tr></table></figure>\n\n<p><strong>命令描述</strong></p>\n<p><code>gunzip</code>命令用来解压缩文件。gunzip是个使用广泛的解压缩程序，它用于解开被gzip压缩过的文件，这些压缩文件预设最后的扩展名为<code>.gz</code>。</p>\n<p><strong>示例</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 解压文件，解压后压缩文件被删除</span><br>$ gunzip a.txt.gz<br>$ <span class=\"hljs-built_in\">ls</span><br>a.txt <br></code></pre></td></tr></table></figure>\n\n<h1 id=\"Bzip2\"><a href=\"#Bzip2\" class=\"headerlink\" title=\"Bzip2\"></a>Bzip2</h1><h2 id=\"bzip2-1\"><a href=\"#bzip2-1\" class=\"headerlink\" title=\"bzip2\"></a>bzip2</h2><p><strong>命令格式</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">bzip2 [选项] [文件]<br></code></pre></td></tr></table></figure>\n\n<p><strong>命令描述</strong></p>\n<ul>\n<li>bzip2命令用于压缩“<code>.bz2</code>”格式的压缩包，是<code>gzip</code>的升级版本，可以保留原文件；</li>\n<li>bzip2的压缩比比较高，可用于压缩较大文件的压缩；</li>\n<li>bzip2也是只对文件进行压缩，如果相对目录进行压缩的话，可以配合 <code>tar</code>命令使用，使用 <code>tar -jcvf</code> 文件名 完成打包压缩。</li>\n</ul>\n<p><strong>选项</strong></p>\n<p>-k（keep）：保留原文件（不删除原文件）</p>\n<p><strong>示例</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># bzip2 压缩文件</span><br>$ bzip2 -k a.txt<br>$ <span class=\"hljs-built_in\">ls</span><br>a.txt  a.txt.bz2<br><br><span class=\"hljs-comment\"># 配合使用tar 命令，完成打包压缩</span><br>$ <span class=\"hljs-built_in\">mkdir</span> music<br>$ tar -jcvf music.tar.bz2 music/<br>$ <span class=\"hljs-built_in\">ls</span><br>music  music.tar.bz2<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"bunzip2-解压\"><a href=\"#bunzip2-解压\" class=\"headerlink\" title=\"bunzip2 解压\"></a>bunzip2 解压</h2><p><strong>命令格式</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">bunzip2 [选项] [文件]<br></code></pre></td></tr></table></figure>\n\n<p><strong>命令描述</strong></p>\n<ul>\n<li>解压缩“<code>.bz2</code>”格式的压缩文件；</li>\n<li>gunzip的升级版，可以使用<code>-k</code>保留原文件；</li>\n<li>可以配合使用tar命令，完成解压缩解包： <code>tar -jxvf 文件名</code></li>\n</ul>\n<p><strong>选项</strong></p>\n<p>-k（keep）：保留原文件（不删除原文件）</p>\n<p><strong>示例</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ <span class=\"hljs-built_in\">ls</span><br>a.txt.bz2  music.tar.bz2<br><br><span class=\"hljs-comment\"># 解压缩文件</span><br>$ bunzip2 -k a.txt.bz2<br>$ <span class=\"hljs-built_in\">ls</span><br>a.txt  a.txt.bz2  music.tar.bz2<br><br><span class=\"hljs-comment\"># 使用tar完成解压解包</span><br>$ tar -jxvf music.tar.bz2<br>$ <span class=\"hljs-built_in\">ls</span><br>a.txt  a.txt.bz2  music  music.tar.bz2<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"tar-1\"><a href=\"#tar-1\" class=\"headerlink\" title=\"tar\"></a>tar</h1><h2 id=\"tar-2\"><a href=\"#tar-2\" class=\"headerlink\" title=\"tar\"></a>tar</h2><p><strong>命令格式</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">tar [选项] [压缩后文件名] [目录]<br></code></pre></td></tr></table></figure>\n\n<p><strong>命令描述</strong></p>\n<p>打包目录，将目录打包成一个文件，同时可以压缩，压缩后的拓展名为<code>.tar.gz</code>，这个拓展名在下载Linux相关安装包时很常见。</p>\n<p>使用<code>tar</code>命令时，如果想要打包并压缩一个目录，可以有两种方法进行：</p>\n<ol>\n<li>先利用tar命令打包目录为一个文件，然后使用gzip压缩</li>\n<li>直接利用tar命令打包并压缩 (简单方便，推荐使用)</li>\n</ol>\n<p>解压时也有两种方式：</p>\n<ol>\n<li>先使用gunzip解压缩，再使用tar解包</li>\n<li>直接利用tar命令解压缩并解包 (简单方便，推荐使用)</li>\n</ol>\n<p><strong>选项</strong></p>\n<ul>\n<li>-c：打包(将所有文件变成一个文件 Create  a new archive)</li>\n<li>-x：解包</li>\n<li>-v：显示详细信息</li>\n<li>-f：指定文件名</li>\n<li>-z：打包同时压缩&#x2F;解压缩  ，gzip压缩</li>\n<li>-j：生成压缩文件 ，bzip2压缩</li>\n</ul>\n<p><strong>示例</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 压缩</span><br>tar -zcvf movie2.tar.gz movie<br><span class=\"hljs-comment\"># 解压</span><br>tar -zxvf movie2.tar.gz<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 1、2为    打包压缩    的两种方法</span><br><span class=\"hljs-comment\"># 1. 使用 tar -cvf 打包，然后使用gzip压缩</span><br>$ tar -cvf movie.tar movie/<br>$ <span class=\"hljs-built_in\">ls</span><br>movie  movie.tar<br>$ gzip movie.tar<br>$ <span class=\"hljs-built_in\">ls</span><br>movie  movie.tar.gz<br><br><span class=\"hljs-comment\"># 2. 使用 tar -zcvf 打包并压缩</span><br>$ tar -zcvf movie2.tar.gz movie<br>$ <span class=\"hljs-built_in\">ls</span><br>movie  movie2.tar.gz<br><br><span class=\"hljs-comment\"># 3、4为     解压缩并解包     的两种方法</span><br><span class=\"hljs-comment\"># 3. 先使用gunzip解压缩，然后 tar -xvf解包</span><br>$ gunzip movie.tar.gz<br>$ <span class=\"hljs-built_in\">ls</span><br>movie2.tar.gz  movie.tar<br>$ tar -xvf movie.tar<br>movie/<br>$ <span class=\"hljs-built_in\">ls</span><br>movie  movie2.tar.gz  movie.tar<br><br><span class=\"hljs-comment\"># 4. 使用tar -zxvf 解压缩并解包</span><br>$ tar -zxvf movie2.tar.gz<br>$ <span class=\"hljs-built_in\">ls</span><br>movie  movie2.tar.gz  movie.tar<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://techviewleo.com/compress-uncompress-files-tar-gzip-bzip2-xz-linux/\">LPIC 101 – Compress and Uncompress Files Using tar, gzip, bzip2 and xz on Linux</a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/List_of_archive_formats#Comparison\">List of archive formats</a></p>\n",
            "tags": [
                "zip",
                "gzip",
                "bzip",
                "tar"
            ]
        },
        {
            "id": "https://www.oikiou.top/2022/45a589a3/",
            "url": "https://www.oikiou.top/2022/45a589a3/",
            "title": "MD5",
            "date_published": "2022-09-14T14:57:15.000Z",
            "content_html": "<h1 id=\"MD5\"><a href=\"#MD5\" class=\"headerlink\" title=\"MD5\"></a>MD5</h1><p><strong>MD5消息摘要算法</strong>（英语：MD5 Message-Digest Algorithm），一种被广泛使用的<a href=\"https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A2%BC%E9%9B%9C%E6%B9%8A%E5%87%BD%E6%95%B8\">密码散列函数</a>，可以产生出一个128位（16个字符(BYTES)）的散列值（hash value），用于确保信息传输完整一致。将<a href=\"https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE\">数据</a>（如一段文字）运算变为另一固定长度值，是散列算法的基础原理。</p>\n<p><strong>参考</strong></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/121492822\">MD5破解的几种方法</a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/MD5\">Wiki MD5</a></p>\n<h1 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h1><ul>\n<li><p>不可逆向的</p>\n<blockquote>\n<p>  我们没办法把MD5码还原对应的原文。道理很简单，任意长度的数据经过MD5处理后，所包含的信息量已经大大减少，那是不可能再次还原成为原始信息的。</p>\n</blockquote>\n</li>\n<li><p>原文中作一个小变化其散列也会发生巨大的变化</p>\n<blockquote>\n  <figure class=\"highlight excel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs excel\"><span class=\"hljs-symbol\">MD5</span>(<span class=\"hljs-string\">&quot;The quick brown fox jumps over the lazy dog&quot;</span>)<br>= <span class=\"hljs-number\">9</span>e107d9d372bb6826bd81d3542a419d6<br></code></pre></td></tr></table></figure>\n\n<p>  比如用c取代d, 其MD5值发生了巨大的变化</p>\n  <figure class=\"highlight excel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs excel\"><span class=\"hljs-symbol\">MD5</span>(<span class=\"hljs-string\">&quot;The quick brown fox jumps over the lazy cog&quot;</span>)<br>= <span class=\"hljs-number\">1055</span>d3e698d289f2af8663725127bd4b<br></code></pre></td></tr></table></figure>\n</blockquote>\n</li>\n<li><p>已被破解</p>\n<blockquote>\n<p>  通俗点讲就是，可以找到一个A和一个B，使hash（A）&#x3D;hash（B），而真正有用的是给定一个A能得到B，使hash（A）&#x3D;hash（B），而王小云能做到这样</p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h1><p>MD5 摘要已在<a href=\"https://en.wikipedia.org/wiki/Software\">软件</a>世界中广泛使用，以确保传输的文件已完好无损地到达。例如，文件服务器通常会为文件提供预先计算的 MD5（称为<a href=\"https://en.wikipedia.org/wiki/Md5sum\">md5sum</a>）<a href=\"https://en.wikipedia.org/wiki/Checksum\">校验和</a>，以便用户可以将下载文件的校验和与其进行比较。</p>\n<p><img src=\"/2022/45a589a3/350px-CPT-Hashing-File-Transmission.png\" alt=\"350px-CPT-Hashing-File-Transmission.svg\"></p>\n<p>由于很容易产生 MD5 冲突，因此创建文件的人可能会创建具有相同校验和的第二个文件，因此该技术无法防止某些形式的恶意篡改。</p>\n<p>在某些情况下，校验和是不可信的（例如，如果它是通过与下载文件相同的渠道获得的，他人可能修改了文件后再次修改了MD5，使得MD5并不可信），在这种情况下，MD5 只能提供错误检查功能：“它会识别损坏或不完整的下载，这变成下载较大文件时更有可能。”</p>\n<h1 id=\"破解\"><a href=\"#破解\" class=\"headerlink\" title=\"破解\"></a>破解</h1><h2 id=\"穷举法-amp-字典法\"><a href=\"#穷举法-amp-字典法\" class=\"headerlink\" title=\"穷举法&amp;字典法\"></a>穷举法&amp;字典法</h2><p><strong>穷举法非常简单，就是不停地尝试各种字符的排列组合，看哪一个组合的MD5码能对上。</strong>可惜缺点是太耗费时间了。我们举个栗子，假设我们要破解一个6位大小写字母和数字混合的密码，那么一共有(26+26+10)<sup>6</sup> 种组合。这个数的大小超过500亿。</p>\n<p>既然计算如此费时，能不能考虑<strong>把计算结果以映射表的形式存放起来，一个萝卜一个坑</strong>，一个原文对应着一个MD5码呢？可以呀！这就是传说中的“字典法”。将已知的MD5码查表，直接反查出原文。<strong>字典法体现了算法设计的“以空间换时间”的思想。</strong>缺点是比较耗费空间。不过现在硬盘的价格变得白菜价了，空间开销不算什么。</p>\n<p><a href=\"https://www.cmd5.com/password.aspx\">CMD5 反查网站</a></p>\n<p><a href=\"https://www.somd5.com/\">SMD5 反查网站</a></p>\n<h2 id=\"哈希链表-amp-彩虹表法\"><a href=\"#哈希链表-amp-彩虹表法\" class=\"headerlink\" title=\"哈希链表&amp;彩虹表法\"></a>哈希链表&amp;彩虹表法</h2><blockquote>\n<p>  如果说穷举法太耗费时间，字典法太耗费存储空间的话，我们能不能考虑在时间消耗和空间消耗之间折中呢？我们可以考虑用链表将一系列有意义的原文和MD5码串起来。</p>\n<p>  要构造这样的链表，我们需要两个函数：哈希函数H(x)和衰减函数（reduction function）R(x)。哈希函数可以是MD5，也可以是其他的消息摘要算法。H(x)的值域是R(x)的定义域，R(x)的值域是H(x)的定义域。<strong>R(x)不是H(x)的反函数。</strong></p>\n<p>  将一个原文不停地使用H(x)和R(x)交替进行运算k次，再将原文本身和运算结果以链表的形式串接起来，就可以得到结点个数为2k+1的链表。实际存放的时候只存放首端和末端两个原文即可。<strong>这种链表叫做“哈希链表”，体现了算法设计的“时空权衡”（Space and Time Tradeoffs）。</strong></p>\n<p>  举个栗子，假设原文s&#x3D;abcabc，经过2次交替运算，得到以下的链表：</p>\n<p>  abcabc-&gt;H(x)-&gt;3C8B0D7A-&gt;R(x)-&gt;eopmca-&gt;H(x)-&gt;7E9F216C-&gt;R(x)-&gt;rapper</p>\n<p>  以上数据均为举例编造的，仅为说明原理使用。那我们存放这个链表的时候，只需要记录abcabc和rapper两个原文即可。</p>\n<p>  假设我们要破解的摘要值（哈希链表的H(x)不一定是MD5算法，这里用更准确的说法代替MD5码）是7E9F216C，经过R(x)运算得到rapper，说明我们要寻找的原文就在以rapper为末端的哈希链表中。从首端开始经过多次运算，我们发现eopmca的摘要值就是7E9F216C。于是就反查出7E9F216C对应的原文是eopmca。</p>\n<p>  <strong>如果在生成哈希链表的时候依次使用多个不一样的R(x)，此时的哈希链表就是“彩虹表”。</strong></p>\n<p>  这里有已经计算好的彩虹表：<a href=\"https://link.zhihu.com/?target=http://project-rainbowcrack.com/table.htm\">http://project-rainbowcrack.com</a></p>\n</blockquote>\n<h2 id=\"差分攻击\"><a href=\"#差分攻击\" class=\"headerlink\" title=\"差分攻击\"></a>差分攻击</h2><p>上面介绍的穷举法、字典法和彩虹表法都是暴力破解，适用于任何的消息摘要算法。</p>\n<p>真正意义上MD5算法的破解，是2004年山东大学王小云教授提出的MD5碰撞方法。她所用到的方法正是差分攻击。</p>\n<p><a href=\"https://www.sohu.com/a/501560600_121106869\">她是这样的“中国密码女神”！</a> </p>\n",
            "tags": [
                "md5"
            ]
        },
        {
            "id": "https://www.oikiou.top/2022/c65e1067/",
            "url": "https://www.oikiou.top/2022/c65e1067/",
            "title": "Tags Label Category",
            "date_published": "2022-08-25T14:57:15.000Z",
            "content_html": "<p>知乎  <a href=\"https://www.zhihu.com/people/songvision\">千鸟</a></p>\n<blockquote>\n<p>  这问题要分两个层面来解读：</p>\n<p>  <strong>首先是Tag与Category的区别。</strong>Category往往限制在一个维度里，当树状结构复杂到不可调和时，出现瓶颈是迟早的事。Category的问题在于，既不能完全满足用户需求，也不能完全表达创建者对内容属性的认知。而Tag反之都成立，完全互补。</p>\n<p>  <strong>其次是Label与Tag的区别。</strong>于对内容的概括出现偏差，但显然这种问题不是tag，在内容组织范畴那应该是什么？答案就是label，除产品描述，其应用范畴还涉及功能名称、模块名称、导航名称、引导文字等等场景。我认为tag与label之间有三个显著差异：</p>\n<ol>\n<li>label是本身的，tag是附加的；</li>\n<li>label强调是一种标志，tag强调是一种记号；</li>\n<li>label标明信息之间的归属，tag区别信息之间的差异。</li>\n</ol>\n</blockquote>\n<p>知乎 郑讯</p>\n<blockquote>\n<p>  Tag，标签，一般包含一段内容的属性，可以是分类，可以是话题，也可以是作者，地理信息等。</p>\n<p>  Label，标记，是网页框架中一个区域的功能概括。比如知乎首页上的“浏览”、“问题”、“通知”就是label。选择不同的标记，相应区域的功能就会发生变化。</p>\n<p>  category，分类，可以理解为种属概念。一段内容有且只有一个种属的分类。和Tag不同的是一段内容可以有多个tag，并且tag是未预先设定的，一段内容可以有多个Tag，也可以没有Tag。但caterory在一个分类标准下只有一个。</p>\n</blockquote>\n<p>知乎 李楠</p>\n<blockquote>\n<p>  <strong>Category</strong></p>\n<p>  Category 是非常理想化和一根筋的分类方式。图书馆这种死板到头的地方用的多。但是他们也遇到了问题：“苏菲的世界”到底是“哲学”，还是“文学”？</p>\n<p>  物理世界无力从根本上解决这种问题（但似乎不少讨论）。问过我们学校的图书馆，似乎他们方式还比较靠谱：<strong>买两本，两处放。</strong></p>\n<p>  分类对象数字化之后， Category 的影响还在（早期的门户找点跨界的东西就很悲剧）。直到 Web2.0 ， Tag 竟然才开始流行。</p>\n<p>  <strong>Tag</strong></p>\n<p>  Tag 是更好的分类方式的原因是：</p>\n<p>  1</p>\n<p>  “类别”本来就不应该事先定义：人不是上帝。</p>\n<p>  从一个个具体对象的“属性”中，总结出“类别”是最自然的模式。也是“人”可以做到的事情。</p>\n<p>  2</p>\n<p>  “属性”本来就应该可以自然的表现为多个。</p>\n<p>  苏菲的世界终于可以自然的打上“哲学”和“文学”的 Tag 了，或者再加个“少儿读物”。这种思考方式比 Category 优雅太多。</p>\n<p>  Tag 最终普及，背后恐怕有<a href=\"https://www.zhihu.com/search?q=%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:12226710%7D\">软件工程</a>上 OO 普及（面向对象）的因素。<strong>“面向对象”不仅仅是的程序构建方式，更是认识世界的方法论的进步。</strong></p>\n<p>  “属性”跟随“对象”，比“对象”属于“类别”更自然，不机械。 。</p>\n<p>  <strong>Tag 的改进</strong></p>\n<p>  Tag 本身也可以看作“对象”。</p>\n<p>  那么就有针对 Tag 的操作，比如“搜索”，“排序”，“关联对象”。也有 Tag 本身的属性，比如“使用次数”，“关注人数”等等。</p>\n<p>  如何能在使用 Tag 的系统中，根据这些数据，计算出最适合的对象，就要靠算法的优化和运营的调整了。</p>\n</blockquote>\n<p>知乎 <a href=\"https://www.zhihu.com/people/zheng-wei-42-9\">榆木脑袋</a></p>\n<blockquote>\n<p>  Catagory是逻辑清晰的。Tag是随意自由的。在看到一个信息的时候我们需要自由捕获自己头脑中的闪光。在重新审视或再利用我们收集的信息时，就需要清晰的逻辑条理。</p>\n<p>  以文件管理为例：</p>\n<p>  在标记Tag时需求有二：一是能够方便增加新的Tag，二是能够很方便的看到已有的Tag，并能同时把已有标签赋予当前信息。</p>\n<p>  在查找文件时个人觉得需要有的功能是：一是有固定的几个入口，也就是根目录；二是可以增加根节点；三是根目录可以指定某几个Tag，也可以不是；三如果根目录不是Tag，需要定义关联到此根目录（分类）下的Tag；四（重点功能）根目录下不直接列出信息或文件（时间长了，某一Tag下文件会相当多），而是列出关联Tag的所有文件的其它Tag，显示为子目录，并标识出此子目录中的文件数量。五（作为管理功能）此时可以定义哪些Tag不在此根目录下出现。六设置某个Tag或某类Tag(文件数量大过一个数量)下仍不列出文件而是继续列出Tag；七子目录（Tag）下，上级目录Tag不再出现。</p>\n<p>  我个人非常偏好使用树形目录结构，但苦恼于文件的多重分类和文件进行多重分类时的繁琐。经过多方搜索只找到三个比较符合的软件，一个是PinKM，一个是蓝码动力图片管理软件，一个是国外的Tabbles。但都因标签管理和整理的繁琐而放弃。</p>\n</blockquote>\n<p><strong>个人理解</strong></p>\n<ul>\n<li>Catagory 是属于严格的分类方法, 一个东西应当只属于一个Catagory内, 而且它是有层级关系的</li>\n<li>Tags 是可有可无的, 一个东西可以有很多的Tags, 它是无层级关系的,</li>\n</ul>\n",
            "tags": [
                "tags",
                "label",
                "category"
            ]
        },
        {
            "id": "https://www.oikiou.top/2022/438d1de3/",
            "url": "https://www.oikiou.top/2022/438d1de3/",
            "title": "字符集和字符编码",
            "date_published": "2022-08-14T14:12:34.000Z",
            "content_html": "<h1 id=\"字符集和字符编码\"><a href=\"#字符集和字符编码\" class=\"headerlink\" title=\"字符集和字符编码\"></a>字符集和字符编码</h1><p><a href=\"https://www.cnblogs.com/skynet/archive/2011/05/03/2035105.html\">字符集和字符编码 (Charset &amp; Encoding)</a></p>\n<p><a href=\"http://www.knowsky.com/resource/gb2312tbl.htm\">GB2312简体中文编码表</a></p>\n<p><a href=\"http://tools.jb51.net/table/gb2312\">GB2312简体中文编码表</a></p>\n<p><a href=\"https://www.unicode.org/charts/\">Unicode码查询</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84\">Unicode字符平面映射</a></p>\n<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p><strong>字符集（Charset）</strong>：是一个系统支持的所有抽象字符的集合。字符是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等。</p>\n<p>常见字符集：ASCII字符集、GB2312字符集、BIG5字符集、GB18030字符集、Unicode字符集等。计算机要准确的处理各种字符集文字，需要进行字符编码，以便计算机能够识别和存储各种文字。</p>\n<p><strong>字符编码（Character Encoding）</strong>：是一套法则，使用该法则能够对自然语言的字符的一个集合（如字母表或音节表），与其他东西的一个集合（如号码、数字或电脉冲）进行配对。即在符号集合与数字系统之间建立对应关系，它是信息处理的一项基本技术。通常人们用符号集合（一般情况下就是文字）来表达信息。而以计算机为基础的信息处理系统则是利用元件（硬件）不同状态的组合来存储和处理信息的。元件不同状态的组合能代表数字系统的数字，因此字符编码就是将符号转换为计算机可以接受的数字系统的数，称为数字代码。</p>\n<h2 id=\"ASCII\"><a href=\"#ASCII\" class=\"headerlink\" title=\"ASCII\"></a>ASCII</h2><p><strong>ASCII字符集</strong>：主要包括控制字符（回车键、退格、换行键等）；可显示字符（英文大小写字符、阿拉伯数字和西文符号）。</p>\n<p><strong>ASCII编码</strong>：将ASCII字符集转换为计算机可以接受的数字系统的数的规则。使用7位（bits）表示一个字符，共128字符；但是7位编码的字符集只能支持128个字符，为了表示更多的常用字符欧洲对ASCII进行了扩展，ASCII扩展字符集使用8位（bits）表示一个字符，共256字符。ASCII字符集映射到数字编码规则如下图所示：</p>\n<p><img src=\"/2022/438d1de3/2011050311372042.png\" alt=\"img\"></p>\n<p><img src=\"/2022/438d1de3/201105031137219627.png\" alt=\"img\"></p>\n<h2 id=\"GBxxx\"><a href=\"#GBxxx\" class=\"headerlink\" title=\"GBxxx\"></a>GBxxx</h2><p>中国把那些127号之后的奇异符号们（即EASCII、扩充ASCII）取消掉，规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字。前面的一个字节（他称之为高字节）从0xA1用到 0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。在这些编码里，还把数学符号、罗马希腊的 字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。</p>\n<p>上述编码规则就是<strong>GB2312</strong>。<strong>GB2312</strong>或<strong>GB2312-80</strong>是<a href=\"http://zh.wikipedia.org/wiki/%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E5%9B%BD%E5%AE%B6%E6%A0%87%E5%87%86\">中国国家标准</a><a href=\"http://zh.wikipedia.org/wiki/%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87\">简体中文</a><a href=\"http://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E9%9B%86\">字符集</a>，全称《<strong>信息交换用汉字编码字符集·基本集</strong>》，又称<a href=\"http://zh.wikipedia.org/wiki/%E5%9B%BD%E5%AE%B6%E6%A0%87%E5%87%86%E4%BB%A3%E7%A0%81\"><strong>GB0</strong></a>，由<a href=\"http://zh.wikipedia.org/w/index.php?title=%E4%B8%AD%E5%9B%BD%E5%9B%BD%E5%AE%B6%E6%A0%87%E5%87%86%E6%80%BB%E5%B1%80&action=edit&redlink=1\">中国国家标准总局</a>发布，<a href=\"http://zh.wikipedia.org/wiki/1981%E5%B9%B4\">1981年</a><a href=\"http://zh.wikipedia.org/wiki/5%E6%9C%881%E6%97%A5\">5月1日</a>实施。GB2312编码通行于中国大陆；<a href=\"http://zh.wikipedia.org/wiki/%E6%96%B0%E5%8A%A0%E5%9D%A1\">新加坡</a>等地也采用此编码。GB2312的出现，基本满足了汉字的计算机处理需要，它所收录的汉字已经覆盖中国大陆99.75%的使用频率。对于<a href=\"http://zh.wikipedia.org/wiki/%E4%BA%BA%E5%90%8D\">人名</a>、<a href=\"http://zh.wikipedia.org/wiki/%E5%8F%A4%E6%B1%89%E8%AF%AD\">古汉语</a>等方面出现的<a href=\"http://zh.wikipedia.org/wiki/%E7%BD%95%E7%94%A8%E5%AD%97\">罕用字</a>，GB2312不能处理，这导致了后来<a href=\"http://zh.wikipedia.org/wiki/GBK\">GBK</a>及<a href=\"http://zh.wikipedia.org/wiki/GB_18030\">GB 18030</a>汉字字符集的出现。</p>\n<p><a href=\"http://www.knowsky.com/resource/gb2312tbl.htm\">GB2312简体中文编码表</a></p>\n<p><a href=\"http://tools.jb51.net/table/gb2312\">GB2312简体中文编码表</a></p>\n<h2 id=\"Unicode\"><a href=\"#Unicode\" class=\"headerlink\" title=\"Unicode\"></a>Unicode</h2><p>Unicode编码系统为表达任意语言的任意字符而设计。它使用4字节的数字来表达每个字母、符号，或者表意文字(ideograph)。每个字符对应一个数字，每个数字对应一个字符，即不存在二义性，不再需要记录”模式”了。U+0041总是代表’A’，即使这种语言没有’A’这个字符。</p>\n<p>在计算机科学领域中，<strong>Unicode</strong>（<strong>统一码</strong>、<strong>万国码</strong>、<strong>单一码</strong>、<strong>标准万国码</strong>）是业界的一种标准，它可以使电脑得以体现世界上数十种文字的系统。</p>\n<p>（<strong>可以这样理解：Unicode是字符集，UTF-32&#x2F; UTF-16&#x2F; UTF-8是三种字符编码方案。</strong>）</p>\n<p><a href=\"https://www.unicode.org/charts/\">Unicode码查询</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84\">Unicode字符平面映射</a></p>\n<h3 id=\"BOM\"><a href=\"#BOM\" class=\"headerlink\" title=\"BOM\"></a>BOM</h3><p>EF BB BF　　　 UTF-8<br>FE FF　　　　　UTF-16&#x2F;UCS-2, little endian<br>FF FE　　　　　UTF-16&#x2F;UCS-2, big endian<br>FF FE 00 00　　UTF-32&#x2F;UCS-4, little endian.<br>00 00 FE FF　　UTF-32&#x2F;UCS-4, big-endian.</p>\n<ul>\n<li><strong>字符集和字符编码</strong></li>\n</ul>\n<p><img src=\"/2022/438d1de3/v2-aee5ae604328ab912b285d03b6c62273_720w.jpg\" alt=\"img\"></p>\n<h3 id=\"UTF-32\"><a href=\"#UTF-32\" class=\"headerlink\" title=\"UTF-32\"></a>UTF-32</h3><p>上述使用4字节的数字来表达每个字母、符号，或者表意文字(ideograph)，每个数字代表唯一的至少在某种语言中使用的符号的编码方案，称为UTF-32。UTF-32又称<strong>UCS-4</strong>是一种将<a href=\"http://zh.wikipedia.org/wiki/Unicode\">Unicode</a>字符编码的协定，对每个字符都使用4字节。就空间而言，是非常没有效率的。</p>\n<p>这种方法有其优点，最重要的一点就是可以在常数时间内定位字符串里的第N个字符，因为第N个字符从第4×Nth个字节开始。虽然每一个码位使用固定长定的字节看似方便，它并不如其它Unicode编码使用得广泛。</p>\n<h3 id=\"UTF-16\"><a href=\"#UTF-16\" class=\"headerlink\" title=\"UTF-16\"></a>UTF-16</h3><p>对于UTF-32和UTF-16编码方式还有一些其他不明显的缺点。不同的计算机系统会以不同的顺序保存字节。这意味着字符U+4E2D在UTF-16编码方式下可能被保存为4E 2D或者2D 4E，这取决于该系统使用的是大尾端(big-endian)还是小尾端(little-endian)。为了解决这个问题，多字节的Unicode编码方式定义了一个”字节顺序标记(Byte Order Mark)”，它是一个特殊的非打印字符，你可以把它包含在文档的开头来指示你所使用的字节顺序。对于UTF-16，字节顺序标记是U+FEFF。如果收到一个以字节FFFE开头的UTF-16编码的文档，你就能确定它的字节顺序是单向的(one way)的了；如果它以FEFF开头，则可以确定字节顺序反向了。</p>\n<p><strong>具体编码方式</strong></p>\n<p>Unicode范围<code>U+10000</code><del><code>U+10FFFF</code>：将Unicode值减去（0x10000），得到20bit长的值。再将Unicode分为高10位和低10位。<a href=\"https://www.zhihu.com/search?q=UTF-16%E7%BC%96%E7%A0%81&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:106379925%7D\">UTF-16编码</a>的高位是2 Byte，高10位Unicode范围为<code>0</code>-<code>0x3FF</code>，将Unicode值加上<code>0XD800</code>，得到高位代理（或称为前导代理，存储高位）；低位也是2 Byte，低十位Unicode范围一样为<code>0</code></del><code>0x3FF</code>，将Unicode值加上<code>0xDC00</code>,得到低位代理（或称为后尾代理，存储低位）</p>\n<p>根据上面的转换方式，我们就能够将Unicode码根据UTF-16的编码方式进行转换。下面我们仍然通过两个例子来看下：</p>\n<ul>\n<li><code>U+0020</code>，这个值的范围在第一部分，即经过UTF-16编码后，结果仍然为<code>U+0020</code>，在内存中的顺序为<code>00 20</code>。</li>\n<li><code>U+12345</code>, 这个值的范围在第二部分，因此需要先减去<code>0x10000</code>，得到<code>0x02345</code>，拆分成高10位<code>00 0000 1000</code>和低10位<code>11 0100 0101</code>。根据上面规则加上特定值后，高位代理值为<code>D808</code>，低位代理值为<code>DF45</code>，最终内存中的顺序为<code>D8 08 DF 45</code>。</li>\n</ul>\n<h3 id=\"UTF-8\"><a href=\"#UTF-8\" class=\"headerlink\" title=\"UTF-8\"></a>UTF-8</h3><p><strong>UTF-8</strong>（8-bit Unicode Transformation Format）是一种针对<a href=\"http://zh.wikipedia.org/wiki/Unicode\">Unicode</a>的可变长度<a href=\"http://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81\">字符编码</a>（<a href=\"http://zh.wikipedia.org/w/index.php?title=%E5%AE%9A%E9%95%BF%E7%A0%81&action=edit&redlink=1\">定长码</a>），也是一种<a href=\"http://zh.wikipedia.org/w/index.php?title=%E5%89%8D%E7%BC%80%E7%A0%81&action=edit&redlink=1\">前缀码</a>。它可以用来表示Unicode标准中的任何字符，且其编码中的第一个<a href=\"http://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82\">字节</a>仍与<a href=\"http://zh.wikipedia.org/wiki/ASCII\">ASCII</a>兼容，这使得原来处理ASCII字符的<a href=\"http://zh.wikipedia.org/wiki/%E8%BB%9F%E9%AB%94\">软件</a>无须或只须做少部份修改，即可继续使用。因此，它逐渐成为<a href=\"http://zh.wikipedia.org/wiki/%E9%9B%BB%E5%AD%90%E9%83%B5%E4%BB%B6\">电子邮件</a>、<a href=\"http://zh.wikipedia.org/wiki/%E7%B6%B2%E9%A0%81\">网页</a>及其他<a href=\"http://zh.wikipedia.org/wiki/%E5%84%B2%E5%AD%98%E8%A3%9D%E7%BD%AE\">存储</a>或传送文字的应用中，优先采用的编码。<a href=\"http://zh.wikipedia.org/wiki/%E7%B6%B2%E9%9A%9B%E7%B6%B2%E8%B7%AF%E5%B7%A5%E7%A8%8B%E5%B7%A5%E4%BD%9C%E5%B0%8F%E7%B5%84\">互联网工程工作小组</a>（IETF）要求所有<a href=\"http://zh.wikipedia.org/wiki/%E7%B6%B2%E9%9A%9B%E7%B6%B2%E8%B7%AF\">互联网</a><a href=\"http://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE\">协议</a>都必须支持UTF-8编码。</p>\n<p>UTF-8使用一至四个<a href=\"http://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82\">字节</a>为每个字符编码</p>\n<p><strong>具体编码方式</strong></p>\n<p><img src=\"/2022/438d1de3/v2-121a14291638f0b28e1dde7c95d2d379_720w.jpg\" alt=\"img\"></p>\n<p>根据上表，解读 UTF-8 编码非常简单。如果一个字节的第一位是<code>0</code>，则这个字节单独就是一个字符；如果第一位是<code>1</code>，则连续有多少个<code>1</code>，就表示当前字符占用多少个字节。<br>下面，还是以汉字<code>严</code>为例，演示如何实现 <a href=\"https://www.zhihu.com/search?q=UTF-8+%E7%BC%96%E7%A0%81&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:790551384%7D\">UTF-8 编码</a>。<br><code>严</code>的 Unicode 是<code>4E25</code>（<code>100111000100101</code>），根据上表，可以发现<code>4E25</code>处在第三行的范围内（<code>0000 0800 - 0000 FFFF</code>），因此<code>严</code>的 UTF-8 编码需要三个字节，即格式是<code>1110xxxx 10xxxxxx 10xxxxxx</code>。然后，从<code>严</code>的最右边<a href=\"https://www.zhihu.com/search?q=%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:790551384%7D\">二进制位</a>开始，依次从右往左填入上边格式中的<code>x</code>，多出的位补<code>0</code>。这样就得到了，<code>严</code>的 UTF-8 编码是<code>11100100 10111000 10100101</code>，转换成<a href=\"https://www.zhihu.com/search?q=%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:790551384%7D\">十六进制</a>就是<code>E4 B8 A5</code>。</p>\n<p><strong>优点</strong></p>\n<ul>\n<li>UTF-8是ASCII的一个<a href=\"http://zh.wikipedia.org/wiki/%E8%B6%85%E9%9B%86\">超集</a>。因为一个纯ASCII字符串也是一个合法的UTF-8字符串，所以现存的ASCII文本不需要转换。为传统的扩展ASCII字符集设计的软件通常可以不经修改或很少修改就能与UTF-8一起使用。</li>\n<li>使用标准的面向字节的排序例程对UTF-8排序将产生与*于Unicode代码点排序相同的结果。（尽管这只有有限的有用性，因为在任何特定语言或文化下都不太可能有仍可接受的文字排列顺序。）</li>\n<li>UTF-8和UTF-16都是<a href=\"http://zh.wikipedia.org/wiki/%E5%8F%AF%E6%89%A9%E5%B1%95%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80\">可扩展标记语言</a>文档的标准编码。所有其它编码都必须通过显式或文本声明来指定。</li>\n<li>任何<a href=\"http://zh.wikipedia.org/w/index.php?title=%E9%9D%A2%E5%90%91%E5%AD%97%E8%8A%82&action=edit&redlink=1\">面向字节</a>的<a href=\"http://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95\">字符串搜索算法</a>都可以用于UTF-8的数据（只要输入仅由完整的UTF-8字符组成）。但是，对于包含字符记数的正则表达式或其它结构必须小心。</li>\n<li>UTF-8字符串可以由一个简单的算法可靠地识别出来。就是，一个字符串在任何其它编码中表现为合法的UTF-8的可能性很低，并随字符串长度增长而减小。举例说，字符值C0,C1,F5至FF从来没有出现。为了更好的可靠性，可以使用正则表达式来统计非法过长和替代值（可以查看<a href=\"http://www.w3.org/International/questions/qa-forms-utf-8\">W3 FAQ: Multilingual Forms</a>上的验证UTF-8字符串的正则表达式）。</li>\n</ul>\n<p><strong>缺点</strong></p>\n<p>因为每个字符使用不同数量的字节编码，所以寻找串中第N个字符是一个O(N)复杂度的操作 — 即，串越长，则需要更多的时间来定位特定的字符。同时，还需要位变换来把字符编码成字节，把字节解码成字符。</p>\n",
            "tags": [
                "character encoding",
                "gb2312",
                "utf-8"
            ]
        },
        {
            "id": "https://www.oikiou.top/2022/3ef2a47d/",
            "url": "https://www.oikiou.top/2022/3ef2a47d/",
            "title": "搭建KMS",
            "date_published": "2022-07-24T14:57:15.000Z",
            "content_html": "<h1 id=\"KMS\"><a href=\"#KMS\" class=\"headerlink\" title=\"KMS\"></a>KMS</h1><p>KMS（Key Management Service），密钥管理服务</p>\n<p>能够通过KMS进行激活的一般称为VL版,即VOLUME授权版，一般不会单独在零售市场进行发售，一般是直接向企业提供电子ISO映像进行批量授权安装，基于对KMS原理研究成果，我们可以自行搭建KMS激活服务器，实现每180天一次的自动激活，使得系统一直保持激活状态。</p>\n<p>KMS可以激活VOL版本的windows系统和office软件</p>\n<h1 id=\"Docker-部署KMS服务器\"><a href=\"#Docker-部署KMS服务器\" class=\"headerlink\" title=\"Docker 部署KMS服务器\"></a>Docker 部署KMS服务器</h1><p><a href=\"https://registry.hub.docker.com/r/teddysun/kms\">https://registry.hub.docker.com/r/teddysun/kms</a></p>\n<ol>\n<li><p>Pull the image</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">docker pull teddysun/kms<br></code></pre></td></tr></table></figure>\n<p>This pulls the latest release of KMS server. It can be found at Docker Hub.</p>\n</li>\n<li><p>Start a container</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">docker run -d -p 1688:1688 --name kms --restart=always teddysun/kms<br></code></pre></td></tr></table></figure>\n<p>Note: The TCP port number <code>1688</code> must be opened in firewall.</p>\n</li>\n</ol>\n<h1 id=\"激活\"><a href=\"#激活\" class=\"headerlink\" title=\"激活\"></a>激活</h1><h2 id=\"激活windows\"><a href=\"#激活windows\" class=\"headerlink\" title=\"激活windows\"></a>激活windows</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 待激活的主机上指定KMS服务器</span><br>slmgr /skms service_address(你搭建的服务器的地址)<br><br><span class=\"hljs-comment\"># 手动激活</span><br>slmgr /ato<br><br><span class=\"hljs-comment\"># 如果激活失败 尝试更改成GVLK KEY再次激活</span><br><span class=\"hljs-comment\"># 运行以下命令查看系统版本 </span><br>wmic os get caption<br><br><span class=\"hljs-comment\"># 访问下面的网址获取key</span><br><span class=\"hljs-comment\"># https://docs.microsoft.com/zh-cn/windows-server/get-started/kms-client-activation-keys</span><br><span class=\"hljs-comment\"># https://technet.microsoft.com/en-us/library/jj612867.aspx</span><br><span class=\"hljs-comment\"># 得到对应key之后，使用管理员权限运行cmd执行安装key：</span><br>slmgr /ipk xxxxx-xxxxx-xxxxx-xxxxx<br><br><span class=\"hljs-comment\"># 手动激活</span><br>slmgr /ato<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"激活office\"><a href=\"#激活office\" class=\"headerlink\" title=\"激活office\"></a>激活office</h2><p>首先你的OFFICE必须是VOL版本，否则无法激活。 找到你的office安装目录，比如</p>\n<figure class=\"highlight livescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livescript\">C:<span class=\"hljs-string\">\\Program</span> Files (x86)<span class=\"hljs-string\">\\Microsoft</span> Office<span class=\"hljs-string\">\\Office16</span><br></code></pre></td></tr></table></figure>\n\n<p>64位的就是</p>\n<figure class=\"highlight livescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livescript\">C:<span class=\"hljs-string\">\\Program</span> Files<span class=\"hljs-string\">\\Microsoft</span> Office<span class=\"hljs-string\">\\Office16</span><br></code></pre></td></tr></table></figure>\n<p>office16是office2016，office15就是2013，office14就是2010.</p>\n<p>然后目录对的话，该目录下面应该有个OSPP.VBS。</p>\n<p>直接输入下面的指令去指定KMS服务器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">cscript <span class=\"hljs-string\">&quot;C:\\Program Files (x86)\\Microsoft Office\\Office16\\OSPP.VBS&quot;</span> sethst:service_address(你搭建的服务器的地址)<br><span class=\"hljs-comment\"># or</span><br>cscript <span class=\"hljs-string\">&quot;C:\\Program Files\\Microsoft Office\\Office16\\OSPP.VBS&quot;</span> /sethst:service_address(你搭建的服务器的地址)<br></code></pre></td></tr></table></figure>\n\n<p>一般来说，“一句命令已经完成了”，但一般office不会马上连接kms服务器进行激活，所以我们额外补充一条手动激活命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">cscript ospp.vbs /act<br></code></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"如果遇到报错，请检查：\"><a href=\"#如果遇到报错，请检查：\" class=\"headerlink\" title=\"如果遇到报错，请检查：\"></a>如果遇到报错，请检查：</h1><blockquote>\n<ol>\n<li>你的系统&#x2F;OFFICE是否是批量VL版本</li>\n<li>是否以管理员权限运行CMD</li>\n<li>你的系统&#x2F;OFFICE是否修改过KEY&#x2F;未安装GVLK KEY</li>\n<li>检查你的网络连接</li>\n<li>服务器繁忙，多试试（点击检查KMS服务是否可用）</li>\n<li>根据出错代码自己搜索出错原因</li>\n</ol>\n</blockquote>\n<h2 id=\"windows没有密钥\"><a href=\"#windows没有密钥\" class=\"headerlink\" title=\"windows没有密钥\"></a>windows没有密钥</h2><ul>\n<li>windows VOL KEY</li>\n</ul>\n<p><a href=\"https://docs.microsoft.com/zh-cn/windows-server/get-started/kmsclientkeys\">https://docs.microsoft.com/zh-cn/windows-server/get-started/kmsclientkeys</a></p>\n<h2 id=\"检查windows版本\"><a href=\"#检查windows版本\" class=\"headerlink\" title=\"检查windows版本\"></a>检查windows版本</h2><ul>\n<li>检查office是否是VOL版本</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 命令提示符（管理员）执行：cd “office的安装目录”</span><br><span class=\"hljs-built_in\">cd</span> <span class=\"hljs-string\">&quot;C:\\Program Files (x86)\\Microsoft Office\\Office16&quot;</span><br><span class=\"hljs-comment\"># or</span><br><span class=\"hljs-built_in\">cd</span> <span class=\"hljs-string\">&quot;C:\\Program Files\\Microsoft Office\\Office16&quot;</span><br><br><span class=\"hljs-comment\"># 执行：</span><br>cscript ospp.vbs /dstatus<br></code></pre></td></tr></table></figure>\n\n<p>在显示的信息中，如果有“VOLUME”字样就是VOL版，即支持KMS激活</p>\n<h2 id=\"office-密钥\"><a href=\"#office-密钥\" class=\"headerlink\" title=\"office 密钥\"></a>office 密钥</h2><ul>\n<li>卸载office的密钥</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 命令提示符（管理员）执行：cd “office的安装目录”</span><br><span class=\"hljs-built_in\">cd</span> <span class=\"hljs-string\">&quot;C:\\Program Files (x86)\\Microsoft Office\\Office16&quot;</span><br><span class=\"hljs-comment\"># or</span><br><span class=\"hljs-built_in\">cd</span> <span class=\"hljs-string\">&quot;C:\\Program Files\\Microsoft Office\\Office16&quot;</span><br><br><span class=\"hljs-comment\"># 查看当前状态</span><br>cscript ospp.vbs /dstatus<br><br><span class=\"hljs-comment\"># 找到 Last 5 characters of installed product key:XXXXX 语句</span><br><span class=\"hljs-comment\"># 卸载密钥</span><br>cscript ospp.vbs /unpkey:XXXXX<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>查找office的VOL KEY</li>\n</ul>\n<p><a href=\"https://docs.microsoft.com/zh-cn/DeployOffice/vlactivation/gvlks\">https://docs.microsoft.com/zh-cn/DeployOffice/vlactivation/gvlks</a></p>\n<ul>\n<li><p>安装密钥</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">Office 专业增强版 2016</span><br>cscript ospp.vbs /inpkey:XQNVK-8JYDB-WJ9W3-YJ8YR-WFG99<br></code></pre></td></tr></table></figure></li>\n</ul>\n",
            "tags": [
                "kms",
                "office",
                "volume"
            ]
        },
        {
            "id": "https://www.oikiou.top/2022/82aca4fc/",
            "url": "https://www.oikiou.top/2022/82aca4fc/",
            "title": "SSL证书的申请和自动续期",
            "date_published": "2022-07-21T14:57:15.000Z",
            "content_html": "<h1 id=\"SSL证书的申请和自动续期\"><a href=\"#SSL证书的申请和自动续期\" class=\"headerlink\" title=\"SSL证书的申请和自动续期\"></a>SSL证书的申请和自动续期</h1><p>Let’s Encrypt 证书续期</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://www.jianshu.com/p/a2d0209fa3f5\">https://www.jianshu.com/p/a2d0209fa3f5</a></p>\n<p><a href=\"https://www.cnblogs.com/esofar/p/9291685.html\">快速签发 Let’s Encrypt 证书指南</a></p>\n<p><a href=\"https://certbot.eff.org/\">https://certbot.eff.org/</a></p>\n<h1 id=\"acme-sh-申请\"><a href=\"#acme-sh-申请\" class=\"headerlink\" title=\"acme.sh 申请\"></a>acme.sh 申请</h1><p>用 acme.sh申请来自动续期ssl证书<br> acme说明：<a href=\"https://links.jianshu.com/go?to=https://github.com/Neilpang/acme.sh/wiki/%E8%AF%B4%E6%98%8E\">https://github.com/Neilpang/acme.sh/wiki/说明</a></p>\n<h2 id=\"通过在网站根目录存放文件来验证域名\"><a href=\"#通过在网站根目录存放文件来验证域名\" class=\"headerlink\" title=\"通过在网站根目录存放文件来验证域名\"></a>通过在网站根目录存放文件来验证域名</h2><ol>\n<li><p>下载acme<code>curl https://get.acme.sh | sh</code>  安装完成后必须关闭当前终端，重新开启一个以使acme.sh命令生效</p>\n</li>\n<li><p>执行生成和自动更新命令：<code>acme.sh --issue -d mydomain.com -d www.mydomain.com --webroot /var/www/mydomain.com/</code></p>\n<blockquote>\n<h2 id=\"通过在网站根目录存放文件来验证域名-1\"><a href=\"#通过在网站根目录存放文件来验证域名-1\" class=\"headerlink\" title=\"通过在网站根目录存放文件来验证域名\"></a>通过在网站根目录存放文件来验证域名</h2>  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">acme.sh --issue -d mydomain.com -d www.mydomain.com --webroot /home/wwwroot/mydomain.com/<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">如果你用的 nginx服务器, 或者反代, acme.sh 还可以智能的从 nginx的配置中自动完成验证, 你不需要指定网站根目录:</span><br>acme.sh --issue -d mydomain.com --nginx<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"通过DNS解析添加TXT解析记录验证\"><a href=\"#通过DNS解析添加TXT解析记录验证\" class=\"headerlink\" title=\"通过DNS解析添加TXT解析记录验证\"></a>通过DNS解析添加TXT解析记录验证</h2>  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">acme.sh --issue --dns -d mydomain.com \\<br> --yes-I-know-dns-manual-mode-enough-go-ahead-please<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">然后, acme.sh 会生成相应的解析记录显示出来, 你只需要在你的域名管理面板中添加这条 txt 记录即可.等待解析完成之后, 重新生成证书:</span><br><br>acme.sh --renew -d mydomain.com \\<br>  --yes-I-know-dns-manual-mode-enough-go-ahead-please<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">注意第二次这里用的是 --renew</span><br></code></pre></td></tr></table></figure>\n</blockquote>\n</li>\n<li><p>安装证书 <code>cd /etc/nginx; mkdir ssl</code></p>\n</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\">acme.sh  --installcert  -d  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">domain</span>&gt;</span>.com   \\<br>        --key-file   /etc/nginx/ssl/<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">domain</span>&gt;</span>.key \\<br>        --fullchain-file /etc/nginx/ssl/fullchain.cer \\<br>        --reloadcmd  &quot;service nginx force-reload&quot;<br></code></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>配置nginx使用ssl</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">server &#123;<br>    listen 80 default_server;<br>    listen 443 http2 ssl;<br>    listen [::]:80 default_server;<br><br>    ssl_certificate /etc/nginx/ssl/fullchain.cer;<br>    ssl_certificate_key /etc/nginx/ssl/domain.key;<br>    <span class=\"hljs-comment\">#http转https</span><br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable\">$scheme</span> = http ) &#123;<span class=\"hljs-built_in\">return</span> 301 https://$host<span class=\"hljs-variable\">$request_uri</span>;&#125;<br>    root /var/www/html;<br><br>    index index.html index.htm index.nginx-debian.html;<br>    server_name _;<br><br>    ssl_certificate /etc/nginx/ssl/fullchain.cer;<br>    ssl_certificate_key /etc/nginx/ssl/domain.key;<br><br>    location /test &#123;<br>          proxy_pass       http://127.0.0.1:3000;<br>          proxy_http_version 1.1;<br>          proxy_set_header Upgrade <span class=\"hljs-variable\">$http_upgrade</span>;<br>          proxy_set_header Connection <span class=\"hljs-string\">&quot;upgrade&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>前端的Upgrade请求发送给后端服务器，Upgrade和Connection的头信息必须被显式的设置。一旦我们完成以上设置，NGINX就可以处理WebSocket连接了。查看配置在哪里<code>ps -ef|grep nginx</code><br> 多个域名的话，配多个nginx.conf配置。</p>\n<ol start=\"5\">\n<li>查看是否有每日任务<br> <code>crontab -l #查看你的任务</code><br> 手动更新证书<code>acme.sh --renew -d domain.com</code></li>\n</ol>\n<h1 id=\"certbot\"><a href=\"#certbot\" class=\"headerlink\" title=\"certbot\"></a>certbot</h1><p><a href=\"https://certbot.eff.org/\">文档</a></p>\n<p>Ubuntu + nginx <a href=\"https://certbot.eff.org/instructions?ws=nginx&os=ubuntufocal\">https://certbot.eff.org/instructions?ws=nginx&amp;os=ubuntufocal</a></p>\n<p>用certbot来自动续期ssl证书</p>\n<ul>\n<li>需要注意的是安装证书的时候最好把nginx关掉先</li>\n</ul>\n",
            "tags": [
                "ssl",
                "https"
            ]
        },
        {
            "id": "https://www.oikiou.top/2022/77d62815/",
            "url": "https://www.oikiou.top/2022/77d62815/",
            "title": "Typora强制升级解决办法",
            "date_published": "2022-07-15T09:23:05.000Z",
            "content_html": "<h1 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h1><p>This beta version of Typora is expired, please download and install a newer version.</p>\n<p>解决typora强制升级问题</p>\n<blockquote>\n<p>This beta version of Typora is expired, please download and install a newer version.</p>\n</blockquote>\n<p>网上一堆的什么改时间改文件只读的办法都不太行, </p>\n<p>最后找到了改<code>buildtime</code>的办法成功解决了这个问题, </p>\n<p>有能力的请支持正版.</p>\n<p>测试环境是 <code>typora:0.11.18</code> 成功</p>\n<h1 id=\"详细\"><a href=\"#详细\" class=\"headerlink\" title=\"详细\"></a>详细</h1><blockquote>\n<p><a href=\"https://www.52pojie.cn/thread-1646214-1-1.html\">https://www.52pojie.cn/thread-1646214-1-1.html</a> (这里可以找到需要换掉的<code>app.asar</code>文件)</p>\n<p><a href=\"https://blog.51cto.com/liangdongchang/5357264\">https://blog.51cto.com/liangdongchang/5357264</a></p>\n</blockquote>\n<p>最简单的操作就是用破解<code>app.asar</code>文件替换掉原来的文件</p>\n<p>注意备份, 替换 <code>C:\\Program Files\\Typora\\resources\\app.asar</code>即可</p>\n<h1 id=\"鸣谢\"><a href=\"#鸣谢\" class=\"headerlink\" title=\"鸣谢\"></a>鸣谢</h1><p>感谢先驱<br><a href=\"https://github.com/fossabot/typoraCracker\">https://github.com/fossabot/typoraCracker</a></p>\n",
            "tags": [
                "typora"
            ]
        },
        {
            "id": "https://www.oikiou.top/2022/714f1d49/",
            "url": "https://www.oikiou.top/2022/714f1d49/",
            "title": "Windows下使用Makefile",
            "date_published": "2022-06-21T14:57:15.000Z",
            "content_html": "<h1 id=\"1-安装MinGW\"><a href=\"#1-安装MinGW\" class=\"headerlink\" title=\"1.安装MinGW\"></a>1.安装MinGW</h1><p>在MinGW的bin目录下有一个文件叫<code>mingw32-make.exe</code> 运行它就跟<code>make</code>指令类似</p>\n<p><img src=\"/2022/714f1d49/watermarkpic_center.png\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"2-CMD-终端运行Makefile-mingw32-make\"><a href=\"#2-CMD-终端运行Makefile-mingw32-make\" class=\"headerlink\" title=\"2. CMD 终端运行Makefile (mingw32-make)\"></a>2. CMD 终端运行Makefile (mingw32-make)</h1><p>在cmd终端下直接输入<code>mingw32-make</code>然后回车就可以进行编译了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">Microsoft Windows [版本 10.0.16299.967]<br>(c) 2017 Microsoft Corporation。保留所有权利。<br><br>D:\\Project\\Code\\C++\\hello&gt; mingw32-make.exe<br>g++    -c -o main.o main.cpp<br>g++ -std=c++17 -o main main.o<br></code></pre></td></tr></table></figure>\n",
            "tags": [
                "windows",
                "makefile"
            ]
        },
        {
            "id": "https://www.oikiou.top/2021/320cfc33/",
            "url": "https://www.oikiou.top/2021/320cfc33/",
            "title": "解决 Chrome由贵单位管理 惠普 谷歌浏览器 HP",
            "date_published": "2021-12-19T13:23:05.000Z",
            "content_html": "<p>关键词:<br>Chrome由贵单位管理 惠普 HP 谷歌浏览器 浏览器由所属组织管理</p>\n<h1 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h1><p>惠普 HP ProBook 450 G8 Notebook PC<br>WIndows10 19042.1415<br>谷歌浏览器 版本 96.0.4664.45（正式版本） （64 位）</p>\n<h1 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h1><ol>\n<li>网上说了很多删除注册表的答案,删除完了只是临时解决,重启后问题依旧,注册表被恢复<br> <code>\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Policies\\Google\\Chrome</code></li>\n<li>思路是找出谁访问修改了这一段注册表, 然后找到了 Process Monitor 软件, 发现注册表的修改是在开机的时候被修改的, 这个软件我也还不太会用, 不知道怎么样才能让他捕获到开机的修改, 随搜索相关文章, 最后发现居然是惠普的锅,简直离了个大谱.</li>\n<li>把这个服务关掉, 就可以解决问题, 我当时把它文件也删掉了!<br><img src=\"/2021/320cfc33/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Li05rW355qE5Z-O,size_20,color_FFFFFF,t_70,g_se,x_16.png\" alt=\"在这里插入图片描述\"></li>\n<li>批处理方案<figure class=\"highlight dos\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dos\">@<span class=\"hljs-built_in\">echo</span> off<br><span class=\"hljs-comment\">rem Automates instructions from google found here https://support.google.com/chrome/a/answer/9844476?hl=en</span><br><span class=\"hljs-comment\">rem Removes the &#x27;Managed by your organization&#x27; from Google Chrome and prevents persistence</span><br><span class=\"hljs-built_in\">echo</span> Make sure you have backed up your registry. Ready to go ahead?<br><span class=\"hljs-built_in\">pause</span><br><span class=\"hljs-built_in\">cls</span><br><span class=\"hljs-built_in\">echo</span> Working...<br><span class=\"hljs-built_in\">echo</span> Exiting Chrome (<span class=\"hljs-keyword\">if</span> running)<br><span class=\"hljs-built_in\">taskkill</span> /f /im chrome.exe<br><span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">exist</span> &quot;C:\\Program Files (x86)\\Google\\Policies&quot; <span class=\"hljs-built_in\">RMDIR</span> /S /Q &quot;C:\\Program Files (x86)\\Google\\Policies&quot;<br>reg delete HKEY_CURRENT_USER\\SOFTWARE\\Google\\Chrome /f /va <br>reg delete HKEY_LOCAL_MACHINE\\SOFTWARE\\Google\\Chrome /f /va <br>reg delete HKEY_LOCAL_MACHINE\\SOFTWARE\\Policies\\Google\\Chrome /f /va <br>reg delete HKEY_LOCAL_MACHINE\\SOFTWARE\\WOW6432Node\\Google\\Update\\ClientState\\&#123;<span class=\"hljs-number\">430</span>FD4D0-B729-<span class=\"hljs-number\">4</span>F61-AA34-<span class=\"hljs-number\">91526481799</span>D&#125; /f /va <br>reg delete HKEY_LOCAL_MACHINE\\SOFTWARE\\Policies\\Google\\Chrome\\ExtensionInstallForcelist /f<br><span class=\"hljs-built_in\">echo</span> Stopping and Disabling Sound Research Service<br>sc stop SECOMNService<br>sc config SECOMNService <span class=\"hljs-built_in\">start</span>= disabled<br><span class=\"hljs-built_in\">echo</span> Complete!<br><span class=\"hljs-built_in\">pause</span><br></code></pre></td></tr></table></figure></li>\n</ol>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://cihansol.com/blog/index.php/2021/07/17/uncovering-hps-potentially-unwanted-applications\">Uncovering HP’s Potentially Unwanted Applications(主要参考)</a><br><a href=\"https://support.google.com/chrome/a/answer/9844476?hl=en#zippy=,windows\">Stop managing Chrome browser</a><br><a href=\"https://meta.appinn.net/t/topic/26165\">https://meta.appinn.net/t/topic/26165</a></p>\n<h1 id=\"吐槽\"><a href=\"#吐槽\" class=\"headerlink\" title=\"吐槽\"></a>吐槽</h1><p><del>吐槽CSDN的Markdown好难用啊,为什么一删除换行把前面的也删除了? 写个github还被审核未通过? 是时候考虑一些别的方案了</del> </p>\n",
            "tags": [
                "hp",
                "chrome"
            ]
        },
        {
            "id": "https://www.oikiou.top/2021/db5fa6fe/",
            "url": "https://www.oikiou.top/2021/db5fa6fe/",
            "title": "解决 Github 无法打开",
            "date_published": "2021-10-15T15:23:05.000Z",
            "content_html": "<h1 id=\"解决-Github-无法打开\"><a href=\"#解决-Github-无法打开\" class=\"headerlink\" title=\"解决 Github 无法打开\"></a>解决 Github 无法打开</h1><h2 id=\"SwitchHosts\"><a href=\"#SwitchHosts\" class=\"headerlink\" title=\"SwitchHosts\"></a>SwitchHosts</h2><ol>\n<li><p>下载 SwitchHosts <a href=\"https://github.com/oldj/SwitchHosts\">Github</a> 下载要是太慢可以 用gitee镜像一下github的库 这里放一个别人镜像过的 <a href=\"https://gitee.com/itas109/SwitchHosts?_from=gitee_search\">Gitee</a></p>\n</li>\n<li><p>安装后新建一个配置</p>\n<ul>\n<li>Title: 随意  Type: Remote  URL:   Auto Refresh: 最好选 1 hour</li>\n</ul>\n<p><img src=\"/2021/db5fa6fe/image-20211015220230835.png\" alt=\"image-20211015220230835\"></p>\n<ul>\n<li>可选的URL：<ul>\n<li>520Github <a href=\"https://raw.hellogithub.com/hosts\">https://raw.hellogithub.com/hosts</a></li>\n<li>ineo6 <a href=\"https://gitee.com/ineo6/hosts/raw/master/hosts\">https://gitee.com/ineo6/hosts/raw/master/hosts</a></li>\n<li>有看到网上还有多个网站同时更新的，但是看到更新速度不够快，也就放弃了。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://github.com/ineo6/hosts\">https://github.com/ineo6/hosts</a></p>\n<p><a href=\"https://github.com/521xueweihan/GitHub520\">https://github.com/521xueweihan/GitHub520</a></p>\n<h2 id=\"Chrome-插件方式\"><a href=\"#Chrome-插件方式\" class=\"headerlink\" title=\"Chrome 插件方式\"></a>Chrome 插件方式</h2><p><a href=\"https://github.com/gauseen/faster-hosts\">FasterHosts</a> 是个 Chrome 插件，主要原理是拦截浏览器的某些请求，将 <code>domain</code> 替换成访问速度较快的那个。hosts 资源来自 <a href=\"https://github.com/521xueweihan/GitHub520\">GitHub520</a>，每 1 小时更新一次。</p>\n<blockquote>\n<ol>\n<li>下载 <a href=\"https://github.com/gauseen/faster-hosts/archive/master.zip\">FasterHosts</a> 然后解压，找到 <code>extension</code> 子目录</li>\n<li>打开 Chrome，输入: <code>chrome://extensions/</code></li>\n<li>打开「开发者模式」</li>\n<li>选择「加载已解压的扩展程序」，然后定位到刚才解压的文件夹里面的 <code>extension</code> 目录，确定</li>\n<li>这就安装好了，关闭「开发者模式」</li>\n</ol>\n</blockquote>\n",
            "tags": [
                "github",
                "hosts"
            ]
        },
        {
            "id": "https://www.oikiou.top/2021/d3f98b78/",
            "url": "https://www.oikiou.top/2021/d3f98b78/",
            "title": "Hex 文件格式解析",
            "date_published": "2021-09-24T12:27:40.000Z",
            "content_html": "<h1 id=\"Hex-文件格式解析\"><a href=\"#Hex-文件格式解析\" class=\"headerlink\" title=\"Hex 文件格式解析\"></a>Hex 文件格式解析</h1><h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://developer.arm.com/documentation/ka003292/1-0\">Intel HEX File Format Keil</a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/Intel_HEX\">Intel HEX Wiki</a></p>\n<h2 id=\"格式\"><a href=\"#格式\" class=\"headerlink\" title=\"格式\"></a>格式</h2><ul>\n<li>以行为单位，每行以冒号开头，内容全部为16进制码（以ASCII码形式显示）</li>\n<li>在HEX文件里面，每一行代表一个记录。记录的基本格式为如表所示</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><strong>冒号</strong></th>\n<th><strong>本行数据长度</strong></th>\n<th><strong>本行数据起始地址</strong></th>\n<th><strong>数据类型</strong></th>\n<th><strong>数据</strong></th>\n<th><strong>校验码</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td>1 byte</td>\n<td>2 bytes</td>\n<td>1 byte</td>\n<td>n byte</td>\n<td>1 byte</td>\n</tr>\n</tbody></table>\n<p><img src=\"/2021/d3f98b78/hex_format.jpg\" alt=\"Hex文件格式解析\"></p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Start code</td>\n<td>one character, an ASCII colon ‘:’</td>\n</tr>\n<tr>\n<td>Byte count</td>\n<td>两个十六进制数字（一个十六进制数字对），表示数据字段中的字节数（十六进制数字对）。最大字节数为 255 (0xFF)。16 (0x10) 和 32 (0x20) 是常用的字节数。</td>\n</tr>\n<tr>\n<td>Address</td>\n<td>四位十六进制数字，表示数据的 16 位起始内存地址偏移量。数据的物理地址是通过将此偏移量添加到先前建立的基地址来计算的，从而允许内存寻址超出 16 位地址的 64 KB 限制。默认为零的基地址可以通过各种类型的记录进行更改。基地址和地址偏移量始终表示为<a href=\"https://en.wikipedia.org/wiki/Big_endian\">大端</a>值。</td>\n</tr>\n<tr>\n<td>Record type</td>\n<td>两个十六进制数字，<em>00</em>到<em>05</em>，定义数据字段的含义。参考下文</td>\n</tr>\n<tr>\n<td>Data</td>\n<td>一个由<em>n</em>个字节组成的数据序列，由 <em>2n</em> 个十六进制数字表示。一些记录省略了这个字段（<em>n</em>等于零）。数据字节的含义和解释取决于应用程序。</td>\n</tr>\n<tr>\n<td>Checksum</td>\n<td>two hex digits, a computed value that can be used to verify the record has no errors.计算校验和前所有16进制码的累加和。</td>\n</tr>\n</tbody></table>\n<h3 id=\"指令类型-Record-type\"><a href=\"#指令类型-Record-type\" class=\"headerlink\" title=\"指令类型 Record type\"></a>指令类型 Record type</h3><p>指令类型<code>Record type</code>的值一般是<code>00~05</code>，这表示了，当前这行<code>hex</code>格式的数据，所代表的含义：</p>\n<table>\n<thead>\n<tr>\n<th>十六进制代码</th>\n<th>记录类型</th>\n<th align=\"center\">描述</th>\n<th align=\"center\">Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>00</strong></td>\n<td>数据</td>\n<td align=\"center\">包含数据和该数据的16位起始地址。字节计数指定记录中的数据字节数。右侧显示的示例为0B （十一）个数据字节（61， 64， 64， 72， 65， 73， 73， 20， 67， 61， 70）位于以地址开头的连续地址 0010。</td>\n<td align=\"center\"><code>:0B 0010 00 6164647265737320676170 A7</code></td>\n</tr>\n<tr>\n<td><strong>01</strong></td>\n<td>文件结束</td>\n<td align=\"center\">每个文件在文件的最后一行必须恰好发生一次。数据字段为空（因此字节数为00），并且地址字段通常为 0000。</td>\n<td align=\"center\"><code>:00 0000 01 FF</code></td>\n</tr>\n<tr>\n<td><strong>02</strong></td>\n<td>扩展段地址</td>\n<td align=\"center\">数据字段包含一个16位的段基址（因此字节数始终为02）与80x86实模式寻址兼容。地址字段（通常为0000）被忽略。最近的段地址02记录乘以16，然后加到每个后续数据记录地址，以形成数据的物理起始地址。这允许寻址多达1 MB的地址空间。</td>\n<td align=\"center\"><code>:02 0000 02 1200 EA</code></td>\n</tr>\n<tr>\n<td><strong>03</strong></td>\n<td>起始段地址</td>\n<td align=\"center\">对于80x86处理器，请指定CS：IP寄存器的初始内容（即起始执行地址）。地址字段是0000，字节数始终为04，前两个数据字节是CS值，后两个是IP值。</td>\n<td align=\"center\"><code>:04 0000 03 00003800 C1</code></td>\n</tr>\n<tr>\n<td><strong>04</strong></td>\n<td>扩展线性地址</td>\n<td align=\"center\">允许32位寻址（最大4GiB）。记录的地址字段将被忽略（通常是0000），其字节数始终为02。两个数据字节（大字节序）为所有后续类型指定32位绝对地址的高16位00记录; 这些高位地址位适用于下一个04记录。类型的绝对地址00 通过组合最近的高16位地址位形成记录 04 用低16位的地址记录 00记录。如果是类型00 记录之前没有任何类型 04 记录，然后其高16位地址位默认为0000。</td>\n<td align=\"center\"><code>:02 0000 04 FFFF FC</code></td>\n</tr>\n<tr>\n<td><strong>05</strong></td>\n<td>起始线性地址</td>\n<td align=\"center\">地址字段是 0000（未使用），字节数始终为04。四个数据字节代表一个32位地址值（big-endian）。对于80386和更高版本的CPU，此地址将加载到EIP寄存器中。<br/><strong>（仅限 MDK-ARM）</strong>起始线性地址记录指定应用程序的起始地址。这些记录包含完整的线性 32 位地址。</td>\n<td align=\"center\"><code>:04 0000 05 000000CD 2A</code></td>\n</tr>\n</tbody></table>\n<h5 id=\"扩展线性地址记录-HEX386\"><a href=\"#扩展线性地址记录-HEX386\" class=\"headerlink\" title=\"扩展线性地址记录 (HEX386)\"></a>扩展线性地址记录 (HEX386)</h5><p>扩展线性地址记录也称为 32 位地址记录和 HEX386 记录。这些记录包含数据地址的高 16 位（位 16-31）。扩展线性地址记录总是有两个数据字节，如下所示：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">:02000004FFFFFC<br></code></pre></td></tr></table></figure>\n\n<p>在哪里：</p>\n<ul>\n<li><strong>02</strong>是记录中的数据字节数。</li>\n<li><strong>0000</strong>是地址字段。对于扩展线性地址记录，此字段始终为 0000。</li>\n<li><strong>04</strong>是记录类型 04（扩展的线性地址记录）。</li>\n<li><strong>FFFF</strong>是地址的高 16 位。</li>\n<li><strong>FC</strong>是记录的校验和，计算方式为<br>01h + NOT(02h + 00h + 00h + 04h + FFh + FFh)。</li>\n</ul>\n<p>读取扩展线性地址记录时，存储在数据字段中的扩展线性地址将被保存并应用于从 Intel HEX 文件读取的后续记录。线性地址保持有效，直到被另一个扩展地址记录改变。</p>\n<p>数据记录的绝对内存地址是通过将记录中的地址字段与扩展线性地址记录的移位地址数据相加得到的。下面的例子说明了这个过程。</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs haskell\"><span class=\"hljs-type\">Address</span> from the <span class=\"hljs-class\"><span class=\"hljs-keyword\">data</span> record&#x27;s address field      2462</span><br><span class=\"hljs-type\">Extended</span> linear address record <span class=\"hljs-class\"><span class=\"hljs-keyword\">data</span> field     <span class=\"hljs-type\">FFFF</span></span><br>                                              <span class=\"hljs-comment\">--------</span><br><span class=\"hljs-type\">Absolute</span>-memory address                       <span class=\"hljs-type\">FFFF2462</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"扩展段地址记录-HEX86\"><a href=\"#扩展段地址记录-HEX86\" class=\"headerlink\" title=\"扩展段地址记录 (HEX86)\"></a>扩展段地址记录 (HEX86)</h5><p>扩展段地址记录（也称为 HEX86 记录）包含数据地址段的第 4-19 位。扩展段地址记录总是有两个数据字节，如下所示：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">:020000021200EA<br></code></pre></td></tr></table></figure>\n\n<p>在哪里：</p>\n<ul>\n<li><strong>02</strong>是记录中的数据字节数。</li>\n<li><strong>0000</strong>是地址字段。对于扩展段地址记录，该字段始终为 0000。</li>\n<li><strong>02</strong>是记录类型 02（扩展段地址记录）。</li>\n<li><strong>1200</strong>是地址段。</li>\n<li><strong>EA</strong>是记录的校验和，计算方式为<br>01h + NOT(02h + 00h + 00h + 02h + 12h + 00h)。</li>\n</ul>\n<p>当读取扩展段地址记录时，存储在数据字段中的扩展段地址被保存并应用于从 Intel HEX 文件读取的后续记录。段地址保持有效，直到被另一个扩展地址记录改变。</p>\n<p>数据记录的绝对内存地址是通过将记录中的地址字段添加到来自扩展段地址记录的移位地址数据中获得的。以下示例说明了此过程。</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs haskell\"><span class=\"hljs-type\">Address</span> from the <span class=\"hljs-class\"><span class=\"hljs-keyword\">data</span> record&#x27;s address field     2462</span><br><span class=\"hljs-type\">Extended</span> segment address record <span class=\"hljs-class\"><span class=\"hljs-keyword\">data</span> field      1200</span><br>                                             <span class=\"hljs-comment\">--------</span><br><span class=\"hljs-type\">Absolute</span> memory address                      <span class=\"hljs-number\">00014462</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"起始线性地址记录（仅限-MDK-ARM）\"><a href=\"#起始线性地址记录（仅限-MDK-ARM）\" class=\"headerlink\" title=\"起始线性地址记录（仅限 MDK-ARM）\"></a>起始线性地址记录（仅限 MDK-ARM）</h5><p>起始线性地址记录指定应用程序的起始地址。这些记录包含完整的线性 32 位地址。起始线性地址记录总是有四个数据字节，如下所示：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">:04000005000000CD2A<br></code></pre></td></tr></table></figure>\n\n<p>在哪里：</p>\n<ul>\n<li><strong>04</strong>是记录中的数据字节数。</li>\n<li><strong>0000</strong>是地址字段。对于起始线性地址记录，该字段始终为 0000。</li>\n<li><strong>05</strong>是记录类型 05（起始线性地址记录）。</li>\n<li><strong>000000CD</strong>是应用程序的 4 字节线性起始地址。</li>\n<li><strong>2A</strong>是记录的校验和，计算方式为<br>01h + NOT(04h + 00h + 00h + 05h + 00h + 00h + 00h + CDh)。</li>\n</ul>\n<p>Start Linear Address 指定了 __main（pre-main）函数的地址，而不是通常在调用 SystemInit() 之后调用 __main 的启动代码的地址。奇数线性起始地址指定 __main 是为 Thumb 指令集编译的。</p>\n<p>起始线性地址记录可以出现在 hex 文件中的任何位置。在大多数情况下，可以忽略此记录，因为它不包含对闪存进行编程所需的信息。</p>\n<h5 id=\"文件结束-EOF-记录\"><a href=\"#文件结束-EOF-记录\" class=\"headerlink\" title=\"文件结束 (EOF) 记录\"></a>文件结束 (EOF) 记录</h5><p>英特尔 HEX 文件必须以文件结束 (EOF) 记录结尾。此记录在记录类型字段中必须具有值 01。EOF 记录始终如下所示：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">:00000001FF<br></code></pre></td></tr></table></figure>\n\n<p>在哪里：</p>\n<ul>\n<li><strong>00</strong>是记录中的数据字节数。</li>\n<li><strong>0000</strong>是数据在内存中的位置。文件尾记录中的地址是无意义的并且被忽略。地址 0000h 是典型的。</li>\n<li><strong>01</strong>是记录类型 01（文件结束记录）。</li>\n<li><strong>FF</strong>是记录的校验和，计算方式为<br>01h + NOT(00h + 00h + 00h + 01h)。</li>\n</ul>\n<h2 id=\"tip\"><a href=\"#tip\" class=\"headerlink\" title=\"tip\"></a>tip</h2><ul>\n<li><strong>用Notepad++打开hex文件，会自动上色、换行</strong></li>\n</ul>\n",
            "tags": [
                "hex"
            ]
        },
        {
            "id": "https://www.oikiou.top/2021/2c1a46d6/",
            "url": "https://www.oikiou.top/2021/2c1a46d6/",
            "title": "XIP 片内执行 eXecute in Place",
            "date_published": "2021-09-24T12:23:05.000Z",
            "content_html": "<h1 id=\"XIP-eXecute-In-Place\"><a href=\"#XIP-eXecute-In-Place\" class=\"headerlink\" title=\"XIP   eXecute In Place\"></a>XIP   eXecute In Place</h1><h2 id=\"含义\"><a href=\"#含义\" class=\"headerlink\" title=\"含义\"></a>含义</h2><p>eXecute In Place，即芯片内执行，是指CPU直接从存储器中读取程序代码执行。</p>\n<p>应用程序可以直接在flash闪存内运行，不必再把代码读到系统RAM中。flash内执行是指nor flash不需要初始化，可以直接在flash内执行代码。但往往<strong>只执行部分代码</strong>，比如<strong>初始化RAM</strong>。好处即是程序代码无需占用内存，减少内存的要求。</p>\n<p><strong>所谓片内执行不是说程序在存储器内执行，CPU的基本功能是取指、译码、运行。Nor Flash能在芯片内执行，指的是CPU能够直接从Nor flash中取指令，供后面的译码器和执行器来使用。</strong></p>\n<p>为实现XIP，必须满足几个条件：</p>\n<ol>\n<li><p>存储器必须提供与内存相似的接口给CPU。</p>\n</li>\n<li><p>该接口必须提供足够快的读取操作，并具有随机访问模式。</p>\n</li>\n<li><p>如有文件系统，则需要提供合适的映射功能</p>\n</li>\n<li><p>程序链接时需要知道存储器的地址或地址与位置无关。</p>\n</li>\n<li><p>程序不能修改已加载映像中的数据。</p>\n</li>\n</ol>\n<p>NOR Flash和EEPROM通常能满足上述要求。</p>\n<h2 id=\"Tip\"><a href=\"#Tip\" class=\"headerlink\" title=\"Tip\"></a>Tip</h2><p><strong>nandflash也可以实现XIP</strong></p>\n<p>“所谓XIP,就是CODE是在FLASH上直接运行. NANDFLASH只是不适合做XIP,但并不是不能做XIP“要一段CODE能够正确的运行,要保证它的CODE是连续的,正确的.由于一些电气特性的原因,NOR FLASH能够做到这一点,不存在坏道或坏块,所以能够做XIP.</p>\n<p><strong>NOR Flash 和 NAND Flash</strong></p>\n<p>NOR Flash具备随机读取给一个地址就能读一个数据，NAND Flash是一次读一块数据，一个地址读出一块数据。</p>\n",
            "tags": [
                "xip",
                "nor",
                "nand"
            ]
        },
        {
            "id": "https://www.oikiou.top/2021/aaef73f3/",
            "url": "https://www.oikiou.top/2021/aaef73f3/",
            "title": "WS2812驱动 SPI+DMA 无需降频 一个灯占用9Byte的RAM",
            "date_published": "2021-01-31T06:23:05.000Z",
            "content_html": "<h1 id=\"WS2812驱动-STM32F103-SPI-DMA-无需降频-一个灯占用9Byte的RAM\"><a href=\"#WS2812驱动-STM32F103-SPI-DMA-无需降频-一个灯占用9Byte的RAM\" class=\"headerlink\" title=\"WS2812驱动 STM32F103 SPI+DMA 无需降频 一个灯占用9Byte的RAM\"></a>WS2812驱动 STM32F103 SPI+DMA 无需降频 一个灯占用9Byte的RAM</h1><p>对于WS2812不了解的朋友可以先看一下这些<br>​<a href=\"https://www.cnblogs.com/PureHeart/p/11349495.html\">【STM32】WS2812介绍、使用SPI+DMA发送数据</a><br><img src=\"/2021/aaef73f3/pic_center.png\" alt=\"ws812\"></p>\n<p>WS2812的驱动我想到的主要有三种</p>\n<ul>\n<li>延时</li>\n<li>SPI</li>\n<li>UART<br><strong>三者区分：</strong></li>\n</ul>\n<ol>\n<li>延时，占用资源，需要用到ASM nop不然容易被优化，需要用示波器抓时间。</li>\n<li>UART 起始位低，结束位高，如果要强行实现也是可以但是实现起来过于复杂，不够优美。</li>\n<li>没有片选的功能，会占用一整个硬件SPI，觉得较为优美。</li>\n</ol>\n<p>在网上看了很多SPI例子都是使用 SPI的8bit数据来模拟WS2812的一个bit颜色的数据，但是由于STM32F103主频72M，要凑出来这个SPI的频率我看某些做法是进行降频，吾不喜，要么还有就是和协议时序差异挺大但是有些WS2812能运行，但是考虑到可能有些ws2812会不能兼容，吾不喜。</p>\n<p>STM32F103 设主频72M，SPI分频数设置为32，则SPI的通信频率为2.25M，传输一位数据的时间约为444纳秒（ns）444ns 888ns 符合WS281X芯片的通信时序。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">//  __</span><br><span class=\"hljs-comment\">// |  |_|   0b110  high level</span><br><span class=\"hljs-comment\">//  _   </span><br><span class=\"hljs-comment\">// | |__|   0b100  low level</span><br></code></pre></td></tr></table></figure>\n<p><strong>这个方式和协议时序更加接近，占用RAM应该是笔者认为最小的了</strong><br>一个灯24bit颜色，只需要24*3&#x2F;8 &#x3D; 9Byte的Buff。</p>\n<p><strong>写代码的时候需要注意一下大小端的问题，尽量保持大小端的兼容性</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * @brief 设置某一个WS2812</span><br><span class=\"hljs-comment\"> * </span><br><span class=\"hljs-comment\"> * @param num </span><br><span class=\"hljs-comment\"> * @param RGB </span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">WS2812_OneSet</span><span class=\"hljs-params\">( <span class=\"hljs-type\">uint8_t</span> num, <span class=\"hljs-type\">uint32_t</span> RGB )</span><br>&#123;<br>    <span class=\"hljs-type\">uint8_t</span> i;<br>    <span class=\"hljs-type\">uint32_t</span> TempR = <span class=\"hljs-number\">0</span>, TempG = <span class=\"hljs-number\">0</span>, TempB = <span class=\"hljs-number\">0</span>;<br><br>    <span class=\"hljs-comment\">//MSB First</span><br>    <span class=\"hljs-keyword\">for</span>( i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">8</span>; ++i,RGB&gt;&gt;=<span class=\"hljs-number\">1</span> )<br>    &#123;<br>        (RGB &amp; <span class=\"hljs-number\">0x00010000</span>) != <span class=\"hljs-number\">0</span> ? (TempR |= (WS2812_HIG&lt;&lt;(i*<span class=\"hljs-number\">3</span>))) : (TempR |= (WS2812_LOW&lt;&lt;(i*<span class=\"hljs-number\">3</span>)));<br>        (RGB &amp; <span class=\"hljs-number\">0x00000100</span>) != <span class=\"hljs-number\">0</span> ? (TempG |= (WS2812_HIG&lt;&lt;(i*<span class=\"hljs-number\">3</span>))) : (TempG |= (WS2812_LOW&lt;&lt;(i*<span class=\"hljs-number\">3</span>)));<br>        (RGB &amp; <span class=\"hljs-number\">0x00000001</span>) != <span class=\"hljs-number\">0</span> ? (TempB |= (WS2812_HIG&lt;&lt;(i*<span class=\"hljs-number\">3</span>))) : (TempB |= (WS2812_LOW&lt;&lt;(i*<span class=\"hljs-number\">3</span>)));<br>    &#125;<br><br>    <span class=\"hljs-keyword\">for</span>( i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">3</span>; ++i )<br>    &#123;<br>        g_ws2812.Col[num].RGB.R[i] = TempR &gt;&gt; (<span class=\"hljs-number\">16</span><span class=\"hljs-number\">-8</span>*i);<br>        g_ws2812.Col[num].RGB.G[i] = TempG &gt;&gt; (<span class=\"hljs-number\">16</span><span class=\"hljs-number\">-8</span>*i);<br>        g_ws2812.Col[num].RGB.B[i] = TempB &gt;&gt; (<span class=\"hljs-number\">16</span><span class=\"hljs-number\">-8</span>*i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这里有参考的代码，有积分的给点积分用吧，没积分的可以去Github下。<br><a href=\"https://github.com/Jack-InGitHub/WS2812\">Github</a><br><a href=\"https://download.csdn.net/download/weixin_42078116/14975868\">CSDN下载</a></p>\n<p>参考资料<br><a href=\"https://www.amobbs.com/thread-5697122-1-1.html?_dsign=01c8809d\">stm32和ws2812B相对较好的方案。SPI和UART </a></p>\n",
            "tags": [
                "ws2812",
                "spi",
                "dma"
            ]
        }
    ]
}
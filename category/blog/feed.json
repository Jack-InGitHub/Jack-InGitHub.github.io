{
    "version": "https://jsonfeed.org/version/1",
    "title": "Oikiou's Blog • All posts by \"blog\" category",
    "description": "Blog",
    "home_page_url": "https://www.oikiou.top",
    "items": [
        {
            "id": "https://www.oikiou.top/2025/87426b16/",
            "url": "https://www.oikiou.top/2025/87426b16/",
            "title": "ESP32 Develop",
            "date_published": "2025-07-03T12:42:16.256Z",
            "content_html": "<h1 id=\"ESP32\"><a href=\"#ESP32\" class=\"headerlink\" title=\"ESP32\"></a>ESP32</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">idf.py set-target esp32c3<br><br>idf.py menuconfig<br><br>idf.py build<br><br>idf.py -p COM12 flash moniter<br></code></pre></td></tr></table></figure>\n\n\n\n\n\n<h1 id=\"IDF\"><a href=\"#IDF\" class=\"headerlink\" title=\"IDF\"></a>IDF</h1><h2 id=\"组件管理器-The-ESP-Component-Registry\"><a href=\"#组件管理器-The-ESP-Component-Registry\" class=\"headerlink\" title=\"组件管理器 The ESP Component Registry\"></a>组件管理器 The ESP Component Registry</h2><p><a href=\"https://components.espressif.com/\">https://components.espressif.com/</a></p>\n<h3 id=\"create-manifest\"><a href=\"#create-manifest\" class=\"headerlink\" title=\"create-manifest\"></a>create-manifest</h3><ul>\n<li><code>idf.py create-manifest</code> 为 main 组件创建清单文件</li>\n<li><code>idf.py create-manifest --component=my_component</code> 在 <code>components</code> 目录下，为组件 <strong>my_component</strong> 创建清单文件</li>\n<li><code>idf.py create-manifest --path=&quot;../../my_component&quot;</code> 在 <code>my_component</code> 目录下，为组件 <strong>my_component</strong> 创建清单文件</li>\n</ul>\n<p>在向项目的某个组件添加新的清单时，必须先运行 <code>idf.py reconfigure</code>，手动重新配置项目。</p>\n<h3 id=\"add-dependency\"><a href=\"#add-dependency\" class=\"headerlink\" title=\"add-dependency\"></a>add-dependency</h3><p>要为 ESP-IDF 项目中的组件（如 <code>my_component</code>）添加依赖项，可以运行命令 <code>idf.py add-dependency DEPENDENCY</code>。<br><code>DEPENDENCY</code> 参数代表一个由 IDF 组件管理器管理的额外组件，而 <code>my_component</code> 也依赖于这个组件。<code>DEPENDENCY</code> 参数的格式为 <code>namespace/name=1.0.0</code>，namespace&#x2F;name 代表组件名称，&#x3D;1.0.0 是组件的版本范围，详情请参阅 <a href=\"https://docs.espressif.com/projects/idf-component-manager/en/latest/reference/versioning.html\">版本文档</a>。</p>\n<h3 id=\"直接编辑\"><a href=\"#直接编辑\" class=\"headerlink\" title=\"直接编辑\"></a>直接编辑</h3><p>通过在文本编辑器直接编辑，你可以轻松定义清单文件 <code>idf_component.yml</code> 中的依赖项。</p>\n",
            "tags": [
                "embedded",
                "esp32",
                "idf"
            ]
        },
        {
            "id": "https://www.oikiou.top/2024/2f262a28/",
            "url": "https://www.oikiou.top/2024/2f262a28/",
            "title": "音视频编解码",
            "date_published": "2024-07-21T08:23:05.000Z",
            "content_html": "<h1 id=\"视频显示原理\"><a href=\"#视频显示原理\" class=\"headerlink\" title=\"视频显示原理\"></a>视频显示原理</h1><p>视频是利用人眼视觉暂留的原理，通过播放一系列的图片，使人眼产生运动的感觉。单纯传输视频画面，视频量非常大，对现有的网络和存储来说是不可接受的。为了能够使视频便于传输和存储，人们发现视频有大量重复的信息，如果将重复信息在发送端去掉，在接收端恢复出来，这样就大大减少了视频数据的文件，因此有了各种视频压缩标准。</p>\n<h1 id=\"视频编码\"><a href=\"#视频编码\" class=\"headerlink\" title=\"视频编码\"></a>视频编码</h1><p><a href=\"https://www.cnblogs.com/yongdaimi/p/10676309.html\">参考 I帧、P帧、B帧、GOP、IDR 和PTS, DTS之间的关系</a><br><a href=\"https://blog.csdn.net/BigDream123/article/details/120329879\">视频编码基础：I帧、P帧 和 B 帧</a></p>\n<blockquote>\n<p>拓展知识：视频编码方式<br>H.26x（由ITU[国际电传视讯联盟]主导）<br>MPEG-x （由ISO[国际标准组织机构]下属的MPEG[运动图象专家组]开发）<br>VP-x （Google开发的开源视频编码格式）<br>AV1 （由Alliance for Open Media 开放媒体联盟，开发的一种开源视频编码格式）</p>\n<ul>\n<li><strong>MPEG-4</strong> 与H.264诞生了H.264&#x2F;AVC标准</li>\n<li><strong>H.264&#x2F;AVC</strong> H.264&#x2F;MPEG-4第十部分，或称AVC（Advanced Video Coding，高级视频编码）</li>\n<li><strong>H.265&#x2F;HEVC</strong> （High Efficiency Video Coding，简称HEVC）H.264的继任者，最高分辨率可达到8192×4320，HEVC被认为不仅提升图像质量，同时也能达到<strong>H.264&#x2F;MPEG-4</strong> AVC两倍之压缩率。唯一的潜在缺点是许可系统有点复杂。</li>\n<li><strong>H.266&#x2F;VVC</strong>  Versatile Video Coding H.266 的开发目的是超越 H.265。但仍然存在一些与前身类似的许可和版税问题需要解决。与 H.265 相比，在相同的感知质量下，H.266 能够将比特率降低 30% 至 50%。</li>\n<li><strong>VP9</strong> VP9 作为 VP8 的后继产品，主要竞争对手是 MPEG 的高效视频编码标准 HEVC。</li>\n<li><strong>AV1</strong> 旨在提供更高效的压缩和更好的视频质量。它免版税且开源，效率比 VP9 高 30%。</li>\n</ul>\n<p>对比：</p>\n<ol>\n<li>压缩效率：H.265和AV1相对于H.264、MPEG-2、MPEG-4和VP9具有更高的压缩效率，可以在相同的视频质量下减少更多的码率，从而减少带宽和存储需求。</li>\n<li>支持的分辨率和帧率：H.264、MPEG-2、MPEG-4和VP9支持较低的分辨率和帧率，而H.265和AV1支持更高的分辨率和帧率，例如4K和8K视频。</li>\n<li>编码延迟：H.265和AV1相对于H.264、MPEG-2、MPEG-4和VP9具有更高的编码延迟，这意味着它们需要更长的时间来编码视频，这可能会影响实时视频流应用。</li>\n<li><strong>编码复杂度</strong>：H.265和AV1相对于H.264、MPEG-2、MPEG-4和VP9具有更高的编码复杂度，这意味着需要更强的计算能力来进行编码。</li>\n<li>开放性：AV1是一种开放标准，由多个公司和组织共同开发，可以免费使用，而H.264、H.265、MPEG-2、MPEG-4和VP9则有专利和版权限制。<br>AV1和H.265的压缩比较高，所以编码较为复杂，延迟较高，计算量更高。</li>\n</ol>\n<p><strong>需要注意的是 MKV MP4 AVI 等等这些是音视频容器，和视频编码不是一个概念，视频容器是用来盛放各种视频流、音频流、字幕等等数据的“容器”。不同的容器里面可能包含着相同的视频流。</strong></p>\n</blockquote>\n<p>编码器将多张图像进行编码后生产成一段一段的 GOP ( Group of Pictures ) ， 解码器在播放时则是读取一段一段的 GOP 进行解码后读取画面再渲染显示。<br>GOP ( Group of Pictures) 是一组连续的画面，由一张 I 帧和数张 B &#x2F; P 帧组成，是视频图像编码器和解码器存取的基本单位，它的排列顺序将会一直重复到影像结束。</p>\n<ul>\n<li><strong>I 帧</strong>是内部编码帧（也称为关键帧）是一个完整的图像帧，它独立于其他帧存在。I帧不依赖于其他帧的信息即可独立解码，类似于静态图像，可以视为视频序列中的一个参考点。由于I帧包含了完整的图像信息，其压缩率相对较低，但在解码时最为简单，因为它不涉及对其他帧的依赖。</li>\n<li><strong>P 帧</strong>是前向预测帧（前向参考帧）依赖于前面的I帧或P帧来生成。P帧存储的是与前一帧相比图像的变化量，因此它的压缩效果通常比I帧更好。在解码P帧时，需要先解码它所依赖的I帧或P帧，然后根据这些信息来重建当前帧的画面。P帧的引入有效减少了时间维度上的冗余，提高了视频的压缩效率。</li>\n<li><strong>B 帧</strong>是双向内插帧（双向参考帧）需要参考前后的I帧或P帧来生成。B帧利用前后帧的信息来预测当前帧的内容，从而实现更高的压缩比。由于B帧的解码需要前后帧的信息，它不能独立解码，必须在解码序列中结合I帧和P帧来完成。<br>简单地讲，I 帧是一个完整的画面，而 P 帧和 B 帧记录的是相对于 I 帧的变化。如果没有 I 帧，P 帧和 B 帧就无法解码。</li>\n</ul>\n<p>在H.264压缩标准中I帧、P帧、B帧用于表示传输的视频画面。<br><img src=\"/2024/2f262a28/image-20240721152541316.png\"></p>\n<h2 id=\"GOP-和-IDR\"><a href=\"#GOP-和-IDR\" class=\"headerlink\" title=\"GOP 和 IDR\"></a>GOP 和 IDR</h2><p>在H264中图像以<strong>序列</strong>为单位进行组织，一个序列是一段图像编码后的数据流。<br>一个序列的第一个图像叫做 <strong>IDR 图像</strong>（<strong>立即刷新图像</strong>），IDR 图像都是 I 帧图像。H.264 引入 IDR 图像是为了解码的重同步，当解码器解码到 IDR 图像时，立即将参考帧队列清空，将已解码的数据全部输出或抛弃，重新查找参数集，开始一个新的序列。这样，如果前一个序列出现重大错误，在这里可以获得重新同步的机会。IDR图像之后的图像永远不会使用IDR之前的图像的数据来解码。<br>一个序列就是一段内容差异不太大的图像编码后生成的一串数据流。当运动变化比较少时，一个序列可以很长，因为运动变化少就代表图像画面的内容变动很小，所以就可以编一个I帧，然后一直P帧、B帧了。当运动变化多时，可能一个序列就比较短了，比如就包含一个I帧和3、4个P帧。<br>在视频编码序列中，GOP即Group of picture（<strong>图像组</strong>），指两个I帧之间的距离，Reference（<strong>参考周期</strong>）指两个P帧之间的距离。两个I帧之间形成一组图片，就是GOP（Group Of Picture）。</p>\n<p>【GOP示意图】<br><img src=\"/2024/2f262a28/image-20240721161215632.png\" alt=\"alt\"></p>\n<h2 id=\"I帧\"><a href=\"#I帧\" class=\"headerlink\" title=\"I帧\"></a>I帧</h2><p>I帧:即Intra-coded picture（<strong>帧内编码图像帧</strong>），I帧表示关键帧，你可以理解为这一帧画面的完整保留；解码时只需要本帧数据就可以完成（因为包含完整画面）。又称为内部画面 (intra picture)，I 帧通常是每个 GOP（MPEG 所使用的一种视频压缩技术）的第一个帧，经过适度地压缩，做为随机访问的参考点，可以当成图象。在MPEG编码的过程中，部分视频帧序列压缩成为I帧；部分压缩成P帧；还有部分压缩成B帧。I帧法是帧内压缩法，也称为“关键帧”压缩法。I帧法是基于离散余弦变换DCT（Discrete Cosine Transform）的压缩技术，这种算法与JPEG压缩算法类似。采用I帧压缩可达到1&#x2F;6的压缩比而无明显的压缩痕迹。</p>\n<p>【<strong>I帧特点</strong>】<br>　　1.它是一个全帧压缩编码帧。它将全帧图像信息进行JPEG压缩编码及传输;<br>　　2.解码时仅用I帧的数据就可重构完整图像;<br>　　3.I帧描述了图像背景和运动主体的详情;<br>　　4.I帧不需要参考其他画面而生成;<br>　　5.I帧是P帧和B帧的参考帧(其质量直接影响到同组中以后各帧的质量);<br>　　6.I帧是帧组GOP的基础帧(第一帧),在一组中只有一个I帧;<br>　　7.I帧不需要考虑运动矢量;<br>　　8.I帧所占数据的信息量比较大。</p>\n<p>【<strong>I帧编码流程</strong>】<br>　　(1)进行帧内预测，决定所采用的帧内预测模式。<br>　　(2)像素值减去预测值，得到残差。<br>　　(3)对残差进行变换和量化。<br>　　(4)变长编码和算术编码。<br>　　(5)重构图像并滤波，得到的图像作为其它帧的参考帧。</p>\n<p>例如：在视频会议系统中，终端发送给MCU（或者MCU发送给终端）的图像，并不是每次都把完整的一幅幅图片发送到远端，而只是发送后一幅画面在前一幅画面基础上发生变化的部分。如果在网络状况不好的情况下，终端的接收远端或者发送给远程的画面就会有丢包而出现图像花屏、图像卡顿的现象，在这种情况下如果没有I帧机制来让远端重新发一幅新的完整的图像到本地（或者本地重新发一幅新的完整的图像给远端），终端的输出图像的花屏、卡顿现象会越来越严重，从而造成会议无法正常进行。<br>在视频画面播放过程中，若I帧丢失了，则后面的P帧也就随着解不出来，就会出现视频画面黑屏的现象；若P帧丢失了，则视频画面会出现花屏、马赛克等现象。<br>在视频会议系统中I帧只会在会议限定的带宽内发生，不会超越会议带宽而生效。I帧机制不仅存在于MCU中，电视墙服务器、录播服务器中也存在。就是为了解决在网络状况不好的情况下，出现的丢包而造成的如图像花屏、卡顿，而影响会议会正常进行。</p>\n<h2 id=\"P-帧\"><a href=\"#P-帧\" class=\"headerlink\" title=\"P 帧\"></a>P 帧</h2><p>P帧:即Predictive-coded Picture（<strong>前向预测编码图像帧</strong>）。P帧表示的是这一帧跟之前的一个关键帧（或P帧）的差别，解码时需要用之前缓存的画面叠加上本帧定义的差别，生成最终画面。（也就是差别帧，P帧没有完整画面数据，只有与前一帧的画面差别的数据）</p>\n<p><img src=\"/2024/2f262a28/image-20240721162346288.png\"></p>\n<p>【<strong>P帧的预测与重构</strong>】<br>　　P帧是以I帧为参考帧,在I帧中找出P帧“某点”的预测值和运动矢量,取预测差值和运动矢量一起传送。在接收端根据运动矢量从I帧中找出P帧“某点”的预测值并与差值相加以得到P帧“某点”样值,从而可得到完整的P帧。</p>\n<p>【<strong>P帧特点</strong>】<br>　　1.P帧是I帧后面相隔1~2帧的编码帧;<br>　　2.P帧采用运动补偿的方法传送它与前面的I或P帧的差值及运动矢量(预测误差);<br>　　3.解码时必须将I帧中的预测值与预测误差求和后才能重构完整的P帧图像;<br>　　4.P帧属于前向预测的帧间编码。它只参考前面最靠近它的I帧或P帧;<br>　　5.P帧可以是其后面P帧的参考帧,也可以是其前后的B帧的参考帧;<br>　　6.由于P帧是参考帧,它可能造成解码错误的扩散;<br>　　7.由于是差值传送,P帧的压缩比较高。</p>\n<h2 id=\"B帧\"><a href=\"#B帧\" class=\"headerlink\" title=\"B帧\"></a>B帧</h2><p>B帧:即Bidirectionally predicted picture（<strong>双向预测编码图像帧</strong>)。B帧是双向差别帧，也就是B帧记录的是本帧与前后帧的差别，换言之，<strong>要解码B帧，不仅要取得之前的缓存画面，还要解码之后的画面</strong>，通过前后画面的与本帧数据的叠加取得最终的画面。B帧压缩率高，但是解码时CPU会比较累。<strong>无论是从编码侧还是解码侧看，B帧都是资源密集型</strong></p>\n<p><img src=\"/2024/2f262a28/image-20240721162537729.png\"></p>\n<p>【<strong>B帧的预测与重构</strong>】<br><strong>B帧以前面的I或P帧和后面的P帧为参考帧</strong>,“找出”B帧“某点”的预测值和两个运动矢量,并取预测差值和运动矢量传送。接收端根据运动矢量在两个参考帧中“找出(算出)”预测值并与差值求和,得到B帧“某点”样值,从而可得到完整的B帧。采用运动预测的方式进行帧间双向预测编码</p>\n<p>【<strong>B帧特点</strong>】<br>　　1.B帧是由前面的I或P帧和后面的P帧来进行预测的;<br>　　2.B帧传送的是<strong>它与前面的I帧或P帧和后面的P帧之间的预测误差及运动矢量</strong>;<br>　　3.B帧是双向预测编码帧;<br>　　4.B帧压缩比最高,因为它只反映丙参考帧间运动主体的变化情况,预测比较准确;<br>　　5.B帧不是参考帧,不会造成解码错误的扩散</p>\n<p>【<strong>为什么需要B帧</strong>】</p>\n<p> 从上面的看，我们知道I和P的解码算法比较简单，资源占用也比较少，I只要自己完成就行了，P呢，也只需要解码器把前一个画面缓存一下，遇到P时就使用之前缓存的画面就好了，如果视频流只有I和P，解码器可以不管后面的数据，边读边解码，线性前进，大家很舒服。那么为什么还要引入B帧？</p>\n<p>网络上的电影很多都采用了B帧，因为B帧记录的是前后帧的差别，<strong>比P帧能节约更多的空间</strong>，但这样一来，文件小了，解码器就麻烦了，因为在解码时，不仅要用之前缓存的画面，还要知道下一个I或者P的画面（也就是说要预读预解码），而且，B帧不能简单地丢掉，因为B帧其实也包含了画面信息，如果简单丢掉，并用之前的画面简单重复，就会造成画面卡（其实就是丢帧了），并且由于网络上的电影为了节约空间，往往使用相当多的B帧，B帧用的多，对不支持B帧的播放器就造成更大的困扰，画面也就越卡。</p>\n<p>【<strong>显示和解码顺序示意图</strong>】<br><img src=\"/2024/2f262a28/image-20240721162803162.png\"></p>\n<h2 id=\"PTS-DTS\"><a href=\"#PTS-DTS\" class=\"headerlink\" title=\"PTS DTS\"></a>PTS DTS</h2><p>【<strong>为什么会有PTS和DTS的概念</strong>】</p>\n<p>通过上面的描述可以看出：P帧需要参考前面的I帧或P帧才可以生成一张完整的图片，而B帧则需要参考前面I帧或P帧及其后面的一个P帧才可以生成一张完整的图片。这样就带来了一个问题：在视频流中，先到来的 B 帧无法立即解码，需要等待它依赖的后面的 I、P 帧先解码完成，这样一来播放时间与解码时间不一致了，顺序打乱了，那这些帧该如何播放呢？这时就引入了另外两个概念：DTS 和 PTS。</p>\n<p>【<strong>PTS和DTS</strong>】</p>\n<p>先来了解一下PTS和DTS的基本概念：</p>\n<p><strong>DTS（Decoding Time Stamp）</strong>：即<strong>解码时间戳</strong>，这个时间戳的意义在于告诉播放器该在什么时候解码这一帧的数据。<br><strong>PTS（Presentation Time Stamp）</strong>：即<strong>显示时间戳</strong>，这个时间戳用来告诉播放器该在什么时候显示这一帧的数据。</p>\n<p>虽然 DTS、PTS 是用于指导播放端的行为，但它们是在编码的时候由编码器生成的。</p>\n<p>在视频采集的时候是录制一帧就编码一帧发送一帧的，在编码的时候会生成 PTS，这里需要特别注意的是 frame（帧）的编码方式，在通常的场景中，编解码器编码一个 I 帧，然后向后跳过几个帧，用编码 I 帧作为基准帧对一个未来 P 帧进行编码，然后跳回到 I 帧之后的下一个帧。编码的 I 帧和 P 帧之间的帧被编码为 B 帧。之后，编码器会再次跳过几个帧，使用第一个 P 帧作为基准帧编码另外一个 P 帧，然后再次跳回，用 B 帧填充显示序列中的空隙。这个过程不断继续，每 12 到 15 个 P 帧和 B 帧内插入一个新的 I 帧。P 帧由前一个 I 帧或 P 帧图像来预测，而 B 帧由前后的两个 P 帧或一个 I 帧和一个 P 帧来预测，因而编解码和帧的显示顺序有所不同，如下所示：</p>\n<p><img src=\"/2024/2f262a28/image-20240721163414484.png\"></p>\n<p>假设编码器采集到的帧是这个样子的：<br><code> I B B P B B P </code></p>\n<p>那么它的显示顺序，也就是PTS应该是这样：<br><code> 1 2 3 4 5 6 7  </code></p>\n<p>编码器的编码顺序是：<br><code> 1 4 2 3 7 5 6 </code></p>\n<p>推流顺序也是按照编码顺序去推的，即<br><code> I P B B P B B </code></p>\n<p>那么接收断收到的视频流也就是<br><code> I P B B P B B </code></p>\n<p>这时候去解码，也是按照收到的视频流一帧一帧去解的了，接收一帧解码一帧，因为在编码的时候已经按照 I、B、P 的依赖关系编好了，接收到数据直接解码就好了。那么解码顺序是：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">     I P B B P B B<br>DTS：1 2 3 4 5 6 7<br>PTS：1 4 2 3 7 5 6<br></code></pre></td></tr></table></figure>\n\n\n<p>可以看到解码出来对应的 PTS 不是顺序的，为了正确显示视频流，这时候我们就必须按照 PTS 重新调整解码后的 frame(帧)，即</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">     I B B P B B P<br>DTS：1 3 4 2 6 7 5<br>PTS：1 2 3 4 5 6 7<br></code></pre></td></tr></table></figure>\n\n\n<p>另外，并不是一定要使用B帧。<strong>在实时互动直播系统中，很少使用B帧</strong>。主要的原因是压缩和解码B帧时，由于要双向参考，所以它需要缓冲更多的数据，且使用的CPU也会更高。由于实时性的要求，所以一般不使用它。不过对于播放器来说，遇到带有B帧的H264数据是常有的事儿。在没有B帧的情况下，存放帧的顺序和显示帧的顺序就是一样的，PTS和DTS的值也是一样的。</p>\n",
            "tags": [
                "audio",
                "video"
            ]
        },
        {
            "id": "https://www.oikiou.top/2024/4ce716c0/",
            "url": "https://www.oikiou.top/2024/4ce716c0/",
            "title": "Flash磨损均衡",
            "date_published": "2024-06-04T14:57:15.000Z",
            "content_html": "<h1 id=\"Flash磨损均衡\"><a href=\"#Flash磨损均衡\" class=\"headerlink\" title=\"Flash磨损均衡\"></a>Flash磨损均衡</h1><h1 id=\"flash-原理和部分名称\"><a href=\"#flash-原理和部分名称\" class=\"headerlink\" title=\"flash 原理和部分名称\"></a>flash 原理和部分名称</h1><p><img src=\"/2024/4ce716c0/image-20240604163634862.png\"></p>\n<ul>\n<li><strong>package</strong> 是存储芯片，即带有电连接器的小黑色矩形。</li>\n<li><strong>dies</strong> 每个<code>package</code>包含一个或多个<code>die</code>（例如一个、两个或四个）。<code>die</code> 是可以独立执行命令或报告状态的最小单元。</li>\n<li><strong>planes</strong>每个芯片包含一个或多个<code>planes</code> （通常为一或两个）。每个<code>planes</code>上都可以进行相同的并发操作，但有一些限制。</li>\n<li><strong>blocks</strong> 每个<code>planes</code>包含若干个<code>block</code> ，<code>block</code><strong>是可以擦除的最小单位</strong>。</li>\n<li><strong>pages</strong>每个<code>block</code>包含若干个 <code>page</code>，<code>page</code>是可进行编程（即写入）的最小单位。</li>\n</ul>\n<p><strong>磨损均衡 可实现的 底层原理是（同一个块）一次擦除，多次写入。</strong></p>\n<p>擦除是将任意内容改成0xff，即全1状态。<br>你可以对一个page执行多次写入，但是需要注意的是写入仅能将1改成0，<strong>无法将0改成1</strong>。</p>\n<blockquote>\n<p>EEPROM可以单字节（或者四字节）写，而FLASH只能按整个blocks擦除，另外EEPROM一般有100万次的读写寿命，而FLASH只有10万次；</p>\n</blockquote>\n<h1 id=\"一些简单实现的Demo\"><a href=\"#一些简单实现的Demo\" class=\"headerlink\" title=\"一些简单实现的Demo\"></a>一些简单实现的Demo</h1><p>这些demo只是头脑风暴的一些实现，仅仅是一个思路，具体实现还需要完善很多的细节。</p>\n<p><a href=\"Flash%E7%A3%A8%E6%8D%9F%E5%9D%87%E8%A1%A1.assets/flash%E7%9A%84%E7%A3%A8%E6%8D%9F%E5%9D%87%E8%A1%A1.drawio\">draw.io 源文件</a></p>\n<h2 id=\"数据长度固定\"><a href=\"#数据长度固定\" class=\"headerlink\" title=\"数据长度固定\"></a>数据长度固定</h2><p>数据长度固定，使用bitmap记录数据状态。</p>\n<p><img src=\"/2024/4ce716c0/image-20240604162704326.png\"></p>\n<p><img src=\"/2024/4ce716c0/image-20240604175346112.png\"><br><img src=\"/2024/4ce716c0/image-20240604175403042.png\"></p>\n<h2 id=\"数据长度可变\"><a href=\"#数据长度可变\" class=\"headerlink\" title=\"数据长度可变\"></a>数据长度可变</h2><p><img src=\"/2024/4ce716c0/image-20240604181628435.png\"></p>\n<h1 id=\"一些高性能的磨损均衡算法-SSD-Wear-Leveling\"><a href=\"#一些高性能的磨损均衡算法-SSD-Wear-Leveling\" class=\"headerlink\" title=\"一些高性能的磨损均衡算法 SSD Wear Leveling\"></a>一些高性能的磨损均衡算法 SSD Wear Leveling</h1><p>Flash采取<strong>异地更新</strong>的策略 ,更新的数据会被放到别的物理页上,而不是覆盖原来的数据。包含新版本数据的页被称为<strong>有效页</strong>,新版本数据被称为<strong>有效数据</strong>。包含旧版本数据的页被称为<strong>无效页</strong>，或称为脏页，脏页经过擦除操作后成为空闲页，才可以重新写入数据。因为Flash是<strong>以块为单位执行擦除</strong>的，因此需要将脏页所在块上的所有物理页都擦除，在擦除之前需要检查此块上是否存在有效页，如果存在就必须先转移到其他块上。因为每个Flash块的擦除次数有限，一般是在10 万次到100万次之间，只要有块的擦除次数达到了上限，Flash数据存储的性能将下降。所以必须想办法，使<strong>擦除操作平均作用在每个Flash块上</strong>，这种方法就是磨损均衡(wear-leveling)算法。</p>\n<p>我们在应用Flash时，实际上访问的是Flash的逻辑地址，在逻辑地址和物理地址之间，存在着映射关系。数据更新后只需改变映射表中物理页的地址，并将原版本数据所在的物理页标为无效。对于经常被更新的数据块，我们称之为<strong>“热”数据块</strong>，对长期得不到更新的数据块，称之为<strong>“冷”数据块</strong>。数据块经常更新的话，就会经常被擦除，而长期不更行的数据块，不会出现脏页而被擦除，其擦除次数会明显少于存放着经常被更新数据的块。如何实现“冷热”数据存放位置的交换是磨损均衡处理中需要考虑的问题。</p>\n<p>目前常用的磨损均衡算法大致分为两类，一类是随机性算法，一类是确定性算法。</p>\n<ul>\n<li>对于随机性算法，其原理为：在每次写或擦除操作后，按照某一概率来触发磨损均衡处理。按照均匀分布的概率，<strong>随机选择某个块执行擦除操作</strong>。不论块上放的是“冷”数据还是“热”数据,让每个块得到相等的擦除机会。最后将选中块上的有效数据复制到空块后擦除此块。将数据移动到哪个空闲块上,也是随机选择,因为没有记录块的擦除情况,存在将“冷”数据又移动到一个“冷”块上的情况,结果此块并没有增加擦除次数, 这种情况尤其会发生在有大量“冷”数据的系统里。</li>\n<li>对于确定性算法，又分为周期性和全局性两种，其中<strong>周期性算法</strong>的原理为：将Flash的寿命看做是一个接一个的磨损均衡周期组成的。在一个处理周期中，达到规定的擦除次数的块在这一轮周期中将不会被选中，这样可使各个块都达到相同的擦除次数，再开始下一个擦除周期。通过调整Flash块的规定擦除次数，可以使整个Flash能够达到理想的磨损均衡。<strong>全局性算法</strong>的原理为：不划分处理周期，在一个全局范围内控制块的磨损均衡。当任何两个块的擦除次数之差超过一个给定的阈值时，或者当某块的擦除次数超过了所有块的平均擦除次数时，启动磨损均衡处理，将擦除次数少的块上的数据和擦除次数多的块上的数据进行交换。如果块上存放的是“冷”数据，即数据很少被更新，则该块上的数据不易变脏，很少得到擦除的机会。相反，如果该块上存放的是“热”数据，则该块上的数据经常被更新，经常得到擦除脏数据的机会。根据这个原理来交换“冷热”数据，从而实现磨损均衡。</li>\n</ul>\n<p>对比两类磨损均衡算法，可以看出：随机性算法的效果受随机因素影响较大，在擦除前，并不知道各个块被擦除的情况，同时对逻辑页的随机性请求并不能做到完全等概率，所以虽然随机性算法是等概率地选择处理页，但每个块的擦除次数并不能达到等概率分布，不能达到很好的磨损均衡效果。确定性算法因记录了物理块的擦除次数，故在处理中可根据这些信息来作出调整决策，各块基本达到了相近的擦除次数，磨损均衡的效果明显好于随机性算法。但这是在消耗大量内存开销的基础上实现的。</p>\n<p>根据以上讨论的情况，可以看出，必须结合两类算法的优势，来实现效果较好的磨损均衡处理，才能既保证Flash的读写速度，又能保证Flash的使用寿命，这将是决定固态存储能否全面战胜机械硬盘的关键之战。</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p>Understanding Flash: Blocks, Pages and Program &#x2F; Erases<br><a href=\"https://flashdba.com/2014/06/20/understanding-flash-blocks-pages-and-program-erases/\">https://flashdba.com/2014/06/20/understanding-flash-blocks-pages-and-program-erases/</a><br>Flash存储器磨损均衡原理及实现<br><a href=\"https://blog.csdn.net/csdliqi/article/details/80361163\">https://blog.csdn.net/csdliqi/article/details/80361163</a><br>深入解析SSD Wear Leveling磨损均衡技术：如何让你的硬盘更长寿？<br><a href=\"https://blog.csdn.net/zhuzongpeng/article/details/134520307\">https://blog.csdn.net/zhuzongpeng/article/details/134520307</a></p>\n",
            "tags": [
                "flash"
            ]
        },
        {
            "id": "https://www.oikiou.top/2024/f17585eb/",
            "url": "https://www.oikiou.top/2024/f17585eb/",
            "title": "AES",
            "date_published": "2024-03-23T14:57:15.000Z",
            "content_html": "<h1 id=\"AES\"><a href=\"#AES\" class=\"headerlink\" title=\"AES\"></a>AES</h1><p>高级加密标准( AES  <strong>Advanced Encryption Standard</strong>)，原名Rijndael，是美国国家标准与技术研究所(NIST) 在 2017 年制定的电子数据加密规范。</p>\n<p>AES已被美国政府采用。它取代了1977 年发布的数据加密标准(DES) 。<br>AES 描述的算法是对称密钥算法，这意味着相同的密钥用于加密和解密数据。</p>\n<p>一些特性</p>\n<ul>\n<li>对称加密，加密解密使用同样的密钥</li>\n<li>分组加密，将明文分块成若干个数据块，分块加密（块大小固定为128位 16Byte）</li>\n<li>密钥长度可选128位、192位、256位，分别对应于10轮循环、12轮循环、14轮循环</li>\n</ul>\n<h1 id=\"加密过程\"><a href=\"#加密过程\" class=\"headerlink\" title=\"加密过程\"></a>加密过程</h1><p><img src=\"/2024/f17585eb/image-20240323184445497.png\"></p>\n<ul>\n<li>最终轮运算有些不同的是它只执行 1、2、4，不执行3。</li>\n</ul>\n<p><img src=\"/2024/f17585eb/image-20240323201021478.png\"></p>\n<h1 id=\"解密\"><a href=\"#解密\" class=\"headerlink\" title=\"解密\"></a>解密</h1><p>解密为加密的完全逆过程</p>\n<blockquote>\n<p>这个图从下往上看</p>\n</blockquote>\n<p><img src=\"/2024/f17585eb/image-20240323203852410.png\"></p>\n",
            "tags": [
                "aes"
            ]
        },
        {
            "id": "https://www.oikiou.top/2024/f0099803/",
            "url": "https://www.oikiou.top/2024/f0099803/",
            "title": "语义化版本编号 Major、Minor、Patch",
            "date_published": "2024-01-19T14:57:15.000Z",
            "content_html": "<h2 id=\"语义化版本（Semantic-Versioning）：Major、Minor-和-Patch-版本号解析\"><a href=\"#语义化版本（Semantic-Versioning）：Major、Minor-和-Patch-版本号解析\" class=\"headerlink\" title=\"语义化版本（Semantic Versioning）：Major、Minor 和 Patch 版本号解析\"></a>语义化版本（Semantic Versioning）：Major、Minor 和 Patch 版本号解析</h2><p>语义化版本，通常简称为SemVer，是一种软件版本号的标准化方案，旨在使软件版本号的管理更加透明和可预测。它主要由三个部分组成：Major（主版本号）、Minor（次版本号）和Patch（修订版本号）。在这篇文章中，我们将深入解释这三个部分的含义，并提供详细的示例来说明它们的用途和变更规则。</p>\n<p>在RT-Thread内有如下代码段：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/* RT-Thread version information */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> RT_VERSION_MAJOR                5               <span class=\"hljs-comment\">/**&lt; Major version number (X.x.x) */</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> RT_VERSION_MINOR                1               <span class=\"hljs-comment\">/**&lt; Minor version number (x.X.x) */</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> RT_VERSION_PATCH                0               <span class=\"hljs-comment\">/**&lt; Patch version number (x.x.X) */</span></span><br><br><span class=\"hljs-comment\">/* e.g. #if (RTTHREAD_VERSION &gt;= RT_VERSION_CHECK(4, 1, 0) */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> RT_VERSION_CHECK(major, minor, revise)          ((major * 10000) + (minor * 100) + revise)</span><br><br><span class=\"hljs-comment\">/* RT-Thread version */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> RTTHREAD_VERSION                RT_VERSION_CHECK(RT_VERSION_MAJOR, RT_VERSION_MINOR, RT_VERSION_PATCH)</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"Major（主版本号）\"><a href=\"#Major（主版本号）\" class=\"headerlink\" title=\"Major（主版本号）\"></a>Major（主版本号）</h3><p>Major版本号是语义化版本中的第一个数字，用于表示软件的主要版本变更。当进行大规模的、不兼容的变更时，应该增加Major版本号。主要变更包括：</p>\n<ol>\n<li><strong>不兼容的API更改</strong>：当你修改了软件的API，以至于旧版本的代码无法与新版本一起正常工作时，应该升级Major版本号。这可能包括删除、更改或添加API端点、参数或行为。</li>\n<li><strong>重大功能新增</strong>：如果你引入了重要的新功能，这可能会改变用户的工作流程或提供新的能力，也应该升级Major版本号。</li>\n<li><strong>废弃旧功能</strong>：当你计划废弃或删除旧的功能时，通常需要增加Major版本号，以提醒用户进行迁移。</li>\n</ol>\n<p>示例： 假设有一个虚构的图形处理库，当前版本号为1.0.0。如果开发团队决定删除现有API中的一个核心功能，这将导致现有的用户无法升级到新版本而不修改其代码，那么新版本的版本号应该升级到2.0.0。</p>\n<h3 id=\"Minor（次版本号）\"><a href=\"#Minor（次版本号）\" class=\"headerlink\" title=\"Minor（次版本号）\"></a>Minor（次版本号）</h3><p>Minor版本号是语义化版本中的第二个数字，用于表示向后兼容的新功能添加。Minor版本号的变更包括：</p>\n<ol>\n<li><strong>新增功能</strong>：当你向软件添加新的功能，但这些功能不会破坏现有的API或功能，应该增加Minor版本号。</li>\n<li><strong>改进现有功能</strong>：如果你对现有功能进行了改进，但这些改进不会导致现有用户的代码无法工作，也应该升级Minor版本号。</li>\n<li><strong>向后兼容的API增强</strong>：如果你增加了现有API的参数、选项或能力，而这不会破坏已有的使用方式，也应该升级Minor版本号。</li>\n</ol>\n<p>示例： 继续以图形处理库为例，当前版本号为1.2.0。开发团队决定在库中添加一个全新的图像滤镜功能，但这不会破坏任何现有功能或API。在这种情况下，版本号应升级到1.3.0。</p>\n<h3 id=\"Patch（修订版本号）\"><a href=\"#Patch（修订版本号）\" class=\"headerlink\" title=\"Patch（修订版本号）\"></a>Patch（修订版本号）</h3><p>Patch版本号是语义化版本中的第三个数字，用于表示向后兼容的错误修复或小的改进。Patch版本号的变更包括：</p>\n<ol>\n<li><strong>错误修复</strong>：当你解决现有功能或API中的错误时，应该升级Patch版本号。这些修复不应引入新的功能或改变现有的行为。</li>\n<li><strong>性能优化</strong>：如果你对现有功能进行性能优化，而不会改变其行为，也应该升级Patch版本号。</li>\n<li><strong>小的改进或修改</strong>：如果你进行了一些小的改进，但它们不会破坏向后兼容性，应该升级Patch版本号。</li>\n</ol>\n<p>示例： 继续以图形处理库为例，当前版本号为1.2.3。在测试中发现一个重要的Bug，它导致图像处理不正确。开发团队修复了这个问题，没有引入新的功能或改变现有功能，版本号应该升级到1.2.4。</p>\n",
            "tags": [
                "major"
            ]
        },
        {
            "id": "https://www.oikiou.top/2024/fd896621/",
            "url": "https://www.oikiou.top/2024/fd896621/",
            "title": "代码、硬件常见的缩写",
            "date_published": "2024-01-12T09:47:15.000Z",
            "content_html": "<h1 id=\"代码、硬件常见的缩写\"><a href=\"#代码、硬件常见的缩写\" class=\"headerlink\" title=\"代码、硬件常见的缩写\"></a>代码、硬件常见的缩写</h1><p><strong>常用单词缩写</strong></p>\n<table>\n<thead>\n<tr>\n<th>全词</th>\n<th>缩词&#x2F;简写</th>\n<th>中译</th>\n<th>全词</th>\n<th>缩词&#x2F;简写</th>\n<th>中译</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>指令内核相关类</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>source</td>\n<td>src</td>\n<td>源头</td>\n<td>default</td>\n<td>def</td>\n<td>默认</td>\n</tr>\n<tr>\n<td>destination</td>\n<td>dst或des</td>\n<td>目的地，目标</td>\n<td>define</td>\n<td>def</td>\n<td>定义</td>\n</tr>\n<tr>\n<td>operator</td>\n<td>optr</td>\n<td>操作符</td>\n<td>macro</td>\n<td>mcr</td>\n<td>宏</td>\n</tr>\n<tr>\n<td>operand</td>\n<td>opnd</td>\n<td>操作数</td>\n<td>return</td>\n<td>ret</td>\n<td>返回</td>\n</tr>\n<tr>\n<td>offset</td>\n<td>ofs</td>\n<td>偏移</td>\n<td>assemble</td>\n<td>asm</td>\n<td>汇编</td>\n</tr>\n<tr>\n<td>clear</td>\n<td>clr</td>\n<td>清除</td>\n<td>interrupt</td>\n<td>intr</td>\n<td>中断</td>\n</tr>\n<tr>\n<td>move</td>\n<td>mov</td>\n<td>移动</td>\n<td>priority</td>\n<td>prio</td>\n<td>优先级</td>\n</tr>\n<tr>\n<td>instruction</td>\n<td>instr</td>\n<td>指令</td>\n<td>vector</td>\n<td>vect</td>\n<td>向量</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>变量内存相关类</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>temperature</td>\n<td>temper</td>\n<td>温度</td>\n<td>address</td>\n<td>addr</td>\n<td>地址</td>\n</tr>\n<tr>\n<td>temporary</td>\n<td>tmp</td>\n<td>临时</td>\n<td>pointer</td>\n<td>ptr</td>\n<td>指针</td>\n</tr>\n<tr>\n<td>counter</td>\n<td>ctr</td>\n<td>计数器</td>\n<td>buffer</td>\n<td>buf</td>\n<td>缓冲区</td>\n</tr>\n<tr>\n<td>count</td>\n<td>cnt</td>\n<td>计数</td>\n<td>stack</td>\n<td>stk</td>\n<td>堆</td>\n</tr>\n<tr>\n<td>flag</td>\n<td>flg</td>\n<td>旗帜、标识</td>\n<td>memory</td>\n<td>mem</td>\n<td>内存</td>\n</tr>\n<tr>\n<td>parameter</td>\n<td>par</td>\n<td>参数</td>\n<td>storage</td>\n<td>stg</td>\n<td>存储器</td>\n</tr>\n<tr>\n<td>argument</td>\n<td>arg</td>\n<td>参数</td>\n<td>block</td>\n<td>blk</td>\n<td>块</td>\n</tr>\n<tr>\n<td>variable</td>\n<td>var</td>\n<td>变量</td>\n<td>allocate</td>\n<td>alloc</td>\n<td>分配</td>\n</tr>\n<tr>\n<td>array</td>\n<td>arr</td>\n<td>数组</td>\n<td>object</td>\n<td>obj</td>\n<td>对象</td>\n</tr>\n<tr>\n<td>string</td>\n<td>str</td>\n<td>字符串</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>character</td>\n<td>char</td>\n<td>字符</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>数学计算相关类</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>increment</td>\n<td>inc</td>\n<td>增加</td>\n<td>average</td>\n<td>avg</td>\n<td>平均数</td>\n</tr>\n<tr>\n<td>decrease</td>\n<td>dec</td>\n<td>减少</td>\n<td>summation</td>\n<td>sum</td>\n<td>求和;总和</td>\n</tr>\n<tr>\n<td>addition</td>\n<td>add</td>\n<td>增加；加法</td>\n<td>calculate</td>\n<td>calc</td>\n<td>计算</td>\n</tr>\n<tr>\n<td>subtraction</td>\n<td>sub</td>\n<td>减少，减法</td>\n<td>total</td>\n<td>tot</td>\n<td>总计</td>\n</tr>\n<tr>\n<td>multiplication</td>\n<td>mul</td>\n<td>乘法</td>\n<td>magnitude</td>\n<td>mag</td>\n<td>巨大</td>\n</tr>\n<tr>\n<td>division</td>\n<td>div</td>\n<td>除法；除以</td>\n<td>maximum</td>\n<td>max</td>\n<td>最大</td>\n</tr>\n<tr>\n<td>proportion</td>\n<td>kp</td>\n<td>比例</td>\n<td>minimum</td>\n<td>min</td>\n<td>最小</td>\n</tr>\n<tr>\n<td>integral</td>\n<td>ki</td>\n<td>积分</td>\n<td>middle</td>\n<td>mid</td>\n<td>中间</td>\n</tr>\n<tr>\n<td>differential</td>\n<td>kd</td>\n<td>微分</td>\n<td>equivalent</td>\n<td>equiv</td>\n<td>相等的</td>\n</tr>\n<tr>\n<td>absolute</td>\n<td>abs</td>\n<td>绝对值</td>\n<td>greater equal</td>\n<td>ge</td>\n<td>大于等于</td>\n</tr>\n<tr>\n<td>algorithm</td>\n<td>algo</td>\n<td>算法</td>\n<td>greater than</td>\n<td>gt</td>\n<td>大于</td>\n</tr>\n<tr>\n<td>exponent</td>\n<td>expo</td>\n<td>指数</td>\n<td>less equal</td>\n<td>le</td>\n<td>小于等于</td>\n</tr>\n<tr>\n<td>recur</td>\n<td>recu</td>\n<td>递归</td>\n<td>less than</td>\n<td>lt</td>\n<td>小于</td>\n</tr>\n<tr>\n<td>limit</td>\n<td>lim</td>\n<td>限制</td>\n<td>quarter</td>\n<td>quar</td>\n<td>四分之一</td>\n</tr>\n<tr>\n<td>mantissa</td>\n<td>mant</td>\n<td>尾数</td>\n<td>scale</td>\n<td>scal</td>\n<td>比例</td>\n</tr>\n<tr>\n<td>fraction</td>\n<td>fract</td>\n<td>小数</td>\n<td>double</td>\n<td>dbl</td>\n<td>两倍</td>\n</tr>\n<tr>\n<td>digit</td>\n<td>dig</td>\n<td>数字</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>number</td>\n<td>num</td>\n<td>数字；数量</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>value</td>\n<td>val</td>\n<td>值</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>其他计算相关类</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>reference</td>\n<td>ref</td>\n<td>引用，参考</td>\n<td>between</td>\n<td>btw</td>\n<td>之间</td>\n</tr>\n<tr>\n<td>compare</td>\n<td>cmp</td>\n<td>比较</td>\n<td>interval</td>\n<td>intvl</td>\n<td>间隔</td>\n</tr>\n<tr>\n<td>different</td>\n<td>diff</td>\n<td>对比</td>\n<td>different</td>\n<td>diff</td>\n<td>区别</td>\n</tr>\n<tr>\n<td>optimization</td>\n<td>opt</td>\n<td>最优化</td>\n<td>error</td>\n<td>err</td>\n<td>错误</td>\n</tr>\n<tr>\n<td>degree</td>\n<td>deg</td>\n<td>度数，程度</td>\n<td>exception</td>\n<td>exc</td>\n<td>异常</td>\n</tr>\n<tr>\n<td>full</td>\n<td>ful</td>\n<td>全量</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>multiplex</td>\n<td>mux</td>\n<td>多路复用</td>\n<td>result</td>\n<td>rslt</td>\n<td>结果</td>\n</tr>\n<tr>\n<td>overflow</td>\n<td>ovf</td>\n<td>溢出</td>\n<td>complete</td>\n<td>comp</td>\n<td>完成</td>\n</tr>\n<tr>\n<td>check</td>\n<td>chk</td>\n<td>检查，核对</td>\n<td>success</td>\n<td>succ</td>\n<td>成功</td>\n</tr>\n<tr>\n<td>test</td>\n<td>tst</td>\n<td>测试</td>\n<td>error</td>\n<td>err</td>\n<td>错误</td>\n</tr>\n<tr>\n<td>detect</td>\n<td></td>\n<td>检测，识别</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>measure</td>\n<td>meas</td>\n<td>测量</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>sample</td>\n<td>smp</td>\n<td>样本</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>make</td>\n<td>mk</td>\n<td>制造</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>时间顺序相关类</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>timer</td>\n<td>tmr或tim</td>\n<td>定时器</td>\n<td>new</td>\n<td></td>\n<td>新的</td>\n</tr>\n<tr>\n<td>time</td>\n<td>tm</td>\n<td>时间</td>\n<td>old</td>\n<td></td>\n<td>老的；旧的</td>\n</tr>\n<tr>\n<td>second</td>\n<td>sec</td>\n<td>秒、第二</td>\n<td>now</td>\n<td></td>\n<td>现在；目前</td>\n</tr>\n<tr>\n<td>minute</td>\n<td>min</td>\n<td>分钟</td>\n<td>current</td>\n<td>cur</td>\n<td>当前</td>\n</tr>\n<tr>\n<td>hour</td>\n<td>hr</td>\n<td>小时</td>\n<td>previous</td>\n<td>prev</td>\n<td>先前的</td>\n</tr>\n<tr>\n<td>day</td>\n<td></td>\n<td>天</td>\n<td>delay</td>\n<td>dly</td>\n<td>延迟</td>\n</tr>\n<tr>\n<td>month</td>\n<td>mth</td>\n<td>月</td>\n<td>expiration</td>\n<td>expi</td>\n<td>过期</td>\n</tr>\n<tr>\n<td>year</td>\n<td></td>\n<td>年</td>\n<td>next</td>\n<td>nex</td>\n<td>下一个</td>\n</tr>\n<tr>\n<td>period</td>\n<td>perd</td>\n<td>时期</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>timestamp</td>\n<td>ts</td>\n<td>时间戳</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>timeout</td>\n<td>to</td>\n<td>超时</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>age</td>\n<td></td>\n<td>年龄</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>结构方向相关类</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>positon</td>\n<td>pos</td>\n<td>位置</td>\n<td>origin</td>\n<td>org</td>\n<td>起源，原点</td>\n</tr>\n<tr>\n<td>coordinates</td>\n<td>coord</td>\n<td>坐标系</td>\n<td>point</td>\n<td>pt</td>\n<td>点</td>\n</tr>\n<tr>\n<td>row</td>\n<td></td>\n<td>行</td>\n<td>rect</td>\n<td>rc</td>\n<td>矩形</td>\n</tr>\n<tr>\n<td>column</td>\n<td>col</td>\n<td>列</td>\n<td>rectangle</td>\n<td>rect</td>\n<td>长方形</td>\n</tr>\n<tr>\n<td>vertical</td>\n<td>vert&#x2F;v</td>\n<td>垂直</td>\n<td>cylinder</td>\n<td>cyl</td>\n<td>圆柱体</td>\n</tr>\n<tr>\n<td>horizontal</td>\n<td>hori&#x2F;h</td>\n<td>水平的</td>\n<td>length</td>\n<td>len</td>\n<td>长度</td>\n</tr>\n<tr>\n<td>dimension</td>\n<td>dim</td>\n<td>维度</td>\n<td>high</td>\n<td>hi</td>\n<td>高度；高的</td>\n</tr>\n<tr>\n<td>permutation</td>\n<td>perm</td>\n<td>排列</td>\n<td>invert</td>\n<td>invt</td>\n<td>颠倒</td>\n</tr>\n<tr>\n<td>信息相关类</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>information</td>\n<td>info</td>\n<td>信息</td>\n<td>command</td>\n<td>cmd</td>\n<td>命令</td>\n</tr>\n<tr>\n<td>communication</td>\n<td>comu</td>\n<td>通信</td>\n<td>config</td>\n<td>conf</td>\n<td>配置</td>\n</tr>\n<tr>\n<td>message</td>\n<td>msg</td>\n<td>消息；信息</td>\n<td>request</td>\n<td>req</td>\n<td>请求</td>\n</tr>\n<tr>\n<td>packet</td>\n<td>pkt</td>\n<td>信息包</td>\n<td>acknowledge</td>\n<td>ack</td>\n<td>承认；应答</td>\n</tr>\n<tr>\n<td>package</td>\n<td>pkg</td>\n<td>包</td>\n<td>answer</td>\n<td>ans</td>\n<td>回答</td>\n</tr>\n<tr>\n<td>protocol</td>\n<td>proto</td>\n<td>协议</td>\n<td>response</td>\n<td>rsp</td>\n<td>响应</td>\n</tr>\n<tr>\n<td>stream</td>\n<td>stm</td>\n<td>流</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>header</td>\n<td>hdr</td>\n<td>头</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>index</td>\n<td>idx</td>\n<td>索引</td>\n<td>decode</td>\n<td>deco</td>\n<td>解码</td>\n</tr>\n<tr>\n<td>frame</td>\n<td>frm</td>\n<td>帧率；框架</td>\n<td>encode</td>\n<td>enc</td>\n<td>编码</td>\n</tr>\n<tr>\n<td>clock</td>\n<td>clok</td>\n<td>时钟</td>\n<td>coding</td>\n<td></td>\n<td>译码；编码</td>\n</tr>\n<tr>\n<td>receive</td>\n<td>recv</td>\n<td>接收</td>\n<td>authentication</td>\n<td>auth</td>\n<td>校验</td>\n</tr>\n<tr>\n<td>send</td>\n<td>send</td>\n<td>发送</td>\n<td>authentication code</td>\n<td>authcode</td>\n<td>校验码</td>\n</tr>\n<tr>\n<td>context</td>\n<td>ctx</td>\n<td>上下文</td>\n<td>unknown</td>\n<td>unk</td>\n<td>未知</td>\n</tr>\n<tr>\n<td>connect</td>\n<td>con</td>\n<td>连接</td>\n<td>extension</td>\n<td>ext</td>\n<td>扩展</td>\n</tr>\n<tr>\n<td>ethernet</td>\n<td>eth</td>\n<td>以太网</td>\n<td>expand</td>\n<td>expa</td>\n<td>扩展</td>\n</tr>\n<tr>\n<td>mailbox</td>\n<td>mbox</td>\n<td>邮箱</td>\n<td>field</td>\n<td>fld</td>\n<td>字段</td>\n</tr>\n<tr>\n<td>mask</td>\n<td>msk</td>\n<td>掩码</td>\n<td>identifier</td>\n<td>id</td>\n<td>标识符</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td>decode</td>\n<td>deco</td>\n<td>解码</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td>encode</td>\n<td>enc</td>\n<td>编码</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>计算机动作操作类</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>construct</td>\n<td>cons</td>\n<td>构建</td>\n<td>select</td>\n<td>sel</td>\n<td>选择</td>\n</tr>\n<tr>\n<td>control</td>\n<td>ctl</td>\n<td>控制</td>\n<td>delete</td>\n<td>del</td>\n<td>删除</td>\n</tr>\n<tr>\n<td>execute</td>\n<td>exec</td>\n<td>执行</td>\n<td>insert</td>\n<td>ins</td>\n<td>插入</td>\n</tr>\n<tr>\n<td>register</td>\n<td>reg</td>\n<td>注册</td>\n<td>copy</td>\n<td>cpy</td>\n<td>复制</td>\n</tr>\n<tr>\n<td>click</td>\n<td>clk</td>\n<td>点击</td>\n<td>paste</td>\n<td></td>\n<td>粘贴</td>\n</tr>\n<tr>\n<td>back</td>\n<td>bk</td>\n<td>后退</td>\n<td>cut</td>\n<td></td>\n<td>剪切</td>\n</tr>\n<tr>\n<td>disable</td>\n<td>dis</td>\n<td>使失效</td>\n<td>print</td>\n<td>Prn&#x2F;prt</td>\n<td>打印</td>\n</tr>\n<tr>\n<td>enable</td>\n<td>en</td>\n<td>使能</td>\n<td>input</td>\n<td>in</td>\n<td>输入</td>\n</tr>\n<tr>\n<td>effective</td>\n<td>eff</td>\n<td>有效的</td>\n<td>output</td>\n<td>out</td>\n<td>输出</td>\n</tr>\n<tr>\n<td>invalid</td>\n<td>inv</td>\n<td>无效的</td>\n<td>lock</td>\n<td>lck</td>\n<td>上锁</td>\n</tr>\n<tr>\n<td>logic</td>\n<td>lgc</td>\n<td>逻辑的</td>\n<td>unlock</td>\n<td>unlk</td>\n<td>解锁</td>\n</tr>\n<tr>\n<td>read</td>\n<td>r</td>\n<td>读</td>\n<td>scan</td>\n<td>sca</td>\n<td>扫描</td>\n</tr>\n<tr>\n<td>write</td>\n<td>w</td>\n<td>写</td>\n<td>search</td>\n<td>srch</td>\n<td>搜索</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>计算机专业名称类</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>iteration</td>\n<td>itr</td>\n<td>迭代；反复；重复</td>\n<td>initialization</td>\n<td>init</td>\n<td>初始化</td>\n</tr>\n<tr>\n<td>version</td>\n<td>ver</td>\n<td>版本</td>\n<td>program</td>\n<td>prg</td>\n<td>程序</td>\n</tr>\n<tr>\n<td>password</td>\n<td>psw</td>\n<td>密码</td>\n<td>system</td>\n<td>sys</td>\n<td>系统</td>\n</tr>\n<tr>\n<td>permission</td>\n<td>perms</td>\n<td>许可</td>\n<td>android</td>\n<td>adr</td>\n<td>安卓操作系统</td>\n</tr>\n<tr>\n<td>device</td>\n<td>dev</td>\n<td>设备</td>\n<td>application</td>\n<td>app</td>\n<td>应用程序</td>\n</tr>\n<tr>\n<td>administrator</td>\n<td>adm</td>\n<td>管理员</td>\n<td>driver</td>\n<td>drv</td>\n<td>驱动</td>\n</tr>\n<tr>\n<td>manager</td>\n<td>mgr</td>\n<td>管理者，管理器</td>\n<td>update</td>\n<td>upd</td>\n<td>更新</td>\n</tr>\n<tr>\n<td>standard</td>\n<td>std</td>\n<td>标准</td>\n<td>upgrade</td>\n<td>upg</td>\n<td>升级</td>\n</tr>\n<tr>\n<td>library</td>\n<td>lib</td>\n<td>静态库</td>\n<td>environment</td>\n<td>env</td>\n<td>运行环境</td>\n</tr>\n<tr>\n<td>database</td>\n<td>db</td>\n<td>数据库</td>\n<td>process</td>\n<td>proc</td>\n<td>进程</td>\n</tr>\n<tr>\n<td>dynamic</td>\n<td>dyna</td>\n<td>动态</td>\n<td>ready</td>\n<td>rdy</td>\n<td>就绪</td>\n</tr>\n<tr>\n<td>synchronization</td>\n<td>sync</td>\n<td>同步</td>\n<td>suspend</td>\n<td>susp</td>\n<td>挂起</td>\n</tr>\n<tr>\n<td>asynchronization</td>\n<td>asyn</td>\n<td>异步</td>\n<td>status</td>\n<td>sts</td>\n<td>状态</td>\n</tr>\n<tr>\n<td>link</td>\n<td>lnk</td>\n<td>链接</td>\n<td>signal</td>\n<td>sig</td>\n<td>信号</td>\n</tr>\n<tr>\n<td>server</td>\n<td>svr</td>\n<td>服务</td>\n<td>semaphore</td>\n<td>sem</td>\n<td>信号量</td>\n</tr>\n<tr>\n<td>executable file</td>\n<td>exe</td>\n<td>可执行文件</td>\n<td>scheduler</td>\n<td>scher</td>\n<td>调度器</td>\n</tr>\n<tr>\n<td>sequence</td>\n<td>seq</td>\n<td>序列</td>\n<td>task</td>\n<td>tsk</td>\n<td>任务</td>\n</tr>\n<tr>\n<td>serialize</td>\n<td>seri</td>\n<td>序列化</td>\n<td>statistic</td>\n<td>stat</td>\n<td>统计</td>\n</tr>\n<tr>\n<td>virus</td>\n<td>vir</td>\n<td>病毒</td>\n<td>process</td>\n<td>proc</td>\n<td>进程</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td>ready</td>\n<td>rdy</td>\n<td>就绪</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>文档图片类</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>directory</td>\n<td>dir</td>\n<td>目录</td>\n<td><a href=\"https://so.csdn.net/so/search?q=bitmap&spm=1001.2101.3001.7020\">bitmap</a></td>\n<td>bmp</td>\n<td>位图纹理</td>\n</tr>\n<tr>\n<td>list</td>\n<td>lst</td>\n<td>列表</td>\n<td>image</td>\n<td>img</td>\n<td>图像</td>\n</tr>\n<tr>\n<td>log</td>\n<td>log</td>\n<td>日志</td>\n<td>picture</td>\n<td>pic</td>\n<td>图片</td>\n</tr>\n<tr>\n<td>document</td>\n<td>doc</td>\n<td>文档</td>\n<td>color</td>\n<td>clr</td>\n<td>颜色</td>\n</tr>\n<tr>\n<td>text</td>\n<td>txt</td>\n<td>文本</td>\n<td>record</td>\n<td>rcd</td>\n<td>记录</td>\n</tr>\n<tr>\n<td>table</td>\n<td>tab或tbl</td>\n<td>表格</td>\n<td>dictionary</td>\n<td>dict</td>\n<td>词典、字典</td>\n</tr>\n<tr>\n<td>manual</td>\n<td>man</td>\n<td>手册</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>specification</td>\n<td>spec</td>\n<td>说明</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>软件界面名称类</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>screen</td>\n<td>scr</td>\n<td>屏幕</td>\n<td>button</td>\n<td>btn</td>\n<td>按钮</td>\n</tr>\n<tr>\n<td>display</td>\n<td>disp</td>\n<td>显示</td>\n<td>component</td>\n<td>com</td>\n<td>组件(多用于ui组件目录命名)</td>\n</tr>\n<tr>\n<td>util</td>\n<td></td>\n<td>工具</td>\n<td>window</td>\n<td>wnd</td>\n<td>窗口</td>\n</tr>\n<tr>\n<td>attribute</td>\n<td>attr</td>\n<td>属性</td>\n<td>dialog</td>\n<td>dlg</td>\n<td>对话框</td>\n</tr>\n<tr>\n<td>feature</td>\n<td>fea</td>\n<td>特征</td>\n<td>cursor</td>\n<td>csr</td>\n<td>光标</td>\n</tr>\n<tr>\n<td>bottom</td>\n<td>btm</td>\n<td>底部</td>\n<td>markdown</td>\n<td>md</td>\n<td>文本标记语言</td>\n</tr>\n<tr>\n<td>descriptor</td>\n<td>desc</td>\n<td>描述符</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>visible</td>\n<td>vis</td>\n<td>可见的</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>电气相关类</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>frequency</td>\n<td>freq</td>\n<td>频率</td>\n<td>poweron</td>\n<td>pwron</td>\n<td>上电</td>\n</tr>\n<tr>\n<td>voltage</td>\n<td>vol</td>\n<td>电压</td>\n<td>back electromotive force</td>\n<td>BEF</td>\n<td>反电动势</td>\n</tr>\n<tr>\n<td>current</td>\n<td>cur</td>\n<td>电流</td>\n<td>speed</td>\n<td>spd</td>\n<td>速度</td>\n</tr>\n<tr>\n<td>power</td>\n<td>pwr</td>\n<td>功率&#x2F;电源</td>\n<td>electric</td>\n<td>elec</td>\n<td>电子的</td>\n</tr>\n<tr>\n<td>trigger</td>\n<td>trig</td>\n<td>触发器</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>threshold</td>\n<td>thold</td>\n<td>阈值</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>switch</td>\n<td>sw</td>\n<td>开关</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>toggle</td>\n<td>tgl</td>\n<td>切换</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>其他类</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>resource</td>\n<td>res</td>\n<td>资源</td>\n<td>prefix</td>\n<td>pre</td>\n<td>前缀</td>\n</tr>\n<tr>\n<td>region</td>\n<td>rgn</td>\n<td>区域、领域</td>\n<td>reactive</td>\n<td>react</td>\n<td>有反应的</td>\n</tr>\n<tr>\n<td>group</td>\n<td>grp</td>\n<td>组</td>\n<td>recall</td>\n<td>rcl</td>\n<td>召回</td>\n</tr>\n<tr>\n<td>assemble</td>\n<td>asm</td>\n<td>集合</td>\n<td>release</td>\n<td>rel</td>\n<td>发布</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td>repeat</td>\n<td>rpt</td>\n<td>重复</td>\n</tr>\n<tr>\n<td>action</td>\n<td>act</td>\n<td>动作</td>\n<td>duplicate</td>\n<td>dup</td>\n<td>重复</td>\n</tr>\n<tr>\n<td>common</td>\n<td>comm</td>\n<td>通用</td>\n<td>repository</td>\n<td>repo</td>\n<td>仓库</td>\n</tr>\n<tr>\n<td>dependency</td>\n<td>dep</td>\n<td>依赖</td>\n<td>reserve</td>\n<td>resv</td>\n<td>保留</td>\n</tr>\n<tr>\n<td>debug</td>\n<td>dbg</td>\n<td>调试</td>\n<td>reset</td>\n<td>rst</td>\n<td>重置</td>\n</tr>\n<tr>\n<td>direct</td>\n<td>dirt</td>\n<td>直接的</td>\n<td>resume</td>\n<td>resu</td>\n<td>重新开始</td>\n</tr>\n<tr>\n<td>engine</td>\n<td>eng</td>\n<td>引擎</td>\n<td>reverse</td>\n<td>revs</td>\n<td>反转</td>\n</tr>\n<tr>\n<td>experiment</td>\n<td>exp</td>\n<td>实验</td>\n<td>schedule</td>\n<td>sch</td>\n<td>计划</td>\n</tr>\n<tr>\n<td>exposure</td>\n<td>expo</td>\n<td>曝光</td>\n<td>section</td>\n<td>sect</td>\n<td>节</td>\n</tr>\n<tr>\n<td>generate</td>\n<td>gen</td>\n<td>产生</td>\n<td>segment</td>\n<td>seg</td>\n<td>段</td>\n</tr>\n<tr>\n<td>handler</td>\n<td></td>\n<td>处理者</td>\n<td>strategy</td>\n<td>stra</td>\n<td>策略</td>\n</tr>\n<tr>\n<td>marshal</td>\n<td>mar</td>\n<td>序列化</td>\n<td>change</td>\n<td>chg</td>\n<td>改变</td>\n</tr>\n<tr>\n<td>unmarshal</td>\n<td>unmar</td>\n<td>反序列化</td>\n<td>convert</td>\n<td>conv</td>\n<td>转换</td>\n</tr>\n<tr>\n<td>deserialize</td>\n<td>dese</td>\n<td>反序列化</td>\n<td>translate</td>\n<td>tran</td>\n<td>翻译，转换</td>\n</tr>\n<tr>\n<td>manufacturer</td>\n<td>mft</td>\n<td>制造商</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>positive</td>\n<td>posi</td>\n<td>积极的</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>negative</td>\n<td>neg</td>\n<td>消极的</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>neutral</td>\n<td>neut</td>\n<td>中立</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>quality</td>\n<td>qlty</td>\n<td>质量</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>properties</td>\n<td>prop</td>\n<td>性能</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>performance</td>\n<td>perf</td>\n<td>性能</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>product</td>\n<td>prod</td>\n<td>产品</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>profile</td>\n<td>pf</td>\n<td>用户画像</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>project</td>\n<td>proj</td>\n<td>项目</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>protect</td>\n<td>prot</td>\n<td>保护</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>proxy</td>\n<td>prx</td>\n<td>代理</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>public</td>\n<td>pub</td>\n<td>公共的</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<p><strong>常用反义词组</strong></p>\n<table>\n<thead>\n<tr>\n<th>词</th>\n<th>反义词</th>\n<th>中译</th>\n<th>词</th>\n<th>反义词</th>\n<th>中译</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>add</td>\n<td>remove</td>\n<td>添加&#x2F;移除</td>\n<td>min</td>\n<td>max</td>\n<td>最小&#x2F;最大</td>\n</tr>\n<tr>\n<td>add</td>\n<td>delete</td>\n<td>添加&#x2F;删除</td>\n<td>old</td>\n<td>new</td>\n<td>旧&#x2F;新</td>\n</tr>\n<tr>\n<td>begin</td>\n<td>end</td>\n<td>开始&#x2F;最后</td>\n<td>start</td>\n<td>stop</td>\n<td>开始&#x2F;停止</td>\n</tr>\n<tr>\n<td>create</td>\n<td>destroy</td>\n<td>创建&#x2F;破坏</td>\n<td>next</td>\n<td>previous</td>\n<td>下个&#x2F;以前的</td>\n</tr>\n<tr>\n<td>insert</td>\n<td>delete</td>\n<td>插入&#x2F;删除</td>\n<td>source</td>\n<td>target</td>\n<td>源头&#x2F;目标</td>\n</tr>\n<tr>\n<td>first</td>\n<td>last</td>\n<td>第一&#x2F;最后</td>\n<td>show</td>\n<td>hide</td>\n<td>显示&#x2F;隐藏</td>\n</tr>\n<tr>\n<td>get</td>\n<td>release</td>\n<td>获得&#x2F;释放</td>\n<td>send</td>\n<td>receive</td>\n<td>发送&#x2F;接收</td>\n</tr>\n<tr>\n<td>put</td>\n<td>get</td>\n<td>放下&#x2F;获得</td>\n<td>source</td>\n<td>destination</td>\n<td>源头&#x2F;目的</td>\n</tr>\n<tr>\n<td>increment</td>\n<td>decrement</td>\n<td>增加&#x2F;减少</td>\n<td>cut</td>\n<td>paste</td>\n<td>剪切&#x2F;粘贴</td>\n</tr>\n<tr>\n<td>lock</td>\n<td>unlock</td>\n<td>上锁&#x2F;解锁</td>\n<td>up</td>\n<td>down</td>\n<td>上&#x2F;下</td>\n</tr>\n<tr>\n<td>open</td>\n<td>close</td>\n<td>打开&#x2F;关闭</td>\n<td>top</td>\n<td>btm</td>\n<td>顶部&#x2F;底部</td>\n</tr>\n</tbody></table>\n",
            "tags": [
                "words"
            ]
        },
        {
            "id": "https://www.oikiou.top/2023/c98db97a/",
            "url": "https://www.oikiou.top/2023/c98db97a/",
            "title": "RustDesk",
            "date_published": "2023-12-16T10:23:05.000Z",
            "content_html": "<h1 id=\"Server-搭建\"><a href=\"#Server-搭建\" class=\"headerlink\" title=\"Server 搭建\"></a>Server 搭建</h1><p>RustDesk Server OSS<strong>功能简单</strong>，<strong>无需许可证</strong>，RustDesk Server Pro<strong>功能更强</strong>，<strong>需要许可证</strong>。</p>\n<p>参考官方<a href=\"https://rustdesk.com/docs/en/self-host/rustdesk-server-oss/\">文档</a>。</p>\n<h2 id=\"RustDesk-Server-OSS-搭建\"><a href=\"#RustDesk-Server-OSS-搭建\" class=\"headerlink\" title=\"RustDesk Server OSS 搭建\"></a>RustDesk Server OSS 搭建</h2><p>RustDesk Server OSS有两个程序<code>hbbs</code>和<code>hbbr</code>。</p>\n<ul>\n<li><code>hbbs</code>- RustDesk ID&#x2F;Rendezvous 服务器</li>\n<li><code>hbbr</code>- RustDesk 中继服务器</li>\n</ul>\n<blockquote>\n<p>  默认情况下，</p>\n<p>  <code>hbbs</code> 侦听 21115 (TCP)、21116 (TCP&#x2F;UDP) 和 21118 (TCP)，</p>\n<p>  <code>hbbr</code> 侦听 21117 (TCP) 、21119（TCP）。</p>\n<p>  请务必在防火墙中打开这些端口。 <strong>请注意，TCP 和 UDP 都应启用 21116。</strong> </p>\n<p>  21115 用于 NAT 类型测试，21116&#x2F;UDP 用于 ID 注册，心跳服务，21116&#x2F;TCP用于TCP打洞和连接服务，21117用于Relay服务，21118和21119用于支持Web客户端。 </p>\n<p>  <em>如果不需要Web客户端（21118、21119）支持，可以禁用相应端口。</em></p>\n</blockquote>\n<ul>\n<li>TCP (<strong>21115、21116、21117、21118、21119</strong>)</li>\n<li>UDP (<strong>21116</strong>)</li>\n</ul>\n<p>关闭防火墙对端口的封锁：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">ufw allow 21115:21119/tcp<br>ufw allow 21116/udp<br>sudo ufw enable<br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"服务器硬件要求\"><a href=\"#服务器硬件要求\" class=\"headerlink\" title=\"服务器硬件要求\"></a>服务器硬件要求</h3><blockquote>\n<h5 id=\"服务器要求\"><a href=\"#服务器要求\" class=\"headerlink\" title=\"服务器要求\"></a>服务器要求</h5><p>  硬件要求很低；基础云服务器最低配置就够了，对CPU和内存的要求也很低。您还可以使用 Raspberry Pi 或类似的东西。从网络规模来看，如果TCP打洞直连失败，会消耗中继流量。中继连接的流量在 30 K&#x2F;s 到 3 M&#x2F;s（1920x1080 屏幕）之间，具体取决于分辨率设置和屏幕更新。如果只是办公需求，流量在100K&#x2F;s左右。</p>\n</blockquote>\n<h3 id=\"hbbr-的运行\"><a href=\"#hbbr-的运行\" class=\"headerlink\" title=\"hbbr 的运行\"></a>hbbr 的运行</h3><blockquote>\n<p>  <code>hbbs</code>第一次运行时，会自动生成一对加密的私钥和<strong>公钥</strong>（分别位于<code>id_ed25519</code>和<code>id_ed25519.pub</code>运行目录下的文件），其主要目的是通信加密。</p>\n<p>  <strong>公钥就是我们需要填入Client端的key</strong></p>\n<p>  如果您想禁止没有密钥的用户建立非加密连接，请在运行时添加<code>-k _</code>参数<code>hbbs</code>和<code>hbbr</code>。</p>\n<p>  <em>注意不要漏写了下划线</em> 例如：</p>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">./hbbs -r &lt;relay-server-ip[:port]&gt; -k _<br>./hbbr -k _<br></code></pre></td></tr></table></figure>\n</blockquote>\n<h3 id=\"使用Docker搭建\"><a href=\"#使用Docker搭建\" class=\"headerlink\" title=\"使用Docker搭建\"></a>使用Docker搭建</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">sudo docker image pull rustdesk/rustdesk-server<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">-v 映射文件夹 容器内 /root 目录会存放key文件等</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">hbbs 的 -r 参数是 服务器地址</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">hbbs 和 hbbr 的 -k 参数是 禁止没有密钥的用户建立非加密连接</span><br>sudo docker run --name hbbs -v ./data:/root -td -m 64M --restart=on-failure --net=host rustdesk/rustdesk-server hbbs -r &lt;relay-server-ip[:port]&gt; -k _<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\"></span><br><span class=\"language-bash\"><span class=\"hljs-built_in\">sudo</span> docker run --name hbbr -v ./data:/root -td -m 64M --restart=on-failure --net=host rustdesk/rustdesk-server hbbr -k _</span><br><br></code></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"客户端配置\"><a href=\"#客户端配置\" class=\"headerlink\" title=\"客户端配置\"></a>客户端配置</h1><p>在 RustDesk 客户端主主页中，单击 ID 旁边的菜单按钮 [ ⋮ ]，然后单击网络，您现在可以使用提升的权限解锁设置并设置您的 ID、中继、API 和密钥。</p>\n<p><img src=\"/2023/c98db97a/network-config.png\" alt=\"img\"></p>\n<p>在<strong>ID Server</strong>输入框中输入<code>hbbs</code>的域名或IP地址。</p>\n<p>另外两个地址可以留空，RustDesk会自动推导（如果没有专门设置），Relay Server指的是<code>hbbr</code>（端口21117）。</p>\n<p>Key的数值：Docker中可以在<code>data</code>文件夹找到<code>id_ed25519.pub</code>文件，此文件内容即为key。</p>\n",
            "tags": [
                "RustDesk"
            ]
        },
        {
            "id": "https://www.oikiou.top/2023/9c721b62/",
            "url": "https://www.oikiou.top/2023/9c721b62/",
            "title": "USB",
            "date_published": "2023-12-01T10:12:15.000Z",
            "content_html": "<h1 id=\"USB-版本及发展历史\"><a href=\"#USB-版本及发展历史\" class=\"headerlink\" title=\"USB 版本及发展历史\"></a>USB 版本及发展历史</h1><p>USB接口自1994年推出以来，经过26年的发展，经过USB1.0&#x2F;1.1、USB2.0、USB3.x，最终发展到了现在的USB4；传输速率也从最开始的1.5Mbps，大幅提高到了最新的40Gbps。<br><img src=\"/2023/9c721b62/image-20240621114302408.png\"></p>\n<h2 id=\"USB1-0\"><a href=\"#USB1-0\" class=\"headerlink\" title=\"USB1.0\"></a>USB1.0</h2><ul>\n<li>1996年1月15日推出USB1.0接口规范</li>\n<li>规定低速传输速率为1.5Mbit&#x2F;s</li>\n<li>对外提供供电电压为5V，最大电流500mA</li>\n<li>一般适用于鼠标、键盘等低速HID设备。</li>\n<li>支持热插拨</li>\n</ul>\n<h2 id=\"USB1-1\"><a href=\"#USB1-1\" class=\"headerlink\" title=\"USB1.1\"></a>USB1.1</h2><ul>\n<li>1998年9月23日对原来的USB1.0进行升级，提出了USB1.1</li>\n<li>USB1.1规定了全速传输速率为12Mbit&#x2F;s,并兼容USB1.0的1.5Mbit&#x2F;s</li>\n<li>传输线缆最大度度3m</li>\n<li>对外提供供电电压为5V，最大电流500mA</li>\n<li>一般适用于鼠标、键盘、U盘，光驱等。</li>\n<li>一个USB接口理论上可以支持127个设备。</li>\n</ul>\n<h2 id=\"USB2-0\"><a href=\"#USB2-0\" class=\"headerlink\" title=\"USB2.0\"></a>USB2.0</h2><ul>\n<li>2000年4月27日由USB-IF组织提出了USB2.0总线协议规范</li>\n<li>具备480Mbit&#x2F;s的高速传输速率，向下兼容低速1.5Mbit&#x2F;s和全速12Mit&#x2F;s</li>\n<li>传输线缆最大度度5m</li>\n<li>对外提供供电电压为5V，最大电流500mA</li>\n<li>通过HUB级联的方式，一个USB接口理论上可以扩展127个USB设备</li>\n<li>支持 4种传输方式：控制传输、中断传输、同步传输和块传输。</li>\n</ul>\n<p><strong>USB3 的名字有些多</strong></p>\n<table>\n<thead>\n<tr>\n<th>版本</th>\n<th>时间</th>\n<th>带宽</th>\n<th>别名，指的是同一种</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>USB3.0</td>\n<td>2008年11月17</td>\n<td>5Gbps</td>\n<td>SuperSpeed USB、USB 3.2 Gen 1、USB 3.1 Gen 1</td>\n</tr>\n<tr>\n<td>USB3.1</td>\n<td>2013年7月</td>\n<td>10Gbps</td>\n<td>SuperSpeed USB 10Gbps、USB 3.2 Gen 2、USB 3.1 Gen 2</td>\n</tr>\n<tr>\n<td>USB3.2</td>\n<td>2017年9月份</td>\n<td>20Gbps</td>\n<td>SuperSpeed USB 20Gbps、USB 3.2 Gen 2x2</td>\n</tr>\n</tbody></table>\n<h2 id=\"USB3-0-USB-3-2-Gen-1-USB-3-1-Gen-1\"><a href=\"#USB3-0-USB-3-2-Gen-1-USB-3-1-Gen-1\" class=\"headerlink\" title=\"USB3.0 &#x2F; USB 3.2 Gen 1 &#x2F; USB 3.1 Gen 1\"></a>USB3.0 &#x2F; USB 3.2 Gen 1 &#x2F; USB 3.1 Gen 1</h2><ul>\n<li>超高速USB3.0规范于2008年11月17日出USB-IF组织推出。</li>\n<li>提供更高的5.0Gbit&#x2F;s的超高速传输速度，并向下兼容低速1.5Mbits&#x2F;s、全速12Mbit&#x2F;s和高速480Mbit&#x2F;s传输速率</li>\n<li>对外提供供电电压为5V，最大电流900mA</li>\n<li>传输线缆最大度度3m</li>\n<li>增加了新的电源管理功能，支持待机、睡眠以及暂定模式，更加省电。</li>\n<li>全双工通讯。</li>\n</ul>\n<h2 id=\"USB3-1-USB-3-2-Gen-2-USB-3-1-Gen-2\"><a href=\"#USB3-1-USB-3-2-Gen-2-USB-3-1-Gen-2\" class=\"headerlink\" title=\"USB3.1 &#x2F; USB 3.2 Gen 2 &#x2F; USB 3.1 Gen 2\"></a>USB3.1 &#x2F; USB 3.2 Gen 2 &#x2F; USB 3.1 Gen 2</h2><p>2013年7月份，USB 3.1发布，速度翻番至10Gbps，同时USB-IF就把USB 3.0改名为USB 3.1 Gen 1，新的USB 3.1则叫做USB 3.1 Gen 2。</p>\n<ul>\n<li>2013年7月份发布</li>\n<li>速度翻番至10Gbps</li>\n<li>新增USB A&#x2F;V影音传输。以更适合作为移动设备的输出接口，尤其是可逆的Type-C。</li>\n<li>将供电的最高允许标准提高到了20V&#x2F;5A，供电100W。</li>\n<li>必须使用USB Type-C接口才能达到10Gbps的速度。</li>\n</ul>\n<h2 id=\"USB3-2-USB-3-2-Gen-2x2\"><a href=\"#USB3-2-USB-3-2-Gen-2x2\" class=\"headerlink\" title=\"USB3.2 &#x2F; USB 3.2 Gen 2x2\"></a>USB3.2 &#x2F; USB 3.2 Gen 2x2</h2><ul>\n<li>2017年9月份，USB 3.2发布。</li>\n<li>据最新公布的规范，USB 3.0、USB 3.1的版本命名都将彻底消失，统一被划入USB 3.2的序列，三者分别再次改名叫做USB 3.2 Gen 1、USB 3.2 Gen 2、USB 3.2 Gen 2x2。</li>\n<li>它们还各自有一个市场推广命名，分别是SuperSpeed USB、SuperSpeed USB 10Gbps、SuperSpeed USB 20Gbps。<br>  之所以想出USB 3.2 Gen2x2这样的名字，大概是因为它使用了USB Type-C接口的上下两端全部针脚，速度得以翻番。</li>\n<li>必须使用USB Type-C接口才能达到20Gbps的速度。</li>\n</ul>\n<h1 id=\"USB-描述符\"><a href=\"#USB-描述符\" class=\"headerlink\" title=\"USB 描述符\"></a>USB 描述符</h1><blockquote>\n<p>  USB是个通用的总线，端口都是统一的。但是USB设备却各种各样，例如USB鼠标，USB键盘，U盘等等，那么USB主机是如何识别出不同的设备的呢？这就要依赖于描述符了。</p>\n<p>  USB的描述符主要有<strong>设备描述符，配置描述符，接口描述符，端点描述符，字符串描述符，HID描述符，报告描述符</strong>等等。</p>\n</blockquote>\n<p><strong>USB各个描述符之间的关系</strong></p>\n<blockquote>\n<p>  一个USB设备有一个<strong>设备描述符</strong>，设备描述符里面决定了该设备有<strong>多少种配置</strong>，每种配置描述符对应着配置描述符；</p>\n<p>  而在<strong>配置描述符</strong>中又定义了该配置里面有<strong>多少个接口</strong>，每个接口有对应的接口描述符；</p>\n<p>  在<strong>接口描述符</strong>里面又定义了该接口有<strong>多少个端点</strong>，每个端点对应一个端点描述符；</p>\n<p>  在<strong>端点描述符</strong>定义了端点的大小，类型等等。</p>\n<blockquote>\n<p>  由此我们可以看出，USB的描述符之间的关系是一层一层的，最上一层是设备描述符，下面是配置描述符，再下面是接口描述符，再下面是端点描述符。</p>\n<p>  在获取描述符时，先获取设备描述符，然后再获取配置描述符，根据配置描述符中的配置集合长度，一次将配置描述符、接口描述符、端点描述符一起一次读回。</p>\n<p>  其中可能还会有获取设备序列号，厂商字符串，产品字符串等。</p>\n</blockquote>\n</blockquote>\n<p><strong>各个描述符的编号</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> DEVICE_DESCRIPTOR               0x01  <span class=\"hljs-comment\">//设备描述符   </span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> CONFIGURATION_DESCRIPTOR        0x02  <span class=\"hljs-comment\">//配置描述符   </span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> STRING_DESCRIPTOR               0x03  <span class=\"hljs-comment\">//字符串描述符   </span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> INTERFACE_DESCRIPTOR            0x04  <span class=\"hljs-comment\">//接口描述符   </span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> ENDPOINT_DESCRIPTOR             0x05  <span class=\"hljs-comment\">//端点描述符  </span></span><br></code></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"/2023/9c721b62/v2-43379ad330f4acd76ce885f2e1359458_720w.webp\" alt=\"img\"></p>\n<p><img src=\"/2023/9c721b62/usbdes.jpeg\" alt=\"img\"></p>\n<p><img src=\"/2023/9c721b62/image-20240620151939825.png\"></p>\n<h2 id=\"设备描述符-0x01-Device-Descriptor\"><a href=\"#设备描述符-0x01-Device-Descriptor\" class=\"headerlink\" title=\"设备描述符 0x01 Device Descriptor\"></a>设备描述符 0x01 Device Descriptor</h2><p><img src=\"/2023/9c721b62/dev.png\" alt=\"设备描述符\"></p>\n<p><strong>代码</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">// 定义标准的设备描述符结构</span><br><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> _<span class=\"hljs-title\">DEVICE_DCESCRIPTOR_STRUCT</span> &#123;</span><br>    BYTE blength;            <span class=\"hljs-comment\">// 设备描述符的字节数大小</span><br>    BYTE bDescriptorType;    <span class=\"hljs-comment\">// 设备描述符类型编号</span><br>    WORD bcdUSB;             <span class=\"hljs-comment\">// USB版本号</span><br>    BYTE bDeviceClass;       <span class=\"hljs-comment\">// USB分配的设备类代码</span><br>    BYTE bDeviceSubClass;    <span class=\"hljs-comment\">// USB分配的子类代码</span><br>    BYTE bDeviceProtocol;    <span class=\"hljs-comment\">// USB分配的设备协议代码</span><br>    BYTE bMaxPacketSize0;    <span class=\"hljs-comment\">// 端点0的最大包大小</span><br>    WORD idVendor;           <span class=\"hljs-comment\">// 厂商编号</span><br>    WORD idProduct;          <span class=\"hljs-comment\">// 产品编号</span><br>    WORD bcdDevice;          <span class=\"hljs-comment\">// 设备出厂编号</span><br>    BYTE iManufacturer;      <span class=\"hljs-comment\">// 设备厂商字符串的索引</span><br>    BYTE iProduct;           <span class=\"hljs-comment\">// 描述产品字符串的索引</span><br>    BYTE iSerialNumber;      <span class=\"hljs-comment\">// 描述设备序列号字符串的索引</span><br>    BYTE bNumConfigurations; <span class=\"hljs-comment\">// 可能的配置数量</span><br>&#125; DEVICE_DESCRIPTOR_STRUCT, *pDEVICE_DESCRIPTOR_STRUCT;<br><br><span class=\"hljs-comment\">// 实际的设备描述符示例</span><br>DEVICE_DESCRIPTOR_STRUCT device_descriptor = &#123;<br>.blength           =<span class=\"hljs-keyword\">sizeof</span>(DEVICE_DESCRIPTOR_STRUCT),<span class=\"hljs-comment\">// 设备描述符的字节数大小，这里是18字节</span><br>.bDescriptorType   =DEVICE_DESCRIPTOR,  <span class=\"hljs-comment\">// 设备描述符类型编号，设备描述符是01</span><br>.bcdUSB            =<span class=\"hljs-number\">0x1001</span>, <span class=\"hljs-comment\">// USB版本号，这里是USB01.10，即USB1.1。由于51是大端模式，所以高低字节交换</span><br>.bDeviceClass      =<span class=\"hljs-number\">0x00</span>,   <span class=\"hljs-comment\">// USB分配的设备类代码，0表示类型在接口描述符中定义</span><br>.bDeviceSubClass   =<span class=\"hljs-number\">0x00</span>,   <span class=\"hljs-comment\">// USB分配的子类代码，上面一项为0时，本项也要设置为0</span><br>.bDeviceProtocol   =<span class=\"hljs-number\">0x00</span>,   <span class=\"hljs-comment\">// USB分配的设备协议代码，上面一项为0时，本项也要设置为0</span><br>.bMaxPacketSize0   =<span class=\"hljs-number\">0x10</span>,   <span class=\"hljs-comment\">// 端点0的最大包大小，这里为16字节</span><br>.idVendor          =<span class=\"hljs-number\">0x7104</span>, <span class=\"hljs-comment\">// 厂商编号，这个是需要跟USB组织申请的ID号，表示厂商代号。</span><br>.idProduct         =<span class=\"hljs-number\">0xf0ff</span>, <span class=\"hljs-comment\">// 该产品的编号，跟厂商编号一起配合使用，让主机注册该设备并加载相应的驱动程序</span><br>.bcdDevice         =<span class=\"hljs-number\">0x0100</span>, <span class=\"hljs-comment\">// 设备出厂编号</span><br>.iManufacturer     =<span class=\"hljs-number\">0x01</span>,   <span class=\"hljs-comment\">// 设备厂商字符串的索引，在获取字符串描述符时，使用该索引号来识别不同的字符串</span><br>.iProduct          =<span class=\"hljs-number\">0x02</span>,   <span class=\"hljs-comment\">// 描述产品字符串的索引，同上</span><br>.iSerialNumber     =<span class=\"hljs-number\">0x03</span>,   <span class=\"hljs-comment\">// 描述设备序列号字符串的索引，同上</span><br>.bNumConfigurations=<span class=\"hljs-number\">0x01</span>    <span class=\"hljs-comment\">// 可能的配置数为1，即该设备只有一个配置</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li><p><strong>bLength</strong></p>\n<ul>\n<li>是设备描述符的总长度，以字节为单位。</li>\n</ul>\n</li>\n<li><p><strong>bDescriptorType</strong></p>\n<ul>\n<li>代表了本描述符的类型。</li>\n<li>用于描述设备的描述符 是0x01。<ul>\n<li>其他描述符的数值及含义</li>\n<li><img src=\"/2023/9c721b62/d976ff82852a45ea8fc59183689cbd5b.png\" alt=\"在这里插入图片描述\"></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>bcdUSB</strong></p>\n<ul>\n<li>显示了设备支持的USB版本，通常是最新版本。</li>\n<li>这是一个<a href=\"https://so.csdn.net/so/search?q=%E4%BA%8C%E8%BF%9B%E5%88%B6&spm=1001.2101.3001.7020\">二进制</a>代码形式的十进制数据，采用0xAABC的形式，其中A是主版本号，B是次版本号，C是子次版本号。</li>\n<li>例如，USB2.0设备拥有0x0200值，USB1.1设备拥有0x0110值。通常，主机将使用bcdUSB以确定需要加载的USB驱动器。</li>\n</ul>\n</li>\n<li><p><strong>bDeviceClass</strong>、<strong>bDeviceSubClass</strong>、<strong>bDeviceProtocol</strong></p>\n<ul>\n<li>分别代表<strong>设备类型</strong>，<strong>子类型</strong>，<strong>设备使用的协议</strong></li>\n<li>USB-IF区分设备类分了三个等级（类-子类-协议码）其中，<ul>\n<li>类包含人机交互类、图像类、无线类、音频类等等，</li>\n<li>子类比如音频类的音频控制、音频流等等，</li>\n<li>协议比如人机接口类中的鼠标、键盘、<a href=\"https://so.csdn.net/so/search?q=%E8%A7%A6%E6%91%B8%E5%B1%8F&spm=1001.2101.3001.7020\">触摸屏</a>等，</li>\n</ul>\n</li>\n<li><blockquote>\n<p>  为何会有这么多USB的Class分类，子分类，设备协议。<br>  我们要知道，USB协议设计的目的，就是为实现通用，用单一的USB接口取代之前种类繁多的各种其他接口。而为了取代其他各种接口，那意味着就要实现各种设备所对应的各种功能。</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p><strong>bMaxPackeSize0</strong></p>\n<ul>\n<li>端点一次最大传多少个字节。</li>\n<li>根据设备，数据包的大小可以为 8 个字节、 16 个字节、 32 个字节和 64 个字节。</li>\n<li>USB协议里有规定，端点0最低8字节，端点的最大传输大小和USB速度等级以及传输类型有关，<strong>控制传输一般使用端点0</strong>，低速最大8字节，全速和高速最大传输64字节：</li>\n</ul>\n</li>\n<li><p><strong>idVendor</strong></p>\n<ul>\n<li>代表着设备的生产商ID,由USB设备生产商向USB-IF官方来统一管理和申请。</li>\n</ul>\n</li>\n<li><p><strong>idProduct</strong></p>\n<ul>\n<li>代表着该生产商生产的产品编号，同一厂商下的不同idProduct代表着该公司不同的产品系列。</li>\n</ul>\n</li>\n<li><p><strong>bcdDevice</strong></p>\n<ul>\n<li>是一个BCD编码格式，代表着设备的出产编号，或者同一产品的版本更新迭代。</li>\n</ul>\n</li>\n<li><p><strong>iManufacturer</strong></p>\n<ul>\n<li>描述厂商的字符串的索引，为0则表示没有。</li>\n</ul>\n</li>\n<li><p><strong>iProduct</strong></p>\n<ul>\n<li>描述产品的字符串的索引，为0则表示没有。</li>\n</ul>\n</li>\n<li><p><strong>iSerialNumber</strong></p>\n<ul>\n<li>产品序列号字符串的索引，为0则表示没有。</li>\n</ul>\n</li>\n<li><p><strong>bNumConfigurations</strong></p>\n<ul>\n<li>指示设备有多少个配置，前面提到过，一个USB可能有多个配置，一般USB产品都是1个配置。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"配置描述符-0x02-Configuration-Descriptor\"><a href=\"#配置描述符-0x02-Configuration-Descriptor\" class=\"headerlink\" title=\"配置描述符 0x02 Configuration Descriptor\"></a>配置描述符 0x02 Configuration Descriptor</h2><table>\n<thead>\n<tr>\n<th>偏移</th>\n<th>字段</th>\n<th>大小<br>Byte</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>bLength</td>\n<td>1</td>\n<td>该描述符的长度 &#x3D; 9 个字节</td>\n</tr>\n<tr>\n<td>1</td>\n<td>bDescriptorType</td>\n<td>1</td>\n<td>描述符类型 &#x3D; 配置（02h）</td>\n</tr>\n<tr>\n<td>2</td>\n<td>wTotalLength</td>\n<td>2</td>\n<td>总长度包括接口和端点描述符在内</td>\n</tr>\n<tr>\n<td>4</td>\n<td>bNumInterfaces</td>\n<td>1</td>\n<td>本配置中接口的数量</td>\n</tr>\n<tr>\n<td>5</td>\n<td>bConfigurationValue</td>\n<td>1</td>\n<td>SET_CONFIGURATION 请求所使用的配置值，用于选择该配置</td>\n</tr>\n<tr>\n<td>6</td>\n<td>iConfiguration</td>\n<td>1</td>\n<td>描述该配置的字符串索引</td>\n</tr>\n<tr>\n<td>7</td>\n<td>bmAttributes</td>\n<td>1</td>\n<td>位 7：预留（设置为 1） <br>位 6：自供电 <br>位 5：远程唤醒<br>位 4:0：保留</td>\n</tr>\n<tr>\n<td>8</td>\n<td>bMaxPower</td>\n<td>1</td>\n<td>本配置所需的最大功耗（单位为 2 mA）</td>\n</tr>\n</tbody></table>\n<ul>\n<li><p><strong>bLength</strong> 1字节，表示配置描述符的长度，配置描述符的长度是9字节。</p>\n</li>\n<li><p><strong>bDescriptor</strong> 1字节，表示描述符的类型，配置描述符的类型编码为 0x02。</p>\n</li>\n<li><p><strong>wTotalLength</strong> 2字节，是整个配置描述符集合的总长度。包括配置描述符，接口描述符，端点描述符和类特殊描述符（如果有）。</p>\n</li>\n<li><p><strong>bNumInterfaces</strong> 1字节，则定义了在该指定配置中接口总数。最小为 1 个接口，通常功能单一的设备只有一个接口（如鼠标），而复合设备具有多个接口（如音频设备）。</p>\n</li>\n<li><p><strong>bConfigurationValue</strong> 1字节，表示该配置的值，设置配置请求时会发送一个配置值，如果某个配置的bConfigurationValue和它相匹配，就表示该配置被激活。</p>\n</li>\n<li><p><strong>iConfiguration</strong> 1字节，描述该配置的字符串的索引，如果该值为0，表示没有字符串来描述它。</p>\n</li>\n<li><p><strong>bmAttributes</strong> 1字节，定义了 USB 设备的一些特性。 位7保留，必须设置为1，位6表示供电方式，设置为 0表示设备由总线供电，设置为 1 表示设备自供电。位5表示是否支持远程唤醒，设置为 1表示支持远程唤醒，设置为 0 表示不支持远程唤醒。位4~位0设置为0。</p>\n</li>\n<li><p><strong>bMaxPower</strong> 1字节，表示设备需要从总线获取的最大电流量，以 2 mA 为单位。如需要200mA的最大电流，则该字段的值为100。</p>\n</li>\n</ul>\n<h2 id=\"字符串描述符-0x03\"><a href=\"#字符串描述符-0x03\" class=\"headerlink\" title=\"字符串描述符 0x03\"></a>字符串描述符 0x03</h2><table>\n<thead>\n<tr>\n<th>偏移</th>\n<th>字段</th>\n<th>大小（字节）</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>bLength</td>\n<td>1</td>\n<td>该描述符的长度 &#x3D; 7 个字节</td>\n</tr>\n<tr>\n<td>1</td>\n<td>bDescriptorType</td>\n<td>1</td>\n<td>描述符类型 &#x3D; STRING （03h）</td>\n</tr>\n<tr>\n<td>2..n</td>\n<td>bString 或 wLangID</td>\n<td>变化</td>\n<td>Unicode 编码字符串 或 LANGID 代码</td>\n</tr>\n</tbody></table>\n<p>字符串描述符是可选的，字符串描述符用于描述一些方便人们阅读的信息，比如制造商、设备名称啥的。如果一个设备没有字符串描述符，那么其他描述符中和字符串有关的索引值都必须为 0。</p>\n<h2 id=\"接口描述符-0x04-Interface-Descriptor\"><a href=\"#接口描述符-0x04-Interface-Descriptor\" class=\"headerlink\" title=\"接口描述符 0x04 Interface Descriptor\"></a>接口描述符 0x04 Interface Descriptor</h2><table>\n<thead>\n<tr>\n<th>偏移</th>\n<th>字段</th>\n<th>大小（字节）</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>bLength</td>\n<td>1</td>\n<td>该描述符的长度 &#x3D; 9 个字节</td>\n</tr>\n<tr>\n<td>1</td>\n<td>bDescriptorType</td>\n<td>1</td>\n<td>描述符类型 &#x3D; 接口（04h）</td>\n</tr>\n<tr>\n<td>2</td>\n<td>bInterfaceNumber</td>\n<td>1</td>\n<td>该接口基于零的索引</td>\n</tr>\n<tr>\n<td>3</td>\n<td>bAlternateSetting</td>\n<td>1</td>\n<td>备用设置值</td>\n</tr>\n<tr>\n<td>4</td>\n<td>bNumEndpoints</td>\n<td>1</td>\n<td>该接口所使用的端点数量（不包含 EP0）</td>\n</tr>\n<tr>\n<td>5</td>\n<td>bInterfaceClass</td>\n<td>1</td>\n<td>接口类别</td>\n</tr>\n<tr>\n<td>6</td>\n<td>bInterfaceSubclass</td>\n<td>1</td>\n<td>接口子类别</td>\n</tr>\n<tr>\n<td>7</td>\n<td>bInterfaceProtocol</td>\n<td>1</td>\n<td>接口协议</td>\n</tr>\n<tr>\n<td>8</td>\n<td>iInterface</td>\n<td>1</td>\n<td>该接口字符串描述符索引</td>\n</tr>\n</tbody></table>\n<ul>\n<li><strong>bLength</strong> 1字节，表示接口描述符的长度，标准的接口描述符的长度为9字节。</li>\n<li><strong>bDescriptorType</strong> 1字节，表示描述符的类型，接口描述符的类型编码为 0x04。</li>\n<li><strong>bInterfaceNumber</strong> 1字节，表示该接口的编号，如果一个配置具有多个接口，每个接口的编号都不相同，从0开始依次递增对一个配置的接口进行编号。</li>\n<li><strong>bAlternateSetting</strong> 1字节，接口的备用编号，很少用到，设置为0。</li>\n<li><strong>bNumEndpoints</strong> 1字节，表示该接口的端点数（不包括0端点）。</li>\n<li><strong>bInterfaceClass、bInterfaceSubClass、bInterfaceProtocol</strong> 均为1字节，分别表示接口所使用的类，子类以及协议，由USB协会规定。</li>\n<li><strong>iInterface</strong> 1字节，描述该接口的字符串的索引值，如果为0，表示没有字符串。</li>\n</ul>\n<p><strong>bInterfaceClass</strong>、<strong>bDeviceClass</strong>：</p>\n<table>\n<thead>\n<tr>\n<th>Base Class</th>\n<th>Descriptor Usage</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>00h</td>\n<td>Device</td>\n<td>Use class information in the Interface Descriptors</td>\n</tr>\n<tr>\n<td>01h</td>\n<td>Interface</td>\n<td>Audio USB音频，参见UAC规范</td>\n</tr>\n<tr>\n<td>02h</td>\n<td>Both</td>\n<td>Communications and <a href=\"https://www.usbzh.com/article/detail-842.html\">CDC</a> Control 网卡、调制解调器、串列端口</td>\n</tr>\n<tr>\n<td>03h</td>\n<td>Interface</td>\n<td><a href=\"https://www.usbzh.com/article/detail-76.html\">HID</a> (Human Interface Device)，键盘、鼠标 参见<a href=\"https://www.usbzh.com/article/detail-76.html\">HID</a>规范</td>\n</tr>\n<tr>\n<td>05h</td>\n<td>Interface</td>\n<td>Physical 控制杆</td>\n</tr>\n<tr>\n<td>06h</td>\n<td>Interface</td>\n<td>Image 影像扫描仪、Picture Transfer Protocol</td>\n</tr>\n<tr>\n<td>07h</td>\n<td>Interface</td>\n<td>Printer 打印机</td>\n</tr>\n<tr>\n<td>08h</td>\n<td>Interface</td>\n<td>Mass Storage U盘、移动硬盘、存储卡读卡器、数字相机</td>\n</tr>\n<tr>\n<td>09h</td>\n<td>Device</td>\n<td>Hub <a href=\"https://www.usbzh.com/article/detail-25.html\">集线器</a></td>\n</tr>\n<tr>\n<td>0Ah</td>\n<td>Interface</td>\n<td><a href=\"https://www.usbzh.com/article/detail-842.html\">CDC</a>-Data 调制解调器、网络卡、ISDN、传真</td>\n</tr>\n<tr>\n<td>0Bh</td>\n<td>Interface</td>\n<td>Smart Card 读卡器</td>\n</tr>\n<tr>\n<td>0Dh</td>\n<td>Interface</td>\n<td>Content Security</td>\n</tr>\n<tr>\n<td>0Eh</td>\n<td>Interface</td>\n<td>Video USB视频，<a href=\"https://www.usbzh.com/article/detail-80.html\">UVC</a>摄像头，参见<a href=\"https://www.usbzh.com/article/detail-80.html\">UVC</a>规范</td>\n</tr>\n<tr>\n<td>0Fh</td>\n<td>Interface</td>\n<td>Personal Healthcare</td>\n</tr>\n<tr>\n<td>10h</td>\n<td>Interface</td>\n<td>Audio&#x2F;Video Devices</td>\n</tr>\n<tr>\n<td>11h</td>\n<td>Device</td>\n<td>Billboard Device Class</td>\n</tr>\n<tr>\n<td>12h</td>\n<td>Interface</td>\n<td>USB Type-C Bridge Class</td>\n</tr>\n<tr>\n<td>DCh</td>\n<td>Both</td>\n<td>Diagnostic Device</td>\n</tr>\n<tr>\n<td>E0h</td>\n<td>Interface</td>\n<td>Wireless Controller 蓝牙</td>\n</tr>\n<tr>\n<td>EFh</td>\n<td>Both</td>\n<td>Miscellaneous</td>\n</tr>\n<tr>\n<td>FEh</td>\n<td>Interface</td>\n<td>Application Specific 红外线资料桥接器</td>\n</tr>\n<tr>\n<td>FFh</td>\n<td>Both</td>\n<td>Vendor Specific 自定义USB设备</td>\n</tr>\n<tr>\n<td>更多信息参考 <a href=\"https://www.usb.org/defined-class-codes\">USB.org</a> 的部分章节</td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"端点描述符-0x05-Endpoint-Descriptor\"><a href=\"#端点描述符-0x05-Endpoint-Descriptor\" class=\"headerlink\" title=\"端点描述符 0x05 Endpoint Descriptor\"></a>端点描述符 0x05 Endpoint Descriptor</h2><table>\n<thead>\n<tr>\n<th>偏移</th>\n<th>字段</th>\n<th>大小<br>Byte</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>bLength</td>\n<td>1</td>\n<td>该描述符长度 &#x3D; 7 个字节</td>\n</tr>\n<tr>\n<td>1</td>\n<td>bDescriptorType</td>\n<td>1</td>\n<td>描述符类型 &#x3D; 端点（05h）</td>\n</tr>\n<tr>\n<td>2</td>\n<td>bEndpointAddress</td>\n<td>1</td>\n<td><strong>位 3…0</strong>：端点数量 <br/><strong>位 6…4</strong>：预留，复位为零 <br/><strong>位 7</strong>：端点的方向。控制端点可以忽略该位。 <br/>0 &#x3D; OUT 端点 (主机到设备) <br/>1 &#x3D; IN 端点 (设备到主机)</td>\n</tr>\n<tr>\n<td>3</td>\n<td>bmAttributes</td>\n<td>1</td>\n<td><strong>位 1…0</strong>：传输类型 <br/>00 &#x3D; 控制传输 <br/>01 &#x3D; 同步传输 <br/>10 &#x3D; 批量传输 <br/>11 &#x3D; 中断传输 <br/>如果该端点不是同步端点，那么位 5 到位 2 将被预留，必须将这些位设置为零。如果该端点是同步的，这些位将按如下内容定义： <br/><strong>位 3…2</strong>：同步类型 <br/>00 &#x3D; 无同步 <br/>01 &#x3D; 异步 <br/>10 &#x3D; 自适应 <br/>11 &#x3D; 同步 <br/><strong>位 5…4</strong>：用途类型 <br/>00 &#x3D; 数据端点 <br/>01 &#x3D; 反馈端点 <br/>10 &#x3D; 隐式反馈数据端点 <br/>数值 11 表示保留</td>\n</tr>\n<tr>\n<td>4</td>\n<td>wMaxPacketSize</td>\n<td>1</td>\n<td>该端点的数据包最大尺寸</td>\n</tr>\n<tr>\n<td>6</td>\n<td>bInterval</td>\n<td>1</td>\n<td>中断端点的轮询间隔，单位为 ms（对于同步端点，该间隔为 1 ms；控制或批量端点可能忽略该字段）</td>\n</tr>\n</tbody></table>\n<ul>\n<li><strong>bLength</strong> 1字节，表示端点描述符的长度，标准的端点描述符的长度为7字节。</li>\n<li><strong>bDescriptorType</strong> 1字节，表示描述符的类型，端点描述符的类型编码为 0x05。</li>\n<li><strong>bEndpointAddress</strong> 1字节，表示该端点的地址和方向。</li>\n<li><strong>bmAttributes</strong> 1字节，表示该端点的属性，详细看上表。<ul>\n<li><strong>Transfer Type</strong> <ul>\n<li><strong>控制CONTROL</strong> 控制端点被用来控制对 USB 设备的不同部分访问。<em>通常用作配置设备、获取设备信息、发送命令到设备或获取设备状态报告</em>。这些端点通常较小。<em>每个 USB 设备都有一个控制端点称为”端点 0”, 被 USB 核心用来在插入时配置设备</em>。USB协议保证总有足够的带宽留给控制端点传送数据到设备.  </li>\n<li><strong>中断INTERRUPT</strong>每当 USB 主机向设备请求数据时，中断端点以固定的速率传送<em>小量的数据</em>。此为USB 键盘和鼠标的主要的数据传送方法。它还用以传送数据到 USB 设备来控制设备。<em>通常不用来传送大量数据</em>。USB协议保证总有足够的带宽留给中断端点传送数据到设备.</li>\n<li><strong>批量BULK</strong>  批量端点用以传送大量数据。这些端点常比中断端点大得多. 它们普遍用于<em>不能有任何数据丢失的数据</em>。USB 协议<em>不保证传输在特定时间范围内完成</em>。如果总线上没有足够的空间来发送整个BULK包，它被分为多个包进行传输。这些端点普遍用于打印机、USB Mass Storage和USB网络设备上。</li>\n<li><strong>等时ISOCHRONOUS</strong> 等时端点也批量传送大量数据, 但是这个数据<em>不被保证能送达</em>。这些端点用在可以处理数据丢失的设备中，并且更多依赖于保持持续的数据流。如音频和视频设备等等。</li>\n<li>对比总结：<em>控制</em>和<em>批量</em>端点用于异步数据传送，而<em>中断</em>和<em>同步</em>端点是周期性的。这意味着这些端点被设置来在固定的时间连续传送数据，USB 核心为它们保留了相应的带宽。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>wMaxPacketSize</strong> 2字节，表示该端点的数据包最大长度。</li>\n<li><strong>bInterval</strong> 1字节</li>\n</ul>\n<p>每个端点描述符都规定了该端点所支持的最大数据包长 (wMaxPacketSize)，主机每次发送数据包，都不能超过端点的最大包长，各种端点的最大包长如下表：</p>\n<table>\n<thead>\n<tr>\n<th>端点类型</th>\n<th>最大包长 (低速)</th>\n<th>最大包长 (全速)</th>\n<th>最大包长 (高)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>控制端点</td>\n<td>8</td>\n<td>8&#x2F;16&#x2F;32&#x2F;64</td>\n<td>64</td>\n</tr>\n<tr>\n<td>实时端点</td>\n<td>不支持</td>\n<td>1023</td>\n<td>1024</td>\n</tr>\n<tr>\n<td>中断端点</td>\n<td>8</td>\n<td>64</td>\n<td>1024</td>\n</tr>\n<tr>\n<td>批量端点</td>\n<td>不支持</td>\n<td>8&#x2F;16&#x2F;32&#x2F;64</td>\n<td>512</td>\n</tr>\n</tbody></table>\n<h1 id=\"HID\"><a href=\"#HID\" class=\"headerlink\" title=\"HID\"></a>HID</h1><h1 id=\"UVC\"><a href=\"#UVC\" class=\"headerlink\" title=\"UVC\"></a>UVC</h1><blockquote>\n<p>UVC，全称为：USB video(device) class,是微软与另外几家设备厂商联合推出的为USB视频捕获设备定义的协议标准，目前已成为USB org标准之一。</p>\n</blockquote>\n",
            "tags": [
                "embedded",
                "usb"
            ]
        },
        {
            "id": "https://www.oikiou.top/2023/a3ad4999/",
            "url": "https://www.oikiou.top/2023/a3ad4999/",
            "title": "查看Apk安装包的签名",
            "date_published": "2023-11-20T09:47:15.000Z",
            "content_html": "<h1 id=\"查看apk安装包的签名\"><a href=\"#查看apk安装包的签名\" class=\"headerlink\" title=\"查看apk安装包的签名\"></a>查看apk安装包的签名</h1><p>首先，确保你已经安装了Java开发工具包（JDK），以便使用其中的工具。</p>\n<p>查看Android apk的签名信息方式有两种</p>\n<ol>\n<li><p>直接查看apk的签名信息（推荐）</p>\n<ol>\n<li><pre><code class=\"shell\">keytool -list -printcert -jarfile wechat.apk \n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\"><br>2.   通过apk中的RSA文件查看签名信息<br><br>     1.   将apk后缀改为.<span class=\"hljs-keyword\">zip</span>，然后解压（**apk其实是一个用<span class=\"hljs-keyword\">zip</span>压缩的文件**），再进入<span class=\"hljs-keyword\">META</span>-<span class=\"hljs-keyword\">INF</span>目录，找到RSA文件<br><br>     2.   ```<span class=\"hljs-keyword\">shell</span><br>          keytool -printcert -<span class=\"hljs-keyword\">file</span> COM_TENC.RSA <br></code></pre></td></tr></table></figure>\n</code></pre>\n</li>\n</ol>\n</li>\n</ol>\n",
            "tags": [
                "apk",
                "java"
            ]
        },
        {
            "id": "https://www.oikiou.top/2023/96364bb6/",
            "url": "https://www.oikiou.top/2023/96364bb6/",
            "title": "踩坑记 BSS段的初始化",
            "date_published": "2023-10-20T11:23:05.000Z",
            "content_html": "<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>接手一个项目，调试全靠串口日志，测试同事测试产品的时候无法拿到日志，刚好产品RAM够大，且刚好有SD卡。所以就诞生了将日志缓存在RAM上，在特定条件下将它写到SD卡上的想法。</p>\n<p>开工。</p>\n<p>写完代码之后发现机器<strong>偶尔会无法启动</strong>，无法开机，无任何日志。</p>\n<p>有的时候是<strong>烧录完成代码后重启无法启动</strong>，有些情况下是<strong>烧录完成代码后运行正常，放置一段时间后无法启动</strong>。</p>\n<p>有时候有些无法启动的机器<strong>放置一段时间又成功启动</strong>。</p>\n<p>一段一段代码，屏蔽，编译，验证，发现一个非常无法理解的事，<code>TFCardLogBufferPut</code>函数注释后设备可以正常启动。</p>\n<p>看代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> TF_CARD_LOG_BUFFER_SIZE     (64*1024ul)</span><br><span class=\"hljs-type\">uint8_t</span> tfCardLogBuffer[TF_CARD_LOG_BUFFER_SIZE] = &#123;<span class=\"hljs-number\">0</span>&#125;;<br><span class=\"hljs-type\">uint32_t</span> tfCardLogBufferIndex = <span class=\"hljs-number\">0</span>;<br><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">TFCardLogBufferPut</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint8_t</span> data)</span> &#123;<br>    tfCardLogBuffer[tfCardLogBufferIndex] = data;<br>    tfCardLogBufferIndex++;<br>    <span class=\"hljs-keyword\">if</span>( tfCardLogBufferIndex&gt;=(<span class=\"hljs-keyword\">sizeof</span>(tfCardLogBuffer)/<span class=\"hljs-keyword\">sizeof</span>(tfCardLogBuffer[<span class=\"hljs-number\">0</span>]))<span class=\"hljs-number\">-1</span> ) &#123;<br>        tfCardLogBufferIndex = <span class=\"hljs-number\">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<p>我实在无法理解，这段代码是如何导致设备无法启动的，后面搁置了一段时间，遂归结于小众芯片不完善导致。</p>\n<p>但是后面这个需求实在是过于旺盛，遂重新开始验证代码。</p>\n<p>当时代码是这样的：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">// main.c</span><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> **argv)</span> &#123;<br>    <br>    hal_uartInit();<br>    ax32xx_uart0SendByte(<span class=\"hljs-string\">&#x27;a&#x27;</span>);<br>    ax32xx_uart0SendByte(<span class=\"hljs-string\">&#x27;b&#x27;</span>);<br>    hal_uartSendData(<span class=\"hljs-string\">&#x27;1&#x27;</span>);<br>    hal_uartSendData(<span class=\"hljs-string\">&#x27;2&#x27;</span>);<br>    ax32xx_uart0SendByte(<span class=\"hljs-string\">&#x27;c&#x27;</span>);<br>    <br>    hal_sysInit();<br>    <br>    <span class=\"hljs-comment\">//.... some code here</span><br>&#125;<br><br><span class=\"hljs-comment\">// uart.c</span><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">hal_uartSendData</span><span class=\"hljs-params\">(u8 data)</span><br>&#123;<br>    ax32xx_uart0SendByte(data);<br>    <br>    TFCardLogBufferPut(data);<br>&#125;<br><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">ax32xx_uart0SendByte</span><span class=\"hljs-params\">(u8 data)</span><br>&#123;<br>    R_UART_DATA0 = data;<br>    <span class=\"hljs-keyword\">while</span>((R_UART_PEND0 &amp; <span class=\"hljs-number\">0x2</span>)==<span class=\"hljs-number\">0</span>);<br>    R_UART_PEND0 |= <span class=\"hljs-number\">1</span>;<br>&#125;<br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> TF_CARD_LOG_BUFFER_SIZE     (64*1024ul)</span><br><span class=\"hljs-type\">uint8_t</span> tfCardLogBuffer[TF_CARD_LOG_BUFFER_SIZE] = &#123;<span class=\"hljs-number\">0</span>&#125;;<br><span class=\"hljs-type\">uint32_t</span> tfCardLogBufferIndex = <span class=\"hljs-number\">0</span>;<br><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">TFCardLogBufferPut</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint8_t</span> data)</span> &#123;<br>    tfCardLogBuffer[tfCardLogBufferIndex] = data;<br>    tfCardLogBufferIndex = (tfCardLogBufferIndex&gt;=(<span class=\"hljs-keyword\">sizeof</span>(tfCardLogBuffer)/<span class=\"hljs-keyword\">sizeof</span>(tfCardLogBuffer[<span class=\"hljs-number\">0</span>]))<span class=\"hljs-number\">-1</span>) ? <span class=\"hljs-number\">0</span> : tfCardLogBufferIndex+<span class=\"hljs-number\">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>运行后日志是这样的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs log\"># 正常运行 的日志<br>ab12c ...<br><br># 无法启动 的日志<br>ab1<br></code></pre></td></tr></table></figure>\n\n\n\n<p>后面我就猜想了很多：</p>\n<ul>\n<li>这个soc不能支持这么大的数值 64KB</li>\n<li>这个位置的内存被改写了</li>\n<li>和冷启动热启动有关</li>\n<li>芯片异常</li>\n</ul>\n<p>后面我猜想，试试把<code>TFCardLogBufferPut</code>函数里面的<code>tfCardLogBufferIndex</code>的数值和<code>data</code>数值输出出来看看。</p>\n<p>这一看不得了，越界了！</p>\n<p>代码：</p>\n<p><img src=\"/2023/96364bb6/image-20231020190520640.png\" alt=\"image-20231020190520640\"></p>\n<p>输出日志：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs log\">ab1z31m00327300<br></code></pre></td></tr></table></figure>\n\n\n\n\n\n<p>这个<code>tfCardLogBufferIndex</code>越界了啊！而且初始化赋0并没有成功！这就非常坑爹了！</p>\n<p>后面尝试在调用这个函数之前再次赋0，发现程序运行正常，设备也正常启动。</p>\n<p>查看map文件这个数组和变量也是存放在BSS段的，这就非常令人费解了。</p>\n<p>看到这里我直接就怀疑，就是这个芯片的锅。</p>\n<p>但是别急这还不是让人最震惊的！后面还有让人更加鼻血飙升的。</p>\n<p>最后找FAE排查问题很久，最后发现BSS段在<code>hal_sysInit</code>函数内初始化。</p>\n<p>看代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">ax32xx_sysInit</span><span class=\"hljs-params\">(u32 *saddr,u32 *eaddr)</span><br>&#123;<br>\tdebg(<span class=\"hljs-string\">&quot;sys init\\n&quot;</span>);\t\t\t<span class=\"hljs-comment\">// 这个debg会调用 hal_uartSendData 函数输出日志</span><br>    <br>    <span class=\"hljs-comment\">//...</span><br>    <br>\tax32xx_wdtClear();<br><br><span class=\"hljs-comment\">//-----cache set</span><br>\tax32xx_sysIcacheInit();<br>\tax32xx_sysDcacheInit();\t<br><span class=\"hljs-comment\">//-----bss clear</span><br>\tax32xx_sysBSSClear();<br>    <br>    <span class=\"hljs-comment\">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<p>实在是震惊，无法理解这个RAM的初始化为什么放在main函数里面，实在无法理解进入main函数了，c语言环境都没有OK。</p>\n<p>最烦的就是这种xx芯片，总是会有一些让人血压飙升的操作。</p>\n<blockquote>\n<p>  参考ARM MDK在编译的时候BSS初始化的操作是放在<code>__main</code>函数里面，需要注意的是这个<code>__main</code>不是c语言里面的<code>main</code>函数，它是从MDK自带的库文件里链接的一个函数。这个<code>__main</code>函数会初始化这些段，并调用<code>__rt_entry</code>，最终在<code>__rt_entry</code>中将会调用c语言里面的<code>main</code>函数。</p>\n</blockquote>\n<h1 id=\"教训总结\"><a href=\"#教训总结\" class=\"headerlink\" title=\"教训总结\"></a>教训总结</h1><p>在对数组进行访问的时候一定要先检查范围。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">// 原函数</span><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">TFCardLogBufferPut</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint8_t</span> data)</span> &#123;<br>    tfCardLogBuffer[tfCardLogBufferIndex] = data;<br>    tfCardLogBufferIndex = (tfCardLogBufferIndex&gt;=(<span class=\"hljs-keyword\">sizeof</span>(tfCardLogBuffer)/<span class=\"hljs-keyword\">sizeof</span>(tfCardLogBuffer[<span class=\"hljs-number\">0</span>]))<span class=\"hljs-number\">-1</span>) ? <span class=\"hljs-number\">0</span> : tfCardLogBufferIndex+<span class=\"hljs-number\">1</span>;<br>&#125;<br><br><span class=\"hljs-comment\">// 改后</span><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">TFCardLogBufferPut</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint8_t</span> data)</span> &#123;<br>    <span class=\"hljs-keyword\">if</span>( tfCardLogBufferIndex&gt;=(<span class=\"hljs-keyword\">sizeof</span>(tfCardLogBuffer)/<span class=\"hljs-keyword\">sizeof</span>(tfCardLogBuffer[<span class=\"hljs-number\">0</span>]))<span class=\"hljs-number\">-1</span> ) &#123;<br>        tfCardLogBufferIndex = <span class=\"hljs-number\">0</span>;<br>    &#125;<br>    tfCardLogBuffer[tfCardLogBufferIndex] = data;<br>    tfCardLogBufferIndex++;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n",
            "tags": [
                "embedded"
            ]
        },
        {
            "id": "https://www.oikiou.top/2023/2f4ac7e2/",
            "url": "https://www.oikiou.top/2023/2f4ac7e2/",
            "title": "AUTOSAR",
            "date_published": "2023-07-27T11:23:05.000Z",
            "content_html": "<h1 id=\"AUTOSAR\"><a href=\"#AUTOSAR\" class=\"headerlink\" title=\"AUTOSAR\"></a>AUTOSAR</h1><p>autosar是一个组织，是一套汽车软件开发的方法论（框架），是一个软件架构（操作系统 中间件），是一个通信接口。</p>\n<p>统一标准、分散实现、集中配置</p>\n<p>AUTOSAR分为两种，这两种是并存的，一个是Classic AUTOSAR（硬实时系统），一个是Adaptive AUTOSAR（软实时系统），</p>\n<p><img src=\"/2023/2f4ac7e2/image_9dlPD4Dlwg.png\"></p>\n<h1 id=\"Classic-AUTOSAR\"><a href=\"#Classic-AUTOSAR\" class=\"headerlink\" title=\"Classic AUTOSAR\"></a>Classic AUTOSAR</h1><p>Classic AUTOSAR，是基于<a href=\"https://en.wikipedia.org/wiki/OSEK\" title=\"OSEK的\">OSEK的</a>嵌入式实时ECU的标准。</p>\n<p>AUTOSAR 经典平台架构在最高抽象级别上区分了微控制器上运行的三个软件层：Application Layer、Runtime Environment (RTE) 和Basic Software (BSW)。</p>\n<p><img src=\"/2023/2f4ac7e2/image_T85kwaEFPS.png\"></p>\n<p>经典平台的一个基本概念是虚拟功能总线（VFB）。该虚拟总线是一组抽象的 RTE，尚未部署到特定 ECU，并将应用程序与基础设施解耦。它通过专用端口进行通信，这意味着应用软件的通信接口必须映射到这些端口。VFB 处理各个 ECU 内部以及 ECU 之间的通信。从应用程序的角度来看，不需要了解底层技术或依赖关系的详细知识。这支持独立于硬件的应用软件的开发和使用。</p>\n<h1 id=\"Adaptive-AUTOSAR\"><a href=\"#Adaptive-AUTOSAR\" class=\"headerlink\" title=\"Adaptive AUTOSAR\"></a>Adaptive AUTOSAR</h1><p>Adaptive AUTOSAR，linux等，高性能</p>\n<p><img src=\"/2023/2f4ac7e2/image_iQN8gxa-yL.png\"></p>\n",
            "tags": [
                "autosar"
            ]
        },
        {
            "id": "https://www.oikiou.top/2023/880e7a30/",
            "url": "https://www.oikiou.top/2023/880e7a30/",
            "title": "常见MCU上电初始化逻辑 以STM32F1 CortexM3 为例",
            "date_published": "2023-06-20T11:23:05.000Z",
            "content_html": "<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>每一款芯片是如何启动的都值得去研究，只有明白了它是怎么样启动的，你才能知道为什么你的程序可以运行？程序是从哪里运行来的？运行你写的函数之前执行了哪些操作？</p>\n<p>也只有这样你才有对全局的掌控，才能对代码了然于心，提高你解决复杂问题的能力。</p>\n<blockquote>\n<p>  有一次踩坑，某MCU的BSS段未在<code>main</code>运行之前初始化导致程序运行异常，也是跟这个启动流程有关。</p>\n</blockquote>\n<p>通过了解启动文件，我们可以体会到处理器的架构、指令集、中断向量安排等内容，是非常值得玩味的。</p>\n<h1 id=\"进入正题\"><a href=\"#进入正题\" class=\"headerlink\" title=\"进入正题\"></a>进入正题</h1><h2 id=\"STM32-上电后做了什么\"><a href=\"#STM32-上电后做了什么\" class=\"headerlink\" title=\"STM32 上电后做了什么\"></a>STM32 上电后做了什么</h2><h3 id=\"图解启动流程\"><a href=\"#图解启动流程\" class=\"headerlink\" title=\"图解启动流程\"></a>图解启动流程</h3><p><img src=\"/2023/880e7a30/STM32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.svg\" alt=\"STM32启动流程\"></p>\n<p><img src=\"/2023/880e7a30/215103893_3_20210208091156505-16901903555945.png\" alt=\"215103893_3_20210208091156505\"></p>\n<h3 id=\"文字详细解读启动流程\"><a href=\"#文字详细解读启动流程\" class=\"headerlink\" title=\"文字详细解读启动流程\"></a>文字详细解读启动流程</h3><p><strong>启动过程概览</strong></p>\n<blockquote>\n<p>  1、初始化堆栈指针 SP&#x3D;_initial_sp</p>\n<p>  2、初始化PC指针&#x3D;Reset_Handler</p>\n<p>  3、初始化中断向量表</p>\n<p>  4、配置系统时钟</p>\n<p>  5、调用C 库函数<code>_main</code>初始化用户堆栈、.bss段、.data段，从而最终调用main 函数去到C 的世界</p>\n</blockquote>\n<p>而Cortex-M3内核规定，起始地址必须存放堆顶指针，而第二个地址则必须存放复位中断入口向量地址，这样在Cortex-M3内核复位后，会自动从起始地址的下一个32位空间取出复位中断入口向量，跳转执行复位中断服务程序。</p>\n<p><strong>启动过程涉及的代码</strong></p>\n<blockquote>\n<p>  启动过程涉及的文件不仅包含startup_stm32f10x_hd.s，还涉及到了MDK自带的连接库文件entry.o、entry2.o、entry5.o、entry7.o等（从生成的map文件可以看出来）</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs asm\">Stack_Size      EQU     0x00000400<br><br>                AREA    STACK, NOINIT, READWRITE, ALIGN=3<br>Stack_Mem       SPACE   Stack_Size<br>__initial_sp<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>  开辟栈的大小为0X00000400（1KB），名字为STACK，NOINIT 即不初始化，可读可写，8（2^3）字节对齐。</p>\n<p>  栈的作用是用于局部变量，函数调用，函数形参等的开销，栈的大小不能超过内部SRAM 的大小。如果编写的程序比较大，定义的局部变量很多，那么就需要修改栈的大小。如果某一天，你写的程序出现了莫名奇怪的错误，并进入了 hardfault 的时候，这时你就要考虑下是不是栈不够大，溢出了。</p>\n<p>  <strong>EQU</strong>：宏定义的伪指令，相当于等于，类似与C 中的define。</p>\n<p>  <strong>AREA</strong>：告诉汇编器汇编一个新的代码段或者数据段。STACK 表示段名，这个可以任意命名；NOINIT 表示不初始化；READWRITE 表示可读可写，ALIGN&#x3D;3，表示按照2^3对齐，即8 字节对齐。</p>\n<p>  <strong>SPACE</strong>：用于分配一定大小的内存空间，单位为字节。这里指定大小等于Stack_Size。标号<code>__initial_sp</code> 紧挨着SPACE 语句放置，表示栈的结束地址，即栈顶地址，栈是由<strong>高向低生长</strong>的。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs asm\">; &lt;h&gt; Heap Configuration<br>;   &lt;o&gt;  Heap Size (in Bytes) &lt;0x0-0xFFFFFFFF:8&gt;<br>; &lt;/h&gt;<br><br>Heap_Size       EQU     0x00000200<br><br>                AREA    HEAP, NOINIT, READWRITE, ALIGN=3<br>__heap_base<br>Heap_Mem        SPACE   Heap_Size<br>__heap_limit<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>  开辟堆的大小为0X00000200（512 字节），名字为HEAP，NOINIT 即不初始化，可读可写，8（2^3）字节对齐。<code>__heap_base</code> 表示对的起始地址，<code>__heap_limit</code> 表示堆的结束地址。堆是由<strong>低向高生长</strong>的，跟栈的生长方向相反。</p>\n<p>  堆主要用来动态内存的分配，像malloc()函数申请的内存就在堆上面。这个在STM32里面用的比较少。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs asm\">; Vector Table Mapped to Address 0 at Reset<br>                AREA    RESET, DATA, READONLY\t\t\t; 定义一个数据段，名字为RESET， 可读。并声明 __Vectors 、__Vectors_End 和__Vectors_Size 这三个标号具有全局属性，可供外部的文件调用。<br>                EXPORT  __Vectors<br>                EXPORT  __Vectors_End<br>                EXPORT  __Vectors_Size<br>    <br>__Vectors       DCD     __initial_sp                    ; Top of Stack  栈顶位置，第一个表项是栈顶地址;该处物理地址值即为 __Vetors 标号所表示的值;该地址中存储__initial_sp所表示的地址值，<br>                DCD     Reset_Handler                   ; Reset Handler 复位程序地址<br>                DCD     NMI_Handler                     ; NMI Handler<br>...<br>__Vectors_End<br><br>__Vectors_Size  EQU  __Vectors_End - __Vectors<br><br>                AREA    |.text|, CODE, READONLY<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>  定义一个数据段，名字为RESET， 可读。并声明 __Vectors 、__Vectors_End 和__Vectors_Size 这三个标号具有全局属性，可供外部的文件调用。</p>\n<p>  <strong>EXPORT</strong>：声明一个标号可被外部的文件使用，使标号具有全局属性。如果是IAR 编译器，则使用的是GLOBAL 这个指令。</p>\n<p>  <code>__Vectors</code> 为向量表起始地址，<code>__Vectors_End</code> 为向量表结束地址，两个相减即可算出向量表大小，也就是<code>__Vectors_Size</code>。</p>\n<p>  向量表从FLASH 的0 地址开始放置，以4 个字节为一个单位，地址0 存放的是栈顶地址，0X04 存放的是复位程序的地址，以此类推。从代码上看，向量表中存放的都是中断服务函数的函数名，可我们知道C 语言中的函数名就是一个地址。</p>\n<p>  <strong>DCD</strong>：分配一个或者多个以字为单位的内存，以四字节对齐，并要求初始化这些内存。在向量表中，DCD 分配了一堆内存，并且以ESR 的入口地址初始化它们。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs asm\">; 这里调用 SystemInit 初始化时钟 时钟初始化完成后跳转到main函数<br>; Reset handler<br>Reset_Handler    PROC<br>                 EXPORT  Reset_Handler             [WEAK]<br>     IMPORT  __main<br>     IMPORT  SystemInit<br>                 LDR     R0, =SystemInit<br>                 BLX     R0<br>                 LDR     R0, =__main<br>                 BX      R0<br>                 ENDP<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>  复位子程序是系统上电后第一个执行的程序，调用SystemInit 函数初始化系统时钟，然后调用C 库函数<code>_mian</code>，最终调用main 函数去到C 的世界。</p>\n<p>  <strong>WEAK</strong>：表示弱定义，如果外部文件优先定义了该标号则首先引用该标号，如果外部文件没有声明也不会出错。这里表示复位子程序可以由用户在其他文件重新实现，这里并不是唯一的。</p>\n<p>  <strong>IMPORT</strong>：表示该标号来自外部文件，跟C 语言中的EXTERN 关键字类似。这里表示<code>SystemInit</code>和<code>__main</code> 这两个函数均来自外部的文件。</p>\n<p>  <code>SystemInit()</code>是一个标准的库函数，在<code>system_stm32f10x.c</code>这个库文件定义。主要作用是配置系统时钟，这里调用这个函数之后，单片机的系统时钟配被配置为72M。</p>\n<p>  <code>__main</code> 是一个标准的C 库函数，主要作用是初始化用户堆栈，并在函数的最后调用main 函数去到C 的世界。这就是为什么我们写的程序都有一个main 函数的原因。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs asm\">;*******************************************************************************<br>; User Stack and Heap initialization<br>;*******************************************************************************<br>                 IF      :DEF:__MICROLIB           <br>                <br>                 EXPORT  __initial_sp<br>                 EXPORT  __heap_base<br>                 EXPORT  __heap_limit<br>                <br>                 ELSE<br>                <br>                 IMPORT  __use_two_region_memory    ;定义全局标号__use_two_region_memory<br>                 EXPORT  __user_initial_stackheap   ;声明全局标号__user_initial_stackheap，这样外部程序也可调用此标号，进行堆栈和堆的赋值，在__main函数执行过程中调用<br>                 <br>__user_initial_stackheap                            ;标号__user_initial_stackheap，表示用户堆栈初始化程序入口<br><br>                 LDR     R0, =  Heap_Mem            ;保存堆始地址<br>                 LDR     R1, =(Stack_Mem + Stack_Size);保存栈的大小<br>                 LDR     R2, = (Heap_Mem +  Heap_Size);保存堆的大小<br>                 LDR     R3, = Stack_Mem            ;保存栈顶指针<br>                 BX      LR<br><br>                 ALIGN<br><br>                 ENDIF<br><br>                 END<br><br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>  首先判断是否定义了<code>__MICROLIB </code>，如果定义了这个宏则赋予标号<code>__initial_sp</code>（栈顶地址）、<code>__heap_base</code>（堆起始地址）、<code>__heap_limit</code>（堆结束地址）全局属性，可供外部文件调用。有关这个宏我们在KEIL 里面配置，具体见下图 。然后堆栈的初始化就由C 库函数<code>_main</code> 来完成。</p>\n<p>  <img src=\"/2023/880e7a30/v2-e38d0eae51917b604ec87c9e767a7049_720w.webp\" alt=\"img\"></p>\n<p>  如果没有定义<code>__MICROLIB</code> ， 则采用双段存储器模式， 且声明标号<code>__user_initial_stackheap</code> 具有全局属性，让用户自己来初始化堆栈。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">// 初始化嵌入式闪存接口、PLL并更新系统核心时钟变量。</span><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">  * @brief  Setup the microcontroller system</span><br><span class=\"hljs-comment\">  *         Initialize the Embedded Flash Interface, the PLL and update the </span><br><span class=\"hljs-comment\">  *         SystemCoreClock variable.</span><br><span class=\"hljs-comment\">  * @note   This function should be used only after reset.</span><br><span class=\"hljs-comment\">  * @param  None</span><br><span class=\"hljs-comment\">  * @retval None</span><br><span class=\"hljs-comment\">  */</span><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">SystemInit</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">if</span> defined(STM32F100xE) || defined(STM32F101xE) || defined(STM32F101xG) || defined(STM32F103xE) || defined(STM32F103xG)</span><br>  <span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> DATA_IN_ExtSRAM</span><br>    SystemInit_ExtMemCtl(); <br>  <span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span> <span class=\"hljs-comment\">/* DATA_IN_ExtSRAM */</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span> </span><br><br>  <span class=\"hljs-comment\">/* Configure the Vector Table location -------------------------------------*/</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">if</span> defined(USER_VECT_TAB_ADDRESS)</span><br>  SCB-&gt;VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; <span class=\"hljs-comment\">/* Vector Table Relocation in Internal SRAM. */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span> <span class=\"hljs-comment\">/* USER_VECT_TAB_ADDRESS */</span></span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"main-做了什么\"><a href=\"#main-做了什么\" class=\"headerlink\" title=\"__main() 做了什么\"></a><code>__main()</code> 做了什么</h3><p><a href=\"https://developer.arm.com/documentation/dui0808/c/chr1358938922456\">参考ARM文档</a></p>\n<blockquote>\n<p>  The entry point of a program is at __main in the C library where library code:</p>\n<ol>\n<li>Copies non-root (RO and RW) execution regions from their load addresses to their execution addresses. Also, if any data sections are compressed, they are decompressed from the load address to the execution address.</li>\n<li>Zeroes ZI regions.</li>\n<li>Branches to <code>__rt_entry</code>.</li>\n</ol>\n</blockquote>\n<p>程序的入口点位于 C 库中的 __main，其中库代码：</p>\n<ol>\n<li>将 non-root（RO 和 RW）从其加载地址复制到其执行地址。此外，如果任何数据部分被压缩，它们将从加载地址解压缩到执行地址。</li>\n<li>将 ZI 区域归零。</li>\n<li>跳转到 <code>__rt_entry</code>。</li>\n</ol>\n<blockquote>\n<p>  The library function <code>__rt_entry()</code> runs the program as follows:</p>\n<ol>\n<li><p>Sets up the stack and the heap by one of a number of means that include calling <code>__user_setup_stackheap()</code>, calling <code>__rt_stackheap_init()</code>, or loading the absolute addresses of scatter-loaded regions.</p>\n</li>\n<li><p>Calls <code>__rt_lib_init()</code> to initialize referenced library functions, initialize the locale and, if necessary, set up argc and argv for <code>main()</code>.</p>\n<p>For C++, calls the constructors for any top-level objects by way of <code>__cpp_initialize__aeabi_</code>.</p>\n</li>\n<li><p>Calls <code>main()</code>, the user-level root of the application.</p>\n<p>From <code>main()</code>, your program might call, among other things, library functions.</p>\n</li>\n<li><p>Calls <code>exit()</code> with the value returned by <code>main()</code>.</p>\n</li>\n</ol>\n</blockquote>\n<p>库函数<code>__rt_entry()</code>运行程序如下：</p>\n<ol>\n<li><p>通过多种方式中的一种设置堆栈和堆，包括调用<code>__user_setup_stackheap()</code>、调用<code>__rt_stackheap_init()</code>或加载scatter-loaded  区域的绝对地址。</p>\n</li>\n<li><p>调用<code>__rt_lib_init()</code>初始化引用的库函数、初始化区域设置，并在必要时为<code>main()</code>设置<code>argv</code>和<code>argc</code>参数。</p>\n<p>对于 C++，通过 <code>__cpp_initialize__aeabi_</code> 调用任何top-level对象的构造函数。</p>\n</li>\n<li><p>调用<code>main()</code>，应用程序的 user-level 级别的起始。</p>\n<p>在<code>main()</code>中，您的程序可能会调用库函数等。</p>\n</li>\n<li><p>根据<code>main()</code>的返回值调用<code>exit()</code>。</p>\n</li>\n</ol>\n<h3 id=\"一些参考\"><a href=\"#一些参考\" class=\"headerlink\" title=\"一些参考\"></a>一些参考</h3><blockquote>\n<p>  STM32启动过程–启动文件–分析：<a href=\"https://www.cnblogs.com/dreamboy2000/p/15806645.html\">https://www.cnblogs.com/dreamboy2000/p/15806645.html</a></p>\n<p>  ARM编译器指南 执行环境的初始化和应用程序的执行：<a href=\"https://developer.arm.com/documentation/dui0808/c/chr1358938922456\">https://developer.arm.com/documentation/dui0808/c/chr1358938922456</a></p>\n</blockquote>\n",
            "tags": [
                "embedded",
                "stm32",
                "cortexm3"
            ]
        },
        {
            "id": "https://www.oikiou.top/2023/79891ac1/",
            "url": "https://www.oikiou.top/2023/79891ac1/",
            "title": "License差异对比",
            "date_published": "2023-02-02T06:23:05.000Z",
            "content_html": "<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://spdx.org/licenses/\">SPDX License List</a></p>\n<p>使用 <strong>SPDX 短格式标识符</strong> 以简单、高效、便携和机器可读的方式 传达 FOSS 许可证信息</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-regexp\">//</span> SPDX-License-Identifier: MIT<br><span class=\"hljs-regexp\">/* SPDX-License-Identifier: MIT OR Apache-2.0 */</span><br><span class=\"hljs-comment\"># SPDX-License-Identifier: GPL-2.0-or-later</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"术语\"><a href=\"#术语\" class=\"headerlink\" title=\"术语\"></a>术语</h1><h2 id=\"什么是“分发”？\"><a href=\"#什么是“分发”？\" class=\"headerlink\" title=\"什么是“分发”？\"></a>什么是“分发”？</h2><p>许可证授予的权利，允许你自由使用、修改、复制，但是<strong>在“分发”时就必须遵守许可证的约束</strong>。换言之，如果不”分发”，就不需要遵守。</p>\n<p>分发就是指将版权作品从一个人转移到另一个人。这意味着，如果你是自己使用，不提供给他人，就没有分发。另外，这里的”人”也指”法人”，因此如果使用方是公司，且只在公司内部使用，也不需要遵守许可证[]。</p>\n<p>其中AGPL有个特例：AGPL定义，如果你使用开源软件<strong>提供网络交互服务，那么该行为也定义为“分发”</strong>，即图中的“网络使用即分发”</p>\n<h2 id=\"什么是“传染性”？\"><a href=\"#什么是“传染性”？\" class=\"headerlink\" title=\"什么是“传染性”？\"></a>什么是“传染性”？</h2><p>传染性来源于GPL，GPL的支持者确信自由软件世界应具有自我保护能力和可持续发展性——为了确保自由软件的演绎作品同样“自由”，所以要求只要使用了GPL的代码，那么整个项目都必须以GPL方式公开源代码</p>\n<p>LGPL 在这方面要求就没GPL那么严格，如果只是子系统&#x2F;模块用了，那么只需要子系统&#x2F;模块开源，整个工程不用开源；如果是以动态链接调用LGPL许可证的库，那么项目也不用开源。</p>\n<p>MPL 在这个方面就更宽松，哪个文件用了该许可证的代码，只需要这些文件开源即可，其他文件不受影响</p>\n<p>所以，GPL v2&#x2F;v3、AGPL 属于工程级别的强传染性；LGPL属于库级别的若传染性；MPL 就是文件级别的，传染性可以忽略不计了</p>\n<h2 id=\"GPL-系列的协议有何区别？\"><a href=\"#GPL-系列的协议有何区别？\" class=\"headerlink\" title=\"GPL 系列的协议有何区别？\"></a>GPL 系列的协议有何区别？</h2><p><strong>AGPL 和 GPL 的区别：</strong></p>\n<p>AGPL明确了GPL 2.0&#x2F;3.0关于提供网络服务也属于分发限制的说明：使用GPL的自由软件，但是并不发布与网络之中，则可以自由的使用GPL协议确不开源自己私有的解决方案。AGPL则增加了对此做法的约束。比如使用了AGPL代码的软件是一个网络应用，那么这个软件的所有源码和修改代码也必须开源</p>\n<p><strong>GPL v2 和 GPL v3的主要差异：</strong></p>\n<p>a) GPLv3包含了明确的专利许可</p>\n<p>b) 添加了对数字版权管理和加密签名的限制，不仅要求用户公开源码，还要求公布相关硬件及必要的安装信息。</p>\n<p><strong>GPL 和LGPL的区别：</strong></p>\n<p>主要区别在于传染性方面，GPL是工程级别的强传染，LGPL是库级别的弱传染</p>\n<h2 id=\"违反开源项目许可有何风险？\"><a href=\"#违反开源项目许可有何风险？\" class=\"headerlink\" title=\"违反开源项目许可有何风险？\"></a>违反开源项目许可有何风险？</h2><p>1.被许可人在违反许可证设定的义务时会构成合同违约</p>\n<p>2.开源软件受著作权保护，著作权法著作权法，但是开源许可证本质却是走在了版权保护的对立面，所以其法律效力并没有被明确认可，是否侵权可能需要法院视具体情况而定</p>\n<p>3.在中国，侵权责任和违约责任不能同时主张</p>\n<p>4.在中国，过往的判例都没有涉及开源软件许可证本身</p>\n<p>5.除了面临法律诉讼风险，违反许可证的行为会导致自由软件者和开源社区的排斥，某种程度上会影响违约公司的商业信誉</p>\n<h1 id=\"差异\"><a href=\"#差异\" class=\"headerlink\" title=\"差异\"></a>差异</h1><p><img src=\"/2023/79891ac1/v2-3a460a2dad345fe0c2e0e79b626aacc9_720w.webp\" alt=\"img\"></p>\n<p><img src=\"/2023/79891ac1/file-20241216174657286.png\"></p>\n",
            "tags": [
                "license"
            ]
        },
        {
            "id": "https://www.oikiou.top/2023/e7fefe87/",
            "url": "https://www.oikiou.top/2023/e7fefe87/",
            "title": "Let's Encrypt SSL 证书申请",
            "date_published": "2023-01-12T04:08:08.000Z",
            "content_html": "<h1 id=\"Let’s-Encrypt-SSL-证书申请\"><a href=\"#Let’s-Encrypt-SSL-证书申请\" class=\"headerlink\" title=\"Let’s Encrypt SSL 证书申请\"></a>Let’s Encrypt SSL 证书申请</h1><h1 id=\"为什么申请？\"><a href=\"#为什么申请？\" class=\"headerlink\" title=\"为什么申请？\"></a>为什么申请？</h1><blockquote>\n<h2 id=\"HTTP：未实施数据加密\"><a href=\"#HTTP：未实施数据加密\" class=\"headerlink\" title=\"HTTP：未实施数据加密\"></a>HTTP：未实施数据加密</h2><p>  每个以 HTTP 开头的 URL 链接都使用一种基本类型的“超文本传输协议”。由 Tim Berners-Lee 于 1990 年代初创建，当时互联网仍处于起步阶段，该网络协议标准允许 Web 浏览器和服务器通过数据交换进行通信。</p>\n<p>  HTTP 也被称为“无状态系统”，这意味着它可以按需连接。您单击一个链接，请求连接，您的 Web 浏览器将此请求发送到服务器，服务器通过打开页面进行响应。连接越快，数据呈现给您的速度就越快。</p>\n<p>  作为一种“应用层协议”，HTTP 仍然专注于呈现信息，但不太关心这些信息从一个地方传播到另一个地方的方式。不幸的是，这意味着 HTTP 可能会<a href=\"https://www.globalsign.com/en/blog/what-is-a-man-in-the-middle-attack\">被拦截并可能被更改</a>，从而使信息和信息接收者（即您）都容易受到攻击。</p>\n<h2 id=\"HTTPS：加密连接\"><a href=\"#HTTPS：加密连接\" class=\"headerlink\" title=\"HTTPS：加密连接\"></a>HTTPS：加密连接</h2><p>  HTTPS 不是 HTTP 的对立面，而是它的表弟。两者本质上是相同的，因为它们都指的是相同的“超文本传输协议”，该协议使请求的 Web 数据能够显示在您的屏幕上。但是，HTTPS 仍然略有不同，更先进，也更安全。</p>\n<p>  简单的说，HTTPS协议是HTTP的扩展。缩写中的“S”来自 Secure 一词，它由传输层安全性 (TLS) [<a href=\"https://www.globalsign.com/en/ssl-information-center/what-is-ssl/\">安全套接字层 (SSL)</a>的后继者] 提供支持，这是一种在 Web 服务器和服务器之间建立加密连接的标准安全技术。浏览器。</p>\n<p>  如果没有 HTTPS，您输入网站的任何数据（例如您的用户名&#x2F;密码、信用卡或银行详细信息、任何其他表单提交数据等）都将以明文形式发送，因此容易被拦截或窃听。因此，在输入任何信息之前，您应该始终检查站点是否使用 HTTPS。</p>\n<p>  除了加密服务器和您的浏览器之间传输的数据外，TLS 还验证您正在连接的服务器并保护传输的数据不被篡改。</p>\n<p>  这有助于我这样思考——HTTPS 中的 HTTP 相当于一个目的地，而 SSL 相当于一个旅程。第一个负责将数据显示到屏幕上，第二个负责管理数据到达那里的方式。通过联合力量，他们以安全的方式移动数据。  </p>\n<p>  <a href=\"https://www.globalsign.com/en/blog/the-difference-between-http-and-https\">What’s the difference between HTTP and HTTPS?</a></p>\n</blockquote>\n<p>HTTPS 有助于确保网络安全。毫无疑问，它是比 HTTP 更好的网络协议解决方案。</p>\n<p>将网站开启HTTPS的服务是需要SSL的证书的，我们来看一下如何在Let’s Encrypt上申请免费的SSL证书。</p>\n<blockquote>\n<p>  Let’s Encrypt 是免费、开放和自动化的证书颁发机构。由非盈利组织<a href=\"https://www.abetterinternet.org/\">互联网安全研究小组（ISRG）</a>运营。</p>\n</blockquote>\n<h1 id=\"申请的前提条件\"><a href=\"#申请的前提条件\" class=\"headerlink\" title=\"申请的前提条件\"></a>申请的前提条件</h1><p>我们申请SSL证书的前提条件有下面这几个</p>\n<ol>\n<li>拥有域名，能够自主配置DNS。或者提供Web服务器做验证，在网站目录下放一个文件。</li>\n<li>获取证书的环境要能访问DNS服务器，因为会需要做DNS解析校验。</li>\n<li>需要有远程主机的权限，会需要更新和安装组件。</li>\n<li>公网IP，保留地址无法申请SSL。</li>\n</ol>\n<h1 id=\"申请步骤\"><a href=\"#申请步骤\" class=\"headerlink\" title=\"申请步骤\"></a>申请步骤</h1><p>Let’s Encrypt 的证书申请除去手动申请常见的主要有下面这几种</p>\n<ul>\n<li><code>acme.sh</code>的方式<em>（我当时选取了这个方式）</em></li>\n<li>docker 镜像获取</li>\n<li><code>certbot</code>方式获取证书<em>（官网建议使用这种方式获取证书，可以在不下线的状态下自动执行证书颁发和安装）</em></li>\n</ul>\n<h2 id=\"acme-sh脚本\"><a href=\"#acme-sh脚本\" class=\"headerlink\" title=\"acme.sh脚本\"></a><code>acme.sh</code>脚本</h2><p><a href=\"https://github.com/acmesh-official/acme.sh\">Github链接：An ACME Shell script: acme.sh</a></p>\n<p>Github的README其实介绍的其实很全面，这里copy一下。</p>\n<blockquote>\n<p>  <strong>acme.sh</strong> 实现了 <code>acme</code> 协议, 可以从 letsencrypt 生成免费的证书.</p>\n<p>  主要步骤:</p>\n<ol>\n<li>安装 <strong>acme.sh</strong></li>\n<li>生成证书</li>\n<li>copy 证书到 nginx&#x2F;apache 或者其他服务</li>\n<li>更新证书</li>\n<li>更新 <strong>acme.sh</strong></li>\n<li>出错怎么办, 如何调试</li>\n</ol>\n<p>  下面详细介绍.</p>\n<h1 id=\"1-安装-acme-sh\"><a href=\"#1-安装-acme-sh\" class=\"headerlink\" title=\"1. 安装 acme.sh\"></a>1. 安装 <strong>acme.sh</strong></h1><p>  安装很简单, 一个命令:</p>\n<blockquote>\n<p>  这里输入你的邮箱，这个邮箱有什么用倒是不太清楚</p>\n</blockquote>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">curl https://get.acme.sh | sh -s email=my@example.com<br></code></pre></td></tr></table></figure>\n\n<p>  普通用户和 root 用户都可以安装使用. 安装过程进行了以下几步:</p>\n<ol>\n<li>把 acme.sh 安装到你的 <strong>home</strong> 目录下:</li>\n</ol>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">~/.acme.sh/<br></code></pre></td></tr></table></figure>\n\n<p>  并创建 一个 shell 的 alias, 例如 .bashrc，方便你的使用: <code>alias acme.sh=~/.acme.sh/acme.sh</code></p>\n<ol start=\"2\">\n<li>自动为你创建 cronjob, 每天 0:00 点自动检测所有的证书, 如果快过期了, 需要更新, 则会自动更新证书.</li>\n</ol>\n<p>  更高级的安装选项请参考: <a href=\"https://github.com/Neilpang/acme.sh/wiki/How-to-install\">https://github.com/Neilpang/acme.sh/wiki/How-to-install</a></p>\n<p>  <strong>安装过程不会污染已有的系统任何功能和文件</strong>, 所有的修改都限制在安装目录中: <code>~/.acme.sh/</code></p>\n<h1 id=\"2-生成证书\"><a href=\"#2-生成证书\" class=\"headerlink\" title=\"2. 生成证书\"></a>2. 生成证书</h1><p>  <strong>acme.sh</strong> 实现了 <strong>acme</strong> 协议支持的所有验证协议. 一般有两种方式验证: http 和 dns 验证.</p>\n<h3 id=\"1-http-方式需要在你的网站根目录下放置一个文件-来验证你的域名所有权-完成验证-然后就可以生成证书了\"><a href=\"#1-http-方式需要在你的网站根目录下放置一个文件-来验证你的域名所有权-完成验证-然后就可以生成证书了\" class=\"headerlink\" title=\"1. http 方式需要在你的网站根目录下放置一个文件, 来验证你的域名所有权,完成验证. 然后就可以生成证书了.\"></a>1. http 方式需要在你的网站根目录下放置一个文件, 来验证你的域名所有权,完成验证. 然后就可以生成证书了.</h3>  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">acme.sh --issue -d mydomain.com -d www.mydomain.com --webroot /home/wwwroot/mydomain.com/<br></code></pre></td></tr></table></figure>\n\n<p>  只需要指定域名, 并指定域名所在的网站根目录. <strong>acme.sh</strong> 会全自动的生成验证文件, 并放到网站的根目录, 然后自动完成验证. 最后会聪明的删除验证文件. 整个过程没有任何副作用.</p>\n<p>  如果你用的 <strong>apache</strong>服务器, <strong>acme.sh</strong> 还可以智能的从 <strong>apache</strong>的配置中自动完成验证, 你不需要指定网站根目录:</p>\n  <figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">acme<span class=\"hljs-selector-class\">.sh</span> <span class=\"hljs-attr\">--issue</span> -d mydomain<span class=\"hljs-selector-class\">.com</span> <span class=\"hljs-attr\">--apache</span><br></code></pre></td></tr></table></figure>\n\n<p>  如果你用的 <strong>nginx</strong>服务器, 或者反代, <strong>acme.sh</strong> 还可以智能的从 <strong>nginx</strong>的配置中自动完成验证, 你不需要指定网站根目录:</p>\n  <figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">acme<span class=\"hljs-selector-class\">.sh</span> <span class=\"hljs-attr\">--issue</span> -d mydomain<span class=\"hljs-selector-class\">.com</span> <span class=\"hljs-attr\">--nginx</span><br></code></pre></td></tr></table></figure>\n\n<p>  <strong>注意, 无论是 apache 还是 nginx 模式, acme.sh在完成验证之后, 会恢复到之前的状态, 都不会私自更改你本身的配置. 好处是你不用担心配置被搞坏, 也有一个缺点, 你需要自己配置 ssl 的配置, 否则只能成功生成证书, 你的网站还是无法访问https. 但是为了安全, 你还是自己手动改配置吧.</strong></p>\n<p>  如果你还没有运行任何 web 服务, <strong>80</strong> 端口是空闲的, 那么 <strong>acme.sh</strong> 还能假装自己是一个webserver, 临时听在<strong>80</strong> 端口, 完成验证:</p>\n  <figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">acme<span class=\"hljs-selector-class\">.sh</span> <span class=\"hljs-attr\">--issue</span> -d mydomain<span class=\"hljs-selector-class\">.com</span> <span class=\"hljs-attr\">--standalone</span><br></code></pre></td></tr></table></figure>\n\n<p>  更高级的用法请参考: <a href=\"https://github.com/Neilpang/acme.sh/wiki/How-to-issue-a-cert\">https://github.com/Neilpang/acme.sh/wiki/How-to-issue-a-cert</a></p>\n<h3 id=\"2-手动-dns-方式-手动在域名上添加一条-txt-解析记录-验证域名所有权\"><a href=\"#2-手动-dns-方式-手动在域名上添加一条-txt-解析记录-验证域名所有权\" class=\"headerlink\" title=\"2. 手动 dns 方式, 手动在域名上添加一条 txt 解析记录, 验证域名所有权.\"></a>2. 手动 dns 方式, 手动在域名上添加一条 txt 解析记录, 验证域名所有权.</h3><p>  这种方式的好处是, 你不需要任何服务器, 不需要任何公网 ip, 只需要 dns 的解析记录即可完成验证. 坏处是，如果不同时配置 Automatic DNS API，使用这种方式 acme.sh 将无法自动更新证书，每次都需要手动再次重新解析验证域名所有权。</p>\n  <figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">acme<span class=\"hljs-selector-class\">.sh</span> <span class=\"hljs-attr\">--issue</span> <span class=\"hljs-attr\">--dns</span> -d mydomain<span class=\"hljs-selector-class\">.com</span> \\<br> <span class=\"hljs-attr\">--yes-I-know-dns-manual-mode-enough-go-ahead-please</span><br></code></pre></td></tr></table></figure>\n\n<p>  然后, <strong>acme.sh</strong> 会生成相应的解析记录显示出来, 你只需要在你的域名管理面板中添加这条 txt 记录即可.</p>\n<p>  等待解析完成之后, 重新生成证书:</p>\n  <figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">acme<span class=\"hljs-selector-class\">.sh</span> <span class=\"hljs-attr\">--renew</span> -d mydomain<span class=\"hljs-selector-class\">.com</span> \\<br>  <span class=\"hljs-attr\">--yes-I-know-dns-manual-mode-enough-go-ahead-please</span><br></code></pre></td></tr></table></figure>\n\n<p>  注意第二次这里用的是 <code>--renew</code></p>\n<p>  dns 方式的真正强大之处在于可以使用域名解析商提供的 api 自动添加 txt 记录完成验证.</p>\n<p>  <strong>acme.sh</strong> 目前支持 cloudflare, dnspod, cloudxns, godaddy 以及 ovh 等数十种解析商的自动集成.</p>\n<p>  以 dnspod 为例, 你需要先登录到 dnspod 账号, 生成你的 api id 和 api key, 都是免费的. 然后:</p>\n  <figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\"><span class=\"hljs-built_in\">export</span> <span class=\"hljs-attribute\">DP_Id</span>=<span class=\"hljs-string\">&quot;1234&quot;</span><br><br><span class=\"hljs-built_in\">export</span> <span class=\"hljs-attribute\">DP_Key</span>=<span class=\"hljs-string\">&quot;sADDsdasdgdsf&quot;</span><br><br>acme.sh --issue --dns dns_dp -d aa.com -d www.aa.com<br></code></pre></td></tr></table></figure>\n\n<p>  证书就会自动生成了. 这里给出的 api id 和 api key 会被自动记录下来, 将来你在使用 dnspod api 的时候, 就不需要再次指定了. 直接生成就好了:</p>\n  <figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">acme<span class=\"hljs-selector-class\">.sh</span> <span class=\"hljs-attr\">--issue</span> -d mydomain2<span class=\"hljs-selector-class\">.com</span> <span class=\"hljs-attr\">--dns</span>  dns_dp<br></code></pre></td></tr></table></figure>\n\n<p>  更详细的 api 用法: <a href=\"https://github.com/Neilpang/acme.sh/blob/master/dnsapi/README.md\">https://github.com/Neilpang/acme.sh/blob/master/dnsapi/README.md</a></p>\n<h3 id=\"3-其他的激活方式\"><a href=\"#3-其他的激活方式\" class=\"headerlink\" title=\"3. 其他的激活方式\"></a>3. 其他的激活方式</h3><p>  <a href=\"https://github.com/acmesh-official/acme.sh/wiki/How-to-issue-a-cert\">https://github.com/acmesh-official/acme.sh/wiki/How-to-issue-a-cert</a></p>\n<h1 id=\"3-copy-安装-证书\"><a href=\"#3-copy-安装-证书\" class=\"headerlink\" title=\"3. copy&#x2F;安装 证书\"></a>3. copy&#x2F;安装 证书</h1><p>  前面证书生成以后, 接下来需要把证书 copy 到真正需要用它的地方.</p>\n<p>  注意, 默认生成的证书都放在安装目录下: <code>~/.acme.sh/</code>, <strong>请不要直接使用此目录下的文件,</strong> 例如: 不要直接让 nginx&#x2F;apache 的配置文件使用这下面的文件. 这里面的文件都是内部使用, 而且目录结构可能会变化.</p>\n<p>  正确的使用方法是使用 <code>--install-cert</code> 命令,并指定目标位置, 然后证书文件会被copy到相应的位置, 例如:</p>\n<h2 id=\"Apache-example\"><a href=\"#Apache-example\" class=\"headerlink\" title=\"Apache example:\"></a>Apache example:</h2>  <figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gradle\">acme.sh --install-cert -d example.com \\<br>--cert-<span class=\"hljs-keyword\">file</span>      <span class=\"hljs-regexp\">/path/</span>to<span class=\"hljs-regexp\">/certfile/i</span>n<span class=\"hljs-regexp\">/apache/</span>cert.pem  \\<br>--key-<span class=\"hljs-keyword\">file</span>       <span class=\"hljs-regexp\">/path/</span>to<span class=\"hljs-regexp\">/keyfile/i</span>n<span class=\"hljs-regexp\">/apache/</span>key.pem  \\<br>--fullchain-<span class=\"hljs-keyword\">file</span> <span class=\"hljs-regexp\">/path/</span>to<span class=\"hljs-regexp\">/fullchain/</span>certfile<span class=\"hljs-regexp\">/apache/</span>fullchain.pem \\<br>--reloadcmd     <span class=\"hljs-string\">&quot;service apache2 force-reload&quot;</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Nginx-example\"><a href=\"#Nginx-example\" class=\"headerlink\" title=\"Nginx example:\"></a>Nginx example:</h2>  <figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">acme<span class=\"hljs-selector-class\">.sh</span> <span class=\"hljs-attr\">--install-cert</span> -d example<span class=\"hljs-selector-class\">.com</span> \\<br><span class=\"hljs-attr\">--key-file</span>       /path/to/keyfile/<span class=\"hljs-keyword\">in</span>/nginx/key<span class=\"hljs-selector-class\">.pem</span>  \\<br><span class=\"hljs-attr\">--fullchain-file</span> /path/to/fullchain/nginx/cert<span class=\"hljs-selector-class\">.pem</span> \\<br><span class=\"hljs-attr\">--reloadcmd</span>     <span class=\"hljs-string\">&quot;service nginx force-reload&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>  (一个小提醒, 这里用的是 <code>service nginx force-reload</code>, 不是 <code>service nginx reload</code>, 据测试, <code>reload</code> 并不会重新加载证书, 所以用的 <code>force-reload</code>)</p>\n<blockquote>\n<p>  我当时使用这个命令的时候发现用 <code>service nginx force-reload</code>  报没有权限，然后是将当前用户</p>\n</blockquote>\n<p>  Nginx 的配置 <code>ssl_certificate</code> 使用 <code>/etc/nginx/ssl/fullchain.cer</code> ，而非 <code>/etc/nginx/ssl/&lt;domain&gt;.cer</code> ，否则 <a href=\"https://www.ssllabs.com/ssltest/\">SSL Labs</a> 的测试会报 <code>Chain issues Incomplete</code> 错误。</p>\n<p>  <code>--install-cert</code>命令可以携带很多参数, 来指定目标文件. 并且可以指定 reloadcmd, 当证书更新以后, reloadcmd会被自动调用,让服务器生效.</p>\n<p>  详细参数请参考: <a href=\"https://github.com/Neilpang/acme.sh#3-install-the-issued-cert-to-apachenginx-etc\">https://github.com/Neilpang/acme.sh#3-install-the-issued-cert-to-apachenginx-etc</a></p>\n<p>  值得注意的是, 这里指定的所有参数都会被自动记录下来, 并在将来证书自动更新以后, 被再次自动调用.</p>\n<h1 id=\"4-查看已安装证书信息\"><a href=\"#4-查看已安装证书信息\" class=\"headerlink\" title=\"4. 查看已安装证书信息\"></a>4. 查看已安装证书信息</h1>  <figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">acme.sh --<span class=\"hljs-built_in\">info</span> -d example.com<br><span class=\"hljs-comment\"># 会输出如下内容：</span><br><span class=\"hljs-attribute\">DOMAIN_CONF</span>=/root/.acme.sh/example.com/example.com.conf<br><span class=\"hljs-attribute\">Le_Domain</span>=example.com<br><span class=\"hljs-attribute\">Le_Alt</span>=<span class=\"hljs-literal\">no</span><br><span class=\"hljs-attribute\">Le_Webroot</span>=dns_ali<br>Le_PreHook=<br>Le_PostHook=<br>Le_RenewHook=<br><span class=\"hljs-attribute\">Le_API</span>=https://acme-v02.api.letsencrypt.org/directory<br>Le_Keylength=<br><span class=\"hljs-attribute\">Le_OrderFinalize</span>=https://acme-v02.api.letsencrypt.org/acme/finalize/23xxxx150/781xxxx4310<br><span class=\"hljs-attribute\">Le_LinkOrder</span>=https://acme-v02.api.letsencrypt.org/acme/order/233xxx150/781xxxx4310<br><span class=\"hljs-attribute\">Le_LinkCert</span>=https://acme-v02.api.letsencrypt.org/acme/cert/04cbd28xxxxxx349ecaea8d07<br><span class=\"hljs-attribute\">Le_CertCreateTime</span>=1649358725<br><span class=\"hljs-attribute\">Le_CertCreateTimeStr</span>=Thu Apr  7 19:12:05 UTC 2022<br><span class=\"hljs-attribute\">Le_NextRenewTimeStr</span>=Mon Jun  6 19:12:05 UTC 2022<br><span class=\"hljs-attribute\">Le_NextRenewTime</span>=1654456325<br>Le_RealCertPath=<br>Le_RealCACertPath=<br><span class=\"hljs-attribute\">Le_RealKeyPath</span>=/etc/acme/example.com/privkey.pem<br><span class=\"hljs-attribute\">Le_ReloadCmd</span>=service nginx force-reload<br><span class=\"hljs-attribute\">Le_RealFullChainPath</span>=/etc/acme/example.com/chain.pem<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"5-更新证书\"><a href=\"#5-更新证书\" class=\"headerlink\" title=\"5. 更新证书\"></a>5. 更新证书</h1><p>  目前证书在 60 天以后会自动更新, 你无需任何操作. 今后有可能会缩短这个时间, 不过都是自动的, 你不用关心.</p>\n<p>  请确保 cronjob 正确安装, 看起来是类似这样的:</p>\n  <figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jboss-cli\">crontab  -l<br><br>56 * * * * <span class=\"hljs-string\">&quot;/root/.acme.sh&quot;</span><span class=\"hljs-string\">/acme.sh</span> <span class=\"hljs-params\">--cron</span> <span class=\"hljs-params\">--home</span> <span class=\"hljs-string\">&quot;/root/.acme.sh&quot;</span> &gt; <span class=\"hljs-string\">/dev/null</span><br></code></pre></td></tr></table></figure>\n\n<h1 id=\"6-关于修改ReloadCmd\"><a href=\"#6-关于修改ReloadCmd\" class=\"headerlink\" title=\"6. 关于修改ReloadCmd\"></a>6. 关于修改ReloadCmd</h1><p>  目前修改<code>ReloadCmd</code>没有专门的命令，可以通过重新安装证书来实现修改<code>reloadCmd</code>的目的。 此外，安装证书后，相关信息是保存在<code>~/.acme.sh/example.com/example.conf</code>文件下的，内容就是<code>acme.sh --info -d example.com</code>输出的信息，不过<code>ReloadCmd</code>在文件中使用了Base64编码。理论上可以通过直接修改该文件来修改<code>ReloadCmd</code>，且修改时，无需Base64编码，直接写命令原文<code>acme.sh</code>也可以识别。 不过，<code>example.conf</code>文件的位置和内容格式以后可能会改变！<code>example.conf</code>一直都是内部使用, 后面有可能会改为用 sqlite 或者mysql 格式存储. 所以一般不建议自己修改。</p>\n<h1 id=\"7-更新-acme-sh\"><a href=\"#7-更新-acme-sh\" class=\"headerlink\" title=\"7. 更新 acme.sh\"></a>7. 更新 acme.sh</h1><p>  目前由于 acme 协议和 letsencrypt CA 都在频繁的更新, 因此 acme.sh 也经常更新以保持同步.</p>\n<p>  升级 acme.sh 到最新版 :</p>\n  <figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">acme<span class=\"hljs-selector-class\">.sh</span> <span class=\"hljs-attr\">--upgrade</span><br></code></pre></td></tr></table></figure>\n\n<p>  如果你不想手动升级, 可以开启自动升级:</p>\n  <figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">acme<span class=\"hljs-selector-class\">.sh</span> <span class=\"hljs-attr\">--upgrade</span> <span class=\"hljs-attr\">--auto-upgrade</span><br></code></pre></td></tr></table></figure>\n\n<p>  之后, acme.sh 就会自动保持更新了.</p>\n<p>  你也可以随时关闭自动更新:</p>\n  <figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">acme<span class=\"hljs-selector-class\">.sh</span> <span class=\"hljs-attr\">--upgrade</span> <span class=\"hljs-attr\">--auto-upgrade</span>  <span class=\"hljs-number\">0</span><br></code></pre></td></tr></table></figure>\n\n<h1 id=\"8-出错怎么办：\"><a href=\"#8-出错怎么办：\" class=\"headerlink\" title=\"8. 出错怎么办：\"></a>8. 出错怎么办：</h1><p>  如果出错, 请添加 debug log：</p>\n  <figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jboss-cli\">acme.sh <span class=\"hljs-params\">--issue</span>  <span class=\"hljs-string\">.....</span>  <span class=\"hljs-params\">--debug</span> <br></code></pre></td></tr></table></figure>\n\n<p>  或者：</p>\n  <figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jboss-cli\">acme.sh <span class=\"hljs-params\">--issue</span>  <span class=\"hljs-string\">.....</span>  <span class=\"hljs-params\">--debug</span>  2<br></code></pre></td></tr></table></figure>\n\n<p>  请参考： <a href=\"https://github.com/Neilpang/acme.sh/wiki/How-to-debug-acme.sh\">https://github.com/Neilpang/acme.sh/wiki/How-to-debug-acme.sh</a></p>\n<p>  最后, 本文并非完全的使用说明, 还有很多高级的功能, 更高级的用法请参看其他 wiki 页面.</p>\n<p>  <a href=\"https://github.com/Neilpang/acme.sh/wiki\">https://github.com/Neilpang/acme.sh/wiki</a></p>\n</blockquote>\n<h2 id=\"Docker\"><a href=\"#Docker\" class=\"headerlink\" title=\"Docker\"></a>Docker</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker run --rm  -itd  \\<br>  -v &quot;$(pwd)/out&quot;:/acme.sh  \\<br>  -e Ali_Key=&quot;xxxxxx&quot; \\<br>  -e Ali_Secret=&quot;xxxx&quot; \\<br>  neilpang/acme.sh  --issue --dns dns_ali -d domain.cn -d *.domain.cn<br></code></pre></td></tr></table></figure>\n\n<p>详细用法，可以参考：<a href=\"https://github.com/Neilpang/acme.sh/wiki/Run-acme.sh-in-docker\">传送门</a></p>\n<blockquote>\n<h1 id=\"acme-sh-💕-docker\"><a href=\"#acme-sh-💕-docker\" class=\"headerlink\" title=\"acme.sh 💕 docker\"></a>acme.sh 💕 docker</h1><p>  作为 docker 的忠实粉丝之一，我知道我们讨厌在 docker 主机上安装任何东西，即使它只是复制一个 shell 脚本。</p>\n<p>  用于 letsencrypt ssl 证书的带有 acme.sh 的自动化 nginx 反向代理 docker 图像： https: <a href=\"https://github.com/Neilpang/letsproxy\">&#x2F;&#x2F;github.com&#x2F;Neilpang&#x2F;letsproxy</a></p>\n<p>  部署到 docker 容器并重新加载它：<a href=\"https://github.com/Neilpang/acme.sh/wiki/deploy-to-docker-containers\">https :&#x2F;&#x2F;github.com&#x2F;Neilpang&#x2F;acme.sh&#x2F;wiki&#x2F;deploy-to-docker-containers</a></p>\n<p>  所以，这里出现了“docker 中的 acme.sh”。</p>\n<ol>\n<li>基于<strong>alpine</strong>，只有 5MB 大小。</li>\n<li>作为可执行文件运行或作为守护进程运行</li>\n<li>支持所有命令行参数。</li>\n</ol>\n<h1 id=\"1-说“Hello-World”\"><a href=\"#1-说“Hello-World”\" class=\"headerlink\" title=\"1.说“Hello World”\"></a>1.说“Hello World”</h1>  <figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dockerfile\">docker <span class=\"hljs-keyword\">run</span><span class=\"language-bash\"> --<span class=\"hljs-built_in\">rm</span> neilpang/acme.sh</span><br></code></pre></td></tr></table></figure>\n\n<h1 id=\"2-用作可执行文件：\"><a href=\"#2-用作可执行文件：\" class=\"headerlink\" title=\"2.用作可执行文件：\"></a>2.用作可执行文件：</h1>  <figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">docker run <span class=\"hljs-attr\">--rm</span>  -it  \\<br>  -v <span class=\"hljs-string\">&quot;$(pwd)/out&quot;</span>:/acme<span class=\"hljs-selector-class\">.sh</span>  \\<br>  <span class=\"hljs-attr\">--net</span>=host \\<br>  neilpang/acme<span class=\"hljs-selector-class\">.sh</span>  <span class=\"hljs-attr\">--issue</span> -d example<span class=\"hljs-selector-class\">.com</span>  <span class=\"hljs-attr\">--standalone</span><br></code></pre></td></tr></table></figure>\n\n<p>  您可以在此处使用<strong>acme.sh</strong>支持的<strong>任何命令</strong>，其他示例：</p>\n  <figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-selector-id\">#revoke</span> <span class=\"hljs-selector-tag\">a</span> cert<br>docker run <span class=\"hljs-attr\">--rm</span>  -it  \\<br>  -v <span class=\"hljs-string\">&quot;$(pwd)/out&quot;</span>:/acme<span class=\"hljs-selector-class\">.sh</span>  \\<br>  <span class=\"hljs-attr\">--net</span>=host \\<br>  neilpang/acme<span class=\"hljs-selector-class\">.sh</span>  <span class=\"hljs-attr\">--revoke</span> -d example<span class=\"hljs-selector-class\">.com</span><br><span class=\"hljs-selector-id\">#use</span> dns mode<br>docker run <span class=\"hljs-attr\">--rm</span>  -it  \\<br>  -v <span class=\"hljs-string\">&quot;$(pwd)/out&quot;</span>:/acme<span class=\"hljs-selector-class\">.sh</span>  \\<br>  neilpang/acme<span class=\"hljs-selector-class\">.sh</span>  <span class=\"hljs-attr\">--issue</span> <span class=\"hljs-attr\">--dns</span> -d example<span class=\"hljs-selector-class\">.com</span><br><span class=\"hljs-selector-id\">#run</span> cron job<br>docker run <span class=\"hljs-attr\">--rm</span>  -it  \\<br>  -v <span class=\"hljs-string\">&quot;$(pwd)/out&quot;</span>:/acme<span class=\"hljs-selector-class\">.sh</span>  \\<br>  <span class=\"hljs-attr\">--net</span>=host \\<br>  neilpang/acme<span class=\"hljs-selector-class\">.sh</span>  <span class=\"hljs-attr\">--cron</span><br></code></pre></td></tr></table></figure>\n\n<p>  无论如何，您可以像调用真正的 shell 脚本一样调用<strong>neilpang&#x2F;acme.sh。</strong></p>\n<h1 id=\"3-将-acme-sh-作为-docker-守护进程运行。\"><a href=\"#3-将-acme-sh-作为-docker-守护进程运行。\" class=\"headerlink\" title=\"3. 将 acme.sh 作为 docker 守护进程运行。\"></a>3. 将 acme.sh 作为 docker 守护进程运行。</h1><ol>\n<li>将 acme.sh 作为 docker 守护进程运行，以便它可以自动处理更新 cronjob。</li>\n</ol>\n  <figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">docker <span class=\"hljs-built_in\">run</span> --rm  -itd  \\<br>  -v <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$(pwd)</span>/out&quot;</span>:/acme.sh  \\<br>  <span class=\"hljs-attribute\">--net</span>=host \\<br>  <span class=\"hljs-attribute\">--name</span>=acme.sh \\<br>  neilpang/acme.sh daemon<br></code></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>然后你就可以使用<code>docker exec</code>来执行任何acme.sh 命令了。</li>\n</ol>\n  <figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">docker  exec  acme<span class=\"hljs-selector-class\">.sh</span> <span class=\"hljs-attr\">--help</span><br>docker  exec  acme<span class=\"hljs-selector-class\">.sh</span> <span class=\"hljs-attr\">--issue</span> -d example<span class=\"hljs-selector-class\">.com</span>  <span class=\"hljs-attr\">--standalone</span><br></code></pre></td></tr></table></figure>\n\n<p>  是的，再次强调，您可以在此处使用<strong>acme.sh</strong>支持的<strong>任何命令</strong>。</p>\n</blockquote>\n<h2 id=\"Certbot\"><a href=\"#Certbot\" class=\"headerlink\" title=\"Certbot\"></a>Certbot</h2><p><a href=\"https://certbot.eff.org/\">https://certbot.eff.org/</a></p>\n",
            "tags": [
                "ssl",
                "https"
            ]
        },
        {
            "id": "https://www.oikiou.top/2022/d911b12b/",
            "url": "https://www.oikiou.top/2022/d911b12b/",
            "title": "Zsh 安装 配置",
            "date_published": "2022-12-12T14:57:15.000Z",
            "content_html": "<h1 id=\"zsh\"><a href=\"#zsh\" class=\"headerlink\" title=\"zsh\"></a>zsh</h1><p><strong>Zsh</strong>是一个为交互使用而设计的shell，它也是一种强大的脚本语言。<em>bash</em>、ksh 和 <em>tcsh</em> 的许多有用特性都被合并到 <em>zsh</em> 中; 添加了许多原始功能。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">Ubuntu</span> <br>sudo apt-get install zsh<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>  zsh非常强大，同时它的配置也是较为繁杂，所以我们使用“oh my zsh”这个框架来简化我们的配置流程。</p>\n</blockquote>\n<p><code>cat /etc/shells</code> 查看当前系统有哪些shell版本<br><code>echo $SHELL</code> 查看当前使用的shell版本</p>\n<p>安装完成后会在<code>~</code>目录下产生一个<code>.zshrc</code>这个跟<code>.bashrc</code>是一样的文件，只是配置的对象不一样。<code>rc</code>就是启动的意思，启动zsh读取的配置就是这个文件。</p>\n<h1 id=\"Oh-My-Zsh\"><a href=\"#Oh-My-Zsh\" class=\"headerlink\" title=\"Oh My Zsh\"></a>Oh My Zsh</h1><p><a href=\"https://ohmyz.sh/\">官网</a></p>\n<p>Oh My Zsh 是一个令人愉快的、开源的、社区驱动的框架，用于管理你的 Zsh 配置。它捆绑了数千个有用的功能、助手、插件、主题和一些东西 让你大喊大叫… “Oh My ZSH!”</p>\n<h2 id=\"安装-1\"><a href=\"#安装-1\" class=\"headerlink\" title=\"安装\"></a>安装</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">sh -c &quot;$(wget https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)&quot;<br></code></pre></td></tr></table></figure>\n\n<p>安装完成后发现<code>~</code>目录下会有一个<code>.oh-my-zsh</code>文件夹，文件夹内的一些文件主要用处</p>\n<ul>\n<li><code>themes</code> 一些主题文件</li>\n<li><code>plugins</code> 插件，我们的插件就下载放在这个文件夹里面</li>\n</ul>\n<p>Powerlevel10k 是用于 Zsh 美化的一个非常酷的主题，它强调速度、 灵活性和开箱即用的体验。</p>\n<h2 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h2><h3 id=\"zsh-syntax-highlighting-语法高亮\"><a href=\"#zsh-syntax-highlighting-语法高亮\" class=\"headerlink\" title=\"zsh-syntax-highlighting 语法高亮\"></a>zsh-syntax-highlighting 语法高亮</h3><p>插件功能：这个包为<code>shell zsh</code>提供语法突出显示。它允许高亮显示在<code>zsh</code>提示符下输入到交互式终端的命令。这有助于在运行命令之前检查它们，特别是在捕获语法错误方面。<br>例：在你输入某个命令时，如果该命令不存在，那么它显示为红色；否则，它会变成绿色。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting<br></code></pre></td></tr></table></figure>\n\n<p>将 <code>zsh-syntax-highlighting</code> 添加到 <code>~/.zshrc</code> 中</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">plugins=(--other-- zsh-syntax-highlighting)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"zsh-autosuggestions-自动补全\"><a href=\"#zsh-autosuggestions-自动补全\" class=\"headerlink\" title=\"zsh-autosuggestions 自动补全\"></a>zsh-autosuggestions 自动补全</h3><p>插件功能：输入命令时可提示自动补全（灰色部分），按tab键（→ ）即可补全。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">git clone https://github.com/zsh-users/zsh-autosuggestions.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions<br></code></pre></td></tr></table></figure>\n\n<p>将 <code>zsh-autosuggestions</code> 添加到 <code>~/.zshrc</code> 中</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">plugins=(--other-- zsh-autosuggestions)<br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">空格分隔不同的插件</span><br></code></pre></td></tr></table></figure>\n\n<h1 id=\"Powerlevel10k\"><a href=\"#Powerlevel10k\" class=\"headerlink\" title=\"Powerlevel10k\"></a>Powerlevel10k</h1><p><a href=\"https://github.com/romkatv/powerlevel10k\">https://github.com/romkatv/powerlevel10k</a></p>\n<h2 id=\"安装-2\"><a href=\"#安装-2\" class=\"headerlink\" title=\"安装\"></a>安装</h2><h3 id=\"安装字体\"><a href=\"#安装字体\" class=\"headerlink\" title=\"安装字体\"></a>安装字体</h3><blockquote>\n<p>  powerlevel10k里面使用了很多的图标，而这些图标只有一些特定的字体才能显示，所以我们需要安装这些字体这样才能正常显示，我们称这些有很多图标的字体为<code>Nerd Fonts</code>。</p>\n</blockquote>\n<p>首先我们需要先安装一下字体，我们先下载官方推荐的<code>MesloLGS NF</code>字体来配置。</p>\n<ul>\n<li>Download these four ttf files:<ul>\n<li>[MesloLGS NF Regular.ttf](<a href=\"https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS\">https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS</a> NF Regular.ttf)</li>\n<li>[MesloLGS NF Bold.ttf](<a href=\"https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS\">https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS</a> NF Bold.ttf)</li>\n<li>[MesloLGS NF Italic.ttf](<a href=\"https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS\">https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS</a> NF Italic.ttf)</li>\n<li>[MesloLGS NF Bold Italic.ttf](<a href=\"https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS\">https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS</a> NF Bold Italic.ttf)</li>\n</ul>\n</li>\n<li>Double-click on each file and click “Install”. This will make <code>MesloLGS NF</code> font available to all applications on your system.</li>\n</ul>\n<blockquote>\n<p>  我们如果是在ssh配置远程主机的时候，是在本地的主机上安装这个字体。</p>\n<p>  字体影响的是显示，ssh显示是在本地渲染的，所以肯定是在本地主机上安装字体。</p>\n</blockquote>\n<h4 id=\"其他的Nerd-Fonts字体\"><a href=\"#其他的Nerd-Fonts字体\" class=\"headerlink\" title=\"其他的Nerd Fonts字体\"></a>其他的<code>Nerd Fonts</code>字体</h4><p><a href=\"https://github.com/ryanoasis/nerd-fonts\">https://github.com/ryanoasis/nerd-fonts</a></p>\n<p>我们可以在这里下载一些打过补丁的热门字体。</p>\n<h3 id=\"安装Powerlevel10k\"><a href=\"#安装Powerlevel10k\" class=\"headerlink\" title=\"安装Powerlevel10k\"></a>安装Powerlevel10k</h3><p>官方的README文档提出了几种安装方式，它推荐使用手动安装方式。</p>\n<h4 id=\"Manual\"><a href=\"#Manual\" class=\"headerlink\" title=\"Manual\"></a>Manual</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ~/powerlevel10k<br>echo &#x27;source ~/powerlevel10k/powerlevel10k.zsh-theme&#x27; &gt;&gt;~/.zshrc<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"Oh-My-Zsh-1\"><a href=\"#Oh-My-Zsh-1\" class=\"headerlink\" title=\"Oh My Zsh\"></a>Oh My Zsh</h4><ol>\n<li><p>Clone the repository:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">git clone --depth=1 https://github.com/romkatv/powerlevel10k.git $&#123;ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom&#125;/themes/powerlevel10k<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>在<code>~/.zshrc</code>文件中，设置<code>ZSH_THEME=&quot;powerlevel10k/powerlevel10k&quot;</code></p>\n</li>\n</ol>\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p>安装好后我们启动zsh，在zsh环境下输入<code>p10k configure</code>用于配置p10k</p>\n<blockquote>\n<p>  这一步我在<code>MobaXterm</code>下进行，发现可配置的选项缺失很多，后面在<code>Windows Terminal</code>重新配置发现显示是正常的。</p>\n<p>  <code>MobaXterm</code>下<code>Fira Code</code>字体似乎显示也有些问题，<code>MesloLGS NF</code>就是正常的。</p>\n<p>  23.8.1 p10k启动配置的时候如果选Unicode，该选项下会有尽量多图标的选项。MobaXterm里面如果出现历史候选词没有变灰色的情况可以在<code>Terminal Type</code>里面修改成<code>xterm-256color</code>，除此之外其他的没有尝试</p>\n</blockquote>\n",
            "tags": [
                "zsh",
                "shell",
                "linux"
            ]
        },
        {
            "id": "https://www.oikiou.top/2022/4dd4ea8a/",
            "url": "https://www.oikiou.top/2022/4dd4ea8a/",
            "title": "Ip 转换成 Location 的Api",
            "date_published": "2022-11-08T15:24:15.000Z",
            "content_html": "<h1 id=\"ip-to-location\"><a href=\"#ip-to-location\" class=\"headerlink\" title=\"ip to location\"></a>ip to location</h1><h2 id=\"ipwhois\"><a href=\"#ipwhois\" class=\"headerlink\" title=\"ipwhois\"></a>ipwhois</h2><p>IPWHOIS.IO的IP地理定位API的URL格式很简单。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">http://ipwhois.app/json/&#123;IP&#125;<br></code></pre></td></tr></table></figure>\n\n<p>例如，我们可以用以下IP地址发出API请求：47.9.123.84。</p>\n<p><img src=\"/2022/4dd4ea8a/ipwhois-api.png\" alt=\"img\"></p>\n<p><strong>参考链接:</strong></p>\n<ul>\n<li><a href=\"https://webdamn.com/ip-geolocation-api/\">IP Geolocation API – IPWHOIS.IO</a></li>\n<li><a href=\"https://webdamn.com/how-to-integrate-ip-geolocation-api-with-php/\">How to Integrate IP Geolocation API with PHP</a></li>\n<li><a href=\"https://webdamn.com/scrape-search-result-data-using-serpapi-with-python/\">Scrape Search Result Data using SerpApi with Python</a></li>\n<li><a href=\"https://webdamn.com/get-geocoding-using-positionstack-api-with-php/\">Get Geocoding using Positionstack API with PHP</a></li>\n<li><a href=\"https://webdamn.com/flight-data-using-aviationstack-api-with-php/\">Flight Data using Aviationstack API with PHP</a></li>\n<li><a href=\"https://webdamn.com/get-address-information-using-geocode-api-with-php/\">Get Address Information using Geocode API with PHP</a></li>\n<li><a href=\"https://webdamn.com/review-scraping-using-reviewapi-with-php/\">Review Scraping using ReviewAPI with PHP</a></li>\n<li><a href=\"https://webdamn.com/simple-web-scraping-with-zenscrape-api-using-php/\">Simple Web Scraping with Zenscrape API using PHP</a></li>\n<li><a href=\"https://webdamn.com/scrape-search-result-with-zenserp-api-using-php/\">Scrape Search Result with Zenserp API using PHP</a></li>\n<li><a href=\"https://webdamn.com/build-user-agent-lookup-system-using-userstack-api-with-php/\">Build User Agent Lookup System using Userstack API with PHP</a></li>\n<li><a href=\"https://webdamn.com/build-ip-lookup-website-using-ipapi-with-php/\">Build IP Lookup Website using ipapi with PHP</a></li>\n<li><a href=\"https://webdamn.com/build-weather-website-with-weatherstack-api-using-php/\">Build Weather Website with Weatherstack API using PHP</a></li>\n<li><a href=\"https://webdamn.com/get-website-visitors-info-using-ipstack-api-with-php/\">Get Website Visitors Info using IPStack API with PHP</a></li>\n<li><a href=\"https://webdamn.com/scrape-serp-data-using-serpstack-api-with-python/\">Scrape SERP Data using SerpStack API with Python</a></li>\n</ul>\n",
            "tags": [
                "ip",
                "location",
                "api"
            ]
        },
        {
            "id": "https://www.oikiou.top/2022/3db44d04/",
            "url": "https://www.oikiou.top/2022/3db44d04/",
            "title": "Android 文件传输模式 电脑无法识别",
            "date_published": "2022-10-10T14:57:15.000Z",
            "content_html": "<h1 id=\"android-文件传输模式-电脑无法识别\"><a href=\"#android-文件传输模式-电脑无法识别\" class=\"headerlink\" title=\"android 文件传输模式 电脑无法识别\"></a>android 文件传输模式 电脑无法识别</h1><p>最近android手机连接电脑选择传输文件模式，电脑不再识别手机。选择照片模式就没有问题。</p>\n<p>手机选择文件传输模式后 选择自动搜索驱动程序 安装后会 提示“这个inf中的服务安装段落无效”。</p>\n<h2 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h2><ol>\n<li><p>按“Win+X” 点击 “设备管理器”</p>\n</li>\n<li><p>在设备管理器中找到你的手机，名字可能是你的手机型号，可能是未知设备 ，</p>\n</li>\n<li><p>右键选择更新驱动程序.</p>\n</li>\n<li><p>选择 “浏览计算机以查找驱动程序软件”</p>\n</li>\n<li><p>选择 “让我从计算机上的可用驱动程序列表中选取”</p>\n</li>\n<li><p>在列表里面找到“便携设备” (可能没有这一步操作)</p>\n</li>\n<li><p>选择 “MTP USB 设备”</p>\n<p><img src=\"/2022/3db44d04/1636599848857.png\" alt=\"win10系统识别不了USB设备解决方法介绍-Win10系统识别不了USB设备怎么办-53系统之家\"></p>\n</li>\n<li><p>点击 “下一步”</p>\n</li>\n<li><p>回到设备管理器看到设备已经可用正确运作了</p>\n</li>\n</ol>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://developer.android.com/studio/run/oem-usb\">安装原始设备制造商 (OEM) USB 驱动程序</a></p>\n<p><a href=\"https://developer.android.com/studio/run/win-usb\">获取 Google USB 驱动程序</a></p>\n",
            "tags": [
                "windows",
                "android",
                "mtp",
                "pc",
                "driver"
            ]
        },
        {
            "id": "https://www.oikiou.top/2022/bc4a75ff/",
            "url": "https://www.oikiou.top/2022/bc4a75ff/",
            "title": "JPEG JPEG2000 WebP PNG GIF对比",
            "date_published": "2022-09-18T05:47:15.000Z",
            "content_html": "<h1 id=\"图像的显示原理\"><a href=\"#图像的显示原理\" class=\"headerlink\" title=\"图像的显示原理\"></a>图像的显示原理</h1><h2 id=\"有损-无损压缩\"><a href=\"#有损-无损压缩\" class=\"headerlink\" title=\"有损&#x2F;无损压缩\"></a>有损&#x2F;无损压缩</h2><p>图片文件格式有可能会对图片的文件大小进行不同程度的压缩，图片的压缩分为有损压缩和无损压缩两种。</p>\n<h3 id=\"有损压缩\"><a href=\"#有损压缩\" class=\"headerlink\" title=\"有损压缩\"></a>有损压缩</h3><p>对图像本身的改变，在保存图像时保留了较多的亮度信息，而将色相和色纯度的信息和周围的像素进行合并，合并的比例不同，压缩的比例也不同，由于信息量减少了，所以压缩比可以很高，图像质量也会相应的下降。并且这种损失是不可逆的，我们不可能从有一个有损压缩过的图片中恢复出全来的图片。常见的有损压缩手段，是按照一定的算法将临近的像素点进行合并。<br><strong>有损压缩的原理：</strong> <em>删除景物边缘的某些颜色部分，当人们在屏幕上观看这个场景图片，大脑会利用在景物上看到的颜色填补所丢失的颜色部分。</em><br><strong>有损压缩的优缺点：</strong> <em>是保持颜色的逐渐变化，删除图像中颜色的突然变化。生物学中的大量实验证明，人类大脑会利用与附近最接近的颜色来填补所丢失的颜色。例如，对于蓝色天空背景上的一朵白云，有损压缩的方法就是删除图像中景物边缘的某些颜色部分。当在·屏幕上看这幅图时，大脑会利用在景物上看到的颜色填补所丢失的颜色部分。利用有损压缩技术，某些数据被有意地删除了，而被取消的数据也不再恢复。 无可否认，利用有损压缩技术可以大大地压缩文件的数据，但是会影响图像质量。如果使用了有损压缩的图像仅在屏幕上显示，可能对图像质量影响不太大，至少对于人类眼睛的识别程度来说区别不大。可是，如果要把一幅经过有损压缩技术处理的图像用高分辨率打印机打印出来，那么图像质量就会有明显的受损痕迹。</em></p>\n<h3 id=\"无损压缩\"><a href=\"#无损压缩\" class=\"headerlink\" title=\"无损压缩\"></a>无损压缩</h3><p>无损压缩的基本原理是相同的颜色信息只需保存一次。压缩图像的软件首先会确定图像中哪些区域是相同的，哪些是不同的。包括了重复数据的图像(如蓝天) 就可以被压缩，只有蓝天的起始点和终结点需要被记录下来。但是蓝色可能还会有不同的深浅，天空有时也可能被树木、山峰或其他的对象掩盖，这些就需要另外记录。从本质上看，无损压缩的方法可以删除一些重复数据，大大减少要在磁盘上保存的图像尺寸。但是，无损压缩的方法并不能减少图像的内存占用量，这是因为，当从磁盘上读取图像时，软件又会把丢失的像素用适当的颜色信息填充进来。如果要减少图像占用内存的容量，就必须使用有损压缩方法。<br><strong>无损压缩的特点：</strong> <em>相同的颜色信息只需保存一次。</em><br><strong>无损压缩的原理：</strong> <em>首先辨别出相同颜色的区域，然后把这些相同的数据信息进行压缩记录，也就是记录它的颜色信息、起始和终止位置。</em></p>\n<h2 id=\"索引色-直接色\"><a href=\"#索引色-直接色\" class=\"headerlink\" title=\"索引色&#x2F;直接色\"></a>索引色&#x2F;直接色</h2><p>计算机在表示颜色的时候，有两种形式，一种称作索引颜色(Index Color)，一种称作直接颜色(Direct Color)。</p>\n<h3 id=\"索引色。\"><a href=\"#索引色。\" class=\"headerlink\" title=\"索引色。\"></a>索引色。</h3><p>是一种以有限的方式管理数字图像颜色的技术，以节省计算机内存和文件存储，同时加速显示刷新和文件传输。即用一个数字来代表（索引）一种颜色，在存储图片的时候，存储一个数字的组合，同时存储数字到图片颜色的映射。这种方式只能存储有限种颜色，通常是256种颜色，对应到计算机系统中，使用一个字节的数字来索引一种颜色。</p>\n<h3 id=\"直接色。\"><a href=\"#直接色。\" class=\"headerlink\" title=\"直接色。\"></a>直接色。</h3><p>使用四个数字来代表一种颜色，这四个数字分别代表这个颜色中红色、绿色、蓝色以及透明度（即rgba）。现在流行的显示设备可以在这四个维度分别支持256种变化，所以直接色可以表示2的32次方种颜色。当然并非所有的直接色都支持这么多种，为压缩空间使用，有可能只有表达红、绿、蓝的三个数字，每个数字也可能不支持256种变化之多</p>\n<h2 id=\"位图-矢量图\"><a href=\"#位图-矢量图\" class=\"headerlink\" title=\"位图&#x2F;矢量图\"></a>位图&#x2F;矢量图</h2><h3 id=\"位图。\"><a href=\"#位图。\" class=\"headerlink\" title=\"位图。\"></a>位图。</h3><p>位图也叫做点阵图，栅格图像，像素图。简单的说，就是最小单位由像素构成的图，缩放会失真。构成位图的最小单位是像素，位图就是由像素阵列的排列来实现其显示效果的，每个像素有自己的颜色信息，在对位图图像进行编辑操作的时候，可操作的对象是每个像素，我们可以改变图像的色相、饱和度、明度，从而改变图像的显示效果。举个例子来说，位图图像就好比在巨大的沙盘上画好的画，当你从远处看的时候，画面细腻多彩，但是当你靠的非常近的时候，你就能看到组成画面的每粒沙子以及每个沙粒单纯的不可变化颜色。</p>\n<h3 id=\"矢量图，\"><a href=\"#矢量图，\" class=\"headerlink\" title=\"矢量图，\"></a>矢量图，</h3><p>也叫做向量图。矢量图并不纪录画面上每一点的信息，而是纪录了元素形状及颜色的算法，当你打开一付矢量图的时候，软件对图形象对应的函数进行运算，将运算结果[图形的形状和颜色]显示给你看。无论显示画面是大还是小，画面上的对象对应的算法是不变的，所以，即使对画面进行倍数相当大的缩放，其显示效果仍然相同(不失真)。</p>\n<h1 id=\"JPEG-JPEG2000-WebP\"><a href=\"#JPEG-JPEG2000-WebP\" class=\"headerlink\" title=\"JPEG JPEG2000 WebP\"></a>JPEG JPEG2000 WebP</h1><blockquote>\n<p>  摘录自知乎: </p>\n<p>  原文: <a href=\"https://zhuanlan.zhihu.com/p/19586108\">https://zhuanlan.zhihu.com/p/19586108</a></p>\n<p>  作者: <a href=\"https://www.zhihu.com/people/xhacker\">柳东原</a> This Xhacker has super Big Cat power.</p>\n</blockquote>\n<p><strong>压缩性能综合看来，WebP 略好于 JPEG2000，而这两者都明显好于 JPEG。</strong></p>\n<p>前段时间测试了一下这三种有损图像压缩算法的质量。（WebP 也能支持无损，不过这里只测试有损。）</p>\n<p>测试结果（<a href=\"https://link.zhihu.com/?target=http://en.wikipedia.org/wiki/Structural_similarity\">SSIM Index</a> 可理解为图片与原图片的相似度）：</p>\n<p><img src=\"/2022/bc4a75ff/6dd37790364b1a5e709f8e67adab81d3_r.jpg\" alt=\"img\"></p>\n<p><img src=\"/2022/bc4a75ff/868c8f801447ee85c0867556cdb1f705_r.jpg\" alt=\"img\"></p>\n<p><img src=\"/2022/bc4a75ff/85ab2ef874126a10072e4669d9cd7c90_720w.jpg\" alt=\"img\"></p>\n<p><img src=\"/2022/bc4a75ff/ea62d92a63b45aa121eb0ccfce4a97fd_720w.jpg\" alt=\"img\"></p>\n<p><img src=\"/2022/bc4a75ff/6cdab6a9efdf3df3fba2657314d81734_720w.jpg\" alt=\"img\"></p>\n<p><img src=\"/2022/bc4a75ff/323465387e562470441127b8f0cc992e_720w.jpg\" alt=\"img\"></p>\n<p>测试细节：对于 JPEG 使用 libjpeg 压缩，JPEG 2000 使用 OpenJPEG，WebP 使用 libwebp。</p>\n<h1 id=\"JPEG-PNG-GIF-WEBP\"><a href=\"#JPEG-PNG-GIF-WEBP\" class=\"headerlink\" title=\"JPEG PNG GIF WEBP\"></a>JPEG PNG GIF WEBP</h1><p><strong>综合看来</strong></p>\n<ul>\n<li>PNG 可以保存透明信息, 比较适合颜色单一, 主要是纯色的图像, ( logo&#x2F;icon&#x2F;透明图 )</li>\n<li>JPEG 适用颜色种类多样 且颜色变化明显的图片 ( 一般照片 )</li>\n<li>GIF 支持动画,透明, 只有8位颜色 ( 动图 )</li>\n<li>WEBP 文件小, 支持透明, 有损无损压缩, 支持动画, 兼容性不好 ( 网页图像 )</li>\n</ul>\n<h2 id=\"JPEG\"><a href=\"#JPEG\" class=\"headerlink\" title=\"JPEG\"></a>JPEG</h2><p>JPEG是有损的、采用直接色的、位图。JPEG也是一种针对照片影像而广泛使用的有损压缩标准方法。JPEG图片格式的设计目标，是在不影响人类可分辨的图片质量的前提下，尽可能的压缩文件大小。这意味着JPEG去掉了一部分图片的原始信息，也即是进行了有损压缩。JPEG的图片的优点，是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，用来表达更生动的图像效果，比如颜色渐变。</p>\n<ul>\n<li>特性：适用于存储色彩丰富、层次分明的图片，不适合于线条绘图（drawing）和其他文字或图标（iconic）的图形，因为它的压缩方法用在这些类型的图形上，得到的结果并不好(PNG和GIF通常是用来存储这类的图形)</li>\n</ul>\n<h2 id=\"PNG\"><a href=\"#PNG\" class=\"headerlink\" title=\"PNG\"></a>PNG</h2><p>便携式网络图形是一种无损压缩的位图图形格式，支持索引、灰度、RGB三种颜色方案以及Alpha通道等特性</p>\n<ul>\n<li>特性：如果保存文本，线条或类似的边缘清晰，有大块相同颜色区域的图像，PNG格式的压缩效果就要比JPEG好很多，并且不会出现JPEG那样的高对比度区域的图像有损。如果图像既有清晰边缘，又有照片图像的特点，就需要在这两种格式之间权衡一下了。JPEG不支持透明度。<br>PNG格式有8位、24位、32位三种形式,其中8位PNG支持两种不同 的透明形式（索引透明和alpha透明）,24位PNG不支持透明,32位 PNG 在24位基础上增加了8位透明通道（32-24&#x3D;&#x3D;&#x3D;8）,因此可展现256级透明程度。</li>\n</ul>\n<h3 id=\"PNG8\"><a href=\"#PNG8\" class=\"headerlink\" title=\"PNG8\"></a>PNG8</h3><p>PNG8是<strong>无损的、使用索引色的、点阵图</strong>,支持不透明、索引透明、Alpha透明，都最多只能展示256（2的8次方）种颜色，所以“PNG8”格式更适合那些颜色比较单一的图像，例如纯色、logo、图标等；因为颜色数量少，所以图片的体积也会更小；</p>\n<ul>\n<li><p>PNG8(不透明),默认PNG8</p>\n</li>\n<li><p>PNG8(索引色透明),简单说可以理解为静态的GIF<br>指定一个像素点是不是透明<br>但是PNG由于算法的优势,体积比较少<br>所以,静态GIF完全可用PNG8取代</p>\n</li>\n<li><p>PNG8(Alpha透明),牛逼在可指定像素点的透明度,例如50%透明度<br>这种优点在于比PNG24&#x2F;32体积小,因为也只有256色嘛<br>缺点在于IE6支持不好,会把半透明的像素点显示成全透明</p>\n</li>\n</ul>\n<h3 id=\"PNG24\"><a href=\"#PNG24\" class=\"headerlink\" title=\"PNG24\"></a>PNG24</h3><p>是PNG的直接色版本。PNG24是<strong>无损的、使用直接色的、点阵图</strong>,支持2的24次方种颜色，表现为不透明。用三个8bits分别去表示 R（红）、G（绿）、B（蓝）。R(0255),G(0255),B(0~255)，可以表达256乘以256乘以256&#x3D;16777216种颜色的图片，这样PNG24就能比PNG8表示色彩更丰富的图片,图片的清晰度也会更好，图片质量更高，当然图片的大小也会相应增加，所以“PNG24”的图片比较适合像摄影作品之类颜色比较丰富的图片<br>PNG24与JPG一样能表达丰富的图片细节，但并不能替代JPG。图片存储为PNG24比存储为JPG，文件大小至少是JPG的5倍，但在图片品质上的提升却微乎其微。所以除非对品质的要求极高，否则色彩丰富的网络图片还是推荐使用JPG</p>\n<h3 id=\"PNG32\"><a href=\"#PNG32\" class=\"headerlink\" title=\"PNG32\"></a>PNG32</h3><p>支持2的32次方种颜色，32位是我们最常使用的格式，它是在PNG在24位的PNG基础上增加了8位的透明信息，支持不同程度的半透效果</p>\n<h3 id=\"PNG8-PNG24-PNG32三者的区别在于：\"><a href=\"#PNG8-PNG24-PNG32三者的区别在于：\" class=\"headerlink\" title=\"PNG8\\PNG24\\PNG32三者的区别在于：\"></a>PNG8\\PNG24\\PNG32三者的区别在于：</h3><ul>\n<li>PNG-32每个像素的深度为32bits，其中RGBA四个通道各占8bits。所谓的RGBA四个通道，就是红，绿，蓝，透明 这四种色值各自的大小，都用8bits来表示（0～255）。</li>\n<li>PNG-24的像素深度为24bits，其中RGB三个通道各占8bits。</li>\n<li>PNG-8则是使用8位的索引色。</li>\n</ul>\n<h2 id=\"GIF\"><a href=\"#GIF\" class=\"headerlink\" title=\"GIF\"></a>GIF</h2><p>GIF是一种<strong>无损、使用于索引色的、位图</strong>。由于采用了无损压缩，相比古老的bmp格式，尺寸较小，而且支持透明和动画。缺点是由于gif只存储8位索引（也就是最多能表达2^8&#x3D;256种颜色），色彩复杂、细节丰富的图片不适合保存为gif格式。色彩简单的logo、icon、线框图适合采用gif格式。</p>\n<p>静态GIF完全可用PNG8取代</p>\n<h2 id=\"WEBP\"><a href=\"#WEBP\" class=\"headerlink\" title=\"WEBP\"></a>WEBP</h2><p>WebP图片是一种同时提供了<strong>有损压缩与无损压缩、使用直接色的、位图</strong>，由Google开发。与png、jpg相比，相同的视觉体验下，WebP图像的尺寸缩小了大约30％。另外，WebP图像格式还支持有损压缩、无损压缩、透明和动画。理论上完全可以替代png、jpg、gif等图片格式，当然目前webp的还没有得到全面的支持。</p>\n<p>WEBP与PNG压缩对比</p>\n<p><img src=\"/2022/bc4a75ff/formatpng.png\" alt=\"img\"></p>\n<p>可以得出结论：</p>\n<blockquote>\n<p>  PNG 转 WebP 的压缩率要高于 PNG 原图压缩率，同样支持有损与无损压缩<br>  转换后的 WebP 体积大幅减少，图片质量也得到保障（同时肉眼几乎无法看出差异）<br>  转换后的 WebP 支持 Alpha 透明和 24-bit 颜色数，不存在 PNG8 色彩不够丰富和在浏览器中可能会出现毛边的问题</p>\n</blockquote>\n",
            "tags": [
                "jpeg",
                "webp",
                "jpeg2000",
                "image"
            ]
        },
        {
            "id": "https://www.oikiou.top/2022/631793c8/",
            "url": "https://www.oikiou.top/2022/631793c8/",
            "title": "文件后缀与文件",
            "date_published": "2022-09-15T09:47:15.000Z",
            "content_html": "<h1 id=\"文件后缀与文件\"><a href=\"#文件后缀与文件\" class=\"headerlink\" title=\"文件后缀与文件\"></a>文件后缀与文件</h1><table>\n<thead>\n<tr>\n<th>后缀</th>\n<th>名称描述</th>\n<th>简述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>.DS_Store</code></td>\n<td>Desktop Services Store</td>\n<td>Mac OS X操作系统所创造的隐藏文件，类似<code>desktop.ini</code></td>\n</tr>\n</tbody></table>\n<h2 id=\"编辑历史\"><a href=\"#编辑历史\" class=\"headerlink\" title=\"编辑历史\"></a>编辑历史</h2><table>\n<thead>\n<tr>\n<th>date</th>\n<th>note</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>2022.9.15</td>\n<td>First Version</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"DS-Store\"><a href=\"#DS-Store\" class=\"headerlink\" title=\".DS_Store\"></a>.DS_Store</h2><blockquote>\n<p>  DS_Store，英文全称是 Desktop Services Store（桌面服务存储），开头的 DS 是 Desktop Services（桌面服务） 的缩写。它是一种由macOS系统自动创建的隐藏文件，存在于每一个用「Finder」打开过的文件夹下面。</p>\n<p>  <code>.DS_Store</code> 是一种由苹果公司的Mac OS X操作系统所创造的隐藏文件，目的在于存贮目录的自定义属性，例如文件们的图标位置或者是背景色的选择。该文件由<code>Finder</code>创建并维护，类似于<code>Microsoft Windows</code>中的<code>desktop.ini</code>文件。</p>\n</blockquote>\n<h2 id=\"RTF\"><a href=\"#RTF\" class=\"headerlink\" title=\".RTF\"></a>.RTF</h2><blockquote>\n<p>  <strong>富文本格式</strong>（<strong>Rich Text Format</strong>）即<strong>RTF格式</strong>，又称<strong>多文本格式</strong>，是由<a href=\"https://zh.wikipedia.org/wiki/%E5%BE%AE%E8%BD%AF\">微软</a>公司开发的跨平台<a href=\"https://zh.wikipedia.org/wiki/%E6%96%87%E6%A1%A3\">文档</a>格式。大多数的<a href=\"https://zh.wikipedia.org/wiki/%E6%96%87%E5%AD%97%E5%A4%84%E7%90%86\">文字处理</a>软件都能读取和保存RTF文档。</p>\n<h2 id=\"支持软件\"><a href=\"#支持软件\" class=\"headerlink\" title=\"支持软件\"></a>支持软件</h2><ul>\n<li><a href=\"https://zh.wikipedia.org/wiki/WordPad\">WordPad</a>（<a href=\"https://zh.wikipedia.org/wiki/Microsoft_Windows\">Microsoft Windows</a>）&#x2F; <a href=\"https://zh.wikipedia.org/wiki/%E6%96%87%E5%AD%97%E7%B7%A8%E8%BC%AF_(%E6%87%89%E7%94%A8%E7%A8%8B%E5%BC%8F)\">文本编辑</a>（<a href=\"https://zh.wikipedia.org/wiki/Mac_OS\">Mac OS</a>）</li>\n<li><a href=\"https://zh.wikipedia.org/wiki/Microsoft_Word\">Microsoft Word</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/Apache_OpenOffice\">Apache OpenOffice</a> &#x2F; <a href=\"https://zh.wikipedia.org/wiki/LibreOffice\">LibreOffice</a></li>\n<li><a href=\"https://zh.wikipedia.org/zh-cn/WPS_Office\">WPS Office</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/EIOffice\">EIOffice</a></li>\n</ul>\n</blockquote>\n",
            "tags": [
                "DS_Store",
                "rtf",
                "后缀"
            ]
        },
        {
            "id": "https://www.oikiou.top/2022/613d8edd/",
            "url": "https://www.oikiou.top/2022/613d8edd/",
            "title": "Zip Gzip Bzip2 Tar 的区别和差异",
            "date_published": "2022-09-14T16:20:15.000Z",
            "content_html": "<h1 id=\"zip-gzip-bzip2-tar-命令的区别和差异\"><a href=\"#zip-gzip-bzip2-tar-命令的区别和差异\" class=\"headerlink\" title=\"zip gzip bzip2 tar 命令的区别和差异\"></a>zip gzip bzip2 tar 命令的区别和差异</h1><ul>\n<li><code>gzip</code> 和 <code>bzip2</code>用于压缩单个文件。bzip2 比 gzip 具有更高的压缩率，同样的也会需要<strong>更多更多更多</strong>时间来进行压缩。</li>\n<li><code>tar</code>格式的包只是将文件归档在一起, 并不会有任何压缩。</li>\n<li><code>zip</code> 和 <code>tar</code> 命令用于压缩和归档文件夹。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>zip</td>\n<td><code>.zip</code></td>\n<td>可以压缩目录</td>\n<td>源文件会保留</td>\n<td>专门的压缩命令</td>\n</tr>\n<tr>\n<td>gzip</td>\n<td><code>.gz</code></td>\n<td>只能压缩文件</td>\n<td>压缩后源文件会被删除</td>\n<td></td>\n</tr>\n<tr>\n<td>bzip2</td>\n<td><code>.bz2</code></td>\n<td>只能压缩文件</td>\n<td>加<code>-k</code>参数源文件可以保留</td>\n<td></td>\n</tr>\n<tr>\n<td>tar</td>\n<td><code>.tar</code></td>\n<td>可以压缩目录</td>\n<td>源文件会保留</td>\n<td>linux包大多是这形态<br>将目录打包成一个文件<code>Tape archive</code></td>\n</tr>\n<tr>\n<td>xz</td>\n<td><code>.xz</code></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"zip\"><a href=\"#zip\" class=\"headerlink\" title=\"zip\"></a>zip</h2><h2 id=\"gzip\"><a href=\"#gzip\" class=\"headerlink\" title=\"gzip\"></a>gzip</h2><p>该<code>gzip</code>程序用于压缩一个或多个文件。执行时，它将原始文件替换为原始文件的压缩版本。使用 gzip 压缩的文件具有扩展名<code>.gz</code></p>\n<h2 id=\"bzip2\"><a href=\"#bzip2\" class=\"headerlink\" title=\"bzip2\"></a>bzip2</h2><p>该<code>bzip2</code>命令类似于 gzip，但使用不同的压缩算法，以牺牲压缩速度为代价归档更高级别的压缩。使用 bzip2 压缩的文件具有扩展名<code>.bz2</code></p>\n<h2 id=\"tar\"><a href=\"#tar\" class=\"headerlink\" title=\"tar\"></a>tar</h2><p><code>tar</code>命令，首字母缩略词<em><strong>Tape archive</strong></em>用于创建存档文件。tar 存档可以由单独的文件、一个或多个目录层次结构或两者的混合组成。tar 文件有扩展名<code>.tar</code></p>\n<h2 id=\"xz\"><a href=\"#xz\" class=\"headerlink\" title=\"xz\"></a>xz</h2><p><code>xz</code>是一个通用的数据压缩工具，命令行语法类似于 gzip 和 bzip2 。它根据选择的操作模式压缩或解压缩每个文件。用 xz 压缩的文件具有扩展名<code>.xz</code></p>\n<h1 id=\"Zip-和-Unzip\"><a href=\"#Zip-和-Unzip\" class=\"headerlink\" title=\"Zip 和 Unzip\"></a>Zip 和 Unzip</h1><h2 id=\"zip-1\"><a href=\"#zip-1\" class=\"headerlink\" title=\"zip\"></a>zip</h2><p><strong>命令格式</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">zip [-r] [压缩后文件名] [文件或目录]<br></code></pre></td></tr></table></figure>\n\n<p><strong>命令描述</strong></p>\n<ul>\n<li><code>zip</code>命令用来对文件进行打包操作。zip是个使用广泛的压缩程序，文件经它压缩后会另外产生具有“.zip”扩展名的压缩文件；</li>\n<li>在linux压缩后的文件，基本都可以在Windows系统中解压；Windows中压缩的文件，在Linux中不一定可用，但是zip格式的压缩文件，可以做到可用；</li>\n<li>zip的压缩比不是很高；</li>\n</ul>\n<p><strong>示例</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 压缩文件</span><br>$ zip a.zip a.txt<br><span class=\"hljs-comment\"># 查看压缩后的文件</span><br>$ <span class=\"hljs-built_in\">ls</span><br>a.txt  a.zip  <br><br><span class=\"hljs-comment\"># 2. -r：压缩文件夹</span><br>$ zip -r test.zip testDir/<br>$ <span class=\"hljs-built_in\">ls</span><br>testDir  test.zip<br><br><span class=\"hljs-comment\"># 3. -x 排除文件</span><br>$ zip -r test2.zip testDir/ -x <span class=\"hljs-string\">&quot;testDir/hello*&quot;</span> -x <span class=\"hljs-string\">&quot;testDir/dir/*&quot;</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"unzip-解压\"><a href=\"#unzip-解压\" class=\"headerlink\" title=\"unzip 解压\"></a>unzip 解压</h2><p><strong>命令格式</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">unzip [选项] 文件名<br></code></pre></td></tr></table></figure>\n\n<p><strong>命令描述</strong></p>\n<p><code>unzip</code>命令用于解压缩由zip命令压缩的“.zip”压缩包。</p>\n<p><strong>选项</strong></p>\n<ul>\n<li>-n：解压缩时不要覆盖原有的文件；</li>\n<li>-o：不必先询问用户，unzip执行后覆盖原有的文件；</li>\n<li>-d &lt;目录&gt;：指定文件解压缩后所要存储的目录(不指定目录，默认解压到当前目录)</li>\n</ul>\n<p><strong>示例</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 解压文件到家目录</span><br>$ unzip test.zip -d ~<br></code></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"Gzip-和-Gunzip\"><a href=\"#Gzip-和-Gunzip\" class=\"headerlink\" title=\"Gzip 和 Gunzip\"></a>Gzip 和 Gunzip</h1><h2 id=\"gzip-1\"><a href=\"#gzip-1\" class=\"headerlink\" title=\"gzip\"></a><strong>gzip</strong></h2><p><strong>命令格式</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">gzip [文件]<br></code></pre></td></tr></table></figure>\n\n<p><strong>命令描述</strong></p>\n<p><code>gzip</code>命令 用来压缩文件。gzip是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多处“<code>.gz</code>”扩展名。<code>gzip</code>只能压缩文件，不能压缩文件夹，压缩后原文件会被删除</p>\n<p><code>gzip</code>是在Linux系统中经常使用的一个对文件进行压缩和解压缩的命令，既方便又好用。gzip不仅可以用来压缩大的、较少使用的文件以节省磁盘空间，还可以和tar命令一起构成Linux操作系统中比较流行的压缩文件格式。据统计，gzip命令对文本文件有60%～70%的压缩率。减少文件大小有两个明显的好处，一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间。</p>\n<p><strong>示例</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 压缩文件</span><br>$ gzip a.txt<br><span class=\"hljs-comment\"># 查看压缩后的文件，源文件被删除</span><br>$ <span class=\"hljs-built_in\">ls</span><br>a.txt.gz<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"gunzip-解压\"><a href=\"#gunzip-解压\" class=\"headerlink\" title=\"gunzip 解压\"></a>gunzip 解压</h2><p><strong>命令格式</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">gzip [文件]<br></code></pre></td></tr></table></figure>\n\n<p><strong>命令描述</strong></p>\n<p><code>gunzip</code>命令用来解压缩文件。gunzip是个使用广泛的解压缩程序，它用于解开被gzip压缩过的文件，这些压缩文件预设最后的扩展名为<code>.gz</code>。</p>\n<p><strong>示例</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 解压文件，解压后压缩文件被删除</span><br>$ gunzip a.txt.gz<br>$ <span class=\"hljs-built_in\">ls</span><br>a.txt <br></code></pre></td></tr></table></figure>\n\n<h1 id=\"Bzip2\"><a href=\"#Bzip2\" class=\"headerlink\" title=\"Bzip2\"></a>Bzip2</h1><h2 id=\"bzip2-1\"><a href=\"#bzip2-1\" class=\"headerlink\" title=\"bzip2\"></a>bzip2</h2><p><strong>命令格式</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">bzip2 [选项] [文件]<br></code></pre></td></tr></table></figure>\n\n<p><strong>命令描述</strong></p>\n<ul>\n<li>bzip2命令用于压缩“<code>.bz2</code>”格式的压缩包，是<code>gzip</code>的升级版本，可以保留原文件；</li>\n<li>bzip2的压缩比比较高，可用于压缩较大文件的压缩；</li>\n<li>bzip2也是只对文件进行压缩，如果相对目录进行压缩的话，可以配合 <code>tar</code>命令使用，使用 <code>tar -jcvf</code> 文件名 完成打包压缩。</li>\n</ul>\n<p><strong>选项</strong></p>\n<p>-k（keep）：保留原文件（不删除原文件）</p>\n<p><strong>示例</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># bzip2 压缩文件</span><br>$ bzip2 -k a.txt<br>$ <span class=\"hljs-built_in\">ls</span><br>a.txt  a.txt.bz2<br><br><span class=\"hljs-comment\"># 配合使用tar 命令，完成打包压缩</span><br>$ <span class=\"hljs-built_in\">mkdir</span> music<br>$ tar -jcvf music.tar.bz2 music/<br>$ <span class=\"hljs-built_in\">ls</span><br>music  music.tar.bz2<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"bunzip2-解压\"><a href=\"#bunzip2-解压\" class=\"headerlink\" title=\"bunzip2 解压\"></a>bunzip2 解压</h2><p><strong>命令格式</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">bunzip2 [选项] [文件]<br></code></pre></td></tr></table></figure>\n\n<p><strong>命令描述</strong></p>\n<ul>\n<li>解压缩“<code>.bz2</code>”格式的压缩文件；</li>\n<li>gunzip的升级版，可以使用<code>-k</code>保留原文件；</li>\n<li>可以配合使用tar命令，完成解压缩解包： <code>tar -jxvf 文件名</code></li>\n</ul>\n<p><strong>选项</strong></p>\n<p>-k（keep）：保留原文件（不删除原文件）</p>\n<p><strong>示例</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ <span class=\"hljs-built_in\">ls</span><br>a.txt.bz2  music.tar.bz2<br><br><span class=\"hljs-comment\"># 解压缩文件</span><br>$ bunzip2 -k a.txt.bz2<br>$ <span class=\"hljs-built_in\">ls</span><br>a.txt  a.txt.bz2  music.tar.bz2<br><br><span class=\"hljs-comment\"># 使用tar完成解压解包</span><br>$ tar -jxvf music.tar.bz2<br>$ <span class=\"hljs-built_in\">ls</span><br>a.txt  a.txt.bz2  music  music.tar.bz2<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"tar-1\"><a href=\"#tar-1\" class=\"headerlink\" title=\"tar\"></a>tar</h1><h2 id=\"tar-2\"><a href=\"#tar-2\" class=\"headerlink\" title=\"tar\"></a>tar</h2><p><strong>命令格式</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">tar [选项] [压缩后文件名] [目录]<br></code></pre></td></tr></table></figure>\n\n<p><strong>命令描述</strong></p>\n<p>打包目录，将目录打包成一个文件，同时可以压缩，压缩后的拓展名为<code>.tar.gz</code>，这个拓展名在下载Linux相关安装包时很常见。</p>\n<p>使用<code>tar</code>命令时，如果想要打包并压缩一个目录，可以有两种方法进行：</p>\n<ol>\n<li>先利用tar命令打包目录为一个文件，然后使用gzip压缩</li>\n<li>直接利用tar命令打包并压缩 (简单方便，推荐使用)</li>\n</ol>\n<p>解压时也有两种方式：</p>\n<ol>\n<li>先使用gunzip解压缩，再使用tar解包</li>\n<li>直接利用tar命令解压缩并解包 (简单方便，推荐使用)</li>\n</ol>\n<p><strong>选项</strong></p>\n<ul>\n<li>-c：打包(将所有文件变成一个文件 Create  a new archive)</li>\n<li>-x：解包</li>\n<li>-v：显示详细信息</li>\n<li>-f：指定文件名</li>\n<li>-z：打包同时压缩&#x2F;解压缩  ，gzip压缩</li>\n<li>-j：生成压缩文件 ，bzip2压缩</li>\n</ul>\n<p><strong>示例</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 压缩</span><br>tar -zcvf movie2.tar.gz movie<br><span class=\"hljs-comment\"># 解压</span><br>tar -zxvf movie2.tar.gz<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 1、2为    打包压缩    的两种方法</span><br><span class=\"hljs-comment\"># 1. 使用 tar -cvf 打包，然后使用gzip压缩</span><br>$ tar -cvf movie.tar movie/<br>$ <span class=\"hljs-built_in\">ls</span><br>movie  movie.tar<br>$ gzip movie.tar<br>$ <span class=\"hljs-built_in\">ls</span><br>movie  movie.tar.gz<br><br><span class=\"hljs-comment\"># 2. 使用 tar -zcvf 打包并压缩</span><br>$ tar -zcvf movie2.tar.gz movie<br>$ <span class=\"hljs-built_in\">ls</span><br>movie  movie2.tar.gz<br><br><span class=\"hljs-comment\"># 3、4为     解压缩并解包     的两种方法</span><br><span class=\"hljs-comment\"># 3. 先使用gunzip解压缩，然后 tar -xvf解包</span><br>$ gunzip movie.tar.gz<br>$ <span class=\"hljs-built_in\">ls</span><br>movie2.tar.gz  movie.tar<br>$ tar -xvf movie.tar<br>movie/<br>$ <span class=\"hljs-built_in\">ls</span><br>movie  movie2.tar.gz  movie.tar<br><br><span class=\"hljs-comment\"># 4. 使用tar -zxvf 解压缩并解包</span><br>$ tar -zxvf movie2.tar.gz<br>$ <span class=\"hljs-built_in\">ls</span><br>movie  movie2.tar.gz  movie.tar<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://techviewleo.com/compress-uncompress-files-tar-gzip-bzip2-xz-linux/\">LPIC 101 – Compress and Uncompress Files Using tar, gzip, bzip2 and xz on Linux</a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/List_of_archive_formats#Comparison\">List of archive formats</a></p>\n",
            "tags": [
                "zip",
                "gzip",
                "bzip",
                "tar"
            ]
        }
    ]
}
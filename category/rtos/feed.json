{
    "version": "https://jsonfeed.org/version/1",
    "title": "Oikiou's Blog • All posts by \"rtos\" category",
    "description": "Blog",
    "home_page_url": "https://www.oikiou.top",
    "items": [
        {
            "id": "https://www.oikiou.top/2021/42e53028/",
            "url": "https://www.oikiou.top/2021/42e53028/",
            "title": "RT-Thread",
            "date_published": "2021-07-21T14:57:15.000Z",
            "content_html": "<h1 id=\"RT-Thread-目录\"><a href=\"#RT-Thread-目录\" class=\"headerlink\" title=\"RT-Thread 目录\"></a>RT-Thread 目录</h1><p>[TOC]</p>\n<h1 id=\"内核简介\"><a href=\"#内核简介\" class=\"headerlink\" title=\"内核简介\"></a>内核简介</h1><h2 id=\"自动初始化机制\"><a href=\"#自动初始化机制\" class=\"headerlink\" title=\"自动初始化机制\"></a>自动初始化机制</h2><table>\n<thead>\n<tr>\n<th><strong>初始化顺序</strong></th>\n<th><strong>宏接口</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>INIT_BOARD_EXPORT(fn)</td>\n<td>非常早期的初始化，此时调度器还未启动</td>\n</tr>\n<tr>\n<td>2</td>\n<td>INIT_PREV_EXPORT(fn)</td>\n<td>主要是用于纯软件的初始化、没有太多依赖的函数</td>\n</tr>\n<tr>\n<td>3</td>\n<td>INIT_DEVICE_EXPORT(fn)</td>\n<td>外设驱动初始化相关，比如网卡设备</td>\n</tr>\n<tr>\n<td>4</td>\n<td>INIT_COMPONENT_EXPORT(fn)</td>\n<td>组件初始化，比如文件系统或者 LWIP</td>\n</tr>\n<tr>\n<td>5</td>\n<td>INIT_ENV_EXPORT(fn)</td>\n<td>系统环境初始化，比如挂载文件系统</td>\n</tr>\n<tr>\n<td>6</td>\n<td>INIT_APP_EXPORT(fn)</td>\n<td>应用初始化，比如 GUI 应用</td>\n</tr>\n</tbody></table>\n<h2 id=\"内核对象管理架构\"><a href=\"#内核对象管理架构\" class=\"headerlink\" title=\"内核对象管理架构\"></a>内核对象管理架构</h2><p>派生和继承</p>\n<p><img src=\"/2021/42e53028/03kernel_object-1608970713169.png\" alt=\"RT-Thread 的内核对象容器及链表\"></p>\n<p><img src=\"/2021/42e53028/03kernel_object2-1608970663476.png\" alt=\"03kernel_object2\"></p>\n<h2 id=\"内核rtconfig-h配置\"><a href=\"#内核rtconfig-h配置\" class=\"headerlink\" title=\"内核rtconfig.h配置\"></a>内核rtconfig.h配置</h2><p>（1）RT-Thread 内核部分</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/* 表示内核对象的名称的最大长度，若代码中对象名称的最大长度大于宏定义的长度，</span><br><span class=\"hljs-comment\"> * 多余的部分将被截掉。*/</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> RT_NAME_MAX 8</span><br><br><span class=\"hljs-comment\">/* 字节对齐时设定对齐的字节个数。常使用 ALIGN(RT_ALIGN_SIZE) 进行字节对齐。*/</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> RT_ALIGN_SIZE 4</span><br><br><span class=\"hljs-comment\">/* 定义系统线程优先级数；通常用 RT_THREAD_PRIORITY_MAX-1 定义空闲线程的优先级 */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> RT_THREAD_PRIORITY_MAX 32</span><br><br><span class=\"hljs-comment\">/* 定义时钟节拍，为 100 时表示 100 个 tick 每秒，一个 tick 为 10ms */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> RT_TICK_PER_SECOND 100</span><br><br><span class=\"hljs-comment\">/* 检查栈是否溢出，未定义则关闭 */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> RT_USING_OVERFLOW_CHECK</span><br><br><span class=\"hljs-comment\">/* 定义该宏开启 debug 模式，未定义则关闭 */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> RT_DEBUG</span><br><span class=\"hljs-comment\">/* 开启 debug 模式时：该宏定义为 0 时表示关闭打印组件初始化信息，定义为 1 时表示启用 */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> RT_DEBUG_INIT 0</span><br><span class=\"hljs-comment\">/* 开启 debug 模式时：该宏定义为 0 时表示关闭打印线程切换信息，定义为 1 时表示启用 */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> RT_DEBUG_THREAD 0</span><br><br><span class=\"hljs-comment\">/* 定义该宏表示开启钩子函数的使用，未定义则关闭 */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> RT_USING_HOOK</span><br><br><span class=\"hljs-comment\">/* 定义了空闲线程的栈大小 */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> IDLE_THREAD_STACK_SIZE 256</span><br></code></pre></td></tr></table></figure>\n\n<p>（2）线程间同步与通信部分，该部分会使用到的对象有信号量、互斥量、事件、邮箱、消息队列、信号等。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/* 定义该宏可开启信号量的使用，未定义则关闭 */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> RT_USING_SEMAPHORE</span><br><br><span class=\"hljs-comment\">/* 定义该宏可开启互斥量的使用，未定义则关闭 */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> RT_USING_MUTEX</span><br><br><span class=\"hljs-comment\">/* 定义该宏可开启事件集的使用，未定义则关闭 */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> RT_USING_EVENT</span><br><br><span class=\"hljs-comment\">/* 定义该宏可开启邮箱的使用，未定义则关闭 */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> RT_USING_MAILBOX</span><br><br><span class=\"hljs-comment\">/* 定义该宏可开启消息队列的使用，未定义则关闭 */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> RT_USING_MESSAGEQUEUE</span><br><br><span class=\"hljs-comment\">/* 定义该宏可开启信号的使用，未定义则关闭 */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> RT_USING_SIGNALS</span><br></code></pre></td></tr></table></figure>\n\n<p>（3）内存管理部分</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/* 开启静态内存池的使用 */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> RT_USING_MEMPOOL</span><br><br><span class=\"hljs-comment\">/* 定义该宏可开启两个或以上内存堆拼接的使用，未定义则关闭 */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> RT_USING_MEMHEAP</span><br><br><span class=\"hljs-comment\">/* 开启小内存管理算法 */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> RT_USING_SMALL_MEM</span><br><br><span class=\"hljs-comment\">/* 关闭 SLAB 内存管理算法 */</span><br><span class=\"hljs-comment\">/* #define RT_USING_SLAB */</span><br><br><span class=\"hljs-comment\">/* 开启堆的使用 */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> RT_USING_HEAP</span><br></code></pre></td></tr></table></figure>\n\n<p>（4）内核设备对象</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/* 表示开启了系统设备的使用 */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> RT_USING_DEVICE</span><br><br><span class=\"hljs-comment\">/* 定义该宏可开启系统控制台设备的使用，未定义则关闭 */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> RT_USING_CONSOLE</span><br><span class=\"hljs-comment\">/* 定义控制台设备的缓冲区大小 */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> RT_CONSOLEBUF_SIZE 128</span><br><span class=\"hljs-comment\">/* 控制台设备的名称 */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> RT_CONSOLE_DEVICE_NAME <span class=\"hljs-string\">&quot;uart1&quot;</span></span><br></code></pre></td></tr></table></figure>\n\n<p>（5）自动初始化方式</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/* 定义该宏开启自动初始化机制，未定义则关闭 */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> RT_USING_COMPONENTS_INIT</span><br><br><span class=\"hljs-comment\">/* 定义该宏开启设置应用入口为 main 函数 */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> RT_USING_USER_MAIN</span><br><span class=\"hljs-comment\">/* 定义 main 线程的栈大小 */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> RT_MAIN_THREAD_STACK_SIZE 2048</span><br></code></pre></td></tr></table></figure>\n\n<p>（6）FinSH</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/* 定义该宏可开启系统 FinSH 调试工具的使用，未定义则关闭 */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> RT_USING_FINSH</span><br><br><span class=\"hljs-comment\">/* 开启系统 FinSH 时：将该线程名称定义为 tshell */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> FINSH_THREAD_NAME <span class=\"hljs-string\">&quot;tshell&quot;</span></span><br><br><span class=\"hljs-comment\">/* 开启系统 FinSH 时：使用历史命令 */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> FINSH_USING_HISTORY</span><br><span class=\"hljs-comment\">/* 开启系统 FinSH 时：对历史命令行数的定义 */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> FINSH_HISTORY_LINES 5</span><br><br><span class=\"hljs-comment\">/* 开启系统 FinSH 时：定义该宏开启使用 Tab 键，未定义则关闭 */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> FINSH_USING_SYMTAB</span><br><br><span class=\"hljs-comment\">/* 开启系统 FinSH 时：定义该线程的优先级 */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> FINSH_THREAD_PRIORITY 20</span><br><span class=\"hljs-comment\">/* 开启系统 FinSH 时：定义该线程的栈大小 */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> FINSH_THREAD_STACK_SIZE 4096</span><br><span class=\"hljs-comment\">/* 开启系统 FinSH 时：定义命令字符长度 */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> FINSH_CMD_SIZE 80</span><br><br><span class=\"hljs-comment\">/* 开启系统 FinSH 时：定义该宏开启 MSH 功能 */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> FINSH_USING_MSH</span><br><span class=\"hljs-comment\">/* 开启系统 FinSH 时：开启 MSH 功能时，定义该宏默认使用 MSH 功能 */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> FINSH_USING_MSH_DEFAULT</span><br><span class=\"hljs-comment\">/* 开启系统 FinSH 时：定义该宏，仅使用 MSH 功能 */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> FINSH_USING_MSH_ONLY</span><br></code></pre></td></tr></table></figure>\n\n<p>（7）关于 MCU</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/* 定义该工程使用的 MCU 为 STM32F103ZE；系统通过对芯片类型的定义，来定义芯片的管脚 */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> STM32F103ZE</span><br><br><span class=\"hljs-comment\">/* 定义时钟源频率 */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> RT_HSE_VALUE 8000000</span><br><br><span class=\"hljs-comment\">/* 定义该宏开启 UART1 的使用 */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> RT_USING_UART1</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"常见宏定义说明\"><a href=\"#常见宏定义说明\" class=\"headerlink\" title=\"常见宏定义说明\"></a>常见宏定义说明</h2><p>1）rt_inline，定义如下，static 关键字的作用是令函数只能在当前的文件中使用；inline 表示内联，用 static 修饰后在调用函数时会建议编译器进行内联展开。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> rt_inline                   static __inline</span><br></code></pre></td></tr></table></figure>\n\n<p>2）RT_USED，定义如下，该宏的作用是向编译器说明这段代码有用，即使函数中没有调用也要保留编译。例如 RT-Thread 自动初始化功能使用了自定义的段，使用 RT_USED 会将自定义的代码段保留。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> RT_USED                     __attribute__((used))</span><br></code></pre></td></tr></table></figure>\n\n<p>3）RT_UNUSED，定义如下，表示函数或变量可能不使用，这个属性可以避免编译器产生警告信息。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> RT_UNUSED                   __attribute__((unused))</span><br></code></pre></td></tr></table></figure>\n\n<p>4）RT_WEAK，定义如下，常用于定义函数，编译器在链接函数时会优先链接没有该关键字前缀的函数，如果找不到则再链接由 weak 修饰的函数。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> RT_WEAK                     __weak</span><br></code></pre></td></tr></table></figure>\n\n<p>5）ALIGN(n)，定义如下，作用是在给某对象分配地址空间时，将其存放的地址按照 n 字节对齐，这里 n 可取 2 的幂次方。字节对齐的作用不仅是便于 CPU 快速访问，同时合理的利用字节对齐可以有效地节省存储空间。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> ALIGN(n)                    __attribute__((aligned(n)))</span><br></code></pre></td></tr></table></figure>\n\n<p>6）RT_ALIGN(size,align)，定义如下，作用是将 size 提升为 align 定义的整数的倍数，例如，RT_ALIGN(13,4) 将返回 16。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> RT_ALIGN(size, align)      (((size) + (align) - 1) &amp; ~((align) - 1))</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"线程管理\"><a href=\"#线程管理\" class=\"headerlink\" title=\"线程管理\"></a>线程管理</h1><h2 id=\"线程状态\"><a href=\"#线程状态\" class=\"headerlink\" title=\"线程状态\"></a>线程状态</h2><table>\n<thead>\n<tr>\n<th><strong>状态</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>初始状态</td>\n<td>当线程刚开始创建还没开始运行时就处于初始状态；<br/>在初始状态下，线程不参与调度。<br/>此状态在 RT-Thread 中的宏定义为 RT_THREAD_INIT</td>\n</tr>\n<tr>\n<td>就绪状态</td>\n<td>在就绪状态下，线程按照优先级排队，等待被执行；<br/>一旦当前线程运行完毕让出处理器，操作系统会马上寻找最高优先级的就绪态线程运行。<br/>此状态在 RT-Thread 中的宏定义为 RT_THREAD_READY</td>\n</tr>\n<tr>\n<td>运行状态</td>\n<td>线程当前正在运行。在单核系统中，只有 rt_thread_self() 函数返回的线程处于运行状态；<br/>在多核系统中，可能就不止这一个线程处于运行状态。<br/>此状态在 RT-Thread 中的宏定义为 RT_THREAD_RUNNING</td>\n</tr>\n<tr>\n<td>挂起状态</td>\n<td>也称阻塞态。它可能因为资源不可用而挂起等待，或线程主动延时一段时间而挂起。<br/>在挂起状态下，线程不参与调度。<br/>此状态在 RT-Thread 中的宏定义为 RT_THREAD_SUSPEND</td>\n</tr>\n<tr>\n<td>关闭状态</td>\n<td>当线程运行结束时将处于关闭状态。<br/>关闭状态的线程不参与线程的调度。<br/>此状态在 RT-Thread 中的宏定义为 RT_THREAD_CLOSE</td>\n</tr>\n</tbody></table>\n<h2 id=\"线程状态的切换\"><a href=\"#线程状态的切换\" class=\"headerlink\" title=\"线程状态的切换\"></a>线程状态的切换</h2><p><img src=\"/2021/42e53028/04thread_sta.png\" alt=\"线程状态转换图\"></p>\n<h2 id=\"线程的管理API\"><a href=\"#线程的管理API\" class=\"headerlink\" title=\"线程的管理API\"></a>线程的管理API</h2><p><img src=\"/2021/42e53028/04thread_ops.png\" alt=\"线程相关操作\"></p>\n<h3 id=\"创建删除-create\"><a href=\"#创建删除-create\" class=\"headerlink\" title=\"创建删除-create\"></a>创建删除-create</h3><p>系统会从动态堆内存中分配一个线程句柄以及按照参数中指定的栈大小从动态堆内存中分配相应的空间。分配出来的栈空间是按照 rtconfig.h 中配置的 <strong>RT_ALIGN_SIZE</strong> 方式对齐</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_thread_t</span> <span class=\"hljs-title function_\">rt_thread_create</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name,</span><br><span class=\"hljs-params\">                            <span class=\"hljs-type\">void</span> (*entry)(<span class=\"hljs-type\">void</span>* parameter),</span><br><span class=\"hljs-params\">                            <span class=\"hljs-type\">void</span>* parameter,</span><br><span class=\"hljs-params\">                            <span class=\"hljs-type\">rt_uint32_t</span> stack_size,</span><br><span class=\"hljs-params\">                            <span class=\"hljs-type\">rt_uint8_t</span> priority,</span><br><span class=\"hljs-params\">                            <span class=\"hljs-type\">rt_uint32_t</span> tick)</span>;<br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>name</td>\n<td>线程的名称；<br/>线程名称的最大长度由 rtconfig.h 中的宏 RT_NAME_MAX 指定，多余部分会被自动截掉</td>\n</tr>\n<tr>\n<td>entry</td>\n<td>线程入口函数</td>\n</tr>\n<tr>\n<td>parameter</td>\n<td>线程入口函数参数</td>\n</tr>\n<tr>\n<td>stack_size</td>\n<td>线程栈大小，单位是字节</td>\n</tr>\n<tr>\n<td>priority</td>\n<td>线程的优先级。<br/>优先级范围根据系统配置情况（rtconfig.h 中的 RT_THREAD_PRIORITY_MAX 宏定义），如果支持的是 256 级优先级，那么范围是从 0~255，数值越小优先级越高，0 代表最高优先级</td>\n</tr>\n<tr>\n<td>tick</td>\n<td>线程的时间片大小。<br/>时间片（tick）的单位是操作系统的时钟节拍。当系统中存在相同优先级线程时，这个参数指定线程一次调度能够运行的最大时间长度。这个时间片运行结束时，调度器自动选择下一个就绪态的同优先级线程进行运行</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>thread</td>\n<td>线程创建成功，返回线程句柄</td>\n</tr>\n<tr>\n<td>RT_NULL</td>\n<td>线程创建失败</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_err_t</span> <span class=\"hljs-title function_\">rt_thread_delete</span><span class=\"hljs-params\">(<span class=\"hljs-type\">rt_thread_t</span> thread)</span>;<br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>thread</td>\n<td>要删除的线程句柄</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>RT_EOK</td>\n<td>删除线程成功</td>\n</tr>\n<tr>\n<td>-RT_ERROR</td>\n<td>删除线程失败</td>\n</tr>\n</tbody></table>\n<h3 id=\"初始化和脱离-init\"><a href=\"#初始化和脱离-init\" class=\"headerlink\" title=\"初始化和脱离-init\"></a>初始化和脱离-init</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_err_t</span> <span class=\"hljs-title function_\">rt_thread_init</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> rt_thread* thread,</span><br><span class=\"hljs-params\">                        <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name,</span><br><span class=\"hljs-params\">                        <span class=\"hljs-type\">void</span> (*entry)(<span class=\"hljs-type\">void</span>* parameter), <span class=\"hljs-type\">void</span>* parameter,</span><br><span class=\"hljs-params\">                        <span class=\"hljs-type\">void</span>* stack_start, <span class=\"hljs-type\">rt_uint32_t</span> stack_size,</span><br><span class=\"hljs-params\">                        <span class=\"hljs-type\">rt_uint8_t</span> priority, <span class=\"hljs-type\">rt_uint32_t</span> tick)</span>;<br></code></pre></td></tr></table></figure>\n\n<p>静态线程的线程句柄（或者说线程控制块指针）、线程栈由用户提供。静态线程是指线程控制块、线程运行栈一般都设置为全局变量，在编译时就被确定、被分配处理，内核不负责动态分配内存空间。需要注意的是，用户提供的栈首地址需做<strong>系统对齐</strong>（例如 ARM 上需要做 4 字节对齐）。</p>\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>thread</td>\n<td>线程句柄。线程句柄由用户提供出来，并指向对应的线程控制块内存地址</td>\n</tr>\n<tr>\n<td>name</td>\n<td>线程的名称；线程名称的最大长度由 rtconfig.h 中定义的 RT_NAME_MAX 宏指定，多余部分会被自动截掉</td>\n</tr>\n<tr>\n<td>entry</td>\n<td>线程入口函数</td>\n</tr>\n<tr>\n<td>parameter</td>\n<td>线程入口函数参数</td>\n</tr>\n<tr>\n<td>stack_start</td>\n<td>线程栈起始地址</td>\n</tr>\n<tr>\n<td>stack_size</td>\n<td>线程栈大小，单位是字节。在大多数系统中需要做栈空间地址对齐（例如 ARM 体系结构中需要向 4 字节地址对齐）</td>\n</tr>\n<tr>\n<td>priority</td>\n<td>线程的优先级。优先级范围根据系统配置情况（rtconfig.h 中的 RT_THREAD_PRIORITY_MAX 宏定义），如果支持的是 256 级优先级，那么范围是从 0 ～ 255，数值越小优先级越高，0 代表最高优先级</td>\n</tr>\n<tr>\n<td>tick</td>\n<td>线程的时间片大小。时间片（tick）的单位是操作系统的时钟节拍。当系统中存在相同优先级线程时，这个参数指定线程一次调度能够运行的最大时间长度。这个时间片运行结束时，调度器自动选择下一个就绪态的同优先级线程进行运行</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>RT_EOK</td>\n<td>线程创建成功</td>\n</tr>\n<tr>\n<td>-RT_ERROR</td>\n<td>线程创建失败</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_err_t</span> <span class=\"hljs-title function_\">rt_thread_detach</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">rt_thread_t</span> thread)</span>;<br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>thread</td>\n<td>线程句柄，它应该是由 rt_thread_init 进行初始化的线程句柄。</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>RT_EOK</td>\n<td>线程脱离成功</td>\n</tr>\n<tr>\n<td>-RT_ERROR</td>\n<td>线程脱离失败</td>\n</tr>\n</tbody></table>\n<h3 id=\"线程启动-startup\"><a href=\"#线程启动-startup\" class=\"headerlink\" title=\"线程启动-startup\"></a>线程启动-startup</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_err_t</span> <span class=\"hljs-title function_\">rt_thread_startup</span><span class=\"hljs-params\">(<span class=\"hljs-type\">rt_thread_t</span> thread)</span>;<br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>thread</td>\n<td>线程句柄</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>RT_EOK</td>\n<td>线程启动成功</td>\n</tr>\n<tr>\n<td>-RT_ERROR</td>\n<td>线程起动失败</td>\n</tr>\n</tbody></table>\n<h3 id=\"获取当前线程-self\"><a href=\"#获取当前线程-self\" class=\"headerlink\" title=\"获取当前线程-self\"></a>获取当前线程-self</h3><p>在程序的运行过程中，相同的一段代码可能会被多个线程执行，在执行的时候可以通过下面的函数接口获得当前执行的线程句柄：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_thread_t</span> <span class=\"hljs-title function_\">rt_thread_self</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span>;<br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>返回</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>thread</td>\n<td>当前运行的线程句柄</td>\n</tr>\n<tr>\n<td>RT_NULL</td>\n<td>失败，调度器还未启动</td>\n</tr>\n</tbody></table>\n<h3 id=\"使线程让出处理器资源-yield\"><a href=\"#使线程让出处理器资源-yield\" class=\"headerlink\" title=\"使线程让出处理器资源-yield\"></a>使线程让出处理器资源-yield</h3><p>（如果当前优先级只有这一个线程，则这个线程继续执行，不进行上下文切换动作）。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_err_t</span> <span class=\"hljs-title function_\">rt_thread_yield</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span>;<br></code></pre></td></tr></table></figure>\n\n<p>rt_thread_yield() 和 rt_schedule() 比较相像，有相同优先级的其他就绪态线程存在时其行为<strong>有所差异</strong>。</p>\n<h3 id=\"使线程睡眠-延时-sleep\"><a href=\"#使线程睡眠-延时-sleep\" class=\"headerlink\" title=\"使线程睡眠(延时)-sleep\"></a>使线程睡眠(延时)-sleep</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_err_t</span> <span class=\"hljs-title function_\">rt_thread_sleep</span><span class=\"hljs-params\">(<span class=\"hljs-type\">rt_tick_t</span> tick)</span>;<br><span class=\"hljs-type\">rt_err_t</span> <span class=\"hljs-title function_\">rt_thread_delay</span><span class=\"hljs-params\">(<span class=\"hljs-type\">rt_tick_t</span> tick)</span>;<br><span class=\"hljs-type\">rt_err_t</span> <span class=\"hljs-title function_\">rt_thread_mdelay</span><span class=\"hljs-params\">(<span class=\"hljs-type\">rt_int32_t</span> ms)</span>;<br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>tick&#x2F;ms</td>\n<td>线程睡眠的时间： sleep&#x2F;delay 的传入参数 tick 以 1 个 OS Tick 为单位 ； mdelay 的传入参数 ms 以 1ms 为单位；</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>RT_EOK</td>\n<td>操作成功</td>\n</tr>\n</tbody></table>\n<h3 id=\"挂起和恢复线程-suspend\"><a href=\"#挂起和恢复线程-suspend\" class=\"headerlink\" title=\"挂起和恢复线程-suspend\"></a>挂起和恢复线程-suspend</h3><blockquote>\n<p>通常不应该使用这个函数来挂起线程本身，如果确实需要采用 rt_thread_suspend() 函数挂起当前任务，需要在调用 rt_thread_suspend() 函数后立刻调用 rt_schedule() 函数进行手动的线程上下文切换。用户只需要了解该接口的作用，不推荐使用该接口。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_err_t</span> <span class=\"hljs-title function_\">rt_thread_suspend</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">rt_thread_t</span> thread)</span>;<br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>thread</td>\n<td>线程句柄</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>RT_EOK</td>\n<td>线程挂起成功</td>\n</tr>\n<tr>\n<td>-RT_ERROR</td>\n<td>线程挂起失败，因为该线程的状态并不是就绪状态</td>\n</tr>\n</tbody></table>\n<p>恢复线程就是让挂起的线程重新进入就绪状态，并将线程放入系统的就绪队列中；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_err_t</span> <span class=\"hljs-title function_\">rt_thread_resume</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">rt_thread_t</span> thread)</span>;<br></code></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>thread</td>\n<td>线程句柄</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>RT_EOK</td>\n<td>线程恢复成功</td>\n</tr>\n<tr>\n<td>-RT_ERROR</td>\n<td>线程恢复失败，因为该个线程的状态并不是 RT_THREAD_SUSPEND 状态</td>\n</tr>\n</tbody></table>\n<h3 id=\"控制线程-control\"><a href=\"#控制线程-control\" class=\"headerlink\" title=\"控制线程-control\"></a>控制线程-control</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_err_t</span> <span class=\"hljs-title function_\">rt_thread_control</span><span class=\"hljs-params\">(<span class=\"hljs-type\">rt_thread_t</span> thread, <span class=\"hljs-type\">rt_uint8_t</span> cmd, <span class=\"hljs-type\">void</span>* arg)</span>;<br></code></pre></td></tr></table></figure>\n\n<p>线程控制接口 rt_thread_control() 的参数和返回值见下表：</p>\n<table>\n<thead>\n<tr>\n<th><strong>函数参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>thread</td>\n<td>线程句柄</td>\n</tr>\n<tr>\n<td>cmd</td>\n<td>指示控制命令</td>\n</tr>\n<tr>\n<td>arg</td>\n<td>控制参数</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>RT_EOK</td>\n<td>控制执行正确</td>\n</tr>\n<tr>\n<td>-RT_ERROR</td>\n<td>失败</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>指示控制命令 cmd 当前支持的命令包括：</p>\n<p>RT_THREAD_CTRL_CHANGE_PRIORITY：动态更改线程的优先级；</p>\n<p>RT_THREAD_CTRL_STARTUP：开始运行一个线程，等同于 rt_thread_startup() 函数调用；</p>\n<p>RT_THREAD_CTRL_CLOSE：关闭一个线程，等同于 rt_thread_delete() 函数调用。</p>\n</blockquote>\n<h3 id=\"设置和删除空闲钩子-idle\"><a href=\"#设置和删除空闲钩子-idle\" class=\"headerlink\" title=\"设置和删除空闲钩子-idle\"></a>设置和删除空闲钩子-idle</h3><p>空闲钩子函数是空闲线程的钩子函数，如果设置了空闲钩子函数，就可以在系统执行空闲线程时，自动执行空闲钩子函数来做一些其他事情，比如系统指示灯。<strong>钩子函数必须保证空闲线程在任何时刻都不会处于挂起状态。</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_err_t</span> <span class=\"hljs-title function_\">rt_thread_idle_sethook</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span> (*hook)(<span class=\"hljs-type\">void</span>))</span>;<br><span class=\"hljs-type\">rt_err_t</span> <span class=\"hljs-title function_\">rt_thread_idle_delhook</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span> (*hook)(<span class=\"hljs-type\">void</span>))</span>;<br></code></pre></td></tr></table></figure>\n\n<p>设置空闲钩子函数 rt_thread_idle_sethook() </p>\n<table>\n<thead>\n<tr>\n<th><strong>函数参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>hook</td>\n<td>设置的钩子函数</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>RT_EOK</td>\n<td>设置成功</td>\n</tr>\n<tr>\n<td>-RT_EFULL</td>\n<td>设置失败</td>\n</tr>\n</tbody></table>\n<p>删除空闲钩子函数 rt_thread_idle_delhook() </p>\n<table>\n<thead>\n<tr>\n<th><strong>函数参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>hook</td>\n<td>删除的钩子函数</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>RT_EOK</td>\n<td>删除成功</td>\n</tr>\n<tr>\n<td>-RT_ENOSYS</td>\n<td>删除失败</td>\n</tr>\n</tbody></table>\n<h3 id=\"设置调度器钩子-scheduler\"><a href=\"#设置调度器钩子-scheduler\" class=\"headerlink\" title=\"设置调度器钩子-scheduler\"></a>设置调度器钩子-scheduler</h3><p>有时用户可能会想知道在一个时刻发生了什么样的线程切换，可以通过调用下面的函数接口设置一个相应的钩子函数。在系统线程切换时，这个钩子函数将被调用：<strong>请仔细编写你的钩子函数，稍有不慎将很可能导致整个系统运行不正常（在这个钩子函数中，基本上不允许调用系统 API，更不应该导致当前运行的上下文挂起）。</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">rt_scheduler_sethook</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span> (*hook)(<span class=\"hljs-keyword\">struct</span> rt_thread* from, <span class=\"hljs-keyword\">struct</span> rt_thread* to))</span>;<br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>函数参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>hook</td>\n<td>表示用户定义的钩子函数指针</td>\n</tr>\n</tbody></table>\n<p>钩子函数 hook() 的声明如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">hook</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> rt_thread* from, <span class=\"hljs-keyword\">struct</span> rt_thread* to)</span>;<br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>函数参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>from</td>\n<td>表示系统所要切换出的线程控制块指针</td>\n</tr>\n<tr>\n<td>to</td>\n<td>表示系统所要切换到的线程控制块指针</td>\n</tr>\n</tbody></table>\n<h2 id=\"API应用示例\"><a href=\"#API应用示例\" class=\"headerlink\" title=\"API应用示例\"></a>API应用示例</h2><p>线程 2 计数到一定值会执行完毕，线程 2 被系统自动删除，计数停止。线程 1 一直打印计数。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;rtthread.h&gt;</span></span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> THREAD_PRIORITY         25</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> THREAD_STACK_SIZE       512</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> THREAD_TIMESLICE        5</span><br><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">rt_thread_t</span> tid1 = RT_NULL;<br><br><span class=\"hljs-comment\">/* 线程 1 的入口函数 */</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">thread1_entry</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span> *parameter)</span><br>&#123;<br>    <span class=\"hljs-type\">rt_uint32_t</span> count = <span class=\"hljs-number\">0</span>;<br><br>    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-number\">1</span>)<br>    &#123;<br>        <span class=\"hljs-comment\">/* 线程 1 采用低优先级运行，一直打印计数值 */</span><br>        rt_kprintf(<span class=\"hljs-string\">&quot;thread1 count: %d\\n&quot;</span>, count ++);<br>        rt_thread_mdelay(<span class=\"hljs-number\">500</span>);<br>    &#125;<br>&#125;<br><br>ALIGN(RT_ALIGN_SIZE)<br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">char</span> thread2_stack[<span class=\"hljs-number\">1024</span>];<br><span class=\"hljs-type\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">rt_thread</span> <span class=\"hljs-title\">thread2</span>;</span><br><span class=\"hljs-comment\">/* 线程 2 入口 */</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">thread2_entry</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span> *param)</span><br>&#123;<br>    <span class=\"hljs-type\">rt_uint32_t</span> count = <span class=\"hljs-number\">0</span>;<br><br>    <span class=\"hljs-comment\">/* 线程 2 拥有较高的优先级，以抢占线程 1 而获得执行 */</span><br>    <span class=\"hljs-keyword\">for</span> (count = <span class=\"hljs-number\">0</span>; count &lt; <span class=\"hljs-number\">10</span> ; count++)<br>    &#123;<br>        <span class=\"hljs-comment\">/* 线程 2 打印计数值 */</span><br>        rt_kprintf(<span class=\"hljs-string\">&quot;thread2 count: %d\\n&quot;</span>, count);<br>    &#125;<br>    rt_kprintf(<span class=\"hljs-string\">&quot;thread2 exit\\n&quot;</span>);<br>    <span class=\"hljs-comment\">/* 线程 2 运行结束后也将自动被系统脱离 */</span><br>&#125;<br><br><span class=\"hljs-comment\">/* 线程示例 */</span><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">thread_sample</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>    <span class=\"hljs-comment\">/* 创建线程 1，名称是 thread1，入口是 thread1_entry*/</span><br>    tid1 = rt_thread_create(<span class=\"hljs-string\">&quot;thread1&quot;</span>,<br>                            thread1_entry, RT_NULL,<br>                            THREAD_STACK_SIZE,<br>                            THREAD_PRIORITY, THREAD_TIMESLICE);<br><br>    <span class=\"hljs-comment\">/* 如果获得线程控制块，启动这个线程 */</span><br>    <span class=\"hljs-keyword\">if</span> (tid1 != RT_NULL)<br>        rt_thread_startup(tid1);<br><br>    <span class=\"hljs-comment\">/* 初始化线程 2，名称是 thread2，入口是 thread2_entry */</span><br>    rt_thread_init(&amp;thread2,<br>                   <span class=\"hljs-string\">&quot;thread2&quot;</span>,<br>                   thread2_entry,<br>                   RT_NULL,<br>                   &amp;thread2_stack[<span class=\"hljs-number\">0</span>],<br>                   <span class=\"hljs-keyword\">sizeof</span>(thread2_stack),<br>                   THREAD_PRIORITY - <span class=\"hljs-number\">1</span>, THREAD_TIMESLICE);<br>    rt_thread_startup(&amp;thread2);<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br><span class=\"hljs-comment\">/* 导出到 msh 命令列表中 */</span><br>MSH_CMD_EXPORT(thread_sample, thread sample);<br></code></pre></td></tr></table></figure>\n\n<p>仿真运行结果如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">\\ | /<br>- RT -     Thread Operating System<br> / | \\     <span class=\"hljs-number\">3.1</span><span class=\"hljs-number\">.0</span> build Aug <span class=\"hljs-number\">24</span> <span class=\"hljs-number\">2018</span><br> <span class=\"hljs-number\">2006</span> - <span class=\"hljs-number\">2018</span> Copyright by rt-thread team<br>msh &gt;thread_sample<br>msh &gt;thread2 count: <span class=\"hljs-number\">0</span><br>thread2 count: <span class=\"hljs-number\">1</span><br>thread2 count: <span class=\"hljs-number\">2</span><br>thread2 count: <span class=\"hljs-number\">3</span><br>thread2 count: <span class=\"hljs-number\">4</span><br>thread2 count: <span class=\"hljs-number\">5</span><br>thread2 count: <span class=\"hljs-number\">6</span><br>thread2 count: <span class=\"hljs-number\">7</span><br>thread2 count: <span class=\"hljs-number\">8</span><br>thread2 count: <span class=\"hljs-number\">9</span><br>thread2 <span class=\"hljs-built_in\">exit</span><br>thread1 count: <span class=\"hljs-number\">0</span><br>thread1 count: <span class=\"hljs-number\">1</span><br>thread1 count: <span class=\"hljs-number\">2</span><br>thread1 count: <span class=\"hljs-number\">3</span><br>…<br></code></pre></td></tr></table></figure>\n\n\n<h2 id=\"笔记\"><a href=\"#笔记\" class=\"headerlink\" title=\"笔记\"></a>笔记</h2><ul>\n<li>若某线程运行完毕，系统将自动删除线程：自动执行 rt_thread_exit() 函数，先将该线程从系统就绪队列中删除，再将该线程的状态更改为关闭状态，不再参与系统调度，然后挂入 rt_thread_defunct 僵尸队列（资源未回收、处于关闭状态的线程队列）中，最后空闲线程会回收被删除线程的资源。</li>\n<li></li>\n</ul>\n<h1 id=\"时钟管理\"><a href=\"#时钟管理\" class=\"headerlink\" title=\"时钟管理\"></a>时钟管理</h1><h2 id=\"获取时钟节拍API\"><a href=\"#获取时钟节拍API\" class=\"headerlink\" title=\"获取时钟节拍API\"></a>获取时钟节拍API</h2><p>由于全局变量 rt_tick 在每经过一个时钟节拍时，值就会加 1，通过调用 rt_tick_get 会返回当前 rt_tick 的值，即可以获取到当前的时钟节拍值。此接口可用于记录系统的运行时间长短，或者测量某任务运行的时间。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_tick_t</span> <span class=\"hljs-title function_\">rt_tick_get</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span>;<br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>返回</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>rt_tick</td>\n<td>当前时钟节拍值</td>\n</tr>\n</tbody></table>\n<h2 id=\"软件定时器管理\"><a href=\"#软件定时器管理\" class=\"headerlink\" title=\"软件定时器管理\"></a>软件定时器管理</h2><p>RT-Thread 操作系统提供软件实现的定时器，以时钟节拍（OS Tick）的时间长度为单位，即定时数值必须是 OS Tick 的整数倍。它构建在硬件定时器基础之上，使系统能够提供不受数目限制的定时器服务。</p>\n<p>RT-Thread 的定时器提供两类定时器机制：</p>\n<ul>\n<li>第一类是单次触发定时器，这类定时器在启动后只会触发一次定时器事件，然后定时器自动停止。</li>\n<li>第二类是周期触发定时器，这类定时器会周期性的触发定时器事件，直到用户手动的停止，否则将永远持续执行下去。</li>\n</ul>\n<p>另外，根据超时函数执行时所处的上下文环境，RT-Thread 的定时器可以分为 <strong>HARD_TIMER</strong> 模式与 <strong>SOFT_TIMER</strong> 模式，如下图。使用<strong>RT_TIMER_FLAG_HARD_TIMER</strong> 和 **RT_TIMER_FLAG_SOFT_TIMER ** 来决定使用的模式</p>\n<p><img src=\"/2021/42e53028/05timer_env.png\" alt=\"定时器上下文环境\"></p>\n<p>系统新创建并激活的定时器都会按照以超时时间排序的方式插入到 rt_timer_list 链表中。</p>\n<p><img src=\"/2021/42e53028/05timer_linked_list.png\" alt=\"定时器链表示意图\"></p>\n<p>rt_tick(当前系统tick) 从 20 增长到 70，与 Timer1 的 timeout 值相等，这时会触发与 Timer1 定时器相关联的超时函数，同时将 Timer1 从 rt_timer_list 链表上删除。</p>\n<p>如果系统当前定时器状态在 10 个 tick 以后（rt_tick&#x3D;30）有一个任务新创建了一个 tick 值为 300 的 Timer4 定时器，由于 Timer4 定时器的 timeout&#x3D;rt_tick+300&#x3D;330, 因此它将被插入到 Timer2 和 Timer3 定时器中间如下图,所示：</p>\n<p><img src=\"/2021/42e53028/05timer_linked_list2.png\" alt=\"定时器链表插入示意图\"></p>\n<h2 id=\"定时器API\"><a href=\"#定时器API\" class=\"headerlink\" title=\"定时器API\"></a>定时器API</h2><p><img src=\"/2021/42e53028/05timer_ops.png\" alt=\"定时器相关操作\"></p>\n<p>在系统启动时需要初始化定时器管理系统。可以通过下面的函数接口完成：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">rt_system_timer_init</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span>;<br></code></pre></td></tr></table></figure>\n\n<p>如果需要使用 SOFT_TIMER，则系统初始化时，应该调用下面这个函数接口：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">rt_system_timer_thread_init</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span>;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"创建和删除-create\"><a href=\"#创建和删除-create\" class=\"headerlink\" title=\"创建和删除-create\"></a>创建和删除-create</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_timer_t</span> <span class=\"hljs-title function_\">rt_timer_create</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name,</span><br><span class=\"hljs-params\">                           <span class=\"hljs-type\">void</span> (*timeout)(<span class=\"hljs-type\">void</span>* parameter),</span><br><span class=\"hljs-params\">                           <span class=\"hljs-type\">void</span>* parameter,</span><br><span class=\"hljs-params\">                           <span class=\"hljs-type\">rt_tick_t</span> time,</span><br><span class=\"hljs-params\">                           <span class=\"hljs-type\">rt_uint8_t</span> flag)</span>;<br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>name</td>\n<td>定时器的名称</td>\n</tr>\n<tr>\n<td>void (timeout) (void parameter)</td>\n<td>定时器超时函数指针（当定时器超时时，系统会调用这个函数）</td>\n</tr>\n<tr>\n<td>parameter</td>\n<td>定时器超时函数的入口参数（当定时器超时时，调用超时回调函数会把这个参数做为入口参数传递给超时函数）</td>\n</tr>\n<tr>\n<td>time</td>\n<td>定时器的超时时间，单位是时钟节拍</td>\n</tr>\n<tr>\n<td>flag</td>\n<td>定时器创建时的参数，支持的值包括单次定时、周期定时、硬件定时器、软件定时器等（可以用 “或” 关系取多个值）</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>RT_NULL</td>\n<td>创建失败（通常会由于系统内存不够用而返回 RT_NULL）</td>\n</tr>\n<tr>\n<td>定时器的句柄</td>\n<td>定时器创建成功</td>\n</tr>\n</tbody></table>\n<p>如下2 组值可以以 “或” 逻辑的方式赋给 flag。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> RT_TIMER_FLAG_ONE_SHOT      0x0     <span class=\"hljs-comment\">/* 单次定时     */</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> RT_TIMER_FLAG_PERIODIC      0x2     <span class=\"hljs-comment\">/* 周期定时     */</span></span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> RT_TIMER_FLAG_HARD_TIMER    0x0     <span class=\"hljs-comment\">/* 时钟中断的服务例程上下文中被调用 */</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> RT_TIMER_FLAG_SOFT_TIMER    0x4     <span class=\"hljs-comment\">/* timer 线程的上下文中被调用 */</span></span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_err_t</span> <span class=\"hljs-title function_\">rt_timer_delete</span><span class=\"hljs-params\">(<span class=\"hljs-type\">rt_timer_t</span> timer)</span>;<br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>timer</td>\n<td>定时器句柄，指向要删除的定时器</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>RT_EOK</td>\n<td>删除成功（如果参数 timer 句柄是一个 RT_NULL，将会导致一个 ASSERT 断言）</td>\n</tr>\n</tbody></table>\n<h3 id=\"初始化和脱离定时器-init\"><a href=\"#初始化和脱离定时器-init\" class=\"headerlink\" title=\"初始化和脱离定时器-init\"></a>初始化和脱离定时器-init</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">rt_timer_init</span><span class=\"hljs-params\">(<span class=\"hljs-type\">rt_timer_t</span> timer,</span><br><span class=\"hljs-params\">                   <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name,</span><br><span class=\"hljs-params\">                   <span class=\"hljs-type\">void</span> (*timeout)(<span class=\"hljs-type\">void</span>* parameter),</span><br><span class=\"hljs-params\">                   <span class=\"hljs-type\">void</span>* parameter,</span><br><span class=\"hljs-params\">                   <span class=\"hljs-type\">rt_tick_t</span> time, <span class=\"hljs-type\">rt_uint8_t</span> flag)</span>;<br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>timer</td>\n<td>定时器句柄，指向要初始化的定时器控制块</td>\n</tr>\n<tr>\n<td>name</td>\n<td>定时器的名称</td>\n</tr>\n<tr>\n<td>void (timeout) (void parameter)</td>\n<td>定时器超时函数指针（当定时器超时时，系统会调用这个函数）</td>\n</tr>\n<tr>\n<td>parameter</td>\n<td>定时器超时函数的入口参数（当定时器超时时，调用超时回调函数会把这个参数做为入口参数传递给超时函数）</td>\n</tr>\n<tr>\n<td>time</td>\n<td>定时器的超时时间，单位是时钟节拍</td>\n</tr>\n<tr>\n<td>flag</td>\n<td>定时器创建时的参数，支持的值包括单次定时、周期定时、硬件定时器、软件定时器（可以用 “或” 关系取多个值），详见上面 <strong>创建和删除</strong></td>\n</tr>\n</tbody></table>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_err_t</span> <span class=\"hljs-title function_\">rt_timer_detach</span><span class=\"hljs-params\">(<span class=\"hljs-type\">rt_timer_t</span> timer)</span>;<br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>timer</td>\n<td>定时器句柄，指向要脱离的定时器控制块</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>RT_EOK</td>\n<td>脱离成功</td>\n</tr>\n</tbody></table>\n<h3 id=\"启动和停止定时器-start\"><a href=\"#启动和停止定时器-start\" class=\"headerlink\" title=\"启动和停止定时器-start\"></a>启动和停止定时器-start</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_err_t</span> <span class=\"hljs-title function_\">rt_timer_start</span><span class=\"hljs-params\">(<span class=\"hljs-type\">rt_timer_t</span> timer)</span>;<br></code></pre></td></tr></table></figure>\n\n<p>调用接口后，定时器的状态将更改为激活状态（RT_TIMER_FLAG_ACTIVATED），并按照超时顺序插入到 rt_timer_list 队列链表中。</p>\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>timer</td>\n<td>定时器句柄，指向要启动的定时器控制块</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>RT_EOK</td>\n<td>启动成功</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_err_t</span> <span class=\"hljs-title function_\">rt_timer_stop</span><span class=\"hljs-params\">(<span class=\"hljs-type\">rt_timer_t</span> timer)</span>;<br></code></pre></td></tr></table></figure>\n\n<p>当一个（周期性）定时器超时时，可以调用这个函数接口停止这个（周期性）定时器本身。</p>\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>timer</td>\n<td>定时器句柄，指向要停止的定时器控制块</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>RT_EOK</td>\n<td>成功停止定时器</td>\n</tr>\n<tr>\n<td>- RT_ERROR</td>\n<td>timer 已经处于停止状态</td>\n</tr>\n</tbody></table>\n<h3 id=\"控制定时器-control\"><a href=\"#控制定时器-control\" class=\"headerlink\" title=\"控制定时器-control\"></a>控制定时器-control</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_err_t</span> <span class=\"hljs-title function_\">rt_timer_control</span><span class=\"hljs-params\">(<span class=\"hljs-type\">rt_timer_t</span> timer, <span class=\"hljs-type\">rt_uint8_t</span> cmd, <span class=\"hljs-type\">void</span>* arg)</span>;<br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>timer</td>\n<td>定时器句柄，指向要停止的定时器控制块</td>\n</tr>\n<tr>\n<td>cmd</td>\n<td>用于控制定时器的命令，当前支持四个命令，分别是设置定时时间，查看定时时间，设置单次触发，设置周期触发</td>\n</tr>\n<tr>\n<td>arg</td>\n<td>与 cmd 相对应的控制命令参数 比如，cmd 为设定超时时间时，就可以将超时时间参数通过 arg 进行设定</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>RT_EOK</td>\n<td>成功</td>\n</tr>\n</tbody></table>\n<p>函数参数 cmd 支持的命令：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> RT_TIMER_CTRL_SET_TIME      0x0     <span class=\"hljs-comment\">/* 设置定时器超时时间       */</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> RT_TIMER_CTRL_GET_TIME      0x1     <span class=\"hljs-comment\">/* 获得定时器超时时间       */</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> RT_TIMER_CTRL_SET_ONESHOT   0x2     <span class=\"hljs-comment\">/* 设置定时器为单次定时器   */</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> RT_TIMER_CTRL_SET_PERIODIC  0x3     <span class=\"hljs-comment\">/* 设置定时器为周期型定时器 */</span></span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"API应用示例-1\"><a href=\"#API应用示例-1\" class=\"headerlink\" title=\"API应用示例\"></a>API应用示例</h2><p>这是一个创建定时器的例子，这个例程会创建两个动态定时器，一个是单次定时，一个是周期性定时并让周期定时器运行一段时间后停止运行，如下所示：周期性定时器 1 的超时函数，每 10 个 OS Tick 运行 1 次，共运行 10 次（10 次后调用 rt_timer_stop 使定时器 1 停止运行）；单次定时器 2 的超时函数在第 30 个 OS Tick 时运行一次。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;rtthread.h&gt;</span></span><br><br><span class=\"hljs-comment\">/* 定时器的控制块 */</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">rt_timer_t</span> timer1;<br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">rt_timer_t</span> timer2;<br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> cnt = <span class=\"hljs-number\">0</span>;<br><br><span class=\"hljs-comment\">/* 定时器 1 超时函数 */</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">timeout1</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span> *parameter)</span><br>&#123;<br>    rt_kprintf(<span class=\"hljs-string\">&quot;periodic timer is timeout %d\\n&quot;</span>, cnt);<br><br>    <span class=\"hljs-comment\">/* 运行第 10 次，停止周期定时器 */</span><br>    <span class=\"hljs-keyword\">if</span> (cnt++&gt;= <span class=\"hljs-number\">9</span>)<br>    &#123;<br>        rt_timer_stop(timer1);<br>        rt_kprintf(<span class=\"hljs-string\">&quot;periodic timer was stopped! \\n&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">/* 定时器 2 超时函数 */</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">timeout2</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span> *parameter)</span><br>&#123;<br>    rt_kprintf(<span class=\"hljs-string\">&quot;one shot timer is timeout\\n&quot;</span>);<br>&#125;<br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">timer_sample</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>    <span class=\"hljs-comment\">/* 创建定时器 1  周期定时器 */</span><br>    timer1 = rt_timer_create(<span class=\"hljs-string\">&quot;timer1&quot;</span>, timeout1,<br>                             RT_NULL, <span class=\"hljs-number\">10</span>,<br>                             RT_TIMER_FLAG_PERIODIC);<br><br>    <span class=\"hljs-comment\">/* 启动定时器 1 */</span><br>    <span class=\"hljs-keyword\">if</span> (timer1 != RT_NULL) rt_timer_start(timer1);<br><br>    <span class=\"hljs-comment\">/* 创建定时器 2 单次定时器 */</span><br>    timer2 = rt_timer_create(<span class=\"hljs-string\">&quot;timer2&quot;</span>, timeout2,<br>                             RT_NULL,  <span class=\"hljs-number\">30</span>,<br>                             RT_TIMER_FLAG_ONE_SHOT);<br><br>    <span class=\"hljs-comment\">/* 启动定时器 2 */</span><br>    <span class=\"hljs-keyword\">if</span> (timer2 != RT_NULL) rt_timer_start(timer2);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br><span class=\"hljs-comment\">/* 导出到 msh 命令列表中 */</span><br>MSH_CMD_EXPORT(timer_sample, timer sample);<br></code></pre></td></tr></table></figure>\n\n<p>仿真运行结果如下：</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs applescript\"> \\ | /<br>- RT -     Thread Operating System<br> / | \\     <span class=\"hljs-number\">3.1</span><span class=\"hljs-number\">.0</span> build Aug <span class=\"hljs-number\">24</span> <span class=\"hljs-number\">2018</span><br> <span class=\"hljs-number\">2006</span> - <span class=\"hljs-number\">2018</span> Copyright <span class=\"hljs-keyword\">by</span> rt-thread team<br>msh &gt;timer_sample<br>msh &gt;periodic timer <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">timeout</span> <span class=\"hljs-number\">0</span><br>periodic timer <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">timeout</span> <span class=\"hljs-number\">1</span><br>one shot timer <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">timeout</span><br>periodic timer <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">timeout</span> <span class=\"hljs-number\">2</span><br>periodic timer <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">timeout</span> <span class=\"hljs-number\">3</span><br>periodic timer <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">timeout</span> <span class=\"hljs-number\">4</span><br>periodic timer <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">timeout</span> <span class=\"hljs-number\">5</span><br>periodic timer <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">timeout</span> <span class=\"hljs-number\">6</span><br>periodic timer <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">timeout</span> <span class=\"hljs-number\">7</span><br>periodic timer <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">timeout</span> <span class=\"hljs-number\">8</span><br>periodic timer <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">timeout</span> <span class=\"hljs-number\">9</span><br>periodic timer was stopped!<br></code></pre></td></tr></table></figure>\n\n<p>初始化定时器的例子与创建定时器的例子类似，这个程序会初始化 2 个静态定时器，一个是单次定时，一个是周期性的定时，如下代码所示：周期性定时器 1 的超时函数，每 10 个 OS Tick 运行 1 次，共运行 10 次（10 次后调用 rt_timer_stop 使定时器 1 停止运行）；单次定时器 2 的超时函数在第 30 个 OS Tick 时运行一次。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;rtthread.h&gt;</span></span><br><br><span class=\"hljs-comment\">/* 定时器的控制块 */</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">rt_timer</span> <span class=\"hljs-title\">timer1</span>;</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">rt_timer</span> <span class=\"hljs-title\">timer2</span>;</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> cnt = <span class=\"hljs-number\">0</span>;<br><br><span class=\"hljs-comment\">/* 定时器 1 超时函数 */</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">timeout1</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>* parameter)</span><br>&#123;<br>    rt_kprintf(<span class=\"hljs-string\">&quot;periodic timer is timeout\\n&quot;</span>);<br>    <span class=\"hljs-comment\">/* 运行 10 次 */</span><br>    <span class=\"hljs-keyword\">if</span> (cnt++&gt;= <span class=\"hljs-number\">9</span>)<br>    &#123;<br>        rt_timer_stop(&amp;timer1);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">/* 定时器 2 超时函数 */</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">timeout2</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>* parameter)</span><br>&#123;<br>    rt_kprintf(<span class=\"hljs-string\">&quot;one shot timer is timeout\\n&quot;</span>);<br>&#125;<br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">timer_static_sample</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>    <span class=\"hljs-comment\">/* 初始化定时器 */</span><br>    rt_timer_init(&amp;timer1, <span class=\"hljs-string\">&quot;timer1&quot;</span>,  <span class=\"hljs-comment\">/* 定时器名字是 timer1 */</span><br>                    timeout1, <span class=\"hljs-comment\">/* 超时时回调的处理函数 */</span><br>                    RT_NULL, <span class=\"hljs-comment\">/* 超时函数的入口参数 */</span><br>                    <span class=\"hljs-number\">10</span>, <span class=\"hljs-comment\">/* 定时长度，以 OS Tick 为单位，即 10 个 OS Tick */</span><br>                    RT_TIMER_FLAG_PERIODIC); <span class=\"hljs-comment\">/* 周期性定时器 */</span><br>    rt_timer_init(&amp;timer2, <span class=\"hljs-string\">&quot;timer2&quot;</span>,   <span class=\"hljs-comment\">/* 定时器名字是 timer2 */</span><br>                    timeout2, <span class=\"hljs-comment\">/* 超时时回调的处理函数 */</span><br>                      RT_NULL, <span class=\"hljs-comment\">/* 超时函数的入口参数 */</span><br>                      <span class=\"hljs-number\">30</span>, <span class=\"hljs-comment\">/* 定时长度为 30 个 OS Tick */</span><br>                    RT_TIMER_FLAG_ONE_SHOT); <span class=\"hljs-comment\">/* 单次定时器 */</span><br><br>    <span class=\"hljs-comment\">/* 启动定时器 */</span><br>    rt_timer_start(&amp;timer1);<br>    rt_timer_start(&amp;timer2);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><span class=\"hljs-comment\">/* 导出到 msh 命令列表中 */</span><br>MSH_CMD_EXPORT(timer_static_sample, timer_static sample);<br></code></pre></td></tr></table></figure>\n\n<p>仿真运行结果如下：</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs applescript\">\\ | /<br>- RT -     Thread Operating System<br> / | \\     <span class=\"hljs-number\">3.1</span><span class=\"hljs-number\">.0</span> build Aug <span class=\"hljs-number\">24</span> <span class=\"hljs-number\">2018</span><br> <span class=\"hljs-number\">2006</span> - <span class=\"hljs-number\">2018</span> Copyright <span class=\"hljs-keyword\">by</span> rt-thread team<br>msh &gt;timer_static_sample<br>msh &gt;periodic timer <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">timeout</span><br>periodic timer <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">timeout</span><br>one shot timer <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">timeout</span><br>periodic timer <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">timeout</span><br>periodic timer <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">timeout</span><br>periodic timer <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">timeout</span><br>periodic timer <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">timeout</span><br>periodic timer <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">timeout</span><br>periodic timer <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">timeout</span><br>periodic timer <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">timeout</span><br>periodic timer <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">timeout</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"低于一个Tick的延时\"><a href=\"#低于一个Tick的延时\" class=\"headerlink\" title=\"低于一个Tick的延时\"></a>低于一个Tick的延时</h2><p>入口参数 us 指示出需要延时的微秒数目，这个函数只能支持低于 1 OS Tick 的延时，否则 SysTick 会出现溢出而不能够获得指定的延时时间。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;board.h&gt;</span></span><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">rt_hw_us_delay</span><span class=\"hljs-params\">(<span class=\"hljs-type\">rt_uint32_t</span> us)</span><br>&#123;<br>    <span class=\"hljs-type\">rt_uint32_t</span> delta;<br>    <span class=\"hljs-comment\">/* 获得延时经过的 tick 数 */</span><br>    us = us * (SysTick-&gt;LOAD/(<span class=\"hljs-number\">1000000</span>/RT_TICK_PER_SECOND));<br>    <span class=\"hljs-comment\">/* 获得当前时间 */</span><br>    delta = SysTick-&gt;VAL;<br>    <span class=\"hljs-comment\">/* 循环获得当前时间，直到达到指定的时间后退出循环 */</span><br>    <span class=\"hljs-keyword\">while</span> (delta - SysTick-&gt;VAL&lt; us);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"笔记-1\"><a href=\"#笔记-1\" class=\"headerlink\" title=\"笔记\"></a>笔记</h2><ul>\n<li>时钟节拍是特定的周期性中断，这个中断可以看做是系统心跳，中断之间的时间间隔取决于不同的应用，一般是 1ms–100ms，时钟节拍率越快，系统的额外开销就越大，从系统启动开始计数的时钟节拍数称为系统时间。</li>\n<li></li>\n</ul>\n<h1 id=\"线程间同步\"><a href=\"#线程间同步\" class=\"headerlink\" title=\"线程间同步\"></a>线程间同步</h1><p>线程的同步方式有很多种，其核心思想都是：<strong>在访问临界区的时候只允许一个 (或一类) 线程运行。</strong>进入 &#x2F; 退出临界区的方式有很多种：</p>\n<p>1）调用 rt_hw_interrupt_disable() 进入临界区，调用 rt_hw_interrupt_enable() 退出临界区；详见《中断管理》的全局中断开关内容。</p>\n<p>2）调用 rt_enter_critical() 进入临界区，调用 rt_exit_critical() 退出临界区。</p>\n<h2 id=\"信号量Semaphore\"><a href=\"#信号量Semaphore\" class=\"headerlink\" title=\"信号量Semaphore\"></a>信号量Semaphore</h2><p>信号量的值对应了信号量对象的实例数目、资源数目，假如信号量值为 5，则表示共有 5 个信号量实例（资源）可以被使用，当信号量实例数目为零时，再申请该信号量的线程就会被挂起在该信号量的等待队列上，等待可用的信号量实例（资源）。</p>\n<p>可以形成<strong>锁</strong>、<strong>同步</strong>、<strong>资源计数</strong>等关系，也能方便的用于<strong>线程与线程</strong>、<strong>中断与线程</strong>间的同步中。</p>\n<p><img src=\"/2021/42e53028/06sem_work.png\" alt=\"信号量工作示意图\"></p>\n<h3 id=\"Semaphore-API\"><a href=\"#Semaphore-API\" class=\"headerlink\" title=\"Semaphore API\"></a>Semaphore API</h3><p><img src=\"/2021/42e53028/06sem_ops.png\" alt=\"信号量相关接口\"></p>\n<h3 id=\"创建和删除信号量-create\"><a href=\"#创建和删除信号量-create\" class=\"headerlink\" title=\"创建和删除信号量-create\"></a>创建和删除信号量-create</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_sem_t</span> <span class=\"hljs-title function_\">rt_sem_create</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *name,</span><br><span class=\"hljs-params\">                       <span class=\"hljs-type\">rt_uint32_t</span> value,</span><br><span class=\"hljs-params\">                       <span class=\"hljs-type\">rt_uint8_t</span> flag)</span>;<br></code></pre></td></tr></table></figure>\n\n<p>当选择 RT_IPC_FLAG_FIFO（先进先出）方式时，那么等待线程队列将按照先进先出的方式排队，先进入的线程将先获得等待的信号量；</p>\n<p>当选择 RT_IPC_FLAG_PRIO（优先级等待）方式时，等待线程队列将按照优先级进行排队，优先级高的等待线程将先获得等待的信号量。</p>\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>name</td>\n<td>信号量名称</td>\n</tr>\n<tr>\n<td>value</td>\n<td>信号量初始值</td>\n</tr>\n<tr>\n<td>flag</td>\n<td>信号量标志，它可以取如下数值： RT_IPC_FLAG_FIFO 或 RT_IPC_FLAG_PRIO</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>RT_NULL</td>\n<td>创建失败</td>\n</tr>\n<tr>\n<td>信号量的控制块指针</td>\n<td>创建成功</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_err_t</span> <span class=\"hljs-title function_\">rt_sem_delete</span><span class=\"hljs-params\">(<span class=\"hljs-type\">rt_sem_t</span> sem)</span>;<br></code></pre></td></tr></table></figure>\n\n<p>如果删除该信号量时，有线程正在等待该信号量，那么删除操作会先唤醒等待在该信号量上的线程（等待线程的返回值是 - RT_ERROR），然后再释放信号量的内存资源。</p>\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>sem</td>\n<td>rt_sem_create() 创建的信号量对象</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>RT_EOK</td>\n<td>删除成功</td>\n</tr>\n</tbody></table>\n<h3 id=\"初始化和脱离信号量-init\"><a href=\"#初始化和脱离信号量-init\" class=\"headerlink\" title=\"初始化和脱离信号量-init\"></a>初始化和脱离信号量-init</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_err_t</span> <span class=\"hljs-title function_\">rt_sem_init</span><span class=\"hljs-params\">(<span class=\"hljs-type\">rt_sem_t</span>       sem,</span><br><span class=\"hljs-params\">                    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>     *name,</span><br><span class=\"hljs-params\">                    <span class=\"hljs-type\">rt_uint32_t</span>    value,</span><br><span class=\"hljs-params\">                    <span class=\"hljs-type\">rt_uint8_t</span>     flag)</span><br></code></pre></td></tr></table></figure>\n\n<p>flag见上↑</p>\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>sem</td>\n<td>信号量对象的句柄</td>\n</tr>\n<tr>\n<td>name</td>\n<td>信号量名称</td>\n</tr>\n<tr>\n<td>value</td>\n<td>信号量初始值</td>\n</tr>\n<tr>\n<td>flag</td>\n<td>信号量标志，它可以取如下数值： RT_IPC_FLAG_FIFO 或 RT_IPC_FLAG_PRIO</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>RT_EOK</td>\n<td>初始化成功</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_err_t</span> <span class=\"hljs-title function_\">rt_sem_detach</span><span class=\"hljs-params\">(<span class=\"hljs-type\">rt_sem_t</span> sem)</span>;<br></code></pre></td></tr></table></figure>\n\n<p>使用该函数后，内核先唤醒所有挂在该信号量等待队列上的线程，然后将该信号量从内核对象管理器中脱离。原来挂起在信号量上的等待线程将获得 - RT_ERROR 的返回值。</p>\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>sem</td>\n<td>信号量对象的句柄</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>RT_EOK</td>\n<td>脱离成功</td>\n</tr>\n</tbody></table>\n<h3 id=\"获取信号量-take\"><a href=\"#获取信号量-take\" class=\"headerlink\" title=\"获取信号量-take\"></a>获取信号量-take</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_err_t</span> <span class=\"hljs-title function_\">rt_sem_take</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">rt_sem_t</span> sem, <span class=\"hljs-type\">rt_int32_t</span> time)</span>;<br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>sem</td>\n<td>信号量对象的句柄</td>\n</tr>\n<tr>\n<td>time</td>\n<td>指定的等待时间，单位是操作系统时钟节拍（OS Tick），或者RT_WAITING_FOREVER永远等待</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>RT_EOK</td>\n<td>成功获得信号量</td>\n</tr>\n<tr>\n<td>-RT_ETIMEOUT</td>\n<td>超时依然未获得信号量</td>\n</tr>\n<tr>\n<td>-RT_ERROR</td>\n<td>其他错误</td>\n</tr>\n</tbody></table>\n<h3 id=\"无等待获取信号量-trytake\"><a href=\"#无等待获取信号量-trytake\" class=\"headerlink\" title=\"无等待获取信号量-trytake\"></a>无等待获取信号量-trytake</h3><p>当用户不想在申请的信号量上挂起线程进行等待时，可以使用无等待方式获取信号量</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_err_t</span> <span class=\"hljs-title function_\">rt_sem_trytake</span><span class=\"hljs-params\">(<span class=\"hljs-type\">rt_sem_t</span> sem)</span>;<br></code></pre></td></tr></table></figure>\n\n<p>这个函数与 rt_sem_take(sem, 0) 的作用相同，即当线程申请的信号量资源实例不可用的时候，它不会等待在该信号量上，而是直接返回 - RT_ETIMEOUT。</p>\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>sem</td>\n<td>信号量对象的句柄</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>RT_EOK</td>\n<td>成功获得信号量</td>\n</tr>\n<tr>\n<td>-RT_ETIMEOUT</td>\n<td>获取失败</td>\n</tr>\n</tbody></table>\n<h3 id=\"释放信号量-release\"><a href=\"#释放信号量-release\" class=\"headerlink\" title=\"释放信号量-release\"></a>释放信号量-release</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_err_t</span> <span class=\"hljs-title function_\">rt_sem_release</span><span class=\"hljs-params\">(<span class=\"hljs-type\">rt_sem_t</span> sem)</span>;<br></code></pre></td></tr></table></figure>\n\n<p>例如当信号量的值等于零时，并且有线程等待这个信号量时，释放信号量将唤醒等待在该信号量线程队列中的第一个线程，由它获取信号量；否则将把信号量的值加 1。</p>\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>sem</td>\n<td>信号量对象的句柄</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>RT_EOK</td>\n<td>成功释放信号量</td>\n</tr>\n</tbody></table>\n<h2 id=\"信号量应用示例\"><a href=\"#信号量应用示例\" class=\"headerlink\" title=\"信号量应用示例\"></a>信号量应用示例</h2><p><strong>动态信号量的使用</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;rtthread.h&gt;</span></span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> THREAD_PRIORITY         25</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> THREAD_TIMESLICE        5</span><br><br><span class=\"hljs-comment\">/* 指向信号量的指针 */</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">rt_sem_t</span> dynamic_sem = RT_NULL;<br><br>ALIGN(RT_ALIGN_SIZE)<br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">char</span> thread1_stack[<span class=\"hljs-number\">1024</span>];<br><span class=\"hljs-type\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">rt_thread</span> <span class=\"hljs-title\">thread1</span>;</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">rt_thread1_entry</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span> *parameter)</span><br>&#123;<br>    <span class=\"hljs-type\">static</span> <span class=\"hljs-type\">rt_uint8_t</span> count = <span class=\"hljs-number\">0</span>;<br><br>    <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-number\">1</span>)<br>    &#123;<br>        <span class=\"hljs-keyword\">if</span>(count &lt;= <span class=\"hljs-number\">100</span>)<br>        &#123;<br>            count++;<br>        &#125;<br>        <span class=\"hljs-keyword\">else</span><br>            <span class=\"hljs-keyword\">return</span>;<br><br>        <span class=\"hljs-comment\">/* count 每计数 10 次，就释放一次信号量 */</span><br>         <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-number\">0</span> == (count % <span class=\"hljs-number\">10</span>))<br>        &#123;<br>            rt_kprintf(<span class=\"hljs-string\">&quot;t1 release a dynamic semaphore.\\n&quot;</span>);<br>            rt_sem_release(dynamic_sem);<br>        &#125;<br>    &#125;<br>&#125;<br><br>ALIGN(RT_ALIGN_SIZE)<br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">char</span> thread2_stack[<span class=\"hljs-number\">1024</span>];<br><span class=\"hljs-type\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">rt_thread</span> <span class=\"hljs-title\">thread2</span>;</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">rt_thread2_entry</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span> *parameter)</span><br>&#123;<br>    <span class=\"hljs-type\">static</span> <span class=\"hljs-type\">rt_err_t</span> result;<br>    <span class=\"hljs-type\">static</span> <span class=\"hljs-type\">rt_uint8_t</span> number = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-number\">1</span>)<br>    &#123;<br>        <span class=\"hljs-comment\">/* 永久方式等待信号量，获取到信号量，则执行 number 自加的操作 */</span><br>        result = rt_sem_take(dynamic_sem, RT_WAITING_FOREVER);<br>        <span class=\"hljs-keyword\">if</span> (result != RT_EOK)<br>        &#123;<br>            rt_kprintf(<span class=\"hljs-string\">&quot;t2 take a dynamic semaphore, failed.\\n&quot;</span>);<br>            rt_sem_delete(dynamic_sem);<br>            <span class=\"hljs-keyword\">return</span>;<br>        &#125;<br>        <span class=\"hljs-keyword\">else</span><br>        &#123;<br>            number++;<br>            rt_kprintf(<span class=\"hljs-string\">&quot;t2 take a dynamic semaphore. number = %d\\n&quot;</span> ,number);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">/* 信号量示例的初始化 */</span><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">semaphore_sample</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>    <span class=\"hljs-comment\">/* 创建一个动态信号量，初始值是 0 */</span><br>    dynamic_sem = rt_sem_create(<span class=\"hljs-string\">&quot;dsem&quot;</span>, <span class=\"hljs-number\">0</span>, RT_IPC_FLAG_FIFO);<br>    <span class=\"hljs-keyword\">if</span> (dynamic_sem == RT_NULL)<br>    &#123;<br>        rt_kprintf(<span class=\"hljs-string\">&quot;create dynamic semaphore failed.\\n&quot;</span>);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span><br>    &#123;<br>        rt_kprintf(<span class=\"hljs-string\">&quot;create done. dynamic semaphore value = 0.\\n&quot;</span>);<br>    &#125;<br><br>    rt_thread_init(&amp;thread1,<br>                   <span class=\"hljs-string\">&quot;thread1&quot;</span>,<br>                   rt_thread1_entry,<br>                   RT_NULL,<br>                   &amp;thread1_stack[<span class=\"hljs-number\">0</span>],<br>                   <span class=\"hljs-keyword\">sizeof</span>(thread1_stack),<br>                   THREAD_PRIORITY, THREAD_TIMESLICE);<br>    rt_thread_startup(&amp;thread1);<br><br>    rt_thread_init(&amp;thread2,<br>                   <span class=\"hljs-string\">&quot;thread2&quot;</span>,<br>                   rt_thread2_entry,<br>                   RT_NULL,<br>                   &amp;thread2_stack[<span class=\"hljs-number\">0</span>],<br>                   <span class=\"hljs-keyword\">sizeof</span>(thread2_stack),<br>                   THREAD_PRIORITY<span class=\"hljs-number\">-1</span>, THREAD_TIMESLICE);<br>    rt_thread_startup(&amp;thread2);<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><span class=\"hljs-comment\">/* 导出到 msh 命令列表中 */</span><br>MSH_CMD_EXPORT(semaphore_sample, semaphore sample);<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\"> \\ | /<br>- RT -     Thread Operating System<br> / | \\     <span class=\"hljs-number\">3.1</span><span class=\"hljs-number\">.0</span> build Aug <span class=\"hljs-number\">27</span> <span class=\"hljs-number\">2018</span><br> <span class=\"hljs-number\">2006</span> - <span class=\"hljs-number\">2018</span> Copyright <span class=\"hljs-keyword\">by</span> rt-thread team<br>msh &gt;semaphore_sample<br><span class=\"hljs-built_in\">create</span> done. dynamic semaphore <span class=\"hljs-built_in\">value</span> = <span class=\"hljs-number\">0.</span><br>msh &gt;t1 release <span class=\"hljs-keyword\">a</span> dynamic semaphore.<br>t2 take <span class=\"hljs-keyword\">a</span> dynamic semaphore. <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">1</span><br>t1 release <span class=\"hljs-keyword\">a</span> dynamic semaphore.<br>t2 take <span class=\"hljs-keyword\">a</span> dynamic semaphore. <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">2</span><br>t1 release <span class=\"hljs-keyword\">a</span> dynamic semaphore.<br>t2 take <span class=\"hljs-keyword\">a</span> dynamic semaphore. <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">3</span><br>t1 release <span class=\"hljs-keyword\">a</span> dynamic semaphore.<br>t2 take <span class=\"hljs-keyword\">a</span> dynamic semaphore. <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">4</span><br>t1 release <span class=\"hljs-keyword\">a</span> dynamic semaphore.<br>t2 take <span class=\"hljs-keyword\">a</span> dynamic semaphore. <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">5</span><br>t1 release <span class=\"hljs-keyword\">a</span> dynamic semaphore.<br>t2 take <span class=\"hljs-keyword\">a</span> dynamic semaphore. <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">6</span><br>t1 release <span class=\"hljs-keyword\">a</span> dynamic semaphore.<br>t2 take <span class=\"hljs-keyword\">a</span> dynamic semaphore. <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">7</span><br>t1 release <span class=\"hljs-keyword\">a</span> dynamic semaphore.<br>t2 take <span class=\"hljs-keyword\">a</span> dynamic semaphore. <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">8</span><br>t1 release <span class=\"hljs-keyword\">a</span> dynamic semaphore.<br>t2 take <span class=\"hljs-keyword\">a</span> dynamic semaphore. <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">9</span><br>t1 release <span class=\"hljs-keyword\">a</span> dynamic semaphore.<br>t2 take <span class=\"hljs-keyword\">a</span> dynamic semaphore. <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">10</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>信号量锁的作用，生产者消费者例程</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;rtthread.h&gt;</span></span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> THREAD_PRIORITY       6</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> THREAD_STACK_SIZE     512</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> THREAD_TIMESLICE      5</span><br><br><span class=\"hljs-comment\">/* 定义最大 5 个元素能够被产生 */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> MAXSEM 5</span><br><br><span class=\"hljs-comment\">/* 用于放置生产的整数数组 */</span><br><span class=\"hljs-type\">rt_uint32_t</span> <span class=\"hljs-built_in\">array</span>[MAXSEM];<br><br><span class=\"hljs-comment\">/* 指向生产者、消费者在 array 数组中的读写位置 */</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">rt_uint32_t</span> <span class=\"hljs-built_in\">set</span>, get;<br><br><span class=\"hljs-comment\">/* 指向线程控制块的指针 */</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">rt_thread_t</span> producer_tid = RT_NULL;<br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">rt_thread_t</span> consumer_tid = RT_NULL;<br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">rt_semaphore</span> <span class=\"hljs-title\">sem_lock</span>;</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">rt_semaphore</span> <span class=\"hljs-title\">sem_empty</span>, <span class=\"hljs-title\">sem_full</span>;</span><br><br><span class=\"hljs-comment\">/* 生产者线程入口 */</span><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">producer_thread_entry</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span> *parameter)</span><br>&#123;<br>    <span class=\"hljs-type\">int</span> cnt = <span class=\"hljs-number\">0</span>;<br><br>    <span class=\"hljs-comment\">/* 运行 10 次 */</span><br>    <span class=\"hljs-keyword\">while</span> (cnt &lt; <span class=\"hljs-number\">10</span>)<br>    &#123;<br>        <span class=\"hljs-comment\">/* 获取一个空位 */</span><br>        rt_sem_take(&amp;sem_empty, RT_WAITING_FOREVER);<br><br>        <span class=\"hljs-comment\">/* 修改 array 内容，上锁 */</span><br>        rt_sem_take(&amp;sem_lock, RT_WAITING_FOREVER);<br>        <span class=\"hljs-built_in\">array</span>[<span class=\"hljs-built_in\">set</span> % MAXSEM] = cnt + <span class=\"hljs-number\">1</span>;<br>        rt_kprintf(<span class=\"hljs-string\">&quot;the producer generates a number: %d\\n&quot;</span>, <span class=\"hljs-built_in\">array</span>[<span class=\"hljs-built_in\">set</span> % MAXSEM]);<br>        <span class=\"hljs-built_in\">set</span>++;<br>        rt_sem_release(&amp;sem_lock);<br><br>        <span class=\"hljs-comment\">/* 发布一个满位 */</span><br>        rt_sem_release(&amp;sem_full);<br>        cnt++;<br><br>        <span class=\"hljs-comment\">/* 暂停一段时间 */</span><br>        rt_thread_mdelay(<span class=\"hljs-number\">20</span>);<br>    &#125;<br><br>    rt_kprintf(<span class=\"hljs-string\">&quot;the producer exit!\\n&quot;</span>);<br>&#125;<br><br><span class=\"hljs-comment\">/* 消费者线程入口 */</span><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">consumer_thread_entry</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span> *parameter)</span><br>&#123;<br>    <span class=\"hljs-type\">rt_uint32_t</span> sum = <span class=\"hljs-number\">0</span>;<br><br>    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-number\">1</span>)<br>    &#123;<br>        <span class=\"hljs-comment\">/* 获取一个满位 */</span><br>        rt_sem_take(&amp;sem_full, RT_WAITING_FOREVER);<br><br>        <span class=\"hljs-comment\">/* 临界区，上锁进行操作 */</span><br>        rt_sem_take(&amp;sem_lock, RT_WAITING_FOREVER);<br>        sum += <span class=\"hljs-built_in\">array</span>[get % MAXSEM];<br>        rt_kprintf(<span class=\"hljs-string\">&quot;the consumer[%d] get a number: %d\\n&quot;</span>, (get % MAXSEM), <span class=\"hljs-built_in\">array</span>[get % MAXSEM]);<br>        get++;<br>        rt_sem_release(&amp;sem_lock);<br><br>        <span class=\"hljs-comment\">/* 释放一个空位 */</span><br>        rt_sem_release(&amp;sem_empty);<br><br>        <span class=\"hljs-comment\">/* 生产者生产到 10 个数目，停止，消费者线程相应停止 */</span><br>        <span class=\"hljs-keyword\">if</span> (get == <span class=\"hljs-number\">10</span>) <span class=\"hljs-keyword\">break</span>;<br><br>        <span class=\"hljs-comment\">/* 暂停一小会时间 */</span><br>        rt_thread_mdelay(<span class=\"hljs-number\">50</span>);<br>    &#125;<br><br>    rt_kprintf(<span class=\"hljs-string\">&quot;the consumer sum is: %d\\n&quot;</span>, sum);<br>    rt_kprintf(<span class=\"hljs-string\">&quot;the consumer exit!\\n&quot;</span>);<br>&#125;<br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">producer_consumer</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>    <span class=\"hljs-built_in\">set</span> = <span class=\"hljs-number\">0</span>;<br>    get = <span class=\"hljs-number\">0</span>;<br><br>    <span class=\"hljs-comment\">/* 初始化 3 个信号量 */</span><br>    rt_sem_init(&amp;sem_lock, <span class=\"hljs-string\">&quot;lock&quot;</span>,     <span class=\"hljs-number\">1</span>,      RT_IPC_FLAG_FIFO);<br>    rt_sem_init(&amp;sem_empty, <span class=\"hljs-string\">&quot;empty&quot;</span>,   MAXSEM, RT_IPC_FLAG_FIFO);<br>    rt_sem_init(&amp;sem_full, <span class=\"hljs-string\">&quot;full&quot;</span>,     <span class=\"hljs-number\">0</span>,      RT_IPC_FLAG_FIFO);<br><br>    <span class=\"hljs-comment\">/* 创建生产者线程 */</span><br>    producer_tid = rt_thread_create(<span class=\"hljs-string\">&quot;producer&quot;</span>,<br>                                    producer_thread_entry, RT_NULL,<br>                                    THREAD_STACK_SIZE,<br>                                    THREAD_PRIORITY - <span class=\"hljs-number\">1</span>,<br>                                    THREAD_TIMESLICE);<br>    <span class=\"hljs-keyword\">if</span> (producer_tid != RT_NULL)<br>    &#123;<br>        rt_thread_startup(producer_tid);<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span><br>    &#123;<br>        rt_kprintf(<span class=\"hljs-string\">&quot;create thread producer failed&quot;</span>);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 创建消费者线程 */</span><br>    consumer_tid = rt_thread_create(<span class=\"hljs-string\">&quot;consumer&quot;</span>,<br>                                    consumer_thread_entry, RT_NULL,<br>                                    THREAD_STACK_SIZE,<br>                                    THREAD_PRIORITY + <span class=\"hljs-number\">1</span>,<br>                                    THREAD_TIMESLICE);<br>    <span class=\"hljs-keyword\">if</span> (consumer_tid != RT_NULL)<br>    &#123;<br>        rt_thread_startup(consumer_tid);<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span><br>    &#123;<br>        rt_kprintf(<span class=\"hljs-string\">&quot;create thread consumer failed&quot;</span>);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br><span class=\"hljs-comment\">/* 导出到 msh 命令列表中 */</span><br>MSH_CMD_EXPORT(producer_consumer, producer_consumer sample);<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\">\\ | /<br>- RT -     Thread Operating System<br> / | \\     <span class=\"hljs-number\">3.1</span><span class=\"hljs-number\">.0</span> build Aug <span class=\"hljs-number\">27</span> <span class=\"hljs-number\">2018</span><br> <span class=\"hljs-number\">2006</span> - <span class=\"hljs-number\">2018</span> Copyright <span class=\"hljs-keyword\">by</span> rt-thread team<br>msh &gt;producer_consumer<br><span class=\"hljs-keyword\">the</span> producer generates <span class=\"hljs-keyword\">a</span> <span class=\"hljs-built_in\">number</span>: <span class=\"hljs-number\">1</span><br><span class=\"hljs-keyword\">the</span> consumer[<span class=\"hljs-number\">0</span>] <span class=\"hljs-built_in\">get</span> <span class=\"hljs-keyword\">a</span> <span class=\"hljs-built_in\">number</span>: <span class=\"hljs-number\">1</span><br>msh &gt;<span class=\"hljs-keyword\">the</span> producer generates <span class=\"hljs-keyword\">a</span> <span class=\"hljs-built_in\">number</span>: <span class=\"hljs-number\">2</span><br><span class=\"hljs-keyword\">the</span> producer generates <span class=\"hljs-keyword\">a</span> <span class=\"hljs-built_in\">number</span>: <span class=\"hljs-number\">3</span><br><span class=\"hljs-keyword\">the</span> consumer[<span class=\"hljs-number\">1</span>] <span class=\"hljs-built_in\">get</span> <span class=\"hljs-keyword\">a</span> <span class=\"hljs-built_in\">number</span>: <span class=\"hljs-number\">2</span><br><span class=\"hljs-keyword\">the</span> producer generates <span class=\"hljs-keyword\">a</span> <span class=\"hljs-built_in\">number</span>: <span class=\"hljs-number\">4</span><br><span class=\"hljs-keyword\">the</span> producer generates <span class=\"hljs-keyword\">a</span> <span class=\"hljs-built_in\">number</span>: <span class=\"hljs-number\">5</span><br><span class=\"hljs-keyword\">the</span> producer generates <span class=\"hljs-keyword\">a</span> <span class=\"hljs-built_in\">number</span>: <span class=\"hljs-number\">6</span><br><span class=\"hljs-keyword\">the</span> consumer[<span class=\"hljs-number\">2</span>] <span class=\"hljs-built_in\">get</span> <span class=\"hljs-keyword\">a</span> <span class=\"hljs-built_in\">number</span>: <span class=\"hljs-number\">3</span><br><span class=\"hljs-keyword\">the</span> producer generates <span class=\"hljs-keyword\">a</span> <span class=\"hljs-built_in\">number</span>: <span class=\"hljs-number\">7</span><br><span class=\"hljs-keyword\">the</span> producer generates <span class=\"hljs-keyword\">a</span> <span class=\"hljs-built_in\">number</span>: <span class=\"hljs-number\">8</span><br><span class=\"hljs-keyword\">the</span> consumer[<span class=\"hljs-number\">3</span>] <span class=\"hljs-built_in\">get</span> <span class=\"hljs-keyword\">a</span> <span class=\"hljs-built_in\">number</span>: <span class=\"hljs-number\">4</span><br><span class=\"hljs-keyword\">the</span> producer generates <span class=\"hljs-keyword\">a</span> <span class=\"hljs-built_in\">number</span>: <span class=\"hljs-number\">9</span><br><span class=\"hljs-keyword\">the</span> consumer[<span class=\"hljs-number\">4</span>] <span class=\"hljs-built_in\">get</span> <span class=\"hljs-keyword\">a</span> <span class=\"hljs-built_in\">number</span>: <span class=\"hljs-number\">5</span><br><span class=\"hljs-keyword\">the</span> producer generates <span class=\"hljs-keyword\">a</span> <span class=\"hljs-built_in\">number</span>: <span class=\"hljs-number\">10</span><br><span class=\"hljs-keyword\">the</span> producer exit!<br><span class=\"hljs-keyword\">the</span> consumer[<span class=\"hljs-number\">0</span>] <span class=\"hljs-built_in\">get</span> <span class=\"hljs-keyword\">a</span> <span class=\"hljs-built_in\">number</span>: <span class=\"hljs-number\">6</span><br><span class=\"hljs-keyword\">the</span> consumer[<span class=\"hljs-number\">1</span>] <span class=\"hljs-built_in\">get</span> <span class=\"hljs-keyword\">a</span> <span class=\"hljs-built_in\">number</span>: <span class=\"hljs-number\">7</span><br><span class=\"hljs-keyword\">the</span> consumer[<span class=\"hljs-number\">2</span>] <span class=\"hljs-built_in\">get</span> <span class=\"hljs-keyword\">a</span> <span class=\"hljs-built_in\">number</span>: <span class=\"hljs-number\">8</span><br><span class=\"hljs-keyword\">the</span> consumer[<span class=\"hljs-number\">3</span>] <span class=\"hljs-built_in\">get</span> <span class=\"hljs-keyword\">a</span> <span class=\"hljs-built_in\">number</span>: <span class=\"hljs-number\">9</span><br><span class=\"hljs-keyword\">the</span> consumer[<span class=\"hljs-number\">4</span>] <span class=\"hljs-built_in\">get</span> <span class=\"hljs-keyword\">a</span> <span class=\"hljs-built_in\">number</span>: <span class=\"hljs-number\">10</span><br><span class=\"hljs-keyword\">the</span> consumer <span class=\"hljs-built_in\">sum</span> is: <span class=\"hljs-number\">55</span><br><span class=\"hljs-keyword\">the</span> consumer exit!<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"互斥量-Mutex\"><a href=\"#互斥量-Mutex\" class=\"headerlink\" title=\"互斥量 Mutex\"></a>互斥量 Mutex</h2><p>互斥量又叫相互排斥的信号量，是一种特殊的二值信号量。</p>\n<p>互斥量和信号量不同的是：拥有互斥量的线程拥有互斥量的所有权，互斥量支持递归访问且能防止线程优先级翻转；并且互斥量只能由持有线程释放，而信号量则可以由任何线程释放。</p>\n<p><img src=\"/2021/42e53028/06mutex_work.png\" alt=\"互斥量工作示意图\"></p>\n<p>线程优先级翻转如下。</p>\n<p><img src=\"/2021/42e53028/06priority_inversion.png\" alt=\"优先级反转 (M 为信号量)\"></p>\n<p><img src=\"/2021/42e53028/06priority_inherit.png\" alt=\"优先级继承 (M 为互斥量)\"></p>\n<h3 id=\"互斥量API\"><a href=\"#互斥量API\" class=\"headerlink\" title=\"互斥量API\"></a>互斥量API</h3><p><img src=\"/2021/42e53028/06mutex_ops.png\" alt=\"互斥量相关接口\"></p>\n<h3 id=\"创建和删除互斥量-create\"><a href=\"#创建和删除互斥量-create\" class=\"headerlink\" title=\"创建和删除互斥量-create\"></a>创建和删除互斥量-create</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_mutex_t</span> <span class=\"hljs-title function_\">rt_mutex_create</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name, <span class=\"hljs-type\">rt_uint8_t</span> flag)</span>;<br></code></pre></td></tr></table></figure>\n\n<p>互斥量的 flag 标志设置为 RT_IPC_FLAG_PRIO，表示在多个线程等待资源时，将由优先级高的线程优先获得资源。flag 设置为 RT_IPC_FLAG_FIFO，表示在多个线程等待资源时，将按照先来先得的顺序获得资源。</p>\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>name</td>\n<td>互斥量的名称</td>\n</tr>\n<tr>\n<td>flag</td>\n<td>互斥量标志，它可以取如下数值： RT_IPC_FLAG_FIFO 或 RT_IPC_FLAG_PRIO</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>互斥量句柄</td>\n<td>创建成功</td>\n</tr>\n<tr>\n<td>RT_NULL</td>\n<td>创建失败</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_err_t</span> <span class=\"hljs-title function_\">rt_mutex_delete</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">rt_mutex_t</span> mutex)</span>;<br></code></pre></td></tr></table></figure>\n\n<p>当删除一个互斥量时，所有等待此互斥量的线程都将被唤醒，等待线程获得的返回值是 - RT_ERROR。然后系统将该互斥量从内核对象管理器链表中删除并释放互斥量占用的内存空间。</p>\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>mutex</td>\n<td>互斥量对象的句柄</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>RT_EOK</td>\n<td>删除成功</td>\n</tr>\n</tbody></table>\n<h3 id=\"初始化和脱离互斥量-init\"><a href=\"#初始化和脱离互斥量-init\" class=\"headerlink\" title=\"初始化和脱离互斥量-init\"></a>初始化和脱离互斥量-init</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_err_t</span> <span class=\"hljs-title function_\">rt_mutex_init</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">rt_mutex_t</span> mutex, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name, <span class=\"hljs-type\">rt_uint8_t</span> flag)</span>;<br></code></pre></td></tr></table></figure>\n\n<p>flag见上</p>\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>mutex</td>\n<td>互斥量对象的句柄，它由用户提供，并指向互斥量对象的内存块</td>\n</tr>\n<tr>\n<td>name</td>\n<td>互斥量的名称</td>\n</tr>\n<tr>\n<td>flag</td>\n<td>互斥量标志，它可以取如下数值： RT_IPC_FLAG_FIFO 或 RT_IPC_FLAG_PRIO</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>RT_EOK</td>\n<td>初始化成功</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_err_t</span> <span class=\"hljs-title function_\">rt_mutex_detach</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">rt_mutex_t</span> mutex)</span>;<br></code></pre></td></tr></table></figure>\n\n<p>使用该函数接口后，内核先唤醒所有挂在该互斥量上的线程（线程的返回值是 -RT_ERROR），然后系统将该互斥量从内核对象管理器中脱离。</p>\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>mutex</td>\n<td>互斥量对象的句柄</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>RT_EOK</td>\n<td>成功</td>\n</tr>\n</tbody></table>\n<h3 id=\"获取互斥量-take\"><a href=\"#获取互斥量-take\" class=\"headerlink\" title=\"获取互斥量-take\"></a>获取互斥量-take</h3><p>线程获取了互斥量，那么线程就有了对该互斥量的所有权，即某一个时刻一个互斥量只能被一个线程持有。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_err_t</span> <span class=\"hljs-title function_\">rt_mutex_take</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">rt_mutex_t</span> mutex, <span class=\"hljs-type\">rt_int32_t</span> time)</span>;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><p>如果互斥量没有被其他线程控制，那么申请该互斥量的线程将成功获得该互斥量。</p>\n</li>\n<li><p>如果互斥量已经被当前线程线程控制，则该互斥量的持有计数加 1，当前线程也不会挂起等待。</p>\n</li>\n<li><p>如果互斥量已经被其他线程占有，则当前线程在该互斥量上挂起等待，直到其他线程释放它或者等待时间超过指定的超时时间。</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>mutex</td>\n<td>互斥量对象的句柄</td>\n</tr>\n<tr>\n<td>time</td>\n<td>指定等待的时间</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>RT_EOK</td>\n<td>成功获得互斥量</td>\n</tr>\n<tr>\n<td>-RT_ETIMEOUT</td>\n<td>超时</td>\n</tr>\n<tr>\n<td>-RT_ERROR</td>\n<td>获取失败</td>\n</tr>\n</tbody></table>\n<h3 id=\"释放互斥量-release\"><a href=\"#释放互斥量-release\" class=\"headerlink\" title=\"释放互斥量-release\"></a>释放互斥量-release</h3><p>当线程完成互斥资源的访问后，应尽快释放它占据的互斥量，使得其他线程能及时获取该互斥量。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_err_t</span> <span class=\"hljs-title function_\">rt_mutex_release</span><span class=\"hljs-params\">(<span class=\"hljs-type\">rt_mutex_t</span> mutex)</span>;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>只有已经拥有互斥量控制权的线程才能释放它，每释放一次该互斥量，它的持有计数就减 1。</li>\n<li>当该互斥量的持有计数为零时（即持有线程已经释放所有的持有操作），它变为可用，等待在该信号量上的线程将被唤醒。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>mutex</td>\n<td>互斥量对象的句柄</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>RT_EOK</td>\n<td>成功</td>\n</tr>\n</tbody></table>\n<h2 id=\"互斥量应用示例\"><a href=\"#互斥量应用示例\" class=\"headerlink\" title=\"互斥量应用示例\"></a>互斥量应用示例</h2><p>这是一个互斥量的应用例程，互斥锁是一种保护共享资源的方法。当一个线程拥有互斥锁的时候，可以保护共享资源不被其他线程破坏。下面用一个例子来说明，有两个线程：线程 1 和线程 2，线程 1 对 2 个 number 分别进行加 1 操作；线程 2 也对 2 个 number 分别进行加 1 操作，使用互斥量保证线程改变 2 个 number 值的操作不被打断。如下代码所示：</p>\n<p><strong>互斥量例程</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;rtthread.h&gt;</span></span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> THREAD_PRIORITY         8</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> THREAD_TIMESLICE        5</span><br><br><span class=\"hljs-comment\">/* 指向互斥量的指针 */</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">rt_mutex_t</span> dynamic_mutex = RT_NULL;<br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">rt_uint8_t</span> number1,number2 = <span class=\"hljs-number\">0</span>;<br><br>ALIGN(RT_ALIGN_SIZE)<br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">char</span> thread1_stack[<span class=\"hljs-number\">1024</span>];<br><span class=\"hljs-type\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">rt_thread</span> <span class=\"hljs-title\">thread1</span>;</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">rt_thread_entry1</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span> *parameter)</span><br>&#123;<br>      <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-number\">1</span>)<br>      &#123;<br>          <span class=\"hljs-comment\">/* 线程 1 获取到互斥量后，先后对 number1、number2 进行加 1 操作，然后释放互斥量 */</span><br>          rt_mutex_take(dynamic_mutex, RT_WAITING_FOREVER);<br>          number1++;<br>          rt_thread_mdelay(<span class=\"hljs-number\">10</span>);<br>          number2++;<br>          rt_mutex_release(dynamic_mutex);<br>       &#125;<br>&#125;<br><br>ALIGN(RT_ALIGN_SIZE)<br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">char</span> thread2_stack[<span class=\"hljs-number\">1024</span>];<br><span class=\"hljs-type\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">rt_thread</span> <span class=\"hljs-title\">thread2</span>;</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">rt_thread_entry2</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span> *parameter)</span><br>&#123;<br>      <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-number\">1</span>)<br>      &#123;<br>          <span class=\"hljs-comment\">/* 线程 2 获取到互斥量后，检查 number1、number2 的值是否相同，相同则表示 mutex 起到了锁的作用 */</span><br>          rt_mutex_take(dynamic_mutex, RT_WAITING_FOREVER);<br>          <span class=\"hljs-keyword\">if</span>(number1 != number2)<br>          &#123;<br>            rt_kprintf(<span class=\"hljs-string\">&quot;not protect.number1 = %d, mumber2 = %d \\n&quot;</span>,number1 ,number2);<br>          &#125;<br>          <span class=\"hljs-keyword\">else</span><br>          &#123;<br>            rt_kprintf(<span class=\"hljs-string\">&quot;mutex protect ,number1 = mumber2 is %d\\n&quot;</span>,number1);<br>          &#125;<br><br>           number1++;<br>           number2++;<br>           rt_mutex_release(dynamic_mutex);<br><br>          <span class=\"hljs-keyword\">if</span>(number1&gt;=<span class=\"hljs-number\">50</span>)<br>              <span class=\"hljs-keyword\">return</span>;<br>      &#125;<br>&#125;<br><br><span class=\"hljs-comment\">/* 互斥量示例的初始化 */</span><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">mutex_sample</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>    <span class=\"hljs-comment\">/* 创建一个动态互斥量 */</span><br>    dynamic_mutex = rt_mutex_create(<span class=\"hljs-string\">&quot;dmutex&quot;</span>, RT_IPC_FLAG_FIFO);<br>    <span class=\"hljs-keyword\">if</span> (dynamic_mutex == RT_NULL)<br>    &#123;<br>        rt_kprintf(<span class=\"hljs-string\">&quot;create dynamic mutex failed.\\n&quot;</span>);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>    &#125;<br><br>    rt_thread_init(&amp;thread1,<br>                   <span class=\"hljs-string\">&quot;thread1&quot;</span>,<br>                   rt_thread_entry1,<br>                   RT_NULL,<br>                   &amp;thread1_stack[<span class=\"hljs-number\">0</span>],<br>                   <span class=\"hljs-keyword\">sizeof</span>(thread1_stack),<br>                   THREAD_PRIORITY, THREAD_TIMESLICE);<br>    rt_thread_startup(&amp;thread1);<br><br>    rt_thread_init(&amp;thread2,<br>                   <span class=\"hljs-string\">&quot;thread2&quot;</span>,<br>                   rt_thread_entry2,<br>                   RT_NULL,<br>                   &amp;thread2_stack[<span class=\"hljs-number\">0</span>],<br>                   <span class=\"hljs-keyword\">sizeof</span>(thread2_stack),<br>                   THREAD_PRIORITY<span class=\"hljs-number\">-1</span>, THREAD_TIMESLICE);<br>    rt_thread_startup(&amp;thread2);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br><span class=\"hljs-comment\">/* 导出到 MSH 命令列表中 */</span><br>MSH_CMD_EXPORT(mutex_sample, mutex sample);<br></code></pre></td></tr></table></figure>\n\n<p>线程 1 与线程 2 中均使用互斥量保护对 2 个 number 的操作（倘若将线程 1 中的获取、释放互斥量语句注释掉，线程 1 将对 number 不再做保护），仿真运行结果如下：</p>\n<figure class=\"highlight livescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livescript\"><span class=\"hljs-string\">\\</span> | /<br>- RT -     Thread Operating System<br> / | <span class=\"hljs-string\">\\</span>     <span class=\"hljs-number\">3.1</span>.<span class=\"hljs-number\">0</span> build Aug <span class=\"hljs-number\">24</span> <span class=\"hljs-number\">2018</span><br> <span class=\"hljs-number\">2006</span> - <span class=\"hljs-number\">2018</span> Copyright <span class=\"hljs-keyword\">by</span> rt-thread team<br>msh &gt;mutex_sample<br>msh &gt;mutex protect ,number1 = mumber2 <span class=\"hljs-keyword\">is</span> <span class=\"hljs-number\">1</span><br>mutex protect ,number1 = mumber2 <span class=\"hljs-keyword\">is</span> <span class=\"hljs-number\">2</span><br>mutex protect ,number1 = mumber2 <span class=\"hljs-keyword\">is</span> <span class=\"hljs-number\">3</span><br>mutex protect ,number1 = mumber2 <span class=\"hljs-keyword\">is</span> <span class=\"hljs-number\">4</span><br>…<br>mutex protect ,number1 = mumber2 <span class=\"hljs-keyword\">is</span> <span class=\"hljs-number\">48</span><br>mutex protect ,number1 = mumber2 <span class=\"hljs-keyword\">is</span> <span class=\"hljs-number\">49</span><br></code></pre></td></tr></table></figure>\n\n<p>线程使用互斥量保护对两个 number 的操作，使 number 值保持一致。</p>\n<p>互斥量的另一个例子见下面的代码，这个例子将创建 3 个动态线程以检查持有互斥量时，持有的线程优先级是否被调整到等待线程优先级中的最高优先级。</p>\n<p><strong>防止优先级翻转特性例程</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;rtthread.h&gt;</span></span><br><br><span class=\"hljs-comment\">/* 指向线程控制块的指针 */</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">rt_thread_t</span> tid1 = RT_NULL;<br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">rt_thread_t</span> tid2 = RT_NULL;<br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">rt_thread_t</span> tid3 = RT_NULL;<br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">rt_mutex_t</span> mutex = RT_NULL;<br><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> THREAD_PRIORITY       10</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> THREAD_STACK_SIZE     512</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> THREAD_TIMESLICE    5</span><br><br><span class=\"hljs-comment\">/* 线程 1 入口 */</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">thread1_entry</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span> *parameter)</span><br>&#123;<br>    <span class=\"hljs-comment\">/* 先让低优先级线程运行 */</span><br>    rt_thread_mdelay(<span class=\"hljs-number\">100</span>);<br><br>    <span class=\"hljs-comment\">/* 此时 thread3 持有 mutex，并且 thread2 等待持有 mutex */</span><br><br>    <span class=\"hljs-comment\">/* 检查 thread2 与 thread3 的优先级情况 */</span><br>    <span class=\"hljs-keyword\">if</span> (tid2-&gt;current_priority != tid3-&gt;current_priority)<br>    &#123;<br>        <span class=\"hljs-comment\">/* 优先级不相同，测试失败 */</span><br>        rt_kprintf(<span class=\"hljs-string\">&quot;the priority of thread2 is: %d\\n&quot;</span>, tid2-&gt;current_priority);<br>        rt_kprintf(<span class=\"hljs-string\">&quot;the priority of thread3 is: %d\\n&quot;</span>, tid3-&gt;current_priority);<br>        rt_kprintf(<span class=\"hljs-string\">&quot;test failed.\\n&quot;</span>);<br>        <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span><br>    &#123;<br>        rt_kprintf(<span class=\"hljs-string\">&quot;the priority of thread2 is: %d\\n&quot;</span>, tid2-&gt;current_priority);<br>        rt_kprintf(<span class=\"hljs-string\">&quot;the priority of thread3 is: %d\\n&quot;</span>, tid3-&gt;current_priority);<br>        rt_kprintf(<span class=\"hljs-string\">&quot;test OK.\\n&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">/* 线程 2 入口 */</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">thread2_entry</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span> *parameter)</span><br>&#123;<br>    <span class=\"hljs-type\">rt_err_t</span> result;<br><br>    rt_kprintf(<span class=\"hljs-string\">&quot;the priority of thread2 is: %d\\n&quot;</span>, tid2-&gt;current_priority);<br><br>    <span class=\"hljs-comment\">/* 先让低优先级线程运行 */</span><br>    rt_thread_mdelay(<span class=\"hljs-number\">50</span>);<br><br>    <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">     * 试图持有互斥锁，此时 thread3 持有，应把 thread3 的优先级提升</span><br><span class=\"hljs-comment\">     * 到 thread2 相同的优先级</span><br><span class=\"hljs-comment\">     */</span><br>    result = rt_mutex_take(mutex, RT_WAITING_FOREVER);<br><br>    <span class=\"hljs-keyword\">if</span> (result == RT_EOK)<br>    &#123;<br>        <span class=\"hljs-comment\">/* 释放互斥锁 */</span><br>        rt_mutex_release(mutex);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">/* 线程 3 入口 */</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">thread3_entry</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span> *parameter)</span><br>&#123;<br>    <span class=\"hljs-type\">rt_tick_t</span> tick;<br>    <span class=\"hljs-type\">rt_err_t</span> result;<br><br>    rt_kprintf(<span class=\"hljs-string\">&quot;the priority of thread3 is: %d\\n&quot;</span>, tid3-&gt;current_priority);<br><br>    result = rt_mutex_take(mutex, RT_WAITING_FOREVER);<br>    <span class=\"hljs-keyword\">if</span> (result != RT_EOK)<br>    &#123;<br>        rt_kprintf(<span class=\"hljs-string\">&quot;thread3 take a mutex, failed.\\n&quot;</span>);<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 做一个长时间的循环，500ms */</span><br>    tick = rt_tick_get();<br>    <span class=\"hljs-keyword\">while</span> (rt_tick_get() - tick &lt; (RT_TICK_PER_SECOND / <span class=\"hljs-number\">2</span>)) ;<br><br>    rt_mutex_release(mutex);<br>&#125;<br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">pri_inversion</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>    <span class=\"hljs-comment\">/* 创建互斥锁 */</span><br>    mutex = rt_mutex_create(<span class=\"hljs-string\">&quot;mutex&quot;</span>, RT_IPC_FLAG_FIFO);<br>    <span class=\"hljs-keyword\">if</span> (mutex == RT_NULL)<br>    &#123;<br>        rt_kprintf(<span class=\"hljs-string\">&quot;create dynamic mutex failed.\\n&quot;</span>);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 创建线程 1 */</span><br>    tid1 = rt_thread_create(<span class=\"hljs-string\">&quot;thread1&quot;</span>,<br>                            thread1_entry,<br>                            RT_NULL,<br>                            THREAD_STACK_SIZE,<br>                            THREAD_PRIORITY - <span class=\"hljs-number\">1</span>, THREAD_TIMESLICE);<br>    <span class=\"hljs-keyword\">if</span> (tid1 != RT_NULL)<br>         rt_thread_startup(tid1);<br><br>    <span class=\"hljs-comment\">/* 创建线程 2 */</span><br>    tid2 = rt_thread_create(<span class=\"hljs-string\">&quot;thread2&quot;</span>,<br>                            thread2_entry,<br>                            RT_NULL,<br>                            THREAD_STACK_SIZE,<br>                            THREAD_PRIORITY, THREAD_TIMESLICE);<br>    <span class=\"hljs-keyword\">if</span> (tid2 != RT_NULL)<br>        rt_thread_startup(tid2);<br><br>    <span class=\"hljs-comment\">/* 创建线程 3 */</span><br>    tid3 = rt_thread_create(<span class=\"hljs-string\">&quot;thread3&quot;</span>,<br>                            thread3_entry,<br>                            RT_NULL,<br>                            THREAD_STACK_SIZE,<br>                            THREAD_PRIORITY + <span class=\"hljs-number\">1</span>, THREAD_TIMESLICE);<br>    <span class=\"hljs-keyword\">if</span> (tid3 != RT_NULL)<br>        rt_thread_startup(tid3);<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br><span class=\"hljs-comment\">/* 导出到 msh 命令列表中 */</span><br>MSH_CMD_EXPORT(pri_inversion, prio_inversion sample);<br></code></pre></td></tr></table></figure>\n\n<p>仿真运行结果如下：</p>\n<figure class=\"highlight subunit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs subunit\">\\ | /<br>- RT -     Thread Operating System<br> / | \\     3.1.0 build Aug 27 2018<br> 2006 - 2018 Copyright by rt-thread team<br>msh &gt;pri_inversion<br>the priority of thread2 is: 10<br>the priority of thread3 is: 11<br>the priority of thread2 is: 10<br>the priority of thread3 is: 10<br><span class=\"hljs-keyword\">test </span>OK.<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"事件集Event\"><a href=\"#事件集Event\" class=\"headerlink\" title=\"事件集Event\"></a>事件集Event</h2><p>一个事件集可以包含多个事件，利用事件集可以完成<strong>一对多</strong>，<strong>多对多</strong>，<strong>多对一</strong>的线程间同步。</p>\n<p>这种多个事件的集合可以用一个 32 位无符号整型变量来表示，变量的每一位代表一个事件，线程通过 “逻辑与” 或“逻辑或”将一个或多个事件关联起来，形成事件组合。</p>\n<ul>\n<li>事件的 “逻辑或” 也称为是独立型同步，指的是线程与任何事件之一发生同步；</li>\n<li>事件 “逻辑与” 也称为是关联型同步，指的是线程与若干事件都发生同步。</li>\n<li>事件只与线程相关，事件间相互独立：每个线程可拥有 32 个事件标志，采用一个 32 bit 无符号整型数进行记录，每一个 bit 代表一个事件；</li>\n<li>事件仅用于同步，不提供数据传输功能；</li>\n<li>事件无排队性，即多次向线程发送同一事件 (如果线程还未来得及读走)，其效果等同于只发送一次。</li>\n</ul>\n<p><img src=\"/2021/42e53028/06event_work.png\" alt=\"事件集工作示意图\"></p>\n<p>线程 #1 的事件标志中第 1 位和第 30 位被置位，如果事件信息标记位设为逻辑与，则表示线程 #1 只有在事件 1 和事件 30 都发生以后才会被触发唤醒，如果事件信息标记位设为逻辑或，则事件 1 或事件 30 中的任意一个发生都会触发唤醒线程 #1。如果信息标记同时设置了清除标记位，则当线程 #1 唤醒后将主动把事件 1 和事件 30 清为零，否则事件标志将依然存在（即置 1）。</p>\n<h3 id=\"事件集API\"><a href=\"#事件集API\" class=\"headerlink\" title=\"事件集API\"></a>事件集API</h3><p><img src=\"/2021/42e53028/06event_ops.png\" alt=\"事件相关接口\"></p>\n<h3 id=\"创建和删除事件集-create\"><a href=\"#创建和删除事件集-create\" class=\"headerlink\" title=\"创建和删除事件集-create\"></a>创建和删除事件集-create</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_event_t</span> <span class=\"hljs-title function_\">rt_event_create</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name, <span class=\"hljs-type\">rt_uint8_t</span> flag)</span>;<br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>name</td>\n<td>事件集的名称</td>\n</tr>\n<tr>\n<td>flag</td>\n<td>事件集的标志，它可以取如下数值： RT_IPC_FLAG_FIFO 或 RT_IPC_FLAG_PRIO</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>RT_NULL</td>\n<td>创建失败</td>\n</tr>\n<tr>\n<td>事件对象的句柄</td>\n<td>创建成功</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_err_t</span> <span class=\"hljs-title function_\">rt_event_delete</span><span class=\"hljs-params\">(<span class=\"hljs-type\">rt_event_t</span> event)</span>;<br></code></pre></td></tr></table></figure>\n\n<p>在删除前会唤醒所有挂起在该事件集上的线程（线程的返回值是 - RT_ERROR），然后释放事件集对象占用的内存块。</p>\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>event</td>\n<td>事件集对象的句柄</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>RT_EOK</td>\n<td>成功</td>\n</tr>\n</tbody></table>\n<h3 id=\"初始化和脱离事件集-init\"><a href=\"#初始化和脱离事件集-init\" class=\"headerlink\" title=\"初始化和脱离事件集-init\"></a>初始化和脱离事件集-init</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_err_t</span> <span class=\"hljs-title function_\">rt_event_init</span><span class=\"hljs-params\">(<span class=\"hljs-type\">rt_event_t</span> event, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name, <span class=\"hljs-type\">rt_uint8_t</span> flag)</span>;<br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>event</td>\n<td>事件集对象的句柄</td>\n</tr>\n<tr>\n<td>name</td>\n<td>事件集的名称</td>\n</tr>\n<tr>\n<td>flag</td>\n<td>事件集的标志，它可以取如下数值： RT_IPC_FLAG_FIFO 或 RT_IPC_FLAG_PRIO</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>RT_EOK</td>\n<td>成功</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_err_t</span> <span class=\"hljs-title function_\">rt_event_detach</span><span class=\"hljs-params\">(<span class=\"hljs-type\">rt_event_t</span> event)</span>;<br></code></pre></td></tr></table></figure>\n\n<p>用户调用这个函数时，系统首先唤醒所有挂在该事件集等待队列上的线程（线程的返回值是 - RT_ERROR），然后将该事件集从内核对象管理器中脱离。</p>\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>event</td>\n<td>事件集对象的句柄</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>RT_EOK</td>\n<td>成功</td>\n</tr>\n</tbody></table>\n<h3 id=\"发送事件-send\"><a href=\"#发送事件-send\" class=\"headerlink\" title=\"发送事件-send\"></a>发送事件-send</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_err_t</span> <span class=\"hljs-title function_\">rt_event_send</span><span class=\"hljs-params\">(<span class=\"hljs-type\">rt_event_t</span> event, <span class=\"hljs-type\">rt_uint32_t</span> <span class=\"hljs-built_in\">set</span>)</span>;<br></code></pre></td></tr></table></figure>\n\n<p>使用该函数接口时，通过参数 set 指定的事件标志来设定 event 事件集对象的事件标志值，然后遍历等待在 event 事件集对象上的等待线程链表，判断是否有线程的事件激活要求与当前 event 对象事件标志值匹配，如果有，则唤醒该线程。</p>\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>event</td>\n<td>事件集对象的句柄</td>\n</tr>\n<tr>\n<td>set</td>\n<td>发送的一个或多个事件的标志值,它可以取如下数值： RT_IPC_FLAG_FIFO 或 RT_IPC_FLAG_PRIO</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>RT_EOK</td>\n<td>成功</td>\n</tr>\n</tbody></table>\n<h3 id=\"接收事件-recv\"><a href=\"#接收事件-recv\" class=\"headerlink\" title=\"接收事件-recv\"></a>接收事件-recv</h3><p>内核使用 32 位的无符号整数来标识事件集，它的每一位代表一个事件，因此一个事件集对象可同时等待接收 32 个事件.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_err_t</span> <span class=\"hljs-title function_\">rt_event_recv</span><span class=\"hljs-params\">(<span class=\"hljs-type\">rt_event_t</span> event,</span><br><span class=\"hljs-params\">                           <span class=\"hljs-type\">rt_uint32_t</span> <span class=\"hljs-built_in\">set</span>,</span><br><span class=\"hljs-params\">                           <span class=\"hljs-type\">rt_uint8_t</span> option,</span><br><span class=\"hljs-params\">                           <span class=\"hljs-type\">rt_int32_t</span> timeout,</span><br><span class=\"hljs-params\">                           <span class=\"hljs-type\">rt_uint32_t</span>* recved)</span>;<br></code></pre></td></tr></table></figure>\n\n<p>当用户调用这个接口时，系统首先根据 set 参数和接收选项 option 来判断它要接收的事件是否发生，如果已经发生，则根据参数 option 上是否设置有 RT_EVENT_FLAG_CLEAR 来决定是否重置事件的相应标志位，然后返回（其中 recved 参数返回接收到的事件）；如果没有发生，则把等待的 set 和 option 参数填入线程本身的结构中，然后把线程挂起在此事件上，直到其等待的事件满足条件或等待时间超过指定的超时时间。如果超时时间设置为零，则表示当线程要接受的事件没有满足其要求时就不等待，而直接返回 - RT_ETIMEOUT。</p>\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>event</td>\n<td>事件集对象的句柄</td>\n</tr>\n<tr>\n<td>set</td>\n<td>接收线程感兴趣的事件</td>\n</tr>\n<tr>\n<td>option</td>\n<td>接收选项 <strong>可取值见下</strong></td>\n</tr>\n<tr>\n<td>timeout</td>\n<td>指定超时时间</td>\n</tr>\n<tr>\n<td>recved</td>\n<td>指向接收到的事件</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>RT_EOK</td>\n<td>成功</td>\n</tr>\n<tr>\n<td>-RT_ETIMEOUT</td>\n<td>超时</td>\n</tr>\n<tr>\n<td>-RT_ERROR</td>\n<td>错误</td>\n</tr>\n</tbody></table>\n<p>option 的值可取：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/* 选择 逻辑与 或 逻辑或 的方式接收事件 */</span><br>RT_EVENT_FLAG_OR<br>RT_EVENT_FLAG_AND<br><br><span class=\"hljs-comment\">/* 选择清除重置事件标志位 */</span><br>RT_EVENT_FLAG_CLEAR<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"事件集应用示例\"><a href=\"#事件集应用示例\" class=\"headerlink\" title=\"事件集应用示例\"></a>事件集应用示例</h2><p>这是事件集的应用例程，例子中初始化了一个事件集，两个线程。一个线程等待自己关心的事件发生，另外一个线程发送事件，如代码清单 6-5 例所示：</p>\n<p>事件集的使用例程</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;rtthread.h&gt;</span></span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> THREAD_PRIORITY      9</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> THREAD_TIMESLICE     5</span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> EVENT_FLAG3 (1 &lt;&lt; 3)</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> EVENT_FLAG5 (1 &lt;&lt; 5)</span><br><br><span class=\"hljs-comment\">/* 事件控制块 */</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">rt_event</span> <span class=\"hljs-title\">event</span>;</span><br><br>ALIGN(RT_ALIGN_SIZE)<br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">char</span> thread1_stack[<span class=\"hljs-number\">1024</span>];<br><span class=\"hljs-type\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">rt_thread</span> <span class=\"hljs-title\">thread1</span>;</span><br><br><span class=\"hljs-comment\">/* 线程 1 入口函数 */</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">thread1_recv_event</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span> *param)</span><br>&#123;<br>    <span class=\"hljs-type\">rt_uint32_t</span> e;<br><br>    <span class=\"hljs-comment\">/* 第一次接收事件，事件 3 或事件 5 任意一个可以触发线程 1，接收完后清除事件标志 */</span><br>    <span class=\"hljs-keyword\">if</span> (rt_event_recv(&amp;event, (EVENT_FLAG3 | EVENT_FLAG5),<br>                      RT_EVENT_FLAG_OR | RT_EVENT_FLAG_CLEAR,<br>                      RT_WAITING_FOREVER, &amp;e) == RT_EOK)<br>    &#123;<br>        rt_kprintf(<span class=\"hljs-string\">&quot;thread1: OR recv event 0x%x\\n&quot;</span>, e);<br>    &#125;<br><br>    rt_kprintf(<span class=\"hljs-string\">&quot;thread1: delay 1s to prepare the second event\\n&quot;</span>);<br>    rt_thread_mdelay(<span class=\"hljs-number\">1000</span>);<br><br>    <span class=\"hljs-comment\">/* 第二次接收事件，事件 3 和事件 5 均发生时才可以触发线程 1，接收完后清除事件标志 */</span><br>    <span class=\"hljs-keyword\">if</span> (rt_event_recv(&amp;event, (EVENT_FLAG3 | EVENT_FLAG5),<br>                      RT_EVENT_FLAG_AND | RT_EVENT_FLAG_CLEAR,<br>                      RT_WAITING_FOREVER, &amp;e) == RT_EOK)<br>    &#123;<br>        rt_kprintf(<span class=\"hljs-string\">&quot;thread1: AND recv event 0x%x\\n&quot;</span>, e);<br>    &#125;<br>    rt_kprintf(<span class=\"hljs-string\">&quot;thread1 leave.\\n&quot;</span>);<br>&#125;<br><br><br>ALIGN(RT_ALIGN_SIZE)<br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">char</span> thread2_stack[<span class=\"hljs-number\">1024</span>];<br><span class=\"hljs-type\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">rt_thread</span> <span class=\"hljs-title\">thread2</span>;</span><br><br><span class=\"hljs-comment\">/* 线程 2 入口 */</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">thread2_send_event</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span> *param)</span><br>&#123;<br>    rt_kprintf(<span class=\"hljs-string\">&quot;thread2: send event3\\n&quot;</span>);<br>    rt_event_send(&amp;event, EVENT_FLAG3);<br>    rt_thread_mdelay(<span class=\"hljs-number\">200</span>);<br><br>    rt_kprintf(<span class=\"hljs-string\">&quot;thread2: send event5\\n&quot;</span>);<br>    rt_event_send(&amp;event, EVENT_FLAG5);<br>    rt_thread_mdelay(<span class=\"hljs-number\">200</span>);<br><br>    rt_kprintf(<span class=\"hljs-string\">&quot;thread2: send event3\\n&quot;</span>);<br>    rt_event_send(&amp;event, EVENT_FLAG3);<br>    rt_kprintf(<span class=\"hljs-string\">&quot;thread2 leave.\\n&quot;</span>);<br>&#125;<br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">event_sample</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>    <span class=\"hljs-type\">rt_err_t</span> result;<br><br>    <span class=\"hljs-comment\">/* 初始化事件对象 */</span><br>    result = rt_event_init(&amp;event, <span class=\"hljs-string\">&quot;event&quot;</span>, RT_IPC_FLAG_FIFO);<br>    <span class=\"hljs-keyword\">if</span> (result != RT_EOK)<br>    &#123;<br>        rt_kprintf(<span class=\"hljs-string\">&quot;init event failed.\\n&quot;</span>);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>    &#125;<br><br>    rt_thread_init(&amp;thread1,<br>                   <span class=\"hljs-string\">&quot;thread1&quot;</span>,<br>                   thread1_recv_event,<br>                   RT_NULL,<br>                   &amp;thread1_stack[<span class=\"hljs-number\">0</span>],<br>                   <span class=\"hljs-keyword\">sizeof</span>(thread1_stack),<br>                   THREAD_PRIORITY - <span class=\"hljs-number\">1</span>, THREAD_TIMESLICE);<br>    rt_thread_startup(&amp;thread1);<br><br>    rt_thread_init(&amp;thread2,<br>                   <span class=\"hljs-string\">&quot;thread2&quot;</span>,<br>                   thread2_send_event,<br>                   RT_NULL,<br>                   &amp;thread2_stack[<span class=\"hljs-number\">0</span>],<br>                   <span class=\"hljs-keyword\">sizeof</span>(thread2_stack),<br>                   THREAD_PRIORITY, THREAD_TIMESLICE);<br>    rt_thread_startup(&amp;thread2);<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br><span class=\"hljs-comment\">/* 导出到 msh 命令列表中 */</span><br>MSH_CMD_EXPORT(event_sample, event sample);<br></code></pre></td></tr></table></figure>\n\n<p>仿真运行结果如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"> \\ | /<br>- RT -     Thread Operating System<br> / | \\     <span class=\"hljs-number\">3.1</span><span class=\"hljs-number\">.0</span> build Aug <span class=\"hljs-number\">24</span> <span class=\"hljs-number\">2018</span><br> <span class=\"hljs-number\">2006</span> - <span class=\"hljs-number\">2018</span> Copyright by rt-thread team<br>msh &gt;event_sample<br>thread2: send event3<br>thread1: OR recv event <span class=\"hljs-number\">0x8</span><br>thread1: delay <span class=\"hljs-number\">1</span>s to prepare the second event<br>msh &gt;thread2: send event5<br>thread2: send event3<br>thread2 leave.<br>thread1: AND recv event <span class=\"hljs-number\">0x28</span><br>thread1 leave.<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"笔记-2\"><a href=\"#笔记-2\" class=\"headerlink\" title=\"笔记\"></a>笔记</h2><p>Semaphore:值、数值</p>\n<p>Mutex:二值性、只能持有进程释放</p>\n<p>Event:32Bit、进行’’或’’和’’与’’操作</p>\n<ul>\n<li>在获得互斥量后，请尽快释放互斥量，并且在持有互斥量的过程中，不得再行更改持有互斥量线程的优先级。</li>\n<li>互斥量不能在中断服务例程中使用。</li>\n</ul>\n<h1 id=\"线程间通信\"><a href=\"#线程间通信\" class=\"headerlink\" title=\"线程间通信\"></a>线程间通信</h1><h2 id=\"邮箱Mailbox\"><a href=\"#邮箱Mailbox\" class=\"headerlink\" title=\"邮箱Mailbox\"></a>邮箱Mailbox</h2><p>邮箱用于线程间通信，特点是开销比较低，效率较高。邮箱中的每一封邮件只能容纳固定的 4 字节内容（针对 32 位处理系统，指针的大小即为 4 个字节，所以一封邮件恰好能够容纳一个指针）。</p>\n<p>如下图所示，线程或中断服务例程把一封 4 字节长度的邮件发送到邮箱中，而一个或多个线程可以从邮箱中接收这些邮件并进行处理。</p>\n<p><img src=\"/2021/42e53028/07mb_work.png\" alt=\"邮箱工作示意图\"></p>\n<h3 id=\"邮箱API\"><a href=\"#邮箱API\" class=\"headerlink\" title=\"邮箱API\"></a>邮箱API</h3><p><img src=\"/2021/42e53028/07mb_ops.png\" alt=\"邮箱相关接口\"></p>\n<h3 id=\"创建和删除邮箱-create\"><a href=\"#创建和删除邮箱-create\" class=\"headerlink\" title=\"创建和删除邮箱-create\"></a>创建和删除邮箱-create</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_mailbox_t</span> <span class=\"hljs-title function_\">rt_mb_create</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name, <span class=\"hljs-type\">rt_size_t</span> size, <span class=\"hljs-type\">rt_uint8_t</span> flag)</span>;<br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>name</td>\n<td>邮箱名称</td>\n</tr>\n<tr>\n<td>size</td>\n<td>邮箱容量</td>\n</tr>\n<tr>\n<td>flag</td>\n<td>邮箱标志，它可以取如下数值： RT_IPC_FLAG_FIFO 或 RT_IPC_FLAG_PRIO</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>RT_NULL</td>\n<td>创建失败</td>\n</tr>\n<tr>\n<td>邮箱对象的句柄</td>\n<td>创建成功</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_err_t</span> <span class=\"hljs-title function_\">rt_mb_delete</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">rt_mailbox_t</span> mb)</span>;<br></code></pre></td></tr></table></figure>\n\n<p>删除邮箱时，如果有线程被挂起在该邮箱对象上，内核先唤醒挂起在该邮箱上的所有线程（线程返回值是 - RT_ERROR），然后再释放邮箱使用的内存，最后删除邮箱对象。</p>\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>mb</td>\n<td>邮箱对象的句柄</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>RT_EOK</td>\n<td>成功</td>\n</tr>\n</tbody></table>\n<h3 id=\"初始化和脱离邮箱-init\"><a href=\"#初始化和脱离邮箱-init\" class=\"headerlink\" title=\"初始化和脱离邮箱-init\"></a>初始化和脱离邮箱-init</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_err_t</span> <span class=\"hljs-title function_\">rt_mb_init</span><span class=\"hljs-params\">(<span class=\"hljs-type\">rt_mailbox_t</span> mb,</span><br><span class=\"hljs-params\">                  <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name,</span><br><span class=\"hljs-params\">                  <span class=\"hljs-type\">void</span>* msgpool,</span><br><span class=\"hljs-params\">                  <span class=\"hljs-type\">rt_size_t</span> size,</span><br><span class=\"hljs-params\">                  <span class=\"hljs-type\">rt_uint8_t</span> flag)</span><br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>mb</td>\n<td>邮箱对象的句柄</td>\n</tr>\n<tr>\n<td>name</td>\n<td>邮箱名称</td>\n</tr>\n<tr>\n<td>msgpool</td>\n<td>缓冲区指针</td>\n</tr>\n<tr>\n<td>size</td>\n<td>邮箱容量</td>\n</tr>\n<tr>\n<td>flag</td>\n<td>邮箱标志，它可以取如下数值： RT_IPC_FLAG_FIFO 或 RT_IPC_FLAG_PRIO</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>RT_EOK</td>\n<td>成功</td>\n</tr>\n</tbody></table>\n<p>即如果 msgpool 指向的缓冲区的字节数是 N，那么邮箱容量应该是 N&#x2F;4。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_err_t</span> <span class=\"hljs-title function_\">rt_mb_detach</span><span class=\"hljs-params\">(<span class=\"hljs-type\">rt_mailbox_t</span> mb)</span>;<br></code></pre></td></tr></table></figure>\n\n<p>使用该函数接口后，内核先唤醒所有挂在该邮箱上的线程（线程获得返回值是 - RT_ERROR），然后将该邮箱对象从内核对象管理器中脱离。</p>\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>mb</td>\n<td>邮箱对象的句柄</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>RT_EOK</td>\n<td>成功</td>\n</tr>\n</tbody></table>\n<h3 id=\"发送邮件-send\"><a href=\"#发送邮件-send\" class=\"headerlink\" title=\"发送邮件-send\"></a>发送邮件-send</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_err_t</span> <span class=\"hljs-title function_\">rt_mb_send</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">rt_mailbox_t</span> mb, <span class=\"hljs-type\">rt_uint32_t</span> value)</span>;<br></code></pre></td></tr></table></figure>\n\n<p>发送的邮件可以是 32 位任意格式的数据，一个整型值或者一个指向缓冲区的指针。当邮箱中的邮件已经满时，发送邮件的线程或者中断程序会收到 -RT_EFULL 的返回值。</p>\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>mb</td>\n<td>邮箱对象的句柄</td>\n</tr>\n<tr>\n<td>value</td>\n<td>邮件内容</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>RT_EOK</td>\n<td>发送成功</td>\n</tr>\n<tr>\n<td>-RT_EFULL</td>\n<td>邮箱已经满了</td>\n</tr>\n</tbody></table>\n<h3 id=\"等待方式发送邮件-wait-send\"><a href=\"#等待方式发送邮件-wait-send\" class=\"headerlink\" title=\"等待方式发送邮件-wait send\"></a>等待方式发送邮件-wait send</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_err_t</span> <span class=\"hljs-title function_\">rt_mb_send_wait</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">rt_mailbox_t</span> mb,</span><br><span class=\"hljs-params\">                      <span class=\"hljs-type\">rt_uint32_t</span> value,</span><br><span class=\"hljs-params\">                      <span class=\"hljs-type\">rt_int32_t</span> timeout)</span>;<br></code></pre></td></tr></table></figure>\n\n<p>rt_mb_send_wait() 与 rt_mb_send() 的区别在于有等待时间，如果邮箱已经满了，那么发送线程将根据设定的 timeout 参数等待邮箱中因为收取邮件而空出空间。如果设置的超时时间到达依然没有空出空间，这时发送线程将被唤醒并返回错误码。</p>\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>mb</td>\n<td>邮箱对象的句柄</td>\n</tr>\n<tr>\n<td>value</td>\n<td>邮件内容</td>\n</tr>\n<tr>\n<td>timeout</td>\n<td>超时时间</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>RT_EOK</td>\n<td>发送成功</td>\n</tr>\n<tr>\n<td>-RT_ETIMEOUT</td>\n<td>超时</td>\n</tr>\n<tr>\n<td>-RT_ERROR</td>\n<td>失败，返回错误</td>\n</tr>\n</tbody></table>\n<h3 id=\"接收邮件-recv\"><a href=\"#接收邮件-recv\" class=\"headerlink\" title=\"接收邮件-recv\"></a>接收邮件-recv</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_err_t</span> <span class=\"hljs-title function_\">rt_mb_recv</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">rt_mailbox_t</span> mb, <span class=\"hljs-type\">rt_uint32_t</span>* value, <span class=\"hljs-type\">rt_int32_t</span> timeout)</span>;<br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>mb</td>\n<td>邮箱对象的句柄</td>\n</tr>\n<tr>\n<td>value</td>\n<td>邮件内容</td>\n</tr>\n<tr>\n<td>timeout</td>\n<td>超时时间</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>RT_EOK</td>\n<td>发送成功</td>\n</tr>\n<tr>\n<td>-RT_ETIMEOUT</td>\n<td>超时</td>\n</tr>\n<tr>\n<td>-RT_ERROR</td>\n<td>失败，返回错误</td>\n</tr>\n</tbody></table>\n<h2 id=\"邮箱应用示例\"><a href=\"#邮箱应用示例\" class=\"headerlink\" title=\"邮箱应用示例\"></a>邮箱应用示例</h2><p>这是一个邮箱的应用例程，初始化 2 个静态线程，一个静态的邮箱对象，其中一个线程往邮箱中发送邮件，一个线程往邮箱中收取邮件。如下代码所示：</p>\n<p>邮箱的使用例程</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;rtthread.h&gt;</span></span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> THREAD_PRIORITY      10</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> THREAD_TIMESLICE     5</span><br><br><span class=\"hljs-comment\">/* 邮箱控制块 */</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">rt_mailbox</span> <span class=\"hljs-title\">mb</span>;</span><br><span class=\"hljs-comment\">/* 用于放邮件的内存池 */</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">char</span> mb_pool[<span class=\"hljs-number\">128</span>];<br><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">char</span> mb_str1[] = <span class=\"hljs-string\">&quot;I&#x27;m a mail!&quot;</span>;<br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">char</span> mb_str2[] = <span class=\"hljs-string\">&quot;this is another mail!&quot;</span>;<br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">char</span> mb_str3[] = <span class=\"hljs-string\">&quot;over&quot;</span>;<br><br>ALIGN(RT_ALIGN_SIZE)<br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">char</span> thread1_stack[<span class=\"hljs-number\">1024</span>];<br><span class=\"hljs-type\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">rt_thread</span> <span class=\"hljs-title\">thread1</span>;</span><br><br><span class=\"hljs-comment\">/* 线程 1 入口 */</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">thread1_entry</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span> *parameter)</span><br>&#123;<br>    <span class=\"hljs-type\">char</span> *str;<br><br>    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-number\">1</span>)<br>    &#123;<br>        rt_kprintf(<span class=\"hljs-string\">&quot;thread1: try to recv a mail\\n&quot;</span>);<br><br>        <span class=\"hljs-comment\">/* 从邮箱中收取邮件 */</span><br>        <span class=\"hljs-keyword\">if</span> (rt_mb_recv(&amp;mb, (<span class=\"hljs-type\">rt_uint32_t</span> *)&amp;str, RT_WAITING_FOREVER) == RT_EOK)<br>        &#123;<br>            rt_kprintf(<span class=\"hljs-string\">&quot;thread1: get a mail from mailbox, the content:%s\\n&quot;</span>, str);<br>            <span class=\"hljs-keyword\">if</span> (str == mb_str3)<br>                <span class=\"hljs-keyword\">break</span>;<br><br>            <span class=\"hljs-comment\">/* 延时 100ms */</span><br>            rt_thread_mdelay(<span class=\"hljs-number\">100</span>);<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-comment\">/* 执行邮箱对象脱离 */</span><br>    rt_mb_detach(&amp;mb);<br>&#125;<br><br>ALIGN(RT_ALIGN_SIZE)<br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">char</span> thread2_stack[<span class=\"hljs-number\">1024</span>];<br><span class=\"hljs-type\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">rt_thread</span> <span class=\"hljs-title\">thread2</span>;</span><br><br><span class=\"hljs-comment\">/* 线程 2 入口 */</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">thread2_entry</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span> *parameter)</span><br>&#123;<br>    <span class=\"hljs-type\">rt_uint8_t</span> count;<br><br>    count = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">while</span> (count &lt; <span class=\"hljs-number\">10</span>)<br>    &#123;<br>        count ++;<br>        <span class=\"hljs-keyword\">if</span> (count &amp; <span class=\"hljs-number\">0x1</span>)<br>        &#123;<br>            <span class=\"hljs-comment\">/* 发送 mb_str1 地址到邮箱中 */</span><br>            rt_mb_send(&amp;mb, (<span class=\"hljs-type\">rt_uint32_t</span>)&amp;mb_str1);<br>        &#125;<br>        <span class=\"hljs-keyword\">else</span><br>        &#123;<br>            <span class=\"hljs-comment\">/* 发送 mb_str2 地址到邮箱中 */</span><br>            rt_mb_send(&amp;mb, (<span class=\"hljs-type\">rt_uint32_t</span>)&amp;mb_str2);<br>        &#125;<br><br>        <span class=\"hljs-comment\">/* 延时 200ms */</span><br>        rt_thread_mdelay(<span class=\"hljs-number\">200</span>);<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 发送邮件告诉线程 1，线程 2 已经运行结束 */</span><br>    rt_mb_send(&amp;mb, (<span class=\"hljs-type\">rt_uint32_t</span>)&amp;mb_str3);<br>&#125;<br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">mailbox_sample</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>    <span class=\"hljs-type\">rt_err_t</span> result;<br><br>    <span class=\"hljs-comment\">/* 初始化一个 mailbox */</span><br>    result = rt_mb_init(&amp;mb,<br>                        <span class=\"hljs-string\">&quot;mbt&quot;</span>,                      <span class=\"hljs-comment\">/* 名称是 mbt */</span><br>                        &amp;mb_pool[<span class=\"hljs-number\">0</span>],                <span class=\"hljs-comment\">/* 邮箱用到的内存池是 mb_pool */</span><br>                        <span class=\"hljs-keyword\">sizeof</span>(mb_pool) / <span class=\"hljs-number\">4</span>,        <span class=\"hljs-comment\">/* 邮箱中的邮件数目，因为一封邮件占 4 字节 */</span><br>                        RT_IPC_FLAG_FIFO);          <span class=\"hljs-comment\">/* 采用 FIFO 方式进行线程等待 */</span><br>    <span class=\"hljs-keyword\">if</span> (result != RT_EOK)<br>    &#123;<br>        rt_kprintf(<span class=\"hljs-string\">&quot;init mailbox failed.\\n&quot;</span>);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>    &#125;<br><br>    rt_thread_init(&amp;thread1,<br>                   <span class=\"hljs-string\">&quot;thread1&quot;</span>,<br>                   thread1_entry,<br>                   RT_NULL,<br>                   &amp;thread1_stack[<span class=\"hljs-number\">0</span>],<br>                   <span class=\"hljs-keyword\">sizeof</span>(thread1_stack),<br>                   THREAD_PRIORITY, THREAD_TIMESLICE);<br>    rt_thread_startup(&amp;thread1);<br><br>    rt_thread_init(&amp;thread2,<br>                   <span class=\"hljs-string\">&quot;thread2&quot;</span>,<br>                   thread2_entry,<br>                   RT_NULL,<br>                   &amp;thread2_stack[<span class=\"hljs-number\">0</span>],<br>                   <span class=\"hljs-keyword\">sizeof</span>(thread2_stack),<br>                   THREAD_PRIORITY, THREAD_TIMESLICE);<br>    rt_thread_startup(&amp;thread2);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br><span class=\"hljs-comment\">/* 导出到 msh 命令列表中 */</span><br>MSH_CMD_EXPORT(mailbox_sample, mailbox sample);<br></code></pre></td></tr></table></figure>\n\n<p>仿真运行结果如下：</p>\n<figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vbnet\"> \\ | /<br>- RT -     Thread Operating System<br> / | \\     <span class=\"hljs-number\">3.1</span>.<span class=\"hljs-number\">0</span> build Aug <span class=\"hljs-number\">27</span> <span class=\"hljs-number\">2018</span><br> <span class=\"hljs-number\">2006</span> - <span class=\"hljs-number\">2018</span> Copyright <span class=\"hljs-keyword\">by</span> rt-thread team<br>msh &gt;mailbox_sample<br><span class=\"hljs-symbol\">thread1:</span> <span class=\"hljs-keyword\">try</span> <span class=\"hljs-keyword\">to</span> recv a mail<br><span class=\"hljs-symbol\">thread1:</span> <span class=\"hljs-keyword\">get</span> a mail <span class=\"hljs-keyword\">from</span> mailbox, the content:I<span class=\"hljs-comment\">&#x27;m a mail!</span><br>msh &gt;thread1: <span class=\"hljs-keyword\">try</span> <span class=\"hljs-keyword\">to</span> recv a mail<br><span class=\"hljs-symbol\">thread1:</span> <span class=\"hljs-keyword\">get</span> a mail <span class=\"hljs-keyword\">from</span> mailbox, the content:this <span class=\"hljs-built_in\">is</span> another mail!<br>…<br><span class=\"hljs-symbol\">thread1:</span> <span class=\"hljs-keyword\">try</span> <span class=\"hljs-keyword\">to</span> recv a mail<br><span class=\"hljs-symbol\">thread1:</span> <span class=\"hljs-keyword\">get</span> a mail <span class=\"hljs-keyword\">from</span> mailbox, the content:this <span class=\"hljs-built_in\">is</span> another mail!<br><span class=\"hljs-symbol\">thread1:</span> <span class=\"hljs-keyword\">try</span> <span class=\"hljs-keyword\">to</span> recv a mail<br><span class=\"hljs-symbol\">thread1:</span> <span class=\"hljs-keyword\">get</span> a mail <span class=\"hljs-keyword\">from</span> mailbox, the content:over<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"消息队列Messagequeue\"><a href=\"#消息队列Messagequeue\" class=\"headerlink\" title=\"消息队列Messagequeue\"></a>消息队列Messagequeue</h2><p>消息队列是另一种常用的线程间通讯方式，是邮箱的扩展(消息队列：不固定长度的消息)。可以应用在多种场合：线程间的消息交换、使用串口接收不定长数据等。</p>\n<p>线程或中断服务例程可以将一条或多条消息放入消息队列中。同样，一个或多个线程也可以从消息队列中获得消息。当有多个消息发送到消息队列时，通常将先进入消息队列的消息先传给线程，也就是说，线程先得到的是最先进入消息队列的消息，即先进先出原则 (FIFO)。</p>\n<ul>\n<li>消息框含有消息头（用于链表连接）</li>\n</ul>\n<p><img src=\"/2021/42e53028/07msg_work.png\" alt=\"消息队列工作示意图\"></p>\n<p>消息队列和邮箱的明显不同是消息的长度并不限定在 4 个字节以内；另外，消息队列也包括了一个发送紧急消息的函数接口。但是当创建的是一个所有消息的最大长度是 4 字节的消息队列时，消息队列对象将蜕化成邮箱。</p>\n<h3 id=\"消息队列API\"><a href=\"#消息队列API\" class=\"headerlink\" title=\"消息队列API\"></a>消息队列API</h3><p><img src=\"/2021/42e53028/07msg_ops.png\" alt=\"消息队列相关接口\"></p>\n<h3 id=\"创建和删除消息队列-create\"><a href=\"#创建和删除消息队列-create\" class=\"headerlink\" title=\"创建和删除消息队列-create\"></a>创建和删除消息队列-create</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_mq_t</span> <span class=\"hljs-title function_\">rt_mq_create</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name, <span class=\"hljs-type\">rt_size_t</span> msg_size,</span><br><span class=\"hljs-params\">            <span class=\"hljs-type\">rt_size_t</span> max_msgs, <span class=\"hljs-type\">rt_uint8_t</span> flag)</span>;<br></code></pre></td></tr></table></figure>\n\n<p>消息队列内存的大小 &#x3D;[消息大小+消息头（用于链表连接）的大小]X消息队列最大个数</p>\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>name</td>\n<td>消息队列的名称</td>\n</tr>\n<tr>\n<td>msg_size</td>\n<td>消息队列中一条消息的最大长度，单位字节</td>\n</tr>\n<tr>\n<td>max_msgs</td>\n<td>消息队列的最大个数</td>\n</tr>\n<tr>\n<td>flag</td>\n<td>消息队列采用的等待方式，它可以取如下数值： RT_IPC_FLAG_FIFO 或 RT_IPC_FLAG_PRIO</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>RT_EOK</td>\n<td>发送成功</td>\n</tr>\n<tr>\n<td>消息队列对象的句柄</td>\n<td>成功</td>\n</tr>\n<tr>\n<td>RT_NULL</td>\n<td>失败</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_err_t</span> <span class=\"hljs-title function_\">rt_mq_delete</span><span class=\"hljs-params\">(<span class=\"hljs-type\">rt_mq_t</span> mq)</span>;<br></code></pre></td></tr></table></figure>\n\n<p>删除消息队列时，如果有线程被挂起在该消息队列等待队列上，则内核先唤醒挂起在该消息等待队列上的所有线程（线程返回值是 - RT_ERROR），然后再释放消息队列使用的内存，最后删除消息队列对象。</p>\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>mq</td>\n<td>消息队列对象的句柄</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>RT_EOK</td>\n<td>成功</td>\n</tr>\n</tbody></table>\n<h3 id=\"初始化和脱离消息队列-init\"><a href=\"#初始化和脱离消息队列-init\" class=\"headerlink\" title=\"初始化和脱离消息队列-init\"></a>初始化和脱离消息队列-init</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_err_t</span> <span class=\"hljs-title function_\">rt_mq_init</span><span class=\"hljs-params\">(<span class=\"hljs-type\">rt_mq_t</span> mq, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name,</span><br><span class=\"hljs-params\">                        <span class=\"hljs-type\">void</span> *msgpool, <span class=\"hljs-type\">rt_size_t</span> msg_size,</span><br><span class=\"hljs-params\">                        <span class=\"hljs-type\">rt_size_t</span> pool_size, <span class=\"hljs-type\">rt_uint8_t</span> flag)</span>;<br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>mq</td>\n<td>消息队列对象的句柄</td>\n</tr>\n<tr>\n<td>name</td>\n<td>消息队列的名称</td>\n</tr>\n<tr>\n<td>msgpool</td>\n<td>指向存放消息的缓冲区的指针</td>\n</tr>\n<tr>\n<td>msg_size</td>\n<td>消息队列中一条消息的最大长度，单位字节</td>\n</tr>\n<tr>\n<td>pool_size</td>\n<td>存放消息的缓冲区大小</td>\n</tr>\n<tr>\n<td>flag</td>\n<td>消息队列采用的等待方式，它可以取如下数值： RT_IPC_FLAG_FIFO 或 RT_IPC_FLAG_PRIO</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>RT_EOK</td>\n<td>成功</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_err_t</span> <span class=\"hljs-title function_\">rt_mq_detach</span><span class=\"hljs-params\">(<span class=\"hljs-type\">rt_mq_t</span> mq)</span>;<br></code></pre></td></tr></table></figure>\n\n<p>使用该函数接口后，内核先唤醒所有挂在该消息等待队列对象上的线程（线程返回值是 -RT_ERROR），然后将该消息队列对象从内核对象管理器中脱离。</p>\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>mq</td>\n<td>消息队列对象的句柄</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>RT_EOK</td>\n<td>成功</td>\n</tr>\n</tbody></table>\n<h3 id=\"发送消息-send\"><a href=\"#发送消息-send\" class=\"headerlink\" title=\"发送消息-send\"></a>发送消息-send</h3><p><strong>线程</strong>或者<strong>中断服务程序</strong>都可以给消息队列发送消息。当发送消息时，消息队列对象先从空闲消息链表上取下一个空闲消息块，把线程或者中断服务程序发送的消息内容复制到消息块上，然后把该消息块挂到消息队列的尾部。当且仅当空闲消息链表上有可用的空闲消息块时，发送者才能成功发送消息；当空闲消息链表上无可用消息块，说明消息队列已满，此时，发送消息的的线程或者中断程序会收到一个错误码（-RT_EFULL）。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_err_t</span> <span class=\"hljs-title function_\">rt_mq_send</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">rt_mq_t</span> mq, <span class=\"hljs-type\">void</span>* buffer, <span class=\"hljs-type\">rt_size_t</span> size)</span>;<br></code></pre></td></tr></table></figure>\n\n<p>发送消息时，发送者需指定发送的消息队列的对象句柄（即指向消息队列控制块的指针），并且指定发送的消息内容以及消息大小。如下图所示，在发送一个普通消息之后，空闲消息链表上的队首消息被转移到了消息队列尾。</p>\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>mq</td>\n<td>消息队列对象的句柄</td>\n</tr>\n<tr>\n<td>buffer</td>\n<td>消息内容</td>\n</tr>\n<tr>\n<td>size</td>\n<td>消息大小</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>RT_EOK</td>\n<td>成功</td>\n</tr>\n<tr>\n<td>-RT_EFULL</td>\n<td>消息队列已满</td>\n</tr>\n<tr>\n<td>-RT_ERROR</td>\n<td>失败，表示发送的消息长度大于消息队列中消息的最大长度</td>\n</tr>\n</tbody></table>\n<h3 id=\"等待方式发送消息-wait\"><a href=\"#等待方式发送消息-wait\" class=\"headerlink\" title=\"等待方式发送消息-wait\"></a>等待方式发送消息-wait</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_err_t</span> <span class=\"hljs-title function_\">rt_mq_send_wait</span><span class=\"hljs-params\">(<span class=\"hljs-type\">rt_mq_t</span>     mq,</span><br><span class=\"hljs-params\">                         <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">void</span> *buffer,</span><br><span class=\"hljs-params\">                         <span class=\"hljs-type\">rt_size_t</span>   size,</span><br><span class=\"hljs-params\">                         <span class=\"hljs-type\">rt_int32_t</span>  timeout)</span>;<br></code></pre></td></tr></table></figure>\n\n<p>rt_mq_send_wait() 与 rt_mq_send() 的区别在于有等待时间，如果消息队列已经满了，那么发送线程将根据设定的 timeout 参数进行等待。如果设置的超时时间到达依然没有空出空间，这时发送线程将被唤醒并返回错误码。</p>\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>mq</td>\n<td>消息队列对象的句柄</td>\n</tr>\n<tr>\n<td>buffer</td>\n<td>消息内容</td>\n</tr>\n<tr>\n<td>size</td>\n<td>消息大小</td>\n</tr>\n<tr>\n<td>timeout</td>\n<td>超时时间</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>RT_EOK</td>\n<td>成功</td>\n</tr>\n<tr>\n<td>-RT_EFULL</td>\n<td>消息队列已满</td>\n</tr>\n<tr>\n<td>-RT_ERROR</td>\n<td>失败，表示发送的消息长度大于消息队列中消息的最大长度</td>\n</tr>\n</tbody></table>\n<h3 id=\"发送紧急消息-urgent\"><a href=\"#发送紧急消息-urgent\" class=\"headerlink\" title=\"发送紧急消息-urgent\"></a>发送紧急消息-urgent</h3><p>发送紧急消息的过程与发送消息几乎一样，唯一的不同是，当发送紧急消息时，从空闲消息链表上取下来的消息块不是挂到消息队列的队尾，而是挂到队首，这样，接收者就能够优先接收到紧急消息，从而及时进行消息处理。发送紧急消息的函数接口如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_err_t</span> <span class=\"hljs-title function_\">rt_mq_urgent</span><span class=\"hljs-params\">(<span class=\"hljs-type\">rt_mq_t</span> mq, <span class=\"hljs-type\">void</span>* buffer, <span class=\"hljs-type\">rt_size_t</span> size)</span>;<br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>mq</td>\n<td>消息队列对象的句柄</td>\n</tr>\n<tr>\n<td>buffer</td>\n<td>消息内容</td>\n</tr>\n<tr>\n<td>size</td>\n<td>消息大小</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>RT_EOK</td>\n<td>成功</td>\n</tr>\n<tr>\n<td>-RT_EFULL</td>\n<td>消息队列已满</td>\n</tr>\n<tr>\n<td>-RT_ERROR</td>\n<td>失败</td>\n</tr>\n</tbody></table>\n<h3 id=\"接收消息-recv\"><a href=\"#接收消息-recv\" class=\"headerlink\" title=\"接收消息-recv\"></a>接收消息-recv</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_err_t</span> <span class=\"hljs-title function_\">rt_mq_recv</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">rt_mq_t</span> mq, <span class=\"hljs-type\">void</span>* buffer,</span><br><span class=\"hljs-params\">                    <span class=\"hljs-type\">rt_size_t</span> size, <span class=\"hljs-type\">rt_int32_t</span> timeout)</span>;<br></code></pre></td></tr></table></figure>\n\n<p>接收消息时，接收者需指定存储消息的消息队列对象句柄，并且指定一个内存缓冲区，接收到的消息内容将被复制到该缓冲区里。此外，还需指定未能及时取到消息时的超时时间。</p>\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>mq</td>\n<td>消息队列对象的句柄</td>\n</tr>\n<tr>\n<td>buffer</td>\n<td>消息内容</td>\n</tr>\n<tr>\n<td>size</td>\n<td>消息大小</td>\n</tr>\n<tr>\n<td>timeout</td>\n<td>指定的超时时间</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>RT_EOK</td>\n<td>成功收到</td>\n</tr>\n<tr>\n<td>-RT_ETIMEOUT</td>\n<td>超时</td>\n</tr>\n<tr>\n<td>-RT_ERROR</td>\n<td>失败，返回错误</td>\n</tr>\n</tbody></table>\n<h2 id=\"消息队列应用示例\"><a href=\"#消息队列应用示例\" class=\"headerlink\" title=\"消息队列应用示例\"></a>消息队列应用示例</h2><p>这是一个消息队列的应用例程，例程中初始化了 2 个静态线程，一个线程会从消息队列中收取消息；另一个线程会定时给消息队列发送普通消息和紧急消息，如下代码所示：</p>\n<p>消息队列的使用例程</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;rtthread.h&gt;</span></span><br><br><span class=\"hljs-comment\">/* 消息队列控制块 */</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">rt_messagequeue</span> <span class=\"hljs-title\">mq</span>;</span><br><span class=\"hljs-comment\">/* 消息队列中用到的放置消息的内存池 */</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">rt_uint8_t</span> msg_pool[<span class=\"hljs-number\">2048</span>];<br><br>ALIGN(RT_ALIGN_SIZE)<br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">char</span> thread1_stack[<span class=\"hljs-number\">1024</span>];<br><span class=\"hljs-type\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">rt_thread</span> <span class=\"hljs-title\">thread1</span>;</span><br><span class=\"hljs-comment\">/* 线程 1 入口函数 */</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">thread1_entry</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span> *parameter)</span><br>&#123;<br>    <span class=\"hljs-type\">char</span> buf = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-type\">rt_uint8_t</span> cnt = <span class=\"hljs-number\">0</span>;<br><br>    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-number\">1</span>)<br>    &#123;<br>        <span class=\"hljs-comment\">/* 从消息队列中接收消息 */</span><br>        <span class=\"hljs-keyword\">if</span> (rt_mq_recv(&amp;mq, &amp;buf, <span class=\"hljs-keyword\">sizeof</span>(buf), RT_WAITING_FOREVER) == RT_EOK)<br>        &#123;<br>            rt_kprintf(<span class=\"hljs-string\">&quot;thread1: recv msg from msg queue, the content:%c\\n&quot;</span>, buf);<br>            <span class=\"hljs-keyword\">if</span> (cnt == <span class=\"hljs-number\">19</span>)<br>            &#123;<br>                <span class=\"hljs-keyword\">break</span>;<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-comment\">/* 延时 50ms */</span><br>        cnt++;<br>        rt_thread_mdelay(<span class=\"hljs-number\">50</span>);<br>    &#125;<br>    rt_kprintf(<span class=\"hljs-string\">&quot;thread1: detach mq \\n&quot;</span>);<br>    rt_mq_detach(&amp;mq);<br>&#125;<br><br>ALIGN(RT_ALIGN_SIZE)<br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">char</span> thread2_stack[<span class=\"hljs-number\">1024</span>];<br><span class=\"hljs-type\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">rt_thread</span> <span class=\"hljs-title\">thread2</span>;</span><br><span class=\"hljs-comment\">/* 线程 2 入口 */</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">thread2_entry</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span> *parameter)</span><br>&#123;<br>    <span class=\"hljs-type\">int</span> result;<br>    <span class=\"hljs-type\">char</span> buf = <span class=\"hljs-string\">&#x27;A&#x27;</span>;<br>    <span class=\"hljs-type\">rt_uint8_t</span> cnt = <span class=\"hljs-number\">0</span>;<br><br>    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-number\">1</span>)<br>    &#123;<br>        <span class=\"hljs-keyword\">if</span> (cnt == <span class=\"hljs-number\">8</span>)<br>        &#123;<br>            <span class=\"hljs-comment\">/* 发送紧急消息到消息队列中 */</span><br>            result = rt_mq_urgent(&amp;mq, &amp;buf, <span class=\"hljs-number\">1</span>);<br>            <span class=\"hljs-keyword\">if</span> (result != RT_EOK)<br>            &#123;<br>                rt_kprintf(<span class=\"hljs-string\">&quot;rt_mq_urgent ERR\\n&quot;</span>);<br>            &#125;<br>            <span class=\"hljs-keyword\">else</span><br>            &#123;<br>                rt_kprintf(<span class=\"hljs-string\">&quot;thread2: send urgent message - %c\\n&quot;</span>, buf);<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (cnt&gt;= <span class=\"hljs-number\">20</span>)<span class=\"hljs-comment\">/* 发送 20 次消息之后退出 */</span><br>        &#123;<br>            rt_kprintf(<span class=\"hljs-string\">&quot;message queue stop send, thread2 quit\\n&quot;</span>);<br>            <span class=\"hljs-keyword\">break</span>;<br>        &#125;<br>        <span class=\"hljs-keyword\">else</span><br>        &#123;<br>            <span class=\"hljs-comment\">/* 发送消息到消息队列中 */</span><br>            result = rt_mq_send(&amp;mq, &amp;buf, <span class=\"hljs-number\">1</span>);<br>            <span class=\"hljs-keyword\">if</span> (result != RT_EOK)<br>            &#123;<br>                rt_kprintf(<span class=\"hljs-string\">&quot;rt_mq_send ERR\\n&quot;</span>);<br>            &#125;<br><br>            rt_kprintf(<span class=\"hljs-string\">&quot;thread2: send message - %c\\n&quot;</span>, buf);<br>        &#125;<br>        buf++;<br>        cnt++;<br>        <span class=\"hljs-comment\">/* 延时 5ms */</span><br>        rt_thread_mdelay(<span class=\"hljs-number\">5</span>);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">/* 消息队列示例的初始化 */</span><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">msgq_sample</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>    <span class=\"hljs-type\">rt_err_t</span> result;<br><br>    <span class=\"hljs-comment\">/* 初始化消息队列 */</span><br>    result = rt_mq_init(&amp;mq,<br>                        <span class=\"hljs-string\">&quot;mqt&quot;</span>,<br>                        &amp;msg_pool[<span class=\"hljs-number\">0</span>],             <span class=\"hljs-comment\">/* 内存池指向 msg_pool */</span><br>                        <span class=\"hljs-number\">1</span>,                          <span class=\"hljs-comment\">/* 每个消息的大小是 1 字节 */</span><br>                        <span class=\"hljs-keyword\">sizeof</span>(msg_pool),        <span class=\"hljs-comment\">/* 内存池的大小是 msg_pool 的大小 */</span><br>                        RT_IPC_FLAG_FIFO);       <span class=\"hljs-comment\">/* 如果有多个线程等待，按照先来先得到的方法分配消息 */</span><br><br>    <span class=\"hljs-keyword\">if</span> (result != RT_EOK)<br>    &#123;<br>        rt_kprintf(<span class=\"hljs-string\">&quot;init message queue failed.\\n&quot;</span>);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>    &#125;<br><br>    rt_thread_init(&amp;thread1,<br>                   <span class=\"hljs-string\">&quot;thread1&quot;</span>,<br>                   thread1_entry,<br>                   RT_NULL,<br>                   &amp;thread1_stack[<span class=\"hljs-number\">0</span>],<br>                   <span class=\"hljs-keyword\">sizeof</span>(thread1_stack), <span class=\"hljs-number\">25</span>, <span class=\"hljs-number\">5</span>);<br>    rt_thread_startup(&amp;thread1);<br><br>    rt_thread_init(&amp;thread2,<br>                   <span class=\"hljs-string\">&quot;thread2&quot;</span>,<br>                   thread2_entry,<br>                   RT_NULL,<br>                   &amp;thread2_stack[<span class=\"hljs-number\">0</span>],<br>                   <span class=\"hljs-keyword\">sizeof</span>(thread2_stack), <span class=\"hljs-number\">25</span>, <span class=\"hljs-number\">5</span>);<br>    rt_thread_startup(&amp;thread2);<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br><span class=\"hljs-comment\">/* 导出到 msh 命令列表中 */</span><br>MSH_CMD_EXPORT(msgq_sample, msgq sample);<br></code></pre></td></tr></table></figure>\n\n<p>仿真运行结果如下：</p>\n<figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vbnet\">\\ | /<br>- RT -     Thread Operating System<br> / | \\     <span class=\"hljs-number\">3.1</span>.<span class=\"hljs-number\">0</span> build Aug <span class=\"hljs-number\">24</span> <span class=\"hljs-number\">2018</span><br> <span class=\"hljs-number\">2006</span> - <span class=\"hljs-number\">2018</span> Copyright <span class=\"hljs-keyword\">by</span> rt-thread team<br>msh &gt; msgq_sample<br>msh &gt;thread2: send message - A<br><span class=\"hljs-symbol\">thread1:</span> recv msg <span class=\"hljs-keyword\">from</span> msg queue, the content:A<br><span class=\"hljs-symbol\">thread2:</span> send message - B<br><span class=\"hljs-symbol\">thread2:</span> send message - C<br><span class=\"hljs-symbol\">thread2:</span> send message - D<br><span class=\"hljs-symbol\">thread2:</span> send message - E<br><span class=\"hljs-symbol\">thread1:</span> recv msg <span class=\"hljs-keyword\">from</span> msg queue, the content:B<br><span class=\"hljs-symbol\">thread2:</span> send message - F<br><span class=\"hljs-symbol\">thread2:</span> send message - G<br><span class=\"hljs-symbol\">thread2:</span> send message - H<br><span class=\"hljs-symbol\">thread2:</span> send urgent message - I<br><span class=\"hljs-symbol\">thread2:</span> send message - J<br><span class=\"hljs-symbol\">thread1:</span> recv msg <span class=\"hljs-keyword\">from</span> msg queue, the content:I<br><span class=\"hljs-symbol\">thread2:</span> send message - K<br><span class=\"hljs-symbol\">thread2:</span> send message - L<br><span class=\"hljs-symbol\">thread2:</span> send message - M<br><span class=\"hljs-symbol\">thread2:</span> send message - N<br><span class=\"hljs-symbol\">thread2:</span> send message - O<br><span class=\"hljs-symbol\">thread1:</span> recv msg <span class=\"hljs-keyword\">from</span> msg queue, the content:C<br><span class=\"hljs-symbol\">thread2:</span> send message - P<br><span class=\"hljs-symbol\">thread2:</span> send message - Q<br><span class=\"hljs-symbol\">thread2:</span> send message - R<br><span class=\"hljs-symbol\">thread2:</span> send message - S<br><span class=\"hljs-symbol\">thread2:</span> send message - T<br><span class=\"hljs-symbol\">thread1:</span> recv msg <span class=\"hljs-keyword\">from</span> msg queue, the content:D<br>message queue <span class=\"hljs-keyword\">stop</span> send, thread2 quit<br><span class=\"hljs-symbol\">thread1:</span> recv msg <span class=\"hljs-keyword\">from</span> msg queue, the content:E<br><span class=\"hljs-symbol\">thread1:</span> recv msg <span class=\"hljs-keyword\">from</span> msg queue, the content:F<br><span class=\"hljs-symbol\">thread1:</span> recv msg <span class=\"hljs-keyword\">from</span> msg queue, the content:G<br>…<br><span class=\"hljs-symbol\">thread1:</span> recv msg <span class=\"hljs-keyword\">from</span> msg queue, the content:T<br><span class=\"hljs-symbol\">thread1:</span> detach mq<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"信号Sigset\"><a href=\"#信号Sigset\" class=\"headerlink\" title=\"信号Sigset\"></a>信号Sigset</h2><p>信号（又称为软中断信号），在软件层次上是对中断机制的一种模拟，在原理上，一个线程收到一个信号与处理器收到一个中断请求可以说是类似的。</p>\n<p>应用程序(用户)能够使用的信号为 SIGUSR1（10）和 SIGUSR2（12）。</p>\n<p>信号本质是<strong>软中断</strong>，用来通知线程发生了异步事件，用做线程之间的异常通知、应急处理。一个线程不必通过任何操作来等待信号的到达，事实上，线程也不知道信号到底什么时候到达，线程之间可以互相通过调用 rt_thread_kill() 发送软中断信号。</p>\n<p>收到信号的线程对各种信号有不同的处理方法，在信号安装时设定 handler 参数，处理方法可以分为三类：</p>\n<ul>\n<li><p>第一种是类似中断的处理程序，对于需要处理的信号，线程可以指定处理函数，由该函数来处理。</p>\n</li>\n<li><p>第二种方法是，参数设为 SIG_IGN，忽略某个信号，对该信号不做任何处理，就像未发生过一样。 </p>\n</li>\n<li><p>第三种方法是，参数设为 SIG_DFL，系统会调用默认的处理函数_signal_default_handler()。</p>\n</li>\n</ul>\n<p>如下图所示，假设线程 1 需要对信号进行处理，首先线程 1 安装一个信号并解除阻塞，并在安装的同时设定了对信号的异常处理方式；然后其他线程可以给线程 1 发送信号，触发线程 1 对该信号的处理。</p>\n<p>当信号被传递给线程 1 时，如果它正处于挂起状态，那会把状态改为就绪状态去处理对应的信号。如果它正处于运行状态，那么会在它当前的线程栈基础上建立新栈帧空间去处理对应的信号，需要注意的是使用的线程栈大小也会相应增加。</p>\n<p><img src=\"/2021/42e53028/07signal_work.png\" alt=\"信号工作机制\"></p>\n<h3 id=\"信号API\"><a href=\"#信号API\" class=\"headerlink\" title=\"信号API\"></a>信号API</h3><p><img src=\"/2021/42e53028/07signal_ops.png\" alt=\"信号相关接口\"></p>\n<h3 id=\"安装信号-install\"><a href=\"#安装信号-install\" class=\"headerlink\" title=\"安装信号-install\"></a>安装信号-install</h3><p>如果线程要处理某一信号，那么就要在线程中安装该信号。安装信号主要用来确定信号值及线程针对该信号值的动作之间的映射关系，即线程将要处理哪个信号，该信号被传递给线程时，将执行何种操作。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_sighandler_t</span> <span class=\"hljs-title function_\">rt_signal_install</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> signo, <span class=\"hljs-type\">rt_sighandler_t</span>[] handler)</span>;<br></code></pre></td></tr></table></figure>\n\n<p>其中 rt_sighandler_t 是定义信号处理函数的函数指针类型。</p>\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>signo</td>\n<td>信号值（只有 SIGUSR1 和 SIGUSR2 是开放给用户使用的，下同）</td>\n</tr>\n<tr>\n<td>handler</td>\n<td>设置对信号值的处理方式 （函数指针）</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>SIG_ERR</td>\n<td>错误的信号</td>\n</tr>\n<tr>\n<td>安装信号前的 handler 值</td>\n<td>成功</td>\n</tr>\n</tbody></table>\n<h3 id=\"屏蔽信号-mask\"><a href=\"#屏蔽信号-mask\" class=\"headerlink\" title=\"屏蔽信号-mask\"></a>屏蔽信号-mask</h3><p>信号阻塞，也可以理解为屏蔽信号。如果该信号被阻塞，则该信号将不会递达给安装此信号的线程，也不会引发软中断处理。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">rt_signal_mask</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> signo)</span>;<br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>signo</td>\n<td>信号值</td>\n</tr>\n</tbody></table>\n<h3 id=\"解除信号屏蔽-unmask\"><a href=\"#解除信号屏蔽-unmask\" class=\"headerlink\" title=\"解除信号屏蔽-unmask\"></a>解除信号屏蔽-unmask</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">rt_signal_unmask</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> signo)</span>;<br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>signo</td>\n<td>信号值</td>\n</tr>\n</tbody></table>\n<h3 id=\"发送信号-kill\"><a href=\"#发送信号-kill\" class=\"headerlink\" title=\"发送信号-kill\"></a>发送信号-kill</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">rt_thread_kill</span><span class=\"hljs-params\">(<span class=\"hljs-type\">rt_thread_t</span> tid, <span class=\"hljs-type\">int</span> sig)</span>;<br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>tid</td>\n<td>接收信号的线程</td>\n</tr>\n<tr>\n<td>sig</td>\n<td>信号值</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>RT_EOK</td>\n<td>发送成功</td>\n</tr>\n<tr>\n<td>-RT_EINVAL</td>\n<td>参数错误</td>\n</tr>\n</tbody></table>\n<h3 id=\"等待信号-wait\"><a href=\"#等待信号-wait\" class=\"headerlink\" title=\"等待信号-wait\"></a>等待信号-wait</h3><p>等待 set 信号的到来，如果没有等到这个信号，则将线程挂起，直到等到这个信号或者等待时间超过指定的超时时间 timeout。如果等到了该信号，则将指向该信号体的指针存入 si，如下是等待信号的函数。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">rt_signal_wait</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">rt_sigset_t</span> *<span class=\"hljs-built_in\">set</span>,</span><br><span class=\"hljs-params\">                        <span class=\"hljs-type\">rt_siginfo_t</span>[] *si, <span class=\"hljs-type\">rt_int32_t</span> timeout)</span>;<br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>set</td>\n<td>指定等待的信号</td>\n</tr>\n<tr>\n<td>si</td>\n<td>指向存储等到信号信息的指针</td>\n</tr>\n<tr>\n<td>timeout</td>\n<td>指定的等待时间</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>RT_EOK</td>\n<td>等到信号</td>\n</tr>\n<tr>\n<td>-RT_ETIMEOUT</td>\n<td>超时</td>\n</tr>\n<tr>\n<td>-RT_EINVAL</td>\n<td>参数错误</td>\n</tr>\n</tbody></table>\n<h2 id=\"信号应用示例\"><a href=\"#信号应用示例\" class=\"headerlink\" title=\"信号应用示例\"></a>信号应用示例</h2><p>这是一个信号的应用例程，如下代码所示。此例程创建了 1 个线程，在安装信号时，信号处理方式设为自定义处理，定义的信号的处理函数为 thread1_signal_handler()。待此线程运行起来安装好信号之后，给此线程发送信号。此线程将接收到信号，并打印信息。</p>\n<p>信号使用例程</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;rtthread.h&gt;</span></span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> THREAD_PRIORITY         25</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> THREAD_STACK_SIZE       512</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> THREAD_TIMESLICE        5</span><br><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">rt_thread_t</span> tid1 = RT_NULL;<br><br><span class=\"hljs-comment\">/* 线程 1 的信号处理函数 */</span><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">thread1_signal_handler</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> sig)</span><br>&#123;<br>    rt_kprintf(<span class=\"hljs-string\">&quot;thread1 received signal %d\\n&quot;</span>, sig);<br>&#125;<br><br><span class=\"hljs-comment\">/* 线程 1 的入口函数 */</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">thread1_entry</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span> *parameter)</span><br>&#123;<br>    <span class=\"hljs-type\">int</span> cnt = <span class=\"hljs-number\">0</span>;<br><br>    <span class=\"hljs-comment\">/* 安装信号 */</span><br>    rt_signal_install(SIGUSR1, thread1_signal_handler);<br>    rt_signal_unmask(SIGUSR1);<br><br>    <span class=\"hljs-comment\">/* 运行 10 次 */</span><br>    <span class=\"hljs-keyword\">while</span> (cnt &lt; <span class=\"hljs-number\">10</span>)<br>    &#123;<br>        <span class=\"hljs-comment\">/* 线程 1 采用低优先级运行，一直打印计数值 */</span><br>        rt_kprintf(<span class=\"hljs-string\">&quot;thread1 count : %d\\n&quot;</span>, cnt);<br><br>        cnt++;<br>        rt_thread_mdelay(<span class=\"hljs-number\">100</span>);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">/* 信号示例的初始化 */</span><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">signal_sample</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>    <span class=\"hljs-comment\">/* 创建线程 1 */</span><br>    tid1 = rt_thread_create(<span class=\"hljs-string\">&quot;thread1&quot;</span>,<br>                            thread1_entry, RT_NULL,<br>                            THREAD_STACK_SIZE,<br>                            THREAD_PRIORITY, THREAD_TIMESLICE);<br><br>    <span class=\"hljs-keyword\">if</span> (tid1 != RT_NULL)<br>        rt_thread_startup(tid1);<br><br>    rt_thread_mdelay(<span class=\"hljs-number\">300</span>);<br><br>    <span class=\"hljs-comment\">/* 发送信号 SIGUSR1 给线程 1 */</span><br>    rt_thread_kill(tid1, SIGUSR1);<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br><span class=\"hljs-comment\">/* 导出到 msh 命令列表中 */</span><br>MSH_CMD_EXPORT(signal_sample, signal sample);<br></code></pre></td></tr></table></figure>\n\n<p>仿真运行结果如下：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"> <span class=\"hljs-string\">\\</span> <span class=\"hljs-string\">|</span> <span class=\"hljs-string\">/</span><br><span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">RT</span> <span class=\"hljs-bullet\">-</span>     <span class=\"hljs-string\">Thread</span> <span class=\"hljs-string\">Operating</span> <span class=\"hljs-string\">System</span><br> <span class=\"hljs-string\">/</span> <span class=\"hljs-string\">|</span> <span class=\"hljs-string\">\\</span>     <span class=\"hljs-number\">3.1</span><span class=\"hljs-number\">.0</span> <span class=\"hljs-string\">build</span> <span class=\"hljs-string\">Aug</span> <span class=\"hljs-number\">24</span> <span class=\"hljs-number\">2018</span><br> <span class=\"hljs-number\">2006</span> <span class=\"hljs-bullet\">-</span> <span class=\"hljs-number\">2018 </span><span class=\"hljs-string\">Copyright</span> <span class=\"hljs-string\">by</span> <span class=\"hljs-string\">rt-thread</span> <span class=\"hljs-string\">team</span><br><span class=\"hljs-string\">msh</span> <span class=\"hljs-string\">&gt;signal_sample</span><br><span class=\"hljs-attr\">thread1 count :</span> <span class=\"hljs-number\">0</span><br><span class=\"hljs-attr\">thread1 count :</span> <span class=\"hljs-number\">1</span><br><span class=\"hljs-attr\">thread1 count :</span> <span class=\"hljs-number\">2</span><br><span class=\"hljs-string\">msh</span> <span class=\"hljs-string\">&gt;thread1</span> <span class=\"hljs-string\">received</span> <span class=\"hljs-string\">signal</span> <span class=\"hljs-number\">10</span><br><span class=\"hljs-attr\">thread1 count :</span> <span class=\"hljs-number\">3</span><br><span class=\"hljs-attr\">thread1 count :</span> <span class=\"hljs-number\">4</span><br><span class=\"hljs-attr\">thread1 count :</span> <span class=\"hljs-number\">5</span><br><span class=\"hljs-attr\">thread1 count :</span> <span class=\"hljs-number\">6</span><br><span class=\"hljs-attr\">thread1 count :</span> <span class=\"hljs-number\">7</span><br><span class=\"hljs-attr\">thread1 count :</span> <span class=\"hljs-number\">8</span><br><span class=\"hljs-attr\">thread1 count :</span> <span class=\"hljs-number\">9</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"笔记-3\"><a href=\"#笔记-3\" class=\"headerlink\" title=\"笔记\"></a>笔记</h2><p>Mailbox:开销较小，4字节内容，</p>\n<p>Message Queue:长度不固定、需要进行内存分配、</p>\n<p>Signal:软件中断</p>\n<h1 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a>内存管理</h1><p>RT-Thread 操作系统在内存管理上，根据上层应用及系统资源的不同，有针对性地提供了不同的内存分配管理算法。总体上可分为两类：内存堆管理与内存池管理，而内存堆管理又根据具体内存设备划分为三种情况：</p>\n<ul>\n<li><p>第一种是针对小内存块的分配管理（小内存管理算法）；</p>\n</li>\n<li><p>第二种是针对大内存块的分配管理（slab 管理算法）；</p>\n</li>\n<li><p>第三种是针对多内存堆的分配情况（memheap 管理算法）</p>\n</li>\n</ul>\n<h2 id=\"内存堆Heap\"><a href=\"#内存堆Heap\" class=\"headerlink\" title=\"内存堆Heap\"></a>内存堆Heap</h2><p>RT-Thread 将 “ZI 段结尾处” 到内存尾部的空间用作内存堆。</p>\n<p><img src=\"/2021/42e53028/08Memory_distribution.png\" alt=\"RT-Thread 内存分布\"></p>\n<p>内存堆可以在当前资源满足的情况下，根据用户的需求分配任意大小的内存块。而当用户不需要再使用这些内存块时，又可以释放回堆中供其他应用分配使用。RT-Thread 系统为了满足不同的需求，提供了不同的内存管理算法，分别是<strong>小内存管理算法</strong>、<strong>Slab</strong> 管理算法和 <strong>memheap 管理算法</strong>。</p>\n<p><strong>小内存管理算法</strong>主要针对系统资源比较少，一般用于小于 2MB 内存空间的系统；</p>\n<p><strong>slab 内存管理算法</strong>则主要是在系统资源比较丰富时，提供了一种近似多内存池管理算法的快速算法。</p>\n<p> <strong>memheap 管理算法</strong>。memheap 方法适用于系统存在多个内存堆的情况，它可以将多个内存 “粘贴” 在一起，形成一个大的内存堆，用户使用起来会非常方便。</p>\n<h3 id=\"小内存管理算法\"><a href=\"#小内存管理算法\" class=\"headerlink\" title=\"小内存管理算法\"></a>小内存管理算法</h3><p><img src=\"/2021/42e53028/08smem_work.png\" alt=\"小内存管理工作机制图\"></p>\n<p>每个内存块（不管是已分配的内存块还是空闲的内存块）都包含一个数据头，其中包括：</p>\n<p><strong>1）magic</strong>：变数（或称为幻数），它会被初始化成 0x1ea0（即英文单词 heap），用于标记这个内存块是一个内存管理用的内存数据块；变数不仅仅用于标识这个数据块是一个内存管理用的内存数据块，实质也是一个内存保护字：如果这个区域被改写，那么也就意味着这块内存块被非法改写（正常情况下只有内存管理器才会去碰这块内存）。</p>\n<p><strong>2）used</strong>：指示出当前内存块是否已经分配。</p>\n<p><strong>内存管理的表现主要体现在内存的分配与释放上，小型内存管理算法可以用以下例子体现出来。</strong></p>\n<p><strong>如下图所示的内存分配情况，空闲链表指针 lfree 初始指向 32 字节的内存块。当用户线程要再分配一个 64 字节的内存块时，但此 lfree 指针指向的内存块只有 32 字节并不能满足要求，内存管理器会继续寻找下一内存块，当找到再下一块内存块，128 字节时，它满足分配的要求。因为这个内存块比较大，分配器将把此内存块进行拆分，余下的内存块（52 字节）继续留在 lfree 链表中，如下图分配 64 字节后的链表结构所示。</strong></p>\n<p><img src=\"/2021/42e53028/08smem_work3.png\" alt=\"小内存管理算法链表结构示意图 2\"></p>\n<p>另外，在每次分配内存块前，都会留出 12 字节数据头用于 magic、used 信息及链表节点使用。返回给应用的地址实际上是这块内存块 12 字节以后的地址，前面的 12 字节数据头是用户永远不应该碰的部分（注：12 字节数据头长度会与系统对齐差异而有所不同）。</p>\n<p>释放时则是相反的过程，但分配器会查看前后相邻的内存块是否空闲，如果空闲则合并成一个大的空闲内存块。</p>\n<h3 id=\"Slab管理算法\"><a href=\"#Slab管理算法\" class=\"headerlink\" title=\"Slab管理算法\"></a>Slab管理算法</h3><p>slab 分配器会根据对象的大小分成多个区（zone），也可以看成每类对象有一个内存池，如下图所示：</p>\n<p><img src=\"/2021/42e53028/08slab.png\" alt=\"slab 内存分配结构图\"></p>\n<p>一个 zone 的大小在 32K 到 128K 字节之间，分配器会在堆初始化时根据堆的大小自动调整。系统中的 zone 最多包括 72 种对象，一次最大能够分配 16K 的内存空间，如果超出了 16K 那么直接从页分配器中分配。每个 zone 上分配的内存块大小是固定的，能够分配相同大小内存块的 zone 会链接在一个链表中，而 72 种对象的 zone 链表则放在一个数组（zone_array[]）中统一管理。</p>\n<p><strong>（1）内存分配</strong></p>\n<p>假设分配一个 32 字节的内存，slab 内存分配器会先按照 32 字节的值，从 zone array 链表表头数组中找到相应的 zone 链表。如果这个链表是空的，则向页分配器分配一个新的 zone，然后从 zone 中返回第一个空闲内存块。如果链表非空，则这个 zone 链表中的第一个 zone 节点必然有空闲块存在（否则它就不应该放在这个链表中），那么就取相应的空闲块。如果分配完成后，zone 中所有空闲内存块都使用完毕，那么分配器需要把这个 zone 节点从链表中删除。</p>\n<p><strong>（2）内存释放</strong></p>\n<p>分配器需要找到内存块所在的 zone 节点，然后把内存块链接到 zone 的空闲内存块链表中。如果此时 zone 的空闲链表指示出 zone 的所有内存块都已经释放，即 zone 是完全空闲的，那么当 zone 链表中全空闲 zone 达到一定数目后，系统就会把这个全空闲的 zone 释放到页面分配器中去。</p>\n<h3 id=\"Memheap管理算法\"><a href=\"#Memheap管理算法\" class=\"headerlink\" title=\"Memheap管理算法\"></a>Memheap管理算法</h3><p> memheap 功能就可以很方便地把多个 memheap（地址可不连续）粘合起来用于系统的 heap 分配。</p>\n<p>memheap 工作机制如下图所示，首先将多块内存加入 memheap_item 链表进行粘合。当分配内存块时，会先从默认内存堆去分配内存，当分配不到时会查找 memheap_item 链表，尝试从其他的内存堆上分配内存块。应用程序不用关心当前分配的内存块位于哪个内存堆上，就像是在操作一个内存堆。</p>\n<p><img src=\"/2021/42e53028/08memheap.png\" alt=\"memheap 处理多内存堆\"></p>\n<h2 id=\"内存池Pool\"><a href=\"#内存池Pool\" class=\"headerlink\" title=\"内存池Pool\"></a>内存池Pool</h2><table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>创建&#x2F;初始化</td>\n<td>rt_mp_create()&#x2F;rt_mp_init()</td>\n</tr>\n<tr>\n<td>分配内存块</td>\n<td>rt_mp_alloc()</td>\n</tr>\n<tr>\n<td>释放内存块</td>\n<td>rt_mp_free()</td>\n</tr>\n<tr>\n<td>删除&#x2F;脱离</td>\n<td>rt_mp_delete()&#x2F;rt_mp_detach()</td>\n</tr>\n</tbody></table>\n<h3 id=\"创建-x2F-删除-create\"><a href=\"#创建-x2F-删除-create\" class=\"headerlink\" title=\"创建&#x2F;删除-create\"></a>创建&#x2F;删除-create</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_mp_t</span> <span class=\"hljs-title function_\">rt_mp_create</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name,</span><br><span class=\"hljs-params\">                         <span class=\"hljs-type\">rt_size_t</span> block_count,</span><br><span class=\"hljs-params\">                         <span class=\"hljs-type\">rt_size_t</span> block_size)</span>;<br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>name</td>\n<td>内存池名</td>\n</tr>\n<tr>\n<td>block_count</td>\n<td>内存块数量</td>\n</tr>\n<tr>\n<td>block_size</td>\n<td>内存块容量</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>内存池的句柄</td>\n<td>创建内存池对象成功</td>\n</tr>\n<tr>\n<td>RT_NULL</td>\n<td>创建失败</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_err_t</span> <span class=\"hljs-title function_\">rt_mp_delete</span><span class=\"hljs-params\">(<span class=\"hljs-type\">rt_mp_t</span> mp)</span>;<br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>mp</td>\n<td>rt_mp_create 返回的内存池对象句柄</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>RT_EOK</td>\n<td>删除成功</td>\n</tr>\n</tbody></table>\n<h3 id=\"初始化-x2F-剥离-init\"><a href=\"#初始化-x2F-剥离-init\" class=\"headerlink\" title=\"初始化&#x2F;剥离-init\"></a>初始化&#x2F;剥离-init</h3><p>内存池块个数 &#x3D; size &#x2F; (block_size + 4 链表指针大小)，计算结果取整数。</p>\n<p>例如：内存池数据区总大小 size 设为 4096 字节，内存块大小 block_size 设为 80 字节；则申请的内存块个数为 4096&#x2F; (80+4)&#x3D; 48 个。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_err_t</span> <span class=\"hljs-title function_\">rt_mp_init</span><span class=\"hljs-params\">(<span class=\"hljs-type\">rt_mp_t</span> mp,</span><br><span class=\"hljs-params\">                        <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name,</span><br><span class=\"hljs-params\">                        <span class=\"hljs-type\">void</span> *start, <span class=\"hljs-type\">rt_size_t</span> size,</span><br><span class=\"hljs-params\">                        <span class=\"hljs-type\">rt_size_t</span> block size)</span>;<br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>mp</td>\n<td>内存池对象</td>\n</tr>\n<tr>\n<td>name</td>\n<td>内存池名</td>\n</tr>\n<tr>\n<td>start</td>\n<td>内存池的起始位置</td>\n</tr>\n<tr>\n<td>size</td>\n<td>内存池数据区域大小</td>\n</tr>\n<tr>\n<td>block_size</td>\n<td>内存块容量</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>RT_EOK</td>\n<td>初始化成功</td>\n</tr>\n<tr>\n<td>- RT_ERROR</td>\n<td>失败</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_err_t</span> <span class=\"hljs-title function_\">rt_mp_detach</span><span class=\"hljs-params\">(<span class=\"hljs-type\">rt_mp_t</span> mp)</span>;<br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>mp</td>\n<td>内存池对象</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>RT_EOK</td>\n<td>成功</td>\n</tr>\n</tbody></table>\n<h3 id=\"分配-alloc\"><a href=\"#分配-alloc\" class=\"headerlink\" title=\"分配-alloc\"></a>分配-alloc</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">void</span> *<span class=\"hljs-title function_\">rt_mp_alloc</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">rt_mp_t</span> mp, <span class=\"hljs-type\">rt_int32_t</span> time)</span>;<br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>mp</td>\n<td>内存池对象</td>\n</tr>\n<tr>\n<td>time</td>\n<td>超时时间</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>分配的内存块地址</td>\n<td>成功</td>\n</tr>\n<tr>\n<td>RT_NULL</td>\n<td>失败</td>\n</tr>\n</tbody></table>\n<h3 id=\"释放-free\"><a href=\"#释放-free\" class=\"headerlink\" title=\"释放-free\"></a>释放-free</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">rt_mp_free</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">void</span> *block)</span>;<br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>block</td>\n<td>内存块指针</td>\n</tr>\n</tbody></table>\n<h2 id=\"笔记-4\"><a href=\"#笔记-4\" class=\"headerlink\" title=\"笔记\"></a>笔记</h2><ul>\n<li>因为内存堆管理器要满足多线程情况下的安全分配，会考虑多线程间的互斥问题，所以请不要在中断服务例程中分配或释放动态内存块。因为它可能会引起当前上下文被挂起等待。</li>\n</ul>\n<h1 id=\"RT-Thread的中断管理\"><a href=\"#RT-Thread的中断管理\" class=\"headerlink\" title=\"RT-Thread的中断管理\"></a>RT-Thread的中断管理</h1><h2 id=\"中断工作机制\"><a href=\"#中断工作机制\" class=\"headerlink\" title=\"中断工作机制\"></a>中断工作机制</h2><h3 id=\"中断处理过程\"><a href=\"#中断处理过程\" class=\"headerlink\" title=\"中断处理过程\"></a>中断处理过程</h3><p>RT-Thread 中断管理中，将中断处理程序分为中断前导程序、用户中断服务程序、中断后续程序三部分<br><img src=\"/2021/42e53028/09interrupt_work_process.png\" alt=\"中断处理程序的 3 部分\"></p>\n<h4 id=\"中断前导\"><a href=\"#中断前导\" class=\"headerlink\" title=\"中断前导\"></a>中断前导</h4><ol>\n<li><p>保存 CPU 中断现场，这部分跟 CPU 架构相关，不同 CPU 架构的实现方式有差异。</p>\n<p>对于 Cortex-M 来说，该工作由硬件自动完成。当一个中断触发并且系统进行响应时，处理器硬件会将当前运行部分的上下文寄存器自动压入中断栈中，这部分的寄存器包括 PSR、PC、LR、R12、R3-R0 寄存器。</p>\n</li>\n<li><p>通知内核进入中断状态，调用 rt_interrupt_enter() 函数，作用是把全局变量 rt_interrupt_nest 加 1，用它来记录中断嵌套的层数，代码如下所示。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">rt_interrupt_enter</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>    <span class=\"hljs-type\">rt_base_t</span> level;<br><br>    level = rt_hw_interrupt_disable();<br>    rt_interrupt_nest ++;<br>    rt_hw_interrupt_enable(level);<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"中断处理\"><a href=\"#中断处理\" class=\"headerlink\" title=\"中断处理\"></a>中断处理</h4><ol>\n<li><p>中断完后<strong>不进行</strong>线程切换，这种情况下用户中断服务程序和中断后续程序运行完毕后退出中断模式，返回被中断的线程。</p>\n</li>\n<li><p>中断完后<strong>进行</strong>线程切换，这种情况会调用 rt_hw_context_switch_interrupt() 函数进行上下文切换，该函数跟 CPU 架构相关，不同 CPU 架构的实现方式有差异。</p>\n<p>rt_hw_context_switch_interrupt() 函数会触发PendSV异常，PendSV 异常被触发后，不会立即进行 PendSV 异常中断处理程序，因为此时还在中断处理中，只有当中断后续程序运行完毕，真正退出中断处理后，才进入 PendSV 异常中断处理程序。</p>\n</li>\n</ol>\n<h4 id=\"中断后续\"><a href=\"#中断后续\" class=\"headerlink\" title=\"中断后续\"></a>中断后续</h4><ol>\n<li><p>通知内核离开中断状态，通过调用 rt_interrupt_leave() 函数，将全局变量 rt_interrupt_nest 减 1，代码如下所示。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">rt_interrupt_leave</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>    <span class=\"hljs-type\">rt_base_t</span> level;<br><br>    level = rt_hw_interrupt_disable();<br>    rt_interrupt_nest --;<br>    rt_hw_interrupt_enable(level);<br>&#125;<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>恢复中断前的 CPU 上下文，中断过程<strong>发生了线程切换</strong>和<strong>没发生线程切换</strong>的CPU上下文是不一样的。</p>\n</li>\n</ol>\n<h3 id=\"中断嵌套\"><a href=\"#中断嵌套\" class=\"headerlink\" title=\"中断嵌套\"></a>中断嵌套</h3><p>如果需要进行线程调度，线程的上下文切换将在所有中断处理程序都运行结束时才发生，如下图所示。</p>\n<p><img src=\"/2021/42e53028/09ths_switch.png\" alt=\"中断中的线程切换\"></p>\n<h3 id=\"中断栈\"><a href=\"#中断栈\" class=\"headerlink\" title=\"中断栈\"></a>中断栈</h3><ol>\n<li>中断栈可以保存在打断线程的栈中，当从中断中退出时，返回相应的线程继续执行。</li>\n<li>中断栈也可以与线程栈完全分离开来，即每次进入中断时，在保存完打断线程上下文后，切换到新的中断栈中独立运行。在中断退出时，再做相应的上下文恢复。</li>\n</ol>\n<p>使用独立中断栈相对来说更容易实现，并且对于线程栈使用情况也比较容易了解和掌握（否则必须要为中断栈预留空间，如果系统支持中断嵌套，还需要考虑应该为嵌套中断预留多大的空间）。</p>\n<h3 id=\"中断的底半处理\"><a href=\"#中断的底半处理\" class=\"headerlink\" title=\"中断的底半处理\"></a>中断的底半处理</h3><p>发生中断后，中断一般读取硬件状态或者数据，然后发送一个通知（信号量、事件、邮箱、消息队列等），接下来的相关线程收到通知对着数据进行进一步处理，这个处理的过程就叫<strong>底半处理</strong>。</p>\n<blockquote>\n<p>当一个中断发生时，中断服务程序需要取得相应的硬件状态或者数据。如果中断服务程序接下来要对状态或者数据进行简单处理，比如 CPU 时钟中断，中断服务程序只需对一个系统时钟变量进行加一操作，然后就结束中断服务程序。这类中断需要的运行时间往往都比较短。但对于另外一些中断，中断服务程序在取得硬件状态或数据以后，还需要进行一系列更耗时的处理过程，通常需要将该中断分割为两部分，即<strong>上半部分</strong>（Top Half）和<strong>底半部分</strong>（Bottom Half）。在上半部分中，取得硬件状态和数据后，打开被屏蔽的中断，给相关线程发送一条通知（可以是 RT-Thread 所提供的信号量、事件、邮箱或消息队列等方式），然后结束中断服务程序；而接下来，相关的线程在接收到通知后，接着对状态或数据进行进一步的处理，这一过程称之为<strong>底半处理</strong>。</p>\n</blockquote>\n<h2 id=\"中断管理API\"><a href=\"#中断管理API\" class=\"headerlink\" title=\"中断管理API\"></a>中断管理API</h2><p><img src=\"/2021/42e53028/09interrupt_ops.png\" alt=\"中断相关接口\"></p>\n<p><strong>请注意！！！装载中断服务例程、中断源管理——的API 并不会出现在每一个移植分支中，例如通常 Cortex-M0&#x2F;M3&#x2F;M4 的移植分支中就没有这些 API。</strong></p>\n<h3 id=\"装载中断服务例程\"><a href=\"#装载中断服务例程\" class=\"headerlink\" title=\"装载中断服务例程\"></a>装载中断服务例程</h3><p>系统把用户的中断服务程序 (handler) 和指定的中断号关联起来，可调用如下的接口挂载一个新的中断服务程序：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_isr_handler_t</span> <span class=\"hljs-title function_\">rt_hw_interrupt_install</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> <span class=\"hljs-built_in\">vector</span>,</span><br><span class=\"hljs-params\">                                        <span class=\"hljs-type\">rt_isr_handler_t</span>  handler,</span><br><span class=\"hljs-params\">                                        <span class=\"hljs-type\">void</span> *param,</span><br><span class=\"hljs-params\">                                        <span class=\"hljs-type\">char</span> *name)</span>;<br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>vector</td>\n<td>vector 是挂载的中断号</td>\n</tr>\n<tr>\n<td>handler</td>\n<td>新挂载的中断服务程序</td>\n</tr>\n<tr>\n<td>param</td>\n<td>param 会作为参数传递给中断服务程序</td>\n</tr>\n<tr>\n<td>name</td>\n<td>中断的名称</td>\n</tr>\n<tr>\n<td><strong>返回</strong></td>\n<td>——</td>\n</tr>\n<tr>\n<td>return</td>\n<td>挂载这个中断服务程序之前挂载的中断服务程序的句柄</td>\n</tr>\n</tbody></table>\n<h3 id=\"中断源管理\"><a href=\"#中断源管理\" class=\"headerlink\" title=\"中断源管理\"></a>中断源管理</h3><ol>\n<li>屏蔽中断源</li>\n</ol>\n<p>通常在 ISR 准备处理某个中断信号之前，我们需要先屏蔽该中断源，在 ISR 处理完状态或数据以后，及时的打开之前被屏蔽的中断源。</p>\n<p>屏蔽中断源可以保证在接下来的处理过程中硬件状态或者数据不会受到干扰，可调用下面这个函数接口：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">rt_hw_interrupt_mask</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> <span class=\"hljs-built_in\">vector</span>)</span>;<br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>vector</td>\n<td>要屏蔽的中断号</td>\n</tr>\n</tbody></table>\n<ol start=\"2\">\n<li>打开被屏蔽的中断源</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">rt_hw_interrupt_umask</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> <span class=\"hljs-built_in\">vector</span>)</span>;<br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>vector</td>\n<td>要打开屏蔽的中断号</td>\n</tr>\n</tbody></table>\n<h3 id=\"全局中断开关\"><a href=\"#全局中断开关\" class=\"headerlink\" title=\"全局中断开关\"></a>全局中断开关</h3><p><strong>全局中断开关也称为</strong>中断锁，是禁止多线程访问临界区最简单的一种方式，即通过关闭中断的方式，来保证当前线程不会被其他事件打断（因为整个系统已经不再响应那些可以触发线程重新调度的外部事件），也就是当前线程不会被抢占，除非这个线程主动放弃了处理器控制权。</p>\n<ol>\n<li>失能全局中断</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_base_t</span> <span class=\"hljs-title function_\">rt_hw_interrupt_disable</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span>;<br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>返回</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>中断状态</td>\n<td>rt_hw_interrupt_disable 函数运行前的中断状态</td>\n</tr>\n<tr>\n<td>2. 使能全局中断</td>\n<td></td>\n</tr>\n</tbody></table>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">rt_hw_interrupt_enable</span><span class=\"hljs-params\">(<span class=\"hljs-type\">rt_base_t</span> level)</span>;<br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>level</td>\n<td>前一次 rt_hw_interrupt_disable 返回的中断状态</td>\n</tr>\n</tbody></table>\n<h3 id=\"中断通知\"><a href=\"#中断通知\" class=\"headerlink\" title=\"中断通知\"></a>中断通知</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">rt_interrupt_enter</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span>;<br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">rt_interrupt_leave</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span>;<br></code></pre></td></tr></table></figure>\n\n<p>这两个接口分别用在中断前导程序和中断后续程序中，均会对 rt_interrupt_nest（中断嵌套深度）的值进行修改。</p>\n<p>使用 rt_interrupt_enter&#x2F;leave() 的作用是，在中断中释放了一个信号量，唤醒了某线程，但通过判断发现当前系统处于中断上下文环境中，那么在进行线程切换时应该采取中断中线程切换的策略（等中断结束再切换），而不是立即进行切换（正常情况下立即进行切换）。</p>\n<p><del>（不建议）但如果中断服务程序不会调用内核相关的函数（释放信号量等操作），这个时候，也可以不调用 rt_interrupt_enter&#x2F;leave() 函数。</del></p>\n<p>在上层应用中，在内核需要知道当前已经进入到中断状态或当前<strong>嵌套的中断深度</strong>时，可调用 rt_interrupt_get_nest() 接口，它会返回 rt_interrupt_nest。如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">rt_uint8_t</span> <span class=\"hljs-title function_\">rt_interrupt_get_nest</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span>;<br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>返回</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>当前系统不处于中断上下文环境中</td>\n</tr>\n<tr>\n<td>1</td>\n<td>当前系统处于中断上下文环境中</td>\n</tr>\n<tr>\n<td>大于 1</td>\n<td>当前中断嵌套层次</td>\n</tr>\n</tbody></table>\n<h2 id=\"中断与轮询\"><a href=\"#中断与轮询\" class=\"headerlink\" title=\"中断与轮询\"></a>中断与轮询</h2><p>当驱动外设工作时，其编程模式到底采用中断模式触发还是轮询模式触发往往是驱动开发人员首先要考虑的问题，并且这个问题在实时操作系统与分时操作系统中差异还非常大。</p>\n<p>在实时系统中轮询模式可能会出现非常大问题，因为在实时操作系统中，当一个程序持续地执行时（轮询时），它所在的线程会一直运行，比它优先级低的线程都不会得到运行。而分时系统中，这点恰恰相反，几乎没有优先级之分，可以在一个时间片运行这个程序，然后在另外一段时间片上运行另外一段程序。</p>\n<p>所以通常情况下，实时系统中更多采用的是中断模式来驱动外设。当数据达到时，由中断唤醒相关的处理线程，再继续进行后续的动作。例如一些携带 FIFO（包含一定数据量的先进先出队列）的串口外设，其写入过程可以是这样的，如下图所示：</p>\n<p><img src=\"/2021/42e53028/09interrupt_reque.png\" alt=\"中断模式驱动外设\"></p>\n<p><strong>对于低速设备来说，运用这种模式非常好，而对于高速设备，数据量又小的情况下，线程的切换时间（几个us）会很明显的影响数据吞吐量和带宽利用率。</strong></p>\n<blockquote>\n<p>发送数据量越小，发送速度越快，对于数据吞吐量的影响也将越大。归根结底，取决于系统中产生中断的频度如何。当一个实时系统想要提升数据吞吐量时，可以考虑的几种方式：</p>\n<p>1）增加每次数据量发送的长度，每次尽量让外设尽量多地发送数据；</p>\n<p>2）必要情况下更改中断模式为轮询模式。同时为了解决轮询方式一直抢占处理机，其他低优先级线程得不到运行的情况，可以把轮询线程的优先级适当降低。</p>\n</blockquote>\n<h1 id=\"内核移植\"><a href=\"#内核移植\" class=\"headerlink\" title=\"内核移植\"></a>内核移植</h1><p>参考官方文档</p>\n<h2 id=\"CPU架构移植\"><a href=\"#CPU架构移植\" class=\"headerlink\" title=\"CPU架构移植\"></a>CPU架构移植</h2><h2 id=\"BSP移植\"><a href=\"#BSP移植\" class=\"headerlink\" title=\"BSP移植\"></a>BSP移植</h2>",
            "tags": [
                "rtos",
                "rt-thread"
            ]
        },
        {
            "id": "https://www.oikiou.top/2020/2b1e625a/",
            "url": "https://www.oikiou.top/2020/2b1e625a/",
            "title": "RTX",
            "date_published": "2020-08-21T14:57:15.000Z",
            "content_html": "<h1 id=\"创建一个RTX项目\"><a href=\"#创建一个RTX项目\" class=\"headerlink\" title=\"创建一个RTX项目\"></a>创建一个RTX项目</h1><p><strong>Create an RTX5 Project</strong></p>\n<ol>\n<li><p>创建一个新的项目,并选择单片机设备。</p>\n<p>Create a new project and select a microcontroller device.</p>\n</li>\n<li><p>设置 <strong>CMSIS::CORE</strong> 和 <strong>CMSIS::RTOS2 (API)::Keil RTX5</strong>，在下拉框中你可以选择添加RTX库或者添加完整源代码。</p>\n<p>In the Manage Run-Time Environment window, select <strong>CMSIS::CORE</strong> and <strong>CMSIS::RTOS2 (API)::Keil RTX5</strong>. You can choose to either add RTX as a library (Variant: <strong>Library</strong>) or to add the full source code (Variant: <strong>Source</strong> - required if using the <a href=\"http://www.keil.com/pack/doc/compiler/EventRecorder/html/index.html\"><strong>Event Recorder</strong></a>):</p>\n</li>\n<li><p>添加启动文件 <strong>Device::Startup</strong></p>\n</li>\n<li><p>一个示例代码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">osKernelInitialize();/ /初始化RTX<br><span class=\"hljs-title function_\">NVIC_SetPriorityGrouping</span> <span class=\"hljs-params\">(<span class=\"hljs-number\">3</span>)</span>;/ /设置优先级分组<br>tread_id =osThreadNew(tread_func,空,空);/ /创建一些线程<br>osKernelStart();/ /开始RTX内核<br></code></pre></td></tr></table></figure>\n\n\n\n<p>注：</p>\n<ol>\n<li><p>添加RTX特定功能的支持</p>\n<p>如果你需要一些的<a href=\"group__rtx5__specific.html\">RTX特定功能</a>在您的应用程序代码中,# include<a href=\"theory_of_operation.html#rtx_os_h\">头文件rtx_os.h</a>。 如使能<a href=\"theory_of_operation.html#lowPower\">低功耗</a>和<a href=\"theory_of_operation.html#TickLess\">tick-less</a>操作模式。</p>\n</li>\n<li><p>添加事件记录器</p>\n<ul>\n<li><p>打开MRTE(Manage Run-Time Environment)窗口</p>\n</li>\n<li><p>确保RTX5使用的是源代码(Source)模式</p>\n</li>\n<li><p>打开 <strong>Compiler::Event Recorder</strong></p>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"中断-Cortex-M\"><a href=\"#中断-Cortex-M\" class=\"headerlink\" title=\"中断 (Cortex-M)\"></a>中断 (Cortex-M)</h1><p>Cortex-M处理器,RTX5内核使用以下异常中断。 下面的表格还列出了必须分配给这些中断的优先级。</p>\n<table>\n<thead>\n<tr>\n<th>处理程序</th>\n<th>优先级</th>\n<th>中断&#x2F;异常</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>SysTick</td>\n<td>最低</td>\n<td>内核系统定时器中断产生周期性的计时器滴答声</td>\n</tr>\n<tr>\n<td>PendSV</td>\n<td>最低</td>\n<td>PendSV(系统级服务请求)当调用某些RTX功能<strong>处理程序</strong>模式</td>\n</tr>\n<tr>\n<td>SVC</td>\n<td>最低+ 1</td>\n<td>主管叫用来输入RTOS内核<strong>线程</strong>模式</td>\n</tr>\n</tbody></table>\n<p>可以使用其他设备中断没有限制。 ARM Cortex-M3 &#x2F; M4 &#x2F; M7 &#x2F; M23 &#x2F; M33 &#x2F; M35P处理器,从未被RTX禁用中断内核。</p>\n<p><strong>使用中断的优先级分组</strong></p>\n<ul>\n<li>在调用函数<a href=\"group__CMSIS__RTOS__KernelCtrl.html#ga9ae2cc00f0d89d7b6a307bba942b5221\">osKernelStart（）</a>之前，应使用CMSIS-Core函数NVIC_SetPriorityGrouping配置中断优先级分组。RTX内核使用优先级组值来设置SysTick和PendSV中断的优先级。</li>\n<li>RTX内核为上表中列出的中断&#x2F;异常设置优先级，并使用最低的两个优先级。</li>\n<li>不要更改RTX内核使用的优先级。如果无法避免，请确保SysTick &#x2F; PendSV的抢占优先级低于SVC。</li>\n<li>允许的优先级组值为0到6.优先级组值7将导致RTX失败，因为只有一个可用优先级。</li>\n<li>的<strong>main函数堆叠</strong>被用于运行RTX功能。因此，需要为RTX内核执行配置足够的堆栈。</li>\n</ul>\n",
            "tags": [
                "rtx",
                "rtos",
                "keil"
            ]
        },
        {
            "id": "https://www.oikiou.top/2020/2ac84091/",
            "url": "https://www.oikiou.top/2020/2ac84091/",
            "title": "UCOS",
            "date_published": "2020-08-21T14:57:15.000Z",
            "content_html": "<h2 id=\"序章\"><a href=\"#序章\" class=\"headerlink\" title=\"序章\"></a>序章</h2><h3 id=\"延时函数\"><a href=\"#延时函数\" class=\"headerlink\" title=\"延时函数\"></a>延时函数</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">void</span>  <span class=\"hljs-title function_\">OSTimeDlyHMSM</span> <span class=\"hljs-params\">(CPU_INT16U   hours,</span><br><span class=\"hljs-params\">                     CPU_INT16U   minutes,</span><br><span class=\"hljs-params\">                     CPU_INT16U   seconds,</span><br><span class=\"hljs-params\">                     CPU_INT32U   milli,</span><br><span class=\"hljs-params\">                     OS_OPT       opt,</span><br><span class=\"hljs-params\">                     OS_ERR      *p_err)</span><br><br><span class=\"hljs-title function_\">OSTimeDlyHMSM</span><span class=\"hljs-params\">(<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">0</span>,OS_OPT_TIME_HMSM_STRICT,&amp;err)</span>; <span class=\"hljs-comment\">//延时1s</span><br><span class=\"hljs-comment\">//strick   adj. 严格的；绝对的；精确的；详细的</span><br></code></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"任务管理\"><a href=\"#任务管理\" class=\"headerlink\" title=\"任务管理\"></a>任务管理</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">//创建开始任务</span><br>\tOSTaskCreate((OS_TCB \t* )&amp;StartTaskTCB,\t\t<span class=\"hljs-comment\">//任务控制块</span><br>\t\t\t\t (CPU_CHAR\t* )<span class=\"hljs-string\">&quot;start task&quot;</span>, \t\t<span class=\"hljs-comment\">//任务名字</span><br>                 (OS_TASK_PTR )start_task, \t\t\t<span class=\"hljs-comment\">//任务函数</span><br>                 (<span class=\"hljs-type\">void</span>\t\t* )<span class=\"hljs-number\">0</span>,\t\t\t\t\t<span class=\"hljs-comment\">//传递给任务函数的参数</span><br>                 (OS_PRIO\t  )START_TASK_PRIO,     <span class=\"hljs-comment\">//任务优先级</span><br>                 (CPU_STK   * )&amp;START_TASK_STK[<span class=\"hljs-number\">0</span>],\t<span class=\"hljs-comment\">//任务堆栈基地址</span><br>                 (CPU_STK_SIZE)START_STK_SIZE/<span class=\"hljs-number\">10</span>,\t<span class=\"hljs-comment\">//任务堆栈深度限位</span><br>                 (CPU_STK_SIZE)START_STK_SIZE,\t\t<span class=\"hljs-comment\">//任务堆栈大小</span><br>                 (OS_MSG_QTY  )<span class=\"hljs-number\">0</span>,\t\t\t\t\t<span class=\"hljs-comment\">//任务内部消息队列能够接收的最大消息数目,为0时禁止接收消息</span><br>                 (OS_TICK\t  )<span class=\"hljs-number\">0</span>,\t\t\t\t\t<span class=\"hljs-comment\">//当使能时间片轮转时的时间片长度，为0时为默认长度，</span><br>                 (<span class=\"hljs-type\">void</span>   \t* )<span class=\"hljs-number\">0</span>,\t\t\t\t\t<span class=\"hljs-comment\">//用户补充的存储区</span><br>                 (OS_OPT      )OS_OPT_TASK_STK_CHK|OS_OPT_TASK_STK_CLR, <span class=\"hljs-comment\">//任务选项</span><br>                 (OS_ERR \t* )&amp;err);\t\t\t\t<span class=\"hljs-comment\">//存放该函数错误时的返回值</span><br><br><br></code></pre></td></tr></table></figure>\n\n<ol>\n<li><p><code>(CPU_STK_SIZE)START_STK_SIZE/10,\t//任务堆栈深度限位</code>    一般设定小于10%即可</p>\n</li>\n<li><p><code>(OS_TCB \t* )&amp;StartTaskTCB,\t\t//任务控制块</code>   <strong>不要访问和更改其中的成员变量</strong></p>\n</li>\n</ol>\n<h4 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h4><ul>\n<li><p>数值越小优先级越高</p>\n</li>\n<li><p>os_cfg.h line48   <strong>OS_CFG_PRIO_MAX</strong>  最大优先级数</p>\n</li>\n</ul>\n<h4 id=\"就绪表\"><a href=\"#就绪表\" class=\"headerlink\" title=\"就绪表\"></a>就绪表</h4><ul>\n<li>优先级位映射表**OSPrioTbl[]**：用来记录哪个优先级下有任务就绪</li>\n<li>就绪任务列表**OSRdyList[]**：用来记录每一个优先级下所有就绪的任务</li>\n</ul>\n<h4 id=\"前导零\"><a href=\"#前导零\" class=\"headerlink\" title=\"前导零\"></a>前导零</h4><ul>\n<li>硬件计算  能计算一个值前面有多少零</li>\n</ul>\n<h2 id=\"任务调度\"><a href=\"#任务调度\" class=\"headerlink\" title=\"任务调度\"></a>任务调度</h2><h4 id=\"任务调度-1\"><a href=\"#任务调度-1\" class=\"headerlink\" title=\"任务调度\"></a>任务调度</h4><ul>\n<li>任务调度器 进入中断   OSIntEnter();  </li>\n<li>任务调度器 退出中断   OSIntExit();</li>\n</ul>\n<h4 id=\"发生任务调度的调度点\"><a href=\"#发生任务调度的调度点\" class=\"headerlink\" title=\"发生任务调度的调度点\"></a>发生任务调度的调度点</h4><ul>\n<li>延时函数OSTimeDly()（按时间延时）或者OSTimeDlyHMSM()（按节拍延时）</li>\n<li>创建、删除任务</li>\n<li>改变优先级</li>\n<li>通过调用OSTaskSuspend()将自身挂起、或解除某个挂起的任务</li>\n<li>OSSched() 用户自行请求调度</li>\n</ul>\n<h4 id=\"调度器上锁解锁\"><a href=\"#调度器上锁解锁\" class=\"headerlink\" title=\"调度器上锁解锁\"></a>调度器上锁解锁</h4><ul>\n<li>OSSchedLock()加锁</li>\n<li>OSSchedUnlock()解锁</li>\n</ul>\n<h4 id=\"时间片轮转调度\"><a href=\"#时间片轮转调度\" class=\"headerlink\" title=\"时间片轮转调度\"></a>时间片轮转调度</h4><ul>\n<li>待补充</li>\n</ul>\n<h2 id=\"UCOS系统初始化\"><a href=\"#UCOS系统初始化\" class=\"headerlink\" title=\"UCOS系统初始化\"></a>UCOS系统初始化</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>   OS_ERR err;<br>   ……<br>   <span class=\"hljs-comment\">//其他函数，一般为外设初始化函数</span><br>   ……<br>   OSInit(&amp;err);<br>   ……<br>   <span class=\"hljs-comment\">//其他函数，一般为创建任务函数</span><br>   ……<br>   OSStart(&amp;err);<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>OSInit()必须先于其他的UCOS函数调用包括OSStart()</li>\n</ul>\n<h2 id=\"任务创建与管理\"><a href=\"#任务创建与管理\" class=\"headerlink\" title=\"任务创建与管理\"></a>任务创建与管理</h2><h4 id=\"任务的创建\"><a href=\"#任务的创建\" class=\"headerlink\" title=\"任务的创建\"></a>任务的创建</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">OSTaskCreate((OS_TCB \t* )&amp;StartTaskTCB,\t\t<span class=\"hljs-comment\">//任务控制块</span><br>             (CPU_CHAR\t* )<span class=\"hljs-string\">&quot;start task&quot;</span>, \t\t<span class=\"hljs-comment\">//任务名字</span><br>             (OS_TASK_PTR )start_task, \t\t\t<span class=\"hljs-comment\">//任务函数</span><br>             (<span class=\"hljs-type\">void</span>\t\t* )<span class=\"hljs-number\">0</span>,\t\t\t\t\t<span class=\"hljs-comment\">//传递给任务函数的参数</span><br>             (OS_PRIO\t  )START_TASK_PRIO,     <span class=\"hljs-comment\">//任务优先级</span><br>             (CPU_STK   * )&amp;START_TASK_STK[<span class=\"hljs-number\">0</span>],\t<span class=\"hljs-comment\">//任务堆栈基地址</span><br>             (CPU_STK_SIZE)START_STK_SIZE/<span class=\"hljs-number\">10</span>,\t<span class=\"hljs-comment\">//任务堆栈深度限位</span><br>             (CPU_STK_SIZE)START_STK_SIZE,\t\t<span class=\"hljs-comment\">//任务堆栈大小</span><br>             (OS_MSG_QTY  )<span class=\"hljs-number\">0</span>,\t\t\t\t\t<span class=\"hljs-comment\">//任务内部消息队列能够接收的最大消息数目,为0时禁止接收消息</span><br>             (OS_TICK\t  )<span class=\"hljs-number\">0</span>,\t\t\t\t\t<span class=\"hljs-comment\">//当使能时间片轮转时的时间片长度，为0时为默认长度，</span><br>             (<span class=\"hljs-type\">void</span>   \t* )<span class=\"hljs-number\">0</span>,\t\t\t\t\t<span class=\"hljs-comment\">//用户补充的存储区</span><br>             (OS_OPT      )OS_OPT_TASK_STK_CHK|OS_OPT_TASK_STK_CLR, <span class=\"hljs-comment\">//任务选项</span><br>             (OS_ERR \t* )&amp;err);\t\t\t\t<span class=\"hljs-comment\">//存放该函数错误时的返回值</span><br></code></pre></td></tr></table></figure>\n\n<p>OS_ERR 错误代码</p>\n<h4 id=\"任务的删除\"><a href=\"#任务的删除\" class=\"headerlink\" title=\"任务的删除\"></a>任务的删除</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">void</span>  <span class=\"hljs-title function_\">OSTaskDel</span> <span class=\"hljs-params\">(OS_TCB  *p_tcb,</span><br><span class=\"hljs-params\">                 OS_ERR  *p_err)</span>;<br>    <br>OSTaskDel((OS_TCB*)&amp;Task2_TaskTCB,&amp;err);<br></code></pre></td></tr></table></figure>\n\n\n\n<p>不建议在系统运行时删除任务</p>\n<blockquote>\n<p>尽管UCOSIII允许在系统运行中删除任务，但是应该尽量避免这种操作，如果这个任务可能占有与其他任务共享的资源，在删除此任务之前这个被占有的资源没有被释放就有可能导致奇怪的结果。</p>\n</blockquote>\n<h2 id=\"任务的挂起与恢复\"><a href=\"#任务的挂起与恢复\" class=\"headerlink\" title=\"任务的挂起与恢复\"></a>任务的挂起与恢复</h2><h3 id=\"挂起\"><a href=\"#挂起\" class=\"headerlink\" title=\"挂起\"></a>挂起</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">void</span>   <span class=\"hljs-title function_\">OSTaskSuspend</span> <span class=\"hljs-params\">(OS_TCB  *p_tcb,</span><br><span class=\"hljs-params\">                      OS_ERR  *p_err)</span>;<br><br>OSTaskSuspend((OS_TCB*)&amp;Task2_TaskTCB,&amp;err);<span class=\"hljs-comment\">//挂起任务2</span><br></code></pre></td></tr></table></figure>\n\n<p>挂起错误</p>\n<ul>\n<li>任务被加锁</li>\n<li>任务空闲</li>\n</ul>\n<h3 id=\"恢复\"><a href=\"#恢复\" class=\"headerlink\" title=\"恢复\"></a>恢复</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">void</span>  <span class=\"hljs-title function_\">OSTaskResume</span> <span class=\"hljs-params\">(OS_TCB  *p_tcb,</span><br><span class=\"hljs-params\">                    OS_ERR  *p_err)</span><br><br><span class=\"hljs-title function_\">OSTaskResume</span><span class=\"hljs-params\">((OS_TCB*)&amp;Task2_TaskTCB,&amp;err)</span>;\t<span class=\"hljs-comment\">//恢复任务2</span><br></code></pre></td></tr></table></figure>\n\n<p>恢复错误</p>\n<ul>\n<li>任务状态无效（错误的状态）、任务不是已经挂起的</li>\n<li>不能恢复自己</li>\n</ul>\n<h2 id=\"时间片轮转调度-1\"><a href=\"#时间片轮转调度-1\" class=\"headerlink\" title=\"时间片轮转调度\"></a>时间片轮转调度</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">void</span>  <span class=\"hljs-title function_\">OSSchedRoundRobinCfg</span> <span class=\"hljs-params\">(CPU_BOOLEAN   en,</span><br><span class=\"hljs-params\">                            OS_TICK       dflt_time_quanta,</span><br><span class=\"hljs-params\">                            OS_ERR       *p_err)</span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">if</span>\tOS_CFG_SCHED_ROUND_ROBIN_EN  <span class=\"hljs-comment\">//当使用时间片轮转的时候</span></span><br>\t <span class=\"hljs-comment\">//使能时间片轮转调度功能,时间片长度为1个系统时钟节拍，既1*5=5ms</span><br>\t<span class=\"hljs-title function_\">OSSchedRoundRobinCfg</span><span class=\"hljs-params\">(DEF_ENABLED,<span class=\"hljs-number\">1</span>,&amp;err)</span>;  <br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><ul>\n<li>设置宏  <strong>OS_CFG_SCHED_ROUND_ROBIN_EN</strong>  为1</li>\n<li>调用函数  <strong>OSSchedRoundRobinCfg()</strong>  开启时间片轮转调度功能</li>\n</ul>\n<h3 id=\"时间片的放弃\"><a href=\"#时间片的放弃\" class=\"headerlink\" title=\"时间片的放弃\"></a>时间片的放弃</h3><p><code>OSSchedRoundRobinYield(&amp;err);</code></p>\n<h3 id=\"注：\"><a href=\"#注：\" class=\"headerlink\" title=\"注：\"></a>注：</h3><p>时间片如果不够执行可能会产生奇怪的效果请注意</p>\n<h2 id=\"系统内部任务\"><a href=\"#系统内部任务\" class=\"headerlink\" title=\"系统内部任务\"></a>系统内部任务</h2><ol>\n<li><p>中断服务管理任务</p>\n</li>\n<li><p>时钟节拍任务</p>\n</li>\n<li><p>定时任务（可选）</p>\n</li>\n<li><p>统计任务（可选）</p>\n</li>\n<li><p>空闲任务</p>\n</li>\n</ol>\n<h3 id=\"中断服务管理任务\"><a href=\"#中断服务管理任务\" class=\"headerlink\" title=\"中断服务管理任务\"></a>中断服务管理任务</h3><ul>\n<li>默认优先级最高，第一，不可更改。</li>\n</ul>\n<h3 id=\"时钟节拍任务\"><a href=\"#时钟节拍任务\" class=\"headerlink\" title=\"时钟节拍任务\"></a>时钟节拍任务</h3><ul>\n<li>优先级较高，第二。</li>\n</ul>\n<h3 id=\"定时任务（可选）\"><a href=\"#定时任务（可选）\" class=\"headerlink\" title=\"定时任务（可选）\"></a>定时任务（可选）</h3><ul>\n<li><p>默认优先级，第三。</p>\n</li>\n<li><p>提供软件定时功能</p>\n</li>\n<li><p>将宏OS_CFG_TMR_EN设置为1就会使能定时任务，在OSInit()中将会调用函数OS_TmrInit()来创建定时任务。</p>\n</li>\n</ul>\n<h3 id=\"统计任务（可选）\"><a href=\"#统计任务（可选）\" class=\"headerlink\" title=\"统计任务（可选）\"></a>统计任务（可选）</h3><ul>\n<li>一般优先级，倒数第二。</li>\n<li>统计CPU使用率，堆栈使用率</li>\n<li>可选创建（将宏<strong>OS_CFG_STAT_TASK_EN</strong>置1）</li>\n<li>必须在main函数创建的以一个任务也是唯一的一个应用任务里面调用函数**OSStatTaskCPUUsageInit()**查询使用情况</li>\n</ul>\n<h3 id=\"空闲任务\"><a href=\"#空闲任务\" class=\"headerlink\" title=\"空闲任务\"></a>空闲任务</h3><ul>\n<li>优先级最低，倒数第一。</li>\n<li>不能调用会使空闲任务进入等待态的函数。</li>\n<li><span style=\"color:red\">可统计CPU使用率</span>（用处）</li>\n</ul>\n<h2 id=\"钩子函数\"><a href=\"#钩子函数\" class=\"headerlink\" title=\"钩子函数\"></a>钩子函数</h2><p>共有8个</p>\n<ol>\n<li>OSIdleTaskHook()，\t\t<strong>空闲任务</strong>\t\t调用这个函数，可以用来让CPU进入低功耗模式</li>\n<li>OSInitHook()，\t\t\t<strong>系统初始化</strong>\t\t函数OSInit()调用此函数</li>\n<li>OSStatTaskHook(),\t\t <strong>统计任务每秒</strong>\t\t中都会调用这个函数，此函数允许你向统计任务中添加自己的应用函数。</li>\n<li>OSTaskCreateHook(),\t\t<strong>任务创建</strong>\t\t的钩子函数。</li>\n<li>OSTaskDelHook(),\t\t<strong>任务删除</strong>\t\t的钩子函数。</li>\n<li>OSTaskReturnHook(),\t\t<strong>任务意外返回</strong>\t\t时调用的钩子函数，比如删除某个任务</li>\n<li>OSTaskSwHook(),\t\t<strong>任务切换</strong>\t\t时候调用的钩子函数。</li>\n<li>OSTimeTickHook()，\t\t<strong>滴答定时器</strong>\t\t调用的钩子函数。</li>\n</ol>\n<h2 id=\"中断时间管理\"><a href=\"#中断时间管理\" class=\"headerlink\" title=\"中断时间管理\"></a>中断时间管理</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">USART1_IRQHandler</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>       OSIntEnter();<br>      <span class=\"hljs-comment\">//中断服务程序</span><br>      OSIntExit();<br>&#125;  <br><br><br><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>最大250级中断嵌套</li>\n</ul>\n<h2 id=\"临界区代码保护\"><a href=\"#临界区代码保护\" class=\"headerlink\" title=\"临界区代码保护\"></a>临界区代码保护</h2><blockquote>\n<p>临界区：不可被打断的代码段</p>\n</blockquote>\n<p>OS_CFG_ISR_POST_DEFERRED_EN   的值与临界段代码保护方式</p>\n<table>\n<thead>\n<tr>\n<th>0</th>\n<th>关中断</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>调度器上锁（可能会被其它中断打断）</td>\n</tr>\n</tbody></table>\n<ol>\n<li><p>进入临界段</p>\n<ul>\n<li>一个进入函数</li>\n</ul>\n</li>\n<li><p>退出临界段</p>\n<ul>\n<li><p>退出后产生调度——-OS_CRITICAL_EXIT()</p>\n</li>\n<li><p>退出后不产生调度—-OS_CRITICAL_EXIT_NO_SCHED()</p>\n</li>\n<li></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"CPU-SR-ALLOC\"><a href=\"#CPU-SR-ALLOC\" class=\"headerlink\" title=\"CPU_SR_ALLOC()\"></a>CPU_SR_ALLOC()</h3><ol>\n<li>函数CPU_SR_ALLOC()是为CPU_CRITICAL_ENTER()和CPU_CRITICAL_EXIT()申请一个变量：</li>\n</ol>\n<p><code>#define  CPU_SR_ALLOC()           CPU_SR  cpu_sr = (CPU_SR)0</code></p>\n<p>这个是临界代码段，在下面一个小节有详细讲解。</p>\n<ol start=\"2\">\n<li>这样做是为了防止编译器警告。</li>\n</ol>\n<h2 id=\"任务延时\"><a href=\"#任务延时\" class=\"headerlink\" title=\"任务延时\"></a>任务延时</h2><ul>\n<li>开始延时</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>OSTimeDly()</th>\n<th>相对延时</th>\n<th>基于时钟节拍</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td>绝对延时</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>周期延时</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>OSTimeDlyHMSM()</td>\n<td>相对延时</td>\n<td>基于时间</td>\n</tr>\n</tbody></table>\n<ul>\n<li><p>取消延时</p>\n<p>延时任务任务可通过在其他任务中调用函数OSTimeDlyResume()取消延时而进入就绪状态，此函数最后会引发一次任务调度。</p>\n</li>\n</ul>\n<h2 id=\"获取系统时间\"><a href=\"#获取系统时间\" class=\"headerlink\" title=\"获取系统时间\"></a>获取系统时间</h2><p>​\tUCOSIII定义了一个 CPU_INT32U 类型的全局变量 OSTickCtr 来记录系统时钟节拍数，在调用 <strong>OSInit()</strong> 时被初始化为 0，以后每发生1个时钟节拍，OSTickCtr加1。</p>\n<ul>\n<li>OSTimeSet()允许用户改变当前时钟节拍计数器的值</li>\n<li>OSTimeGet()用来获取动迁时钟节拍计数器的值</li>\n</ul>\n<h2 id=\"软件定时器\"><a href=\"#软件定时器\" class=\"headerlink\" title=\"软件定时器\"></a>软件定时器</h2><p>​\t定时器本质是递减计数器，当计数器减到零时可以执行回调函数。应用程序可以有任意数量的定时器，UCOSIII中定时器的时间分辨率由一个宏 <strong>OS_CFG_TMR_TASK_RATE_HZ</strong> 确定，单位为HZ，默认为100Hz。</p>\n<ul>\n<li>避免在回调函数使用   <strong>阻塞</strong>，<strong>删除</strong>   定时器任务的函数。</li>\n</ul>\n<h3 id=\"软件定时器的API\"><a href=\"#软件定时器的API\" class=\"headerlink\" title=\"软件定时器的API\"></a>软件定时器的API</h3><table>\n<thead>\n<tr>\n<th><strong>OSTmrCreate()</strong></th>\n<th><strong>创建定时器并制定运行模式</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>OSTmrDel()</td>\n<td>删除定时器</td>\n</tr>\n<tr>\n<td>OSTmrRemainGet()</td>\n<td>获取定时器的剩余时间</td>\n</tr>\n<tr>\n<td><strong>OSTmrStart()</strong></td>\n<td><strong>启动定时器计数</strong></td>\n</tr>\n<tr>\n<td>OSTmrStateGet()</td>\n<td>获取当前定时器状态</td>\n</tr>\n<tr>\n<td><strong>OSTmrStop()</strong></td>\n<td><strong>停止计数器倒计时</strong></td>\n</tr>\n</tbody></table>\n<p><strong>OSTmrCreate()有三种模式</strong></p>\n<ul>\n<li>单次模式（通过OSTmrStart()触发）</li>\n<li>周期无延迟模式</li>\n<li>周期有延迟模式</li>\n</ul>\n<h2 id=\"信号量、互斥信号量、内嵌信号量\"><a href=\"#信号量、互斥信号量、内嵌信号量\" class=\"headerlink\" title=\"信号量、互斥信号量、内嵌信号量\"></a>信号量、互斥信号量、内嵌信号量</h2><h3 id=\"信号量\"><a href=\"#信号量\" class=\"headerlink\" title=\"信号量\"></a>信号量</h3><p>信号量像是一种上锁机制，代码必须获得对应的钥匙才能继续执行，一旦获得了钥匙，也就意味着该任务具有进入被锁部分代码的权限。一旦执行至被锁代码段，则任务一直等待，直到对应被锁部分代码的钥匙被再次释放才能继续执行。</p>\n<ul>\n<li>信号量用于控制对共享资源的保护，但是现在基本用来做任务同步用。</li>\n</ul>\n<h4 id=\"信号量API\"><a href=\"#信号量API\" class=\"headerlink\" title=\"信号量API\"></a>信号量API</h4><table>\n<thead>\n<tr>\n<th>OSSemCreate()</th>\n<th>建立一个信号量</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>OSSemDel()</td>\n<td>删除一个信号量</td>\n</tr>\n<tr>\n<td><strong>OSSemPend()</strong></td>\n<td><strong>等待一个信号量</strong></td>\n</tr>\n<tr>\n<td>OSSemPendAbrot()</td>\n<td>取消等待</td>\n</tr>\n<tr>\n<td><strong>OSSemPost()</strong></td>\n<td><strong>释放或者发出一个信号量</strong></td>\n</tr>\n<tr>\n<td>OSSemSet()</td>\n<td>强制设置一个信号量的值</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">void</span>  <span class=\"hljs-title function_\">OSSemCreate</span> <span class=\"hljs-params\">(OS_SEM      *p_sem,\t\t<span class=\"hljs-comment\">//OS_SEM\tMY_SEM;\t定义一个信号量，用于访问共享资源</span></span><br><span class=\"hljs-params\">                   CPU_CHAR    *p_name,\t\t<span class=\"hljs-comment\">//&quot;MY_SEM&quot;\t名称</span></span><br><span class=\"hljs-params\">                   OS_SEM_CTR   cnt,\t\t<span class=\"hljs-comment\">//如果设置成计数型信号量 此处设置成对应数字即可   如果设置成二进制信号量   此处设置成0即可</span></span><br><span class=\"hljs-params\">                   OS_ERR      *p_err)</span>\t\t<span class=\"hljs-comment\">//</span><br>    <br><span class=\"hljs-title function_\">OSSemCreate</span> <span class=\"hljs-params\">((OS_SEM*\t)&amp;MY_SEM,</span><br><span class=\"hljs-params\">             (CPU_CHAR*\t)<span class=\"hljs-string\">&quot;MY_SEM&quot;</span>,</span><br><span class=\"hljs-params\">             (OS_SEM_CTR)<span class=\"hljs-number\">1</span>,\t\t</span><br><span class=\"hljs-params\">             (OS_ERR*\t)&amp;err)</span>;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>OS_SEM_CTR   cnt,\t\t<ul>\n<li>如果设置成计数型信号量   此处设置成对应数字即可   </li>\n<li>如果设置成二进制信号量   此处设置成0，指示事件的发生（同步）</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">OS_SEM_CTR  <span class=\"hljs-title function_\">OSSemPend</span> <span class=\"hljs-params\">(OS_SEM   *p_sem,</span><br><span class=\"hljs-params\">                       OS_TICK   timeout,</span><br><span class=\"hljs-params\">                       OS_OPT    opt,</span><br><span class=\"hljs-params\">                       CPU_TS   *p_ts,</span><br><span class=\"hljs-params\">                       OS_ERR   *p_err)</span><br><br><span class=\"hljs-title function_\">OSSemPend</span><span class=\"hljs-params\">(&amp;MY_SEM,<span class=\"hljs-number\">0</span>,OS_OPT_PEND_BLOCKING,<span class=\"hljs-number\">0</span>,&amp;err)</span>; \t<span class=\"hljs-comment\">//请求信号量</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>OS_OPT    opt,<ul>\n<li>OS_OPT_PEND_BLOCKING —————-&gt;  阻塞式</li>\n<li>OS_OPT_PEND_NON_BLOCKING ——-&gt; 非阻塞式</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">OS_SEM_CTR  <span class=\"hljs-title function_\">OSSemPost</span> <span class=\"hljs-params\">(OS_SEM  *p_sem,</span><br><span class=\"hljs-params\">                       OS_OPT   opt,</span><br><span class=\"hljs-params\">                       OS_ERR  *p_err)</span><br>    <br><span class=\"hljs-title function_\">OSSemPost</span> <span class=\"hljs-params\">(&amp;MY_SEM,OS_OPT_POST_1,&amp;err)</span>;\t\t\t\t<span class=\"hljs-comment\">//发送 释放 信号量</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>OS_OPT    opt，<ul>\n<li>OS_OPT_POST_1 —–&gt;只使能等待信号量的最高优先级任务   (如果任务正在等待)。</li>\n<li>OS_OPT_POST_ALL  ——&gt;发送到所有等待信号量的任务</li>\n<li>OS_OPT_POST_NO_SCHED  ———&gt;不调用调度程序  可以与其他选项之一一起添加。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"互斥信号量\"><a href=\"#互斥信号量\" class=\"headerlink\" title=\"互斥信号量\"></a>互斥信号量</h3><h4 id=\"互斥信号量API\"><a href=\"#互斥信号量API\" class=\"headerlink\" title=\"互斥信号量API\"></a>互斥信号量API</h4><table>\n<thead>\n<tr>\n<th>OSMutexCreate()</th>\n<th>建立一个互斥信号量</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>OSMutexDel()</td>\n<td>删除一个互斥信号量</td>\n</tr>\n<tr>\n<td><strong>OSMutexPend()</strong></td>\n<td><strong>等待一个互斥信号量</strong></td>\n</tr>\n<tr>\n<td>OSMutexPendAbrot()</td>\n<td>取消等待</td>\n</tr>\n<tr>\n<td><strong>OSMutexPost()</strong></td>\n<td><strong>释放或者发布一个互斥信号量</strong></td>\n</tr>\n</tbody></table>\n<h3 id=\"内嵌信号量\"><a href=\"#内嵌信号量\" class=\"headerlink\" title=\"内嵌信号量\"></a>内嵌信号量</h3><table>\n<thead>\n<tr>\n<th>OSTaskSemPend()</th>\n<th>等待一个任务信号量</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>OSTaskSemPendAbort()</td>\n<td>取消等待任务信号量</td>\n</tr>\n<tr>\n<td><strong>OSTaskSemPost()</strong></td>\n<td><strong>发布任务信号量</strong></td>\n</tr>\n<tr>\n<td>OSTaskSemSet()</td>\n<td>强行设置任务信号量计数</td>\n</tr>\n</tbody></table>\n<h2 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列\"></a>消息队列</h2><h3 id=\"消息队列-1\"><a href=\"#消息队列-1\" class=\"headerlink\" title=\"消息队列\"></a>消息队列</h3><table>\n<thead>\n<tr>\n<th><strong>函数名</strong></th>\n<th><strong>作用</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>OSQCreate()</strong></td>\n<td><strong>创建一个消息   队列</strong></td>\n</tr>\n<tr>\n<td>OSQDel()</td>\n<td>删除一个消息队列</td>\n</tr>\n<tr>\n<td>OSQFlush()</td>\n<td>清空消息队列</td>\n</tr>\n<tr>\n<td><strong>OSQPend()</strong></td>\n<td><strong>等待消息</strong></td>\n</tr>\n<tr>\n<td>OSQPendAbort()</td>\n<td>取消等待消息</td>\n</tr>\n<tr>\n<td><strong>OSQPost()</strong></td>\n<td><strong>向消息队列发布一则消息</strong></td>\n</tr>\n</tbody></table>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">void</span>  <span class=\"hljs-title function_\">OSQCreate</span> <span class=\"hljs-params\">(OS_Q        *p_q,</span><br><span class=\"hljs-params\">                 CPU_CHAR    *p_name,</span><br><span class=\"hljs-params\">                 OS_MSG_QTY   max_qty,</span><br><span class=\"hljs-params\">                 OS_ERR      *p_err)</span><br>    <br><span class=\"hljs-title function_\">OSQCreate</span> <span class=\"hljs-params\">((OS_Q*\t\t)&amp;KEY_Msg,\t<span class=\"hljs-comment\">//消息队列</span></span><br><span class=\"hljs-params\">           (CPU_CHAR*\t)<span class=\"hljs-string\">&quot;KEY Msg&quot;</span>,\t<span class=\"hljs-comment\">//消息队列名称</span></span><br><span class=\"hljs-params\">           (OS_MSG_QTY\t)KEYMSG_Q_NUM,\t<span class=\"hljs-comment\">//消息队列长度，这里设置为1</span></span><br><span class=\"hljs-params\">           (OS_ERR*\t)&amp;err)</span>;\t\t<span class=\"hljs-comment\">//错误码</span><br></code></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">//发送消息</span><br>OSQPost((OS_Q*\t\t)&amp;DATA_Msg,\t\t<br>        (<span class=\"hljs-type\">void</span>*\t\t)pbuf,<br>        (OS_MSG_SIZE)<span class=\"hljs-number\">10</span>,<br>        (OS_OPT\t\t)OS_OPT_POST_FIFO,<br>        (OS_ERR*\t)&amp;err);<br><br></code></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">//请求消息</span><br>p=OSQPend((OS_Q*\t\t)&amp;DATA_Msg,   <br>          (OS_TICK\t\t)<span class=\"hljs-number\">0</span>,<br>          (OS_OPT\t\t)OS_OPT_PEND_BLOCKING,<br>          (OS_MSG_SIZE*\t)&amp;size,\t<br>          (CPU_TS*\t\t)<span class=\"hljs-number\">0</span>,<br>          (OS_ERR*\t\t)&amp;err);<br></code></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<h3 id=\"任务内建消息队列\"><a href=\"#任务内建消息队列\" class=\"headerlink\" title=\"任务内建消息队列\"></a>任务内建消息队列</h3><table>\n<thead>\n<tr>\n<th><strong>函数名</strong></th>\n<th><strong>作用</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>OSTaskQPend()</strong></td>\n<td><strong>等待消息</strong></td>\n</tr>\n<tr>\n<td>OSTaskQPendAbort()</td>\n<td>取消等待消息</td>\n</tr>\n<tr>\n<td><strong>OSTaskQPost()</strong></td>\n<td><strong>向任务发布一则消息</strong></td>\n</tr>\n<tr>\n<td>OSTaskQFlush()</td>\n<td>清空任务的消息队列</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">//创建MSGDIS任务</span><br>OSTaskCreate((OS_TCB \t* )&amp;Msgdis_TaskTCB,\t\t<br>             (CPU_CHAR\t* )<span class=\"hljs-string\">&quot;Msgdis task&quot;</span>, \t\t<br>             (OS_TASK_PTR )msgdis_task, \t\t\t<br>             (<span class=\"hljs-type\">void</span>\t\t* )<span class=\"hljs-number\">0</span>,\t\t\t\t\t<br>             (OS_PRIO\t  )MSGDIS_TASK_PRIO,     <br>             (CPU_STK   * )&amp;MSGDIS_TASK_STK[<span class=\"hljs-number\">0</span>],\t<br>             (CPU_STK_SIZE)MSGDIS_STK_SIZE/<span class=\"hljs-number\">10</span>,\t<br>             (CPU_STK_SIZE)MSGDIS_STK_SIZE,\t\t<br>             (OS_MSG_QTY  )TASK_Q_NUM,\t\t<span class=\"hljs-comment\">//任务Msgdis_task需要使用内建消息队列，消息队列长度为4\t\t\t\t\t</span><br>             (OS_TICK\t  )<span class=\"hljs-number\">0</span>,  \t\t\t\t\t<br>             (<span class=\"hljs-type\">void</span>   \t* )<span class=\"hljs-number\">0</span>,\t\t\t\t\t<br>             (OS_OPT      )OS_OPT_TASK_STK_CHK|OS_OPT_TASK_STK_CLR,<br>             (OS_ERR \t* )&amp;err);<br><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>注意看 OS_MSG_QTY 正常时其设置为0  使用内建消息队列将之设置成对应的数量即可</li>\n</ul>\n<h2 id=\"事件标志组\"><a href=\"#事件标志组\" class=\"headerlink\" title=\"事件标志组\"></a>事件标志组</h2><p>​       在UCOSIII中事件标志组为OS_FLAG_GRP，如果需要使用事件标志组的时候需要将宏OS_CFG_FLAG_EN置1，</p>\n<table>\n<thead>\n<tr>\n<th><strong>函数名</strong></th>\n<th><strong>作用</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>OSFlagCreate()</strong></td>\n<td><strong>创建事件标志组</strong></td>\n</tr>\n<tr>\n<td>OSFlagDel()</td>\n<td>删除事件标志组</td>\n</tr>\n<tr>\n<td><strong>OSFlagPend()</strong></td>\n<td><strong>等待事件标志组</strong></td>\n</tr>\n<tr>\n<td>OSFlagPendAbort()</td>\n<td>取消等待事件标志</td>\n</tr>\n<tr>\n<td>OSFlagPendGetFlagsRdy()</td>\n<td>获取使任务就绪的事件标志</td>\n</tr>\n<tr>\n<td><strong>OSFlagPost()</strong></td>\n<td><strong>向事件标志组发布标志</strong></td>\n</tr>\n</tbody></table>\n<h2 id=\"同时等待多个内核对象\"><a href=\"#同时等待多个内核对象\" class=\"headerlink\" title=\"同时等待多个内核对象\"></a>同时等待多个内核对象</h2><p>​\t在UCOSIII中允许任务同时等待多个<strong>信号量</strong>和多个<strong>消息队列</strong>，也就是说，UCOSIII不支持同时等待多个事件标志组或互斥信号量。</p>\n<p>​    一个任务可以等待任意数量的信号量和消息队列，第一个信号量或消息队列的发布会导致该任务进入就绪态。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">OS_OBJ_QTY  <span class=\"hljs-title function_\">OSPendMulti</span> <span class=\"hljs-params\">(OS_PEND_DATA  *p_pend_data_tbl,</span><br><span class=\"hljs-params\">                         OS_OBJ_QTY     tbl_size,</span><br><span class=\"hljs-params\">                         OS_TICK        timeout,</span><br><span class=\"hljs-params\">                         OS_OPT         opt,</span><br><span class=\"hljs-params\">                         OS_ERR        *p_err)</span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">OS_SEM\tTest_Sem1;\t\t\t<span class=\"hljs-comment\">//信号量1\t\t</span><br>OS_SEM\tTest_Sem2;\t\t\t<span class=\"hljs-comment\">//信号量2</span><br>OS_Q\tTest_Q;\t\t\t\t<span class=\"hljs-comment\">//消息队列</span><br><br>OS_PEND_DATA pend_multi_tbl[CORE_OBJ_NUM];\t<br><br>pend_multi_tbl[<span class=\"hljs-number\">0</span>].PendObjPtr=(OS_PEND_OBJ*)&amp;Test_Sem1;<br>pend_multi_tbl[<span class=\"hljs-number\">1</span>].PendObjPtr=(OS_PEND_OBJ*)&amp;Test_Sem2;<br>pend_multi_tbl[<span class=\"hljs-number\">2</span>].PendObjPtr=(OS_PEND_OBJ*)&amp;Test_Q;<br></code></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<h2 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a>内存管理</h2>",
            "tags": [
                "rtos",
                "ucos"
            ]
        }
    ]
}
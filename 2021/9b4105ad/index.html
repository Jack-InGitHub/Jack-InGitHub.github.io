<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.webp"><link rel="icon" href="/img/favicon.webp"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="Oikiou"><meta name="keywords" content=""><meta name="description" content="Cortex-A7 MPCore架构汇编基础1label： instruction @ comment   label 即标号，表示地址位置，有些指令前面可能会有标号，这样就可以通过这个标号得到指令的地址，标号也可以用来表示数据地址。注意 label 后面的“：”，任何以“：”结尾的标识符都会被识别为一个标号。instruction 即指令，也就是汇编指令或伪指令。@符号，表示后面的是注释comm"><meta property="og:type" content="article"><meta property="og:title" content="LinuxAlphaMini"><meta property="og:url" content="https://www.oikiou.top/2021/9b4105ad/index.html"><meta property="og:site_name" content="Oikiou&#39;s Blog"><meta property="og:description" content="Cortex-A7 MPCore架构汇编基础1label： instruction @ comment   label 即标号，表示地址位置，有些指令前面可能会有标号，这样就可以通过这个标号得到指令的地址，标号也可以用来表示数据地址。注意 label 后面的“：”，任何以“：”结尾的标识符都会被识别为一个标号。instruction 即指令，也就是汇编指令或伪指令。@符号，表示后面的是注释comm"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.oikiou.top/2021/9b4105ad/image-20210707144653945.png"><meta property="og:image" content="https://www.oikiou.top/2021/9b4105ad/image-20231107151921777.png"><meta property="og:image" content="https://www.oikiou.top/2021/9b4105ad/image-20231107162628528.png"><meta property="og:image" content="https://www.oikiou.top/2021/9b4105ad/c8e0872247ff49de99539712b5b6237f.png"><meta property="og:image" content="https://www.oikiou.top/2021/9b4105ad/f5acc963e742489185cd4cf5d1bc774f.png"><meta property="og:image" content="https://www.oikiou.top/2021/9b4105ad/image-20230821122002797.png"><meta property="og:image" content="https://www.oikiou.top/2021/9b4105ad/image-20230818180021537.png"><meta property="og:image" content="https://www.oikiou.top/2021/9b4105ad/image-20230818180129919.png"><meta property="article:published_time" content="2021-07-07T06:46:15.000Z"><meta property="article:modified_time" content="2024-08-07T09:07:46.916Z"><meta property="article:author" content="Oikiou"><meta property="article:tag" content="linux"><meta property="article:tag" content="alpha_mini"><meta property="article:tag" content="正点原子"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://www.oikiou.top/2021/9b4105ad/image-20210707144653945.png"><meta name="referrer" content="no-referrer-when-downgrade"><title>LinuxAlphaMini - Oikiou&#39;s Blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/custom.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"www.oikiou.top",root:"/",version:"1.9.8",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"bash"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"left",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!1,baidu:null,google:"G-TSV6137NWK",tencent:{sid:null,cid:null},leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1},umami:{src:null,website_id:null,domains:null,start_time:"2024-01-01T00:00:00.000Z",token:null,api_server:null},gtag:"G-TSV6137NWK",woyaola:null,cnzz:null},search_path:"/xml/local-search-database.xml",include_content_in_search:!0};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 7.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Oikiou&#39;s Blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item"><a class="nav-link" href="/links/" target="_self"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(https://bing.img.run/1920x1080.php) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="LinuxAlphaMini"></span></div><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> Oikiou </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2021-07-07 14:46" pubdate>2021年7月7日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 19k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 325 分钟 </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="padding-left:2rem;margin-right:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">LinuxAlphaMini</h1><p id="updated-time" class="note note-info" style="display:none">本文最后更新于 2024-08-07T17:07:46+08:00</p><div class="markdown-body"><h1 id="Cortex-A7-MPCore架构"><a href="#Cortex-A7-MPCore架构" class="headerlink" title="Cortex-A7 MPCore架构"></a>Cortex-A7 MPCore架构</h1><h1 id="汇编基础"><a href="#汇编基础" class="headerlink" title="汇编基础"></a>汇编基础</h1><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">label： instruction @ comment <br></code></pre></td></tr></table></figure><p><strong>label 即标号</strong>，表示地址位置，有些指令前面可能会有标号，这样就可以通过这个标号得到指令的地址，标号也可以用来表示数据地址。注意 label 后面的“：”，任何以“：”结尾的标识符都会被识别为一个标号。<br><strong>instruction 即指令</strong>，也就是汇编指令或伪指令。<br><strong>@符号</strong>，表示后面的是注释<br><strong>comment</strong> 就是注释内容。</p><p>例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">add:<br>MOVS R0, #0X12 @设置 R0=0X12<br></code></pre></td></tr></table></figure><p><strong>注意！ ARM 中的指令、伪指令、伪操作、寄存器名等可以全部使用大写，也可以全部使用小写，但是不能大小写混用。</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">.section .testsection @定义一个 testsetcion 段 <br></code></pre></td></tr></table></figure><ul><li>.text 表示代码段。</li><li>.data 初始化的数据段。</li><li>.bss 未初始化的数据段。</li><li>.rodata 只读数据段。</li></ul><p><strong>伪操作:</strong></p><ul><li>.byte 定义单字节数据，比如.byte 0x12。</li><li>.short 定义双字节数据，比如.short 0x1234。</li><li>.long 定义一个 4 字节数据，比如.long 0x12345678。</li><li>.equ 赋值语句，格式为： .equ 变量名，表达式，比如.equ num, 0x12，表示 num&#x3D;0x12。</li><li>.align 数据字节对齐，比如： .align 4 表示 4 字节对齐。</li><li>.end 表示源文件结束。</li><li>.global 定义一个全局符号，格式为： .global symbol，比如： .global _start(汇编程序的默认入口标号是_start )。</li></ul><p><strong>函数:</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">函数名:<br> 函数体<br> 返回语句<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">/* SVC 中断 */<br>SVC_Handler:<br>    ldr r0, =SVC_Handler<br>    bx r0     @跳转<br></code></pre></td></tr></table></figure><h2 id="常用汇编指令"><a href="#常用汇编指令" class="headerlink" title="常用汇编指令"></a>常用汇编指令</h2><h3 id="处理器内部数据传输指令-mov-mrs-msr"><a href="#处理器内部数据传输指令-mov-mrs-msr" class="headerlink" title="处理器内部数据传输指令 mov mrs msr"></a>处理器内部数据传输指令 mov mrs msr</h3><table><thead><tr><th>指令</th><th>目的</th><th>源</th><th></th></tr></thead><tbody><tr><td>MOV</td><td>R0</td><td>R1</td><td>将 R1 里面的数据复制到 R0 中。</td></tr><tr><td>MRS</td><td>R0</td><td>CPSR</td><td>将特殊寄存器 CPSR 里面的数据复制到 R0 中。<br><strong>(特殊寄存器只能由这个指令 读 )</strong></td></tr><tr><td>MSR</td><td>CPSR</td><td>R1</td><td>将 R1 里面的数据复制到特殊寄存器 CPSR 里中。<br><strong>(特殊寄存器只能由这个指令 写 )</strong></td></tr></tbody></table><h3 id="存储器访问指令-ldr-str"><a href="#存储器访问指令-ldr-str" class="headerlink" title="存储器访问指令 ldr str"></a>存储器访问指令 ldr str</h3><p>I.MX6UL中的RAM,寄存器都需要这个指令访问。</p><p>LDR和STR是按照字进行读取和写入的，LDRB和STRB是按字节，LDRH和STRH是按半字操作。</p><table><thead><tr><th>指令</th><th></th></tr></thead><tbody><tr><td>LDR Rd, [Rn , #offset]</td><td>从存储器 Rn+offset 的位置读取数据存放到 Rd 中。</td></tr><tr><td>STR Rd, [Rn, #offset]</td><td>将 Rd 中的数据写入到存储器中的 Rn+offset 位置。</td></tr></tbody></table><h4 id="LDR"><a href="#LDR" class="headerlink" title="LDR"></a>LDR</h4><ul><li><p>读取寄存器值</p></li><li><p>加载立即数到寄存器</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">@加载立即数<br>LDR R0, =0X0209C004 @将寄存器地址 0X0209C004 加载到 R0 中，即 R0=0X0209C004<br>@读取寄存器值<br>LDR R1, [R0] @读取地址 0X0209C004 中的数据到 R1 寄存器中<br></code></pre></td></tr></table></figure><h4 id="STR"><a href="#STR" class="headerlink" title="STR"></a>STR</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">LDR R0, =0X0209C004 @将寄存器地址 0X0209C004 加载到 R0 中，即 R0=0X0209C004<br>LDR R1, =0X12345678 @R1 保存要写入到寄存器的值，即 R1=0X12345678<br>STR R1, [R0] @将 R1 中的值写入到 R0 中的地址上<br></code></pre></td></tr></table></figure><h3 id="压栈出栈指令-push-pop"><a href="#压栈出栈指令-push-pop" class="headerlink" title="压栈出栈指令 push pop"></a>压栈出栈指令 push pop</h3><table><thead><tr><th>指令</th><th></th></tr></thead><tbody><tr><td>PUSH &lt;reg list&gt;</td><td>将寄存器列表存入栈中。</td></tr><tr><td>POP &lt;reg list&gt;</td><td>从栈中恢复寄存器列表。</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asm">@处理器的堆栈是向下增长的 见下图<br>PUSH &#123;R0~R3, R12&#125; @将 R0~R3 和 R12 压栈<br>PUSH &#123;LR&#125; @将 LR 进行压栈<br><br>POP &#123;LR&#125; @先恢复 LR<br>POP &#123;R0~R3,R12&#125; @在恢复 R0~R3,R12<br></code></pre></td></tr></table></figure><p><img src="/2021/9b4105ad/image-20210707144653945.png" srcset="/img/loading.gif" lazyload alt="image-20210707144653945"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs asm">@这个和上面的是等同的<br>STMFD SP!,&#123;R0~R3, R12&#125; @R0~R3,R12 入栈<br>STMFD SP!,&#123;LR&#125; @LR 入栈<br><br>LDMFD SP!, &#123;LR&#125; @先恢复 LR<br>LDMFD SP!, &#123;R0~R3, R12&#125; @再恢复 R0~R3, R12<br><br><br>LDMFD = LDM + FD<br>STMFD = STM + FD<br>LDM(多个) -&gt; LDR(单个)<br>STM(多个) -&gt; STR(单个)<br>FD = Full Descending 即满递减的意思(根据 ATPCS 规则,ARM 使用的 FD 类型的堆栈， SP 指向最后一个入栈的数值，堆栈是由高地址向下增长的，也就是前面说的向下增长的堆栈，)<br></code></pre></td></tr></table></figure><h3 id="跳转指令-b-bx-bl-blx"><a href="#跳转指令-b-bx-bl-blx" class="headerlink" title="跳转指令 b bx bl blx"></a>跳转指令 b bx bl blx</h3><p>跳转操作的方法</p><ol><li>直接使用跳转指令 B、 BL、 BX 等</li><li>直接向 PC 寄存器里面写入数据。</li></ol><table><thead><tr><th>指令</th><th></th></tr></thead><tbody><tr><td>B &lt;label&gt;</td><td>跳转到 label，如果跳转范围超过了+&#x2F;-2KB，<br>可以指定 B.W &lt;label&gt;使用 32 位版本的跳转指令， 这样可以得到较大范围的 跳转</td></tr><tr><td>BX &lt;Rm&gt;</td><td>间接跳转，跳转到存放于 Rm 中的地址处，并且切换指令集</td></tr><tr><td>BL &lt;label&gt;</td><td>跳转到标号地址，并将返回地址保存在 LR 中。</td></tr><tr><td>BLX &lt;Rm&gt;</td><td>结合 BX 和 BL 的特点，跳转到 Rm 指定的地址，并将返回地 址保存在 LR 中，切换指令集。</td></tr></tbody></table><h4 id="B指令"><a href="#B指令" class="headerlink" title="B指令"></a>B指令</h4><p>这是最简单的跳转指令， B 指令会将 PC 寄存器的值设置为跳转目标地址， 一旦执行 B 指令， ARM 处理器就会立即跳转到指定的目标地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">_start:<br>    ldr sp,=0X80200000 @设置栈指针<br>    b main @跳转到 main 函数<br></code></pre></td></tr></table></figure><p>上述代码就是典型的在汇编中初始化 C 运行环境，然后跳转到 C 文件的 main 函数中运行 ，上述代码只是初始化了 SP 指针，有些处理器还需要做其他的初始化，比如初始化 DDR 等等。因为跳转到 C 文件以后再也不会回到汇编了，所以在第 4 行使用了 B 指令来完成跳转 。</p><h4 id="BL指令"><a href="#BL指令" class="headerlink" title="BL指令"></a>BL指令</h4><p>BL 指令相比 B 指令，在跳转之前会在寄存器 LR(R14)中保存当前 PC 寄存器值，所以可以通过将 LR 寄存器中的值重新加载到 PC 中来继续从跳转之前的代码处运行，这是子程序调用一个基本但常用的手段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asm">push &#123;r0, r1&#125; 			@保存 r0,r1<br>cps #0x13 				@进入 SVC 模式，允许其他中断再次进去<br><br>bl system_irqhandler	@加载 C 语言中断处理函数到 r2 寄存器中<br><br>cps #0x12 				@进入 IRQ 模式<br>pop &#123;r0, r1&#125;<br>str r0, [r1, #0X10] 	@中断执行完成，写 EOIR<br></code></pre></td></tr></table></figure><p>上述代码中第 5 行就是执行 C 语言版的中断处理函数，当处理完成以后是需要返回来继续执行下面的程序，所以使用了 BL 指令。</p><h3 id="算术运算指令"><a href="#算术运算指令" class="headerlink" title="算术运算指令"></a>算术运算指令</h3><p>汇编中也可以进行算术运算， 比如加减乘除，常用的运算指令用法如表 7.2.5.1 所示：</p><table><thead><tr><th>指令</th><th>计算公式</th><th></th></tr></thead><tbody><tr><td>ADD Rd, Rn, Rm</td><td>Rd &#x3D; Rn + Rm</td><td>加法运算，指令为 ADD</td></tr><tr><td>ADD Rd, Rn, #immed</td><td>Rd &#x3D; Rn + #immed</td><td>加法运算，指令为 ADD</td></tr><tr><td>ADC Rd, Rn, Rm</td><td>Rd &#x3D; Rn + Rm + 进位</td><td>带进位的加法运算，指令为 ADC</td></tr><tr><td>ADC Rd, Rn, #immed</td><td>Rd &#x3D; Rn + #immed +进位</td><td>带进位的加法运算，指令为 ADC</td></tr><tr><td>SUB Rd, Rn, Rm</td><td>Rd &#x3D; Rn – Rm</td><td>减法</td></tr><tr><td>SUB Rd, #immed</td><td>Rd &#x3D; Rd - #immed</td><td>减法</td></tr><tr><td>SUB Rd, Rn, #immed</td><td>Rd &#x3D; Rn - #immed</td><td>减法</td></tr><tr><td>SBC Rd, Rn, #immed</td><td>Rd &#x3D; Rn - #immed – 借位</td><td>带借位的减法</td></tr><tr><td>SBC Rd, Rn ,Rm</td><td>Rd &#x3D; Rn – Rm – 借位</td><td>带借位的减法</td></tr><tr><td>MUL Rd, Rn, Rm</td><td>Rd &#x3D; Rn * Rm</td><td>乘法(32 位)</td></tr><tr><td>UDIV Rd, Rn, Rm</td><td>Rd &#x3D; Rn &#x2F; Rm</td><td>无符号除法</td></tr><tr><td>SDIV Rd, Rn, Rm</td><td>Rd &#x3D; Rn &#x2F; Rm</td><td>有符号除法</td></tr></tbody></table><h3 id="逻辑运算指令"><a href="#逻辑运算指令" class="headerlink" title="逻辑运算指令"></a>逻辑运算指令</h3><table><thead><tr><th>指令</th><th>计算公式</th><th></th></tr></thead><tbody><tr><td>AND Rd, Rn</td><td>Rd &#x3D; Rd &amp;Rn</td><td>按位与</td></tr><tr><td>AND Rd, Rn, #immed</td><td>Rd &#x3D; Rn &amp;#immed</td><td>按位与</td></tr><tr><td>AND Rd, Rn, Rm</td><td>Rd &#x3D; Rn &amp; Rm</td><td>按位与</td></tr><tr><td>ORR Rd, Rn</td><td>Rd &#x3D; Rd | Rn</td><td>按位或</td></tr><tr><td>ORR Rd, Rn, #immed</td><td>Rd &#x3D; Rn | #immed</td><td>按位或</td></tr><tr><td>ORR Rd, Rn, Rm</td><td>Rd &#x3D; Rn | Rm</td><td>按位或</td></tr><tr><td>BIC Rd, Rn</td><td>Rd &#x3D; Rd &amp; (~Rn)</td><td>位清除</td></tr><tr><td>BIC Rd, Rn, #immed</td><td>Rd &#x3D; Rn &amp; (~#immed)</td><td>位清除</td></tr><tr><td>BIC Rd, Rn , Rm</td><td>Rd &#x3D; Rn &amp; (~Rm)</td><td>位清除</td></tr><tr><td>ORN Rd, Rn, #immed</td><td>Rd &#x3D; Rn | (#immed)</td><td>按位或非</td></tr><tr><td>ORN Rd, Rn, Rm</td><td>Rd &#x3D; Rn | (Rm)</td><td>按位或非</td></tr><tr><td>EOR Rd, Rn</td><td>Rd &#x3D; Rd ^ Rn</td><td>按位异或</td></tr><tr><td>EOR Rd, Rn, #immed</td><td>Rd &#x3D; Rn ^ #immed</td><td>按位异或</td></tr><tr><td>EOR Rd, Rn, Rm</td><td>Rd &#x3D; Rn ^ Rm</td><td>按位异或</td></tr></tbody></table><h1 id="启动方式"><a href="#启动方式" class="headerlink" title="启动方式"></a>启动方式</h1><h2 id="BOOT"><a href="#BOOT" class="headerlink" title="BOOT"></a>BOOT</h2><p>OOT_MODE[1:0]的值是可以改变的，有两种方式，一种是改写 eFUSE(熔丝)，一种是修改相应的 GPIO 高低电平。</p><ul><li>BOOT_MODE1 和 BOOT_MODE0 在芯片内部是有 100KΩ下拉电阻的 ，所以默认是0。</li></ul><table><thead><tr><th>BOOT_MODE[1:0]</th><th>BOOT 类型</th></tr></thead><tbody><tr><td>00</td><td>从 FUSE 启动</td></tr><tr><td>01</td><td>串行下载</td></tr><tr><td>10</td><td>内部 BOOT 模式</td></tr><tr><td>11</td><td>保留</td></tr></tbody></table><h3 id="串行下载"><a href="#串行下载" class="headerlink" title="串行下载"></a>串行下载</h3><p>串行下载的意思就是可以通过 USB 或者 UART 将代码下载到板子上的外置存储设备中，我们可以使用 OTG1 这个 USB口向开发板上的 SD&#x2F;EMMC、 NAND 等存储设备下载代码。</p><h3 id="内部-BOOT-模式"><a href="#内部-BOOT-模式" class="headerlink" title="内部 BOOT 模式"></a>内部 BOOT 模式</h3><p>芯片会执行内部的 boot ROM 代码，代码会进行硬件初始化(一部分外设)，然后从 boot 设备(就是存放代码的设备、比如 SD&#x2F;EMMC、 NAND)中<strong>将代码拷贝出来复制到指定的 RAM 中，一般是 DDR。</strong></p><h2 id="BOOT模式-启动设备"><a href="#BOOT模式-启动设备" class="headerlink" title="BOOT模式 启动设备"></a>BOOT模式 启动设备</h2><p>当 BOOT_MODE 设置为内部 BOOT 模式以后，可以从以下设备中启动：<br>①、接到 EIM 接口的 CS0 上的 16 位 NOR Flash。<br>②、接到 EIM 接口的 CS0 上的 OneNAND Flash。<br>③、接到 GPMI 接口上的 MLC&#x2F;SLC NAND Flash， NAND Flash 页大小支持 2KByte、 4KByte和 8KByte， 8 位宽。<br>④、 Quad SPI Flash。<br>⑤、接到 USDHC 接口上的 SD&#x2F;MMC&#x2F;eSD&#x2F;SDXC&#x2F;eMMC 等设备。<br>⑥、 SPI 接口的 EEPROM。</p><p>启动设备是通过 BOOT_CFG1[7:0]、 BOOT_CFG2[7:0]和 BOOT_CFG4[7:0]这 24 个配置 IO配置，这 24 个配置 IO 刚好对应着 LCD 的 24 根数据线 LCD_DATA0~LCDDATA23，<strong>当启动完成以后这 24 个 IO 就可以作为 LCD 的数据线使用。</strong></p><table><thead><tr><th>boot1</th><th>boot0</th><th></th><th></th><th></th><th></th><th></th><th></th><th>启动设备</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>x</td><td>x</td><td>x</td><td>x</td><td>x</td><td>x</td><td>串行下载，可以通过 USB 烧写镜像文件。</td></tr><tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>SD 卡启动。</td></tr><tr><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>EMMC 启动。</td></tr><tr><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>NAND FLASH 启动。</td></tr></tbody></table><h2 id="烧写镜像"><a href="#烧写镜像" class="headerlink" title="烧写镜像"></a>烧写镜像</h2><p><strong>imxdownload 会在 led.bin前面添加一些头信息，重新生成一个叫做 load.imx 的文件，头部信息包含以下</strong></p><ul><li><p>Image vector table，简称 IVT， IVT 里面包含了一系列的地址信息，这些地址信息在ROM 中按照固定的地址存放着。</p></li><li><p>Boot data，启动数据，包含了镜像要拷贝到哪个地址，拷贝的大小是多少等等。</p></li><li><p>Device configuration data，简称 DCD，设备配置信息，重点是 DDR3 的初始化配置。</p></li><li><p>用户代码可执行文件，比如 led.bin。</p></li></ul><p>最终烧写到 I.MX6U 中的程序其组成为： IVT+Boot data+DCD+.bin 。(3KByte 的 IVT+Boot Data+DCD)</p><p>.bin是从0x87800000这个地方开始，往前推load.imx就是从0x877FF400开始的。</p><h1 id="点灯Makefile"><a href="#点灯Makefile" class="headerlink" title="点灯Makefile"></a>点灯Makefile</h1><p><strong>Makefile</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 定义了一个变量 objs， objs 包含着要生成 ledc.bin 所需的材料： start.o 和 main.o</span><br><span class="hljs-comment"># 这里要注意 start.o 一定要放到最前面！因为在后面链接的时候 start.o 要在最前面，因为 start.o 是最先要执行的文件！</span><br>objs := start.o main.o<br><br><span class="hljs-comment"># 使用依赖文件(objs:=start.o main.o),生成目标可执行文件ledc.bin</span><br><span class="hljs-section">ledc.bin:<span class="hljs-variable">$(objs)</span></span><br>	<span class="hljs-comment"># 使用编译器 arm-linux-gnueabihf-ld 进行连接,-Ttext指定起始地址是0X87800000</span><br>	<span class="hljs-comment"># $^ 是所有依赖文件的集合,也就是变量objs的值(start.o main.o)</span><br>	<span class="hljs-comment"># 展开等价 arm-linux-gnueabihf-ld -Ttext 0X87800000 -o ledc.elf start.o main.o</span><br>	arm-linux-gnueabihf-ld -Ttext 0X87800000 -o ledc.elf <span class="hljs-variable">$^</span><br>	<span class="hljs-comment"># 将ledc.elf转换成ledc.bin文件</span><br>	<span class="hljs-comment"># $@ 的意思是目标集合，在这里就是 ledc.bin</span><br>	<span class="hljs-comment"># 展开等价 arm-linux-gnueabihf-objcopy -O binary -S ledc.elf ledc.bin</span><br>	arm-linux-gnueabihf-objcopy -O binary -S ledc.elf <span class="hljs-variable">$@</span><br>	<span class="hljs-comment"># 反汇编，生成 ledc.dis 文件</span><br>	arm-linux-gnueabihf-objdump -D -m arm ledc.elf &gt; ledc.dis<br><br><span class="hljs-comment"># 下面规则展开等价 </span><br><span class="hljs-comment"># start.o:start.s</span><br><span class="hljs-comment">#	arm-linux-gnueabihf-gcc -Wall -nostdlib -c -O2 -o start.o start.s</span><br><span class="hljs-comment"># %匹配任意字符</span><br><span class="hljs-section">%.o:%.s</span><br>	<span class="hljs-comment"># $@ 的意思是目标集合，在这里就是 %.o</span><br>	<span class="hljs-comment"># $&lt; 所有依赖文件的集合，在这就是 %.s</span><br>	arm-linux-gnueabihf-gcc -Wall -nostdlib -c -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br><span class="hljs-section">%.o:%.S</span><br>	arm-linux-gnueabihf-gcc -Wall -nostdlib -c -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br><span class="hljs-section">%.o:%.c</span><br>	arm-linux-gnueabihf-gcc -Wall -nostdlib -c -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br><br><span class="hljs-section">clean:</span><br>	rm -rf *.o ledc.bin ledc.elf ledc.dis<br></code></pre></td></tr></table></figure><p><strong>Makefile</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 类似于上面的只是用到了变量</span><br>CROSS_COMPILE	?= arm-linux-gnueabihf-<br>NAME 			?= ledc<br><br>CC 				:= <span class="hljs-variable">$(CROSS_COMPILE)</span>gcc<br>LD 				:= <span class="hljs-variable">$(CROSS_COMPILE)</span>ld<br>OBJCOPY 		:= <span class="hljs-variable">$(CROSS_COMPILE)</span>objcopy<br>OBJDUMP 		:= <span class="hljs-variable">$(CROSS_COMPILE)</span>objdump<br>OBJS 			:= start.o main.o<br><br><span class="hljs-variable">$(NAME)</span>.bin:<span class="hljs-variable">$(OBJS)</span><br>	<span class="hljs-variable">$(LD)</span> -Timx6ul.lds -o <span class="hljs-variable">$(NAME)</span>.elf <span class="hljs-variable">$^</span><br>	<span class="hljs-variable">$(OBJCOPY)</span> -O binary -S <span class="hljs-variable">$(NAME)</span>.elf <span class="hljs-variable">$@</span><br>	<span class="hljs-variable">$(OBJDUMP)</span> -D -m arm <span class="hljs-variable">$(NAME)</span>.elf &gt; <span class="hljs-variable">$(NAME)</span>.dis<br>    <br><span class="hljs-section">%.o:%.s</span><br>	<span class="hljs-variable">$(CC)</span> -Wall -nostdlib -c -O2 -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br><span class="hljs-section">%.o:%.S</span><br>	<span class="hljs-variable">$(CC)</span> -Wall -nostdlib -c -O2 -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br><span class="hljs-section">%.o:%.c</span><br>	<span class="hljs-variable">$(CC)</span> -Wall -nostdlib -c -O2 -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br>	<br><span class="hljs-section">clean:</span><br>	rm -rf *.o <span class="hljs-variable">$(NAME)</span>.bin <span class="hljs-variable">$(NAME)</span>.elf <span class="hljs-variable">$(NAME)</span>.dis<br></code></pre></td></tr></table></figure><p><strong>Makefile</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs makefile">CROSS_COMPILE	?= arm-linux-gnueabihf-<br><span class="hljs-comment"># 编译后 目标名</span><br>TARGET			?= bsp<br><br><span class="hljs-comment"># 编译器相关</span><br>CC				:= <span class="hljs-variable">$(CROSS_COMPILE)</span>gcc<br>LD				:= <span class="hljs-variable">$(CROSS_COMPILE)</span>ld<br>OBJCOPY			:= <span class="hljs-variable">$(CROSS_COMPILE)</span>objcopy<br>OBJDUMP			:= <span class="hljs-variable">$(CROSS_COMPILE)</span>objdump<br><br><span class="hljs-comment"># include dir</span><br>INCDIRS			:=  imx6ul  \<br>					bsp/clk \<br>					bsp/led \<br>					bsp/delay<br><br><span class="hljs-comment"># sourc dir</span><br>SRCDIRS 		:=  project \<br>					bsp/clk \<br>					bsp/led \<br>					bsp/delay<br><br><span class="hljs-comment"># 这里用到了 patsubst 函数 通过这个函数给 INCDIRS 前面加了一个 -I</span><br><span class="hljs-comment"># 展开 INCLUDE := -I imx6ul -I bsp/clk -I bsp/led -I bsp/delay</span><br>INCLUDE 		:= <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %, -I %, <span class="hljs-variable">$(INCDIRS)</span>)</span><br><br><span class="hljs-comment"># 这里用到了 foreach 和 wildcard 函数</span><br><span class="hljs-comment"># 展开 SFILES := project/start.S</span><br><span class="hljs-comment"># 展开 CFILES := project/main.c bsp/clk/bsp_clk.c bsp/led/bsp_led.c bsp/delay/bsp_delay.c</span><br>SFILES 			:= <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> <span class="hljs-built_in">dir</span>, <span class="hljs-variable">$(SRCDIRS)</span>, $(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(dir)</span>/*.S)</span>)<br>CFILES 			:= <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> <span class="hljs-built_in">dir</span>, <span class="hljs-variable">$(SRCDIRS)</span>, $(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(dir)</span>/*.c)</span>)<br><br><span class="hljs-comment"># 这里用到了 notdir 函数 除去路径函数</span><br><span class="hljs-comment"># 展开 SFILENDIR := start.S</span><br><span class="hljs-comment"># 展开 CFILENDIR := main.c bsp_clk.c bsp_led.c bsp_delay.c</span><br>SFILENDIR 		:= <span class="hljs-variable">$(<span class="hljs-built_in">notdir</span> <span class="hljs-variable">$(SFILES)</span>)</span><br>CFILENDIR 		:= <span class="hljs-variable">$(<span class="hljs-built_in">notdir</span> <span class="hljs-variable">$(CFILES)</span>)</span><br><br><span class="hljs-comment"># 展开 SOBJS := obj/start.o</span><br><span class="hljs-comment"># 展开 COBJS := obj/main.o obj/bsp_clk.o obj/bsp_led.o obj/bsp_delay.o</span><br><span class="hljs-comment"># 展开 OBJS  := obj/start.o obj/main.o obj/bsp_clk.o obj/bsp_led.o obj/bsp_delay.o</span><br>SOBJS 			:= <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %, obj/%, $(SFILENDIR:.S=.o)</span>)<br>COBJS 			:= <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %, obj/%, $(CFILENDIR:.c=.o)</span>)<br>OBJS 			:= <span class="hljs-variable">$(SOBJS)</span> <span class="hljs-variable">$(COBJS)</span><br><br>VPATH 			:= <span class="hljs-variable">$(SRCDIRS)</span><br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: clean</span><br><br><span class="hljs-variable">$(TARGET)</span>.bin : <span class="hljs-variable">$(OBJS)</span><br>	<span class="hljs-variable">$(LD)</span> -Timx6ul.lds -o <span class="hljs-variable">$(TARGET)</span>.elf <span class="hljs-variable">$^</span><br>	<span class="hljs-variable">$(OBJCOPY)</span> -O binary -S <span class="hljs-variable">$(TARGET)</span>.elf <span class="hljs-variable">$@</span><br>	<span class="hljs-variable">$(OBJDUMP)</span> -D -m arm <span class="hljs-variable">$(TARGET)</span>.elf &gt; <span class="hljs-variable">$(TARGET)</span>.dis<br><br><span class="hljs-variable">$(SOBJS)</span> : obj/%.o : %.S<br>	<span class="hljs-variable">$(CC)</span> -Wall -nostdlib -c -O2 <span class="hljs-variable">$(INCLUDE)</span> -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br><span class="hljs-variable">$(COBJS)</span> : obj/%.o : %.c<br>	<span class="hljs-variable">$(CC)</span> -Wall -nostdlib -c -O2 <span class="hljs-variable">$(INCLUDE)</span> -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br><br><span class="hljs-section">clean:</span><br>	rm -rf <span class="hljs-variable">$(TARGET)</span>.elf <span class="hljs-variable">$(TARGET)</span>.dis <span class="hljs-variable">$(TARGET)</span>.bin <span class="hljs-variable">$(COBJS)</span> <span class="hljs-variable">$(SOBJS)</span><br></code></pre></td></tr></table></figure><h1 id="Board-Support"><a href="#Board-Support" class="headerlink" title="Board Support"></a>Board Support</h1><ul><li>正点原子的 I.MX6ULL EMMC 核心板上 FSL_SDHC(0)接的 SD(TF)卡，FSL_SDHC(1)接的 EMMC。</li></ul><h1 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h1><h2 id="Ubuntu-交叉编译工具链安装"><a href="#Ubuntu-交叉编译工具链安装" class="headerlink" title="Ubuntu 交叉编译工具链安装"></a>Ubuntu 交叉编译工具链安装</h2><blockquote><p>交叉编译器有很多种，我们使用 Linaro 出品的交叉编译器，Linaro 是一间非营利性质的开放源代码软件工程公司，Linaro 开发了很多软件，最著名的就是 Linaro GCC 编译工具链(编译器)</p></blockquote><p>Linaro 编译器7.5.0下载<a target="_blank" rel="noopener" href="https://releases.linaro.org/components/toolchain/binaries/latest-7/arm-linux-gnueabihf/">链接</a></p><ol><li><p>有很多种 GCC 交叉编译工具链，因为我们所使用的 I.MX6U-ALPHA 开发板是一个 Cortex-A7 内核的开发板，因此选择 arm-linux-gnueabihf</p><blockquote><p>aarch64-elf<br>aarch64-linux-gnu<br>aarch64_be-elf<br>aarch64_be-linux-gnu<br>arm-eabi<br>arm-linux-gnueabi<br><strong>arm-linux-gnueabihf</strong><br>armeb-eabi<br>armeb-linux-gnueabihf<br>armv8l-linux-gnueabihf</p></blockquote></li><li><p><code>gcc-linaro-7.5.0-2019.12-x86_64_arm-linux-gnueabihf.tar.xz</code> 这个文件就是7.5.0版本的GCC交叉编译器，用于X86——64位的linux上运行</p><ol><li><strong>需要注意的是</strong>，这个开发板用的是4.9.4版本的编译器，过高版本的编译器会有一些问题。</li><li><a target="_blank" rel="noopener" href="https://releases.linaro.org/components/toolchain/binaries/4.9-2017.01/arm-linux-gnueabihf/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf.tar.xz">Linaro 4.9.4 下载链接</a></li></ol></li><li><p>下载好编译器之后需要做的就是将编译器添加到环境变量，使得可以在任何目录下调用编译器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo mkdir /usr/local/arm<br><br>sudo cp gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf.tar.xz /usr/local/arm/ -f<br><br>sudo tar -vxf gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf.tar.xz<br><br>sudo vi /etc/profile<br><br>export PATH=$PATH:/usr/local/arm/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin<br></code></pre></td></tr></table></figure></li><li><p>搞定环境变量之后需要安装一些其他的编译库</p><ol><li><code>sudo apt-get install lsb-core lib32stdc++6</code></li></ol></li><li><p>验证编译器</p><ol><li>任意目录输入<code>arm-linux-gnueabihf-gcc -v</code> 即可查看编译器版本号</li><li>arm 表示这是编译 arm 架构代码的编译器。<br>linux 表示运行在 linux 环境下。<br>gnueabihf 表示嵌入式二进制接口。<br>gcc 表示是 gcc 工具</li></ol></li></ol><h1 id="烧写程序"><a href="#烧写程序" class="headerlink" title="烧写程序"></a>烧写程序</h1><h2 id="烧写Uboot"><a href="#烧写Uboot" class="headerlink" title="烧写Uboot"></a>烧写Uboot</h2><h3 id="烧写到SD卡，通过ta启动uboot"><a href="#烧写到SD卡，通过ta启动uboot" class="headerlink" title="烧写到SD卡，通过ta启动uboot"></a>烧写到SD卡，通过ta启动uboot</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod 777 imxdownload<br><span class="hljs-meta prompt_"># </span><span class="language-bash">烧写到 SD 卡，注意区别设备号 不能烧写到/dev/sda 或 sda1 设备里面！</span><br>./imxdownload u-boot.bin /dev/sdd<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">烧写uboot之后就可以通过网络的方式加载 linux kernel 和 rootfs 参考boot章节</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者通过mfg工具将准备好的固件打包下载到特定存储介质上</span><br></code></pre></td></tr></table></figure><h3 id="烧写到EMMC-NAND，通过ta启动uboot"><a href="#烧写到EMMC-NAND，通过ta启动uboot" class="headerlink" title="烧写到EMMC&#x2F;NAND，通过ta启动uboot"></a>烧写到EMMC&#x2F;NAND，通过ta启动uboot</h3><h1 id="U-Boot"><a href="#U-Boot" class="headerlink" title="U-Boot"></a>U-Boot</h1><p>uboot 的全称是 Universal Boot Loader。</p><p>Linux 系统要启动就必须需要一个 bootloader 程序，也就说芯片上电以后先运行一段bootloader 程序。这段 bootloader程序会先初始化 DDR等外设，然后将Linux 内核从flash(NAND，NOR FLASH，SD，MMC 等)拷贝到 DDR 中，最后启动 Linux 内核。当然了，bootloader 的实际工作要复杂的多，但是它最主要的工作就是启动 Linux 内核，bootloader 和 Linux 内核的关系就跟 PC 上的 BIOS 和 Windows 的关系一样，bootloader 就相当于 BIOS。所以我们要先搞定bootloader，很庆幸，有很多现成的 bootloader 软件可以使用，比如 U-Boot、vivi、RedBoot 等等，其中以 U-Boot 使用最为广泛。</p><p>U-Boot分为以下几种</p><ul><li>第一种，uboot官方维护的uboot代码，更新最快，包含所有常用芯片。</li><li>第二种，半导体厂商维护的uboot代码，例如NXP的uboot，针对性更强，对自己家芯片的支持性更好</li><li>第三种，产品开发公司维护的uboot代码，使用芯片的公司自己添加了一些支持，boot移植就是讲的这个</li></ul><p><a target="_blank" rel="noopener" href="https://github.com/nxp-imx/uboot-imx">NXP uboot-imx 链接</a></p><blockquote><p><span style="color:red"><strong>！注意！</strong></span></p><ul><li>只能在 uboot 中 ping 其他的机器，其他机器不能 ping uboot，因为 uboot 没有对 ping命令做处理，如果用其他的机器 ping uboot 的话会失败！</li><li>uboot 命令中的数字都是十六进制的！不是十进制的！</li><li>EMMC 核心板 uboot 环境变量的存储起始地址就是第1536(0x600)block。1536*512&#x3D;786432</li><li><code>u-boot.imx</code>是从第0个分区的第2个block开始的。</li><li>千万不要写 SD 卡或者 EMMC 的前两个块(扇区)，里面保存着分区表！</li></ul></blockquote><h2 id="Uboot的编译"><a href="#Uboot的编译" class="headerlink" title="Uboot的编译"></a>Uboot的编译</h2><ol><li><p>安装库 <code>sudo apt-get install libncurses5-dev</code></p></li><li><p>解压对应的uboot代码 <code>tar -vxjf uboot-imx-2016.03-2.1.0-g8b546e4.tar.bz2</code></p></li><li><p>使用脚本编译uboot代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用了 make 命令，用于清理工程，也就是每次在编译 uboot 之前都清理一下工程。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这里的 make 命令带有三个参数，第一个是 ARCH，也就是指定架构，这里肯定是 arm；</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">第二个参数 CROSS_COMPILE 用于指定编译器，只需要指明编译器前缀就行了，比如 arm-linux-gnueabihf-gcc 编译器的前缀就是“arm-linux-gnueabihf-”</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">最后一个参数 distclean 就是清除工程</span><br>make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- distclean<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设定配置文件为 mx6ull_14x14_ddr512_emmc_defconfig</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这个配置文件在 uboot 源码的 configs 目录中</span><br>make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- mx6ull_alientek_emmc_defconfig<br>make V=1 ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j16<br></code></pre></td></tr></table></figure><blockquote><p>　uboot 是 bootloader 的一种，可以用来引导Linux，但是 uboot 除了引导 Linux 以外还可以引导其它的系统，而且 uboot 还支持其它的架构和外设，比如 USB、网络、SD 卡等。这些都是可以配置的，需要什么功能就使能什么功能。所以在编译 uboot 之前，一定要根据自己的需求配置 uboot。而这个配置文件在上面的例子中就是<code>mx6ull_alientek_emmc_defconfig</code></p></blockquote></li></ol><h2 id="Uboot的启动"><a href="#Uboot的启动" class="headerlink" title="Uboot的启动"></a>Uboot的启动</h2><p>通过前面介绍过的烧写程序的方法将uboot烧写到设备，修改启动方式，启动对应设备内的uboot程序。</p><p>接上串口，不出意外就会出现下面的提示。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">指示了uboot版本 和 编译时间</span><br>U-Boot 2016.03-g0ae7e33 (Aug 14 2022 - 19:42:45 +0800)<br><span class="hljs-meta prompt_"># </span><span class="language-bash">指示cpu型号 和 运行频率</span><br>CPU:   Freescale i.MX6ULL rev1.1 792 MHz (running at 396 MHz)<br><span class="hljs-meta prompt_"># </span><span class="language-bash">CPU温度范围 和 当前温度</span><br>CPU:   Industrial temperature grade (-40C to 105C) at 47C<br><span class="hljs-meta prompt_"># </span><span class="language-bash">复位原因 当前的复位原因是 POR。I.MX6ULL 芯片上有个 POR_B 引脚，将这个引脚拉低即可复位。</span><br>Reset cause: POR<br><span class="hljs-meta prompt_"># </span><span class="language-bash">board name</span><br>Board: I.MX6U ALPHA|MINI<br>I2C:   ready<br>DRAM:  512 MiB<br><span class="hljs-meta prompt_"># </span><span class="language-bash">当前有两个 MMC/SD 卡控制器：FSL_SDHC(0)和 FSL_SDHC(1)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">正点原子的 I.MX6ULL EMMC 核心板上 FSL_SDHC(0)接的 SD(TF)卡 FSL_SDHC(1)接的 EMMC。</span><br>MMC:   FSL_SDHC: 0, FSL_SDHC: 1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">标准输入、标准输出和标准错误所使用的终端，这里都使用串口(serial)作为终端。</span><br>In:    serial<br>Out:   serial<br>Err:   serial<br><span class="hljs-meta prompt_"># </span><span class="language-bash">切换到 emmc 的第 0 个分区上，因为当前的 uboot 是 emmc 版本的，也就是从 emmc 启动的。</span><br>switch to partitions #0, OK<br>mmc1(part 0) is current device<br><span class="hljs-meta prompt_"># </span><span class="language-bash">网口信息，提示我们当前使用的 FEC1 这个网口，I.MX6ULL 支持两个网口。</span><br>Net:   FEC1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">提示正常启动，也就是说 uboot 要从 emmc 里面读取环境变量和参数信息启动 Linux内核了。</span><br>Normal Boot<br><span class="hljs-meta prompt_"># </span><span class="language-bash">倒计时结束之前按下任意键就会进入Linux命令行模式。如果在倒计时结束以后没有按下，那么Linux内核就会启动，Linux内核一旦启动，uboot就会寿终正寝。</span><br>Hit any key to stop autoboot: 2<br></code></pre></td></tr></table></figure><p>如果在 3 秒倒计时结束之前按下任意键，那么就会进入 uboot 的命令行模式。</p><h2 id="Uboot的命令及相关操作"><a href="#Uboot的命令及相关操作" class="headerlink" title="Uboot的命令及相关操作"></a>Uboot的命令及相关操作</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">输入 <span class="hljs-built_in">help</span> 或者 ? 即可查看当前uboot支持的命令</span><br>==&gt; help<br><span class="hljs-meta prompt_"># </span><span class="language-bash">输入 ? <span class="hljs-built_in">env</span> 或者 <span class="hljs-built_in">env</span> <span class="hljs-built_in">help</span> 即可查看 <span class="hljs-built_in">env</span> 命令的使用方法</span><br>==&gt; env help<br></code></pre></td></tr></table></figure><h4 id="bdinfo"><a href="#bdinfo" class="headerlink" title="bdinfo"></a>bdinfo</h4><p>DRAM 的起始地址和大小、启动参数保存起始地址、波特率、sp(堆栈指针)起始地址等信息。</p><h4 id="△-env"><a href="#△-env" class="headerlink" title="△ env"></a>△ env</h4><ul><li><code>env print</code> 输出环境变量</li><li><strong><code>env set</code> 设置环境变量，设置为空就是删除环境变量</strong><ul><li>示例 设置serverip <code>env set serverip 192.168.192.100</code></li><li>示例 带空格的环境变量 <code>env set teest_args &#39;xxx xxx xxx&#39;</code></li></ul></li><li><code>env save</code> 用set设定的环境变量只是临时的，使用save命令将环境变量固化到非易失存储器内。</li></ul><table><thead><tr><th>环境变量名</th><th></th></tr></thead><tbody><tr><td>bootdelay</td><td>boot的延迟等待时间</td></tr><tr><td></td><td></td></tr><tr><td>bootcmd</td><td>前面说过 uboot 倒计时结束以后就会启动 Linux 系统，其实就是执行的 bootcmd 中的启动命令。</td></tr><tr><td></td><td></td></tr><tr><td>ipaddr</td><td>开发板 ip 地址，可以不设置，使用 dhcp 命令来从路由器获取 IP 地址。</td></tr><tr><td>ethaddr</td><td>开发板的 MAC 地址，一定要设置。</td></tr><tr><td>gatewayip</td><td>网关地址。</td></tr><tr><td>netmask</td><td>子网掩码。</td></tr><tr><td>serverip</td><td>服务器 IP 地址，也就是 Ubuntu 主机 IP 地址，用于调试代码。</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">setenv ipaddr 192.168.192.120<br>setenv ethaddr b8:ae:1d:01:00:00<br>setenv gatewayip 192.168.192.1<br>setenv netmask 255.255.255.0<br>setenv serverip 192.168.192.100<br>saveenv<br></code></pre></td></tr></table></figure><h4 id="md-DRAM查看"><a href="#md-DRAM查看" class="headerlink" title="md DRAM查看"></a>md DRAM查看</h4><p>md 命令用于显示内存值。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">md[.b, .w, .l] address [# of objects]<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">[.b .w .l]对应 byte、word 和 long</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">address 就是要查看的内存起始地址</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">[# of objects]表示要查看的数据长度 16进制 单位是前面的bwl</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">示例</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">从0x80000000 查看 0x10 个 long 的数据</span><br>md.l 80000000 10<br></code></pre></td></tr></table></figure><h4 id="nm-DRAM修改"><a href="#nm-DRAM修改" class="headerlink" title="nm DRAM修改"></a>nm DRAM修改</h4><p>地址不自增</p><h4 id="mm-DRAM修改"><a href="#mm-DRAM修改" class="headerlink" title="mm DRAM修改"></a>mm DRAM修改</h4><p>mm 命令用于修改指定地址的内存值，地址自增。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">mm[.b, .w, .l] address<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">示例</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改 0x80000000 的数据</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">输入 q 即可退出修改</span><br>=&gt; mm.l 80000010<br>80000010: 00000000 ? _<br><br></code></pre></td></tr></table></figure><h4 id="mw-填充DRAM"><a href="#mw-填充DRAM" class="headerlink" title="mw 填充DRAM"></a>mw 填充DRAM</h4><p>命令 mw 用于使用一个指定的数据填充一段内存</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">mw[.b, .w, .l] address value [count]<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">示例</span><br>=&gt; mw.l 80000010 faaffaaf 4<br></code></pre></td></tr></table></figure><h4 id="cp-copy"><a href="#cp-copy" class="headerlink" title="cp copy"></a>cp copy</h4><p>cp 是数据拷贝命令，用于将 DRAM 中的数据从一段内存拷贝到另一段内存中，或者把 NorFlash 中的数据拷贝到 DRAM 中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp[.b, .w, .l] source target count<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">source</span> 为源地址</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">target 为目的地址</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">count 为拷贝的数量 单位是前面的bwl</span><br></code></pre></td></tr></table></figure><h4 id="dhcp"><a href="#dhcp" class="headerlink" title="dhcp"></a>dhcp</h4><p>dhcp 用于从路由器获取 IP 地址</p><h4 id="△-nfs"><a href="#△-nfs" class="headerlink" title="△ nfs"></a>△ nfs</h4><p>nfs - boot image via network using NFS protocol</p><p>Usage:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">nfs [loadAddress] [[hostIPaddr:]bootfilename]<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">loadAddress 是要保存的 DRAM 地址</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">[[hostIPaddr:]bootfilename]是要下载的文件地址</span><br><br>nfs 80800000 192.168.192.100:/home/frank/linuxMini/nfs_dir/u-boot.imx<br>nfs 80800000 192.168.192.100:/home/frank/linuxMini/nfs_dir/zImage<br>nfs 83000000 192.168.192.100:/home/frank/linuxMini/nfs_dir/imx6ull-14x14-emmc-4.3-480x272-c.dtb<br></code></pre></td></tr></table></figure><h4 id="△-tftp-tftpboot"><a href="#△-tftp-tftpboot" class="headerlink" title="△ tftp &amp; tftpboot"></a>△ tftp &amp; tftpboot</h4><p>tftpboot - boot image via network using TFTP protocol</p><p>Usage:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">tftpboot [loadAddress] [[hostIPaddr:]bootfilename]<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">loadAddress 是要保存的 DRAM 地址</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">[[hostIPaddr:]bootfilename]是要下载的文件地址</span><br></code></pre></td></tr></table></figure><h4 id="△-mmc"><a href="#△-mmc" class="headerlink" title="△ mmc"></a>△ mmc</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs shell">mmc info<br><span class="hljs-meta prompt_"># </span><span class="language-bash">△ 显示当前mmc的信息</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">- display info of the current MMC device</span><br><br>mmc read addr blk# cnt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">addr 是数据读取到 DRAM 中的地址</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">blk 是要读取的块起始地址(十六进制)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">cnt 是块计数</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">示例</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">=&gt; mmc <span class="hljs-built_in">read</span> 80800000 600 10</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">从mmc的第0x600个block开始，读取0x10个block，到DRAM的0x80800000处</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">注意从mmc info可以看到一个block的大小是512Byte</span><br><br>mmc write addr blk# cnt<br>mmc erase blk# cnt<br>mmc rescan<br><br>mmc part<br><span class="hljs-meta prompt_"># </span><span class="language-bash">△ 显示分区</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">- lists available partition on current mmc device</span><br><br>mmc dev [dev] [part]<br><span class="hljs-meta prompt_"># </span><span class="language-bash">△ 显示或者切换当前的设备</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">[dev] 设备号，mmc list可以查看</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">[part] 分区号，mmc part可以查看</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">- show or <span class="hljs-built_in">set</span> current mmc device [partition]</span><br><br>mmc list <br><span class="hljs-meta prompt_"># </span><span class="language-bash">- lists available devices</span><br><br>mmc hwpartition [args...] <br><span class="hljs-meta prompt_"># </span><span class="language-bash">- does hardware partitioning</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"> arguments (sizes <span class="hljs-keyword">in</span> 512-byte blocks):</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">   [user [enh start cnt] [wrrel &#123;on|off&#125;]] - sets user data area attributes</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">   [gp1|gp2|gp3|gp4 cnt [enh] [wrrel &#123;on|off&#125;]] - general purpose partition</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">   [check|<span class="hljs-built_in">set</span>|complete] - mode, complete <span class="hljs-built_in">set</span> partitioning completed</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"> WARNING: Partitioning is a write-once setting once it is <span class="hljs-built_in">set</span> to complete.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"> Power cycling is required to initialize partitions after <span class="hljs-built_in">set</span> to complete.</span><br><br>mmc bootbus dev boot_bus_width reset_boot_bus_width boot_mode<br><span class="hljs-meta prompt_"># </span><span class="language-bash">- Set the BOOT_BUS_WIDTH field of the specified device</span><br><br>mmc bootpart-resize &lt;dev&gt; &lt;boot part size MB&gt; &lt;RPMB part size MB&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">- Change sizes of boot and RPMB partitions of specified device</span><br><br>mmc partconf dev boot_ack boot_partition partition_access<br><span class="hljs-meta prompt_"># </span><span class="language-bash">- Change the bits of the PARTITION_CONFIG field of the specified device</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">说明：设置启动分区</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">dev：mmc设备编号</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">boot_ack：是否应答</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">boot_partition：用户选择发送到主机的引导数据</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">partition_access：用户选择要访问的分区</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">示例</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">=&gt; mmc partconf 1 1 0 0</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将mmc dev 1 设置为启动分区</span><br><br>mmc rst-function dev value<br><span class="hljs-meta prompt_"># </span><span class="language-bash">- Change the RST_n_FUNCTION field of the specified device</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  WARNING: This is a write-once field and 0 / 1 / 2 are the only valid values.</span><br><br>mmc setdsr &lt;value&gt; <br><span class="hljs-meta prompt_"># </span><span class="language-bash">- <span class="hljs-built_in">set</span> DSR register value</span><br></code></pre></td></tr></table></figure><p><strong>在Uboot中更新uboot程序</strong></p><blockquote><p>思路就是先通过网络把文件存在DRAM中（nfs、tftp），再将文件写入到特定位置（mmc write）。</p><p>如果 EMMC 里面烧写了 Linux 系统的话，EMMC 是有 3 个分区的</p><ul><li>第 0 个分区存放 uboot，</li><li>第 1 个分区存放Linux 镜像文件和设备树，</li><li>第 2 个分区存放根文件系统。</li></ul></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">mmc dev 1 0              # 切换到 EMMC 分区 0<br>tftp 80800000 u-boot.imx # 下载 u-boot.imx 到 DRAM<br><span class="hljs-meta prompt_"># </span><span class="language-bash">或 nfs 80800000 192.168.192.100:/home/frank/linuxMini/nfs_dir/u-boot.imx</span><br>mmc write 80800000 2 32E # 烧写 u-boot.imx 到 EMMC 中 (注意这里是block的数量，xxx Byte/512Byte)<br>mmc partconf 1 1 0 0     # 分区配置，EMMC 需要这一步！ SD卡不需要。<br></code></pre></td></tr></table></figure><h4 id="fatinfo"><a href="#fatinfo" class="headerlink" title="fatinfo"></a>fatinfo</h4><p>fatinfo 命令用于查询指定 MMC 设备分区的文件系统信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">fatinfo &lt;interface&gt; [&lt;dev[:part]&gt;]<br><span class="hljs-meta prompt_"># </span><span class="language-bash">interface 表示接口，比如 mmc，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">dev 是查询的设备号，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">part 是要查询的分区。</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查询 EMMC 分区 1 的文件系统信息，命令如下：</span><br>=&gt; fatinfo mmc 1:1<br>Interface:  MMC<br>  Device 1: Vendor: Man 000015 Snr 3ee65248 Rev: 0.6 Prod: 8GTF4R<br>            Type: Removable Hard Disk<br>            Capacity: 7456.0 MB = 7.2 GB (15269888 x 512)<br>Filesystem: FAT32 &quot;NO NAME    &quot;<br></code></pre></td></tr></table></figure><h4 id="fstype-查看文件系统格式"><a href="#fstype-查看文件系统格式" class="headerlink" title="fstype 查看文件系统格式"></a>fstype 查看文件系统格式</h4><p>fstype 用于查看 MMC 设备某个分区的文件系统格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">fstype &lt;interface&gt; &lt;dev&gt;:&lt;part&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">正点原子 EMMC 核心板上的 EMMC 默认有 3 个分区，我们来查看一下这三个分区的文件系统格式</span><br>=&gt; fstype mmc 1:0<br>Failed to mount ext2 filesystem...<br>** Unrecognized filesystem type **<br>=&gt; fstype mmc 1:1<br>fat<br>=&gt; fstype mmc 1:2<br>ext4<br><span class="hljs-meta prompt_"># </span><span class="language-bash">从上可以看出，分区 0 格式未知，因为分区 0 存放的 uboot，并且分区 0 没有格式化，所以文件系统格式未知。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">分区 1 的格式为 fat，分区 1 用于存放 linux 镜像和设备树。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">分区 2 的格式为 ext4，用于存放 Linux 的根文件系统(rootfs)。</span><br></code></pre></td></tr></table></figure><h4 id="fatls-fat列出文件"><a href="#fatls-fat列出文件" class="headerlink" title="fatls fat列出文件"></a>fatls fat列出文件</h4><p>fatls 命令用于查询 FAT 格式设备的目录和文件信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">fatls &lt;interface&gt; [&lt;dev[:part]&gt;] [directory]<br><span class="hljs-meta prompt_"># </span><span class="language-bash">interface 是要查询的接口，比如 mmc，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">dev 是要查询的设备号，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">part 是要查询的分区，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">directory是要查询的目录。</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查询 EMMC 分区 1 中的所有的目录和文件，输入命令：</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">分区1中存放着dts文件，通过这个命令可以查看到</span><br>=&gt; fatls mmc 1:1 /<br>  6785480   zimage<br>    39459   imx6ull-14x14-emmc-4.3-480x272-c.dtb<br>    39459   imx6ull-14x14-emmc-4.3-800x480-c.dtb<br>    39459   imx6ull-14x14-emmc-7-800x480-c.dtb<br>    39459   imx6ull-14x14-emmc-7-1024x600-c.dtb<br>    39459   imx6ull-14x14-emmc-10.1-1280x800-c.dtb<br>    40295   imx6ull-14x14-emmc-hdmi.dtb<br>    40203   imx6ull-14x14-emmc-vga.dtb<br><br>8 file(s), 0 dir(s)<br></code></pre></td></tr></table></figure><h4 id="fatload-设备文件load到DRAM"><a href="#fatload-设备文件load到DRAM" class="headerlink" title="fatload 设备文件load到DRAM"></a>fatload 设备文件load到DRAM</h4><p>fatload 命令用于将指定的文件读取到 DRAM 中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">fatload &lt;interface&gt; [&lt;dev[:part]&gt; [&lt;addr&gt; [&lt;filename&gt; [bytes [pos]]]]]<br><span class="hljs-meta prompt_"># </span><span class="language-bash">interface 为接口，比如 mmc，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">dev 是设备号，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">part 是分区，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">addr 是保存在 DRAM 中的起始地址，filename 是要读取的文件名字。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">bytes 表示读取多少字节的数据，如果 bytes 为 0 或者省略的话表示读取整个文件。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">pos 是要读的文件相对于文件首地址的偏移，如果为 0 或者省略的话表示从文件首地址开始读取。</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">我们将 EMMC 分区 1 中的 zImage 文件读取到 DRAM 中的 0X80800000 地址处，命令如下：</span><br>fatload mmc 1:1 80800000 zImage<br></code></pre></td></tr></table></figure><h4 id="fatwrite-文件写入设备"><a href="#fatwrite-文件写入设备" class="headerlink" title="fatwrite 文件写入设备"></a>fatwrite 文件写入设备</h4><p>fatwirte 命令用于将 DRAM 中的数据写入到 MMC 设备中</p><ul><li>我们可以通过 fatwrite 命令在 uboot 中更新 linux 镜像文件和设备树。</li><li>注意！uboot 默认没有使能 fatwrite 命令，需要修改板子配置头文件。找到自己开发板对应的配置头文件然后添加如下一行宏定义来使能 fatwrite 命令：<br><code>#define CONFIG_FAT_WRITE /* 使能 fatwrite 命令 */</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">fatwrite &lt;interface&gt; &lt;dev[:part]&gt; &lt;addr&gt; &lt;filename&gt; &lt;bytes&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">interface 为接口，比如 mmc，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">dev 是设备号，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">part 是分区，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">addr 是要写入的数据在 DRAM 中的起始地址，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">filename 是写入的数据文件名字，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">bytes 表示要写入多少字节的数据。</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">把位于 0x80800000 的 0x6788f8 字节的 zimage 文件 写入到 mmc 1:1 中</span><br>fatwrite mmc 1:1 80800000 zImage 6788f8<br></code></pre></td></tr></table></figure><h4 id="ext4ls-ext4列出文件"><a href="#ext4ls-ext4列出文件" class="headerlink" title="ext4ls ext4列出文件"></a>ext4ls ext4列出文件</h4><h4 id="ext4load"><a href="#ext4load" class="headerlink" title="ext4load"></a>ext4load</h4><h4 id="ext4write"><a href="#ext4write" class="headerlink" title="ext4write"></a>ext4write</h4><h4 id="reset-重启"><a href="#reset-重启" class="headerlink" title="reset 重启"></a>reset 重启</h4><h4 id="go-执行指定地址的程序"><a href="#go-执行指定地址的程序" class="headerlink" title="go 执行指定地址的程序"></a>go 执行指定地址的程序</h4><h4 id="△-run-运行环境变量中的脚本"><a href="#△-run-运行环境变量中的脚本" class="headerlink" title="△ run 运行环境变量中的脚本"></a>△ run 运行环境变量中的脚本</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">run bootcmd<br><br><br>setenv boot2nfs &#x27;nfs 80800000 192.168.192.100:/home/frank/linuxMini/nfs_dir/zImage; nfs 83000000 192.168.192.100:/home/frank/linuxMini/nfs_dir/imx6ull-14x14-emmc-4.3-480x272-c.dtb; bootz 80800000 - 83000000&#x27;<br>setenv boot2nfs &#x27;nfs 80800000 192.168.192.100:/home/frank/linuxMini/nfs_dir/zImage; nfs 83000000 192.168.192.100:/home/frank/linuxMini/nfs_dir/imx6ull-14x14-emmc-4.3-480x272-c.dtb; bootz 80800000 - 83000000&#x27;<br>run boot2nfs<br></code></pre></td></tr></table></figure><h4 id="mtest-DRAM-test"><a href="#mtest-DRAM-test" class="headerlink" title="mtest DRAM test"></a>mtest DRAM test</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mtest [start [end [pattern [iterations]]]]<br><br>=&gt; mtest 80000000 80001000<br></code></pre></td></tr></table></figure><h2 id="Uboot的BOOT操作"><a href="#Uboot的BOOT操作" class="headerlink" title="Uboot的BOOT操作"></a>Uboot的BOOT操作</h2><p>uboot 的本质工作是引导 Linux，所以 uboot 肯定有相关的 boot(引导)命令来启动 Linux。常用的跟 boot 有关的命令有：bootz、bootm 和 boot。</p><blockquote><p>我们也可以通过设置环境变量，通过run指令来执行环境变量的方式来启动预定义的linux系统</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">run bootcmd<br><br><br>setenv boot2nfs &#x27;nfs 80800000 192.168.192.100:/home/frank/linuxMini/nfs_dir/zImage; nfs 83000000 192.168.192.100:/home/frank/linuxMini/nfs_dir/imx6ull-14x14-emmc-4.3-480x272-c.dtb; bootz 80800000 - 83000000&#x27;<br>run boot2nfs<br><br><br><br>setenv serverip &quot;192.168.3.5’<br>setenv ipaddr &#x27;192.168.3.135&#x27;<br>setenv gatewayip &#x27;192.168.3.1&#x27;<br>setenv netmask &#x27;255.255.255.0&#x27;<br>setenv oikiou_zImage &#x27;/home/frank/linuxMini/nfs_dir/oikiou_zImage&#x27;<br>setenv oikiou_dtbp &#x27;/home/frank/linuxMini/nfs_dir/imx6ull-14x14-emmc-4.3-480x272-c.dtb&#x27;<br>setenv oikiou_rootfs &#x27;/home/frank/linuxMini/nfs_dir/rootfs_oikiou_buildroot&#x27;<br>setenv oikiou_netargs &#x27;setenv bootargs console=ttymxc0,115200 root=/dev/nfs nfsroot=$&#123;serverip&#125;:$&#123;oikiou_rootfs&#125;,proto=tcp rw ip=$&#123;ipaddr&#125;:$&#123;serverip&#125;:$&#123;gatewayip&#125;:$&#123;netmask&#125;::eth0:off&#x27;<br>setenv onetboot &#x27;echo Booting from net ...; run oikiou_netargs; nfs $&#123;loadaddr&#125; $&#123;serverip&#125;:$&#123;oikiou_zImage&#125;; nfs $&#123;fdt_addr&#125; $&#123;serverip&#125;:$&#123;oikiou_dtbp&#125;; bootz $&#123;loadaddr&#125; - $&#123;fdt_addr&#125;;&#x27;<br>run onetboot<br></code></pre></td></tr></table></figure></blockquote><h4 id="bootz"><a href="#bootz" class="headerlink" title="bootz"></a>bootz</h4><p>要启动 Linux，需要先将 Linux 镜像文件拷贝到 DRAM 中，如果使用到设备树的话也需要将设备树拷贝到 DRAM 中。</p><p>可以从 EMMC 或者 NAND 等存储设备中将 Linux 镜像和设备树文件拷贝到 DRAM，也可以通过 nfs 或者 tftp 将 Linux 镜像文件和设备树文件下载到 DRAM 中。<br>不管用那种方法，只要能将 Linux 镜像和设备树文件存到 DRAM 中就行，然后使用 bootz 命令来启动linux</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">bootz [addr [initrd[:size]] [fdt]]<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">addr 是 Linux 镜像文件在 DRAM 中的位置，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">initrd 是 initrd 文件在DRAM 中的地址，如果不使用 initrd 的话使用‘-’代替即可，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">fdt 就是设备树文件在 DRAM 中的地址。</span><br></code></pre></td></tr></table></figure><p>网络方式通过bootz启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">nfs 80800000 192.168.192.100:/home/frank/linuxMini/nfs_dir/zImage<br>nfs 83000000 192.168.192.100:/home/frank/linuxMini/nfs_dir/imx6ull-14x14-emmc-4.3-480x272-c.dtb<br>bootz 80800000 - 83000000<br></code></pre></td></tr></table></figure><h4 id="bootm"><a href="#bootm" class="headerlink" title="bootm"></a>bootm</h4><p>bootm 和 bootz 功能类似，但是 bootm 用于启动 uImage 镜像文件。</p><h4 id="boot"><a href="#boot" class="headerlink" title="boot"></a>boot</h4><p>boot 命令也是用来启动 Linux 系统的，只是 boot 是通过读取环境变量 bootcmd 来启动 Linux 系统。</p><p>原始的<code>bootcmd</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">run findfdt;<br>mmc dev $&#123;mmcdev&#125;;<br>mmc dev $&#123;mmcdev&#125;;<br>if mmc rescan;<br>then if run loadbootscript;<br>then run bootscript;<br>else if run loadimage;<br>then run mmcboot;<br>else run netboot;<br>fi; <br>fi; <br>else run netboot; <br>fi<br><br>&#x27;run findfdt;mmc dev $&#123;mmcdev&#125;;mmc dev $&#123;mmcdev&#125;;if mmc rescan;then if run loadbootscript;then run bootscript;else if run loadimage;then run mmcboot;else run netboot;fi;fi;else run netboot;fi&#x27;<br></code></pre></td></tr></table></figure><h1 id="Linux-Kernel-内核"><a href="#Linux-Kernel-内核" class="headerlink" title="Linux Kernel 内核"></a>Linux Kernel 内核</h1><p>Linux 由 Linux 基金会管理与发布，Linux 官网为 <a target="_blank" rel="noopener" href="https://www.kernel.org/">https://www.kernel.org</a></p><p>Linux内核和Uboot也是类似，有linux原生代码，和NXP维护测试ok的代码。</p><h2 id="Kernel的编译"><a href="#Kernel的编译" class="headerlink" title="Kernel的编译"></a>Kernel的编译</h2><p>编译内核之前需要先在 ubuntu 上安装 <code>lzop</code> 库，否则内核编译会失败！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install lzop<br></code></pre></td></tr></table></figure><h2 id="Kernel文件解析"><a href="#Kernel文件解析" class="headerlink" title="Kernel文件解析"></a>Kernel文件解析</h2><h3 id="arch"><a href="#arch" class="headerlink" title="arch"></a>arch</h3><p><code>arch/arm/configs</code> 中就包含有 I.MX6U-ALPHA 开发板的默认配置文件。</p><p><code>arch/arm/boot/dts</code> 目录里面是对应开发平台的设备树文件(.dtb文件)。</p><p><strong><code>arch/arm/boot</code> 目录下会保存编译出来的 Im age 和 zImage 镜像文件，而 zImage 就是我们要用的 linux 镜像文件。</strong><br><code>arch/arm/mach-xxx</code> 目录分别为相应平台的驱动和初始化文件，比如 mach-imx 目录里面就是 I.MX 系列 CPU 的驱动和初始化文件。</p><h3 id="drivers"><a href="#drivers" class="headerlink" title="drivers"></a>drivers</h3><p>驱动目录文件，此目录根据驱动类型的不同，分门别类进行整理，比如 drivers&#x2F;i2c 就是 I2C相关驱动目录，<code>drivers/gpio</code> 就是 GPIO 相关的驱动目录，这是我们学习的重点。</p><h1 id="Rootfs-根文件系统"><a href="#Rootfs-根文件系统" class="headerlink" title="Rootfs 根文件系统"></a>Rootfs 根文件系统</h1><p>Linux 中的根文件系统更像是一个文件夹或者叫做目录，在这个目录里面会有很多的子目录。根目录下和子目录中会有很多的文<br>件，这些文件是 Linux 运行所必须的，比如库、常用的软件和命令、设备文件、配置文件等等。</p><p>根文件系统是内核启动时所mount的第一个文件系统，内核代码映像文件保存在根文件系统中，而系统引导启动程序会在根文件系统挂载之后从中把一些基本的初始化脚本和服务等加载到内存中去运行。</p><h2 id="rootfs的构建-busybox"><a href="#rootfs的构建-busybox" class="headerlink" title="rootfs的构建 (busybox)"></a>rootfs的构建 (busybox)</h2><p>usyBox 是一个集成了大量的 Linux 命令和工具的软件，像 ls、mv、ifconfig 等命令 BusyBox 都会提供。BusyBox 就是一<br>个大的工具箱，这个工具箱里面集成了 Linux 的许多工具和命令。一般下载 BusyBox 的源码，然后配置 BusyBox，选择自己想要的功能，最后编译即可。</p><p>BusyBox 官网：<a target="_blank" rel="noopener" href="https://busybox.net/">https://busybox.net/</a></p><ol><li><p>我们自己下载对应版本的busybox，这里示例版本是<code>busybox-1.35.0</code>。<br>对于现在2023年7月25日来说<code>busybox-1.36.1</code>这个版本太新了容易有一些问题，暂时不用。</p></li><li><p>下载对应版本的源码后我们先编辑顶层<code>Makefile</code>，编辑<code>CROSS_COMPILE ?= arm-linux-gnueabihf-</code>，指定编译器。</p></li><li><p><code>busybox</code>的官方不支持中文，所以需要修改一些代码来完成对中文的支持。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c">diff -Nura a/libbb/printable_string.c b/libbb/printable_string.c<br>--- a/libbb/printable_string.c <span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-12</span> <span class="hljs-number">06</span>:<span class="hljs-number">27</span>:<span class="hljs-number">20.785120436</span> <span class="hljs-number">-0500</span><br>+++ b/libbb/printable_string.c <span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-12</span> <span class="hljs-number">06</span>:<span class="hljs-number">40</span>:<span class="hljs-number">37.481954486</span> <span class="hljs-number">-0500</span><br>@@ <span class="hljs-number">-28</span>,<span class="hljs-number">8</span> +<span class="hljs-number">28</span>,<span class="hljs-number">10</span> @@<br>&#125;<br><span class="hljs-keyword">if</span> (c &lt; <span class="hljs-string">&#x27; &#x27;</span>)<br>    <span class="hljs-keyword">break</span>;<br>-  <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-number">0x7f</span>)<br>+  <span class="hljs-comment">/*support chinese display*/</span><br>+  <span class="hljs-comment">/*if (c &gt;= 0x7f)</span><br><span class="hljs-comment">    break;</span><br><span class="hljs-comment">+  */</span><br>s++;<br>&#125;<br><br>@@ <span class="hljs-number">-42</span>,<span class="hljs-number">7</span> +<span class="hljs-number">44</span>,<span class="hljs-number">9</span> @@<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c = *d;<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;\0&#x27;</span>)<br>    <span class="hljs-keyword">break</span>;<br>-   <span class="hljs-keyword">if</span> (c &lt; <span class="hljs-string">&#x27; &#x27;</span> || c &gt;= <span class="hljs-number">0x7f</span>)<br>+   <span class="hljs-comment">/*support chinese display*/</span><br>+   <span class="hljs-comment">/*if (c &lt; &#x27; &#x27; || c &gt;= 0x7f)*/</span><br>+   <span class="hljs-keyword">if</span> (c &lt; <span class="hljs-string">&#x27; &#x27;</span> )<br>    *d = <span class="hljs-string">&#x27;?&#x27;</span>;<br>    d++;<br>&#125;<br>diff -Nura a/libbb/unicode.c b/libbb/unicode.c<br>--- a/libbb/unicode.c <span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-12</span> <span class="hljs-number">06</span>:<span class="hljs-number">28</span>:<span class="hljs-number">37.601117822</span> <span class="hljs-number">-0500</span><br>+++ b/libbb/unicode.c <span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-12</span> <span class="hljs-number">06</span>:<span class="hljs-number">44</span>:<span class="hljs-number">05.502420078</span> <span class="hljs-number">-0500</span><br>@@ <span class="hljs-number">-1019</span>,<span class="hljs-number">7</span> +<span class="hljs-number">1019</span>,<span class="hljs-number">9</span> @@<br>    <span class="hljs-keyword">while</span> ((<span class="hljs-type">int</span>)--width &gt;= <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">break</span>;<br>    &#125;<br>-    *d++ = (c &gt;= <span class="hljs-string">&#x27; &#x27;</span> &amp;&amp; c &lt; <span class="hljs-number">0x7f</span>) ? c : <span class="hljs-string">&#x27;?&#x27;</span>;<br>+    <span class="hljs-comment">/*support chinese display*/</span><br>+    <span class="hljs-comment">/**d++ = (c &gt;= &#x27; &#x27; &amp;&amp; c &lt; 0x7f) ? c : &#x27;?&#x27;;*/</span><br>+    *d++ = (c &gt;= <span class="hljs-string">&#x27; &#x27;</span>) ? c : <span class="hljs-string">&#x27;?&#x27;</span>;<br>    src++;<br>    &#125;<br>    *d = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>@@ <span class="hljs-number">-1027</span>,<span class="hljs-number">7</span> +<span class="hljs-number">1029</span>,<span class="hljs-number">9</span> @@<br>    d = dst = xstrndup(src, width);<br>    <span class="hljs-keyword">while</span> (*d) &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c = *d;<br>-    <span class="hljs-keyword">if</span> (c &lt; <span class="hljs-string">&#x27; &#x27;</span> || c &gt;= <span class="hljs-number">0x7f</span>)<br>+    <span class="hljs-comment">/* support chinese display*/</span><br>+    <span class="hljs-comment">/*if (c &lt; &#x27; &#x27; || c &gt;= 0x7f)*/</span><br>+    <span class="hljs-keyword">if</span> (c &lt; <span class="hljs-string">&#x27; &#x27;</span>)<br>    *d = <span class="hljs-string">&#x27;?&#x27;</span>;<br>    d++;<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p><code>busybox</code>的配置。</p><ol><li><p>先对busybox进行默认选项配置，再在这个基础上进行微调。</p></li><li><p>运行<code>make defconfig</code>，进行默认选项配置。<br>busybox有以下几种配置选项。</p><ol><li>defconfig，缺省配置，也就是默认配置选项。</li><li>allyesconfig，全选配置，也就是选中 busybox 的所有功能。</li><li>allnoconfig，最小配置。</li></ol></li><li><p>打开图像界面进行微调，<code>make menuconfig</code>。</p><ol><li><p>选中 这些选项</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">Settings-&gt; [*] vi-style line editing commands<br>Settings-&gt; [*] Support Unicode<br>Settings-&gt; [*] Check $LC_ALL, $LC_CTYPE and $LANG environment variables<br></code></pre></td></tr></table></figure></li></ol></li><li><p>配置结束</p></li></ol></li><li><p><code>busybox</code>的编译安装</p><ol><li><p>配置好 busybox 以后就可以编译了，我们要将编译结果存储到前面创建的 rootfs 目录中，之后将这个目录作为nfs的server文件夹，用于开发板的rootfs挂载。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">make<br>make install CONFIG_PREFIX=/home/frank/linuxMini/nfs_dir/rootfs<br></code></pre></td></tr></table></figure></li><li><p>我们查看rootfs的输出文件夹 <code>/home/frank/linuxMini/nfs_dir/rootfs</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span></span><br>bin  linuxrc  sbin  usr<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">rootfs 目录下有 bin、sbin 和 usr 这三个目录，以及 linuxrc 这个文件。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">前面说过 Linux 内核 init 进程最后会查找用户空间的 init 程序，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">找到以后就会运行这个用户空间的 init 程序，从而切换到用户态。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果 bootargs 设置 init=/linuxrc，那么 linuxrc 就是可以作为用户空间的 init 程序，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">所以用户态空间的 init 程序是 busybox 来生成的</span><br></code></pre></td></tr></table></figure></li></ol></li><li><p><code>busybox</code>完善</p><ol><li><p>可以看出来这个rootfs缺失很多文件，lib，ev、proc、mnt、sys、tmp 和 root 等</p></li><li><p>创建缺失的文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir dev proc mnt sys tmp root lib usr/lib -p<br></code></pre></td></tr></table></figure></li><li><p>先添加lib文件，为了方便直接将所有的库文件都拷贝进去，这块后续可以根据用到的库文件做优化。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">拷贝 /lib</span><br>cd /usr/local/arm/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/arm-linux-<br>gnueabihf/libc/lib<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">“-d”表示拷贝符号链接</span><br>cp *so* *.a /home/frank/linuxMini/nfs_dir/rootfs/lib/ -d<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">ld-linux-armhf.so.3 会链接到 ld-2.19-2014.08-1-git.so 上我们将这个符号链接删掉，<span class="hljs-built_in">cp</span>一份原来的文件代替</span><br>cd /home/frank/linuxMini/nfs_dir/rootfs/lib/<br>rm ld-linux-armhf.so.3<br>cp ld-2.19-2014.08-1-git.so ld-linux-armhf.so.3<br><br>cd /usr/local/arm/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/arm-linux-gnueabihf/lib<br>cp *so* *.a /home/frank/linuxMini/nfs_dir/rootfs/lib/ -d<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">拷贝 /usr/lib</span><br>cd /usr/local/arm/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/arm-linux-gnueabihf/libc/usr/lib<br>cp *so* *.a /home/frank/linuxMini/nfs_dir/rootfs/usr/lib/ -d<br></code></pre></td></tr></table></figure></li><li><p>给rootfs添加<code>/etc/init.d/rcS</code>文件</p><ol><li><p>创建<code>/etc/init.d/rcS</code>文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/sh</span><br><br>PATH=/sbin:/bin:/usr/sbin:/usr/bin:$PATH<br>LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/lib:/usr/lib<br>export PATH LD_LIBRARY_PATH<br>mount -a<br>mkdir /dev/pts<br>mount -t devpts devpts /dev/pts<br><br>echo /sbin/mdev &gt; /proc/sys/kernel/hotplug<br>mdev -s<br></code></pre></td></tr></table></figure><blockquote><p>rcS 是个 shell 脚本，Linux 内核启动以后需要启动一些服务，而 rcS 就是规定启动哪些文件的脚本文件。</p><p>第 1 行，表示这是一个 shell 脚本。<br>第 3 行，PATH 环境变量保存着可执行文件可能存在的目录，这样我们在执行一些命令或 者可执行文件的时候就不会提示找不到文件这样的错误。<br>第 4 行，LD_LIBRARY_PATH 环境变量保存着库文件所在的目录。<br>第 5 行，使用 export 来导出上面这些环境变量，相当于声明一些“全局变量”。<br>第 7 行，使用 mount 命令来挂载所有的文件系统，这些文件系统由文件&#x2F;etc&#x2F;fstab 来指定， 所以我们一会还要创建&#x2F;etc&#x2F;fstab 文件。<br>第 8 和 9 行，创建目录&#x2F;dev&#x2F;pts，然后将 devpts 挂载到&#x2F;dev&#x2F;pts 目录中。<br>第 11 和 12 行，使用 mdev 来管理热插拔设备，通过这两行，Linux 内核就可以在&#x2F;dev 目录下自动创建设备节点。</p></blockquote></li><li><p>将上面文件存储到<code>/etc/init.d/rcS</code>文件中，并给它加上可执行权限。</p></li></ol></li><li><p>给rootfs添加<code>/etc/fstab</code>文件</p><ul><li>fstab 在 Linux 开机以后自动配置哪些需要自动挂载的分区，格式如下：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">&lt;file system&gt; &lt;mount point&gt; &lt;<span class="hljs-built_in">type</span>&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt;</span><br>proc            /proc        proc    defaults   0      0<br>tmpfs           /tmp         tmpfs   defaults   0      0<br>sysfs           /sys         sysfs   defaults   0      0<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;file system&gt; &lt;mount point&gt; &lt;<span class="hljs-built_in">type</span>&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment"># &lt;file system&gt;：要挂载的特殊的设备，也可以是块设备，比如/dev/sda 等等。</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;mount point&gt;：挂载点。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;<span class="hljs-built_in">type</span>&gt;：文件系统类型，比如 ext2、ext3、proc、romfs、tmpfs 等等。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;options&gt;：挂载选项，在 Ubuntu 中输入“man mount”命令可以查看具体的选项。一般使用 defaults，也就是默认选项，defaults 包含了 rw、suid、 dev、 <span class="hljs-built_in">exec</span>、 auto、 nouser 和 async。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;dump&gt;：为 1 的话表示允许备份，为 0 不备份，一般不备份，因此设置为 0。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;pass&gt;：磁盘检查设置，为 0 表示不检查。根目录‘/’设置为 1，其他的都不能设置为 1，其他的分区从 2 开始。一般不在 fstab 中挂载根目录，因此这里一般设置为 0。</span><br></code></pre></td></tr></table></figure></li><li><p>给rootfs添加<code>/etc/inittab</code>文件</p><ul><li>init 程序会读取&#x2F;etc&#x2F;inittab这个文件，inittab 由若干条指令组成。每条指令的结构都是一样的，由以“:”分隔的 4 个段组成</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">etc/inittab</span><br>::sysinit:/etc/init.d/rcS<br>console::askfirst:-/bin/sh<br>::restart:/sbin/init<br>::ctrlaltdel:/sbin/reboot<br>::shutdown:/bin/umount -a -r<br>::shutdown:/sbin/swapoff -a<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;<span class="hljs-built_in">id</span>&gt;:&lt;runlevels&gt;:&lt;action&gt;:&lt;process&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;<span class="hljs-built_in">id</span>&gt;：每个指令的标识符，不能重复。但是对于 busybox 的 init 来说，&lt;<span class="hljs-built_in">id</span>&gt;有着特殊意义。对于 busybox 而言&lt;<span class="hljs-built_in">id</span>&gt;用来指定启动进程的控制 <span class="hljs-built_in">tty</span>，一般我们将串口或者 LCD 屏幕设置为控制 <span class="hljs-built_in">tty</span>。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;runlevels&gt;：对 busybox 来说此项完全没用，所以空着。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;action&gt;：动作，用于指定&lt;process&gt;可能用到的动作。</span><br>    sysinit<br>        在系统初始化的时候 process 才会执行一次。<br>    respawn<br>        当 process 终止以后马上启动一个新的。<br>    askfirst<br>        和 respawn 类似，在运行 process 之前在控制台上显示“Please press Enter to activate this console.”。只要用户按下“Enter”键以后才会执行 process。<br>    wait<br>        告诉 init，要等待相应的进程执行完以后才能继续执行。<br>    once<br>        仅执行一次，而且不会等待 process 执行完成。<br>    restart<br>        当 init 重启的时候才会执行 procee。<br>    ctrlaltdel<br>        当按下 ctrl+alt+del 组合键才会执行 process。<br>    shutdown<br>        关机的时候执行 process。<br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;process&gt;：具体的动作，比如程序、脚本或命令等。</span><br></code></pre></td></tr></table></figure></li></ol></li><li><p><code>busybox</code>搭建完成。</p></li></ol><h2 id="buildroot-配置-rootfs"><a href="#buildroot-配置-rootfs" class="headerlink" title="buildroot 配置 rootfs"></a>buildroot 配置 rootfs</h2><blockquote><p>《第三篇 系统移植篇》我们最后讲解了如何使用 busybox 构建文件系统，busybox 仅仅只是帮我们构建好了一些常用的命令和文件，像 lib 库、&#x2F;etc 目录下的一些文件都需要我们自己手动创建，而且 busybox 构建的根文件系统默认没有用户名和密码设置。在后续的实验中，我们还要自己去移植一些第三方软件和库，比如 alsa、iperf、mplayer 等等。那么有没有一种傻瓜式的方法或软件，它不仅包含了 busybox 的功能，而且里面还集成了各种软件，需要什么软件就选择什么软件，不需要我们去移植。答案肯定是有的，buildroot 就是这样一种工具，buildroot 比 busybox 更上一层楼，buildroot 不仅集成了 busybox，而且还集成了各种常见的第三方库和软件，需要什么就选择什么，就跟我们去吃自助餐一样，想吃什么就拿什么。buildroot 极大的方便了我们嵌入式 Linux 开发人员构建实用的根文件系统。</p></blockquote><ol><li><p>下载buildroot <a target="_blank" rel="noopener" href="https://buildroot.org/">https://buildroot.org/</a></p><ol><li>解压</li></ol></li><li><p><code>make menuconfig</code> 执行配置</p><p>1.</p><pre><code class="hljs"> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">这里主要是配置架构相关的内容</span><br>Target options<br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">Target Architecture = ARM (little endian)</span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">Target Binary Format = ELF</span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">Target Architecture Variant = cortex-A7</span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">Target ABI = EABIhf</span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">Floating point strategy = NEON/VFPv4</span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">ARM instruction <span class="hljs-built_in">set</span> = ARM</span><br></code></pre></td></tr></table></figure>
</code></pre><p>2.</p><pre><code class="hljs"> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Toolchain 这里主要是配置交叉编译链</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这里设置为我们自己所使用的交叉编译器即可。buildroot 其实是可以自动下载交叉编译器的，但是都是从国外服务器下载的，鉴于国内的网络环境，强烈推荐大家设置成自己所使用的交叉编译器。</span><br><br>Toolchain<br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">Toolchain <span class="hljs-built_in">type</span> = External toolchain</span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">Toolchain = Custom toolchain <span class="hljs-comment">#用户自己的交叉编译器</span></span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">Toolchain origin = Pre-installed toolchain <span class="hljs-comment">#预装的编译器</span></span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">Toolchain path =/usr/local/arm/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf  <span class="hljs-comment"># 绝对路径</span></span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">Toolchain prefix = $(ARCH)-linux-gnueabihf <span class="hljs-comment">#置交叉编译器前缀，要根据自己实际所使用的交叉编译器来设置，比如我们使用的是 arm-linux-gnueabihf-gcc，因此前缀就是$(ARCH)-linux-gnueabihf，其中 ARCH我们前面已经设置为了 arm。</span></span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">External toolchain gcc version = 4.9.x</span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">External toolchain kernel headers series = 4.1.x</span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">External toolchain C library = glibc/eglibc</span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">[*] Toolchain has SSP support? (NEW) <span class="hljs-comment">#选中</span></span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">[*] Toolchain has RPC support? (NEW) <span class="hljs-comment">#选中</span></span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">[*] Toolchain has C++ support? <span class="hljs-comment">#选中</span></span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">[*] Enable MMU support (NEW) <span class="hljs-comment">#选中</span></span><br></code></pre></td></tr></table></figure>
</code></pre><p>3.</p><pre><code class="hljs"> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">系统配置</span><br>System configuration<br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">System hostname = alpha_imx6ull <span class="hljs-comment">#平台名字，自行设置</span></span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">System banner = Welcome to alpha i.mx6ull <span class="hljs-comment">#欢迎语</span></span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">Init system = BusyBox <span class="hljs-comment">#使用 busybox</span></span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">/dev management = Dynamic using devtmpfs + mdev <span class="hljs-comment">#使用 mdev</span></span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">[*] Enable root login with password (NEW) <span class="hljs-comment">#使能登录密码</span></span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">Root password = 123456 <span class="hljs-comment">#登录密码为 123456</span></span><br></code></pre></td></tr></table></figure>
</code></pre><p>4.</p><pre><code class="hljs"> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">此选项配置我们最终制作的根文件系统为什么格式的</span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">Filesystem images</span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">[*] ext2/3/4 root filesystem <span class="hljs-comment">#如果是 EMMC 或 SD 卡的话就用 ext3/ext4</span></span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">ext2/3/4 variant = ext4 <span class="hljs-comment">#选择 ext4 格式</span></span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">[*] ubi image containing an ubifs root filesystem <span class="hljs-comment">#如果使用 NAND 的话就用 ubifs</span></span><br></code></pre></td></tr></table></figure>
</code></pre><p>5.</p><pre><code class="hljs"> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">buildroot 不仅仅能构建根文件系统，也可以编译 linux 内核和 uboot。当配置 buildroot，使能 linux 内核和 uboot 以后 buildroot 就会自动下载最新的 linux 内核和 uboot 源码并编译。但是我们一般都不会使用 buildroot 下载的 linux 内核和 uboot，因为 buildroot 下载的 linux 和 uboot官方源码，里面会缺少很多驱动文件，而且最新的 linux 内核和 uboot 会对编译器版本号有要求，可能导致编译失败。因此我们需要配置 buildroot，关闭 linux 内核和 uboot 的编译，只使用 buildroot 来构建根文件系统</span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">Kernel</span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">[ ] Linux Kernel <span class="hljs-comment">#不要选择编译 Linux Kernel 选项！</span></span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">Bootloaders</span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">[ ] U-Boot <span class="hljs-comment">#不要选择编译 U-Boot 选项！</span></span><br></code></pre></td></tr></table></figure>
</code></pre><ol start="6"><li><p>接下来就是 Target packages 用来配置第三方库和软件</p></li><li><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">iperf3<br>netools<br>Target packages-&gt;Networking applications-&gt;openssh<br></code></pre></td></tr></table></figure></li></ol></li><li><p>编译 buildroot</p><ol><li><code>sudo make</code> 注意，一定要加 sudo，而且不能通过-jx 来指定多核编译<ol><li>编译过程可能会下载很多组件，可以考虑给wget添加代理</li></ol></li><li>编译完成后会在<code>output/images</code>生成根文件系统<ol><li>其中 rootfs.tar 就是打包好的根文件系统</li></ol></li></ol></li></ol><h2 id="Yocto-构建-rootfs"><a href="#Yocto-构建-rootfs" class="headerlink" title="Yocto 构建 rootfs"></a>Yocto 构建 rootfs</h2><h2 id="Yocto-和-buildroot-构建-rootfs-的差异"><a href="#Yocto-和-buildroot-构建-rootfs-的差异" class="headerlink" title="Yocto 和 buildroot 构建 rootfs 的差异"></a>Yocto 和 buildroot 构建 rootfs 的差异</h2><p>值得注意的是，Yocto 和 Buildroot 本身并不是 Linux 发行版，它们只是帮助开发人员构建基于 Linux 的嵌入式系统（选择 Yocto，您可以构建 Linux 发行版；选择 Buildroot，您可以开发用于构建发行版的根文件系统）。</p><blockquote><p><strong>为什么应该选择 Yocto</strong></p><p>尽管 Yocto 操作更复杂，但它也有很明显的优势。或许其中最大的优势就是 Yocto 拥有广泛的用户群体和支持，开发社区非常活跃，为其创建了各种新的工具、层级和特性。此外，它由 Linux 基金会出资扶持，因而也更得人心。</p><p>Yocto 的另一大好处则是它可以实现层级，用于各种任务，从功能添加，到项目版本中不可用平台的定位等，都可以实现。此外，还可以添加特殊功能，例如自定义浏览器，以便实现 Yocto 本身进一步的功能定制化。</p><p>Yocto 获得了多家半导体和电路板生产商的支持，在同类项目中，可以兼容的设备最多。也就是说，除了充满活力的 Yocto 生态系统之外，自定义 Yocto 构建还可以添加大量的 SDK、工具和功能。</p><p>正是有了这些要素，Yocto 实现了高度可定制，同时还拥有强劲的支持，可供计划构建嵌入式系统的开发人员使用。</p><p><strong>Yocto 的缺点</strong></p><p>即便如此，Yocto 也有一些缺点。一方面，入门时的学习曲线稍微有点陡峭。对于时间有限的小型单个项目或小型团队来说，使用这个工具可能根本没有意义。另一方面，众所周知，Yocto 的构建时间很长。这就降低了迭代频率，如用在时间紧迫的项目中，效果可能会不太理想。</p><p><strong>为什么应该选择 Buildroot</strong></p><p>Buildroot 的构建很简单——从运行方式到输出，都非常简便快捷。它的核心构建系统采用 Make 语言编写而成，语言十分简短，开发人员不需要学习，就能轻松理解。正如上文所述，Buildroot 使用标准的 Makefiles 和 kconfig 进行配置。Makefiles 和 kconfig 是 Linux 内核社区制作的两个工具，它们获得了广泛应用和支持。</p><p>Buildroot 要求的“企业”参与度较低，因此它也是开源社区的“宠儿”。这样就会实现更高的可定制性以及更多的能力，从而尽可能开发具有针对性的系统，满足开发团队的需求。</p><p>最后，Buildroot 还有一项极其有用的功能——它禁用了可选的构建时间设置，选择以即开即用的方式，创建尽可能小的镜像。这样大幅缩短了构建时间，减少了所需的必要计算资源（不过无法实现更灵活的构建）。对于小型团队或资源有限的团队而言，这可能是一种理想的解决方案。</p><p><strong>Buildroot 的缺点</strong></p><p>首先必须要讨论的就是它最明显的缺点——缺乏公司支持。尽管对于许多开发人员来说，这可能是一个好处，但其实它也有一些明显的不足。即，社区较小，且生态系统不太活跃。也就是说，它没有那么多的支持。由于许多开发人员更愿意专注研究应用更广泛的工具，因此，如果您遇到问题，您可能必须自己处理或学习如何解决。</p><p>Buildroot 的另一个主要缺点是它不支持增量构建。每当您需要进行更新，即使是很小的更新，您都必须从头开始重新制作镜像。这样必定会使开发周期延长，增加不必要的时间。</p><p>此外，Buildroot 最大的亮点就是其注重简约，但这也意味着，相比 Yocto，Buildroot 定制和特殊系统搭建会困难得多。<br><strong>Buildroot 和 yocto的对比</strong></p><p><strong>对比内容：</strong><br>（1） 嵌入式构建系统<br>目标是构建一个完整的，客制化的嵌入式Linux系统<br>包括root filesystem， toolchain， kernel， bootloader<br>（2） 从源代码开始<br>（3） 使用交叉编译工具链<br>（4） 非常活跃的维护和开发工程<br>（5） 工业界广泛使用<br>（6） 有文档和培训课程<br>（7） 自由软件</p><p><strong>buildroot的通用信条</strong><br>（1） 专注于简单化<br>（2） 使用简单，理解简单，扩展简单<br>（3） 通过扩展脚本而不是buildroot本身来处理特殊情况<br>（4） 使用现存的技术&#x2F;语言：kconfig， make. (值得投入时间去学习)<br>（5） 默认小<br>（6） 目的无关的（Purpose-agnostic）<br>（7） 开放社区，没有供应商、官僚&#x2F;公司的管理</p><p><strong>yocto的通用信条</strong><br>（1） 支持主要的CPU架构<br>OpenEmbedded：仅qemu<br>Yocto Project：为一小部分机器增加支持<br>（2） 只提供核心方法，使用layers来支持更多的package和机器<br>（3） 客户的改动应该在一个单独的layer<br>（4） 多用途的构建系统：尽可能灵活的处理更多的使用情况<br>（5） 开放社区，但是该工程被公司赞助商发起的Yocto Project Advisory Board监管<br>（6） OpenEmbedded 是一个独立社区驱动的工程。</p><p><strong>buildroot 输出</strong><br>（1） 主要是根文件系统镜像<br>同时包含：工具链， 内核镜像， bootloader等<br>（2） 支持多种格式：ext2&#x2F;3&#x2F;4， ubifs， iso9600等<br>（3） 没有二进制包， 没有包管理系统<br>一些人称之为一个firmware generator<br>通过包不可能更新<br>更新需要一个完整的系统更新，像Andorid一样<br>认为部分更新是有害的</p><p><strong>Yocto 输出</strong><br>（1） 构建distribution，主要的输出是一个package feed<br>包管理系统是可选的<br>装载和更新系统的一部分是可能的<br>（2） 通过安装一些包，也可以产生根文件系统镜像。支持ext2&#x2F;3&#x2F;4， ubifs， iso9600等，也支持VM镜像：vmdk，vdi，qcow2<br>（3） 最终，镜像类或者工具，wic可用来构建磁盘镜像<br>（4） 生成image时也可以生成SDK，可以让应用开发者编译和测试他们的应用（不用集成到build中）。但是SDK必须要和image匹配。</p><p><strong>Buildroot 配置</strong><br>（1） 和Linux kernel一样使用kconfig<br>（2） 简单的{menu，x，n，g}配置接口<br>（3） 整个配置保存在一个文件 .config&#x2F;defconfig<br>（4） 定义系统的各个方面：架构，内核版本&#x2F;内核配置，bootloader，用户空间package等等。<br>（5） make menuconfig， make<br>（6） 为不同的机器构建通用的系统：单独处理<br>一个可以从fragment中构建出defconfig的工具<br>可行的，但是并非超级简单<br>每台机器完全独立的构建</p><p><strong>Yocto 配置</strong><br>（1） 配置分成几个部分：<br>Distribution 配置 （package配置，toolchain和libc选择…）<br>Machine Configuration （定义架构， CPU功能， BSP）<br>Image recipe （target安装什么package）<br>Local配置 （Distribution和默认machine选择， 编译时使用多少个线程， 是否删除build artifact）<br>（2） 有必要收集将要被使用的layers，并宣布它们。<br>（3） 允许为不同的机器构建相同的镜像，或者为同一个机器构建不同的distribution或镜像。</p><p><strong>Buildroot layers</strong><br>（1） 没有layer的概念<br>（2） 所有的包在官方repository中维护<br>（3） 添加BR2_EXTERNAL<br>允许存储包定义、配置和其他人工文件<br>一个BR2_EXTERNAL<br>通常用作专有的&#x2F;客制化的包和配置<br>仅增加包，不覆盖buildroot中的包</p><p><strong>yocto layers</strong><br>（1） layer机制允许修改和增加新package或image<br>（2） core build system， BSP和custome modifications之间明确分离<br>（3） 第三方提供为它们layers提供BSP，或者一套处理专用应用程序的方法<br>（4） Layers需要兼容和使用相同的OE branch base<br>（5） 谨防layer quality， 检查不是系统性的<br>（6） OpenEmbedded Metadata Index 列出了可用的layers，recipes，machines：<a href="https://link.zhihu.com/?target=http://layers.openembedded.org/layerindex/">http://layers.openembedded.org/layerindex/</a><br>（7） 此外，有一个强大的override机制，可以基于machine或者distribution调整recipe variables</p><p><strong>buildroot&#x2F;yocto toolchain</strong><br>相同的功能：<br>（1） 构建自己的toolchain，基于gcc、C库（glibc， uClibc， musl）<br>（2） 使用external toolchain， 对于buildroot更简单，因为内置有这个功能，对于yocto，只有在additional vendor layers正真完全支持。</p><p><strong>buildroot new package</strong><br>涉及三个文件 Config.in xxx.mk xxx.hash</p><p><strong>yocto new package</strong><br>涉及一个文件×××.bb</p><p><strong>buildroot: complexity</strong><br>（1） 设计成简单使用<br>（2） 对于core，每个建议的功能以有用性&#x2F;复杂度比来分析<br>（3） core逻辑完全使用make编写，少于1000行的code包含了230行注释：确实容易理解what、why、how；几乎和一个shell脚本一个接一个地下载、提取、构建、安装软件那样简单。<br>（4） 文档很充分，有很多资源可用<br>（5） 一个小时的talk足以描述所有内部实现（ELCE 2014）<br>（6） IRC上典型的反馈：来自Yocto，非常惊喜，使用起来这么简单。这是让我为难的第一件事。</p><p><strong>Yocto Project: complexity</strong><br>（1） 有点陡峭的学习曲线<br>（2） 核心是bitbake， 一个用python编写的单独项目（60千行代码）<br>（3） 一套class定义common task<br>（4） recipe 使用 bitbake specific language， python 和 shell 混合编写<br>（5） 日志和调试可帮助理解每个task具体做了什么<br>（6） 详细的文档，但是有很多不同的配置变量<br>（7） 并不总是容易理解最佳实践（比如， Poky 不能用于 production， distro&#x2F;image 修改不能在local.conf中做， 删除tmp&#x2F;）<br>（8） 人们依然对一些术语感到疑惑（Yocto Project， Poky， OpenEmbedded， bitbake）</p><p><strong>Buildroot packages</strong><br>（1） 1800+ packages<br>（2） Graphics: X.org, Wayland, Qt4&#x2F;Qt5, Gtk2&#x2F;Gtk3, EFL<br>（3） Multimedia: Gstreamer 0.10&#x2F;1.x, ffmpeg, Kodi, OpenGL<br>（4） Languages: Python2&#x2F;3, PHP, Lua, Perl, Erlang, Mono, Ruby, Node.js<br>（5） Networking: Apache, Samba, Dovecot, Exim, CUPS, lots of servers&#x2F;tools<br>（6） Init systems: Busybox(default), initsysv, systemd<br>（7） No support for a toolchain on the target</p><p><strong>Yocto Project packages</strong><br>（1） 几千个recipes: 对于oe-core， meta-openembedded， meta-qt5大约2200个。通过Metadata Index知道多余8400<br>（2） 大部分和buildroot一样<br>（3） 更多的语言: Java, Go, Rust, smalltalk<br>（4） 对于Qt3仍有一个起作用的layer<br>（5） meta-virtualization（Docker， KVM， LXC， Xen）和 meta-openstack layers</p><p><strong>Buildroot 依赖方法</strong><br>（1） 极简依赖， 如果一个功能可以关闭，那么默认关闭<br>（2） 很多自动依赖，比如，如果你开启OpenSSL，将自动从其他可提供SSL支持的enabled的包中获得SSL支持<br>（3） 默认毫不费力的的得到小的根文件系统</p><p><strong>Yocto Project 依赖方法</strong><br>（1） 在distribution级进行package 配置<br>开启OpenSSL将对所有package打开，但是可以对一些package关闭，相反，也可以对选定的pacakge开启一些功能。<br>（2） 可以在machine级进行修改，但是应该避免这样做<br>（3） 每个recipe可以定义自己的默认功能集，一个稳健的默认配置。</p><p><strong>Buildroot 更新&#x2F;安全</strong><br>（1） 每三个月release，两个月开发，一个月稳定<br>（2） release包含package版本更新：security 更新和major 更新<br>（3） 核心架构也可能潜在性的发生改变<br>（4） 没有LTS版本，用于需要自己处理<br>（5） 正在提供一个脚本来评估给定buildroot配置中未解决的CVE （Common Vulnerabilities &amp; Exposures）</p><p><strong>Yocto Project 更新&#x2F;安全</strong><br>（1） 每6个月release，一次在4月，一次在10月<br>（2） 可通过wiki: <a href="https://link.zhihu.com/?target=https://wiki.yoctoproject.org/wiki/Yocto_Project_v2.1_Status">https://wiki.yoctoproject.org/wiki/Yocto_Project_v2.1_Status</a>了解planning和roadmap<br>（3） 在M1和最终release之间的三个月内包含4个milestone<br>（4） 至少先前和当前release的版本有指定维护者，他们获取安全和重要的解决方法，但是没有recipe更新<br>（5） 旧版本由社区维护</p><p><strong>Buildroot 检测配置修改</strong><br>（1） Buildroot不很智能<br>（2） 当修改配置是，它不尝试检测哪些需要rebuild<br>（3） 一旦build一个package，buildroot将不rebuild它，除非你强制<br>（4） 大的配置修改需要full rebuild<br>（5） 小的配置修改可以不需要full rebuild<br>（6） 一个配置，一个build，不能配置间不能分享</p><p><strong>Yocto Project 检测配置修改</strong><br>（1） bitbake 维护一个shared State Cache允许增加的builds<br>（2） 它通过创建inputs的checksum检测task的input修改<br>（3） 该cache可在所有的builds间共享， 对于类似的machines，build很快<br>（4） 可以跨主机分享该cache，比如一个夜间服务器和一个开发机，大大加快full build</p><p><strong>Buildroot: architecture support</strong><br>（1） 支持很多架构<br>（2） ARM（64）， MIPS， PowerPC（64）， x86&#x2F;x86-64<br>（3） 也支持很多更专用的架构：Xtensa, Blackfin, ARC, m68k, SPARC, Microblaze, NIOSII; ARM noMMU, especially ARMv7-M<br>（4） 架构供应商提供援助: Imagination Technologies的MIPS, IBM的PowerPC64， Synopsys的ARC， Analog Devices的Blackfin</p><p><strong>Yocto Project: architecture support</strong><br>（1） core中， ARM， MIPS， PowerPC， X86，以及它们64bit 系列<br>（2） separate layers：Microblaze， NIOSII<br>（3） 通常芯片厂商维护他们自己的BSP layer：meta-intell， meta-altera （ARM &amp; NIOSII）， meta-atmel， meta-fsl， meta-ti， mtea-xilinx …<br>（4） 社区提供：meta-rockchip， meta-sunxi</p><p><strong>Buildroot: minimal build</strong><br>最小的build花费15分25秒，image size 2.2MB</p><p><strong>yocto project: minimal build</strong><br>最小build花费50分47秒， image size为4.9MB。如果有存在的sstate-cache，花费1分21秒</p><p><strong>License</strong><br>（1） 都可以创建一个使用许可证的列表<br>（2） 都能够检测到许可证更改<br>（3） Yocto项目可以剔除GPLv3</p><p><strong>Buildroot &amp; Yocto 选择</strong><br><strong>Buildroot</strong><br>（1） 非常专用的CPU架构<br>（2） 非常小的rootfs &lt; 8M<br>（3） 对工程师没有很大的要求<br>（4） 不支持各种mechines或者类似的系统<br>（5） 不需要包&#x2F;部分系统的更新<br>（6） 小系统</p><p><strong>yocto</strong><br>（1） 不是非常特殊的CPU架构，不是非常小的rootfs，需要有经验的工程师。<br>（2） 不是非常特殊的CPU架构，不是非常小的rootfs，需要有经验的工程师。支持几种类似的系统<br>（3） 不是非常特殊的CPU架构，不是非常小的rootfs，需要有经验的工程师。需要更新包和部分系统<br>（4） 不是非常特殊的CPU架构，不是非常小的rootfs，需要有经验的工程师。非常大的系统</p></blockquote><h2 id="Ubuntu-Base-rootfs构建"><a href="#Ubuntu-Base-rootfs构建" class="headerlink" title="Ubuntu-Base rootfs构建"></a>Ubuntu-Base rootfs构建</h2><blockquote><p>Ubuntu是 Linux 系统的一种，可以简单的将 Ubuntu 理解为一个根文件系统，和我们用 busybox、buildroot制作的根文件系统一样。</p><p>根文件系统下载地址 <a target="_blank" rel="noopener" href="http://cdimage.ubuntu.com/">http://cdimage.ubuntu.com/</a> (ubuntu-base)</p><p>Ubuntu 针对不同的 CPU 架构提供相应的 ubuntu base 根文件系统，有 amd64(64 位 X86)、armhf、i386(32 位 X86)、powerpc、ppc64el 等系统的。I.MX6ULL 是 Cortex-A7 内核的 CPU，并且有硬件浮点运算单元，因此选择 <strong>armhf</strong> 版本。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">解压</span><br>tar -vxf ubuntu-base-16.04.6-base-armhf.tar.gz -C rootfs_ubuntu_1604<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装qemu虚拟机</span><br>sudo apt-get install qemu-user-static<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将 qemu-user-static 拷贝到ubuntu base目录下</span><br>cd rootfs_ubuntu_1604<br>sudo cp /usr/bin/qemu-arm-static ./usr/bin/<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">配置开发板用的rootfs</span><br>cd rootfs_ubuntu_1604<br><span class="hljs-meta prompt_"># </span><span class="language-bash">从主机复制 DNS配置文件</span><br>sudo cp /etc/resolv.conf ./etc/resolv.conf<br><span class="hljs-meta prompt_"># </span><span class="language-bash">换源 修改开发板 rootfs 的源</span><br>./etc/apt/sources.list<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在主机(虚拟机(当前执行指令的设备))中挂载根文件系统(刚刚下载的，给开发板用的根文件系统)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">相当于把主机的根文件系统改成了开发板用的根文件系统</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">把下面的脚本保存下来并添加运行权限</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">挂载脚本 例如保存为 mount.sh</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>sudo mount -t proc /proc /home/frank/linuxMini/nfs_dir/rootfs_ubuntu_1604/proc<br>sudo mount -t sysfs /sys /home/frank/linuxMini/nfs_dir/rootfs_ubuntu_1604/sys<br>sudo mount -o bind /dev /home/frank/linuxMini/nfs_dir/rootfs_ubuntu_1604/dev<br>sudo mount -o bind /dev/pts /home/frank/linuxMini/nfs_dir/rootfs_ubuntu_1604/dev/pts<br>sudo chroot /home/frank/linuxMini/nfs_dir/rootfs_ubuntu_1604<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">卸载脚本 unmount.sh</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>sudo umount /home/frank/linuxMini/nfs_dir/rootfs_ubuntu_1604/proc<br>sudo umount /home/frank/linuxMini/nfs_dir/rootfs_ubuntu_1604/sys<br>sudo umount /home/frank/linuxMini/nfs_dir/rootfs_ubuntu_1604/dev/pts<br>sudo umount /home/frank/linuxMini/nfs_dir/rootfs_ubuntu_1604/dev<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">挂载</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">执行脚本之后发现shell变了</span><br>./mount.sh<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装软件</span><br>apt update<br>apt install sudo<br>apt install vim<br>apt install net-tools<br>apt install ethtool<br>apt install net-tools<br>apt install openssh-server openssh-client<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置root密码</span><br>passwd root<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置 hostname</span><br>echo &quot;ubuntu1604&quot; &gt; /etc/hostname<br>echo &quot;127.0.0.1 localhost&quot; &gt;&gt; /etc/hosts<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">配置串口终端</span><br>ln -s /lib/systemd/system/getty@.service /etc/systemd/system/getty.target.wants/getty@ttymxc0.service<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">配置ssh</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">注意一下这些配置项</span><br>PermitRootLogin yes<br>PubkeyAuthentication yes<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">退出</span><br>exit<br>./unmount.sh<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">至此 ubuntu 配置完成 在uboot内更改启动参数就可以对这个根文件系统进行测试了</span><br><br></code></pre></td></tr></table></figure><h2 id="使用NFS挂载rootfs"><a href="#使用NFS挂载rootfs" class="headerlink" title="使用NFS挂载rootfs"></a>使用NFS挂载rootfs</h2><p>uboot 里面的 bootargs 环境变量会设置“root”的值，所以我们将 root 的值改为 NFS 挂载即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">root=/dev/nfs nfsroot=[&lt;server-ip&gt;:]&lt;root-dir&gt;[,&lt;nfs-options&gt;] ip=&lt;client-ip&gt;:&lt;server-ip&gt;:&lt;gw-ip&gt;:&lt;netmask&gt;:&lt;hostname&gt;:&lt;device&gt;:&lt;autoconf&gt;:&lt;dns0-ip&gt;:&lt;dns1-ip&gt;<br><br>&lt;server-ip&gt;：服务器 IP 地址，也就是存放根文件系统主机的 IP 地址，那就是 Ubuntu 的 IP地址，比如我的 Ubuntu 主机 IP 地址为 192.168.1.250。<br>&lt;root-dir&gt;：根文件系统的存放路径，比如我的就是/home/zuozhongkai/linux/nfs/rootfs。<br>&lt;nfs-options&gt;：NFS 的其他可选选项，一般不设置。<br>&lt;client-ip&gt;：客户端 IP 地址，也就是我们开发板的 IP 地址，Linux 内核启动以后就会使用此 IP 地址来配置开发板。此地址一定要和 Ubuntu 主机在同一个网段内，并且没有被其他的设备使用，在 Ubuntu 中使用 ping 命令 ping 一下就知道要设置的 IP 地址有没有被使用，如果不能ping 通就说明没有被使用，那么就可以设置为开发板的 IP 地址，比如我就可以设置为192.168.1.251。<br>&lt;server-ip&gt;：服务器 IP 地址，前面已经说了。<br>&lt;gw-ip&gt;：网关地址，我的就是 192.168.1.1。<br>&lt;netmask&gt;：子网掩码，我的就是 255.255.255.0。<br>&lt;hostname&gt;：客户机的名字，一般不设置，此值可以空着。<br>&lt;device&gt;：设备名，也就是网卡名，一般是 eth0，eth1….，正点原子的 I.MX6U-ALPHA 开发板的 ENET2 为 eth0，ENET1 为 eth1。如果你的电脑只有一个网卡，那么基本只能是 eth0。这里我们使用 ENET2，所以网卡名就是 eth0。<br>&lt;autoconf&gt;：自动配置，一般不使用，所以设置为 off。<br>&lt;dns0-ip&gt;：DNS0 服务器 IP 地址，不使用。<br>&lt;dns1-ip&gt;：DNS1 服务器 IP 地址，不使用。<br></code></pre></td></tr></table></figure><p>根据上面的格式 bootargs 环境变量的值如下：</p><p>“proto&#x3D;tcp”表示使用 TCP 协议，“rw”表示 nfs 挂载的根文件系统为可读可写。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">设定 bootargs 环境变量</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">linux kernel是通过读取这个环境变量来启动rootfs的</span><br>=&gt; env set bootargs &#x27;console=ttymxc0,115200 root=/dev/nfs nfsroot=192.168.192.100:/home/frank/linuxMini/nfs_dir/rootfs,proto=tcp rw ip=192.168.192.80:192.168.192.100:192.168.192.100:255.255.255.0::eth0:off&#x27;<br><br><br>=&gt; env print boot2nfs<br>boot2nfs=nfs 80800000 192.168.192.100:/home/frank/linuxMini/nfs_dir/zImage; nfs 83000000 192.168.192.100:/home/frank/linuxMini/nfs_dir/imx6ull-14x14-emmc-4.3-480x272-c.dtb; bootz 80800000 - 83000000<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">运行boot2nfs</span><br>=&gt; run boot2nfs<br></code></pre></td></tr></table></figure><h1 id="Drive-驱动"><a href="#Drive-驱动" class="headerlink" title="Drive 驱动"></a>Drive 驱动</h1><blockquote><p>Linux 中的驱动分为三大类：<strong>字符设备驱动、块设备驱动、网络设备驱动</strong>。</p><p><strong>一个设备有可能属于多种设备类型</strong>，比如 USB WIFI，其使用 USB 接口，所以属于字符设备，但是其又能上网，所以也属于网络设备驱动。</p><h3 id="字符设备驱动"><a href="#字符设备驱动" class="headerlink" title="字符设备驱动"></a>字符设备驱动</h3><p>是占用篇幅最大的一类驱动，因为字符设备最多，从最简单的点灯到 I2C、SPI、音频等都属于字符设备驱动的类型。</p><h3 id="块设备驱动"><a href="#块设备驱动" class="headerlink" title="块设备驱动"></a>块设备驱动</h3><p>所谓的块设备驱动就是存储器设备的驱动，比如 EMMC、NAND、SD 卡和 U 盘等存储设备，因为这些存储设备的特点是以<strong>存储块为基础</strong>，因此叫做块设备</p><h3 id="网络设备驱动"><a href="#网络设备驱动" class="headerlink" title="网络设备驱动"></a>网络设备驱动</h3><p>网络设备驱动，不管是有线的还是无线的，都属于网络设备驱动的范畴</p></blockquote><h2 id="字符设备驱动-1"><a href="#字符设备驱动-1" class="headerlink" title="字符设备驱动"></a>字符设备驱动</h2><h3 id="驱动调用流程"><a href="#驱动调用流程" class="headerlink" title="驱动调用流程"></a>驱动调用流程</h3><p><img src="/2021/9b4105ad/image-20231107151921777.png" srcset="/img/loading.gif" lazyload alt="字符设备的函数调用"></p><p>在 Linux 中一切皆为文件，<strong>驱动加载成功以后</strong>会在“&#x2F;dev”目录下生成一个相应的文件，应用程序通过对这个名为“&#x2F;dev&#x2F;xxx”(xxx 是具体的驱动文件名字)的文件进行相应的操作即可实现对硬件的操作。</p><p>应用程序运行在用户空间，而 Linux 驱动属于内核的一部分，驱动运行于内核空间。</p><p>当我们在用户空间想要实现对内核的操作，比如使用 open 函数打开&#x2F;dev&#x2F;led 这个驱动，因为<strong>用户空间不能直接对内核进行操作</strong>，因此必须使用一个叫做“<strong>系统调用</strong>”的方法来实现从用户空间“陷入”到内核空间，这样才能实现对底层驱动的操作。</p><p>open 函数调用流程:</p><p><img src="/2021/9b4105ad/image-20231107162628528.png" srcset="/img/loading.gif" lazyload alt="open 函数调用流程"></p><h3 id="驱动API函数"><a href="#驱动API函数" class="headerlink" title="驱动API函数"></a>驱动API函数</h3><p>每一个系统调用，在驱动中都有与之对应的一个驱动函数，在 Linux 内核文件 <code>include/linux/fs.h</code> 中有个叫做 <strong><code>file_operations</code></strong> 的结构体，此结构体就是 Linux 内核驱动操作函数集合，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> &#123;</span><br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span> *<span class="hljs-title">owner</span>;</span><br> <span class="hljs-type">loff_t</span> (*llseek) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span>, <span class="hljs-type">int</span>);<br> <span class="hljs-type">ssize_t</span> (*read) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">char</span> __user *, <span class="hljs-type">size_t</span>, <span class="hljs-type">loff_t</span> *);<br> <span class="hljs-type">ssize_t</span> (*write) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *, <span class="hljs-type">size_t</span>, <span class="hljs-type">loff_t</span> *);<br> <span class="hljs-type">ssize_t</span> (*read_iter) (<span class="hljs-keyword">struct</span> kiocb *, <span class="hljs-keyword">struct</span> iov_iter *);<br> <span class="hljs-type">ssize_t</span> (*write_iter) (<span class="hljs-keyword">struct</span> kiocb *, <span class="hljs-keyword">struct</span> iov_iter *);<br> <span class="hljs-type">int</span> (*iterate) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> dir_context *);<br> <span class="hljs-type">unsigned</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(*poll)</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> poll_table_struct *)</span>;<br> <span class="hljs-type">long</span> (*unlocked_ioctl) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>);<br> <span class="hljs-type">long</span> (*compat_ioctl) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>);<br> <span class="hljs-type">int</span> (*mmap) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> vm_area_struct *);<br> <span class="hljs-type">int</span> (*mremap)(<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> vm_area_struct *);<br> <span class="hljs-type">int</span> (*open) (<span class="hljs-keyword">struct</span> inode *, <span class="hljs-keyword">struct</span> file *);<br> <span class="hljs-type">int</span> (*flush) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">fl_owner_t</span> id);<br> <span class="hljs-type">int</span> (*release) (<span class="hljs-keyword">struct</span> inode *, <span class="hljs-keyword">struct</span> file *);<br> <span class="hljs-type">int</span> (*fsync) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span>, <span class="hljs-type">loff_t</span>, <span class="hljs-type">int</span> datasync);<br> <span class="hljs-type">int</span> (*aio_fsync) (<span class="hljs-keyword">struct</span> kiocb *, <span class="hljs-type">int</span> datasync);<br> <span class="hljs-type">int</span> (*fasync) (<span class="hljs-type">int</span>, <span class="hljs-keyword">struct</span> file *, <span class="hljs-type">int</span>);<br> <span class="hljs-type">int</span> (*lock) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">int</span>, <span class="hljs-keyword">struct</span> file_lock *);<br> <span class="hljs-type">ssize_t</span> (*sendpage) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> page *, <span class="hljs-type">int</span>, <span class="hljs-type">size_t</span>, <span class="hljs-type">loff_t</span> *, <span class="hljs-type">int</span>);<br> <span class="hljs-type">unsigned</span> <span class="hljs-title function_">long</span> <span class="hljs-params">(*get_unmapped_area)</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)</span>;<br> <span class="hljs-type">int</span> (*check_flags)(<span class="hljs-type">int</span>);<br> <span class="hljs-type">int</span> (*flock) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">int</span>, <span class="hljs-keyword">struct</span> file_lock *);<br> <span class="hljs-type">ssize_t</span> (*splice_write)(<span class="hljs-keyword">struct</span> pipe_inode_info *, <span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span> *, <span class="hljs-type">size_t</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>);<br> <span class="hljs-type">ssize_t</span> (*splice_read)(<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span> *, <span class="hljs-keyword">struct</span> pipe_inode_info *, <span class="hljs-type">size_t</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>);<br> <span class="hljs-type">int</span> (*setlease)(<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">long</span>, <span class="hljs-keyword">struct</span> file_lock **, <span class="hljs-type">void</span> **);<br> <span class="hljs-type">long</span> (*fallocate)(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-type">int</span> mode, <span class="hljs-type">loff_t</span> offset, <span class="hljs-type">loff_t</span> len);<br> <span class="hljs-type">void</span> (*show_fdinfo)(<span class="hljs-keyword">struct</span> seq_file *m, <span class="hljs-keyword">struct</span> file *f);<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_MMU</span><br> <span class="hljs-type">unsigned</span> (*mmap_capabilities)(<span class="hljs-keyword">struct</span> file *);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>简单介绍一下 file_operation 结构体中比较重要的、常用的函数：<br><strong>owner 拥有该结构体的模块的指针，一般设置为 THIS_MODULE。</strong><br><strong>llseek 函数</strong>用于修改文件当前的读写位置。<br><strong>read 函数用于读取设备文件。</strong><br><strong>write 函数用于向设备文件写入(发送)数据。</strong><br><strong>poll 函数</strong>是个轮询函数，用于查询设备是否可以进行非阻塞的读写。<br><strong>unlocked_ioctl 函数</strong>提供对于设备的控制功能，与应用程序中的 ioctl 函数对应。<br><strong>compat_ioctl 函数</strong>与 unlocked_ioctl 函数功能一样，区别在于在 64 位系统上，32 位的应用程序调用将会使用此函数。在 32 位的系统上运行 32 位的应用程序调用的是unlocked_ioctl。<br><strong>mmap 函数</strong>用于将设备的内存映射到进程空间中(也就是用户空间)，一般帧缓冲设备会使用此函数，比如 LCD 驱动的显存，将帧缓冲(LCD 显存)映射到用户空间中以后应用程序就可以直接操作显存了，这样就不用在用户空间和内核空间之间来回复制。<br><strong>open 函数用于打开设备文件。</strong><br><strong>release 函数</strong>用于释放(关闭)设备文件，与应用程序中的 close 函数对应。<br><strong>fasync 函数</strong>用于刷新待处理的数据，用于将缓冲区中的数据刷新到磁盘中。<br><strong>aio_fsync 函数</strong>与 fasync 函数的功能类似，只是 aio_fsync 是异步刷新待处理的数据。</p><p>这些函数并不是全部都需要实现的，可以只实现需要的部分函数。</p></blockquote><h3 id="驱动的加载卸载"><a href="#驱动的加载卸载" class="headerlink" title="驱动的加载卸载"></a>驱动的加载卸载</h3><p><strong>驱动的加载和卸载</strong></p><p>Linux 驱动有两种运行方式</p><ul><li><p>第一种是将驱动编译进 Linux 内核中</p><ul><li>当 Linux 内核启动的时候就会自动运行驱动程序</li></ul></li><li><p>第二种就是将驱动编译成模块(Linux 下模块扩展名为.ko)</p><ul><li><p>在Linux 内核启动以后使“insmod”命令加载驱动模块。</p></li><li><blockquote><p>在调试驱动的时候一般都选择将其编译为模块，这样我们修改驱动以后只需要编译一下驱动代码即可，不需要编译整个 Linux 代码。</p><p>而且在调试的时候只需要加载或者卸载驱动模块即可，不需要重启整个系统。</p></blockquote></li></ul></li></ul><p>将驱动编译为模块最大的好处就是方便开发，当驱动开发完成，确定没有问题以后就可以将驱动编译进 Linux 内核中，当然也可以不编译进 Linux 内核中，具体看自己的需求。</p><p>模块有加载和卸载两种操作，我们在编写驱动的时候需要注册这两种操作函数，模块的加载和卸载注册函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">module_init(xxx_init);   <span class="hljs-comment">//注册模块加载函数</span><br>module_exit(xxx_exit);   <span class="hljs-comment">//注册模块卸载函数</span><br></code></pre></td></tr></table></figure><p>module_init() 函数用来向 Linux 内核注册一个模块<strong>加载函数</strong>，参数 xxx_init 就是需要注册的具体函数，当使用<code>insmod</code>命令加载驱动的时候，xxx_init 这个函数就会被调用。</p><p>module_exit()函数用来向 Linux 内核注册一个模块<strong>卸载函数</strong>，参数 xxx_exit 就是需要注册的具体函数，当使用<code>rmmod</code>命令卸载具体驱动的时候 xxx_exit 函数就会被调用。</p><p>驱动加载函数和卸载函数的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 驱动入口函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">xxx_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br> <span class="hljs-comment">/* 入口函数具体内容 */</span><br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/* 驱动出口函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">xxx_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br> <span class="hljs-comment">/* 出口函数具体内容 */</span><br>&#125;<br><span class="hljs-comment">/* 将上面两个函数指定为驱动的入口和出口函数 */</span><br>module_init(xxx_init);<br>module_exit(xxx_exit);<br></code></pre></td></tr></table></figure><p>驱动编译完成后，编译出来的文件名为<code>.ko</code>我们可以通过命令去将这个文件加载、卸载。</p><p><strong>驱动加载命令</strong></p><p>驱动的加载有两个命令：</p><ul><li><p>insmod</p><ul><li><pre><code class="shell">     insmod drv.ko
 <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><br>  - insmod 命令不能解决模块的依赖关系，比如 drv<span class="hljs-selector-class">.ko</span> 依赖 first<span class="hljs-selector-class">.ko</span> 这个模块，就必须先使用insmod 命令加载 first<span class="hljs-selector-class">.ko</span> 这个模块，然后再加载 drv<span class="hljs-selector-class">.ko</span> 这个模块。<br><br>- modprobe<br><br>  - ```shell<br>        modprobe drv.ko<br></code></pre></td></tr></table></figure>
</code></pre></li><li><p>modprobe 会分析模块的依赖关系，然后会将所有的依赖模块都加载到内核中。</p></li><li><p>modprobe 命令主要智能在提供了模块的依赖性分析、错误检查、错误报告等功能</p></li></ul></li></ul><p><strong>驱动的卸载</strong></p><p>对应的驱动的卸载有两个命令：</p><ul><li><p>rmmod</p><ul><li><pre><code class="shell">    rmmod drv.ko
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">  -</span> 对应的 rmmod 也是卸载单一的驱动。<br><br><span class="hljs-bullet">-</span> modprobe -r<br><br><span class="hljs-bullet">  -</span> <span class="hljs-code">```shell</span><br><span class="hljs-code">        modprobe -r drv.ko</span><br></code></pre></td></tr></table></figure>
</code></pre></li><li><p>使用 modprobe 命令可以卸载掉驱动模块所依赖的其他模块。</p></li><li><p>需要注意的是这些被依赖的模块需要确保已经没有被其他模块所使用，否则就不能使用 modprobe 来卸载驱动模块。</p></li></ul></li></ul><h3 id="驱动-字符设备-的注册和注销"><a href="#驱动-字符设备-的注册和注销" class="headerlink" title="驱动(字符设备)的注册和注销"></a>驱动(字符设备)的注册和注销</h3><p>对于字符设备驱动而言，当驱动模块加载成功以后需要注册字符设备，同样，卸载驱动模块的时候也需要注销掉字符设备。</p><p>驱动注册函数和注销函数的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 原型</span><br><span class="hljs-comment">// major：主设备号，Linux 下每个设备都有一个设备号，设备号分为主设备号和次设备号两部分，这里是主设备号</span><br><span class="hljs-comment">// name：设备名字，指向一串字符串</span><br><span class="hljs-comment">// fops：结构体 file_operations 类型指针，指向设备的操作函数集合变量</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">register_chrdev</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> major, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> file_operations *fops)</span>;<br><br><span class="hljs-comment">// major：要注销的设备对应的主设备号</span><br><span class="hljs-comment">// name：要注销的设备对应的设备名</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">unregister_chrdev</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> major, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span>;<br><br><span class="hljs-comment">// 定义 file_operations 结构的变量。这个就是操作函数集合。定义在linux内核的include/linux/fs.h中</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">test_fops</span>;</span><br><span class="hljs-comment">/* 驱动入口函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">xxx_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/* 入口函数具体内容 */</span><br>    <span class="hljs-type">int</span> retvalue = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">/* 注册字符设备驱动 */</span><br>    <span class="hljs-comment">// 注册设备号为 200 名为 &quot;chrtest&quot;</span><br>    retvalue = register_chrdev(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;chrtest&quot;</span>, &amp;test_fops);<br> <span class="hljs-keyword">if</span>(retvalue &lt; <span class="hljs-number">0</span>) &#123;<br>  <span class="hljs-comment">/* 字符设备注册失败,自行处理 */</span><br> &#125;<br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 驱动出口函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">xxx_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/* 注销字符设备驱动 */</span><br>    unregister_chrdev(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;chrtest&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">/* 将上面两个函数指定为驱动的入口和出口函数 */</span><br>module_init(xxx_init);<br>module_exit(xxx_exit);<br></code></pre></td></tr></table></figure><p><strong>设备号的动态分配</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 申请设备号</span><br><span class="hljs-comment">// dev：保存申请到的设备号</span><br><span class="hljs-comment">// baseminor：次设备号起始地址，alloc_chrdev_region 可以申请一段连续的多个设备号，这些设备号的主设备号一样，但是次设备号不同，次设备号以 baseminor 为起始地址地址开始递增。一般 baseminor 为 0，也就是说次设备号从 0 开始。</span><br><span class="hljs-comment">// count：要申请的设备号数量（次设备号的差别）</span><br><span class="hljs-comment">// name：设备名字。</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">alloc_chrdev_region</span><span class="hljs-params">(<span class="hljs-type">dev_t</span> *dev, <span class="hljs-type">unsigned</span> baseminor, <span class="hljs-type">unsigned</span> count, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span><br><br><span class="hljs-comment">// 释放掉设备</span><br><span class="hljs-comment">// from：要释放的设备号</span><br><span class="hljs-comment">// count：表示从 from 开始，要释放的设备号数量</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">unregister_chrdev_region</span><span class="hljs-params">(<span class="hljs-type">dev_t</span> from, <span class="hljs-type">unsigned</span> count)</span><br></code></pre></td></tr></table></figure><h3 id="驱动文件的整体实现"><a href="#驱动文件的整体实现" class="headerlink" title="驱动文件的整体实现"></a>驱动文件的整体实现</h3><p>参考代码仓库</p><h3 id="驱动测试"><a href="#驱动测试" class="headerlink" title="驱动测试"></a>驱动测试</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">输入如下命令加载 chrdev_demo.ko 驱动文件：</span><br>insmod chrdev_demo.ko<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果使用 modprobe 加载驱动</span> <br>modprobe chrdev_demo.ko<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看当前系统中存在的模块</span><br>lsmod<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看系统中的设备 可以看到 chrdev_demo.ko 的主设备号和设备名</span><br>cat /proc/devices<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建设备节点文件</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">驱动加载成功需要在/dev 目录下创建一个与之对应的设备节点文件，应用程序就是通过操作这个设备节点文件来完成对具体设备的操作。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">其中 <span class="hljs-built_in">mknod</span> 是创建节点命令，/dev/chrdev_demo 是要创建的节点文件，c 表示这是个字符设备，237 是设备的主设备号，0 是设备的次设备号</span><br>mknod /dev/chrdev_demo c 237 0<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">卸载驱动模块</span><br>rmmod chrdev_demo.ko<br></code></pre></td></tr></table></figure><h3 id="Q-A"><a href="#Q-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><p><strong>什么是设备号？</strong></p><blockquote><p>设备号是Linux系统用来管理设备的一种方式，它由**主设备号(Major Device Number)<strong>和</strong>次设备号(Minor Device Number)**组成。</p><p>主设备号用来区分不同种类的设备，如<strong>字符设备</strong>、<strong>块设备</strong>、<strong>网络设备</strong>等，它用来表示一个特定的驱动程序。</p><p>次设备号用来区分同一类型的多个设备，如不同的硬盘、串口、网卡等，它用来表示使用该驱动程序的特定设备。</p><blockquote><p>以磁盘为例：在同一个系统中，磁盘设备的主设备号是唯一的。比如：scsi设备。次设备号只是在提供给scsi驱动程序内部使用，系统内核直接把次设备号传递给应用程序，scsi设备由驱动程序管理，我们可能有多个scsi设备，每个scsi设备都会分配一个次设备号。</p><blockquote><p>注：</p><p>主设备对应一个特定的驱动程序，所以一个系统里面所有的scsi硬盘使用的都是scsi驱动，所以他们的主设备号是一致的。</p><p>而不同的硬盘通过次设备号来做区分，保证它们的唯一性。</p><p>主设备号用来区分不同种类的设备，而次设备号用来区分同一类型的多个设备。</p></blockquote></blockquote><p>设备号可以用一个<strong>32位</strong>的无符号整数表示，其中<strong>高12位</strong>是主设备号，<strong>低20位</strong>是次设备号。</p><p>设备号可以通过<code>/dev</code>目录下的设备文件来访问，也可以通过<code>/proc/devices</code>文件来查看当前配置的设备号。<code>/proc/devices</code>类似一个类别，而<code>/dev/</code>下是某个类别下的项，由他们两个最终确定了一对多关系。</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看主设备号</span><br>cat /proc/devices<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看次设备号</span><br>ll /dev/<br><span class="hljs-meta prompt_"># </span><span class="language-bash">c 代表 char 设备  89 主设备 0 次设备</span><br>crw------- 1 root root   89,   0 Nov  7 08:23 i2c-0<br><span class="hljs-meta prompt_"># </span><span class="language-bash">b 代表 block 设备  179 主设备 1 次设备</span><br>brw-rw---- 1 root disk  179,   1 Nov  7 08:23 mmcblk1p1<br></code></pre></td></tr></table></figure></blockquote><p>设备号的分配和使用有一定的规则和约定，以保证设备的唯一性和通用性。</p><ul><li>静态设备号：有一些常用的设备号已经被 Linux 内核开发者给分配掉了，具体分配的内容可以查看文档 Documentation&#x2F;devices.txt。</li><li>动态设备号：Linux 社区推荐使用动态分配设备号，在注册字符设备之前先申请一个设备号，系统会自动给你一个没有被使用的设备号，这样就避免了冲突。</li></ul><p><strong>常见设备名称：</strong></p><blockquote><p>fb::frame缓冲<br>fd:—–:软驱<br>hd:—–:IDE 硬盘&#x2F;光驱<br>md:—–:RAID设备(Metadisk)<br>dm:—–:LVM设备(DeviceMapper)<br>xd:—–:虚拟机中的硬盘驱动器<br>tty:—–:终端设备<br>psaux:—–:PS&#x2F;2 鼠标设备<br>lp:—–:打印机<br>par:—–:并口<br>pt:—–:伪终端</p><p>s:—–:SCSI设备<br>scd:—–:SCSI音频光驱<br>sd:—–:SCSI硬盘<br>sg:—–:SCSI通用设备<br>sr:—–:SCSI数据光驱<br>st:—–:SCSI磁带<br>cdrom:—–:光驱的符号链接<br>mouse:—–:鼠标设备的符号链接<br>gpmdata:—–:伪设备<br>null:—–:写入消失<br>zero:—–:一直产生零</p></blockquote><p><strong>参考：</strong></p><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/aozhejin/p/15874504.html">linux设备管理之主设备号与次设备号 - jinzi - 博客园 (cnblogs.com)</a></p></blockquote><h1 id="外设"><a href="#外设" class="headerlink" title="外设"></a>外设</h1><h2 id="LCD"><a href="#LCD" class="headerlink" title="LCD"></a>LCD</h2><p><strong>VSYNC 垂直同步脉冲（Vertical synchronization, Vsync</strong>）是加在两帧之间。跟水平同步脉冲类似，但它指示着前一帧的结束，和新一帧的开始。 垂直同步脉冲是一个持续时间比较长的脉冲。</p><p><strong>HSYNC 水平同步脉冲（Horizontal synchronization pulse, Hsync）</strong>加在两个扫描行之间。它是一个短小的脉冲，在一行扫描完成之后，它就会出现，指示着这一行扫描完成，同时它也指示着下一行将要开始。</p><h3 id="LCD屏幕的数据总线接口类型"><a href="#LCD屏幕的数据总线接口类型" class="headerlink" title="LCD屏幕的数据总线接口类型"></a>LCD屏幕的数据总线接口类型</h3><p><strong>MCU-LCD和RGB-LCD的主要差别</strong></p><blockquote><ol><li>RGB-LCD的显存(GRAM)由系统RAM充当。而MCU-LCD的显存由驱动IC决定。</li><li>显存的不一致直接导致了他们更新速率上的差异，MCU-LCD需要发送画点指令来修改驱动IC的显存，而RGB-LCD直接操作系统RAM，由DMA搬运到驱动IC。</li></ol></blockquote><h4 id="串口屏-UART-接口"><a href="#串口屏-UART-接口" class="headerlink" title="串口屏 UART 接口"></a>串口屏 UART 接口</h4><h4 id="SPI-接口"><a href="#SPI-接口" class="headerlink" title="SPI 接口"></a>SPI 接口</h4><h4 id="MCU-MPU接口"><a href="#MCU-MPU接口" class="headerlink" title="MCU MPU接口"></a>MCU MPU接口</h4><p>LCD液晶屏的MCU接口主要针对单片机的领域。</p><p>MCU接口的标准是因特尔提出的8080总线标准，因此在很多文档中用<strong>I80</strong>来指MCU接口屏。</p><p>MCU接口模式分为<strong>I(intel) 8080模式</strong>和<strong>M(Motorola) 6800</strong>模式，主要是时序的区别。数据位传输有8位，16位，18位，24位。</p><p>连线分为：CS&#x2F;RS&#x2F;RD&#x2F;WR&#x2F;。</p><p>优点是控制简单方便，无需时钟和同步信号。</p><p>缺点是要<strong>耗费GRAM</strong>，所以难以做到大屏，一般都用在4寸以下。</p><blockquote><p>i80</p><ul><li>CS 片选信号</li><li>RS (D&#x2F;I 数据&#x2F;指令选择线, 置1为写数据, 置0为写命令)</li><li>&#x2F;WR (为0表示写数据)</li><li>&#x2F;RD (为0表示读数据)</li><li>RESET 复位LCD(用固定命令系列 0 1 0来复位)</li></ul><p>m6800</p><ul><li>CS 片选信号</li><li>RS (D&#x2F;I 数据&#x2F;指令选择线, 置1为写数据, 置0为写命令)</li><li>&#x2F;WR (读写信号)</li><li>E (锁存信号)</li><li>RESET 复位LCD(用固定命令系列来复位)</li></ul><p>m6800其实际设计思想是与 I80 的思想是一样的，主要区别就是该模式的总线控制读写信号组合在一个引脚上（&#x2F;WR），而增加了一个锁存信号(E)</p></blockquote><p><img src="/2021/9b4105ad/c8e0872247ff49de99539712b5b6237f.png" srcset="/img/loading.gif" lazyload alt="img"></p><h4 id="RGB接口"><a href="#RGB接口" class="headerlink" title="RGB接口"></a>RGB接口</h4><p>LCD液晶屏的RGB接口通过对红(R)、绿(G)、蓝(B)三个颜色通道的变化以及三者组合来得到丰富多彩的颜色。</p><p><strong>RGB-LCD的显存“GRAM”是由系统内存充当的，因此其大小只受限于系统内存的大小</strong>，这样RGB-LCD可以做出较大尺寸</p><p>所以LCD液晶屏的RGB接口就是分三原色输入的视频接口 。</p><p>通常一个颜色通道由8bit表示, 即每个颜色通道值得范围是0~255, 通常称<strong>RGB888&#x2F;RGB24</strong>。三个颜色通道总共能组合出约1678(256×256×256)万种色彩, 简称为1600万色或千万色, 也称为24位色。</p><p>在实际的使用中, 除了<strong>RGB888&#x2F;RGB24</strong>, 还有**RGB555、RGB565、RGB32、RGB666、RGB16、RGB24、RGB32、ARGB32(A就是alpha，透明度通道)**等等。</p><p><img src="/2021/9b4105ad/f5acc963e742489185cd4cf5d1bc774f.png" srcset="/img/loading.gif" lazyload alt="img"></p><h4 id="LVDS接口"><a href="#LVDS接口" class="headerlink" title="LVDS接口"></a>LVDS接口</h4><p>LCD液晶屏的LVDS接口即Low Voltage Differential Signaling，是一种低压差分信号技术接口。</p><p>克服以TTL电平方式传输宽带高码率数据时功耗大、EMI电磁干扰大等缺点而研制的一种数字视频信号传输方式。</p><p>LVDS输出接口利用非常低的电压摆幅（约350mV）在两条PCB走线或一对平衡电缆上通过差分进行数据的传输，即低压差分信号传输。</p><p>采用LVDS输出接口，可以使得信号在差分PCB线或平衡电缆上以几百Mbit／s的速率传输，由于采用低压和低电流驱动方式，因此，实现了低噪声和低功耗。</p><h4 id="MIPI接口"><a href="#MIPI接口" class="headerlink" title="MIPI接口"></a>MIPI接口</h4><p>LCD液晶屏的MIPI接口是Mobile Industry Processor Interface的缩写。</p><p>MIPI（移动行业处理器接口）是MIPI联盟发起的为移动应用处理器制定的开放标准。</p><p>MIPI是一个比较新的标准，其规范也在不断修改和改进，目前比较成熟的接口应用有DSI(显示接口)和CSI（摄像头接口）。CSI&#x2F;DSI分别是指其承载的是针对Camera或Display应用，都有复杂的协议结构。</p><h3 id="RGB-驱动原理"><a href="#RGB-驱动原理" class="headerlink" title="RGB 驱动原理"></a>RGB 驱动原理</h3><p>主要信号线：</p><table><thead><tr><th>信号线</th><th>描述</th></tr></thead><tbody><tr><td>R[7:0]</td><td>8 根红色数据线</td></tr><tr><td>G[7:0]</td><td></td></tr><tr><td>B[7:0]</td><td></td></tr><tr><td>DE</td><td>数据使能线 Data Enable</td></tr><tr><td>VSYNC</td><td>垂直同步信号线 Vertical synchronization, Vsync</td></tr><tr><td>HSYNC</td><td>水平同步信号线 Horizontal synchronization pulse, Hsync</td></tr><tr><td>PCLK</td><td>像素时钟信号线</td></tr><tr><td></td><td></td></tr><tr><td>RESET</td><td></td></tr></tbody></table><p>同步信号示意图：</p><p><img src="/2021/9b4105ad/image-20230821122002797.png" srcset="/img/loading.gif" lazyload alt="image-20230821122002797"></p><p>Timing 示意图(摘录于GC9503V)：</p><blockquote><p>在很多情况下PCLK时钟是不停歇 持续产生的。</p><p>The Pixel clock (PCLK) is running all the time without stopping, it is used for entering VS, HS, DE and DB [23:0] states when there is a rising edge of the PCLK.The PCLK can not be used as the internal clock for other functions of the display module.</p></blockquote><p><img src="/2021/9b4105ad/image-20230818180021537.png" srcset="/img/loading.gif" lazyload alt="image-20230818180021537"><img src="/2021/9b4105ad/image-20230818180129919.png" srcset="/img/loading.gif" lazyload alt="image-20230818180129919"></p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td><strong>HSYNC</strong></td><td><strong>Horizontal synchronization pulse, Hsync</strong></td><td><strong>水平同步信号线</strong></td></tr><tr><td>HLW&#x2F;HSPW&#x2F;THP</td><td>Horizontal Low Pulse width</td><td>HSYNC 信号宽度，也就是 HSYNC 信号持续时间。</td></tr><tr><td>HBP&#x2F;THB</td><td>Horizontal Back Porch</td><td>行同步信号后肩</td></tr><tr><td>HACT&#x2F;HOZVAL&#x2F;THD</td><td>Horizontal</td><td>显示一行数据所需的时间</td></tr><tr><td>HFP&#x2F;THF</td><td>Horizontal Front Porch</td><td>行同步信号前肩</td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><strong>VSYNC</strong></td><td><strong>Vertical synchronization, Vsync</strong></td><td><strong>垂直同步信号线</strong></td></tr><tr><td>VLW&#x2F;VSPW&#x2F;TVP</td><td>Vertical Low Pulse width</td><td></td></tr><tr><td>VBP&#x2F;TVB</td><td>Vertical Back Porch</td><td>帧同步信号后肩</td></tr><tr><td>VACT&#x2F;LINE</td><td>Vertical</td><td>显示一帧有效数据所需的时间</td></tr><tr><td>VFP&#x2F;TVF</td><td>Vertical Front Porch</td><td>帧同步信号前肩</td></tr><tr><td></td><td></td><td></td></tr><tr><td>DCLK</td><td>Data Clock</td><td>像素时钟</td></tr></tbody></table><p><strong>显示一行所需要的时间就是：</strong></p><p><code>HLW + HBP + HACT + HFP</code></p><p><strong>显示一帧所需要的时间就是：</strong></p><p><code>(HLW + HBP+ HACT + HFP)*(VLW + VBP + VACT + VFP)</code></p><p><strong>DCLK时钟的计算：</strong></p><p>根据上面的公式计算出一帧数据的时钟数假定未Vclock，帧数为Vfps。</p><p><code>DCLK = Vclock * Vfps</code></p><p>例如一帧需要<code>853440</code>个CLOCK，帧数设定为<code>60</code>，那么PCLK时钟就要设置成为<code>853440*60=51206400=51.2064M</code></p><p><strong>最小显存的计算：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">853*480 分辨率   RGB888 模式</span><br>853*480*3 = 1,228,320 Byte = 1.1714 MByte<br><span class="hljs-meta prompt_"># </span><span class="language-bash">1024*600 分辨率  ARGB8888 模式</span><br>1024*600*4 = 2457600Byte = 2.4 MByte<br></code></pre></td></tr></table></figure></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/linux/" class="category-chain-item">linux</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/linux/" class="print-no-link">#linux</a> <a href="/tags/alpha-mini/" class="print-no-link">#alpha_mini</a> <a href="/tags/%E6%AD%A3%E7%82%B9%E5%8E%9F%E5%AD%90/" class="print-no-link">#正点原子</a></div></div><div class="license-box my-3"><div class="license-title"><div>LinuxAlphaMini</div><div>https://www.oikiou.top/2021/9b4105ad/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Oikiou</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2021年7月7日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-cc-by"></i> </span></a><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="NC - 非商业性使用"><i class="iconfont icon-cc-nc"></i> </span></a><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="SA - 相同方式共享"><i class="iconfont icon-cc-sa"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2021/42e53028/" title="RT-Thread"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">RT-Thread</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2021/da01e608/" title="Cortex-A7 基础"><span class="hidden-mobile">Cortex-A7 基础</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="twikoo"></div><script type="text/javascript">Fluid.utils.loadComments("#comments",function(){Fluid.utils.createScript("https://lib.baomitu.com/twikoo/1.6.10/twikoo.all.min.js",function(){var o=Object.assign({envId:"https://twikoo.oikiou.top/",region:"ap-shanghai",path:"window.location.pathname"},{el:"#twikoo",path:"window.location.pathname",onCommentLoaded:function(){Fluid.utils.listenDOMLoaded(function(){var o="#twikoo .tk-content img:not(.tk-owo-emotion)";Fluid.plugins.imageCaption(o),Fluid.plugins.fancyBox(o)})}});twikoo.init(o)})})</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar category-bar" style="margin-left:-1rem"><div class="category-list"><div class="category row nomargin-x"><a class="category-item list-group-item category-item-action col-10 col-md-11 col-xm-11" title="linux" id="heading-e206a54e97690cce50cc872dd70ee896" role="tab" data-toggle="collapse" href="#collapse-e206a54e97690cce50cc872dd70ee896" aria-expanded="true">linux <span class="list-group-count">(7)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse show" id="collapse-e206a54e97690cce50cc872dd70ee896" role="tabpanel" aria-labelledby="heading-e206a54e97690cce50cc872dd70ee896"><div class="category-post-list"><a href="/2020/d4436089/" title="Linux 杂乱学习笔记" class="list-group-item list-group-item-action"><span class="category-post">Linux 杂乱学习笔记</span> </a><a href="/2021/9b4105ad/" title="LinuxAlphaMini" class="list-group-item list-group-item-action active"><span class="category-post">LinuxAlphaMini</span> </a><a href="/2021/784ee20b/" title="WSL" class="list-group-item list-group-item-action"><span class="category-post">WSL</span> </a><a href="/2023/52593829/" title="Linux 应用编程 Curl Libcurl" class="list-group-item list-group-item-action"><span class="category-post">Linux 应用编程 Curl Libcurl</span> </a><a href="/2023/bb8e62be/" title="Linux 应用编程 Zlib Minizip" class="list-group-item list-group-item-action"><span class="category-post">Linux 应用编程 Zlib Minizip</span> </a><a href="/2023/47a3870e/" title="Linux 应用编程" class="list-group-item list-group-item-action"><span class="category-post">Linux 应用编程</span> </a><a href="/2023/6dfa9920/" title="OrangePi" class="list-group-item list-group-item-action"><span class="category-post">OrangePi</span></a></div></div></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><span>如果你有任何反馈请联系oikiou@outlook.com</span></div><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">总访问量 <span id="busuanzi_value_site_pv"></span> 次 </span><span id="busuanzi_container_site_uv" style="display:none">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script>var relativeDate=function(){var t,e,i,n,m=document.getElementById("updated-time");m&&(e=/\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:Z|[+-]\d{2}:\d{2})/,(i=(t=m.textContent).match(e))&&(n=moment(i[0]).fromNow(),m.textContent=t.replace(e,n)),m.style.display="")};Fluid.utils.createScript("https://lib.baomitu.com/moment.js/2.29.4/moment.min.js",function(){"zh-cn".startsWith("en")?relativeDate():Fluid.utils.createScript("https://lib.baomitu.com/moment.js/2.29.4/locale/zh-cn.min.js",function(){relativeDate()})})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/custom.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>
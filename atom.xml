<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Oikiou&#39;s Blog</title>
  <icon>https://www.oikiou.top/img/favicon.ico</icon>
  <subtitle>花有重开日，人无再少年</subtitle>
  <link href="https://www.oikiou.top/atom.xml" rel="self"/>
  
  <link href="https://www.oikiou.top/"/>
  <updated>2022-09-10T05:20:07.359Z</updated>
  <id>https://www.oikiou.top/</id>
  
  <author>
    <name>Oikiou</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CC2530</title>
    <link href="https://www.oikiou.top/2022/8d6db935/"/>
    <id>https://www.oikiou.top/2022/8d6db935/</id>
    <published>2022-08-21T14:57:15.000Z</published>
    <updated>2022-09-10T05:20:07.359Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>CC2530是针对IEEE 802.15.4，Zigbee和RF4CE应用的真正片上系统（SoC）解决方案。 它能够以非常低的总物料成本构建强大的网络节点。 CC2530将领先的射频收发器的卓越性能与业界标准增强型8051 MCU，系统内可编程闪存，8 KB RAM以及许多其他强大功能相结合。 CC2530有四种不同的闪存版本：分别为CC2530F32 &#x2F; 64&#x2F;128&#x2F;256对应32&#x2F;64&#x2F;128&#x2F;256 KB的闪存。 CC2530具有多种工作模式，非常适合需要超低功耗的系统。 运行模式之间的短暂转换时间进一步确保了低能耗。</p><p>•CC2530是TI公司推出的用来实现嵌入式ZigBee应用的低功耗片上系统。</p><p>•在单个芯片上整合了ZigBee 射频(RF)前端、内存和微控制器。</p><p>•8 位MCU（增强型、标准8051指令集）。</p><p>•256 KB Flash和8 KB 的RAM，内部16MHz RC 和 32kHz RC 振荡器。</p><p>•8路12位ADC；18个中断源；4个Timer；硬件支持的AES128 ；WDT(1.9ms-1s)；32 kHz晶振的休眠模式定时器、POR(上电复位)、BOD(掉电检测)，以及21 个通用I&#x2F;O 。</p></blockquote><h1 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><img src="/2022/8d6db935/20180211202707601.png" alt="img"></p><p>I &#x2F; O端口具有以下主要功能：</p><ul><li>21个数字通用输入&#x2F;输出引脚</li><li>通用I &#x2F; O或外设I &#x2F; O</li><li>输入上拉或下拉功能</li><li>外部中断功能</li></ul><blockquote><p>所有21个I &#x2F; O引脚都具有外部中断功能。 因此，如果需要，外部设备可能会产生中断。 外部中断功能也可用于将器件从睡眠模式（电源模式PM1，PM2和PM3）中唤醒</p></blockquote><blockquote><p>通用IO：共21个，分成3组，<strong>P0组、P1组、P2组</strong>，其中P0\P1组各8个IO，P2组5个（P2_0、P2_1、 P2_2、P2_3、 P2_4）。其中P1_0、P1_1有20mA的输出驱动能力，其余的只有4mA。</p></blockquote><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><ol><li><p>GPIO<strong>功能</strong>选择寄存器——<strong>PxSEL</strong></p><p> 寄存器PxSEL（其中x是端口号0-2）用于将端口中的每个引脚配置为<strong>通用I&#x2F;O引脚</strong>或<strong>外设I&#x2F;O引脚</strong>，可位寻址。 默认情况下，复位后，所有数字输入&#x2F;输出引脚都配置为<strong>通用上拉输入引脚</strong>。</p><blockquote><p>其中，P2SEL只有第0位至第2位是端口2的功能选择控制位，第3位至第6位是端口1的外设优先级控制位。</p></blockquote></li></ol><ul><li>0&#x3D;通用</li><li>1&#x3D;外设I&#x2F;O</li></ul><ol><li><p>GPIO<strong>输入输出方向</strong>选择寄存器——<strong>PxDIR</strong></p><p>寄存器PxDIR用于将每个端口的引脚方向设置为<strong>输入方向</strong>或<strong>输出方向</strong>。 因此，将PxDIR中的相应位设置为1，相应的引脚就变成输出方向，可位寻址。复位后为<strong>输入引脚</strong>。</p><blockquote><p>其中，P2DIR只有第0位至第4位是端口2的方向选择控制位，第6位和第7位是端口0外设优先级控制位。</p></blockquote></li></ol><ul><li><p>0&#x3D;输入</p></li><li><p>1&#x3D;输出</p></li></ul><ol start="2"><li><p>GPIO<strong>输入模式</strong>寄存器——<strong>PxINP</strong></p><p>寄存器PxINP用于设置IO端口的<strong>输入模式</strong>，通用I &#x2F; O端口引脚可配置为具有<strong>上拉</strong>，<strong>下拉</strong>或<strong>三态</strong>操作模式。 默认情况下，复位后，输入配置为带有上拉的输入。如果要取消输入端口的上拉或下拉功能，必须将PxINP中的相应位设置为1。</p><ul><li>请注意，即使IO端口是外设功能输入，配置为外设I &#x2F; O信号的引脚也不具有上拉或下拉功能。</li></ul><blockquote><p>其中，P2INP中，第0位至第4位是端口2的输入模式选择位</p><p><strong>第5位至第7位是端口0、端口1、端口2的上下拉选择位。</strong></p><ul><li>0&#x3D;PullUp</li><li>1&#x3D;PullDown</li></ul></blockquote></li></ol><ul><li>0&#x3D;上拉或下拉</li><li>1&#x3D;三态</li></ul><h1 id="Z-Stack"><a href="#Z-Stack" class="headerlink" title="Z-Stack"></a>Z-Stack</h1><h2 id="创建一个任务-Create-Task"><a href="#创建一个任务-Create-Task" class="headerlink" title="创建一个任务 Create Task"></a>创建一个任务 Create Task</h2><ul><li>&#x2F;&#x2F; 任务列表<br>const pTaskEventHandlerFn tasksArr[] &#x3D; {…..}</li><li>&#x2F;&#x2F; 初始化任务<br>void osalInitTasks( void )<br>{…..}</li><li>&#x2F;&#x2F; 任务处理函数<br>uint16 Hello_ProcessEvent(uint8 task_id, uint16 events)<br>{…}</li></ul><h2 id="HAL库之LED"><a href="#HAL库之LED" class="headerlink" title="HAL库之LED"></a>HAL库之LED</h2><ol><li>uint8 HalLedSet (uint8 leds, uint8 mode)</li></ol><table><thead><tr><th>ModeName</th><th>作用</th></tr></thead><tbody><tr><td>HAL_LED_MODE_BLINK</td><td>闪烁  (一次)</td></tr><tr><td>HAL_LED_MODE_FLASH</td><td>闪烁</td></tr><tr><td>HAL_LED_MODE_ON</td><td></td></tr><tr><td>HAL_LED_MODE_OFF</td><td></td></tr><tr><td>HAL_LED_MODE_TOGGLE</td><td>触发</td></tr></tbody></table><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><ol><li><p>uint8 osal_start_timerEx( uint8 taskID, uint16 event_id, uint16 timeout_value )</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//为指定的任务设置定时器</span><br><br>osal_start_timerEx(task_id, <span class="hljs-number">0x0001</span>, <span class="hljs-number">10000</span>);<br></code></pre></td></tr></table></figure></li><li></li></ol><h2 id="PAN-ID"><a href="#PAN-ID" class="headerlink" title="PAN_ID"></a>PAN_ID</h2><ul><li><p>全称 Personal Area Network (网络标识符)</p></li><li><p>相当于网络号，网段。</p></li></ul><p>Tools\f8Config.cfgLine59</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Define the default PAN ID.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Setting this to a value other than 0xFFFF causes</span><br><span class="hljs-comment"> * ZDO_COORD to use this value as its PAN ID and</span><br><span class="hljs-comment"> * Routers and end devices to join PAN with this ID</span><br><span class="hljs-comment"> */</span><br>-DZDAPP_CONFIG_PAN_ID=<span class="hljs-number">0x0010</span><br></code></pre></td></tr></table></figure><h2 id="Z-Stack开发步骤"><a href="#Z-Stack开发步骤" class="headerlink" title="Z-Stack开发步骤"></a>Z-Stack开发步骤</h2><h3 id="功能类型定义"><a href="#功能类型定义" class="headerlink" title="功能类型定义"></a>功能类型定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 功能类型值定义</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    DevTemp = <span class="hljs-number">1</span>,<br>    DevHumm,<br><span class="hljs-comment">//略---------------------</span><br>    DevMaxNum<br>&#125;;<br></code></pre></td></tr></table></figure><p>枚举功能类型值，需要时添加即可。</p><h3 id="定义节点功能列表"><a href="#定义节点功能列表" class="headerlink" title="定义节点功能列表"></a>定义节点功能列表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/***************************************************/</span><br><span class="hljs-comment">/* 节点功能列表                                    */</span><br><span class="hljs-comment">/***************************************************/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ep_info_t</span> <span class="hljs-title">funcList</span>[] =</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(HAS_GAS)</span><br>    &#123;<br>        <span class="hljs-comment">//stat,income,timeout,resource</span><br>        <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, sensorGasTimeout, sensorGasResAvailable,<br>        &#123; DevGas, <span class="hljs-number">0</span>, <span class="hljs-number">3</span> &#125;,                   <span class="hljs-comment">// type, id, refresh cycle</span><br>    &#125;,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-comment">//略----------------</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(ZDO_COORDINATOR)</span><br>    &#123;   <span class="hljs-comment">// 协调器</span><br>        CoordinatorNwkStateChangeRoutine,<br>        CoordinatorIncomingRoutine,<br>        CoordinatorTimeoutRoutine,<br>        CoordinatorResAvailableRoutine,<br>        &#123; DevCoordinator, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;,<br>    &#125;,<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(RTR_NWK)</span><br>    &#123;   <span class="hljs-comment">// 路由器</span><br>        RouterNwkStateChangeRoutine,<br>        RouterIncomingRoutine,<br>        RouterTimeoutRoutine,<br>        RouterResAvailableRoutine,<br>        &#123; DevRouter, <span class="hljs-number">0</span>, <span class="hljs-number">30</span> &#125;,<br>    &#125;,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p>功能列表</p></li><li><p>参考下面的 <strong>ep_info_t</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 不能修改下面的内容!!!</span><br><span class="hljs-type">const</span> uint8 funcCount = <span class="hljs-keyword">sizeof</span>(funcList) / <span class="hljs-keyword">sizeof</span>(funcList[<span class="hljs-number">0</span>]);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><br></code></pre></td></tr></table></figure></li><li><p>功能数量</p></li><li></li></ul><h3 id="ep-info-t"><a href="#ep-info-t" class="headerlink" title="ep_info_t"></a>ep_info_t</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ep_info_t</span> &#123;</span><br>    <span class="hljs-comment">// 网络状态发生变化时会调用该函数</span><br>    <span class="hljs-type">void</span> (*nwk_stat_change)(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep);<br>    <span class="hljs-comment">// 接收到数据时会调用该函数</span><br>    <span class="hljs-type">void</span> (*incoming_data)(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg);<br>    <span class="hljs-comment">// 周期性调用的函数</span><br>    <span class="hljs-type">void</span> (*time_out)(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep);<br>    <span class="hljs-comment">// 系统资源可用时调用该函数,系统资源指的是:串口接收到数据/中断等等</span><br>    <span class="hljs-type">void</span> (*res_available)(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep, RES_TYPE type, <span class="hljs-type">void</span> *res);<br>    <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> cycle成员会被用来计数,并周期性调用time_out函数</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">func_info_t</span> <span class="hljs-title">function</span>;</span><br>    <br><span class="hljs-comment">//以下数据用户不能进行更改！！！！！</span><br>    <br>    <span class="hljs-comment">// 当前端点号</span><br>    uint8 ep;<br>    <span class="hljs-comment">// 与此端点绑定的任务ID</span><br>    uint8 task_id;<br>    <span class="hljs-comment">// 递减计数,为0时调用time_out函数,并重载初值=cycle</span><br>    uint8 timerTick;<br>    uint8 userTimer;<br>    endPointDesc_t SampleApp_epDesc;<br>    SimpleDescriptionFormat_t simpleDesc;<br>&#125;;<br><br><span class="hljs-comment">//一个典型的初始化</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(ZDO_COORDINATOR)</span><br>    &#123;   <span class="hljs-comment">// 协调器</span><br>        CoordinatorNwkStateChangeRoutine,<span class="hljs-comment">//节点加入网络完成后调用</span><br>        CoordinatorIncomingRoutine,<span class="hljs-comment">//端点接收到数据后会调用</span><br>        CoordinatorTimeoutRoutine,<span class="hljs-comment">//周期调用</span><br>        CoordinatorResAvailableRoutine,<span class="hljs-comment">//系统初始化、串口收到数据、用户定时器到时 会调用</span><br>        &#123; DevCoordinator, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;,<span class="hljs-comment">//功能类型、功能编号、刷新周期</span><br>    &#125;,<br><br></code></pre></td></tr></table></figure><h4 id="nwk-stat-change"><a href="#nwk-stat-change" class="headerlink" title="nwk_stat_change"></a>nwk_stat_change</h4><p><strong>节点加入网络完成后调用</strong></p><ul><li>可用于读取当前  端点  信息</li><li></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">xxNwkStateChange</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep)</span><br>    <br><span class="hljs-type">void</span> <span class="hljs-title function_">sensorVoiceNwkStateChange</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep)</span><br>&#123;<br>    voiceEndPoint = ep;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="incoming-data"><a href="#incoming-data" class="headerlink" title="incoming_data"></a>incoming_data</h4><p><strong>端点接收到数据后会调用</strong></p><ul><li>下发的指令的处理</li><li></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">xxReceiveData</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg)</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">testReceiveData</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg)</span><br>&#123;<br>    <span class="hljs-comment">//msg-&gt;Data[0] 是接受到的总  比特   数 </span><br><span class="hljs-keyword">if</span>( (msg-&gt;Data[<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;L&#x27;</span>)&amp;&amp;(msg-&gt;Data[<span class="hljs-number">2</span>]==<span class="hljs-string">&#x27;E&#x27;</span>)&amp;&amp;(msg-&gt;Data[<span class="hljs-number">3</span>]==<span class="hljs-string">&#x27;D&#x27;</span>) )<br>    &#123;<br><span class="hljs-keyword">if</span>( msg-&gt;Data[<span class="hljs-number">4</span>]==<span class="hljs-string">&#x27;1&#x27;</span> )<br>&#123;<br>HalUARTWrite(HAL_UART_PORT_0, <span class="hljs-string">&quot;LED_1\r\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;LED_1\r\n&quot;</span>) - <span class="hljs-number">1</span>);<br><span class="hljs-comment">//HalLedBlink(HAL_LED_1, 2, 50, 100);</span><br>&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="time-out"><a href="#time-out" class="headerlink" title="time_out"></a>time_out</h4><p><strong>周期调用</strong></p><ul><li>读取传感器数据</li><li></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">xxTimeout</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep)</span><br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">sensorFireTimeout</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep)</span><br>&#123;<br>    uint8 value = FireInfo();<br>    SendData(ep-&gt;ep, &amp;value, <span class="hljs-number">0x0000</span>, TRANSFER_ENDPOINT, <span class="hljs-keyword">sizeof</span>(value));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="res-available"><a href="#res-available" class="headerlink" title="res_available"></a>res_available</h4><p><strong>系统初始化、串口收到数据、用户定时器到时 会调用</strong></p><ul><li>初始化端口、</li><li></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">xxResAvailable</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep, RES_TYPE type, <span class="hljs-type">void</span> *res)</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">sensorRainResAvailable</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep, RES_TYPE type, <span class="hljs-type">void</span> *res)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(type == ResInit)<br>    &#123;<br>        RainInit();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="IAR学习笔记"><a href="#IAR学习笔记" class="headerlink" title="IAR学习笔记"></a>IAR学习笔记</h1><h2 id="无法观察局部变量"><a href="#无法观察局部变量" class="headerlink" title="无法观察局部变量"></a>无法观察局部变量</h2><p>在软件调试的时候发现Watch窗口中无法观察局部变量的值，总是显示<unavailable><br>　　设置IAR中的”<strong>Options — c&#x2F;c++ compiler — Optimization — Level</strong>“ 选项：<br>　　Level的缺省值为Low，当我把Level选为None之后，即不执行任何优化时，全局变量、静态局部变量、局部变量的值都可以看到。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;CC2530是针对IEEE 802.15.4，Zigbee和RF4CE应用的真正片上系统（SoC）解决方案。 它能够以非常低的总物料成本构建强大的网络节点。</summary>
        
      
    
    
    
    <category term="blog" scheme="https://www.oikiou.top/categories/blog/"/>
    
    
    <category term="Embedded" scheme="https://www.oikiou.top/tags/Embedded/"/>
    
    <category term="CC2530" scheme="https://www.oikiou.top/tags/CC2530/"/>
    
    <category term="Zigbee" scheme="https://www.oikiou.top/tags/Zigbee/"/>
    
  </entry>
  
  <entry>
    <title>MarkDown学习笔记</title>
    <link href="https://www.oikiou.top/2022/da7ed36c/"/>
    <id>https://www.oikiou.top/2022/da7ed36c/</id>
    <published>2022-08-21T14:57:15.000Z</published>
    <updated>2022-09-10T05:20:07.362Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><p>asdasdasdasdassdasdas</p><h2 id="这是一段引用"><a href="#这是一段引用" class="headerlink" title="这是一段引用"></a>这是一段引用</h2><blockquote><p>这是一段引用</p></blockquote><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><ul><li>阿斯大声</li><li>阿斯大声打</li><li>阿斯大声问请问恶</li></ul><h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><ol><li><p>阿斯大声打</p></li><li><p>阿斯大声阿斯大声</p></li><li><p>dasd阿斯dasdaaa</p></li></ol><h2 id="斜体-和-加粗-强调"><a href="#斜体-和-加粗-强调" class="headerlink" title="斜体 和 加粗 (强调)"></a>斜体 和 加粗 (强调)</h2><p>这是<em>斜体</em>      这是<strong>加粗</strong>   这是_什么呢_  好像也__是一样的__</p><h2 id="这是上下标"><a href="#这是上下标" class="headerlink" title="这是上下标"></a>这是上下标</h2><p>  H<del>2</del>0   H^2^0</p><h2 id="这段是横线"><a href="#这段是横线" class="headerlink" title="这段是横线"></a>这段是横线</h2><hr><hr><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p><a href="./assets/00.jpg">这是超链接</a></p><p><a href=".%5Cassets%5C00.jpg">www.Baidu.com</a></p><p><a href="https://sigrok.org/wiki/Protocol_decoder_API">这是一个超链接 （注意链接前后不要留空格）</a></p><p>This is <a href="http://example.com/" title="Optional Title Here">an example</a> reference-style link.</p><h2 id="文章内的超链接"><a href="#文章内的超链接" class="headerlink" title="文章内的超链接"></a><a id="文章内的超链接">文章内的超链接</a></h2><p> <a href="##%E8%A1%A8%E6%A0%BC">这是一个文章内部的超链接</a></p><p> Ctrl+左键  </p><p><a href="#HTML跳转">回到-&gt;HTML 跳转</a></p><h2 id="Email-链接"><a href="#Email-链接" class="headerlink" title="Email 链接"></a>Email 链接</h2><p>作者的 Emal <a href="mailto:&#x78;&#x78;&#64;&#x78;&#x78;&#x2e;&#99;&#x6f;&#109;">&#x78;&#x78;&#64;&#x78;&#x78;&#x2e;&#99;&#x6f;&#109;</a> 链接</p><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><ul><li>内联风格</li></ul><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1557132849466&di=61258032fff80f7d4bfff0ad0b325b12&imgtype=0&src=http://s6.sinaimg.cn/middle/6dca756dhad5c3293f515&690" alt="iPhone"></p><ul><li>引用风格</li></ul><p><strong>一直没弄出来</strong></p><p>xxx<img src="/photo_id" alt="photo_id"></p><h2 id="代码块-与-代码行"><a href="#代码块-与-代码行" class="headerlink" title="代码块 与 代码行"></a>代码块 与 代码行</h2><p><code>  delay_init();     //延时函数初始化</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>delay_init();     <span class="hljs-comment">//延时函数初始化</span><br>TIM_ALL_Init();<br> LED_Init();     <span class="hljs-comment">//LED端口初始化</span><br>LCD_Init();<br>POINT_COLOR=WHITE;<br>BACK_COLOR = BLACK;<br>LCD_Clear(BLACK);<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><table><thead><tr><th>name</th><th>age</th><th>sex</th></tr></thead><tbody><tr><td>Done</td><td>20</td><td>0</td></tr><tr><td>Jack</td><td>21</td><td>0</td></tr><tr><td>Done<br/>这里换行了</td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><p><del>这是一条删除             线线线线线线线线线线线线线线线</del></p><h2 id="这是一个注释"><a href="#这是一个注释" class="headerlink" title="这是一个注释"></a>这是一个注释</h2><p>[注释] <a href="%E8%BF%99%E6%98%AF%E6%B3%A8%E9%87%8A%E7%9A%84%E8%A7%A3%E9%87%8A">^注释</a>:Somebody that I used to know.</p><h2 id="数学表达式"><a href="#数学表达式" class="headerlink" title="数学表达式"></a>数学表达式</h2><p>$ (h&#x2F;2)<em>(a+9)&#x2F;(b</em>9))*L $</p><p>$lim_{x \to \infty} \ exp(-x)&#x3D;0$</p><h2 id="修改文字颜色-HTLML"><a href="#修改文字颜色-HTLML" class="headerlink" title="修改文字颜色 HTLML"></a>修改文字颜色 HTLML</h2><p>You can use HTML to style content what pure Markdown does not support.</p><p><span style="color:red"><strong>TEXT Style</strong></span></p><p><span style="color:#29b6f6"> <strong>TEXT Style</strong> </span></p><p><span style="color:rgb(255, 255, 255)"><strong>TEXT Style</strong></span></p><p><span style="color:LightPink"> <strong>TEXT Style</strong> </span></p><p><span style="color:Thistle"> <strong>TEXT Style</strong> </span></p><p><span style="color:Gold"> <strong>TEXT Style</strong> </span></p><p><span style="color:Tomato"> <strong>TEXT Style</strong> </span></p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:red&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:#29b6f6&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:rgb(255, 255, 255)&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><br>https://www.5tu.cn/colors/yansezhongwenming.html<br></code></pre></td></tr></table></figure><p>For example, use <code>&lt;span style=&quot;color:red&quot;&gt;this text is red&lt;/span&gt;</code> to add text with red color.</p><h2 id="表情-Emoji-smile"><a href="#表情-Emoji-smile" class="headerlink" title="表情 Emoji :smile:"></a>表情 Emoji :smile:</h2><p>Input emoji with syntax <code>:smile:</code>.</p><p>User can trigger auto-complete suggestions for emoji by pressing <code>ESC</code> key, or trigger it automatically after enabling it on preference panel. Also, inputting UTF-8 emoji characters directly is also supported by going to <code>Edit</code> -&gt; <code>Emoji &amp; Symbols</code> in the menu bar (macOS).</p><h2 id="Task-List-带勾的计划任务-勾选框"><a href="#Task-List-带勾的计划任务-勾选框" class="headerlink" title="Task List 带勾的计划任务 勾选框"></a>Task List 带勾的计划任务 勾选框</h2><ul><li><input disabled="" type="checkbox"> a task list item</li><li><input disabled="" type="checkbox"> list syntax required </li><li><input checked="" disabled="" type="checkbox"> completed</li></ul><p>注意    [内有一个空格] </p><h2 id="Video"><a href="#Video" class="headerlink" title="Video"></a>Video</h2><p>You can use the <code>&lt;video&gt;</code> HTML tag to embed videos. For example:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Markdown"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;xxx.mp4&quot;</span> /&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">文字[^脚注1]文字.<br>[<span class="hljs-symbol">^脚注1</span>]:<span class="hljs-link">这是脚注1的内容</span><br></code></pre></td></tr></table></figure><p>文字<a href="%E8%BF%99%E6%98%AF%E8%84%9A%E6%B3%A81%E7%9A%84%E5%86%85%E5%AE%B9">^脚注1</a>文字.</p><h2 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h2><p><strong>1.实现下标与上标的三种方法：</strong></p><ul><li><p>方法1（符号）：(这是Markdown的拓展语法)</p><figure class="highlight parser3"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs parser3"><span class="language-xml">下标 ：θ~</span><span class="hljs-number">1</span><span class="language-xml">~ </span><br><span class="language-xml">上标 ：θ</span><span class="hljs-keyword">^2</span><span class="language-xml">^</span><br><span class="language-xml"></span><span class="hljs-number">12</span><br></code></pre></td></tr></table></figure></li><li><p>结果如下：<br>下标 ：θ<del>1</del><br>上标 ：θ^2^</p></li><li><p>方法2（HTML标签）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml">下标 ：θ<span class="hljs-tag">&lt;<span class="hljs-name">sub</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">sub</span>&gt;</span><br>上标 ：θ<span class="hljs-tag">&lt;<span class="hljs-name">sup</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">sup</span>&gt;</span><br>12<br></code></pre></td></tr></table></figure></li><li><p>结果如下：<br>下标 ：θ<sub>1</sub><br>上标 ：θ<sup>2</sup></p></li><li><p>方法3（公式块）：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br>下标 ：θ_1 ，上标 ：θ^<span class="hljs-number">2</span><br><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure></li><li><p>结果如下：</p></li><li><p>$$<br>下标 ：θ_1 ，上标 ：θ^2<br>$$</p></li></ul><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><h2 id="HTML-跳转"><a href="#HTML-跳转" class="headerlink" title="HTML 跳转"></a><a id="HTML跳转">HTML 跳转</a></h2><p><a href="#文章内的超链接">点击到达-&gt;文章内的超链接</a> </p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">&lt;<span class="hljs-keyword">a</span> href=<span class="hljs-string">&quot;#demo&quot;</span>&gt;点击到达跳转位置演示&lt;/<span class="hljs-keyword">a</span>&gt; <span class="hljs-comment"># 在需要跳转的地方添加此代码。</span><br>&lt;<span class="hljs-keyword">a</span> id=<span class="hljs-string">&quot;demo&quot;</span>&gt;跳转位置演示（跳转位置设置点）&lt;/<span class="hljs-keyword">a</span>&gt; <span class="hljs-comment"># 在跳转位置添加次代码。</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;一级标题&quot;&gt;&lt;a href=&quot;#一级标题&quot; class=&quot;headerlink&quot; title=&quot;一级标题&quot;&gt;&lt;/a&gt;一级标题&lt;/h1&gt;&lt;h2 id=&quot;二级标题&quot;&gt;&lt;a href=&quot;#二级标题&quot;</summary>
        
      
    
    
    
    <category term="blog" scheme="https://www.oikiou.top/categories/blog/"/>
    
    
    <category term="MarkDown" scheme="https://www.oikiou.top/tags/MarkDown/"/>
    
    <category term="note" scheme="https://www.oikiou.top/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>Hex 文件格式解析</title>
    <link href="https://www.oikiou.top/2022/d3f98b78/"/>
    <id>https://www.oikiou.top/2022/d3f98b78/</id>
    <published>2022-08-21T14:57:15.000Z</published>
    <updated>2022-09-10T05:20:07.360Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hex-文件格式解析"><a href="#Hex-文件格式解析" class="headerlink" title="Hex 文件格式解析"></a>Hex 文件格式解析</h1><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://developer.arm.com/documentation/ka003292/1-0">Intel HEX File Format Keil</a></p><p><a href="https://en.wikipedia.org/wiki/Intel_HEX">Intel HEX Wiki</a></p><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><ul><li>以行为单位，每行以冒号开头，内容全部为16进制码（以ASCII码形式显示）</li><li>在HEX文件里面，每一行代表一个记录。记录的基本格式为如表所示</li></ul><table><thead><tr><th><strong>冒号</strong></th><th><strong>本行数据长度</strong></th><th><strong>本行数据起始地址</strong></th><th><strong>数据类型</strong></th><th><strong>数据</strong></th><th><strong>校验码</strong></th></tr></thead><tbody><tr><td></td><td>1 byte</td><td>2 bytes</td><td>1 byte</td><td>n byte</td><td>1 byte</td></tr></tbody></table><p><img src="/2022/d3f98b78/hex_format.jpg"></p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Start code</td><td>one character, an ASCII colon ‘:’</td></tr><tr><td>Byte count</td><td>两个十六进制数字（一个十六进制数字对），表示数据字段中的字节数（十六进制数字对）。最大字节数为 255 (0xFF)。16 (0x10) 和 32 (0x20) 是常用的字节数。</td></tr><tr><td>Address</td><td>四位十六进制数字，表示数据的 16 位起始内存地址偏移量。数据的物理地址是通过将此偏移量添加到先前建立的基地址来计算的，从而允许内存寻址超出 16 位地址的 64 KB 限制。默认为零的基地址可以通过各种类型的记录进行更改。基地址和地址偏移量始终表示为<a href="https://en.wikipedia.org/wiki/Big_endian">大端</a>值。</td></tr><tr><td>Record type</td><td>两个十六进制数字，<em>00</em>到<em>05</em>，定义数据字段的含义。参考下文</td></tr><tr><td>Data</td><td>一个由<em>n</em>个字节组成的数据序列，由 <em>2n</em> 个十六进制数字表示。一些记录省略了这个字段（<em>n</em>等于零）。数据字节的含义和解释取决于应用程序。</td></tr><tr><td>Checksum</td><td>two hex digits, a computed value that can be used to verify the record has no errors.计算校验和前所有16进制码的累加和。</td></tr></tbody></table><h3 id="指令类型-Record-type"><a href="#指令类型-Record-type" class="headerlink" title="指令类型 Record type"></a>指令类型 Record type</h3><p>指令类型<code>Record type</code>的值一般是<code>00~05</code>，这表示了，当前这行<code>hex</code>格式的数据，所代表的含义：</p><table><thead><tr><th>十六进制代码</th><th>记录类型</th><th align="center">描述</th><th align="center">Example</th></tr></thead><tbody><tr><td><strong>00</strong></td><td>数据</td><td align="center">包含数据和该数据的16位起始地址。字节计数指定记录中的数据字节数。右侧显示的示例为0B （十一）个数据字节（61， 64， 64， 72， 65， 73， 73， 20， 67， 61， 70）位于以地址开头的连续地址 0010。</td><td align="center"><code>:0B 0010 00 6164647265737320676170 A7</code></td></tr><tr><td><strong>01</strong></td><td>文件结束</td><td align="center">每个文件在文件的最后一行必须恰好发生一次。数据字段为空（因此字节数为00），并且地址字段通常为 0000。</td><td align="center"><code>:00 0000 01 FF</code></td></tr><tr><td><strong>02</strong></td><td>扩展段地址</td><td align="center">数据字段包含一个16位的段基址（因此字节数始终为02）与80x86实模式寻址兼容。地址字段（通常为0000）被忽略。最近的段地址02记录乘以16，然后加到每个后续数据记录地址，以形成数据的物理起始地址。这允许寻址多达1 MB的地址空间。</td><td align="center"><code>:02 0000 02 1200 EA</code></td></tr><tr><td><strong>03</strong></td><td>起始段地址</td><td align="center">对于80x86处理器，请指定CS：IP寄存器的初始内容（即起始执行地址）。地址字段是0000，字节数始终为04，前两个数据字节是CS值，后两个是IP值。</td><td align="center"><code>:04 0000 03 00003800 C1</code></td></tr><tr><td><strong>04</strong></td><td>扩展线性地址</td><td align="center">允许32位寻址（最大4GiB）。记录的地址字段将被忽略（通常是0000），其字节数始终为02。两个数据字节（大字节序）为所有后续类型指定32位绝对地址的高16位00记录; 这些高位地址位适用于下一个04记录。类型的绝对地址00 通过组合最近的高16位地址位形成记录 04 用低16位的地址记录 00记录。如果是类型00 记录之前没有任何类型 04 记录，然后其高16位地址位默认为0000。</td><td align="center"><code>:02 0000 04 FFFF FC</code></td></tr><tr><td><strong>05</strong></td><td>起始线性地址</td><td align="center">地址字段是 0000（未使用），字节数始终为04。四个数据字节代表一个32位地址值（big-endian）。对于80386和更高版本的CPU，此地址将加载到EIP寄存器中。<br/><strong>（仅限 MDK-ARM）</strong>起始线性地址记录指定应用程序的起始地址。这些记录包含完整的线性 32 位地址。</td><td align="center"><code>:04 0000 05 000000CD 2A</code></td></tr></tbody></table><h5 id="扩展线性地址记录-HEX386"><a href="#扩展线性地址记录-HEX386" class="headerlink" title="扩展线性地址记录 (HEX386)"></a>扩展线性地址记录 (HEX386)</h5><p>扩展线性地址记录也称为 32 位地址记录和 HEX386 记录。这些记录包含数据地址的高 16 位（位 16-31）。扩展线性地址记录总是有两个数据字节，如下所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">:02000004FFFFFC<br></code></pre></td></tr></table></figure><p>在哪里：</p><ul><li><strong>02</strong>是记录中的数据字节数。</li><li><strong>0000</strong>是地址字段。对于扩展线性地址记录，此字段始终为 0000。</li><li><strong>04</strong>是记录类型 04（扩展的线性地址记录）。</li><li><strong>FFFF</strong>是地址的高 16 位。</li><li><strong>FC</strong>是记录的校验和，计算方式为<br>01h + NOT(02h + 00h + 00h + 04h + FFh + FFh)。</li></ul><p>读取扩展线性地址记录时，存储在数据字段中的扩展线性地址将被保存并应用于从 Intel HEX 文件读取的后续记录。线性地址保持有效，直到被另一个扩展地址记录改变。</p><p>数据记录的绝对内存地址是通过将记录中的地址字段与扩展线性地址记录的移位地址数据相加得到的。下面的例子说明了这个过程。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-type">Address</span> from the <span class="hljs-class"><span class="hljs-keyword">data</span> record&#x27;s address field      2462</span><br><span class="hljs-type">Extended</span> linear address record <span class="hljs-class"><span class="hljs-keyword">data</span> field     <span class="hljs-type">FFFF</span></span><br>                                              <span class="hljs-comment">--------</span><br><span class="hljs-type">Absolute</span>-memory address                       <span class="hljs-type">FFFF2462</span><br></code></pre></td></tr></table></figure><h5 id="扩展段地址记录-HEX86"><a href="#扩展段地址记录-HEX86" class="headerlink" title="扩展段地址记录 (HEX86)"></a>扩展段地址记录 (HEX86)</h5><p>扩展段地址记录（也称为 HEX86 记录）包含数据地址段的第 4-19 位。扩展段地址记录总是有两个数据字节，如下所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">:020000021200EA<br></code></pre></td></tr></table></figure><p>在哪里：</p><ul><li><strong>02</strong>是记录中的数据字节数。</li><li><strong>0000</strong>是地址字段。对于扩展段地址记录，该字段始终为 0000。</li><li><strong>02</strong>是记录类型 02（扩展段地址记录）。</li><li><strong>1200</strong>是地址段。</li><li><strong>EA</strong>是记录的校验和，计算方式为<br>01h + NOT(02h + 00h + 00h + 02h + 12h + 00h)。</li></ul><p>当读取扩展段地址记录时，存储在数据字段中的扩展段地址被保存并应用于从 Intel HEX 文件读取的后续记录。段地址保持有效，直到被另一个扩展地址记录改变。</p><p>数据记录的绝对内存地址是通过将记录中的地址字段添加到来自扩展段地址记录的移位地址数据中获得的。以下示例说明了此过程。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-type">Address</span> from the <span class="hljs-class"><span class="hljs-keyword">data</span> record&#x27;s address field     2462</span><br><span class="hljs-type">Extended</span> segment address record <span class="hljs-class"><span class="hljs-keyword">data</span> field      1200</span><br>                                             <span class="hljs-comment">--------</span><br><span class="hljs-type">Absolute</span> memory address                      <span class="hljs-number">00014462</span><br></code></pre></td></tr></table></figure><h5 id="起始线性地址记录（仅限-MDK-ARM）"><a href="#起始线性地址记录（仅限-MDK-ARM）" class="headerlink" title="起始线性地址记录（仅限 MDK-ARM）"></a>起始线性地址记录（仅限 MDK-ARM）</h5><p>起始线性地址记录指定应用程序的起始地址。这些记录包含完整的线性 32 位地址。起始线性地址记录总是有四个数据字节，如下所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">:04000005000000CD2A<br></code></pre></td></tr></table></figure><p>在哪里：</p><ul><li><strong>04</strong>是记录中的数据字节数。</li><li><strong>0000</strong>是地址字段。对于起始线性地址记录，该字段始终为 0000。</li><li><strong>05</strong>是记录类型 05（起始线性地址记录）。</li><li><strong>000000CD</strong>是应用程序的 4 字节线性起始地址。</li><li><strong>2A</strong>是记录的校验和，计算方式为<br>01h + NOT(04h + 00h + 00h + 05h + 00h + 00h + 00h + CDh)。</li></ul><p>Start Linear Address 指定了 __main（pre-main）函数的地址，而不是通常在调用 SystemInit() 之后调用 __main 的启动代码的地址。奇数线性起始地址指定 __main 是为 Thumb 指令集编译的。</p><p>起始线性地址记录可以出现在 hex 文件中的任何位置。在大多数情况下，可以忽略此记录，因为它不包含对闪存进行编程所需的信息。</p><h5 id="文件结束-EOF-记录"><a href="#文件结束-EOF-记录" class="headerlink" title="文件结束 (EOF) 记录"></a>文件结束 (EOF) 记录</h5><p>英特尔 HEX 文件必须以文件结束 (EOF) 记录结尾。此记录在记录类型字段中必须具有值 01。EOF 记录始终如下所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">:00000001FF<br></code></pre></td></tr></table></figure><p>在哪里：</p><ul><li><strong>00</strong>是记录中的数据字节数。</li><li><strong>0000</strong>是数据在内存中的位置。文件尾记录中的地址是无意义的并且被忽略。地址 0000h 是典型的。</li><li><strong>01</strong>是记录类型 01（文件结束记录）。</li><li><strong>FF</strong>是记录的校验和，计算方式为<br>01h + NOT(00h + 00h + 00h + 01h)。</li></ul><h2 id="tip"><a href="#tip" class="headerlink" title="tip"></a>tip</h2><ul><li><strong>用Notepad++打开hex文件，会自动上色、换行</strong></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Hex-文件格式解析&quot;&gt;&lt;a href=&quot;#Hex-文件格式解析&quot; class=&quot;headerlink&quot; title=&quot;Hex 文件格式解析&quot;&gt;&lt;/a&gt;Hex 文件格式解析&lt;/h1&gt;&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a</summary>
        
      
    
    
    
    <category term="blog" scheme="https://www.oikiou.top/categories/blog/"/>
    
    
    <category term="Hex" scheme="https://www.oikiou.top/tags/Hex/"/>
    
  </entry>
  
  <entry>
    <title>SSL证书的申请和自动续期</title>
    <link href="https://www.oikiou.top/2022/82aca4fc/"/>
    <id>https://www.oikiou.top/2022/82aca4fc/</id>
    <published>2022-08-21T14:57:15.000Z</published>
    <updated>2022-09-10T05:20:07.364Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SSL证书的申请和自动续期"><a href="#SSL证书的申请和自动续期" class="headerlink" title="SSL证书的申请和自动续期"></a>SSL证书的申请和自动续期</h1><p>Let’s Encrypt 证书续期</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/a2d0209fa3f5">https://www.jianshu.com/p/a2d0209fa3f5</a></p><p><a href="https://www.cnblogs.com/esofar/p/9291685.html">快速签发 Let’s Encrypt 证书指南</a></p><p><a href="https://certbot.eff.org/">https://certbot.eff.org/</a></p><h1 id="acme-sh-申请"><a href="#acme-sh-申请" class="headerlink" title="acme.sh 申请"></a>acme.sh 申请</h1><p>用 acme.sh申请来自动续期ssl证书<br> acme说明：<a href="https://links.jianshu.com/go?to=https://github.com/Neilpang/acme.sh/wiki/%E8%AF%B4%E6%98%8E">https://github.com/Neilpang/acme.sh/wiki/说明</a></p><ol><li>下载acme<code>curl https://get.acme.sh | sh</code>  安装完成后必须关闭当前终端，重新开启一个以使acme.sh命令生效</li><li>执行生成和自动更新命令：<code>acme.sh --issue -d mydomain.com -d www.mydomain.com --webroot /var/www/mydomain.com/</code></li><li>安装证书 <code>cd /etc/nginx; mkdir ssl</code></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">acme.sh  --installcert  -d  <span class="hljs-tag">&lt;<span class="hljs-name">domain</span>&gt;</span>.com   \<br>        --key-file   /etc/nginx/ssl/<span class="hljs-tag">&lt;<span class="hljs-name">domain</span>&gt;</span>.key \<br>        --fullchain-file /etc/nginx/ssl/fullchain.cer \<br>        --reloadcmd  &quot;service nginx force-reload&quot;<br></code></pre></td></tr></table></figure><ol start="4"><li>配置nginx使用ssl</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash">server &#123;<br>    listen 80 default_server;<br>    listen 443 http2 ssl;<br>    listen [::]:80 default_server;<br><br>    ssl_certificate /etc/nginx/ssl/fullchain.cer;<br>    ssl_certificate_key /etc/nginx/ssl/domain.key;<br>    <span class="hljs-comment">#http转https</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable">$scheme</span> = http ) &#123;<span class="hljs-built_in">return</span> 301 https://$host<span class="hljs-variable">$request_uri</span>;&#125;<br>    root /var/www/html;<br><br>    index index.html index.htm index.nginx-debian.html;<br>    server_name _;<br><br>    ssl_certificate /etc/nginx/ssl/fullchain.cer;<br>    ssl_certificate_key /etc/nginx/ssl/domain.key;<br><br>    location /test &#123;<br>          proxy_pass       http://127.0.0.1:3000;<br>          proxy_http_version 1.1;<br>          proxy_set_header Upgrade <span class="hljs-variable">$http_upgrade</span>;<br>          proxy_set_header Connection <span class="hljs-string">&quot;upgrade&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>前端的Upgrade请求发送给后端服务器，Upgrade和Connection的头信息必须被显式的设置。一旦我们完成以上设置，NGINX就可以处理WebSocket连接了。查看配置在哪里<code>ps -ef|grep nginx</code><br> 多个域名的话，配多个nginx.conf配置。</p><ol start="5"><li>查看是否有每日任务<br> <code>crontab -l #查看你的任务</code><br> 手动更新证书<code>acme.sh --renew -d domain.com</code></li></ol><h1 id="certbot"><a href="#certbot" class="headerlink" title="certbot"></a>certbot</h1><p><a href="https://certbot.eff.org/">文档</a></p><p>Ubuntu + nginx <a href="https://certbot.eff.org/instructions?ws=nginx&amp;os=ubuntufocal">https://certbot.eff.org/instructions?ws=nginx&amp;os=ubuntufocal</a></p><p>用certbot来自动续期ssl证书</p><ul><li>需要注意的是安装证书的时候最好把nginx关掉先</li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;SSL证书的申请和自动续期&quot;&gt;&lt;a href=&quot;#SSL证书的申请和自动续期&quot; class=&quot;headerlink&quot; title=&quot;SSL证书的申请和自动续期&quot;&gt;&lt;/a&gt;SSL证书的申请和自动续期&lt;/h1&gt;&lt;p&gt;Let’s</summary>
        
      
    
    
    
    <category term="blog" scheme="https://www.oikiou.top/categories/blog/"/>
    
    
    <category term="SSL" scheme="https://www.oikiou.top/tags/SSL/"/>
    
    <category term="HTTPS" scheme="https://www.oikiou.top/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>OSI</title>
    <link href="https://www.oikiou.top/2022/1a11e44c/"/>
    <id>https://www.oikiou.top/2022/1a11e44c/</id>
    <published>2022-08-21T14:57:15.000Z</published>
    <updated>2022-09-10T05:20:07.363Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OSI"><a href="#OSI" class="headerlink" title="OSI"></a>OSI</h1><p>开放系统互联参考模型(OSI Referenec Model)，即我们通常所说的网络互联的七层框架，它是国际标准组织(International Organization for Standization)于1977年提出的标准，又称为ISO&#x2F;IEC 7498或X.200建议。值得注意的是，OSI并没有提供一个可以实现的方法，它不是一个标准而只是一个制定标准时使用的概念性的框架，更不是一个网络协议。</p><ol><li>物理层(Physical Layer)：主要功能为定义了网络的物理结构，传输的电磁标准，Bit流的编码及网络的时间原则，如分时复用及分频复用。决定了网络连接类型(端到端或多端连接)及物理拓扑结构。说的通俗一些，这一层主要负责实际的<a href="https://product.pconline.com.cn/itbk/sjtx/sj/1203/2699254.html">信号</a>传输。</li><li>数据链路层(D<a href="https://product.pconline.com.cn/itbk/diy/mb/1107/2474080.html">ata</a> Link eview)：在两个主机上建立数据链路连接，向物理层传输数据信号，并对信号进行处理使之无差错并合理的传输</li><li>网络层(Network Layer)：主要负责路由，选择合适的路径，进行阻塞控制等功能。</li><li>传输层(Transfer Layer)：最关键的一层，向拥护提供可靠的端到端(End-to-End)服务，它屏蔽了下层的数据通信细节，让用户及应用程序不需要考虑实际的通信方法。</li><li>会话层(Session Layer)：主要负责两个会话进程之间的通信，即两个会话层实体之间的信息交换，管理数据的交换。</li><li>表示层(Presentation Layer)：处理通信信号的表示方法，进行不同的格式之间的翻译，并负责数据的加密解密，数据的压缩与恢复</li><li>应用层(Application Layer)：保持应用程序之间建立连接所需要的数据记录，为用户服务。 三大协议NetBEUI和 IPX&#x2F;SPX TCP&#x2F;IP</li></ol><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td></td></tr><tr><td>应用层(Application Layer)</td><td>消息</td></tr><tr><td>表示层(Presentation Layer)</td><td></td></tr><tr><td>会话层(Session Layer)</td><td></td></tr><tr><td>传输层(Transfer Layer)</td><td>数据段(segment)</td></tr><tr><td>网络层(Network Layer)</td><td>分组、数据包（packet）</td></tr><tr><td>链路层(Data Link eview)</td><td>帧（frame）</td></tr><tr><td>物理层(Physical Layer)</td><td>P-PDU（bit）</td></tr></tbody></table>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;OSI&quot;&gt;&lt;a href=&quot;#OSI&quot; class=&quot;headerlink&quot; title=&quot;OSI&quot;&gt;&lt;/a&gt;OSI&lt;/h1&gt;&lt;p&gt;开放系统互联参考模型(OSI Referenec</summary>
        
      
    
    
    
    <category term="blog" scheme="https://www.oikiou.top/categories/blog/"/>
    
    
    <category term="OSI" scheme="https://www.oikiou.top/tags/OSI/"/>
    
  </entry>
  
  <entry>
    <title>Tags Label Category</title>
    <link href="https://www.oikiou.top/2022/c65e1067/"/>
    <id>https://www.oikiou.top/2022/c65e1067/</id>
    <published>2022-08-21T14:57:15.000Z</published>
    <updated>2022-09-10T05:20:07.364Z</updated>
    
    <content type="html"><![CDATA[<p>知乎  <a href="https://www.zhihu.com/people/songvision">千鸟</a></p><blockquote><p>  这问题要分两个层面来解读：</p><p>  <strong>首先是Tag与Category的区别。</strong>Category往往限制在一个维度里，当树状结构复杂到不可调和时，出现瓶颈是迟早的事。Category的问题在于，既不能完全满足用户需求，也不能完全表达创建者对内容属性的认知。而Tag反之都成立，完全互补。</p><p>  <a href="https://link.zhihu.com/?target=http://blog.rexsong.com/?p=975">http://blog.rexsong.com/?p=975</a>（内容、标签和分类）</p><p>  <a href="https://link.zhihu.com/?target=http://blog.rexsong.com/?p=1753">http://blog.rexsong.com/?p=1753</a>（使用标签是迟早的事）</p><p>  <strong>其次是Label与Tag的区别。</strong>于对内容的概括出现偏差，但显然这种问题不是tag，在内容组织范畴那应该是什么？答案就是label，除产品描述，其应用范畴还涉及功能名称、模块名称、导航名称、引导文字等等场景。我认为tag与label之间有三个显著差异：</p><ol><li>label是本身的，tag是附加的；</li><li>label强调是一种标志，tag强调是一种记号；</li><li>label标明信息之间的归属，tag区别信息之间的差异。</li></ol><p>  <a href="https://link.zhihu.com/?target=http://blog.rexsong.com/?p=11900">http://blog.rexsong.com/?p=11900</a>（标签与标记的区别）</p></blockquote><p>知乎 郑讯</p><blockquote><p>  Tag，标签，一般包含一段内容的属性，可以是分类，可以是话题，也可以是作者，地理信息等。</p><p>  Label，标记，是网页框架中一个区域的功能概括。比如知乎首页上的“浏览”、“问题”、“通知”就是label。选择不同的标记，相应区域的功能就会发生变化。</p><p>  category，分类，可以理解为种属概念。一段内容有且只有一个种属的分类。和Tag不同的是一段内容可以有多个tag，并且tag是未预先设定的，一段内容可以有多个Tag，也可以没有Tag。但caterory在一个分类标准下只有一个。</p></blockquote><p>知乎 李楠</p><blockquote><p>  <strong>Category</strong></p><p>  Category 是非常理想化和一根筋的分类方式。图书馆这种死板到头的地方用的多。但是他们也遇到了问题：“苏菲的世界”到底是“哲学”，还是“文学”？</p><p>  物理世界无力从根本上解决这种问题（但似乎不少讨论）。问过我们学校的图书馆，似乎他们方式还比较靠谱：<strong>买两本，两处放。</strong></p><p>  分类对象数字化之后， Category 的影响还在（早期的门户找点跨界的东西就很悲剧）。直到 Web2.0 ， Tag 竟然才开始流行。</p><p>  <strong>Tag</strong></p><p>  Tag 是更好的分类方式的原因是：</p><p>  1</p><p>  “类别”本来就不应该事先定义：人不是上帝。</p><p>  从一个个具体对象的“属性”中，总结出“类别”是最自然的模式。也是“人”可以做到的事情。</p><p>  2</p><p>  “属性”本来就应该可以自然的表现为多个。</p><p>  苏菲的世界终于可以自然的打上“哲学”和“文学”的 Tag 了，或者再加个“少儿读物”。这种思考方式比 Category 优雅太多。</p><p>  Tag 最终普及，背后恐怕有<a href="https://www.zhihu.com/search?q=%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:12226710%7D">软件工程</a>上 OO 普及（面向对象）的因素。<strong>“面向对象”不仅仅是的程序构建方式，更是认识世界的方法论的进步。</strong></p><p>  “属性”跟随“对象”，比“对象”属于“类别”更自然，不机械。 。</p><p>  <strong>Tag 的改进</strong></p><p>  Tag 本身也可以看作“对象”。</p><p>  那么就有针对 Tag 的操作，比如“搜索”，“排序”，“关联对象”。也有 Tag 本身的属性，比如“使用次数”，“关注人数”等等。</p><p>  如何能在使用 Tag 的系统中，根据这些数据，计算出最适合的对象，就要靠算法的优化和运营的调整了。</p></blockquote><p>知乎 <a href="https://www.zhihu.com/people/zheng-wei-42-9">榆木脑袋</a></p><blockquote><p>  Catagory是逻辑清晰的。Tag是随意自由的。在看到一个信息的时候我们需要自由捕获自己头脑中的闪光。在重新审视或再利用我们收集的信息时，就需要清晰的逻辑条理。</p><p>  以文件管理为例：</p><p>  在标记Tag时需求有二：一是能够方便增加新的Tag，二是能够很方便的看到已有的Tag，并能同时把已有标签赋予当前信息。</p><p>  在查找文件时个人觉得需要有的功能是：一是有固定的几个入口，也就是根目录；二是可以增加根节点；三是根目录可以指定某几个Tag，也可以不是；三如果根目录不是Tag，需要定义关联到此根目录（分类）下的Tag；四（重点功能）根目录下不直接列出信息或文件（时间长了，某一Tag下文件会相当多），而是列出关联Tag的所有文件的其它Tag，显示为子目录，并标识出此子目录中的文件数量。五（作为管理功能）此时可以定义哪些Tag不在此根目录下出现。六设置某个Tag或某类Tag(文件数量大过一个数量)下仍不列出文件而是继续列出Tag；七子目录（Tag）下，上级目录Tag不再出现。</p><p>  我个人非常偏好使用树形目录结构，但苦恼于文件的多重分类和文件进行多重分类时的繁琐。经过多方搜索只找到三个比较符合的软件，一个是PinKM，一个是蓝码动力图片管理软件，一个是国外的Tabbles。但都因标签管理和整理的繁琐而放弃。</p></blockquote><p><strong>个人理解</strong></p><ul><li>Catagory 是属于严格的分类方法, 一个东西应当只属于一个Catagory内, 而且它是有层级关系的</li><li>Tags 是可有可无的, 一个东西可以有很多的Tags, 它是无层级关系的,</li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;知乎  &lt;a href=&quot;https://www.zhihu.com/people/songvision&quot;&gt;千鸟&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;  这问题要分两个层面来解读：&lt;/p&gt;
&lt;p&gt; </summary>
        
      
    
    
    
    <category term="blog" scheme="https://www.oikiou.top/categories/blog/"/>
    
    
    <category term="Tags" scheme="https://www.oikiou.top/tags/Tags/"/>
    
    <category term="Label" scheme="https://www.oikiou.top/tags/Label/"/>
    
    <category term="Category" scheme="https://www.oikiou.top/tags/Category/"/>
    
  </entry>
  
  <entry>
    <title>USART硬件流控制</title>
    <link href="https://www.oikiou.top/2022/3b631eba/"/>
    <id>https://www.oikiou.top/2022/3b631eba/</id>
    <published>2022-08-21T14:57:15.000Z</published>
    <updated>2022-09-10T05:20:07.365Z</updated>
    
    <content type="html"><![CDATA[<h1 id="USART硬件流控制"><a href="#USART硬件流控制" class="headerlink" title="USART硬件流控制"></a>USART硬件流控制</h1><p><img src="/2022/3b631eba/SouthEast.jpeg"></p><p>RS232 DB9定义</p><p>1 CD ← Carrier Detect 载波检测</p><p>2 RXD ← Receive Data 接收数据</p><p>3 TXD → Transmit Data 发送数据</p><p>4 <strong>DTR → Data Terminal Ready数据终端就绪</strong></p><p>5 GND — System Ground 系统接地</p><p>6 DSR ← Data Set Ready 数据设备就绪</p><p>7 <strong>RTS → Request To Send 请求发送</strong></p><p>8 CTS ← Clear To Send 清除发送(允许发送)</p><p>9 RI → 振铃指示</p><h2 id="RTS-CTS"><a href="#RTS-CTS" class="headerlink" title="RTS CTS"></a>RTS CTS</h2><ul><li>RTS （Require ToSend，发送请求）为输出信号，用于指示本设备准备好可接收数据，低电平有效，低电平说明本设备可以接收数据。</li><li>CTS （Clear ToSend，发送允许）为输入信号，用于判断是否可以向对方发送数据，低电平有效，低电平说明本设备可以向对方发送数据。</li></ul><h2 id="DTR-DSR"><a href="#DTR-DSR" class="headerlink" title="DTR DSR"></a>DTR DSR</h2>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;USART硬件流控制&quot;&gt;&lt;a href=&quot;#USART硬件流控制&quot; class=&quot;headerlink&quot; title=&quot;USART硬件流控制&quot;&gt;&lt;/a&gt;USART硬件流控制&lt;/h1&gt;&lt;p&gt;&lt;img</summary>
        
      
    
    
    
    <category term="blog" scheme="https://www.oikiou.top/categories/blog/"/>
    
    
    <category term="USART" scheme="https://www.oikiou.top/tags/USART/"/>
    
    <category term="RTS" scheme="https://www.oikiou.top/tags/RTS/"/>
    
    <category term="CTS" scheme="https://www.oikiou.top/tags/CTS/"/>
    
    <category term="DTR" scheme="https://www.oikiou.top/tags/DTR/"/>
    
    <category term="DSR" scheme="https://www.oikiou.top/tags/DSR/"/>
    
  </entry>
  
  <entry>
    <title>Windows下使用Makefile</title>
    <link href="https://www.oikiou.top/2022/714f1d49/"/>
    <id>https://www.oikiou.top/2022/714f1d49/</id>
    <published>2022-08-21T14:57:15.000Z</published>
    <updated>2022-09-10T05:20:07.368Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-安装MinGW"><a href="#1-安装MinGW" class="headerlink" title="1.安装MinGW"></a>1.安装MinGW</h1><p>在MinGW的bin目录下有一个文件叫<code>mingw32-make.exe</code> 运行它就跟<code>make</code>指令类似</p><p><img src="/2022/714f1d49/watermarkpic_center.png" alt="在这里插入图片描述"></p><h1 id="2-CMD-终端运行Makefile-mingw32-make"><a href="#2-CMD-终端运行Makefile-mingw32-make" class="headerlink" title="2. CMD 终端运行Makefile (mingw32-make)"></a>2. CMD 终端运行Makefile (mingw32-make)</h1><p>在cmd终端下直接输入<code>mingw32-make</code>然后回车就可以进行编译了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">Microsoft Windows [版本 10.0.16299.967]<br>(c) 2017 Microsoft Corporation。保留所有权利。<br><br>D:\Project\Code\C++\hello&gt; mingw32-make.exe<br>g++    -c -o main.o main.cpp<br>g++ -std=c++17 -o main main.o<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;1-安装MinGW&quot;&gt;&lt;a href=&quot;#1-安装MinGW&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="blog" scheme="https://www.oikiou.top/categories/blog/"/>
    
    
    <category term="Windows" scheme="https://www.oikiou.top/tags/Windows/"/>
    
    <category term="Makefile" scheme="https://www.oikiou.top/tags/Makefile/"/>
    
  </entry>
  
  <entry>
    <title>VScode插件CommentTranslate在WSL内无效</title>
    <link href="https://www.oikiou.top/2022/1d3ed0f3/"/>
    <id>https://www.oikiou.top/2022/1d3ed0f3/</id>
    <published>2022-08-21T14:57:15.000Z</published>
    <updated>2022-09-10T05:20:07.365Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VScode插件CommentTranslate在WSL内无效"><a href="#VScode插件CommentTranslate在WSL内无效" class="headerlink" title="VScode插件CommentTranslate在WSL内无效"></a>VScode插件CommentTranslate在WSL内无效</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/intellism/vscode-comment-translate/issues/64">https://github.com/intellism/vscode-comment-translate/issues/64</a></p><ol><li><p>找到相关语言语法规则文件。如C&#x2F;CPP、bat、css、java、python，这些文件都是在Windows版本的VSCode中内置的，文件路径在 <code>C:\Users\ **userNmae** \AppData\Local\Programs\Microsoft VS Code\resources\app\extensions</code>改过安装路径的是<code>Microsoft VS Code\resources\app\extensions</code></p><p><img src="/2022/1d3ed0f3/image-20220811202401467.png" alt="image-20220811202401467"></p></li></ol><p>​</p><ol><li><p>将语法规则的<strong>高亮规则</strong>文件夹拷贝到远程vscode的相关插件目录。以C语言为例，将<code>cpp</code>目录下的高亮规则文件夹<code>syntaxes</code>拷贝到远程C&#x2F;C++插件（<code>ms-vscode.cpptools-x.x.x</code>）目录下。如果你使用SSH远程，远程插件的目录在<code>~/.vscode-server/extensions/ms-vscode.cpptools-x.x.x</code>。</p><p><img src="/2022/1d3ed0f3/image-20220811202845203.png" alt="image-20220811202845203"></p></li><li><p>修改远程插件，添加语法高亮规则。修改远程插件的<code>package.json</code>文件，如C&#x2F;C++插件（<code>ms-vscode.cpptools-x.x.x</code>）目录下的<code>package.json</code>文件，将刚才cpp语法规则文件夹中的<code>package.json</code>文件的”<code>grammars</code>“部分拷贝出来，粘贴到远程插件的<code>package.json</code>的<code>contributes</code>部分中去。</p><p>如果遇到格式难以复制，可以全选内容然后按Shift+Alt+F格式化选定内容。<img src="/2022/1d3ed0f3/image-20220811202944334.png" alt="image-20220811202944334"></p></li></ol><p><img src="/2022/1d3ed0f3/image-20220811203114753.png" alt="image-20220811203114753"></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;VScode插件CommentTranslate在WSL内无效&quot;&gt;&lt;a href=&quot;#VScode插件CommentTranslate在WSL内无效&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="blog" scheme="https://www.oikiou.top/categories/blog/"/>
    
    
    <category term="VSCode" scheme="https://www.oikiou.top/tags/VSCode/"/>
    
    <category term="CommentTranslate" scheme="https://www.oikiou.top/tags/CommentTranslate/"/>
    
    <category term="WSL" scheme="https://www.oikiou.top/tags/WSL/"/>
    
  </entry>
  
  <entry>
    <title>XIP 片内执行</title>
    <link href="https://www.oikiou.top/2022/2c1a46d6/"/>
    <id>https://www.oikiou.top/2022/2c1a46d6/</id>
    <published>2022-08-21T14:57:15.000Z</published>
    <updated>2022-09-10T05:20:07.369Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XIP-eXecute-In-Place"><a href="#XIP-eXecute-In-Place" class="headerlink" title="XIP   eXecute In Place"></a>XIP   eXecute In Place</h1><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><p>eXecute In Place，即芯片内执行，是指CPU直接从存储器中读取程序代码执行。</p><p>应用程序可以直接在flash闪存内运行，不必再把代码读到系统RAM中。flash内执行是指nor flash不需要初始化，可以直接在flash内执行代码。但往往<strong>只执行部分代码</strong>，比如<strong>初始化RAM</strong>。好处即是程序代码无需占用内存，减少内存的要求。</p><p><strong>所谓片内执行不是说程序在存储器内执行，CPU的基本功能是取指、译码、运行。Nor Flash能在芯片内执行，指的是CPU能够直接从Nor flash中取指令，供后面的译码器和执行器来使用。</strong></p><p>为实现XIP，必须满足几个条件：</p><ol><li><p>存储器必须提供与内存相似的接口给CPU。</p></li><li><p>该接口必须提供足够快的读取操作，并具有随机访问模式。</p></li><li><p>如有文件系统，则需要提供合适的映射功能</p></li><li><p>程序链接时需要知道存储器的地址或地址与位置无关。</p></li><li><p>程序不能修改已加载映像中的数据。</p></li></ol><p>NOR Flash和EEPROM通常能满足上述要求。</p><h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p><strong>nandflash也可以实现XIP</strong></p><p>“所谓XIP,就是CODE是在FLASH上直接运行. NANDFLASH只是不适合做XIP,但并不是不能做XIP“要一段CODE能够正确的运行,要保证它的CODE是连续的,正确的.由于一些电气特性的原因,NOR FLASH能够做到这一点,不存在坏道或坏块,所以能够做XIP.</p><p><strong>NOR Flash 和 NAND Flash</strong></p><p>NOR Flash具备随机读取给一个地址就能读一个数据，NAND Flash是一次读一块数据，一个地址读出一块数据。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;XIP-eXecute-In-Place&quot;&gt;&lt;a href=&quot;#XIP-eXecute-In-Place&quot; class=&quot;headerlink&quot; title=&quot;XIP   eXecute In Place&quot;&gt;&lt;/a&gt;XIP</summary>
        
      
    
    
    
    <category term="blog" scheme="https://www.oikiou.top/categories/blog/"/>
    
    
    <category term="XIP" scheme="https://www.oikiou.top/tags/XIP/"/>
    
    <category term="NOR" scheme="https://www.oikiou.top/tags/NOR/"/>
    
    <category term="NAND" scheme="https://www.oikiou.top/tags/NAND/"/>
    
  </entry>
  
  <entry>
    <title>机智云通信</title>
    <link href="https://www.oikiou.top/2022/60aa39b4/"/>
    <id>https://www.oikiou.top/2022/60aa39b4/</id>
    <published>2022-08-21T14:57:15.000Z</published>
    <updated>2022-09-10T05:20:07.387Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>包头(2B)</th><th>包长度(2B)</th><th>命令(1B)</th><th>包序号(1B)</th></tr></thead><tbody><tr><td>0xFFFF</td><td>(包长度)后面的数据长度</td><td></td><td></td></tr></tbody></table><table><thead><tr><th>Flag(2B)</th><th>xxx</th><th>校验和(1B)</th></tr></thead><tbody><tr><td></td><td></td><td>和校验</td></tr></tbody></table><p>因为包头为固定 0xFFFF，对于发送方，如检测到有出现 0xFF 的数据内容，需要在 0xFF 后添加 0x55。对于接收方，如检测到非包头部分出现 0xFF，需要把紧跟其后的 0x55 移除。</p><table><thead><tr><th>命令</th><th>内容</th></tr></thead><tbody><tr><td>0x01</td><td>设备向MCU请求信息</td></tr><tr><td>0x02</td><td>MCU回复设备</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;包头(2B)&lt;/th&gt;
&lt;th&gt;包长度(2B)&lt;/th&gt;
&lt;th&gt;命令(1B)&lt;/th&gt;
&lt;th&gt;包序号(1B)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;0x</summary>
        
      
    
    
    
    <category term="blog" scheme="https://www.oikiou.top/categories/blog/"/>
    
    
    <category term="Embedded" scheme="https://www.oikiou.top/tags/Embedded/"/>
    
    <category term="机智云" scheme="https://www.oikiou.top/tags/%E6%9C%BA%E6%99%BA%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>搭建KMS</title>
    <link href="https://www.oikiou.top/2022/3ef2a47d/"/>
    <id>https://www.oikiou.top/2022/3ef2a47d/</id>
    <published>2022-08-21T14:57:15.000Z</published>
    <updated>2022-09-10T05:20:07.387Z</updated>
    
    <content type="html"><![CDATA[<h1 id="KMS"><a href="#KMS" class="headerlink" title="KMS"></a>KMS</h1><p>KMS（Key Management Service），密钥管理服务</p><p>能够通过KMS进行激活的一般称为VL版,即VOLUME授权版，一般不会单独在零售市场进行发售，一般是直接向企业提供电子ISO映像进行批量授权安装，基于对KMS原理研究成果，我们可以自行搭建KMS激活服务器，实现每180天一次的自动激活，使得系统一直保持激活状态。</p><p>KMS可以激活VOL版本的windows系统和office软件</p><h1 id="Docker-部署KMS服务器"><a href="#Docker-部署KMS服务器" class="headerlink" title="Docker 部署KMS服务器"></a>Docker 部署KMS服务器</h1><p><a href="https://registry.hub.docker.com/r/teddysun/kms">https://registry.hub.docker.com/r/teddysun/kms</a></p><ol><li><p>Pull the image</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull teddysun/kms<br></code></pre></td></tr></table></figure><p>This pulls the latest release of KMS server. It can be found at Docker Hub.</p></li><li><p>Start a container</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d -p 1688:1688 --name kms --restart=always teddysun/kms<br></code></pre></td></tr></table></figure><p>Note: The TCP port number <code>1688</code> must be opened in firewall.</p></li></ol><h1 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h1><h2 id="激活windows"><a href="#激活windows" class="headerlink" title="激活windows"></a>激活windows</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 待激活的主机上指定KMS服务器</span><br>slmgr /skms service_address(你搭建的服务器的地址)<br><br><span class="hljs-comment"># 手动激活</span><br>slmgr /ato<br><br><span class="hljs-comment"># 如果激活失败 尝试更改成GVLK KEY再次激活</span><br><span class="hljs-comment"># 运行以下命令查看系统版本 </span><br>wmic os get caption<br><br><span class="hljs-comment"># 访问下面的网址获取key</span><br><span class="hljs-comment"># https://docs.microsoft.com/zh-cn/windows-server/get-started/kms-client-activation-keys</span><br><span class="hljs-comment"># https://technet.microsoft.com/en-us/library/jj612867.aspx</span><br><span class="hljs-comment"># 得到对应key之后，使用管理员权限运行cmd执行安装key：</span><br>slmgr /ipk xxxxx-xxxxx-xxxxx-xxxxx<br><br><span class="hljs-comment"># 手动激活</span><br>slmgr /ato<br></code></pre></td></tr></table></figure><h2 id="激活office"><a href="#激活office" class="headerlink" title="激活office"></a>激活office</h2><p>首先你的OFFICE必须是VOL版本，否则无法激活。 找到你的office安装目录，比如</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">C:<span class="hljs-string">\Program</span> Files (x86)<span class="hljs-string">\Microsoft</span> Office<span class="hljs-string">\Office16</span><br></code></pre></td></tr></table></figure><p>64位的就是</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">C:<span class="hljs-string">\Program</span> Files<span class="hljs-string">\Microsoft</span> Office<span class="hljs-string">\Office16</span><br></code></pre></td></tr></table></figure><p>office16是office2016，office15就是2013，office14就是2010.</p><p>然后目录对的话，该目录下面应该有个OSPP.VBS。</p><p>直接输入下面的指令去指定KMS服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">cscript <span class="hljs-string">&quot;C:\Program Files (x86)\Microsoft Office\Office16\OSPP.VBS&quot;</span> sethst:service_address(你搭建的服务器的地址)<br><span class="hljs-comment"># or</span><br>cscript <span class="hljs-string">&quot;C:\Program Files\Microsoft Office\Office16\OSPP.VBS&quot;</span> /sethst:service_address(你搭建的服务器的地址)<br></code></pre></td></tr></table></figure><p>一般来说，“一句命令已经完成了”，但一般office不会马上连接kms服务器进行激活，所以我们额外补充一条手动激活命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cscript ospp.vbs /act<br></code></pre></td></tr></table></figure><h1 id="如果遇到报错，请检查："><a href="#如果遇到报错，请检查：" class="headerlink" title="如果遇到报错，请检查："></a>如果遇到报错，请检查：</h1><blockquote><ol><li>你的系统&#x2F;OFFICE是否是批量VL版本</li><li>是否以管理员权限运行CMD</li><li>你的系统&#x2F;OFFICE是否修改过KEY&#x2F;未安装GVLK KEY</li><li>检查你的网络连接</li><li>服务器繁忙，多试试（点击检查KMS服务是否可用）</li><li>根据出错代码自己搜索出错原因</li></ol></blockquote><ul><li>windows VOL KEY</li></ul><p><a href="https://docs.microsoft.com/zh-cn/windows-server/get-started/kmsclientkeys">https://docs.microsoft.com/zh-cn/windows-server/get-started/kmsclientkeys</a></p><ul><li>检查office是否是VOL版本</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 命令提示符（管理员）执行：cd “office的安装目录”</span><br><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;C:\Program Files (x86)\Microsoft Office\Office16&quot;</span><br><span class="hljs-comment"># or</span><br><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;C:\Program Files\Microsoft Office\Office16&quot;</span><br><br><span class="hljs-comment"># 执行：</span><br>cscript ospp.vbs /dstatus<br></code></pre></td></tr></table></figure><p>在显示的信息中，如果有“VOLUME”字样就是VOL版，即支持KMS激活</p><ul><li>卸载office的密钥</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 命令提示符（管理员）执行：cd “office的安装目录”</span><br><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;C:\Program Files (x86)\Microsoft Office\Office16&quot;</span><br><span class="hljs-comment"># or</span><br><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;C:\Program Files\Microsoft Office\Office16&quot;</span><br><br><span class="hljs-comment"># 查看当前状态</span><br>cscript ospp.vbs /dstatus<br><br><span class="hljs-comment"># 找到 Last 5 characters of installed product key:XXXXX 语句</span><br><span class="hljs-comment"># 卸载密钥</span><br>cscript ospp.vbs /unpkey:XXXXX<br></code></pre></td></tr></table></figure><ul><li>查找office的VOL KEY</li></ul><p><a href="https://docs.microsoft.com/zh-cn/DeployOffice/vlactivation/gvlks">https://docs.microsoft.com/zh-cn/DeployOffice/vlactivation/gvlks</a></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;KMS&quot;&gt;&lt;a href=&quot;#KMS&quot; class=&quot;headerlink&quot; title=&quot;KMS&quot;&gt;&lt;/a&gt;KMS&lt;/h1&gt;&lt;p&gt;KMS（Key Management</summary>
        
      
    
    
    
    <category term="blog" scheme="https://www.oikiou.top/categories/blog/"/>
    
    
    <category term="KMS" scheme="https://www.oikiou.top/tags/KMS/"/>
    
    <category term="office" scheme="https://www.oikiou.top/tags/office/"/>
    
    <category term="volume" scheme="https://www.oikiou.top/tags/volume/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥杯STM32国赛笔记</title>
    <link href="https://www.oikiou.top/2022/b9b15cd2/"/>
    <id>https://www.oikiou.top/2022/b9b15cd2/</id>
    <published>2022-08-21T14:57:15.000Z</published>
    <updated>2022-09-10T05:20:07.387Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CT117E-EX-扩展板笔记"><a href="#CT117E-EX-扩展板笔记" class="headerlink" title="CT117E-EX 扩展板笔记"></a>CT117E-EX 扩展板笔记</h1><h2 id="数码管（74HC595）"><a href="#数码管（74HC595）" class="headerlink" title="数码管（74HC595）"></a>数码管（74HC595）</h2><h3 id="RCLK-R-存储寄存器读取"><a href="#RCLK-R-存储寄存器读取" class="headerlink" title="RCLK(R:存储寄存器读取)"></a>RCLK(R:存储寄存器读取)</h3><ul><li>上升沿    移位寄存器进入存储寄存器</li><li>下降沿    数据保持不变</li></ul><h3 id="SCK-S-送入595"><a href="#SCK-S-送入595" class="headerlink" title="SCK(S:送入595)"></a>SCK(S:送入595)</h3><ul><li>上升沿    数据寄存器数据移位。Q0–&gt;Q1–&gt;Q2–&gt;Q3–&gt;…–&gt;Q7;</li><li>下降沿    移位寄存器数据不变</li></ul><h3 id="SER（数据脚）"><a href="#SER（数据脚）" class="headerlink" title="SER（数据脚）"></a>SER（数据脚）</h3><ul><li>串行数据输入端</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">SEG_DisplayValue</span><span class="hljs-params">(u8 Bit1,  u8 Bit2, u8 Bit3)</span><br>&#123;<br>u8 i = <span class="hljs-number">0</span>;<span class="hljs-comment">//</span><br>u8 code_tmp = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    *略过部分代码</span><br><span class="hljs-comment">    */</span><br><br>code_tmp = Seg7[Bit1];<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)&#123;<br><br><span class="hljs-keyword">if</span>(code_tmp &amp; <span class="hljs-number">0x80</span>)&#123;<br>SER_H;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>SER_L;<br>&#125;<br>SCK_H;<span class="hljs-comment">//数据移位</span><br>code_tmp = code_tmp &lt;&lt; <span class="hljs-number">1</span>;   <br>SCK_L;<br>&#125;<br>RCLK_H;<span class="hljs-comment">//上升沿时移位寄存器进入存储寄存器</span><br>RCLK_L;<span class="hljs-comment">//下降沿是数据保持不变</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数码管显示数组"><a href="#数码管显示数组" class="headerlink" title="数码管显示数组"></a>数码管显示数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">u8 code t_display[]=&#123;                       <span class="hljs-comment">//标准字库</span><br><span class="hljs-comment">//   0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F</span><br><span class="hljs-number">0x3F</span>,<span class="hljs-number">0x06</span>,<span class="hljs-number">0x5B</span>,<span class="hljs-number">0x4F</span>,<span class="hljs-number">0x66</span>,<span class="hljs-number">0x6D</span>,<span class="hljs-number">0x7D</span>,<span class="hljs-number">0x07</span>,<span class="hljs-number">0x7F</span>,<span class="hljs-number">0x6F</span>,<span class="hljs-number">0x77</span>,<span class="hljs-number">0x7C</span>,<span class="hljs-number">0x39</span>,<span class="hljs-number">0x5E</span>,<span class="hljs-number">0x79</span>,<span class="hljs-number">0x71</span>,<br><br><span class="hljs-comment">//black  -     H    J    K    L    N    o   P    U     t    G    Q    r   M    y</span><br><span class="hljs-number">0x00</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x76</span>,<span class="hljs-number">0x1E</span>,<span class="hljs-number">0x70</span>,<span class="hljs-number">0x38</span>,<span class="hljs-number">0x37</span>,<span class="hljs-number">0x5C</span>,<span class="hljs-number">0x73</span>,<span class="hljs-number">0x3E</span>,<span class="hljs-number">0x78</span>,<span class="hljs-number">0x3d</span>,<span class="hljs-number">0x67</span>,<span class="hljs-number">0x50</span>,<span class="hljs-number">0x37</span>,<span class="hljs-number">0x6e</span>,<br>    <br> <span class="hljs-comment">//0. 1. 2. 3. 4. 5. 6. 7. 8. 9. -1</span><br><span class="hljs-number">0xBF</span>,<span class="hljs-number">0x86</span>,<span class="hljs-number">0xDB</span>,<span class="hljs-number">0xCF</span>,<span class="hljs-number">0xE6</span>,<span class="hljs-number">0xED</span>,<span class="hljs-number">0xFD</span>,<span class="hljs-number">0x87</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xEF</span>,<span class="hljs-number">0x46</span>&#125;;    <br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//   0    1    2    3    4    5    6    7    8    9</span><br><br><span class="hljs-number">0x3F</span>,<span class="hljs-number">0x06</span>,<span class="hljs-number">0x5B</span>,<span class="hljs-number">0x4F</span>,<span class="hljs-number">0x66</span>,<span class="hljs-number">0x6D</span>,<span class="hljs-number">0x7D</span>,<span class="hljs-number">0x07</span>,<span class="hljs-number">0x7F</span>,<span class="hljs-number">0x6F</span>,<span class="hljs-number">0x77</span><br></code></pre></td></tr></table></figure><h2 id="ADC按键"><a href="#ADC按键" class="headerlink" title="ADC按键"></a>ADC按键</h2><h3 id="ADC-KEY-引脚"><a href="#ADC-KEY-引脚" class="headerlink" title="ADC KEY 引脚"></a>ADC KEY 引脚</h3><p> PA5      ADC_12_<strong>IN5</strong></p><h3 id="按键值"><a href="#按键值" class="headerlink" title="按键值"></a>按键值</h3><table><thead><tr><th align="left">ADC值</th><th>ADC按键区间</th></tr></thead><tbody><tr><td align="left">0</td><td>&lt;100</td></tr><tr><td align="left">200</td><td>&lt;400</td></tr><tr><td align="left">600</td><td>&lt;800</td></tr><tr><td align="left">1000</td><td>&lt;1200</td></tr><tr><td align="left">1300-1400</td><td>&lt;1600</td></tr><tr><td align="left">1700-1900</td><td>&lt;2000</td></tr><tr><td align="left">2100-2400</td><td>&lt;2600</td></tr><tr><td align="left">2800-3000</td><td>&lt;3200</td></tr></tbody></table><h2 id="DHT11模块"><a href="#DHT11模块" class="headerlink" title="DHT11模块"></a>DHT11模块</h2><h3 id="芯片性能"><a href="#芯片性能" class="headerlink" title="芯片性能"></a>芯片性能</h3><ul><li>温度测量范围：0－50℃</li><li>湿度测量范围：20－90％RH</li><li>采样周期 ：1S</li></ul><h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><table><thead><tr><th>Byte0</th><th>Byte1</th><th>Byte2</th><th>Byte3</th><th>Byte4</th></tr></thead><tbody><tr><td>湿度整数数据</td><td>湿度小数数据</td><td>温度整数数据</td><td>温度小数数据</td><td>校验和</td></tr></tbody></table><h3 id="编程思路"><a href="#编程思路" class="headerlink" title="编程思路"></a>编程思路</h3><ul><li>主机输出</li><li>主机拉  <strong>低</strong>  至少 <font color="red">18ms</font></li><li>主机拉  <strong>高</strong>  <font color="red">20-40us</font></li><li>主机输入</li><li>主机等待信号线拉 <strong>低</strong>   （DHT11发送持续  <strong>40-50us</strong> 的  <strong>低</strong>   响应信号）</li><li>主机等待信号线拉 <strong>高</strong>   （DHT11发送持续  <strong>40-50us</strong> 的  <strong>高</strong>   拉高信号）</li><li>for(){   &#x2F;&#x2F;40bit数据       5Byte<ul><li>主机等待数据线拉<strong>低</strong>    （数据Bit开始）</li><li>主机等待数据线拉<strong>高</strong>    </li><li>主机延时 时间大于<strong>28us</strong>小于<strong>70us</strong>    （ <font color="red">Type值 40us</font>）</li><li>主机读取数据</li></ul></li><li>}</li><li>主机输出</li><li>主机拉高</li></ul><h3 id="技巧-amp-TIP"><a href="#技巧-amp-TIP" class="headerlink" title="技巧&amp;TIP"></a>技巧&amp;TIP</h3><ul><li><p>DHT11分辨率都是整数级别的<strong>读取小数的数据部分没有意义</strong>。（全为0）</p></li><li><p>读取间隔建议大于100ms（采样 1S 过高的读取频率没有意义）</p></li><li><p>在72MHz频率下 <strong>Delay_LCD</strong> 运行一次大约 <strong>375us</strong></p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Delay_LCD</span><span class="hljs-params">(u16 n)</span><br>&#123;<br>u16 i,j;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>;i&lt;n;++i)<br><span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">3000</span>;++j);<br>&#125;<br><span class="hljs-comment">//将里面的 3000 改成 8 运行一次大概 1us </span><br><span class="hljs-comment">//运行次数越少比1us越多</span><br><span class="hljs-comment">//运行次数越多比1us越少</span><br></code></pre></td></tr></table></figure><h2 id="18B20模块"><a href="#18B20模块" class="headerlink" title="18B20模块"></a>18B20模块</h2><h3 id="芯片性能-1"><a href="#芯片性能-1" class="headerlink" title="芯片性能"></a>芯片性能</h3><ul><li>±0.5°C accuracy from -10°C to +85°C</li><li>Can be powered from data line. Power supply range is 3.0V to 5.5V</li><li>Converts 12-bit temperature to digital word in 750 ms (max.)</li></ul><h3 id="数据格式-1"><a href="#数据格式-1" class="headerlink" title="数据格式"></a>数据格式</h3><h4 id="数据格式-2"><a href="#数据格式-2" class="headerlink" title="数据格式"></a>数据格式</h4><ul><li><p>写Byte数据先写<strong>低位</strong></p></li><li><p>读Byte数据先读出的是<strong>低位</strong></p></li><li><p>读出来的温度先是  <strong>LSM 8bit</strong>  然后是 MSB 8bit</p></li></ul><h4 id="总线协议-amp-时序"><a href="#总线协议-amp-时序" class="headerlink" title="总线协议&amp;时序"></a>总线协议&amp;时序</h4><p><img src="/2022/b9b15cd2/01-1557625836489.png" alt="复位时序"></p><p><img src="/2022/b9b15cd2/02.png" alt="读写时序"></p><h3 id="编程思路-1"><a href="#编程思路-1" class="headerlink" title="编程思路"></a>编程思路</h3><p>0xCCOW_SKIP_ROM</p><p>0x44DS18B20_CONVERT</p><p>0xCCOW_SKIP_ROM</p><p>0xBEDS18B20_READ</p><h2 id="LIS302DL"><a href="#LIS302DL" class="headerlink" title="LIS302DL"></a>LIS302DL</h2><p>NULL</p><h2 id="光敏-D-amp-A"><a href="#光敏-D-amp-A" class="headerlink" title="光敏 D&amp;A"></a>光敏 D&amp;A</h2><h3 id="光敏D"><a href="#光敏D" class="headerlink" title="光敏D"></a>光敏D</h3><ul><li>GPIOA_Pin_3 </li><li>GPIO_Mode_IPU</li></ul><h3 id="光敏A"><a href="#光敏A" class="headerlink" title="光敏A"></a>光敏A</h3><ul><li><p>GPIOA_Pin_4</p></li><li><p>ADC1</p></li><li><p>ADC_Channel_4</p></li></ul><h2 id="电位器"><a href="#电位器" class="headerlink" title="电位器"></a>电位器</h2><p>NULL</p><h2 id="PULS-amp-PWM"><a href="#PULS-amp-PWM" class="headerlink" title="PULS&amp;PWM"></a>PULS&amp;PWM</h2><p>PA1        TIM2_CH2</p><p>PA2        TIM2_CH3</p><p>PA6        TIM3_CH1</p><p>PA7        TIM3_CH2</p><h2 id="界面颜色搭配"><a href="#界面颜色搭配" class="headerlink" title="界面颜色搭配"></a>界面颜色搭配</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">LCD_SetBackColor(Blue);<br>LCD_SetTextColor(White);<br><span class="hljs-comment">//Line01</span><br>LCD_SetBackColor(White);<br>LCD_SetTextColor(Blue);<br><span class="hljs-comment">//Line1-77</span><br>LCD_SetBackColor(Blue);<br>LCD_SetTextColor(Black);<br><span class="hljs-comment">//Line892</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;CT117E-EX-扩展板笔记&quot;&gt;&lt;a href=&quot;#CT117E-EX-扩展板笔记&quot; class=&quot;headerlink&quot; title=&quot;CT117E-EX 扩展板笔记&quot;&gt;&lt;/a&gt;CT117E-EX</summary>
        
      
    
    
    
    <category term="blog" scheme="https://www.oikiou.top/categories/blog/"/>
    
    
    <category term="STM32" scheme="https://www.oikiou.top/tags/STM32/"/>
    
    <category term="蓝桥杯" scheme="https://www.oikiou.top/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    <category term="国赛" scheme="https://www.oikiou.top/tags/%E5%9B%BD%E8%B5%9B/"/>
    
    <category term="CT117E" scheme="https://www.oikiou.top/tags/CT117E/"/>
    
  </entry>
  
  <entry>
    <title>解决 Github 无法打开</title>
    <link href="https://www.oikiou.top/2022/db5fa6fe/"/>
    <id>https://www.oikiou.top/2022/db5fa6fe/</id>
    <published>2022-08-21T14:57:15.000Z</published>
    <updated>2022-09-10T05:20:07.390Z</updated>
    
    <content type="html"><![CDATA[<h1 id="解决-Github-无法打开"><a href="#解决-Github-无法打开" class="headerlink" title="解决 Github 无法打开"></a>解决 Github 无法打开</h1><h2 id="SwitchHosts"><a href="#SwitchHosts" class="headerlink" title="SwitchHosts"></a>SwitchHosts</h2><ol><li><p>下载 SwitchHosts <a href="https://github.com/oldj/SwitchHosts">Github</a> 下载要是太慢可以 用gitee镜像一下github的库 这里放一个别人镜像过的 <a href="https://gitee.com/itas109/SwitchHosts?_from=gitee_search">Gitee</a></p></li><li><p>安装后新建一个配置</p><ul><li>Title: 随意  Type: Remote  URL:   Auto Refresh: 最好选 1 hour</li></ul><p><img src="/2022/db5fa6fe/image-20211015220230835.png" alt="image-20211015220230835"></p><ul><li>可选的URL：<ul><li>520Github <a href="https://raw.hellogithub.com/hosts">https://raw.hellogithub.com/hosts</a></li><li>ineo6 <a href="https://gitee.com/ineo6/hosts/raw/master/hosts">https://gitee.com/ineo6/hosts/raw/master/hosts</a></li><li>有看到网上还有多个网站同时更新的，但是看到更新速度不够快，也就放弃了。</li></ul></li></ul></li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://github.com/ineo6/hosts">https://github.com/ineo6/hosts</a></p><p><a href="https://github.com/521xueweihan/GitHub520">https://github.com/521xueweihan/GitHub520</a></p><h2 id="Chrome-插件方式"><a href="#Chrome-插件方式" class="headerlink" title="Chrome 插件方式"></a>Chrome 插件方式</h2><p><a href="https://github.com/gauseen/faster-hosts">FasterHosts</a> 是个 Chrome 插件，主要原理是拦截浏览器的某些请求，将 <code>domain</code> 替换成访问速度较快的那个。hosts 资源来自 <a href="https://github.com/521xueweihan/GitHub520">GitHub520</a>，每 1 小时更新一次。</p><blockquote><ol><li>下载 <a href="https://github.com/gauseen/faster-hosts/archive/master.zip">FasterHosts</a> 然后解压，找到 <code>extension</code> 子目录</li><li>打开 Chrome，输入: <code>chrome://extensions/</code></li><li>打开「开发者模式」</li><li>选择「加载已解压的扩展程序」，然后定位到刚才解压的文件夹里面的 <code>extension</code> 目录，确定</li><li>这就安装好了，关闭「开发者模式」</li></ol></blockquote>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;解决-Github-无法打开&quot;&gt;&lt;a href=&quot;#解决-Github-无法打开&quot; class=&quot;headerlink&quot; title=&quot;解决 Github 无法打开&quot;&gt;&lt;/a&gt;解决 Github 无法打开&lt;/h1&gt;&lt;h2</summary>
        
      
    
    
    
    <category term="blog" scheme="https://www.oikiou.top/categories/blog/"/>
    
    
    <category term="github" scheme="https://www.oikiou.top/tags/github/"/>
    
    <category term="hosts" scheme="https://www.oikiou.top/tags/hosts/"/>
    
  </entry>
  
  <entry>
    <title>C</title>
    <link href="https://www.oikiou.top/2022/3dd7ffa7/"/>
    <id>https://www.oikiou.top/2022/3dd7ffa7/</id>
    <published>2022-08-21T14:57:15.000Z</published>
    <updated>2022-09-10T05:20:07.414Z</updated>
    
    <content type="html"><![CDATA[<h1 id="标准库函数"><a href="#标准库函数" class="headerlink" title="标准库函数"></a>标准库函数</h1><h2 id="fprintf-输出到流中"><a href="#fprintf-输出到流中" class="headerlink" title="fprintf 输出到流中"></a>fprintf 输出到流中</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>C 库函数 <strong>int fprintf(FILE *stream, const char *format, …)</strong> 发送格式化输出到流 stream 中。</p><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>下面是 fprintf() 函数的声明。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fprintf</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span><br></code></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。</li><li><strong>format</strong> – 这是 C 字符串，包含了要被写入到流 stream 中的文本。它可以包含嵌入的 format 标签，format 标签可被随后的附加参数中指定的值替换，并按需求进行格式化。format 标签属性是 <strong>%[flags][width][.precision][length]specifier</strong>，具体讲解如下：</li></ul><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>如果成功，则返回写入的字符总数，否则返回一个负数。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>下面的实例演示了 fprintf() 函数的用法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>   FILE * fp;<br><br>   fp = fopen (<span class="hljs-string">&quot;file.txt&quot;</span>, <span class="hljs-string">&quot;w+&quot;</span>);<br>   <span class="hljs-built_in">fprintf</span>(fp, <span class="hljs-string">&quot;%s %s %s %d&quot;</span>, <span class="hljs-string">&quot;We&quot;</span>, <span class="hljs-string">&quot;are&quot;</span>, <span class="hljs-string">&quot;in&quot;</span>, <span class="hljs-number">2014</span>);<br>   <br>   fclose(fp);<br>   <br>   <span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>让我们编译并运行上面的程序，这将创建文件 <strong>file.txt</strong>，它的内容如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">We</span> are in <span class="hljs-number">2014</span><br></code></pre></td></tr></table></figure><h2 id="atoi-字符串转换成整数"><a href="#atoi-字符串转换成整数" class="headerlink" title="atoi 字符串转换成整数"></a>atoi 字符串转换成整数</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>C 库函数 <strong>int atoi(const char *str)</strong> 把参数 <strong>str</strong> 所指向的字符串转换为一个整数（类型为 int 型）。</p><h3 id="声明-1"><a href="#声明-1" class="headerlink" title="声明"></a>声明</h3><p>下面是 atoi() 函数的声明。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">atoi</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str)</span><br></code></pre></td></tr></table></figure><h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><ul><li><strong>str</strong> – 要转换为整数的字符串。</li></ul><h3 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h3><p>该函数返回转换后的长整数，如果没有执行有效的转换，则返回零。</p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>下面的实例演示了 atoi() 函数的用法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>   <span class="hljs-type">int</span> val;<br>   <span class="hljs-type">char</span> str[<span class="hljs-number">20</span>];<br>   <br>   <span class="hljs-built_in">strcpy</span>(str, <span class="hljs-string">&quot;98993489&quot;</span>);<br>   val = atoi(str);<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;字符串值 = %s, 整型值 = %d\n&quot;</span>, str, val);<br><br>   <span class="hljs-built_in">strcpy</span>(str, <span class="hljs-string">&quot;runoob.com&quot;</span>);<br>   val = atoi(str);<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;字符串值 = %s, 整型值 = %d\n&quot;</span>, str, val);<br><br>   <span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>让我们编译并运行上面的程序，这将产生以下结果：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">字符串值 = <span class="hljs-number">98993489</span>, 整型值 = <span class="hljs-number">98993489</span><br>字符串值 = runoob.com, 整型值 = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h1 id="杂乱"><a href="#杂乱" class="headerlink" title="杂乱"></a>杂乱</h1><h2 id="stderr-stdout"><a href="#stderr-stdout" class="headerlink" title="stderr stdout"></a>stderr stdout</h2><ul><li><p>stdout – 标准输出设备 stdout。 </p></li><li><p>stderr – 标准错误输出设备</p></li></ul><p>两者默认向屏幕输出。 但如果用转向标准输出到磁盘文件，则可看出两者区别。stdout输出到磁盘文件，stderr在屏幕。 </p><blockquote><p>转向标准输出到磁盘文件tmp.txt<br>my.exe &gt; tmp.txt</p></blockquote><p>在默认情况下，stdout是行缓冲的，他的输出会放在一个buffer里面，只有到换行的时候，才会输出到屏幕。而stderr是无缓冲的，会直接输出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stdout</span>,<span class="hljs-string">&quot;Group&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<span class="hljs-string">&quot;XiyouLinux&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">linux下，第一次会输出XiYouLinuxGroup,是因为stdout将输出的Group放到了缓冲区当中直到程序结束在将缓冲区中的数据刷新出来。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;标准库函数&quot;&gt;&lt;a href=&quot;#标准库函数&quot; class=&quot;headerlink&quot; title=&quot;标准库函数&quot;&gt;&lt;/a&gt;标准库函数&lt;/h1&gt;&lt;h2 id=&quot;fprintf-输出到流中&quot;&gt;&lt;a</summary>
        
      
    
    
    
    <category term="language" scheme="https://www.oikiou.top/categories/language/"/>
    
    
    <category term="C/C++" scheme="https://www.oikiou.top/tags/C-C/"/>
    
    <category term="C" scheme="https://www.oikiou.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>MS-DOS</title>
    <link href="https://www.oikiou.top/2022/ddff0c71/"/>
    <id>https://www.oikiou.top/2022/ddff0c71/</id>
    <published>2022-08-21T14:57:15.000Z</published>
    <updated>2022-09-10T05:20:07.414Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MS-DOS"><a href="#MS-DOS" class="headerlink" title="MS-DOS"></a>MS-DOS</h1><p><strong>CMD(windows-commands)</strong></p><p><a href="https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/windows-commands">Windowscommands</a></p><p>在cmd内<code>/?</code>即可获得帮助信息</p><h2 id="FOR"><a href="#FOR" class="headerlink" title="FOR"></a>FOR</h2><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs tex">对一组文件中的每一个文件执行某个特定命令。<br><br>FOR <span class="hljs-comment">%variable IN (set) DO command [command-parameters]</span><br><br>  <span class="hljs-comment">%variable  指定一个单一字母可替换的参数。</span><br>  (set)      指定一个或一组文件。可以使用通配符。<br>  command    指定对每个文件执行的命令。<br>  command-parameters <br>             为特定命令指定参数或命令行开关。<br><br>在批处理程序中使用 FOR 命令时，指定变量请使用 <span class="hljs-comment">%%variable</span><br>而不要用 <span class="hljs-comment">%variable。变量名称是区分大小写的，所以 %i 不同于 %I.</span><br><br>如果启用命令扩展，则会支持下列 FOR 命令的其他格式:<br><br>FOR /D <span class="hljs-comment">%variable IN (set) DO command [command-parameters]</span><br><br>    如果集中包含通配符，则指定与目录名匹配，而不与文件名匹配。<br><br>FOR /R [[drive:]path] <span class="hljs-comment">%variable IN (set) DO command [command-parameters]</span><br><br>    检查以 [drive:]path 为根的目录树，指向每个目录中的 FOR 语句。<br>    如果在 /R 后没有指定目录规范，则使用当前目录。如果集仅为一个单点(.)字符，<br>    则枚举该目录树。<br><br>FOR /L <span class="hljs-comment">%variable IN (start,step,end) DO command [command-parameters]</span><br><br>    该集表示以增量形式从开始到结束的一个数字序列。因此，(1,1,5)将产生序列<br>    1 2 3 4 5，(5,-1,1)将产生序列(5 4 3 2 1)<br><br>FOR /F [&quot;options&quot;] <span class="hljs-comment">%variable IN (file-set) DO command [command-parameters]</span><br>FOR /F [&quot;options&quot;] <span class="hljs-comment">%variable IN (&quot;string&quot;) DO command [command-parameters]</span><br>FOR /F [&quot;options&quot;] <span class="hljs-comment">%variable IN (&#x27;command&#x27;) DO command [command-parameters]</span><br><br>    或者，如果有 usebackq 选项:<br><br>FOR /F [&quot;options&quot;] <span class="hljs-comment">%variable IN (file-set) DO command [command-parameters]</span><br>FOR /F [&quot;options&quot;] <span class="hljs-comment">%variable IN (&quot;string&quot;) DO command [command-parameters]</span><br>FOR /F [&quot;options&quot;] <span class="hljs-comment">%variable IN (&#x27;command&#x27;) DO command [command-parameters]</span><br><br>    fileset 为一个或多个文件名。继续到 fileset 中的下一个文件之前，<br>    每份文件都被打开、读取并经过处理。处理包括读取文件，将其分成一行行的文字，<br>    然后将每行解析成零或更多的符号。然后用已找到的符号字符串变量值调用 For 循环。<br>    以默认方式，/F 通过每个文件的每一行中分开的第一个空白符号。跳过空白行。<br>    你可通过指定可选 &quot;options&quot; 参数替代默认解析操作。这个带引号的字符串包括一个<br>    或多个指定不同解析选项的关键字。这些关键字为:<br><br>        eol=c           - 指一个行注释字符的结尾(就一个)<br>        skip=n          - 指在文件开始时忽略的行数。<br>        delims=xxx      - 指分隔符集。这个替换了空格和制表符的<br>                          默认分隔符集。<br>        tokens=x,y,m-n  - 指每行的哪一个符号被传递到每个迭代<br>                          的 for 本身。这会导致额外变量名称的分配。m-n<br>                          格式为一个范围。通过 nth 符号指定 mth。如果<br>                          符号字符串中的最后一个字符星号，<br>                          那么额外的变量将在最后一个符号解析之后<br>                          分配并接受行的保留文本。<br>        usebackq        - 指定新语法已在下类情况中使用:<br>                          在作为命令执行一个后引号的字符串并且一个单<br>                          引号字符为文字字符串命令并允许在 file-set<br>                          中使用双引号扩起文件名称。<br><br>    某些范例可能有助:<br><br>FOR /F &quot;eol=; tokens=2,3* delims=, &quot; <span class="hljs-comment">%i in (myfile.txt) do @echo %i %j %k</span><br><br>    会分析 myfile.txt 中的每一行，忽略以分号打头的那些行，将<br>    每行中的第二个和第三个符号传递给 for 函数体，用逗号和/或<br>    空格分隔符号。请注意，此 for 函数体的语句引用 <span class="hljs-comment">%i 来</span><br>    获得第二个符号，引用 <span class="hljs-comment">%j 来获得第三个符号，引用 %k</span><br>    来获得第三个符号后的所有剩余符号。对于带有空格的文件<br>    名，你需要用双引号将文件名括起来。为了用这种方式来使<br>    用双引号，还需要使用 usebackq 选项，否则，双引号会<br>    被理解成是用作定义某个要分析的字符串的。<br><br>    <span class="hljs-comment">%i 在 for 语句中显式声明，%j 和 %k 是通过</span><br>    tokens= 选项隐式声明的。可以通过 tokens= 一行<br>    指定最多 26 个符号，只要不试图声明一个高于字母 &quot;z&quot; 或<br>    &quot;Z&quot; 的变量。请记住，FOR 变量是单一字母、分大小写和全局的变量；<br>    而且，不能同时使用超过 52 个。<br><br>    还可以在相邻字符串上使用 FOR /F 分析逻辑，方法是，<br>    用单引号将括号之间的 file-set 括起来。这样，该字符<br>    串会被当作一个文件中的一个单一输入行进行解析。<br><br>    最后，可以用 FOR /F 命令来分析命令的输出。方法是，将<br>    括号之间的 file-set 变成一个反括字符串。该字符串会<br>    被当作命令行，传递到一个子 CMD.EXE，其输出会被捕获到<br>    内存中，并被当作文件分析。如以下例子所示:<br><br>      FOR /F &quot;usebackq delims==&quot; <span class="hljs-comment">%i IN (`set`) DO @echo %i</span><br><br>    会枚举当前环境中的环境变量名称。<br><br>另外，FOR 变量参照的替换已被增强。你现在可以使用下列<br>选项语法:<br><br>     <span class="hljs-comment">%~I          - 删除任何引号(&quot;)，扩展 %I</span><br>     <span class="hljs-comment">%~fI        - 将 %I 扩展到一个完全合格的路径名</span><br>     <span class="hljs-comment">%~dI        - 仅将 %I 扩展到一个驱动器号</span><br>     <span class="hljs-comment">%~pI        - 仅将 %I 扩展到一个路径</span><br>     <span class="hljs-comment">%~nI        - 仅将 %I 扩展到一个文件名</span><br>     <span class="hljs-comment">%~xI        - 仅将 %I 扩展到一个文件扩展名</span><br>     <span class="hljs-comment">%~sI        - 扩展的路径只含有短名</span><br>     <span class="hljs-comment">%~aI        - 将 %I 扩展到文件的文件属性</span><br>     <span class="hljs-comment">%~tI        - 将 %I 扩展到文件的日期/时间</span><br>     <span class="hljs-comment">%~zI        - 将 %I 扩展到文件的大小</span><br>     <span class="hljs-comment">%~$PATH:I   - 查找列在路径环境变量的目录，并将 %I 扩展</span><br>                   到找到的第一个完全合格的名称。如果环境变量名<br>                   未被定义，或者没有找到文件，此组合键会扩展到<br>                   空字符串<br><br>可以组合修饰符来得到多重结果:<br><br>     <span class="hljs-comment">%~dpI       - 仅将 %I 扩展到一个驱动器号和路径</span><br>     <span class="hljs-comment">%~nxI       - 仅将 %I 扩展到一个文件名和扩展名</span><br>     <span class="hljs-comment">%~fsI       - 仅将 %I 扩展到一个带有短名的完整路径名</span><br>     <span class="hljs-comment">%~dp$PATH:I - 搜索列在路径环境变量的目录，并将 %I 扩展</span><br>                   到找到的第一个驱动器号和路径。<br>     <span class="hljs-comment">%~ftzaI     - 将 %I 扩展到类似输出线路的 DIR</span><br><br>在以上例子中，<span class="hljs-comment">%I 和 PATH 可用其他有效数值代替。%~ 语法</span><br>用一个有效的 FOR 变量名终止。选取类似 <span class="hljs-comment">%I 的大写变量名</span><br>比较易读，而且避免与不分大小写的组合键混淆。<br></code></pre></td></tr></table></figure><h2 id="dir"><a href="#dir" class="headerlink" title="dir"></a>dir</h2><p>列出文件</p><h2 id="cls"><a href="#cls" class="headerlink" title="cls"></a>cls</h2><p>清屏</p><h1 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE"></a>NOTE</h1><h2 id="mklinkC盘程序搬家"><a href="#mklinkC盘程序搬家" class="headerlink" title="mklinkC盘程序搬家"></a>mklinkC盘程序搬家</h2><p>命令参数</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">mklink<span class="hljs-string">[[/d]|[/h]|[/j]]</span>&lt;Link&gt;&lt;Target&gt;<br></code></pre></td></tr></table></figure><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>&#x2F;d</td><td>创建目录符号链接。默认情况下，mklink会创建文件符号链接。</td></tr><tr><td>&#x2F;H</td><td>创建硬链接而不是符号链接。</td></tr><tr><td>&#x2F;J</td><td>创建目录连接。</td></tr><tr><td>&lt;链接&gt;</td><td>指定正在创建的符号链接的名称。</td></tr><tr><td>&lt;目标&gt;</td><td>指定新符号链接引用的路径（相对或绝对）。</td></tr><tr><td>&#x2F;？</td><td>在命令提示符下显示帮助。</td></tr></tbody></table>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;MS-DOS&quot;&gt;&lt;a href=&quot;#MS-DOS&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="language" scheme="https://www.oikiou.top/categories/language/"/>
    
    
    <category term="Windows" scheme="https://www.oikiou.top/tags/Windows/"/>
    
    <category term="MS-DOS" scheme="https://www.oikiou.top/tags/MS-DOS/"/>
    
  </entry>
  
  <entry>
    <title>Python学习笔记</title>
    <link href="https://www.oikiou.top/2022/297a89d9/"/>
    <id>https://www.oikiou.top/2022/297a89d9/</id>
    <published>2022-08-21T14:57:15.000Z</published>
    <updated>2022-09-10T05:20:07.415Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h1><p>Python学习笔记</p><h1 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;第一行\n第二行&#x27;</span>)<br><br><br><span class="hljs-built_in">print</span>(a + <span class="hljs-string">&#x27; &#x27;</span> + b + <span class="hljs-string">&#x27; %d %d&#x27;</span>%(c,d))//连字符<br></code></pre></td></tr></table></figure><h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><h3 id="基本格式化"><a href="#基本格式化" class="headerlink" title="基本格式化"></a>基本格式化</h3><p>在Python中，采用的格式化方式和C语言是一致的，用%实现，举例如下</p><ul><li>单个</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;Hello, %s&#x27;</span> % <span class="hljs-string">&#x27;world&#x27;</span><br><span class="hljs-string">&#x27;Hello, world&#x27;</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>k=<span class="hljs-number">2</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;big&#x27;</span>, k)<br><span class="hljs-string">&#x27;big 2&#x27;</span><br></code></pre></td></tr></table></figure><ul><li><p>多个</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;Hi, %s, you have $%d.&#x27;</span> % (<span class="hljs-string">&#x27;Michael&#x27;</span>, <span class="hljs-number">1000000</span>)<br><span class="hljs-string">&#x27;Hi, Michael, you have $1000000.&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>如果你不太确定应该用什么，%s永远起作用，它会把任何数据类型转换为字符串</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;Age: %s. Gender: %s&#x27;</span> % (<span class="hljs-number">25</span>, <span class="hljs-literal">True</span>)<br><span class="hljs-string">&#x27;Age: 25. Gender: True&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="format-格式化"><a href="#format-格式化" class="headerlink" title="format 格式化"></a>format 格式化</h3><p>format()它会用传入的参数依次替换字符串内的占位符{0}、{1}……</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;Hello, &#123;0&#125;, 成绩提升了 &#123;1:.1f&#125;%&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-number">17.125</span>)<br><span class="hljs-string">&#x27;Hello, 小明, 成绩提升了 17.1%&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="字符转义"><a href="#字符转义" class="headerlink" title="字符转义"></a>字符转义</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#如果字符串里面有很多字符都需要转义，就需要加很多\，为了简化，Python还允许用``r&#x27;&#x27;表示&#x27;&#x27;``内部的字符串默认不转义</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\\\t\\&#x27;</span>)<br>\       \<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-string">r&#x27;\\\t\\&#x27;</span>)<br>\\\t\\<br><br><br><span class="hljs-comment">#如果字符串内部有很多换行，用\n写在一行里不好阅读，为了简化，Python允许用&#x27;&#x27;&#x27;...&#x27;&#x27;&#x27;的格式表示多行内容，可以自己试试：</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#x27;&#x27;line1</span><br><span class="hljs-string"><span class="hljs-meta">... </span>line2</span><br><span class="hljs-string"><span class="hljs-meta">... </span>line3&#x27;&#x27;&#x27;</span>)<br>line1<br>line2<br>line3<br></code></pre></td></tr></table></figure><h2 id="显示字符串的前部分长度"><a href="#显示字符串的前部分长度" class="headerlink" title="显示字符串的前部分长度"></a>显示字符串的前部分长度</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(pi_string[:<span class="hljs-number">52</span>] + <span class="hljs-string">&quot;...&quot;</span>)<br><span class="hljs-comment"># 3.14159265358979323846264338327950288419716939937510...</span><br></code></pre></td></tr></table></figure><h1 id="input"><a href="#input" class="headerlink" title="input"></a>input</h1><p>幸好，<code>input()</code>可以让你显示一个字符串来提示用户，于是我们把代码改成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;please enter your name: &#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;hello,&#x27;</span>, name)<br></code></pre></td></tr></table></figure><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 这是一段 行注释</span><br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">这是一段 段注释</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h1 id="数据类型-和-算数运算符"><a href="#数据类型-和-算数运算符" class="headerlink" title="数据类型 和 算数运算符"></a>数据类型 和 算数运算符</h1><p>整数、浮点数、字符串、布尔型（True、False（注意大小写））、空值</p><p>所谓常量就是不能变的变量，比如常用的数学常数π就是一个常量。在Python中，通常用全部大写的变量名表示，但是不能保证其不被改变</p><p>空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">+</td><td align="left">加 - 两个对象相加</td><td align="left">a + b 输出结果 30</td></tr><tr><td align="left">-</td><td align="left">减 - 得到负数或是一个数减去另一个数</td><td align="left">a - b 输出结果 -10</td></tr><tr><td align="left">*</td><td align="left">乘 - 两个数相乘或是返回一个被重复若干次的字符串</td><td align="left">a * b 输出结果 200</td></tr><tr><td align="left">&#x2F;</td><td align="left">除 - x除以y</td><td align="left">b &#x2F; a 输出结果 2</td></tr><tr><td align="left">%</td><td align="left">取模 - 返回除法的余数</td><td align="left">b % a 输出结果 0</td></tr><tr><td align="left">**</td><td align="left">幂 - 返回x的y次幂</td><td align="left">a**b 为10的20次方， 输出结果 100000000000000000000</td></tr><tr><td align="left">&#x2F;&#x2F;</td><td align="left">取整除 - 返回商的整数部分（<strong>向下取整</strong>）</td><td align="left"><code>&gt;&gt;&gt; 9//2 = 4 &gt;&gt;&gt; -9//2 = -5</code></td></tr></tbody></table><p>&#x2F;除法计算结果是浮点数</p><p>&#x2F;&#x2F;称为地板除，两个整数的除法仍然是整数（c整数除法）</p><h1 id="编码（数据转换）"><a href="#编码（数据转换）" class="headerlink" title="编码（数据转换）"></a>编码（数据转换）</h1><p>ord()函数获取字符的整数表示</p><p>&gt;&gt;&gt; ord(‘中’)</p><p>20013</p><p>chr()函数把编码转换为对应的字符</p><p>&gt;&gt;&gt; chr(25991)</p><p>‘文’</p><p>str通过encode()可以编码为bytes</p><p>&gt;&gt;&gt; ‘ABC’.encode(‘ascii’)</p><p>b’ABC’</p><p>&gt;&gt;&gt; ‘中文’.encode(‘utf-8’)</p><p>b’\xe4\xb8\xad\xe6\x96\x87’</p><p>要把bytes变为str，就需要用decode()</p><p>&gt;&gt;&gt; b’ABC’.decode(‘ascii’)</p><p>‘ABC’</p><p>要计算str包含多少个字符，可以用len()函数</p><p>&gt;&gt;&gt; len(‘ABC’)</p><p>3</p><p>&gt;&gt;&gt; len(‘中文’)</p><p>2</p><p>len()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数</p><p>&gt;&gt;&gt; len(b’ABC’)</p><p>3</p><p>&gt;&gt;&gt; len(b’\xe4\xb8\xad\xe6\x96\x87’)</p><p>6</p><p>&gt;&gt;&gt; len(‘中文’.encode(‘utf-8’))</p><p>6</p><hr><p>‘ABC’和b’ABC’，</p><p>前者是str，在内存中以Unicode表示，一个字符对应若干个字节</p><p>后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节</p><h1 id="List列表（类似数组）"><a href="#List列表（类似数组）" class="headerlink" title="List列表（类似数组）"></a>List列表（类似数组）</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">s = [<span class="hljs-number">0</span>]*<span class="hljs-number">10</span><span class="hljs-comment">#10个0</span><br>[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br><br>s = [<span class="hljs-string">&#x27;hello&#x27;</span>]*<span class="hljs-number">3</span>    <span class="hljs-comment">#10个&#x27;hello&#x27;</span><br>[<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-string">&#x27;hello&#x27;</span>]<br><br>s = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>))<span class="hljs-comment">#10个 从0到10</span><br>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]<br><br></code></pre></td></tr></table></figure><hr><p>Python内置的一种数据类型是list。list是一种有序的集合，可以随时添加和删除其中的元素。</p><p>&gt;&gt;&gt; classmates &#x3D; [‘Jack’, 180, 1.69]</p><p>&gt;&gt;&gt; classmates</p><p>[‘Jack’, 180, 1.69]</p><hr><p>如果要取最后一个元素，除了计算索引位置外，还可以用-1做索引，直接获取最后一个元素：</p><p>&gt;&gt;&gt; classmates[-1]</p><p>‘Tracy’</p><hr><p>list是一个可变的有序表，所以，可以往list中追加元素到末尾：</p><p>&gt;&gt;&gt; classmates.append(‘Adam’)</p><p>&gt;&gt;&gt; classmates</p><p>[‘Michael’, ‘Bob’, ‘Tracy’, ‘Adam’]</p><p>也可以把元素插入到指定的位置，比如索引号为1的位置：</p><p>&gt;&gt;&gt; classmates.insert(1, ‘Jack’)</p><p>&gt;&gt;&gt; classmates</p><p>[‘Michael’, ‘Jack’, ‘Bob’, ‘Tracy’, ‘Adam’]</p><p>要删除list末尾的元素，用pop()方法：</p><p>&gt;&gt;&gt; classmates.pop()</p><p>‘Adam’</p><p>&gt;&gt;&gt; classmates</p><p>[‘Michael’, ‘Jack’, ‘Bob’, ‘Tracy’]</p><p>要删除指定位置的元素，用pop(i)方法，其中i是索引位置：</p><p>&gt;&gt;&gt; classmates.pop(1)</p><p>‘Jack’</p><p>&gt;&gt;&gt; classmates</p><p>[‘Michael’, ‘Bob’, ‘Tracy’]</p><hr><p>-———————————————————————————————————————</p><p>list元素也可以是另一个list，比如：</p><p>&gt;&gt;&gt; s &#x3D; [‘python’, ‘java’, [‘asp’, ‘php’], ‘scheme’]</p><p>&gt;&gt;&gt; len(s)</p><p>4</p><p>要注意s只有4个元素，其中s[2]又是一个list，如果拆开写就更容易理解了</p><p>&gt;&gt;&gt; p &#x3D; [‘asp’, ‘php’]</p><p>&gt;&gt;&gt; s &#x3D; [‘python’, ‘java’, p, ‘scheme’]</p><p>要访问’php’可以写p[1]或者s[2][1]，因此s可以看成是一个二维数组</p><h1 id="Tuple元组（静态数组）"><a href="#Tuple元组（静态数组）" class="headerlink" title="Tuple元组（静态数组）"></a>Tuple元组（静态数组）</h1><p>另一种有序列表叫元组：tuple</p><p>。tuple和list非常类似，但是tuple一旦初始化就不能修改</p><p>&gt;&gt;&gt; classmates &#x3D; (‘Michael’, ‘Bob’, ‘Tracy’)</p><p>要定义一个只有1个元素的tuple，如果你这么定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>t = (<span class="hljs-number">1</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>t<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>定义的不是tuple，是<code>1</code>这个数！这是因为括号<code>()</code>既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是<code>1</code>。</p><p>所以，只有1个元素的tuple定义时必须加一个逗号<code>,</code>，来消除歧义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>t = (<span class="hljs-number">1</span>,)<br><span class="hljs-meta">&gt;&gt;&gt; </span>t<br>(<span class="hljs-number">1</span>,)<br></code></pre></td></tr></table></figure><p>Python在显示只有1个元素的tuple时，也会加一个逗号<code>,</code>，以免你误解成数学计算意义上的括号。</p><p>最后来看一个“可变的”tuple：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>t = (<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>])<br><span class="hljs-meta">&gt;&gt;&gt; </span>t[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;X&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>t[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;Y&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>t<br>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, [<span class="hljs-string">&#x27;X&#x27;</span>, <span class="hljs-string">&#x27;Y&#x27;</span>])<br></code></pre></td></tr></table></figure><h2 id="str-replace-替换"><a href="#str-replace-替换" class="headerlink" title="str.replace 替换"></a>str.replace 替换</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>message = <span class="hljs-string">&quot;I really like dogs.&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>message.replace(<span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-string">&#x27;cat&#x27;</span>)<br><span class="hljs-string">&#x27;I really like cats.&#x27;</span><br></code></pre></td></tr></table></figure><h1 id="if-、-for-、-while-、-range"><a href="#if-、-for-、-while-、-range" class="headerlink" title="if 、 for 、 while 、 range"></a>if 、 for 、 while 、 range</h1><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><p><strong>变体</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">ii = <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> ss == <span class="hljs-number">2</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br><br><span class="hljs-comment">#当ss == 2时 ii=1 否则 ii=0</span><br></code></pre></td></tr></table></figure><p>if age &gt;&#x3D; 18:</p><p>​    print(‘adult’)</p><p>else:</p><p>​    print(‘teenager’)</p><p>age &#x3D; 3</p><p>if age &gt;&#x3D; 18:</p><p>​    print(‘adult’)</p><p>elif age &gt;&#x3D; 6:</p><p>​    print(‘teenager’)</p><p>else:</p><p>​    print(‘kid’)</p><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p>所以for x in …循环就是把每个元素代入变量x，然后执行缩进块的语句。</p><p>再比如我们想计算1-10的整数之和，可以用一个sum变量做累加：</p><p>sum &#x3D; 0</p><p>for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]:</p><p>​    sum &#x3D; sum + x</p><p>print(sum)</p><hr><p>sum &#x3D; 0</p><p>for x in  range(101):</p><p>​    sum &#x3D; sum + x</p><p>print(sum)</p><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><p>while循环</p><p>sum &#x3D; 0</p><p>n &#x3D; 99</p><p>while n &gt; 0:</p><p>​    sum &#x3D; sum + n</p><p>​    n &#x3D; n - 2</p><p>print(sum)</p><h2 id="range"><a href="#range" class="headerlink" title="range"></a>range</h2><p>range(start, stop[, step])    可以生成一个整数序列，</p><p>start: 计数从 start 开始。默认是从 0 开始。例如range（5）等价于range（0， 5）;</p><p>stop: 计数到 stop 结束，但不包括 stop。例如：range（0， 5） 是[0, 1, 2, 3, 4]没有5</p><p>step：步长，默认为1。例如：range（0， 5） 等价于 range(0, 5, 1)</p><p>&gt;&gt;&gt; list(range(5))</p><p>[0, 1, 2, 3, 4]</p><p>&gt;&gt;&gt;range(10)        # 从 0 开始到 10</p><p>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</p><p>&gt;&gt;&gt; range(1, 11)     # 从 1 开始到 11</p><p>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</p><p>&gt;&gt;&gt; range(0, 30, 5)  # 步长为 5</p><p>[0, 5, 10, 15, 20, 25]</p><p>&gt;&gt;&gt; range(0, 10, 3)  # 步长为 3</p><p>[0, 3, 6, 9]</p><p>&gt;&gt;&gt; range(0, -10, -1) # 负数</p><p>[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]</p><p>&gt;&gt;&gt; range(0)</p><p>[]</p><p>&gt;&gt;&gt; range(1, 0)</p><p>[]</p><h1 id="Dict（字典）"><a href="#Dict（字典）" class="headerlink" title="Dict（字典）"></a>Dict（字典）</h1><p>Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。</p><p>如果用dict实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用Python写一个dict如下：</p><p>&gt;&gt;&gt; d &#x3D; {‘Michael’: 95, ‘Bob’: 75, ‘Tracy’: 85}</p><p>&gt;&gt;&gt; d[‘Michael’]</p><p>95 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">Kw = &#123;<span class="hljs-string">&#x27;city&#x27;</span>: <span class="hljs-number">22</span>, <span class="hljs-string">&#x27;job&#x27;</span>: <span class="hljs-number">33</span>&#125;: <br><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;city&#x27;</span> <span class="hljs-keyword">in</span> kw:<br><span class="hljs-comment"># 有city参数</span><br>    <span class="hljs-keyword">pass</span><br><br><br>&gt;&gt;&gt;kw.get(<span class="hljs-string">&#x27;city&#x27;</span>)<br><span class="hljs-number">22</span><br>&gt;&gt;&gt;kw.[<span class="hljs-string">&#x27;city&#x27;</span>]<br><span class="hljs-number">22</span><br></code></pre></td></tr></table></figure><h2 id="字典内置函数-amp-方法"><a href="#字典内置函数-amp-方法" class="headerlink" title="字典内置函数&amp;方法"></a>字典内置函数&amp;方法</h2><p>Python字典包含了以下内置函数：</p><table><thead><tr><th align="left">序号</th><th align="left">函数及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-cmp.html">cmp(dict1, dict2)</a> 比较两个字典元素。</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-len.html">len(dict)</a> 计算字典元素个数，即键的总数。</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-str.html">str(dict)</a> 输出字典可打印的字符串表示。</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-type.html">type(variable)</a> 返回输入的变量类型，如果变量是字典就返回字典类型。</td></tr></tbody></table><p>Python字典包含了以下内置方法：</p><table><thead><tr><th align="left">序号</th><th align="left">函数及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-clear.html">dict.clear()</a> 删除字典内所有元素</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-copy.html">dict.copy()</a> 返回一个字典的浅复制</td></tr><tr><td align="left">3</td><td align="left">[dict.fromkeys(seq<a href="https://www.runoob.com/python/att-dictionary-fromkeys.html">, val])</a> 创建一个新字典，以序列 seq 中元素做字典的键，val 为字典所有键对应的初始值</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-get.html">dict.get(key, default&#x3D;None)</a> 返回指定键的值，如果值不在字典中返回default值</td></tr><tr><td align="left">5</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-has_key.html">dict.has_key(key)</a> 如果键在字典dict里返回true，否则返回false</td></tr><tr><td align="left">6</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-items.html">dict.items()</a> 以列表返回可遍历的(键, 值) 元组数组</td></tr><tr><td align="left">7</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-keys.html">dict.keys()</a> 以列表返回一个字典所有的键</td></tr><tr><td align="left">8</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-setdefault.html">dict.setdefault(key, default&#x3D;None)</a> 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default</td></tr><tr><td align="left">9</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-update.html">dict.update(dict2)</a> 把字典dict2的键&#x2F;值对更新到dict里</td></tr><tr><td align="left">10</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-values.html">dict.values()</a> 以列表返回字典中的所有值</td></tr><tr><td align="left">11</td><td align="left">[pop(key<a href="https://www.runoob.com/python/python-att-dictionary-pop.html">,default])</a> 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。</td></tr><tr><td align="left">12</td><td align="left"><a href="https://www.runoob.com/python/python-att-dictionary-popitem.html">popitem()</a> 返回并删除字典中的最后一对键和值。</td></tr></tbody></table><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><h2 id="基本打开输出文件"><a href="#基本打开输出文件" class="headerlink" title="基本打开输出文件"></a>基本打开输出文件</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;pi_digits.txt&#x27;</span>) <span class="hljs-keyword">as</span> file_object:<br>    contents = file_object.read()<br>    <span class="hljs-built_in">print</span>(contents)<br></code></pre></td></tr></table></figure><p>在这个程序中，第1行代码做了大量的工作。我们先来看看函数open() 。要以任何方式使用文件——哪怕仅仅是打印其内容，都得先打开 文件，这样才能访问它。函数open()接受一个参数：要打开的文件的名称。Python在当前执行的文件所在的目录中查找指定的文件。在这个示例中，当前运行的是file_reader.py，因此Python在file_reader.py所在的目录中查找pi_digits.txt。函数open() 返回一个表示文件的对象。在这里，open(‘pi_digits.txt’) 返回一个表示文件pi_digits.txt 的对象；Python将这个对象存储在我们将在后面使用的变量中。</p><p>关键字with 在不再需要访问文件后将其关闭。在这个程序中，注意到我们调用了open() ，但没有调用close() ；你也可以调用open() 和close() 来打开和关闭文件，但这样做时，如果程序存在bug，导致close() 语句未执行，文件将不会关闭。这看似微不足道，但未妥善地关闭文件可能会导致数据丢失或受损。如果在程序中过早地调用close() ，你会发现需要使用文件时它已关闭 （无法访问），这会导致更多的错误。并非在任何情况下都能轻松确定关闭文件的恰当时机，但通过使用前面所示的结构，可让Python去确定：你只管打开文件，并在需要时使用它，Python自会在合适的时候自动将其关闭。</p><h2 id="删除字符串末尾的空白-rstrip"><a href="#删除字符串末尾的空白-rstrip" class="headerlink" title="删除字符串末尾的空白 rstrip"></a>删除字符串末尾的空白 rstrip</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;pi_digits.txt&#x27;</span>) <span class="hljs-keyword">as</span> file_object:<br>    contents = file_object.read()<br>    <span class="hljs-built_in">print</span>(contents.rstrip())<br></code></pre></td></tr></table></figure><p>相比于原始文件，该输出唯一不同的地方是末尾多了一个空行。为何会多出这个空行呢？因为read() 到达文件末尾时返回一个空字符串，而将这个空字符串显示出来时就是一个空行。要删除多出来的空行，可在print 语句中使用rstrip() ：</p><p>每行左边的空格，为删除这些空格，可使用strip() </p><h2 id="逐行读取文件"><a href="#逐行读取文件" class="headerlink" title="逐行读取文件"></a>逐行读取文件</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">filename = <span class="hljs-string">&#x27;pi_digits.txt&#x27;</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename) <span class="hljs-keyword">as</span> file_object:<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> file_object:<br>    <span class="hljs-built_in">print</span>(line.rstrip())<br></code></pre></td></tr></table></figure><h2 id="文件打开模式"><a href="#文件打开模式" class="headerlink" title="文件打开模式"></a>文件打开模式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">filename = <span class="hljs-string">&#x27;programming.txt&#x27;</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> file_object:<br>    file_object.write(<span class="hljs-string">&quot;I love programming.&quot;</span>)<br></code></pre></td></tr></table></figure><p>在这个示例中，调用open() 时提供了两个实参（见❶）。第一个实参也是要打开的文件的名称；第二个实参（’w’ ）告诉Python，我们要以写入模式 打开这个文件。打开文件时，<strong>可指定读取模式 （’r’ ）、写入模式 （’w’ ）、附加模式 （’a’ ）附加到文件末尾、让你能够读取和写入文件的模式（’r+’ ）</strong>。如果你省略了模式实参，Python将以默认的只读模式打开文件。</p><h2 id="异常处理-try-except"><a href="#异常处理-try-except" class="headerlink" title="异常处理 try-except"></a>异常处理 try-except</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">filename = <span class="hljs-string">&#x27;alice.txt&#x27;</span><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename) <span class="hljs-keyword">as</span> f_obj:<br>    contents = f_obj.read()<br><span class="hljs-keyword">except</span> FileNotFoundError:<br>    msg = <span class="hljs-string">&quot;Sorry, the file &quot;</span> + filename + <span class="hljs-string">&quot; does not exist.&quot;</span><br><span class="hljs-built_in">print</span>(msg)<br></code></pre></td></tr></table></figure><p>在这个示例中，try 代码块引发FileNotFoundError 异常，因此Python找出与该错误匹配的except 代码块，并运行其中的代码。最终的结果是显示一条友好的错误消息，而不是traceback：</p><h1 id="一些方法"><a href="#一些方法" class="headerlink" title="一些方法"></a>一些方法</h1><h2 id="count"><a href="#count" class="headerlink" title=".count()"></a>.count()</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>Python count() 方法用于统计字符串里某个字符出现的次数。可选参数为在字符串搜索的开始与结束位置。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>count()方法语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span>.count(sub, start= <span class="hljs-number">0</span>,end=<span class="hljs-built_in">len</span>(string))<br></code></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li>sub – 搜索的子字符串</li><li>start – 字符串开始搜索的位置。默认为第一个字符,第一个字符索引值为0。</li><li>end – 字符串中结束搜索的位置。字符中第一个字符的索引为 0。默认为字符串的最后一个位置。</li></ul><h2 id="to-bytes"><a href="#to-bytes" class="headerlink" title=".to_bytes()"></a>.to_bytes()</h2><p>(0x12).to_bytes(10, byteorder&#x3D; ‘big’, signed &#x3D; ‘true’)</p><ul><li><p>10：表示转换后的数据占10个字节</p></li><li><p>byteorder：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;(<span class="hljs-number">0x12</span>).to_bytes(<span class="hljs-number">10</span>, byteorder = <span class="hljs-string">&#x27;big&#x27;</span>)<br><br><span class="hljs-comment">#b&#x27;\xf8\x12\x00\x00&#x27;</span><br><br>&gt;&gt;&gt;(<span class="hljs-number">0x12</span>).to_bytes(<span class="hljs-number">10</span>, byteorder = <span class="hljs-string">&#x27;little&#x27;</span>)<br><br><span class="hljs-comment">#b&#x27;\x00\x00\x12\xf8&#x27;</span><br></code></pre></td></tr></table></figure><ul><li>signed： 表示有符号和无符号</li></ul><h2 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h2><p>函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：(类似于指针？？？？准确描述应该是类似 tpyedef )</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-built_in">abs</span> <span class="hljs-comment"># 变量a指向abs函数</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a(-<span class="hljs-number">1</span>) <span class="hljs-comment"># 所以也可以通过a调用abs函数1</span><br></code></pre></td></tr></table></figure><h2 id="abs-绝对值"><a href="#abs-绝对值" class="headerlink" title="abs 绝对值"></a>abs 绝对值</h2><p>abs( x )函数 取绝对值</p><p>x – 数值表达式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">abs</span>(<span class="hljs-number">100</span>)<span class="hljs-number">100</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">abs</span>(-<span class="hljs-number">20</span>)<span class="hljs-number">20</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">abs</span>(<span class="hljs-number">12.34</span>)<span class="hljs-number">12.34</span><br></code></pre></td></tr></table></figure><h2 id="max-找平均值"><a href="#max-找平均值" class="headerlink" title="max 找平均值"></a>max 找平均值</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><br>list1 = [<span class="hljs-number">123</span>, <span class="hljs-number">568</span>, <span class="hljs-number">423</span>, <span class="hljs-number">365</span>]<br><br><span class="hljs-built_in">print</span>( np.mean(list1) )<br></code></pre></td></tr></table></figure><h2 id="max-找最大-x2F-小值"><a href="#max-找最大-x2F-小值" class="headerlink" title="max 找最大&#x2F;小值"></a>max 找最大&#x2F;小值</h2><p>max( x, y, z, …. )  可以接收任意多个参数，并返回最大的那个（可以传入list）：</p><p>x – 数值表达式。y – 数值表达式。z – 数值表达式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><span class="hljs-number">2</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">max</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">5</span>)<br><span class="hljs-number">3</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>list1 = [<span class="hljs-number">123</span>, <span class="hljs-number">568</span>, <span class="hljs-number">423</span>, <span class="hljs-number">365</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Max value element : &quot;</span>, <span class="hljs-built_in">max</span>(list1))<br>Max value element :  <span class="hljs-number">568</span><br></code></pre></td></tr></table></figure><h2 id="exal-执行字符串类型的表达式"><a href="#exal-执行字符串类型的表达式" class="headerlink" title="exal 执行字符串类型的表达式"></a>exal 执行字符串类型的表达式</h2><p>eval(expression[, globals[, locals]])函数   函数用来执行一个字符串表达式，并返回表达式的值。</p><p>expression – 表达式。</p><p>globals – 变量作用域，全局命名空间，如果被提供，则必须是一个字典对象。</p><p>locals – 变量作用域，局部命名空间，如果被提供，可以是任何映射对象。</p><p>&gt;&gt;&gt;x &#x3D; 7</p><p>&gt;&gt;&gt; eval( ‘3 * x’ )</p><p>21</p><p>&gt;&gt;&gt; eval(‘pow(2,2)’)</p><p>4</p><p>a&#x3D;eval(input(“请输入一个整数”))           #（自动类型转换）</p><h2 id="int-强制转换"><a href="#int-强制转换" class="headerlink" title="int 强制转换"></a>int 强制转换</h2><p>class int(x, base&#x3D;10)    强制转换返回整型数据。</p><p>x – 字符串或数字。base – 进制数，默认十进制。</p><p>&gt;&gt;&gt; int(‘0xa’,16)  </p><p>10  </p><p>&gt;&gt;&gt; int(‘10’,8)  </p><p>8</p><p>a&#x3D;int(input(“请输入一个整数”))             #（强制类型转换）</p><h2 id="type-判断对象类型"><a href="#type-判断对象类型" class="headerlink" title="type 判断对象类型"></a>type 判断对象类型</h2><p>首先，我们来判断对象类型，使用<code>type()</code>函数：</p><p>基本类型都可以用<code>type()</code>判断：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haskell">&gt;&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">type</span>(123)</span><br>&lt;<span class="hljs-keyword">class</span> &#x27;int&#x27;&gt;<br>&gt;&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">type</span>(&#x27;<span class="hljs-title">str&#x27;</span>)</span><br>&lt;<span class="hljs-keyword">class</span> &#x27;str&#x27;&gt;<br>&gt;&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">type</span>(<span class="hljs-type">None</span>)</span><br>&lt;<span class="hljs-class"><span class="hljs-keyword">type</span>(<span class="hljs-type">None</span>) &#x27;<span class="hljs-type">NoneType&#x27;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果一个变量指向函数或者类，也可以用<code>type()</code>判断：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(<span class="hljs-built_in">abs</span>)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;builtin_function_or_method&#x27;</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(a)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.Animal&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>但是<code>type()</code>函数返回的是什么类型呢？它返回对应的Class类型。如果我们要在<code>if</code>语句中判断，就需要比较两个变量的type类型是否相同：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">type</span>(<span class="hljs-number">123</span>)==<span class="hljs-built_in">type</span>(<span class="hljs-number">456</span>)</span><br>True<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">type</span>(<span class="hljs-number">123</span>)==<span class="hljs-built_in">int</span></span><br>True<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">type</span>(<span class="hljs-string">&#x27;abc&#x27;</span>)==<span class="hljs-built_in">type</span>(<span class="hljs-string">&#x27;123&#x27;</span>)</span><br>True<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">type</span>(<span class="hljs-string">&#x27;abc&#x27;</span>)==<span class="hljs-built_in">str</span></span><br>True<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">type</span>(<span class="hljs-string">&#x27;abc&#x27;</span>)==<span class="hljs-built_in">type</span>(<span class="hljs-number">123</span>)</span><br>False<br></code></pre></td></tr></table></figure><p>判断基本数据类型可以直接写<code>int</code>，<code>str</code>等，但如果要判断一个对象是否是函数怎么办？可以使用<code>types</code>模块中定义的常量：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">import</span> types</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fn</span>():</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    <span class="hljs-keyword">pass</span></span><br><span class="hljs-meta prompt_">...</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">type</span>(fn)==types.FunctionType</span><br>True<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">type</span>(<span class="hljs-built_in">abs</span>)==types.BuiltinFunctionType</span><br>True<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">type</span>(<span class="hljs-keyword">lambda</span> x: x)==types.LambdaType</span><br>True<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">type</span>((x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)))==types.GeneratorType</span><br>True<br></code></pre></td></tr></table></figure><h2 id="isinstance-判断类型是否相同"><a href="#isinstance-判断类型是否相同" class="headerlink" title="isinstance 判断类型是否相同"></a>isinstance 判断类型是否相同</h2><p>isinstance(object, classinfo)     如果对象的类型与参数二的类型（classinfo）相同则返回 True，否则返回 False</p><p>object – 实例对象。</p><p>classinfo – 可以是直接或间接类名、基本类型或者由它们组成的元组。</p><p>能用<code>type()</code>判断的基本类型也可以用<code>isinstance()</code>判断：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-built_in">str</span>)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(<span class="hljs-number">123</span>, <span class="hljs-built_in">int</span>)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(<span class="hljs-string">b&#x27;a&#x27;</span>, <span class="hljs-built_in">bytes</span>)<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>并且还可以判断一个变量是否是某些类型中的一种，比如下面的代码就可以判断是否是list或者tuple：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], (<span class="hljs-built_in">list</span>, <span class="hljs-built_in">tuple</span>))<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>), (<span class="hljs-built_in">list</span>, <span class="hljs-built_in">tuple</span>))<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#判断传入的参数是否正确</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(x, (<span class="hljs-built_in">int</span>, <span class="hljs-built_in">float</span>)):<br>        <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&#x27;bad operand type&#x27;</span>)<br></code></pre></td></tr></table></figure><p>isinstance() 与 type() 区别：</p><p>type() 不会认为子类是一种父类类型，不考虑继承关系。</p><p>isinstance() 会认为子类是一种父类类型，考虑继承关系。</p><p>如果要判断两个类型是否相同推荐使用 isinstance()。</p><h2 id="dir-获得对象的所有属性和方法"><a href="#dir-获得对象的所有属性和方法" class="headerlink" title="dir 获得对象的所有属性和方法"></a>dir 获得对象的所有属性和方法</h2><p>如果要获得一个对象的所有属性和方法，可以使用<code>dir()</code>函数，它返回一个包含字符串的list，比如，获得一个str对象的所有属性和方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">dir</span>(<span class="hljs-string">&#x27;ABC&#x27;</span>)<br>[<span class="hljs-string">&#x27;__add__&#x27;</span>, <span class="hljs-string">&#x27;__class__&#x27;</span>,..., <span class="hljs-string">&#x27;__subclasshook__&#x27;</span>, <span class="hljs-string">&#x27;capitalize&#x27;</span>, <span class="hljs-string">&#x27;casefold&#x27;</span>,..., <span class="hljs-string">&#x27;zfill&#x27;</span>]<br></code></pre></td></tr></table></figure><p>类似<code>__xxx__</code>的属性和方法在Python中都是有特殊用途的，比如<code>__len__</code>方法返回长度。在Python中，如果你调用<code>len()</code>函数试图获取一个对象的长度，实际上，在<code>len()</code>函数内部，它自动去调用该对象的<code>__len__()</code>方法，所以，下面的代码是等价的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">len</span>(<span class="hljs-string">&#x27;ABC&#x27;</span>)<br><span class="hljs-number">3</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;ABC&#x27;</span>.__len__()<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h2 id="二次三次方根"><a href="#二次三次方根" class="headerlink" title="二次三次方根"></a>二次三次方根</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">9</span>*<span class="hljs-number">9</span><br>== <span class="hljs-number">9</span>**<span class="hljs-number">2</span><br><br><span class="hljs-number">9</span>*<span class="hljs-number">9</span>*<span class="hljs-number">9</span><br>== <span class="hljs-number">9</span>**<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h1 id="math模块的一些方法"><a href="#math模块的一些方法" class="headerlink" title="math模块的一些方法"></a>math模块的一些方法</h1><h2 id="math-modf-分离小数和整数部分"><a href="#math-modf-分离小数和整数部分" class="headerlink" title="math.modf(分离小数和整数部分)"></a>math.modf(分离小数和整数部分)</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>modf() 方法返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>以下展示了使用 modf() 方法的实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math   <span class="hljs-comment"># This will import math module</span><br><br><span class="hljs-built_in">print</span>( math.modf(-<span class="hljs-number">100.12</span>) )<br><span class="hljs-built_in">print</span>( math.modf(-<span class="hljs-number">100.12</span>)[<span class="hljs-number">0</span>] )<br></code></pre></td></tr></table></figure><p>以上实例运行后输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">(-<span class="hljs-number">0.12000000000000455</span>, -<span class="hljs-number">100.0</span>)<br>-<span class="hljs-number">0.12000000000000455</span><br></code></pre></td></tr></table></figure><h1 id="用户自定义函数"><a href="#用户自定义函数" class="headerlink" title="用户自定义函数"></a>用户自定义函数</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_abs</span>(<span class="hljs-params">x</span>):<br><br>   <span class="hljs-keyword">if</span> x &gt;= <span class="hljs-number">0</span>:<br><br>      <span class="hljs-keyword">return</span> x<br><br>   <span class="hljs-keyword">else</span>:<br><br>       <span class="hljs-keyword">return</span> -x<br></code></pre></td></tr></table></figure><p>（导入其他文件内的函数的方法）如果你已经把<code>my_abs()</code>的函数定义保存为<code>abs.py</code>文件了，那么，可以在该文件的当前目录下启动Python解释器，用<code>from abs import my_abs</code>来导入<code>my_abs()</code>函数，注意<code>abs</code>是文件名（不含<code>.py</code>扩展名）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> <span class="hljs-built_in">abs</span> <span class="hljs-keyword">import</span> my_abs<br><span class="hljs-meta">&gt;&gt;&gt; </span>my_abs(-<span class="hljs-number">9</span>) <br><span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><h2 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#pass语句，实际上pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来。但是缺少了pass，代码运行就会有语法错误。</span><br><span class="hljs-keyword">if</span> age &gt;= <span class="hljs-number">18</span>:<br><span class="hljs-keyword">pass</span><br> <br>函数返回多个值<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_two</span>(<span class="hljs-params">x, y</span>):<br>    x = x + <span class="hljs-number">1</span><br>    y = y + <span class="hljs-number">2</span><br><span class="hljs-keyword">return</span> x, y<br> <br><span class="hljs-meta">&gt;&gt;&gt; </span>x = y = <span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>x, y = add_two(x,y)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(x, y)<br><span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>r = add_two(x,y)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(r)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>其实返回值是一个tuple(静态数组)！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。</p><p>函数的传入参数<br>函数传入list要特别小心，函数内的修改会影响其本身，类似C中的指针对list产生了修改。<br>关键字传值(带**的传值)传入的是值，不会影响原来的内容。</p><h2 id="函数的输入"><a href="#函数的输入" class="headerlink" title="函数的输入"></a>函数的输入</h2><h3 id="函数的默认参数"><a href="#函数的默认参数" class="headerlink" title="函数的默认参数"></a>函数的默认参数</h3><p>默认参数。由于我们经常计算x2，所以，完全可以把第二个参数n的默认值设定为2：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">power</span>(<span class="hljs-params">x, n=<span class="hljs-number">2</span></span>):<br>    s = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> n &gt; <span class="hljs-number">0</span>:<br>        n = n - <span class="hljs-number">1</span><br>        s = s * x<br>    <span class="hljs-keyword">return</span> s<br></code></pre></td></tr></table></figure><p>调用时可以 power(5) 直接计算5的2次方，也可以power(5,3)计算5的3次方。即默认参数可以传入也可以不传入。<br>定义默认参数要牢记一点：默认参数必须指向不变对象！</p><p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431752945034eb82ac80a3e64b9bb4929b16eeed1eb9000">具体可以点击此处参考</a></p><h3 id="输入可变长变量"><a href="#输入可变长变量" class="headerlink" title="输入可变长变量"></a>输入可变长变量</h3><p>可变长度的传入变量，加了星号（*）的变量名会存放所有未命名的变量参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">printinfo</span>(<span class="hljs-params"> *vartuple </span>):<br>   <span class="hljs-string">&quot;打印任何传入的参数&quot;</span><br>   <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;输出: &quot;</span><br>   <span class="hljs-keyword">for</span> var <span class="hljs-keyword">in</span> vartuple:<br>      <span class="hljs-built_in">print</span> var<br>   <span class="hljs-keyword">return</span>;<br><br> <br><span class="hljs-comment"># 调用printinfo 函数</span><br>printinfo( <span class="hljs-number">10</span> );<br>printinfo( <span class="hljs-number">70</span>, <span class="hljs-number">60</span>, <span class="hljs-number">50</span> );<br></code></pre></td></tr></table></figure><h3 id="关键字参数（字典-dict-参数）"><a href="#关键字参数（字典-dict-参数）" class="headerlink" title="关键字参数（字典(dict)参数）"></a>关键字参数（字典(dict)参数）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">person</span>(<span class="hljs-params">name, age, **kw</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;name:&#x27;</span>, name, <span class="hljs-string">&#x27;age:&#x27;</span>, age, <span class="hljs-string">&#x27;other:&#x27;</span>, kw)<br> <br><span class="hljs-meta">&gt;&gt;&gt; </span>person(<span class="hljs-string">&#x27;Michael&#x27;</span>, <span class="hljs-number">30</span>)<br>name: Michael age: <span class="hljs-number">30</span> other: &#123;&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>person(<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-number">35</span>, city=<span class="hljs-string">&#x27;Beijing&#x27;</span>)<br>name: Bob age: <span class="hljs-number">35</span> other: &#123;<span class="hljs-string">&#x27;city&#x27;</span>: <span class="hljs-string">&#x27;Beijing&#x27;</span>&#125;<br><span class="hljs-comment">#如果函数内使用了某个关键字参数，但调用时没有传入，代码会有异常</span><br><span class="hljs-comment">#如果要限制只能传指定名字的参数，则可以使用命名关键字参数</span><br></code></pre></td></tr></table></figure><h3 id="命名关键词参数"><a href="#命名关键词参数" class="headerlink" title="命名关键词参数"></a>命名关键词参数</h3> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#命名关键字参数，是对关键字参数方式的进一步约束，更安全了</span><br><span class="hljs-comment">#定义需要一个*号作为分隔符，*后面的参数表示只能传递该名字的参数</span><br><span class="hljs-comment">#如下表示两个位置参数，还有两个名为city和job的关键字参数，调用时传其它名字会报错</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">person</span>(<span class="hljs-params">name, age, *, city, job</span>):<br>    <span class="hljs-built_in">print</span>(name, age, city, job)<br></code></pre></td></tr></table></figure><p>和关键字参数<code>**kw</code>不同，命名关键字参数需要一个特殊分隔符<code>*</code>，<code>*</code>后面的参数被视为命名关键字参数。</p><p>调用方式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>person(<span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-number">24</span>, city=<span class="hljs-string">&#x27;Beijing&#x27;</span>, job=<span class="hljs-string">&#x27;Engineer&#x27;</span>)<br>Jack <span class="hljs-number">24</span> Beijing Engineer<br></code></pre></td></tr></table></figure><p>添加缺省值，从而简化调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">person</span>(<span class="hljs-params">name, age, *, city=<span class="hljs-string">&#x27;Beijing&#x27;</span>, job</span>):<br>    <span class="hljs-built_in">print</span>(name, age, city, job)<br></code></pre></td></tr></table></figure><p>由于命名关键字参数<code>city</code>具有默认值，调用时，可不传入<code>city</code>参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>person(<span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-number">24</span>, job=<span class="hljs-string">&#x27;Engineer&#x27;</span>)<br>Jack <span class="hljs-number">24</span> Beijing Engineer<br></code></pre></td></tr></table></figure><h1 id="匿名函数lambda"><a href="#匿名函数lambda" class="headerlink" title="匿名函数lambda"></a>匿名函数lambda</h1><p>python 使用 lambda 来创建匿名函数。</p><ul><li>lambda只是一个表达式，函数体比def简单很多。</li><li>lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。</li><li>lambda函数拥有自己的命名空间，且不能访问自有参数列表之外或全局命名空间里的参数。</li><li>虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。</li></ul><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p>lambda函数的语法只包含一个语句，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">lambda</span> [arg1 [,arg2,.....argn]]:expression<br></code></pre></td></tr></table></figure><p>如下实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 可写函数说明</span><br><span class="hljs-built_in">sum</span> = <span class="hljs-keyword">lambda</span> arg1, arg2: arg1 + arg2;<br> <br><span class="hljs-comment"># 调用sum函数</span><br><span class="hljs-built_in">print</span>( <span class="hljs-string">&quot;相加后的值为 : &quot;</span>, <span class="hljs-built_in">sum</span>( <span class="hljs-number">10</span>, <span class="hljs-number">20</span> ))<br><span class="hljs-built_in">print</span>( <span class="hljs-string">&quot;相加后的值为 : &quot;</span>, <span class="hljs-built_in">sum</span>( <span class="hljs-number">20</span>, <span class="hljs-number">20</span> ))<br></code></pre></td></tr></table></figure><h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><h2 id="面向过程-和-面向对象的对比"><a href="#面向过程-和-面向对象的对比" class="headerlink" title="面向过程 和 面向对象的对比"></a>面向过程 和 面向对象的对比</h2><p>Q：存储学生的信息并打印出来</p><p><strong>面向过程</strong></p><p> 假设我们要处理学生的成绩表，为了表示一个学生的成绩，面向过程的程序可以用一个dict表示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">std1 = &#123; <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Michael&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">98</span> &#125;<br>std2 = &#123; <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">81</span> &#125;<br></code></pre></td></tr></table></figure><p>而处理学生成绩可以通过函数实现，比如打印学生的成绩：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_score</span>(<span class="hljs-params">std</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%s: %s&#x27;</span> % (std[<span class="hljs-string">&#x27;name&#x27;</span>], std[<span class="hljs-string">&#x27;score&#x27;</span>]))<br></code></pre></td></tr></table></figure><p><strong>面向对象</strong></p><p>如果采用面向对象的程序设计思想，我们首选思考的不是程序的执行流程，而是<code>Student</code>这种数据类型应该被视为一个对象，这个对象拥有<code>name</code>和<code>score</code>这两个属性（Property）。如果要打印一个学生的成绩，首先必须创建出这个学生对应的对象，然后，给对象发一个<code>print_score</code>消息，让对象自己把自己的数据打印出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, score</span>):<br>        self.name = name<br>        self.score = score<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">print_score</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%s: %s&#x27;</span> % (self.name, self.score))<br></code></pre></td></tr></table></figure><p>给对象发消息实际上就是调用对象对应的关联函数，我们称之为对象的方法（Method）。面向对象的程序写出来就像这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">bart = Student(<span class="hljs-string">&#x27;Bart Simpson&#x27;</span>, <span class="hljs-number">59</span>)<br>lisa = Student(<span class="hljs-string">&#x27;Lisa Simpson&#x27;</span>, <span class="hljs-number">87</span>)<br>bart.print_score()<br>lisa.print_score()<br></code></pre></td></tr></table></figure><h2 id="类、实例、方法和属性"><a href="#类、实例、方法和属性" class="headerlink" title="类、实例、方法和属性"></a>类、实例、方法和属性</h2><ul><li>类 Student</li><li>实例 jack</li><li>方法 print_score</li><li>属性 obj_name</li><li>增加属性 gender</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>): <span class="hljs-comment">#Student是类</span><br>    obj_name = <span class="hljs-string">&#x27;this is obj name str！&#x27;</span><span class="hljs-comment">#这个类有一个属性（类属性）</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, score</span>):  <span class="hljs-comment">#特殊方法“__init__”前后分别有两个下划线！！！</span><br>        self.name = name<br>        self.score = score<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">print_score</span>(<span class="hljs-params">self</span>):<span class="hljs-comment">#print_score 这个函数就是方法</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%s: %s&#x27;</span> % (self.name, self.score))<br>        <br>jack = Student(<span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-number">95</span>)  <span class="hljs-comment">#jack是实例</span><br>jack.gender = <span class="hljs-string">&#x27;man&#x27;</span> <span class="hljs-comment">#此处加了一个属性（实例属性）</span><br><br><span class="hljs-built_in">print</span> (<span class="hljs-string">&#x27;%s is a %s&#x27;</span> % (jack.name, jack.gender))<span class="hljs-comment">#输出 增加的实例属性</span><br><span class="hljs-built_in">print</span> (<span class="hljs-string">&#x27;%s&#x27;</span> % (jack.obj_name))<span class="hljs-comment">#输出类属性</span><br><span class="hljs-built_in">print</span> (<span class="hljs-string">&#x27;Hi,%s your score is %s&#x27;</span> % (jack.name, jack.score))<span class="hljs-comment">#输出实例的属性</span><br><span class="hljs-comment">#运行结果</span><br>Jack <span class="hljs-keyword">is</span> a man<br>this <span class="hljs-keyword">is</span> obj name <span class="hljs-built_in">str</span>！<br>Hi，Jack yours score <span class="hljs-keyword">is</span> <span class="hljs-number">95</span><br></code></pre></td></tr></table></figure><h3 id="类-实例"><a href="#类-实例" class="headerlink" title="类 实例"></a>类 实例</h3><p>类是创建实例的模板，而实例则是一个一个具体的对象，各个实例拥有的数据都互相独立，互不影响；</p><hr><p>面向对象最重要的概念就是<strong>类（Class）</strong>和<strong>实例（Instance）</strong>，必须牢记类是抽象的模板，比如Student类，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的<strong>方法</strong>，但各自的数据可能不同。</p><p>仍以Student类为例，在Python中，定义类是通过<code>class</code>关键字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>): <span class="hljs-comment">#Student是类</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, score</span>):  <span class="hljs-comment">#特殊方法“__init__”前后分别有两个下划线！！！</span><br>        self.name = name<br>        self.score = score<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">print_score</span>(<span class="hljs-params">self</span>):<span class="hljs-comment">#这就是方法</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%s: %s&#x27;</span> % (self.name, self.score))<br></code></pre></td></tr></table></figure><p><code>class</code>后面紧接着是类名，即<code>Student</code>，类名通常是大写开头的单词，紧接着是<code>(object)</code>，表示该类是从哪个类继承下来的，继承的概念我们后面再讲，通常，如果没有合适的继承类，就使用<code>object</code>类，这是所有类最终都会继承的类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">jack = Student(<span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-number">95</span>)     <span class="hljs-comment">#jack是实例</span><br></code></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p><strong>方法</strong>就是与实例绑定的函数，和普通函数不同，方法可以直接访问实例的数据；</p><hr><p>面向对象编程的一个重要特点就是数据封装。在上面的<code>Student</code>类中，每个实例就拥有各自的<code>name</code>和<code>score</code>这些数据。我们可以通过函数来访问这些数据，比如打印一个学生的成绩：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_score</span>(<span class="hljs-params">std</span>):<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%s: %s&#x27;</span> % (std.name, std.score))<br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>print_score(bart)<br>Bart Simpson: <span class="hljs-number">59</span><br></code></pre></td></tr></table></figure><p>但是，既然<code>Student</code>实例本身就拥有这些数据，要访问这些数据，就没有必要从外面的函数去访问，可以直接在<code>Student</code>类的内部定义访问数据的函数，这样，就把“数据”给封装起来了。这些封装数据的函数是和<code>Student</code>类本身是关联起来的，我们称之为类的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, score</span>):<br>        self.name = name<br>        self.score = score<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">print_score</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%s: %s&#x27;</span> % (self.name, self.score))<br></code></pre></td></tr></table></figure><p>要定义一个方法，除了第一个参数是<code>self</code>外，其他和普通函数一样。要调用一个方法，只需要在实例变量上直接调用，除了<code>self</code>不用传递，其他参数正常传入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bart.print_score()<br>Bart Simpson: <span class="hljs-number">59</span><br></code></pre></td></tr></table></figure><h3 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h3><ul><li>实例增加属性</li></ul><p>类相当于一个模板，用模板（类）定义实例后，实例还可以再加其他属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>): <span class="hljs-comment">#Student是类</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, score</span>):  <span class="hljs-comment">#特殊方法“__init__”前后分别有两个下划线！！！</span><br>        self.name = name<br>        self.score = score<br><br>jack = Student(<span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-number">95</span>)<br>jack.gender = <span class="hljs-string">&#x27;man&#x27;</span> <span class="hljs-comment">#此处加了一个属性</span><br><br><br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;%s is a %s&quot;</span> % (jack.name, jack.gender))<br></code></pre></td></tr></table></figure><h2 id="访问限制-private"><a href="#访问限制-private" class="headerlink" title="访问限制 private"></a>访问限制 private</h2><p>外部无法访问，只能通过方法访问（私有变量）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, score</span>):<br>        self.__name = name<span class="hljs-comment">#变成私有变量（private）了</span><br>        self.__score = score<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">print_score</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%s: %s&#x27;</span> % (self.__name, self.__score))<br></code></pre></td></tr></table></figure><hr><p>需要注意的是，在Python中，变量名类似<code>__xxx__</code>的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用<code>__name__</code>、<code>__score__</code>这样的变量名。</p><p>有些时候，你会看到以一个下划线开头的实例变量名，比如<code>_name</code>，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。</p><p>双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问<code>__name</code>是因为Python解释器对外把<code>__name</code>变量改成了<code>_Student__name</code>，所以，仍然可以通过<code>_Student__name</code>来访问<code>__name</code>变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bart._Student__name<br><span class="hljs-string">&#x27;Bart Simpson&#x27;</span><br></code></pre></td></tr></table></figure><p>但是强烈建议你不要这么干，因为不同版本的Python解释器可能会把<code>__name</code>改成不同的变量名。</p><p>总的来说就是，Python本身没有任何机制阻止你干坏事，一切全靠自觉。</p><p>最后注意下面的这种<strong>错误写法</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bart = Student(<span class="hljs-string">&#x27;Bart Simpson&#x27;</span>, <span class="hljs-number">59</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bart.get_name()<br><span class="hljs-string">&#x27;Bart Simpson&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>bart.__name = <span class="hljs-string">&#x27;New Name&#x27;</span> <span class="hljs-comment"># 设置__name变量！</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>bart.__name<br><span class="hljs-string">&#x27;New Name&#x27;</span><br></code></pre></td></tr></table></figure><p>表面上看，外部代码“成功”地设置了<code>__name</code>变量，但实际上这个<code>__name</code>变量和class内部的<code>__name</code>变量<em>不是</em>一个变量！内部的<code>__name</code>变量已经被Python解释器自动改成了<code>_Student__name</code>，而外部代码给<code>bart</code>新增了一个<code>__name</code>变量。不信试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bart.get_name() <span class="hljs-comment"># get_name()内部返回self.__name</span><br><span class="hljs-string">&#x27;Bart Simpson&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p><strong>用组合的方式建立了类与组合的类之间的关系，它是一种‘有’的关系,比如教授有生日，教授教python课程</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BirthDate</span>:    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,year,month,day</span>):<br>        self.year=year<br>        self.month=month<br>        self.day=day<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Couse</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,name,price,period</span>):<br>        self.name=name<br>        self.price=price<br>        self.period=period<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,name,gender,birth,course</span>):<br>        self.name=name <br>        self.gender=gender<br>        self.birth=birth<br>        self.course=course<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">teach</span>(<span class="hljs-params">self</span>): <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;teaching&#x27;</span>)<br>p1=Teacher(<span class="hljs-string">&#x27;egon&#x27;</span>,<span class="hljs-string">&#x27;male&#x27;</span>, <br>            BirthDate(<span class="hljs-string">&#x27;1995&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;27&#x27;</span>), <br>            Couse(<span class="hljs-string">&#x27;python&#x27;</span>,<span class="hljs-string">&#x27;28000&#x27;</span>,<span class="hljs-string">&#x27;4 months&#x27;</span>)<br>           ) <br><br><span class="hljs-built_in">print</span>(p1.birth.year,p1.birth.month,p1.birth.day) <br><br><span class="hljs-built_in">print</span>(p1.course.name,p1.course.price,p1.course.period)<br><span class="hljs-string">&#x27;&#x27;&#x27; </span><br><span class="hljs-string">运行结果: </span><br><span class="hljs-string">1 27 </span><br><span class="hljs-string">python 28000 4 months </span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>当类之间有显著不同，并且较小的类是较大的类所需要的组件时，用组合比较好</strong></p><h2 id="继承-多态"><a href="#继承-多态" class="headerlink" title="继承 多态"></a>继承 多态</h2><ul><li>抽象：抽象即抽取类似或者说比较像的部分。是一个从具题到抽象的过程。</li><li>继承：子类继承了父类的方法和属性</li><li>派生：子类在父类方法和属性的基础上产生了新的方法和属性</li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li>建立一个新类（子类 Subclass）可以copy一份原来类（父类 基类或超类 Base class、Super class）的全部功能（方法、变量 等）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-title class_ inherited__">object</span>):<span class="hljs-comment">#父类</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Animal is running...&#x27;</span>)<br>        <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-title class_ inherited__">Animal</span>):<span class="hljs-comment">#子类</span><br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment">#运行结果</span><br>Animal <span class="hljs-keyword">is</span> running...<span class="hljs-comment">#子类有了父类的方法</span><br></code></pre></td></tr></table></figure><ul><li>当子类和父类都存在相同的<code>run()</code>方法时，我们说，子类的<code>run()</code>覆盖了父类的<code>run()</code>，在代码运行的时候，总是会调用子类的<code>run()</code>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-title class_ inherited__">object</span>):<span class="hljs-comment">#父类</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Animal is running...&#x27;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-title class_ inherited__">Animal</span>):<span class="hljs-comment">#子类</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Dog is running...&#x27;</span>)<br><br><span class="hljs-comment">#运行结果</span><br>Dog <span class="hljs-keyword">is</span> running...<span class="hljs-comment">#子类覆盖了父类的方法</span><br></code></pre></td></tr></table></figure><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p><strong>就是一个集合的概念，子类包含了父类，子类比父类范围更大，这种好处是通用性更强</strong></p><ul><li>子类继承了父类的类型，子类既是  <strong>子类类型</strong>  也是  <strong>父类类型</strong>  </li><li>传入类型设置为  父类   可以有很好的通用性</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-title class_ inherited__">object</span>):<span class="hljs-comment">#父类</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Animal is running...&#x27;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-title class_ inherited__">Animal</span>):<span class="hljs-comment">#子类</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Dog is running...&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run_twice</span>(<span class="hljs-params">animal</span>):<span class="hljs-comment">#因为传入的是 父类 所以子类父类都可以用    有很好通用性</span><br>    animal.run()<br>    animal.run()<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>run_twice(Animal())<br>Animal <span class="hljs-keyword">is</span> running...<br>Animal <span class="hljs-keyword">is</span> running...<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>run_twice(Dog())<br>Dog <span class="hljs-keyword">is</span> running...<br>Dog <span class="hljs-keyword">is</span> running...<br></code></pre></td></tr></table></figure><hr><p>要理解什么是多态，我们首先要对数据类型再作一点说明。当我们定义一个class的时候，我们实际上就定义了一种数据类型。我们定义的数据类型和Python自带的数据类型，比如str、list、dict没什么两样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-built_in">list</span>() <span class="hljs-comment"># a是list类型</span><br>b = Animal() <span class="hljs-comment"># b是Animal类型</span><br>c = Dog() <span class="hljs-comment"># c是Dog类型</span><br></code></pre></td></tr></table></figure><p>判断一个变量是否是某个类型可以用<code>isinstance()</code>判断：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(a, <span class="hljs-built_in">list</span>)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(b, Animal)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(c, Dog)<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>看来<code>a</code>、<code>b</code>、<code>c</code>确实对应着<code>list</code>、<code>Animal</code>、<code>Dog</code>这3种类型。</p><p>但是等等，试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(c, Animal)<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>看来<code>c</code>不仅仅是<code>Dog</code>，<code>c</code>还是<code>Animal</code>！</p><p>不过仔细想想，这是有道理的，因为<code>Dog</code>是从<code>Animal</code>继承下来的，当我们创建了一个<code>Dog</code>的实例<code>c</code>时，我们认为<code>c</code>的数据类型是<code>Dog</code>没错，但<code>c</code>同时也是<code>Animal</code>也没错，<code>Dog</code>本来就是<code>Animal</code>的一种！</p><p>所以，在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。但是，反过来就不行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>b = Animal()<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(b, Dog)<br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p><code>Dog</code>可以看成<code>Animal</code>，但<code>Animal</code>不可以看成<code>Dog</code>。</p><p>要理解多态的好处，我们还需要再编写一个函数，这个函数接受一个<code>Animal</code>类型的变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">run_twice</span>(<span class="hljs-params">animal</span>):<br>    animal.run()<br>    animal.run()<br></code></pre></td></tr></table></figure><p>当我们传入<code>Animal</code>的实例时，<code>run_twice()</code>就打印出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>run_twice(Animal())<br>Animal <span class="hljs-keyword">is</span> running...<br>Animal <span class="hljs-keyword">is</span> running...<br></code></pre></td></tr></table></figure><p>当我们传入<code>Dog</code>的实例时，<code>run_twice()</code>就打印出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>run_twice(Dog())<br>Dog <span class="hljs-keyword">is</span> running...<br>Dog <span class="hljs-keyword">is</span> running...<br></code></pre></td></tr></table></figure><p>当我们传入<code>Cat</code>的实例时，<code>run_twice()</code>就打印出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>run_twice(Cat())<br>Cat <span class="hljs-keyword">is</span> running...<br>Cat <span class="hljs-keyword">is</span> running...<br></code></pre></td></tr></table></figure><p>看上去没啥意思，但是仔细想想，现在，如果我们再定义一个<code>Tortoise</code>类型，也从<code>Animal</code>派生：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tortoise</span>(<span class="hljs-title class_ inherited__">Animal</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Tortoise is running slowly...&#x27;</span>)<br></code></pre></td></tr></table></figure><p>当我们调用<code>run_twice()</code>时，传入<code>Tortoise</code>的实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>run_twice(Tortoise())<br>Tortoise <span class="hljs-keyword">is</span> running slowly...<br>Tortoise <span class="hljs-keyword">is</span> running slowly...<br></code></pre></td></tr></table></figure><p>你会发现，新增一个<code>Animal</code>的子类，不必对<code>run_twice()</code>做任何修改，实际上，任何依赖<code>Animal</code>作为参数的函数或者方法都可以不加修改地正常运行，原因就在于多态。</p><p>多态的好处就是，当我们需要传入<code>Dog</code>、<code>Cat</code>、<code>Tortoise</code>……时，我们只需要接收<code>Animal</code>类型就可以了，因为<code>Dog</code>、<code>Cat</code>、<code>Tortoise</code>……都是<code>Animal</code>类型，然后，按照<code>Animal</code>类型进行操作即可。由于<code>Animal</code>类型有<code>run()</code>方法，因此，传入的任意类型，只要是<code>Animal</code>类或者子类，就会自动调用实际类型的<code>run()</code>方法，这就是多态的意思：</p><p>对于一个变量，我们只需要知道它是<code>Animal</code>类型，无需确切地知道它的子类型，就可以放心地调用<code>run()</code>方法，而具体调用的<code>run()</code>方法是作用在<code>Animal</code>、<code>Dog</code>、<code>Cat</code>还是<code>Tortoise</code>对象上，由运行时该对象的确切类型决定，这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种<code>Animal</code>的子类时，只要确保<code>run()</code>方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则：</p><p>对扩展开放：允许新增<code>Animal</code>子类；</p><p>对修改封闭：不需要修改依赖<code>Animal</code>类型的<code>run_twice()</code>等函数。</p><p>继承还可以一级一级地继承下来，就好比从爷爷到爸爸、再到儿子这样的关系。而任何类，最终都可以追溯到根类object，这些继承关系看上去就像一颗倒着的树。比如如下的继承树：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ascii">                ┌───────────────┐<br>                │    object     │<br>                └───────────────┘<br>                        │<br>           ┌────────────┴────────────┐<br>           │                         │<br>           ▼                         ▼<br>    ┌─────────────┐           ┌─────────────┐<br>    │   Animal    │           │    Plant    │<br>    └─────────────┘           └─────────────┘<br>           │                         │<br>     ┌─────┴──────┐            ┌─────┴──────┐<br>     │            │            │            │<br>     ▼            ▼            ▼            ▼<br>┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐<br>│   Dog   │  │   Cat   │  │  Tree   │  │ Flower  │<br>└─────────┘  └─────────┘  └─────────┘  └─────────┘<br></code></pre></td></tr></table></figure><h4 id="静态语言-vs-动态语言"><a href="#静态语言-vs-动态语言" class="headerlink" title="静态语言 vs 动态语言"></a>静态语言 vs 动态语言</h4><p>对于静态语言（例如Java）来说，如果需要传入<code>Animal</code>类型，则传入的对象必须是<code>Animal</code>类型或者它的子类，否则，将无法调用<code>run()</code>方法。</p><p>对于Python这样的动态语言来说，则不一定需要传入<code>Animal</code>类型。我们只需要保证传入的对象有一个<code>run()</code>方法就可以了：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Timer</span>(object):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>        print(<span class="hljs-string">&#x27;Start...&#x27;</span>)<br></code></pre></td></tr></table></figure><p>这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</p><p>Python的“file-like object“就是一种鸭子类型。对真正的文件对象，它有一个<code>read()</code>方法，返回其内容。但是，许多对象，只要有<code>read()</code>方法，都被视为“file-like object“。许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了<code>read()</code>方法的对象。</p><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p><strong>抽象类是一个特殊的类，它的特殊之处在于只能被继承，不能被实例化</strong></p><p><em>比如我们有香蕉的类，有苹果的类，有桃子的类，从这些类抽取相同的内容就是水果这个抽象的类，你吃水果时，要么是吃一个具体的香蕉，要么是吃一个具体的桃子。。。。。。你永远无法吃到一个叫做水果的东西</em></p><p><em>从实现角度来看，抽象类与普通类的不同之处在于：抽象类中有抽象方法，该类不能被实例化，只能被继承，且子类必须实现抽象方法。这一点与接口有点类似，但其实是不同的，即将揭晓答案</em></p><h2 id="经典类和新式类"><a href="#经典类和新式类" class="headerlink" title="经典类和新式类"></a>经典类和新式类</h2><p><img src="/2022/297a89d9/1610094679745.jpg" alt="1610094679745"></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Content&quot;&gt;&lt;a href=&quot;#Content&quot; class=&quot;headerlink&quot; title=&quot;Content&quot;&gt;&lt;/a&gt;Content&lt;/h1&gt;&lt;p&gt;Python学习笔记&lt;/p&gt;
&lt;h1</summary>
        
      
    
    
    
    <category term="language" scheme="https://www.oikiou.top/categories/language/"/>
    
    
    <category term="Python" scheme="https://www.oikiou.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>MicroPython</title>
    <link href="https://www.oikiou.top/2022/bf76c113/"/>
    <id>https://www.oikiou.top/2022/bf76c113/</id>
    <published>2022-08-21T14:57:15.000Z</published>
    <updated>2022-09-10T05:20:07.414Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MicroPython"><a href="#MicroPython" class="headerlink" title="MicroPython"></a>MicroPython</h1><p><a href="https://www.cirmall.com/articles/301308/p1">简单、方便、快速开发嵌入式实时系统——MicroPytho</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pyb <span class="hljs-keyword">import</span> uart<br><br><span class="hljs-keyword">from</span> pyb <span class="hljs-keyword">import</span> I2C <span class="hljs-comment">#工程师将从pyb库导入I2C</span><br><span class="hljs-comment">#这里的PYB库提供了接入到微控制器外围功能，如SPI，I2C以及UART</span><br><span class="hljs-comment">#在使用任何外设之前，工程师必须实例化外设类以创建可用于控制外设的对象。一旦外设类被初始化，工程师可以执行任何其他操作，例如在进入主应用程序循环之前验证设备是否存在，主要应用程序代码将会每秒采样一次传感器。</span><br><br>GlobalTemp = <span class="hljs-number">0.0</span><br><br>GlobalBarometer = <span class="hljs-number">0.0</span><br><br>＃初始化和实例化I2C外设<span class="hljs-number">2</span><br><br>I2C2 = I2C（<span class="hljs-number">2</span>，I2C.MASTER，波特率= <span class="hljs-number">100000</span>）<br><br>＃配置Uart1进行通信<br><br>Uart1 = pyb.UART（<span class="hljs-number">1</span>,<span class="hljs-number">115200</span>）<br><br>Uart1.init（<span class="hljs-number">115200</span>，bits = <span class="hljs-number">8</span>，parity = <span class="hljs-literal">None</span>，stop = <span class="hljs-number">1</span>）<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br><br>SampleSensor（）<br><br>pyb.delay（<span class="hljs-number">1000</span>）<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">SensorSample</span>（）：<br><br>＃读取温度数据<br><br>TempSample = I2C2.readfrom_mem（<span class="hljs-number">119</span>，<span class="hljs-number">0xFA</span>，<span class="hljs-number">3</span>）<br><br>＃读取压力数据<br><br>PressureSample = I2C2.readfrom_mem（<span class="hljs-number">119</span>，<span class="hljs-number">0xF7</span>,<span class="hljs-number">3</span>）<br><br>将样本数据转换为字符串<br><br>data =“＃，temperature =”<span class="hljs-built_in">str</span>（TempSample）+“，pressure”+ <span class="hljs-built_in">str</span>（PressureSample）+“，＃，\ n \ r”<br><br>＃将数据写入蓝牙<br><br>Uart1.write（data）<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;MicroPython&quot;&gt;&lt;a href=&quot;#MicroPython&quot; class=&quot;headerlink&quot; title=&quot;MicroPython&quot;&gt;&lt;/a&gt;MicroPython&lt;/h1&gt;&lt;p&gt;&lt;a</summary>
        
      
    
    
    
    <category term="language" scheme="https://www.oikiou.top/categories/language/"/>
    
    
    <category term="Embedded" scheme="https://www.oikiou.top/tags/Embedded/"/>
    
    <category term="Python" scheme="https://www.oikiou.top/tags/Python/"/>
    
    <category term="MicroPython" scheme="https://www.oikiou.top/tags/MicroPython/"/>
    
  </entry>
  
  <entry>
    <title>PyQT</title>
    <link href="https://www.oikiou.top/2022/7ecf7a99/"/>
    <id>https://www.oikiou.top/2022/7ecf7a99/</id>
    <published>2022-08-21T14:57:15.000Z</published>
    <updated>2022-09-10T05:20:07.415Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PyQt"><a href="#PyQt" class="headerlink" title="PyQt"></a>PyQt</h1><h2 id="添加图标"><a href="#添加图标" class="headerlink" title="添加图标"></a>添加图标</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WindowGUI</span>(QMainWindow, Ui_MainWindow):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(WindowGUI, self).__init__()<br>        self.setupUi(self)<br>        <span class="hljs-comment">#这里添加了一个图标</span><br>        self.setWindowIcon(QIcon(<span class="hljs-string">&#x27;./Data/SerialBlack.ico&#x27;</span>))<br>        self.pushButton.clicked.connect(self.Butt)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 每一pyqt5应用程序必须创建一个应用程序对象。sys.argv参数是一个列表，从命令行输入参数。</span><br>    app = QApplication(sys.argv)<br>    window = WindowGUI()<br>    window.show()<br>    sys.exit(app.exec_())<br></code></pre></td></tr></table></figure><h2 id="退出确认"><a href="#退出确认" class="headerlink" title="退出确认"></a>退出确认</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WindowGUI</span>(QMainWindow, Ui_MainWindow):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(WindowGUI, self).__init__()<br>        self.setupUi(self)<br>    <span class="hljs-comment">#关闭窗口产生 QCloseEvent</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">closeEvent</span>(<span class="hljs-params">self, event</span>):<br>        reply = QMessageBox.question(self, <span class="hljs-string">&#x27;Message&#x27;</span>,<br>                                     <span class="hljs-string">&quot;Are you sure to quit?&quot;</span>, QMessageBox.Yes |<br>                                     QMessageBox.No, QMessageBox.No)<br>        <span class="hljs-keyword">if</span> reply == QMessageBox.Yes:<br>            event.accept()<br>        <span class="hljs-keyword">else</span>:<br>            event.ignore()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 每一pyqt5应用程序必须创建一个应用程序对象。sys.argv参数是一个列表，从命令行输入参数。</span><br>    app = QApplication(sys.argv)<br>    window = WindowGUI()<br>    window.show()<br>    sys.exit(app.exec_())<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;PyQt&quot;&gt;&lt;a href=&quot;#PyQt&quot; class=&quot;headerlink&quot; title=&quot;PyQt&quot;&gt;&lt;/a&gt;PyQt&lt;/h1&gt;&lt;h2 id=&quot;添加图标&quot;&gt;&lt;a href=&quot;#添加图标&quot;</summary>
        
      
    
    
    
    <category term="language" scheme="https://www.oikiou.top/categories/language/"/>
    
    
    <category term="Python" scheme="https://www.oikiou.top/tags/Python/"/>
    
    <category term="QT" scheme="https://www.oikiou.top/tags/QT/"/>
    
    <category term="PyQT" scheme="https://www.oikiou.top/tags/PyQT/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="https://www.oikiou.top/2022/2f57a694/"/>
    <id>https://www.oikiou.top/2022/2f57a694/</id>
    <published>2022-08-21T14:57:15.000Z</published>
    <updated>2022-09-10T05:20:07.418Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="正则表达式语法"><a href="#正则表达式语法" class="headerlink" title="正则表达式语法"></a>正则表达式语法</h2><ul><li><strong>runoo+b</strong>，可以匹配 runoob、runooob、runoooooob 等，+ 号代表前面的字符必须至少出现一次（1次或多次）。</li><li><strong>runoo*b</strong>，可以匹配 runob、runoob、runoooooob 等，* 号代表前面的字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次）。</li><li><strong>colou?r</strong> 可以匹配 color 或者 colour，? 问号代表前面的字符最多只可以出现一次（0次、或1次）。</li></ul><h2 id="正则表达式替换"><a href="#正则表达式替换" class="headerlink" title="正则表达式替换"></a>正则表达式替换</h2><p>VSCode不可用，notepad++可用</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs inform7">原始串 <br>str<span class="hljs-comment">[1]</span>abc<span class="hljs-comment">[991]</span>; <br>str<span class="hljs-comment">[2]</span>abc<span class="hljs-comment">[992]</span>; <br>str<span class="hljs-comment">[11]</span>abc<span class="hljs-comment">[993]</span>; <br>str<span class="hljs-comment">[22]</span>abc<span class="hljs-comment">[994]</span>; <br>str<span class="hljs-comment">[111]</span>abc<span class="hljs-comment">[995]</span>; <br>str<span class="hljs-comment">[222]</span>abc<span class="hljs-comment">[996]</span>; <br>str<span class="hljs-comment">[1111]</span>abc<span class="hljs-comment">[997]</span>; <br>str<span class="hljs-comment">[2222]</span>abc<span class="hljs-comment">[999]</span>; <br><br>目标串： <br>abc<span class="hljs-comment">[1]</span>; <br>abc<span class="hljs-comment">[2]</span>; <br>abc<span class="hljs-comment">[11]</span>; <br>abc<span class="hljs-comment">[22]</span>; <br>abc<span class="hljs-comment">[111]</span>; <br>abc<span class="hljs-comment">[222]</span>; <br>abc<span class="hljs-comment">[1111]</span>; <br>abc<span class="hljs-comment">[2222]</span>; <br><br>处理： <br>查找串：str/<span class="hljs-comment">[(<span class="hljs-comment">[0-9]</span>+)/]</span>abc/<span class="hljs-comment">[<span class="hljs-comment">[0-9]</span>+/]</span> <br>替换串：abc<span class="hljs-comment">[/1]</span> <br></code></pre></td></tr></table></figure><p><img src="/2022/2f57a694/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzMzc5Mzc0MDAw,size_16,color_FFFFFF,t_70.png" alt="img"></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;正则表达式&quot;&gt;&lt;a href=&quot;#正则表达式&quot; class=&quot;headerlink&quot; title=&quot;正则表达式&quot;&gt;&lt;/a&gt;正则表达式&lt;/h1&gt;&lt;h2 id=&quot;正则表达式语法&quot;&gt;&lt;a href=&quot;#正则表达式语法&quot;</summary>
        
      
    
    
    
    <category term="language" scheme="https://www.oikiou.top/categories/language/"/>
    
    
    <category term="正则表达式" scheme="https://www.oikiou.top/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
</feed>

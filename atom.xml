<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Oikiou&#39;s Blog</title>
  <icon>https://www.oikiou.top/img/favicon.ico</icon>
  <subtitle>花有重开日，人无再少年</subtitle>
  <link href="https://www.oikiou.top/atom.xml" rel="self"/>
  
  <link href="https://www.oikiou.top/"/>
  <updated>2022-09-14T17:36:49.076Z</updated>
  <id>https://www.oikiou.top/</id>
  
  <author>
    <name>Oikiou</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>zip gzip bzip2 tar 的区别和差异</title>
    <link href="https://www.oikiou.top/2022/613d8edd/"/>
    <id>https://www.oikiou.top/2022/613d8edd/</id>
    <published>2022-09-14T16:20:15.000Z</published>
    <updated>2022-09-14T17:36:49.076Z</updated>
    
    <content type="html"><![CDATA[<h1 id="zip-gzip-bzip2-tar-的区别和差异"><a href="#zip-gzip-bzip2-tar-的区别和差异" class="headerlink" title="zip gzip bzip2 tar 的区别和差异"></a>zip gzip bzip2 tar 的区别和差异</h1><ul><li><strong>gzip 和 bzip2</strong>用于压缩单个文件。bzip2 比 gzip 具有更高的压缩率，同样的也会需要更多时间来进行压缩。</li><li><strong>zip 和 tar</strong>用于压缩和归档文件夹。</li></ul><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>zip</td><td><code>.zip</code></td><td>可以压缩目录</td><td>源文件会保留</td><td>专门的压缩命令</td></tr><tr><td>gzip</td><td><code>.gz</code></td><td>只能压缩文件</td><td>压缩后源文件会被删除</td><td></td></tr><tr><td>bzip2</td><td><code>.bz2</code></td><td>只能压缩文件</td><td>加<code>-k</code>参数源文件可以保留</td><td></td></tr><tr><td>tar</td><td><code>.tar</code></td><td>可以压缩目录</td><td>源文件会保留</td><td>linux包大多是这形态<br>将目录打包成一个文件<code>Tape archive</code></td></tr><tr><td>xz</td><td><code>.xz</code></td><td></td><td></td><td></td></tr></tbody></table><h2 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h2><h2 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h2><p>该<code>gzip</code>程序用于压缩一个或多个文件。执行时，它将原始文件替换为原始文件的压缩版本。使用 gzip 压缩的文件具有扩展名<code>.gz</code></p><h2 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h2><p>该<code>bzip2</code>命令类似于 gzip，但使用不同的压缩算法，以牺牲压缩速度为代价归档更高级别的压缩。使用 bzip2 压缩的文件具有扩展名<code>.bz2</code></p><h2 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h2><p><code>tar</code>命令，首字母缩略词<em><strong>Tape archive</strong></em>用于创建存档文件。tar 存档可以由单独的文件、一个或多个目录层次结构或两者的混合组成。tar 文件有扩展名<code>.tar</code></p><h2 id="xz"><a href="#xz" class="headerlink" title="xz"></a>xz</h2><p><code>xz</code>是一个通用的数据压缩工具，命令行语法类似于 gzip 和 bzip2 。它根据选择的操作模式压缩或解压缩每个文件。用 xz 压缩的文件具有扩展名<code>.xz</code></p><h1 id="Zip-和-Unzip"><a href="#Zip-和-Unzip" class="headerlink" title="Zip 和 Unzip"></a>Zip 和 Unzip</h1><h2 id="zip-1"><a href="#zip-1" class="headerlink" title="zip"></a>zip</h2><p><strong>命令格式</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">zip [-r] [压缩后文件名] [文件或目录]<br></code></pre></td></tr></table></figure><p><strong>命令描述</strong></p><ul><li><code>zip</code>命令用来对文件进行打包操作。zip是个使用广泛的压缩程序，文件经它压缩后会另外产生具有“.zip”扩展名的压缩文件；</li><li>在linux压缩后的文件，基本都可以在Windows系统中解压；Windows中压缩的文件，在Linux中不一定可用，但是zip格式的压缩文件，可以做到可用；</li><li>zip的压缩比不是很高；</li></ul><p><strong>示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 压缩文件</span><br>$ zip a.zip a.txt<br><span class="hljs-comment"># 查看压缩后的文件</span><br>$ <span class="hljs-built_in">ls</span><br>a.txt  a.zip  <br><br><span class="hljs-comment"># 2. -r：压缩文件夹</span><br>$ zip -r test.zip testDir/<br>$ <span class="hljs-built_in">ls</span><br>testDir  test.zip<br><br><span class="hljs-comment"># 3. -x 排除文件</span><br>$ zip -r test2.zip testDir/ -x <span class="hljs-string">&quot;testDir/hello*&quot;</span> -x <span class="hljs-string">&quot;testDir/dir/*&quot;</span><br></code></pre></td></tr></table></figure><h2 id="unzip-解压"><a href="#unzip-解压" class="headerlink" title="unzip 解压"></a>unzip 解压</h2><p><strong>命令格式</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">unzip [选项] 文件名<br></code></pre></td></tr></table></figure><p><strong>命令描述</strong></p><p><code>unzip</code>命令用于解压缩由zip命令压缩的“.zip”压缩包。</p><p><strong>选项</strong></p><ul><li>-n：解压缩时不要覆盖原有的文件；</li><li>-o：不必先询问用户，unzip执行后覆盖原有的文件；</li><li>-d &lt;目录&gt;：指定文件解压缩后所要存储的目录(不指定目录，默认解压到当前目录)</li></ul><p><strong>示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 解压文件到家目录</span><br>$ unzip test.zip -d ~<br></code></pre></td></tr></table></figure><h1 id="Gzip-和-Gunzip"><a href="#Gzip-和-Gunzip" class="headerlink" title="Gzip 和 Gunzip"></a>Gzip 和 Gunzip</h1><h2 id="gzip-1"><a href="#gzip-1" class="headerlink" title="gzip"></a><strong>gzip</strong></h2><p><strong>命令格式</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">gzip [文件]<br></code></pre></td></tr></table></figure><p><strong>命令描述</strong></p><p><code>gzip</code>命令 用来压缩文件。gzip是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多处“<code>.gz</code>”扩展名。<code>gzip</code>只能压缩文件，不能压缩文件夹，压缩后原文件会被删除</p><p><code>gzip</code>是在Linux系统中经常使用的一个对文件进行压缩和解压缩的命令，既方便又好用。gzip不仅可以用来压缩大的、较少使用的文件以节省磁盘空间，还可以和tar命令一起构成Linux操作系统中比较流行的压缩文件格式。据统计，gzip命令对文本文件有60%～70%的压缩率。减少文件大小有两个明显的好处，一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间。</p><p><strong>示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 压缩文件</span><br>$ gzip a.txt<br><span class="hljs-comment"># 查看压缩后的文件，源文件被删除</span><br>$ <span class="hljs-built_in">ls</span><br>a.txt.gz<br></code></pre></td></tr></table></figure><h2 id="gunzip-解压"><a href="#gunzip-解压" class="headerlink" title="gunzip 解压"></a>gunzip 解压</h2><p><strong>命令格式</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">gzip [文件]<br></code></pre></td></tr></table></figure><p><strong>命令描述</strong></p><p><code>gunzip</code>命令用来解压缩文件。gunzip是个使用广泛的解压缩程序，它用于解开被gzip压缩过的文件，这些压缩文件预设最后的扩展名为<code>.gz</code>。</p><p><strong>示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 解压文件，解压后压缩文件被删除</span><br>$ gunzip a.txt.gz<br>$ <span class="hljs-built_in">ls</span><br>a.txt <br></code></pre></td></tr></table></figure><h1 id="Bzip2"><a href="#Bzip2" class="headerlink" title="Bzip2"></a>Bzip2</h1><h2 id="bzip2-1"><a href="#bzip2-1" class="headerlink" title="bzip2"></a>bzip2</h2><p><strong>命令格式</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">bzip2 [选项] [文件]<br></code></pre></td></tr></table></figure><p><strong>命令描述</strong></p><ul><li>bzip2命令用于压缩“<code>.bz2</code>”格式的压缩包，是<code>gzip</code>的升级版本，可以保留原文件；</li><li>bzip2的压缩比比较高，可用于压缩较大文件的压缩；</li><li>bzip2也是只对文件进行压缩，如果相对目录进行压缩的话，可以配合 <code>tar</code>命令使用，使用 <code>tar -jcvf</code> 文件名 完成打包压缩。</li></ul><p><strong>选项</strong></p><p>-k（keep）：保留原文件（不删除原文件）</p><p><strong>示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># bzip2 压缩文件</span><br>$ bzip2 -k a.txt<br>$ <span class="hljs-built_in">ls</span><br>a.txt  a.txt.bz2<br><br><span class="hljs-comment"># 配合使用tar 命令，完成打包压缩</span><br>$ <span class="hljs-built_in">mkdir</span> music<br>$ tar -jcvf music.tar.bz2 music/<br>$ <span class="hljs-built_in">ls</span><br>music  music.tar.bz2<br></code></pre></td></tr></table></figure><h2 id="bunzip2-解压"><a href="#bunzip2-解压" class="headerlink" title="bunzip2 解压"></a>bunzip2 解压</h2><p><strong>命令格式</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">bunzip2 [选项] [文件]<br></code></pre></td></tr></table></figure><p><strong>命令描述</strong></p><ul><li>解压缩“<code>.bz2</code>”格式的压缩文件；</li><li>gunzip的升级版，可以使用<code>-k</code>保留原文件；</li><li>可以配合使用tar命令，完成解压缩解包： <code>tar -jxvf 文件名</code></li></ul><p><strong>选项</strong></p><p>-k（keep）：保留原文件（不删除原文件）</p><p><strong>示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">ls</span><br>a.txt.bz2  music.tar.bz2<br><br><span class="hljs-comment"># 解压缩文件</span><br>$ bunzip2 -k a.txt.bz2<br>$ <span class="hljs-built_in">ls</span><br>a.txt  a.txt.bz2  music.tar.bz2<br><br><span class="hljs-comment"># 使用tar完成解压解包</span><br>$ tar -jxvf music.tar.bz2<br>$ <span class="hljs-built_in">ls</span><br>a.txt  a.txt.bz2  music  music.tar.bz2<br></code></pre></td></tr></table></figure><h1 id="tar-和-tar"><a href="#tar-和-tar" class="headerlink" title="tar 和 tar"></a>tar 和 tar</h1><h2 id="tar-1"><a href="#tar-1" class="headerlink" title="tar"></a>tar</h2><p><strong>命令格式</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">tar [选项] [压缩后文件名] [目录]<br></code></pre></td></tr></table></figure><p><strong>命令描述</strong></p><p>打包目录，将目录打包成一个文件，同时可以压缩，压缩后的拓展名为<code>.tar.gz</code>，这个拓展名在下载Linux相关安装包时很常见。</p><p>使用<code>tar</code>命令时，如果想要打包并压缩一个目录，可以有两种方法进行：</p><ol><li>先利用tar命令打包目录为一个文件，然后使用gzip压缩</li><li>直接利用tar命令打包并压缩 (简单方便，推荐使用)</li></ol><p>解压时也有两种方式：</p><ol><li>先使用gunzip解压缩，再使用tar解包</li><li>直接利用tar命令解压缩并解包 (简单方便，推荐使用)</li></ol><p><strong>选项</strong></p><ul><li>-c：打包(将所有文件变成一个文件 Create  a new archive)</li><li>-x：解包</li><li>-v：显示详细信息</li><li>-f：指定文件名</li><li>-z：打包同时压缩&#x2F;解压缩  ，gzip压缩</li><li>-j：生成压缩文件 ，bzip2压缩</li></ul><p><strong>示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 压缩</span><br>tar -zcvf movie2.tar.gz movie<br><span class="hljs-comment"># 解压</span><br>tar -zxvf movie2.tar.gz<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1、2为    打包压缩    的两种方法</span><br><span class="hljs-comment"># 1. 使用 tar -cvf 打包，然后使用gzip压缩</span><br>$ tar -cvf movie.tar movie/<br>$ <span class="hljs-built_in">ls</span><br>movie  movie.tar<br>$ gzip movie.tar<br>$ <span class="hljs-built_in">ls</span><br>movie  movie.tar.gz<br><br><span class="hljs-comment"># 2. 使用 tar -zcvf 打包并压缩</span><br>$ tar -zcvf movie2.tar.gz movie<br>$ <span class="hljs-built_in">ls</span><br>movie  movie2.tar.gz<br><br><span class="hljs-comment"># 3、4为     解压缩并解包     的两种方法</span><br><span class="hljs-comment"># 3. 先使用gunzip解压缩，然后 tar -xvf解包</span><br>$ gunzip movie.tar.gz<br>$ <span class="hljs-built_in">ls</span><br>movie2.tar.gz  movie.tar<br>$ tar -xvf movie.tar<br>movie/<br>$ <span class="hljs-built_in">ls</span><br>movie  movie2.tar.gz  movie.tar<br><br><span class="hljs-comment"># 4. 使用tar -zxvf 解压缩并解包</span><br>$ tar -zxvf movie2.tar.gz<br>$ <span class="hljs-built_in">ls</span><br>movie  movie2.tar.gz  movie.tar<br></code></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://techviewleo.com/compress-uncompress-files-tar-gzip-bzip2-xz-linux/">LPIC 101 – Compress and Uncompress Files Using tar, gzip, bzip2 and xz on Linux</a></p><p><a href="https://en.wikipedia.org/wiki/List_of_archive_formats#Comparison">List of archive formats</a></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;zip-gzip-bzip2-tar-的区别和差异&quot;&gt;&lt;a href=&quot;#zip-gzip-bzip2-tar-的区别和差异&quot; class=&quot;headerlink&quot; title=&quot;zip gzip bzip2 tar</summary>
        
      
    
    
    
    <category term="blog" scheme="https://www.oikiou.top/categories/blog/"/>
    
    
    <category term="zip" scheme="https://www.oikiou.top/tags/zip/"/>
    
    <category term="gzip" scheme="https://www.oikiou.top/tags/gzip/"/>
    
    <category term="bzip" scheme="https://www.oikiou.top/tags/bzip/"/>
    
    <category term="tar" scheme="https://www.oikiou.top/tags/tar/"/>
    
  </entry>
  
  <entry>
    <title>MD5</title>
    <link href="https://www.oikiou.top/2022/45a589a3/"/>
    <id>https://www.oikiou.top/2022/45a589a3/</id>
    <published>2022-09-14T14:57:15.000Z</published>
    <updated>2022-09-14T17:36:49.071Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h1><p><strong>MD5消息摘要算法</strong>（英语：MD5 Message-Digest Algorithm），一种被广泛使用的<a href="https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A2%BC%E9%9B%9C%E6%B9%8A%E5%87%BD%E6%95%B8">密码散列函数</a>，可以产生出一个128位（16个字符(BYTES)）的散列值（hash value），用于确保信息传输完整一致。将<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE">数据</a>（如一段文字）运算变为另一固定长度值，是散列算法的基础原理。</p><p><strong>参考</strong></p><p><a href="https://zhuanlan.zhihu.com/p/121492822">MD5破解的几种方法</a></p><p><a href="https://en.wikipedia.org/wiki/MD5">Wiki MD5</a></p><h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><ul><li><p>不可逆向的</p><blockquote><p>  我们没办法把MD5码还原对应的原文。道理很简单，任意长度的数据经过MD5处理后，所包含的信息量已经大大减少，那是不可能再次还原成为原始信息的。</p></blockquote></li><li><p>原文中作一个小变化其散列也会发生巨大的变化</p><blockquote>  <figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-symbol">MD5</span>(<span class="hljs-string">&quot;The quick brown fox jumps over the lazy dog&quot;</span>)<br>= <span class="hljs-number">9</span>e107d9d372bb6826bd81d3542a419d6<br></code></pre></td></tr></table></figure><p>  比如用c取代d, 其MD5值发生了巨大的变化</p>  <figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-symbol">MD5</span>(<span class="hljs-string">&quot;The quick brown fox jumps over the lazy cog&quot;</span>)<br>= <span class="hljs-number">1055</span>d3e698d289f2af8663725127bd4b<br></code></pre></td></tr></table></figure></blockquote></li><li><p>已被破解</p><blockquote><p>  通俗点讲就是，可以找到一个A和一个B，使hash（A）&#x3D;hash（B），而真正有用的是给定一个A能得到B，使hash（A）&#x3D;hash（B），而王小云能做到这样</p></blockquote></li></ul><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>MD5 摘要已在<a href="https://en.wikipedia.org/wiki/Software">软件</a>世界中广泛使用，以确保传输的文件已完好无损地到达。例如，文件服务器通常会为文件提供预先计算的 MD5（称为<a href="https://en.wikipedia.org/wiki/Md5sum">md5sum</a>）<a href="https://en.wikipedia.org/wiki/Checksum">校验和</a>，以便用户可以将下载文件的校验和与其进行比较。</p><p><img src="/2022/undefined/350px-CPT-Hashing-File-Transmission.svg-16631605314513.png" alt="350px-CPT-Hashing-File-Transmission.svg"></p><p>由于很容易产生 MD5 冲突，因此创建文件的人可能会创建具有相同校验和的第二个文件，因此该技术无法防止某些形式的恶意篡改。</p><p>在某些情况下，校验和是不可信的（例如，如果它是通过与下载文件相同的渠道获得的，他人可能修改了文件后再次修改了MD5，使得MD5并不可信），在这种情况下，MD5 只能提供错误检查功能：“它会识别损坏或不完整的下载，这变成下载较大文件时更有可能。”</p><h1 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h1><h2 id="穷举法-amp-字典法"><a href="#穷举法-amp-字典法" class="headerlink" title="穷举法&amp;字典法"></a>穷举法&amp;字典法</h2><p><strong>穷举法非常简单，就是不停地尝试各种字符的排列组合，看哪一个组合的MD5码能对上。</strong>可惜缺点是太耗费时间了。我们举个栗子，假设我们要破解一个6位大小写字母和数字混合的密码，那么一共有(26+26+10)<sup>6</sup> 种组合。这个数的大小超过500亿。</p><p>既然计算如此费时，能不能考虑<strong>把计算结果以映射表的形式存放起来，一个萝卜一个坑</strong>，一个原文对应着一个MD5码呢？可以呀！这就是传说中的“字典法”。将已知的MD5码查表，直接反查出原文。<strong>字典法体现了算法设计的“以空间换时间”的思想。</strong>缺点是比较耗费空间。不过现在硬盘的价格变得白菜价了，空间开销不算什么。</p><p><a href="https://www.cmd5.com/password.aspx">CMD5 反查网站</a></p><p><a href="https://www.somd5.com/">SMD5 反查网站</a></p><h2 id="哈希链表-amp-彩虹表法"><a href="#哈希链表-amp-彩虹表法" class="headerlink" title="哈希链表&amp;彩虹表法"></a>哈希链表&amp;彩虹表法</h2><blockquote><p>  如果说穷举法太耗费时间，字典法太耗费存储空间的话，我们能不能考虑在时间消耗和空间消耗之间折中呢？我们可以考虑用链表将一系列有意义的原文和MD5码串起来。</p><p>  要构造这样的链表，我们需要两个函数：哈希函数H(x)和衰减函数（reduction function）R(x)。哈希函数可以是MD5，也可以是其他的消息摘要算法。H(x)的值域是R(x)的定义域，R(x)的值域是H(x)的定义域。<strong>R(x)不是H(x)的反函数。</strong></p><p>  将一个原文不停地使用H(x)和R(x)交替进行运算k次，再将原文本身和运算结果以链表的形式串接起来，就可以得到结点个数为2k+1的链表。实际存放的时候只存放首端和末端两个原文即可。<strong>这种链表叫做“哈希链表”，体现了算法设计的“时空权衡”（Space and Time Tradeoffs）。</strong></p><p>  举个栗子，假设原文s&#x3D;abcabc，经过2次交替运算，得到以下的链表：</p><p>  abcabc-&gt;H(x)-&gt;3C8B0D7A-&gt;R(x)-&gt;eopmca-&gt;H(x)-&gt;7E9F216C-&gt;R(x)-&gt;rapper</p><p>  以上数据均为举例编造的，仅为说明原理使用。那我们存放这个链表的时候，只需要记录abcabc和rapper两个原文即可。</p><p>  假设我们要破解的摘要值（哈希链表的H(x)不一定是MD5算法，这里用更准确的说法代替MD5码）是7E9F216C，经过R(x)运算得到rapper，说明我们要寻找的原文就在以rapper为末端的哈希链表中。从首端开始经过多次运算，我们发现eopmca的摘要值就是7E9F216C。于是就反查出7E9F216C对应的原文是eopmca。</p><p>  <strong>如果在生成哈希链表的时候依次使用多个不一样的R(x)，此时的哈希链表就是“彩虹表”。</strong></p><p>  这里有已经计算好的彩虹表：<a href="https://link.zhihu.com/?target=http://project-rainbowcrack.com/table.htm">http://project-rainbowcrack.com</a></p></blockquote><h2 id="差分攻击"><a href="#差分攻击" class="headerlink" title="差分攻击"></a>差分攻击</h2><p>上面介绍的穷举法、字典法和彩虹表法都是暴力破解，适用于任何的消息摘要算法。</p><p>真正意义上MD5算法的破解，是2004年山东大学王小云教授提出的MD5碰撞方法。她所用到的方法正是差分攻击。</p><p><a href="https://www.sohu.com/a/501560600_121106869">她是这样的“中国密码女神”！</a> </p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;MD5&quot;&gt;&lt;a href=&quot;#MD5&quot; class=&quot;headerlink&quot; title=&quot;MD5&quot;&gt;&lt;/a&gt;MD5&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;MD5消息摘要算法&lt;/strong&gt;（英语：MD5</summary>
        
      
    
    
    
    <category term="blog" scheme="https://www.oikiou.top/categories/blog/"/>
    
    
    <category term="MD5" scheme="https://www.oikiou.top/tags/MD5/"/>
    
  </entry>
  
  <entry>
    <title>使用Jlink 烧写SPI Flash存储芯片</title>
    <link href="https://www.oikiou.top/2022/fd90dc4c/"/>
    <id>https://www.oikiou.top/2022/fd90dc4c/</id>
    <published>2022-08-26T15:23:05.000Z</published>
    <updated>2022-09-13T12:45:40.135Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用Jlink-烧写SPI-Flash存储芯片"><a href="#使用Jlink-烧写SPI-Flash存储芯片" class="headerlink" title="使用Jlink 烧写SPI Flash存储芯片"></a>使用Jlink 烧写SPI Flash存储芯片</h1><p>参考:</p><p><a href="https://www.segger.com/products/debug-probes/j-link/tools/j-flash-spi/">https://www.segger.com/products/debug-probes/j-link/tools/j-flash-spi/</a></p><h1 id="硬件连接"><a href="#硬件连接" class="headerlink" title="硬件连接"></a>硬件连接</h1><h2 id="SPI-amp-Single"><a href="#SPI-amp-Single" class="headerlink" title="SPI &amp; Single"></a>SPI &amp; Single</h2><p><img src="/2022/fd90dc4c/formatpng.png" alt="img"></p><p><img src="/2022/fd90dc4c/pinout-spi-20-pin.gif" alt="引出线 spi 20 针"></p><h2 id="QSPI-amp-Quad"><a href="#QSPI-amp-Quad" class="headerlink" title="QSPI &amp; Quad"></a>QSPI &amp; Quad</h2><p><img src="/2022/fd90dc4c/pinout-qspi-20-pin.png" alt="img"></p><blockquote><p>  注意:</p><p>  这里要注意的一点，正版的Jlink仿真器1脚是输入引脚，是外部提供参考电平的，但由于现在大部分的JLink仿真器都是学习(dao)版的，1脚不是输入，而是3.3v的输出(并不确定也有可能是5V的, 盗版的Jlink真的是什么乱七八糟的都有)，所以正常情况下可以直接用这个管教来给SPI Flash供电。</p><p>  <strong>关于 nRESET 的注意事项</strong>：如果有另一个设备&#x2F;外围设备也控制 SPI 闪存（例如闪存连接到的 CPU），则 J-Link 的 nRESET 应连接到目标系统的复位或 CPU 的复位引脚确保 J-Link 可以在对 SPI 闪存进行编程时保持 CPU 处于复位状态。</p></blockquote><h1 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h1><p>安装Jlink套件的时候会自带<code>JFlashSPI.exe</code>在开始菜单名称应该类似<code>J-Flash SPI</code>, 这是J-Flash的GUI程序,还有一个命令行的不多做介绍.</p><blockquote><p>  如果没有找到自带的, 请更新Jlink套件, 旧版确实不带这个东西.</p><p>  Segger Jlink套件下载链接 <a href="https://www.segger.com/downloads/jlink/">https://www.segger.com/downloads/jlink/</a></p></blockquote><p><img src="/2022/fd90dc4c/image-20220826224742256.png" alt="image-20220826224742256"></p><p>点击<code>target -&gt; connet</code>连接到Jlink, 它会自动检测大部分SPI闪存, </p><blockquote><p>  有时候识别的具体型号并不准确, 但是这不重要他们参数类似, 可以正常完成编程的工作.</p><p>  Jlink支持的SPI Flash型号可以在<a href="https://www.segger.com/products/debug-probes/j-link/technology/cpus-and-devices/supported-spi-flashes/">点击这里</a>找到.</p></blockquote><p>点击<code>file -&gt; open data file </code>我们打开要烧录的文件.</p><blockquote><p>  bin 文件需要设定起始地址</p><p>  hex文件自带了位置信息</p></blockquote><p>点击<code>target -&gt; auto</code>可以自动将文件烧录进去 还会进行读回校验.</p><p>至此烧录完成.</p><p><strong>Tips:</strong></p><blockquote><p>  点击<code>target -&gt; read back</code> 可以将SPI Flash内的数据读取出来<br>  点击<code>options -&gt; settings -&gt; setup -&gt; interface speed</code>可以修改时钟速度. </p></blockquote><p><strong>Other:</strong></p><p>Jlink真的是超级牛的工具, J-Scope, RTT这些都很好用, 还有很多高级功能我还没用上.<br>我前面有写过RTT的笔记, 在调试一个项目的时候没法使用串口, 当时就是用RTT搭建了一个log平台.</p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="winbood-W25Q128封装"><a href="#winbood-W25Q128封装" class="headerlink" title="winbood W25Q128封装"></a>winbood W25Q128封装</h2><p><img src="/2022/fd90dc4c/image-20220826104542006.png" alt="image-20220826104542006"></p><p><img src="/2022/fd90dc4c/20210622091839750557.png" alt="img"></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;使用Jlink-烧写SPI-Flash存储芯片&quot;&gt;&lt;a href=&quot;#使用Jlink-烧写SPI-Flash存储芯片&quot; class=&quot;headerlink&quot; title=&quot;使用Jlink 烧写SPI</summary>
        
      
    
    
    
    <category term="blog" scheme="https://www.oikiou.top/categories/blog/"/>
    
    
    <category term="J-Link" scheme="https://www.oikiou.top/tags/J-Link/"/>
    
    <category term="SPI" scheme="https://www.oikiou.top/tags/SPI/"/>
    
    <category term="Flash" scheme="https://www.oikiou.top/tags/Flash/"/>
    
    <category term="J-Tag" scheme="https://www.oikiou.top/tags/J-Tag/"/>
    
    <category term="Jlink" scheme="https://www.oikiou.top/tags/Jlink/"/>
    
  </entry>
  
  <entry>
    <title>CC2530</title>
    <link href="https://www.oikiou.top/2022/8d6db935/"/>
    <id>https://www.oikiou.top/2022/8d6db935/</id>
    <published>2022-08-21T14:57:15.000Z</published>
    <updated>2022-09-10T05:20:07.359Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>CC2530是针对IEEE 802.15.4，Zigbee和RF4CE应用的真正片上系统（SoC）解决方案。 它能够以非常低的总物料成本构建强大的网络节点。 CC2530将领先的射频收发器的卓越性能与业界标准增强型8051 MCU，系统内可编程闪存，8 KB RAM以及许多其他强大功能相结合。 CC2530有四种不同的闪存版本：分别为CC2530F32 &#x2F; 64&#x2F;128&#x2F;256对应32&#x2F;64&#x2F;128&#x2F;256 KB的闪存。 CC2530具有多种工作模式，非常适合需要超低功耗的系统。 运行模式之间的短暂转换时间进一步确保了低能耗。</p><p>•CC2530是TI公司推出的用来实现嵌入式ZigBee应用的低功耗片上系统。</p><p>•在单个芯片上整合了ZigBee 射频(RF)前端、内存和微控制器。</p><p>•8 位MCU（增强型、标准8051指令集）。</p><p>•256 KB Flash和8 KB 的RAM，内部16MHz RC 和 32kHz RC 振荡器。</p><p>•8路12位ADC；18个中断源；4个Timer；硬件支持的AES128 ；WDT(1.9ms-1s)；32 kHz晶振的休眠模式定时器、POR(上电复位)、BOD(掉电检测)，以及21 个通用I&#x2F;O 。</p></blockquote><h1 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><img src="/2022/8d6db935/20180211202707601.png" alt="img"></p><p>I &#x2F; O端口具有以下主要功能：</p><ul><li>21个数字通用输入&#x2F;输出引脚</li><li>通用I &#x2F; O或外设I &#x2F; O</li><li>输入上拉或下拉功能</li><li>外部中断功能</li></ul><blockquote><p>所有21个I &#x2F; O引脚都具有外部中断功能。 因此，如果需要，外部设备可能会产生中断。 外部中断功能也可用于将器件从睡眠模式（电源模式PM1，PM2和PM3）中唤醒</p></blockquote><blockquote><p>通用IO：共21个，分成3组，<strong>P0组、P1组、P2组</strong>，其中P0\P1组各8个IO，P2组5个（P2_0、P2_1、 P2_2、P2_3、 P2_4）。其中P1_0、P1_1有20mA的输出驱动能力，其余的只有4mA。</p></blockquote><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><ol><li><p>GPIO<strong>功能</strong>选择寄存器——<strong>PxSEL</strong></p><p> 寄存器PxSEL（其中x是端口号0-2）用于将端口中的每个引脚配置为<strong>通用I&#x2F;O引脚</strong>或<strong>外设I&#x2F;O引脚</strong>，可位寻址。 默认情况下，复位后，所有数字输入&#x2F;输出引脚都配置为<strong>通用上拉输入引脚</strong>。</p><blockquote><p>其中，P2SEL只有第0位至第2位是端口2的功能选择控制位，第3位至第6位是端口1的外设优先级控制位。</p></blockquote></li></ol><ul><li>0&#x3D;通用</li><li>1&#x3D;外设I&#x2F;O</li></ul><ol><li><p>GPIO<strong>输入输出方向</strong>选择寄存器——<strong>PxDIR</strong></p><p>寄存器PxDIR用于将每个端口的引脚方向设置为<strong>输入方向</strong>或<strong>输出方向</strong>。 因此，将PxDIR中的相应位设置为1，相应的引脚就变成输出方向，可位寻址。复位后为<strong>输入引脚</strong>。</p><blockquote><p>其中，P2DIR只有第0位至第4位是端口2的方向选择控制位，第6位和第7位是端口0外设优先级控制位。</p></blockquote></li></ol><ul><li><p>0&#x3D;输入</p></li><li><p>1&#x3D;输出</p></li></ul><ol start="2"><li><p>GPIO<strong>输入模式</strong>寄存器——<strong>PxINP</strong></p><p>寄存器PxINP用于设置IO端口的<strong>输入模式</strong>，通用I &#x2F; O端口引脚可配置为具有<strong>上拉</strong>，<strong>下拉</strong>或<strong>三态</strong>操作模式。 默认情况下，复位后，输入配置为带有上拉的输入。如果要取消输入端口的上拉或下拉功能，必须将PxINP中的相应位设置为1。</p><ul><li>请注意，即使IO端口是外设功能输入，配置为外设I &#x2F; O信号的引脚也不具有上拉或下拉功能。</li></ul><blockquote><p>其中，P2INP中，第0位至第4位是端口2的输入模式选择位</p><p><strong>第5位至第7位是端口0、端口1、端口2的上下拉选择位。</strong></p><ul><li>0&#x3D;PullUp</li><li>1&#x3D;PullDown</li></ul></blockquote></li></ol><ul><li>0&#x3D;上拉或下拉</li><li>1&#x3D;三态</li></ul><h1 id="Z-Stack"><a href="#Z-Stack" class="headerlink" title="Z-Stack"></a>Z-Stack</h1><h2 id="创建一个任务-Create-Task"><a href="#创建一个任务-Create-Task" class="headerlink" title="创建一个任务 Create Task"></a>创建一个任务 Create Task</h2><ul><li>&#x2F;&#x2F; 任务列表<br>const pTaskEventHandlerFn tasksArr[] &#x3D; {…..}</li><li>&#x2F;&#x2F; 初始化任务<br>void osalInitTasks( void )<br>{…..}</li><li>&#x2F;&#x2F; 任务处理函数<br>uint16 Hello_ProcessEvent(uint8 task_id, uint16 events)<br>{…}</li></ul><h2 id="HAL库之LED"><a href="#HAL库之LED" class="headerlink" title="HAL库之LED"></a>HAL库之LED</h2><ol><li>uint8 HalLedSet (uint8 leds, uint8 mode)</li></ol><table><thead><tr><th>ModeName</th><th>作用</th></tr></thead><tbody><tr><td>HAL_LED_MODE_BLINK</td><td>闪烁  (一次)</td></tr><tr><td>HAL_LED_MODE_FLASH</td><td>闪烁</td></tr><tr><td>HAL_LED_MODE_ON</td><td></td></tr><tr><td>HAL_LED_MODE_OFF</td><td></td></tr><tr><td>HAL_LED_MODE_TOGGLE</td><td>触发</td></tr></tbody></table><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><ol><li><p>uint8 osal_start_timerEx( uint8 taskID, uint16 event_id, uint16 timeout_value )</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//为指定的任务设置定时器</span><br><br>osal_start_timerEx(task_id, <span class="hljs-number">0x0001</span>, <span class="hljs-number">10000</span>);<br></code></pre></td></tr></table></figure></li><li></li></ol><h2 id="PAN-ID"><a href="#PAN-ID" class="headerlink" title="PAN_ID"></a>PAN_ID</h2><ul><li><p>全称 Personal Area Network (网络标识符)</p></li><li><p>相当于网络号，网段。</p></li></ul><p>Tools\f8Config.cfgLine59</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Define the default PAN ID.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Setting this to a value other than 0xFFFF causes</span><br><span class="hljs-comment"> * ZDO_COORD to use this value as its PAN ID and</span><br><span class="hljs-comment"> * Routers and end devices to join PAN with this ID</span><br><span class="hljs-comment"> */</span><br>-DZDAPP_CONFIG_PAN_ID=<span class="hljs-number">0x0010</span><br></code></pre></td></tr></table></figure><h2 id="Z-Stack开发步骤"><a href="#Z-Stack开发步骤" class="headerlink" title="Z-Stack开发步骤"></a>Z-Stack开发步骤</h2><h3 id="功能类型定义"><a href="#功能类型定义" class="headerlink" title="功能类型定义"></a>功能类型定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 功能类型值定义</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    DevTemp = <span class="hljs-number">1</span>,<br>    DevHumm,<br><span class="hljs-comment">//略---------------------</span><br>    DevMaxNum<br>&#125;;<br></code></pre></td></tr></table></figure><p>枚举功能类型值，需要时添加即可。</p><h3 id="定义节点功能列表"><a href="#定义节点功能列表" class="headerlink" title="定义节点功能列表"></a>定义节点功能列表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/***************************************************/</span><br><span class="hljs-comment">/* 节点功能列表                                    */</span><br><span class="hljs-comment">/***************************************************/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ep_info_t</span> <span class="hljs-title">funcList</span>[] =</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(HAS_GAS)</span><br>    &#123;<br>        <span class="hljs-comment">//stat,income,timeout,resource</span><br>        <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, sensorGasTimeout, sensorGasResAvailable,<br>        &#123; DevGas, <span class="hljs-number">0</span>, <span class="hljs-number">3</span> &#125;,                   <span class="hljs-comment">// type, id, refresh cycle</span><br>    &#125;,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-comment">//略----------------</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(ZDO_COORDINATOR)</span><br>    &#123;   <span class="hljs-comment">// 协调器</span><br>        CoordinatorNwkStateChangeRoutine,<br>        CoordinatorIncomingRoutine,<br>        CoordinatorTimeoutRoutine,<br>        CoordinatorResAvailableRoutine,<br>        &#123; DevCoordinator, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;,<br>    &#125;,<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(RTR_NWK)</span><br>    &#123;   <span class="hljs-comment">// 路由器</span><br>        RouterNwkStateChangeRoutine,<br>        RouterIncomingRoutine,<br>        RouterTimeoutRoutine,<br>        RouterResAvailableRoutine,<br>        &#123; DevRouter, <span class="hljs-number">0</span>, <span class="hljs-number">30</span> &#125;,<br>    &#125;,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p>功能列表</p></li><li><p>参考下面的 <strong>ep_info_t</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 不能修改下面的内容!!!</span><br><span class="hljs-type">const</span> uint8 funcCount = <span class="hljs-keyword">sizeof</span>(funcList) / <span class="hljs-keyword">sizeof</span>(funcList[<span class="hljs-number">0</span>]);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><br></code></pre></td></tr></table></figure></li><li><p>功能数量</p></li><li></li></ul><h3 id="ep-info-t"><a href="#ep-info-t" class="headerlink" title="ep_info_t"></a>ep_info_t</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ep_info_t</span> &#123;</span><br>    <span class="hljs-comment">// 网络状态发生变化时会调用该函数</span><br>    <span class="hljs-type">void</span> (*nwk_stat_change)(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep);<br>    <span class="hljs-comment">// 接收到数据时会调用该函数</span><br>    <span class="hljs-type">void</span> (*incoming_data)(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg);<br>    <span class="hljs-comment">// 周期性调用的函数</span><br>    <span class="hljs-type">void</span> (*time_out)(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep);<br>    <span class="hljs-comment">// 系统资源可用时调用该函数,系统资源指的是:串口接收到数据/中断等等</span><br>    <span class="hljs-type">void</span> (*res_available)(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep, RES_TYPE type, <span class="hljs-type">void</span> *res);<br>    <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> cycle成员会被用来计数,并周期性调用time_out函数</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">func_info_t</span> <span class="hljs-title">function</span>;</span><br>    <br><span class="hljs-comment">//以下数据用户不能进行更改！！！！！</span><br>    <br>    <span class="hljs-comment">// 当前端点号</span><br>    uint8 ep;<br>    <span class="hljs-comment">// 与此端点绑定的任务ID</span><br>    uint8 task_id;<br>    <span class="hljs-comment">// 递减计数,为0时调用time_out函数,并重载初值=cycle</span><br>    uint8 timerTick;<br>    uint8 userTimer;<br>    endPointDesc_t SampleApp_epDesc;<br>    SimpleDescriptionFormat_t simpleDesc;<br>&#125;;<br><br><span class="hljs-comment">//一个典型的初始化</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(ZDO_COORDINATOR)</span><br>    &#123;   <span class="hljs-comment">// 协调器</span><br>        CoordinatorNwkStateChangeRoutine,<span class="hljs-comment">//节点加入网络完成后调用</span><br>        CoordinatorIncomingRoutine,<span class="hljs-comment">//端点接收到数据后会调用</span><br>        CoordinatorTimeoutRoutine,<span class="hljs-comment">//周期调用</span><br>        CoordinatorResAvailableRoutine,<span class="hljs-comment">//系统初始化、串口收到数据、用户定时器到时 会调用</span><br>        &#123; DevCoordinator, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;,<span class="hljs-comment">//功能类型、功能编号、刷新周期</span><br>    &#125;,<br><br></code></pre></td></tr></table></figure><h4 id="nwk-stat-change"><a href="#nwk-stat-change" class="headerlink" title="nwk_stat_change"></a>nwk_stat_change</h4><p><strong>节点加入网络完成后调用</strong></p><ul><li>可用于读取当前  端点  信息</li><li></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">xxNwkStateChange</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep)</span><br>    <br><span class="hljs-type">void</span> <span class="hljs-title function_">sensorVoiceNwkStateChange</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep)</span><br>&#123;<br>    voiceEndPoint = ep;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="incoming-data"><a href="#incoming-data" class="headerlink" title="incoming_data"></a>incoming_data</h4><p><strong>端点接收到数据后会调用</strong></p><ul><li>下发的指令的处理</li><li></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">xxReceiveData</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg)</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">testReceiveData</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg)</span><br>&#123;<br>    <span class="hljs-comment">//msg-&gt;Data[0] 是接受到的总  比特   数 </span><br><span class="hljs-keyword">if</span>( (msg-&gt;Data[<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;L&#x27;</span>)&amp;&amp;(msg-&gt;Data[<span class="hljs-number">2</span>]==<span class="hljs-string">&#x27;E&#x27;</span>)&amp;&amp;(msg-&gt;Data[<span class="hljs-number">3</span>]==<span class="hljs-string">&#x27;D&#x27;</span>) )<br>    &#123;<br><span class="hljs-keyword">if</span>( msg-&gt;Data[<span class="hljs-number">4</span>]==<span class="hljs-string">&#x27;1&#x27;</span> )<br>&#123;<br>HalUARTWrite(HAL_UART_PORT_0, <span class="hljs-string">&quot;LED_1\r\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;LED_1\r\n&quot;</span>) - <span class="hljs-number">1</span>);<br><span class="hljs-comment">//HalLedBlink(HAL_LED_1, 2, 50, 100);</span><br>&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="time-out"><a href="#time-out" class="headerlink" title="time_out"></a>time_out</h4><p><strong>周期调用</strong></p><ul><li>读取传感器数据</li><li></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">xxTimeout</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep)</span><br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">sensorFireTimeout</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep)</span><br>&#123;<br>    uint8 value = FireInfo();<br>    SendData(ep-&gt;ep, &amp;value, <span class="hljs-number">0x0000</span>, TRANSFER_ENDPOINT, <span class="hljs-keyword">sizeof</span>(value));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="res-available"><a href="#res-available" class="headerlink" title="res_available"></a>res_available</h4><p><strong>系统初始化、串口收到数据、用户定时器到时 会调用</strong></p><ul><li>初始化端口、</li><li></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">xxResAvailable</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep, RES_TYPE type, <span class="hljs-type">void</span> *res)</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">sensorRainResAvailable</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep, RES_TYPE type, <span class="hljs-type">void</span> *res)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(type == ResInit)<br>    &#123;<br>        RainInit();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="IAR学习笔记"><a href="#IAR学习笔记" class="headerlink" title="IAR学习笔记"></a>IAR学习笔记</h1><h2 id="无法观察局部变量"><a href="#无法观察局部变量" class="headerlink" title="无法观察局部变量"></a>无法观察局部变量</h2><p>在软件调试的时候发现Watch窗口中无法观察局部变量的值，总是显示<unavailable><br>　　设置IAR中的”<strong>Options — c&#x2F;c++ compiler — Optimization — Level</strong>“ 选项：<br>　　Level的缺省值为Low，当我把Level选为None之后，即不执行任何优化时，全局变量、静态局部变量、局部变量的值都可以看到。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;CC2530是针对IEEE 802.15.4，Zigbee和RF4CE应用的真正片上系统（SoC）解决方案。 它能够以非常低的总物料成本构建强大的网络节点。</summary>
        
      
    
    
    
    <category term="blog" scheme="https://www.oikiou.top/categories/blog/"/>
    
    
    <category term="Embedded" scheme="https://www.oikiou.top/tags/Embedded/"/>
    
    <category term="CC2530" scheme="https://www.oikiou.top/tags/CC2530/"/>
    
    <category term="Zigbee" scheme="https://www.oikiou.top/tags/Zigbee/"/>
    
  </entry>
  
  <entry>
    <title>Hex 文件格式解析</title>
    <link href="https://www.oikiou.top/2022/d3f98b78/"/>
    <id>https://www.oikiou.top/2022/d3f98b78/</id>
    <published>2022-08-21T14:57:15.000Z</published>
    <updated>2022-09-10T05:20:07.360Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hex-文件格式解析"><a href="#Hex-文件格式解析" class="headerlink" title="Hex 文件格式解析"></a>Hex 文件格式解析</h1><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://developer.arm.com/documentation/ka003292/1-0">Intel HEX File Format Keil</a></p><p><a href="https://en.wikipedia.org/wiki/Intel_HEX">Intel HEX Wiki</a></p><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><ul><li>以行为单位，每行以冒号开头，内容全部为16进制码（以ASCII码形式显示）</li><li>在HEX文件里面，每一行代表一个记录。记录的基本格式为如表所示</li></ul><table><thead><tr><th><strong>冒号</strong></th><th><strong>本行数据长度</strong></th><th><strong>本行数据起始地址</strong></th><th><strong>数据类型</strong></th><th><strong>数据</strong></th><th><strong>校验码</strong></th></tr></thead><tbody><tr><td></td><td>1 byte</td><td>2 bytes</td><td>1 byte</td><td>n byte</td><td>1 byte</td></tr></tbody></table><p><img src="/2022/d3f98b78/hex_format.jpg"></p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Start code</td><td>one character, an ASCII colon ‘:’</td></tr><tr><td>Byte count</td><td>两个十六进制数字（一个十六进制数字对），表示数据字段中的字节数（十六进制数字对）。最大字节数为 255 (0xFF)。16 (0x10) 和 32 (0x20) 是常用的字节数。</td></tr><tr><td>Address</td><td>四位十六进制数字，表示数据的 16 位起始内存地址偏移量。数据的物理地址是通过将此偏移量添加到先前建立的基地址来计算的，从而允许内存寻址超出 16 位地址的 64 KB 限制。默认为零的基地址可以通过各种类型的记录进行更改。基地址和地址偏移量始终表示为<a href="https://en.wikipedia.org/wiki/Big_endian">大端</a>值。</td></tr><tr><td>Record type</td><td>两个十六进制数字，<em>00</em>到<em>05</em>，定义数据字段的含义。参考下文</td></tr><tr><td>Data</td><td>一个由<em>n</em>个字节组成的数据序列，由 <em>2n</em> 个十六进制数字表示。一些记录省略了这个字段（<em>n</em>等于零）。数据字节的含义和解释取决于应用程序。</td></tr><tr><td>Checksum</td><td>two hex digits, a computed value that can be used to verify the record has no errors.计算校验和前所有16进制码的累加和。</td></tr></tbody></table><h3 id="指令类型-Record-type"><a href="#指令类型-Record-type" class="headerlink" title="指令类型 Record type"></a>指令类型 Record type</h3><p>指令类型<code>Record type</code>的值一般是<code>00~05</code>，这表示了，当前这行<code>hex</code>格式的数据，所代表的含义：</p><table><thead><tr><th>十六进制代码</th><th>记录类型</th><th align="center">描述</th><th align="center">Example</th></tr></thead><tbody><tr><td><strong>00</strong></td><td>数据</td><td align="center">包含数据和该数据的16位起始地址。字节计数指定记录中的数据字节数。右侧显示的示例为0B （十一）个数据字节（61， 64， 64， 72， 65， 73， 73， 20， 67， 61， 70）位于以地址开头的连续地址 0010。</td><td align="center"><code>:0B 0010 00 6164647265737320676170 A7</code></td></tr><tr><td><strong>01</strong></td><td>文件结束</td><td align="center">每个文件在文件的最后一行必须恰好发生一次。数据字段为空（因此字节数为00），并且地址字段通常为 0000。</td><td align="center"><code>:00 0000 01 FF</code></td></tr><tr><td><strong>02</strong></td><td>扩展段地址</td><td align="center">数据字段包含一个16位的段基址（因此字节数始终为02）与80x86实模式寻址兼容。地址字段（通常为0000）被忽略。最近的段地址02记录乘以16，然后加到每个后续数据记录地址，以形成数据的物理起始地址。这允许寻址多达1 MB的地址空间。</td><td align="center"><code>:02 0000 02 1200 EA</code></td></tr><tr><td><strong>03</strong></td><td>起始段地址</td><td align="center">对于80x86处理器，请指定CS：IP寄存器的初始内容（即起始执行地址）。地址字段是0000，字节数始终为04，前两个数据字节是CS值，后两个是IP值。</td><td align="center"><code>:04 0000 03 00003800 C1</code></td></tr><tr><td><strong>04</strong></td><td>扩展线性地址</td><td align="center">允许32位寻址（最大4GiB）。记录的地址字段将被忽略（通常是0000），其字节数始终为02。两个数据字节（大字节序）为所有后续类型指定32位绝对地址的高16位00记录; 这些高位地址位适用于下一个04记录。类型的绝对地址00 通过组合最近的高16位地址位形成记录 04 用低16位的地址记录 00记录。如果是类型00 记录之前没有任何类型 04 记录，然后其高16位地址位默认为0000。</td><td align="center"><code>:02 0000 04 FFFF FC</code></td></tr><tr><td><strong>05</strong></td><td>起始线性地址</td><td align="center">地址字段是 0000（未使用），字节数始终为04。四个数据字节代表一个32位地址值（big-endian）。对于80386和更高版本的CPU，此地址将加载到EIP寄存器中。<br/><strong>（仅限 MDK-ARM）</strong>起始线性地址记录指定应用程序的起始地址。这些记录包含完整的线性 32 位地址。</td><td align="center"><code>:04 0000 05 000000CD 2A</code></td></tr></tbody></table><h5 id="扩展线性地址记录-HEX386"><a href="#扩展线性地址记录-HEX386" class="headerlink" title="扩展线性地址记录 (HEX386)"></a>扩展线性地址记录 (HEX386)</h5><p>扩展线性地址记录也称为 32 位地址记录和 HEX386 记录。这些记录包含数据地址的高 16 位（位 16-31）。扩展线性地址记录总是有两个数据字节，如下所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">:02000004FFFFFC<br></code></pre></td></tr></table></figure><p>在哪里：</p><ul><li><strong>02</strong>是记录中的数据字节数。</li><li><strong>0000</strong>是地址字段。对于扩展线性地址记录，此字段始终为 0000。</li><li><strong>04</strong>是记录类型 04（扩展的线性地址记录）。</li><li><strong>FFFF</strong>是地址的高 16 位。</li><li><strong>FC</strong>是记录的校验和，计算方式为<br>01h + NOT(02h + 00h + 00h + 04h + FFh + FFh)。</li></ul><p>读取扩展线性地址记录时，存储在数据字段中的扩展线性地址将被保存并应用于从 Intel HEX 文件读取的后续记录。线性地址保持有效，直到被另一个扩展地址记录改变。</p><p>数据记录的绝对内存地址是通过将记录中的地址字段与扩展线性地址记录的移位地址数据相加得到的。下面的例子说明了这个过程。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-type">Address</span> from the <span class="hljs-class"><span class="hljs-keyword">data</span> record&#x27;s address field      2462</span><br><span class="hljs-type">Extended</span> linear address record <span class="hljs-class"><span class="hljs-keyword">data</span> field     <span class="hljs-type">FFFF</span></span><br>                                              <span class="hljs-comment">--------</span><br><span class="hljs-type">Absolute</span>-memory address                       <span class="hljs-type">FFFF2462</span><br></code></pre></td></tr></table></figure><h5 id="扩展段地址记录-HEX86"><a href="#扩展段地址记录-HEX86" class="headerlink" title="扩展段地址记录 (HEX86)"></a>扩展段地址记录 (HEX86)</h5><p>扩展段地址记录（也称为 HEX86 记录）包含数据地址段的第 4-19 位。扩展段地址记录总是有两个数据字节，如下所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">:020000021200EA<br></code></pre></td></tr></table></figure><p>在哪里：</p><ul><li><strong>02</strong>是记录中的数据字节数。</li><li><strong>0000</strong>是地址字段。对于扩展段地址记录，该字段始终为 0000。</li><li><strong>02</strong>是记录类型 02（扩展段地址记录）。</li><li><strong>1200</strong>是地址段。</li><li><strong>EA</strong>是记录的校验和，计算方式为<br>01h + NOT(02h + 00h + 00h + 02h + 12h + 00h)。</li></ul><p>当读取扩展段地址记录时，存储在数据字段中的扩展段地址被保存并应用于从 Intel HEX 文件读取的后续记录。段地址保持有效，直到被另一个扩展地址记录改变。</p><p>数据记录的绝对内存地址是通过将记录中的地址字段添加到来自扩展段地址记录的移位地址数据中获得的。以下示例说明了此过程。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-type">Address</span> from the <span class="hljs-class"><span class="hljs-keyword">data</span> record&#x27;s address field     2462</span><br><span class="hljs-type">Extended</span> segment address record <span class="hljs-class"><span class="hljs-keyword">data</span> field      1200</span><br>                                             <span class="hljs-comment">--------</span><br><span class="hljs-type">Absolute</span> memory address                      <span class="hljs-number">00014462</span><br></code></pre></td></tr></table></figure><h5 id="起始线性地址记录（仅限-MDK-ARM）"><a href="#起始线性地址记录（仅限-MDK-ARM）" class="headerlink" title="起始线性地址记录（仅限 MDK-ARM）"></a>起始线性地址记录（仅限 MDK-ARM）</h5><p>起始线性地址记录指定应用程序的起始地址。这些记录包含完整的线性 32 位地址。起始线性地址记录总是有四个数据字节，如下所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">:04000005000000CD2A<br></code></pre></td></tr></table></figure><p>在哪里：</p><ul><li><strong>04</strong>是记录中的数据字节数。</li><li><strong>0000</strong>是地址字段。对于起始线性地址记录，该字段始终为 0000。</li><li><strong>05</strong>是记录类型 05（起始线性地址记录）。</li><li><strong>000000CD</strong>是应用程序的 4 字节线性起始地址。</li><li><strong>2A</strong>是记录的校验和，计算方式为<br>01h + NOT(04h + 00h + 00h + 05h + 00h + 00h + 00h + CDh)。</li></ul><p>Start Linear Address 指定了 __main（pre-main）函数的地址，而不是通常在调用 SystemInit() 之后调用 __main 的启动代码的地址。奇数线性起始地址指定 __main 是为 Thumb 指令集编译的。</p><p>起始线性地址记录可以出现在 hex 文件中的任何位置。在大多数情况下，可以忽略此记录，因为它不包含对闪存进行编程所需的信息。</p><h5 id="文件结束-EOF-记录"><a href="#文件结束-EOF-记录" class="headerlink" title="文件结束 (EOF) 记录"></a>文件结束 (EOF) 记录</h5><p>英特尔 HEX 文件必须以文件结束 (EOF) 记录结尾。此记录在记录类型字段中必须具有值 01。EOF 记录始终如下所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">:00000001FF<br></code></pre></td></tr></table></figure><p>在哪里：</p><ul><li><strong>00</strong>是记录中的数据字节数。</li><li><strong>0000</strong>是数据在内存中的位置。文件尾记录中的地址是无意义的并且被忽略。地址 0000h 是典型的。</li><li><strong>01</strong>是记录类型 01（文件结束记录）。</li><li><strong>FF</strong>是记录的校验和，计算方式为<br>01h + NOT(00h + 00h + 00h + 01h)。</li></ul><h2 id="tip"><a href="#tip" class="headerlink" title="tip"></a>tip</h2><ul><li><strong>用Notepad++打开hex文件，会自动上色、换行</strong></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Hex-文件格式解析&quot;&gt;&lt;a href=&quot;#Hex-文件格式解析&quot; class=&quot;headerlink&quot; title=&quot;Hex 文件格式解析&quot;&gt;&lt;/a&gt;Hex 文件格式解析&lt;/h1&gt;&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a</summary>
        
      
    
    
    
    <category term="blog" scheme="https://www.oikiou.top/categories/blog/"/>
    
    
    <category term="Hex" scheme="https://www.oikiou.top/tags/Hex/"/>
    
  </entry>
  
  <entry>
    <title>MarkDown学习笔记</title>
    <link href="https://www.oikiou.top/2022/da7ed36c/"/>
    <id>https://www.oikiou.top/2022/da7ed36c/</id>
    <published>2022-08-21T14:57:15.000Z</published>
    <updated>2022-09-14T17:36:49.074Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><p>asdasdasdasdassdasdas</p><h2 id="这是一段引用"><a href="#这是一段引用" class="headerlink" title="这是一段引用"></a>这是一段引用</h2><blockquote><p>这是一段引用</p></blockquote><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><ul><li>阿斯大声</li><li>阿斯大声打</li><li>阿斯大声问请问恶</li></ul><h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><ol><li><p>阿斯大声打</p></li><li><p>阿斯大声阿斯大声</p></li><li><p>dasd阿斯dasdaaa</p></li></ol><h2 id="斜体-和-加粗-强调"><a href="#斜体-和-加粗-强调" class="headerlink" title="斜体 和 加粗 (强调)"></a>斜体 和 加粗 (强调)</h2><p>这是<em>斜体</em>      这是<strong>加粗</strong>   这是_什么呢_  好像也__是一样的__</p><h2 id="这段是横线"><a href="#这段是横线" class="headerlink" title="这段是横线"></a>这段是横线</h2><hr><hr><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p><a href="./assets/00.jpg">这是超链接</a></p><p><a href=".%5Cassets%5C00.jpg">www.Baidu.com</a></p><p><a href="https://sigrok.org/wiki/Protocol_decoder_API">这是一个超链接 （注意链接前后不要留空格）</a></p><p>This is <a href="http://example.com/" title="Optional Title Here">an example</a> reference-style link.</p><h2 id="文章内的超链接"><a href="#文章内的超链接" class="headerlink" title="文章内的超链接"></a><a id="文章内的超链接">文章内的超链接</a></h2><p> <a href="##%E8%A1%A8%E6%A0%BC">这是一个文章内部的超链接</a></p><p> Ctrl+左键  </p><p><a href="#HTML跳转">回到-&gt;HTML 跳转</a></p><h2 id="Email-链接"><a href="#Email-链接" class="headerlink" title="Email 链接"></a>Email 链接</h2><p>作者的 Emal <a href="mailto:&#x78;&#x78;&#64;&#120;&#x78;&#x2e;&#99;&#x6f;&#109;">&#x78;&#x78;&#64;&#120;&#x78;&#x2e;&#99;&#x6f;&#109;</a> 链接</p><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><ul><li>内联风格</li></ul><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1557132849466&di=61258032fff80f7d4bfff0ad0b325b12&imgtype=0&src=http://s6.sinaimg.cn/middle/6dca756dhad5c3293f515&690" alt="iPhone"></p><ul><li>引用风格</li></ul><p><strong>一直没弄出来</strong></p><p>xxx<img src="/photo_id" alt="photo_id"></p><h2 id="代码块-与-代码行"><a href="#代码块-与-代码行" class="headerlink" title="代码块 与 代码行"></a>代码块 与 代码行</h2><p><code>  delay_init();     //延时函数初始化</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>delay_init();     <span class="hljs-comment">//延时函数初始化</span><br>TIM_ALL_Init();<br> LED_Init();     <span class="hljs-comment">//LED端口初始化</span><br>LCD_Init();<br>POINT_COLOR=WHITE;<br>BACK_COLOR = BLACK;<br>LCD_Clear(BLACK);<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><table><thead><tr><th>name</th><th>age</th><th>sex</th></tr></thead><tbody><tr><td>Done</td><td>20</td><td>0</td></tr><tr><td>Jack</td><td>21</td><td>0</td></tr><tr><td>Done<br/>这里换行了</td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><p><del>这是一条删除             线线线线线线线线线线线线线线线</del></p><h2 id="这是一个注释"><a href="#这是一个注释" class="headerlink" title="这是一个注释"></a>这是一个注释</h2><p>[注释] <a href="%E8%BF%99%E6%98%AF%E6%B3%A8%E9%87%8A%E7%9A%84%E8%A7%A3%E9%87%8A">^注释</a>:Somebody that I used to know.</p><h2 id="数学表达式"><a href="#数学表达式" class="headerlink" title="数学表达式"></a>数学表达式</h2><p>$ (h&#x2F;2)<em>(a+9)&#x2F;(b</em>9))*L $</p><p>$lim_{x \to \infty} \ exp(-x)&#x3D;0$</p><h2 id="修改文字颜色-HTLML"><a href="#修改文字颜色-HTLML" class="headerlink" title="修改文字颜色 HTLML"></a>修改文字颜色 HTLML</h2><p>You can use HTML to style content what pure Markdown does not support.</p><p><span style="color:red"><strong>TEXT Style</strong></span></p><p><span style="color:#29b6f6"> <strong>TEXT Style</strong> </span></p><p><span style="color:rgb(255, 255, 255)"><strong>TEXT Style</strong></span></p><p><span style="color:LightPink"> <strong>TEXT Style</strong> </span></p><p><span style="color:Thistle"> <strong>TEXT Style</strong> </span></p><p><span style="color:Gold"> <strong>TEXT Style</strong> </span></p><p><span style="color:Tomato"> <strong>TEXT Style</strong> </span></p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:red&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:#29b6f6&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:rgb(255, 255, 255)&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><br>https://www.5tu.cn/colors/yansezhongwenming.html<br></code></pre></td></tr></table></figure><p>For example, use <code>&lt;span style=&quot;color:red&quot;&gt;this text is red&lt;/span&gt;</code> to add text with red color.</p><h2 id="表情-Emoji-smile"><a href="#表情-Emoji-smile" class="headerlink" title="表情 Emoji :smile:"></a>表情 Emoji :smile:</h2><p>Input emoji with syntax <code>:smile:</code>.</p><p>User can trigger auto-complete suggestions for emoji by pressing <code>ESC</code> key, or trigger it automatically after enabling it on preference panel. Also, inputting UTF-8 emoji characters directly is also supported by going to <code>Edit</code> -&gt; <code>Emoji &amp; Symbols</code> in the menu bar (macOS).</p><h2 id="Task-List-带勾的计划任务-勾选框"><a href="#Task-List-带勾的计划任务-勾选框" class="headerlink" title="Task List 带勾的计划任务 勾选框"></a>Task List 带勾的计划任务 勾选框</h2><ul><li><input disabled="" type="checkbox"> a task list item</li><li><input disabled="" type="checkbox"> list syntax required </li><li><input checked="" disabled="" type="checkbox"> completed</li></ul><p>注意    [内有一个空格] </p><h2 id="Video"><a href="#Video" class="headerlink" title="Video"></a>Video</h2><p>You can use the <code>&lt;video&gt;</code> HTML tag to embed videos. For example:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Markdown"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;xxx.mp4&quot;</span> /&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">文字[^脚注1]文字.<br>[<span class="hljs-symbol">^脚注1</span>]:<span class="hljs-link">这是脚注1的内容</span><br></code></pre></td></tr></table></figure><p>文字<a href="%E8%BF%99%E6%98%AF%E8%84%9A%E6%B3%A81%E7%9A%84%E5%86%85%E5%AE%B9">^脚注1</a>文字.</p><h2 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h2><p><strong>1.实现下标与上标的三种方法：</strong></p><ul><li><p>方法1（符号）：(这是Markdown的拓展语法)</p><figure class="highlight parser3"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs parser3"><span class="language-xml">下标 ：θ~</span><span class="hljs-number">1</span><span class="language-xml">~ </span><br><span class="language-xml">上标 ：θ</span><span class="hljs-keyword">^2</span><span class="language-xml">^</span><br><span class="language-xml"></span><span class="hljs-number">12</span><br></code></pre></td></tr></table></figure></li><li><p>结果如下：<br>下标 ：θ<del>1</del><br>上标 ：θ^2^</p></li><li><p>方法2（HTML标签）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml">下标 ：θ<span class="hljs-tag">&lt;<span class="hljs-name">sub</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">sub</span>&gt;</span><br>上标 ：θ<span class="hljs-tag">&lt;<span class="hljs-name">sup</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">sup</span>&gt;</span><br>12<br></code></pre></td></tr></table></figure></li><li><p>结果如下：<br>下标 ：θ<sub>1</sub><br>上标 ：θ<sup>2</sup></p></li><li><p>方法3（公式块）：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br>下标 ：θ_1 ，上标 ：θ^<span class="hljs-number">2</span><br><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure></li><li><p>结果如下：</p></li><li><p>$$<br>下标 ：θ_1 ，上标 ：θ^2<br>$$</p></li></ul><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><h2 id="HTML-跳转"><a href="#HTML-跳转" class="headerlink" title="HTML 跳转"></a><a id="HTML跳转">HTML 跳转</a></h2><p><a href="#文章内的超链接">点击到达-&gt;文章内的超链接</a> </p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">&lt;<span class="hljs-keyword">a</span> href=<span class="hljs-string">&quot;#demo&quot;</span>&gt;点击到达跳转位置演示&lt;/<span class="hljs-keyword">a</span>&gt; <span class="hljs-comment"># 在需要跳转的地方添加此代码。</span><br>&lt;<span class="hljs-keyword">a</span> id=<span class="hljs-string">&quot;demo&quot;</span>&gt;跳转位置演示（跳转位置设置点）&lt;/<span class="hljs-keyword">a</span>&gt; <span class="hljs-comment"># 在跳转位置添加次代码。</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;一级标题&quot;&gt;&lt;a href=&quot;#一级标题&quot; class=&quot;headerlink&quot; title=&quot;一级标题&quot;&gt;&lt;/a&gt;一级标题&lt;/h1&gt;&lt;h2 id=&quot;二级标题&quot;&gt;&lt;a href=&quot;#二级标题&quot;</summary>
        
      
    
    
    
    <category term="blog" scheme="https://www.oikiou.top/categories/blog/"/>
    
    
    <category term="MarkDown" scheme="https://www.oikiou.top/tags/MarkDown/"/>
    
    <category term="note" scheme="https://www.oikiou.top/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>SSL证书的申请和自动续期</title>
    <link href="https://www.oikiou.top/2022/82aca4fc/"/>
    <id>https://www.oikiou.top/2022/82aca4fc/</id>
    <published>2022-08-21T14:57:15.000Z</published>
    <updated>2022-09-10T05:20:07.364Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SSL证书的申请和自动续期"><a href="#SSL证书的申请和自动续期" class="headerlink" title="SSL证书的申请和自动续期"></a>SSL证书的申请和自动续期</h1><p>Let’s Encrypt 证书续期</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/a2d0209fa3f5">https://www.jianshu.com/p/a2d0209fa3f5</a></p><p><a href="https://www.cnblogs.com/esofar/p/9291685.html">快速签发 Let’s Encrypt 证书指南</a></p><p><a href="https://certbot.eff.org/">https://certbot.eff.org/</a></p><h1 id="acme-sh-申请"><a href="#acme-sh-申请" class="headerlink" title="acme.sh 申请"></a>acme.sh 申请</h1><p>用 acme.sh申请来自动续期ssl证书<br> acme说明：<a href="https://links.jianshu.com/go?to=https://github.com/Neilpang/acme.sh/wiki/%E8%AF%B4%E6%98%8E">https://github.com/Neilpang/acme.sh/wiki/说明</a></p><ol><li>下载acme<code>curl https://get.acme.sh | sh</code>  安装完成后必须关闭当前终端，重新开启一个以使acme.sh命令生效</li><li>执行生成和自动更新命令：<code>acme.sh --issue -d mydomain.com -d www.mydomain.com --webroot /var/www/mydomain.com/</code></li><li>安装证书 <code>cd /etc/nginx; mkdir ssl</code></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">acme.sh  --installcert  -d  <span class="hljs-tag">&lt;<span class="hljs-name">domain</span>&gt;</span>.com   \<br>        --key-file   /etc/nginx/ssl/<span class="hljs-tag">&lt;<span class="hljs-name">domain</span>&gt;</span>.key \<br>        --fullchain-file /etc/nginx/ssl/fullchain.cer \<br>        --reloadcmd  &quot;service nginx force-reload&quot;<br></code></pre></td></tr></table></figure><ol start="4"><li>配置nginx使用ssl</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash">server &#123;<br>    listen 80 default_server;<br>    listen 443 http2 ssl;<br>    listen [::]:80 default_server;<br><br>    ssl_certificate /etc/nginx/ssl/fullchain.cer;<br>    ssl_certificate_key /etc/nginx/ssl/domain.key;<br>    <span class="hljs-comment">#http转https</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable">$scheme</span> = http ) &#123;<span class="hljs-built_in">return</span> 301 https://$host<span class="hljs-variable">$request_uri</span>;&#125;<br>    root /var/www/html;<br><br>    index index.html index.htm index.nginx-debian.html;<br>    server_name _;<br><br>    ssl_certificate /etc/nginx/ssl/fullchain.cer;<br>    ssl_certificate_key /etc/nginx/ssl/domain.key;<br><br>    location /test &#123;<br>          proxy_pass       http://127.0.0.1:3000;<br>          proxy_http_version 1.1;<br>          proxy_set_header Upgrade <span class="hljs-variable">$http_upgrade</span>;<br>          proxy_set_header Connection <span class="hljs-string">&quot;upgrade&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>前端的Upgrade请求发送给后端服务器，Upgrade和Connection的头信息必须被显式的设置。一旦我们完成以上设置，NGINX就可以处理WebSocket连接了。查看配置在哪里<code>ps -ef|grep nginx</code><br> 多个域名的话，配多个nginx.conf配置。</p><ol start="5"><li>查看是否有每日任务<br> <code>crontab -l #查看你的任务</code><br> 手动更新证书<code>acme.sh --renew -d domain.com</code></li></ol><h1 id="certbot"><a href="#certbot" class="headerlink" title="certbot"></a>certbot</h1><p><a href="https://certbot.eff.org/">文档</a></p><p>Ubuntu + nginx <a href="https://certbot.eff.org/instructions?ws=nginx&amp;os=ubuntufocal">https://certbot.eff.org/instructions?ws=nginx&amp;os=ubuntufocal</a></p><p>用certbot来自动续期ssl证书</p><ul><li>需要注意的是安装证书的时候最好把nginx关掉先</li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;SSL证书的申请和自动续期&quot;&gt;&lt;a href=&quot;#SSL证书的申请和自动续期&quot; class=&quot;headerlink&quot; title=&quot;SSL证书的申请和自动续期&quot;&gt;&lt;/a&gt;SSL证书的申请和自动续期&lt;/h1&gt;&lt;p&gt;Let’s</summary>
        
      
    
    
    
    <category term="blog" scheme="https://www.oikiou.top/categories/blog/"/>
    
    
    <category term="SSL" scheme="https://www.oikiou.top/tags/SSL/"/>
    
    <category term="HTTPS" scheme="https://www.oikiou.top/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>OSI</title>
    <link href="https://www.oikiou.top/2022/1a11e44c/"/>
    <id>https://www.oikiou.top/2022/1a11e44c/</id>
    <published>2022-08-21T14:57:15.000Z</published>
    <updated>2022-09-10T05:20:07.363Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OSI"><a href="#OSI" class="headerlink" title="OSI"></a>OSI</h1><p>开放系统互联参考模型(OSI Referenec Model)，即我们通常所说的网络互联的七层框架，它是国际标准组织(International Organization for Standization)于1977年提出的标准，又称为ISO&#x2F;IEC 7498或X.200建议。值得注意的是，OSI并没有提供一个可以实现的方法，它不是一个标准而只是一个制定标准时使用的概念性的框架，更不是一个网络协议。</p><ol><li>物理层(Physical Layer)：主要功能为定义了网络的物理结构，传输的电磁标准，Bit流的编码及网络的时间原则，如分时复用及分频复用。决定了网络连接类型(端到端或多端连接)及物理拓扑结构。说的通俗一些，这一层主要负责实际的<a href="https://product.pconline.com.cn/itbk/sjtx/sj/1203/2699254.html">信号</a>传输。</li><li>数据链路层(D<a href="https://product.pconline.com.cn/itbk/diy/mb/1107/2474080.html">ata</a> Link eview)：在两个主机上建立数据链路连接，向物理层传输数据信号，并对信号进行处理使之无差错并合理的传输</li><li>网络层(Network Layer)：主要负责路由，选择合适的路径，进行阻塞控制等功能。</li><li>传输层(Transfer Layer)：最关键的一层，向拥护提供可靠的端到端(End-to-End)服务，它屏蔽了下层的数据通信细节，让用户及应用程序不需要考虑实际的通信方法。</li><li>会话层(Session Layer)：主要负责两个会话进程之间的通信，即两个会话层实体之间的信息交换，管理数据的交换。</li><li>表示层(Presentation Layer)：处理通信信号的表示方法，进行不同的格式之间的翻译，并负责数据的加密解密，数据的压缩与恢复</li><li>应用层(Application Layer)：保持应用程序之间建立连接所需要的数据记录，为用户服务。 三大协议NetBEUI和 IPX&#x2F;SPX TCP&#x2F;IP</li></ol><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td></td></tr><tr><td>应用层(Application Layer)</td><td>消息</td></tr><tr><td>表示层(Presentation Layer)</td><td></td></tr><tr><td>会话层(Session Layer)</td><td></td></tr><tr><td>传输层(Transfer Layer)</td><td>数据段(segment)</td></tr><tr><td>网络层(Network Layer)</td><td>分组、数据包（packet）</td></tr><tr><td>链路层(Data Link eview)</td><td>帧（frame）</td></tr><tr><td>物理层(Physical Layer)</td><td>P-PDU（bit）</td></tr></tbody></table>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;OSI&quot;&gt;&lt;a href=&quot;#OSI&quot; class=&quot;headerlink&quot; title=&quot;OSI&quot;&gt;&lt;/a&gt;OSI&lt;/h1&gt;&lt;p&gt;开放系统互联参考模型(OSI Referenec</summary>
        
      
    
    
    
    <category term="blog" scheme="https://www.oikiou.top/categories/blog/"/>
    
    
    <category term="OSI" scheme="https://www.oikiou.top/tags/OSI/"/>
    
  </entry>
  
  <entry>
    <title>Tags Label Category</title>
    <link href="https://www.oikiou.top/2022/c65e1067/"/>
    <id>https://www.oikiou.top/2022/c65e1067/</id>
    <published>2022-08-21T14:57:15.000Z</published>
    <updated>2022-09-13T12:45:40.152Z</updated>
    
    <content type="html"><![CDATA[<p>知乎  <a href="https://www.zhihu.com/people/songvision">千鸟</a></p><blockquote><p>  这问题要分两个层面来解读：</p><p>  <strong>首先是Tag与Category的区别。</strong>Category往往限制在一个维度里，当树状结构复杂到不可调和时，出现瓶颈是迟早的事。Category的问题在于，既不能完全满足用户需求，也不能完全表达创建者对内容属性的认知。而Tag反之都成立，完全互补。</p><p>  <strong>其次是Label与Tag的区别。</strong>于对内容的概括出现偏差，但显然这种问题不是tag，在内容组织范畴那应该是什么？答案就是label，除产品描述，其应用范畴还涉及功能名称、模块名称、导航名称、引导文字等等场景。我认为tag与label之间有三个显著差异：</p><ol><li>label是本身的，tag是附加的；</li><li>label强调是一种标志，tag强调是一种记号；</li><li>label标明信息之间的归属，tag区别信息之间的差异。</li></ol></blockquote><p>知乎 郑讯</p><blockquote><p>  Tag，标签，一般包含一段内容的属性，可以是分类，可以是话题，也可以是作者，地理信息等。</p><p>  Label，标记，是网页框架中一个区域的功能概括。比如知乎首页上的“浏览”、“问题”、“通知”就是label。选择不同的标记，相应区域的功能就会发生变化。</p><p>  category，分类，可以理解为种属概念。一段内容有且只有一个种属的分类。和Tag不同的是一段内容可以有多个tag，并且tag是未预先设定的，一段内容可以有多个Tag，也可以没有Tag。但caterory在一个分类标准下只有一个。</p></blockquote><p>知乎 李楠</p><blockquote><p>  <strong>Category</strong></p><p>  Category 是非常理想化和一根筋的分类方式。图书馆这种死板到头的地方用的多。但是他们也遇到了问题：“苏菲的世界”到底是“哲学”，还是“文学”？</p><p>  物理世界无力从根本上解决这种问题（但似乎不少讨论）。问过我们学校的图书馆，似乎他们方式还比较靠谱：<strong>买两本，两处放。</strong></p><p>  分类对象数字化之后， Category 的影响还在（早期的门户找点跨界的东西就很悲剧）。直到 Web2.0 ， Tag 竟然才开始流行。</p><p>  <strong>Tag</strong></p><p>  Tag 是更好的分类方式的原因是：</p><p>  1</p><p>  “类别”本来就不应该事先定义：人不是上帝。</p><p>  从一个个具体对象的“属性”中，总结出“类别”是最自然的模式。也是“人”可以做到的事情。</p><p>  2</p><p>  “属性”本来就应该可以自然的表现为多个。</p><p>  苏菲的世界终于可以自然的打上“哲学”和“文学”的 Tag 了，或者再加个“少儿读物”。这种思考方式比 Category 优雅太多。</p><p>  Tag 最终普及，背后恐怕有<a href="https://www.zhihu.com/search?q=%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:12226710%7D">软件工程</a>上 OO 普及（面向对象）的因素。<strong>“面向对象”不仅仅是的程序构建方式，更是认识世界的方法论的进步。</strong></p><p>  “属性”跟随“对象”，比“对象”属于“类别”更自然，不机械。 。</p><p>  <strong>Tag 的改进</strong></p><p>  Tag 本身也可以看作“对象”。</p><p>  那么就有针对 Tag 的操作，比如“搜索”，“排序”，“关联对象”。也有 Tag 本身的属性，比如“使用次数”，“关注人数”等等。</p><p>  如何能在使用 Tag 的系统中，根据这些数据，计算出最适合的对象，就要靠算法的优化和运营的调整了。</p></blockquote><p>知乎 <a href="https://www.zhihu.com/people/zheng-wei-42-9">榆木脑袋</a></p><blockquote><p>  Catagory是逻辑清晰的。Tag是随意自由的。在看到一个信息的时候我们需要自由捕获自己头脑中的闪光。在重新审视或再利用我们收集的信息时，就需要清晰的逻辑条理。</p><p>  以文件管理为例：</p><p>  在标记Tag时需求有二：一是能够方便增加新的Tag，二是能够很方便的看到已有的Tag，并能同时把已有标签赋予当前信息。</p><p>  在查找文件时个人觉得需要有的功能是：一是有固定的几个入口，也就是根目录；二是可以增加根节点；三是根目录可以指定某几个Tag，也可以不是；三如果根目录不是Tag，需要定义关联到此根目录（分类）下的Tag；四（重点功能）根目录下不直接列出信息或文件（时间长了，某一Tag下文件会相当多），而是列出关联Tag的所有文件的其它Tag，显示为子目录，并标识出此子目录中的文件数量。五（作为管理功能）此时可以定义哪些Tag不在此根目录下出现。六设置某个Tag或某类Tag(文件数量大过一个数量)下仍不列出文件而是继续列出Tag；七子目录（Tag）下，上级目录Tag不再出现。</p><p>  我个人非常偏好使用树形目录结构，但苦恼于文件的多重分类和文件进行多重分类时的繁琐。经过多方搜索只找到三个比较符合的软件，一个是PinKM，一个是蓝码动力图片管理软件，一个是国外的Tabbles。但都因标签管理和整理的繁琐而放弃。</p></blockquote><p><strong>个人理解</strong></p><ul><li>Catagory 是属于严格的分类方法, 一个东西应当只属于一个Catagory内, 而且它是有层级关系的</li><li>Tags 是可有可无的, 一个东西可以有很多的Tags, 它是无层级关系的,</li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;知乎  &lt;a href=&quot;https://www.zhihu.com/people/songvision&quot;&gt;千鸟&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;  这问题要分两个层面来解读：&lt;/p&gt;
&lt;p&gt; </summary>
        
      
    
    
    
    <category term="blog" scheme="https://www.oikiou.top/categories/blog/"/>
    
    
    <category term="Tags" scheme="https://www.oikiou.top/tags/Tags/"/>
    
    <category term="Label" scheme="https://www.oikiou.top/tags/Label/"/>
    
    <category term="Category" scheme="https://www.oikiou.top/tags/Category/"/>
    
  </entry>
  
  <entry>
    <title>USART硬件流控制</title>
    <link href="https://www.oikiou.top/2022/3b631eba/"/>
    <id>https://www.oikiou.top/2022/3b631eba/</id>
    <published>2022-08-21T14:57:15.000Z</published>
    <updated>2022-09-10T05:20:07.365Z</updated>
    
    <content type="html"><![CDATA[<h1 id="USART硬件流控制"><a href="#USART硬件流控制" class="headerlink" title="USART硬件流控制"></a>USART硬件流控制</h1><p><img src="/2022/3b631eba/SouthEast.jpeg"></p><p>RS232 DB9定义</p><p>1 CD ← Carrier Detect 载波检测</p><p>2 RXD ← Receive Data 接收数据</p><p>3 TXD → Transmit Data 发送数据</p><p>4 <strong>DTR → Data Terminal Ready数据终端就绪</strong></p><p>5 GND — System Ground 系统接地</p><p>6 DSR ← Data Set Ready 数据设备就绪</p><p>7 <strong>RTS → Request To Send 请求发送</strong></p><p>8 CTS ← Clear To Send 清除发送(允许发送)</p><p>9 RI → 振铃指示</p><h2 id="RTS-CTS"><a href="#RTS-CTS" class="headerlink" title="RTS CTS"></a>RTS CTS</h2><ul><li>RTS （Require ToSend，发送请求）为输出信号，用于指示本设备准备好可接收数据，低电平有效，低电平说明本设备可以接收数据。</li><li>CTS （Clear ToSend，发送允许）为输入信号，用于判断是否可以向对方发送数据，低电平有效，低电平说明本设备可以向对方发送数据。</li></ul><h2 id="DTR-DSR"><a href="#DTR-DSR" class="headerlink" title="DTR DSR"></a>DTR DSR</h2>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;USART硬件流控制&quot;&gt;&lt;a href=&quot;#USART硬件流控制&quot; class=&quot;headerlink&quot; title=&quot;USART硬件流控制&quot;&gt;&lt;/a&gt;USART硬件流控制&lt;/h1&gt;&lt;p&gt;&lt;img</summary>
        
      
    
    
    
    <category term="blog" scheme="https://www.oikiou.top/categories/blog/"/>
    
    
    <category term="USART" scheme="https://www.oikiou.top/tags/USART/"/>
    
    <category term="RTS" scheme="https://www.oikiou.top/tags/RTS/"/>
    
    <category term="CTS" scheme="https://www.oikiou.top/tags/CTS/"/>
    
    <category term="DTR" scheme="https://www.oikiou.top/tags/DTR/"/>
    
    <category term="DSR" scheme="https://www.oikiou.top/tags/DSR/"/>
    
  </entry>
  
  <entry>
    <title>VScode插件CommentTranslate在WSL内无效</title>
    <link href="https://www.oikiou.top/2022/1d3ed0f3/"/>
    <id>https://www.oikiou.top/2022/1d3ed0f3/</id>
    <published>2022-08-21T14:57:15.000Z</published>
    <updated>2022-09-14T17:36:49.075Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VScode插件CommentTranslate在WSL内无效"><a href="#VScode插件CommentTranslate在WSL内无效" class="headerlink" title="VScode插件CommentTranslate在WSL内无效"></a>VScode插件CommentTranslate在WSL内无效</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/intellism/vscode-comment-translate/issues/64">https://github.com/intellism/vscode-comment-translate/issues/64</a></p><ol><li><p>找到相关语言语法规则文件。如C&#x2F;CPP、bat、css、java、python，这些文件都是在Windows版本的VSCode中内置的，文件路径在 <code>C:\Users\ **userNmae** \AppData\Local\Programs\Microsoft VS Code\resources\app\extensions</code>改过安装路径的是<code>Microsoft VS Code\resources\app\extensions</code></p><p><img src="/2022/1d3ed0f3/image-20220811202401467.png" alt="image-20220811202401467"></p></li></ol><p>​</p><ol><li><p>将语法规则的<strong>高亮规则</strong>文件夹拷贝到远程vscode的相关插件目录。以C语言为例，将<code>cpp</code>目录下的高亮规则文件夹<code>syntaxes</code>拷贝到远程C&#x2F;C++插件（<code>ms-vscode.cpptools-x.x.x</code>）目录下。如果你使用SSH远程，远程插件的目录在<code>~/.vscode-server/extensions/ms-vscode.cpptools-x.x.x</code>。</p><p><img src="/2022/1d3ed0f3/image-20220811202845203.png" alt="image-20220811202845203"></p></li><li><p>修改远程插件，添加语法高亮规则。修改远程插件的<code>package.json</code>文件，如C&#x2F;C++插件（<code>ms-vscode.cpptools-x.x.x</code>）目录下的<code>package.json</code>文件，将刚才cpp语法规则文件夹中的<code>package.json</code>文件的”<code>grammars</code>“部分拷贝出来，粘贴到远程插件的<code>package.json</code>的<code>contributes</code>部分中去。</p><p>如果遇到格式难以复制，可以全选内容然后按Shift+Alt+F格式化选定内容。<img src="/2022/1d3ed0f3/image-20220811202944334.png" alt="image-20220811202944334"></p></li></ol><p><img src="/2022/1d3ed0f3/image-20220811203114753.png" alt="image-20220811203114753"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-string">&quot;grammars&quot;</span>: [<br>          &#123;<br>              <span class="hljs-string">&quot;language&quot;</span>: <span class="hljs-string">&quot;c&quot;</span>,<br>              <span class="hljs-string">&quot;scopeName&quot;</span>: <span class="hljs-string">&quot;source.c&quot;</span>,<br>              <span class="hljs-string">&quot;path&quot;</span>: <span class="hljs-string">&quot;./syntaxes/c.tmLanguage.json&quot;</span><br>          &#125;,<br>          &#123;<br>              <span class="hljs-string">&quot;language&quot;</span>: <span class="hljs-string">&quot;cpp&quot;</span>,<br>              <span class="hljs-string">&quot;scopeName&quot;</span>: <span class="hljs-string">&quot;source.cpp.embedded.macro&quot;</span>,<br>              <span class="hljs-string">&quot;path&quot;</span>: <span class="hljs-string">&quot;./syntaxes/cpp.embedded.macro.tmLanguage.json&quot;</span><br>          &#125;,<br>          &#123;<br>              <span class="hljs-string">&quot;language&quot;</span>: <span class="hljs-string">&quot;cpp&quot;</span>,<br>              <span class="hljs-string">&quot;scopeName&quot;</span>: <span class="hljs-string">&quot;source.cpp&quot;</span>,<br>              <span class="hljs-string">&quot;path&quot;</span>: <span class="hljs-string">&quot;./syntaxes/cpp.tmLanguage.json&quot;</span><br>          &#125;,<br>          &#123;<br>              <span class="hljs-string">&quot;scopeName&quot;</span>: <span class="hljs-string">&quot;source.c.platform&quot;</span>,<br>              <span class="hljs-string">&quot;path&quot;</span>: <span class="hljs-string">&quot;./syntaxes/platform.tmLanguage.json&quot;</span><br>          &#125;,<br>          &#123;<br>              <span class="hljs-string">&quot;language&quot;</span>: <span class="hljs-string">&quot;cuda-cpp&quot;</span>,<br>              <span class="hljs-string">&quot;scopeName&quot;</span>: <span class="hljs-string">&quot;source.cuda-cpp&quot;</span>,<br>              <span class="hljs-string">&quot;path&quot;</span>: <span class="hljs-string">&quot;./syntaxes/cuda-cpp.tmLanguage.json&quot;</span><br>          &#125;<br>      ],<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;VScode插件CommentTranslate在WSL内无效&quot;&gt;&lt;a href=&quot;#VScode插件CommentTranslate在WSL内无效&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="blog" scheme="https://www.oikiou.top/categories/blog/"/>
    
    
    <category term="VSCode" scheme="https://www.oikiou.top/tags/VSCode/"/>
    
    <category term="CommentTranslate" scheme="https://www.oikiou.top/tags/CommentTranslate/"/>
    
    <category term="WSL" scheme="https://www.oikiou.top/tags/WSL/"/>
    
  </entry>
  
  <entry>
    <title>Windows下使用Makefile</title>
    <link href="https://www.oikiou.top/2022/714f1d49/"/>
    <id>https://www.oikiou.top/2022/714f1d49/</id>
    <published>2022-08-21T14:57:15.000Z</published>
    <updated>2022-09-10T05:20:07.368Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-安装MinGW"><a href="#1-安装MinGW" class="headerlink" title="1.安装MinGW"></a>1.安装MinGW</h1><p>在MinGW的bin目录下有一个文件叫<code>mingw32-make.exe</code> 运行它就跟<code>make</code>指令类似</p><p><img src="/2022/714f1d49/watermarkpic_center.png" alt="在这里插入图片描述"></p><h1 id="2-CMD-终端运行Makefile-mingw32-make"><a href="#2-CMD-终端运行Makefile-mingw32-make" class="headerlink" title="2. CMD 终端运行Makefile (mingw32-make)"></a>2. CMD 终端运行Makefile (mingw32-make)</h1><p>在cmd终端下直接输入<code>mingw32-make</code>然后回车就可以进行编译了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">Microsoft Windows [版本 10.0.16299.967]<br>(c) 2017 Microsoft Corporation。保留所有权利。<br><br>D:\Project\Code\C++\hello&gt; mingw32-make.exe<br>g++    -c -o main.o main.cpp<br>g++ -std=c++17 -o main main.o<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;1-安装MinGW&quot;&gt;&lt;a href=&quot;#1-安装MinGW&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="blog" scheme="https://www.oikiou.top/categories/blog/"/>
    
    
    <category term="Windows" scheme="https://www.oikiou.top/tags/Windows/"/>
    
    <category term="Makefile" scheme="https://www.oikiou.top/tags/Makefile/"/>
    
  </entry>
  
  <entry>
    <title>XIP 片内执行</title>
    <link href="https://www.oikiou.top/2022/2c1a46d6/"/>
    <id>https://www.oikiou.top/2022/2c1a46d6/</id>
    <published>2022-08-21T14:57:15.000Z</published>
    <updated>2022-09-10T05:20:07.369Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XIP-eXecute-In-Place"><a href="#XIP-eXecute-In-Place" class="headerlink" title="XIP   eXecute In Place"></a>XIP   eXecute In Place</h1><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><p>eXecute In Place，即芯片内执行，是指CPU直接从存储器中读取程序代码执行。</p><p>应用程序可以直接在flash闪存内运行，不必再把代码读到系统RAM中。flash内执行是指nor flash不需要初始化，可以直接在flash内执行代码。但往往<strong>只执行部分代码</strong>，比如<strong>初始化RAM</strong>。好处即是程序代码无需占用内存，减少内存的要求。</p><p><strong>所谓片内执行不是说程序在存储器内执行，CPU的基本功能是取指、译码、运行。Nor Flash能在芯片内执行，指的是CPU能够直接从Nor flash中取指令，供后面的译码器和执行器来使用。</strong></p><p>为实现XIP，必须满足几个条件：</p><ol><li><p>存储器必须提供与内存相似的接口给CPU。</p></li><li><p>该接口必须提供足够快的读取操作，并具有随机访问模式。</p></li><li><p>如有文件系统，则需要提供合适的映射功能</p></li><li><p>程序链接时需要知道存储器的地址或地址与位置无关。</p></li><li><p>程序不能修改已加载映像中的数据。</p></li></ol><p>NOR Flash和EEPROM通常能满足上述要求。</p><h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p><strong>nandflash也可以实现XIP</strong></p><p>“所谓XIP,就是CODE是在FLASH上直接运行. NANDFLASH只是不适合做XIP,但并不是不能做XIP“要一段CODE能够正确的运行,要保证它的CODE是连续的,正确的.由于一些电气特性的原因,NOR FLASH能够做到这一点,不存在坏道或坏块,所以能够做XIP.</p><p><strong>NOR Flash 和 NAND Flash</strong></p><p>NOR Flash具备随机读取给一个地址就能读一个数据，NAND Flash是一次读一块数据，一个地址读出一块数据。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;XIP-eXecute-In-Place&quot;&gt;&lt;a href=&quot;#XIP-eXecute-In-Place&quot; class=&quot;headerlink&quot; title=&quot;XIP   eXecute In Place&quot;&gt;&lt;/a&gt;XIP</summary>
        
      
    
    
    
    <category term="blog" scheme="https://www.oikiou.top/categories/blog/"/>
    
    
    <category term="XIP" scheme="https://www.oikiou.top/tags/XIP/"/>
    
    <category term="NOR" scheme="https://www.oikiou.top/tags/NOR/"/>
    
    <category term="NAND" scheme="https://www.oikiou.top/tags/NAND/"/>
    
  </entry>
  
  <entry>
    <title>机智云通信</title>
    <link href="https://www.oikiou.top/2022/60aa39b4/"/>
    <id>https://www.oikiou.top/2022/60aa39b4/</id>
    <published>2022-08-21T14:57:15.000Z</published>
    <updated>2022-09-10T05:20:07.387Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>包头(2B)</th><th>包长度(2B)</th><th>命令(1B)</th><th>包序号(1B)</th></tr></thead><tbody><tr><td>0xFFFF</td><td>(包长度)后面的数据长度</td><td></td><td></td></tr></tbody></table><table><thead><tr><th>Flag(2B)</th><th>xxx</th><th>校验和(1B)</th></tr></thead><tbody><tr><td></td><td></td><td>和校验</td></tr></tbody></table><p>因为包头为固定 0xFFFF，对于发送方，如检测到有出现 0xFF 的数据内容，需要在 0xFF 后添加 0x55。对于接收方，如检测到非包头部分出现 0xFF，需要把紧跟其后的 0x55 移除。</p><table><thead><tr><th>命令</th><th>内容</th></tr></thead><tbody><tr><td>0x01</td><td>设备向MCU请求信息</td></tr><tr><td>0x02</td><td>MCU回复设备</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;包头(2B)&lt;/th&gt;
&lt;th&gt;包长度(2B)&lt;/th&gt;
&lt;th&gt;命令(1B)&lt;/th&gt;
&lt;th&gt;包序号(1B)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;0x</summary>
        
      
    
    
    
    <category term="blog" scheme="https://www.oikiou.top/categories/blog/"/>
    
    
    <category term="Embedded" scheme="https://www.oikiou.top/tags/Embedded/"/>
    
    <category term="机智云" scheme="https://www.oikiou.top/tags/%E6%9C%BA%E6%99%BA%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>搭建KMS</title>
    <link href="https://www.oikiou.top/2022/3ef2a47d/"/>
    <id>https://www.oikiou.top/2022/3ef2a47d/</id>
    <published>2022-08-21T14:57:15.000Z</published>
    <updated>2022-09-14T17:36:49.076Z</updated>
    
    <content type="html"><![CDATA[<h1 id="KMS"><a href="#KMS" class="headerlink" title="KMS"></a>KMS</h1><p>KMS（Key Management Service），密钥管理服务</p><p>能够通过KMS进行激活的一般称为VL版,即VOLUME授权版，一般不会单独在零售市场进行发售，一般是直接向企业提供电子ISO映像进行批量授权安装，基于对KMS原理研究成果，我们可以自行搭建KMS激活服务器，实现每180天一次的自动激活，使得系统一直保持激活状态。</p><p>KMS可以激活VOL版本的windows系统和office软件</p><h1 id="Docker-部署KMS服务器"><a href="#Docker-部署KMS服务器" class="headerlink" title="Docker 部署KMS服务器"></a>Docker 部署KMS服务器</h1><p><a href="https://registry.hub.docker.com/r/teddysun/kms">https://registry.hub.docker.com/r/teddysun/kms</a></p><ol><li><p>Pull the image</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull teddysun/kms<br></code></pre></td></tr></table></figure><p>This pulls the latest release of KMS server. It can be found at Docker Hub.</p></li><li><p>Start a container</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d -p 1688:1688 --name kms --restart=always teddysun/kms<br></code></pre></td></tr></table></figure><p>Note: The TCP port number <code>1688</code> must be opened in firewall.</p></li></ol><h1 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h1><h2 id="激活windows"><a href="#激活windows" class="headerlink" title="激活windows"></a>激活windows</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 待激活的主机上指定KMS服务器</span><br>slmgr /skms service_address(你搭建的服务器的地址)<br><br><span class="hljs-comment"># 手动激活</span><br>slmgr /ato<br><br><span class="hljs-comment"># 如果激活失败 尝试更改成GVLK KEY再次激活</span><br><span class="hljs-comment"># 运行以下命令查看系统版本 </span><br>wmic os get caption<br><br><span class="hljs-comment"># 访问下面的网址获取key</span><br><span class="hljs-comment"># https://docs.microsoft.com/zh-cn/windows-server/get-started/kms-client-activation-keys</span><br><span class="hljs-comment"># https://technet.microsoft.com/en-us/library/jj612867.aspx</span><br><span class="hljs-comment"># 得到对应key之后，使用管理员权限运行cmd执行安装key：</span><br>slmgr /ipk xxxxx-xxxxx-xxxxx-xxxxx<br><br><span class="hljs-comment"># 手动激活</span><br>slmgr /ato<br></code></pre></td></tr></table></figure><h2 id="激活office"><a href="#激活office" class="headerlink" title="激活office"></a>激活office</h2><p>首先你的OFFICE必须是VOL版本，否则无法激活。 找到你的office安装目录，比如</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">C:<span class="hljs-string">\Program</span> Files (x86)<span class="hljs-string">\Microsoft</span> Office<span class="hljs-string">\Office16</span><br></code></pre></td></tr></table></figure><p>64位的就是</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">C:<span class="hljs-string">\Program</span> Files<span class="hljs-string">\Microsoft</span> Office<span class="hljs-string">\Office16</span><br></code></pre></td></tr></table></figure><p>office16是office2016，office15就是2013，office14就是2010.</p><p>然后目录对的话，该目录下面应该有个OSPP.VBS。</p><p>直接输入下面的指令去指定KMS服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">cscript <span class="hljs-string">&quot;C:\Program Files (x86)\Microsoft Office\Office16\OSPP.VBS&quot;</span> sethst:service_address(你搭建的服务器的地址)<br><span class="hljs-comment"># or</span><br>cscript <span class="hljs-string">&quot;C:\Program Files\Microsoft Office\Office16\OSPP.VBS&quot;</span> /sethst:service_address(你搭建的服务器的地址)<br></code></pre></td></tr></table></figure><p>一般来说，“一句命令已经完成了”，但一般office不会马上连接kms服务器进行激活，所以我们额外补充一条手动激活命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cscript ospp.vbs /act<br></code></pre></td></tr></table></figure><h1 id="如果遇到报错，请检查："><a href="#如果遇到报错，请检查：" class="headerlink" title="如果遇到报错，请检查："></a>如果遇到报错，请检查：</h1><blockquote><ol><li>你的系统&#x2F;OFFICE是否是批量VL版本</li><li>是否以管理员权限运行CMD</li><li>你的系统&#x2F;OFFICE是否修改过KEY&#x2F;未安装GVLK KEY</li><li>检查你的网络连接</li><li>服务器繁忙，多试试（点击检查KMS服务是否可用）</li><li>根据出错代码自己搜索出错原因</li></ol></blockquote><h2 id="windows没有密钥"><a href="#windows没有密钥" class="headerlink" title="windows没有密钥"></a>windows没有密钥</h2><ul><li>windows VOL KEY</li></ul><p><a href="https://docs.microsoft.com/zh-cn/windows-server/get-started/kmsclientkeys">https://docs.microsoft.com/zh-cn/windows-server/get-started/kmsclientkeys</a></p><h2 id="检查windows版本"><a href="#检查windows版本" class="headerlink" title="检查windows版本"></a>检查windows版本</h2><ul><li>检查office是否是VOL版本</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 命令提示符（管理员）执行：cd “office的安装目录”</span><br><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;C:\Program Files (x86)\Microsoft Office\Office16&quot;</span><br><span class="hljs-comment"># or</span><br><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;C:\Program Files\Microsoft Office\Office16&quot;</span><br><br><span class="hljs-comment"># 执行：</span><br>cscript ospp.vbs /dstatus<br></code></pre></td></tr></table></figure><p>在显示的信息中，如果有“VOLUME”字样就是VOL版，即支持KMS激活</p><h2 id="office-密钥"><a href="#office-密钥" class="headerlink" title="office 密钥"></a>office 密钥</h2><ul><li>卸载office的密钥</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 命令提示符（管理员）执行：cd “office的安装目录”</span><br><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;C:\Program Files (x86)\Microsoft Office\Office16&quot;</span><br><span class="hljs-comment"># or</span><br><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;C:\Program Files\Microsoft Office\Office16&quot;</span><br><br><span class="hljs-comment"># 查看当前状态</span><br>cscript ospp.vbs /dstatus<br><br><span class="hljs-comment"># 找到 Last 5 characters of installed product key:XXXXX 语句</span><br><span class="hljs-comment"># 卸载密钥</span><br>cscript ospp.vbs /unpkey:XXXXX<br></code></pre></td></tr></table></figure><ul><li>查找office的VOL KEY</li></ul><p><a href="https://docs.microsoft.com/zh-cn/DeployOffice/vlactivation/gvlks">https://docs.microsoft.com/zh-cn/DeployOffice/vlactivation/gvlks</a></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;KMS&quot;&gt;&lt;a href=&quot;#KMS&quot; class=&quot;headerlink&quot; title=&quot;KMS&quot;&gt;&lt;/a&gt;KMS&lt;/h1&gt;&lt;p&gt;KMS（Key Management</summary>
        
      
    
    
    
    <category term="blog" scheme="https://www.oikiou.top/categories/blog/"/>
    
    
    <category term="KMS" scheme="https://www.oikiou.top/tags/KMS/"/>
    
    <category term="office" scheme="https://www.oikiou.top/tags/office/"/>
    
    <category term="volume" scheme="https://www.oikiou.top/tags/volume/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥杯STM32国赛笔记</title>
    <link href="https://www.oikiou.top/2022/b9b15cd2/"/>
    <id>https://www.oikiou.top/2022/b9b15cd2/</id>
    <published>2022-08-21T14:57:15.000Z</published>
    <updated>2022-09-10T05:20:07.387Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CT117E-EX-扩展板笔记"><a href="#CT117E-EX-扩展板笔记" class="headerlink" title="CT117E-EX 扩展板笔记"></a>CT117E-EX 扩展板笔记</h1><h2 id="数码管（74HC595）"><a href="#数码管（74HC595）" class="headerlink" title="数码管（74HC595）"></a>数码管（74HC595）</h2><h3 id="RCLK-R-存储寄存器读取"><a href="#RCLK-R-存储寄存器读取" class="headerlink" title="RCLK(R:存储寄存器读取)"></a>RCLK(R:存储寄存器读取)</h3><ul><li>上升沿    移位寄存器进入存储寄存器</li><li>下降沿    数据保持不变</li></ul><h3 id="SCK-S-送入595"><a href="#SCK-S-送入595" class="headerlink" title="SCK(S:送入595)"></a>SCK(S:送入595)</h3><ul><li>上升沿    数据寄存器数据移位。Q0–&gt;Q1–&gt;Q2–&gt;Q3–&gt;…–&gt;Q7;</li><li>下降沿    移位寄存器数据不变</li></ul><h3 id="SER（数据脚）"><a href="#SER（数据脚）" class="headerlink" title="SER（数据脚）"></a>SER（数据脚）</h3><ul><li>串行数据输入端</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">SEG_DisplayValue</span><span class="hljs-params">(u8 Bit1,  u8 Bit2, u8 Bit3)</span><br>&#123;<br>u8 i = <span class="hljs-number">0</span>;<span class="hljs-comment">//</span><br>u8 code_tmp = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    *略过部分代码</span><br><span class="hljs-comment">    */</span><br><br>code_tmp = Seg7[Bit1];<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)&#123;<br><br><span class="hljs-keyword">if</span>(code_tmp &amp; <span class="hljs-number">0x80</span>)&#123;<br>SER_H;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>SER_L;<br>&#125;<br>SCK_H;<span class="hljs-comment">//数据移位</span><br>code_tmp = code_tmp &lt;&lt; <span class="hljs-number">1</span>;   <br>SCK_L;<br>&#125;<br>RCLK_H;<span class="hljs-comment">//上升沿时移位寄存器进入存储寄存器</span><br>RCLK_L;<span class="hljs-comment">//下降沿是数据保持不变</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数码管显示数组"><a href="#数码管显示数组" class="headerlink" title="数码管显示数组"></a>数码管显示数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">u8 code t_display[]=&#123;                       <span class="hljs-comment">//标准字库</span><br><span class="hljs-comment">//   0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F</span><br><span class="hljs-number">0x3F</span>,<span class="hljs-number">0x06</span>,<span class="hljs-number">0x5B</span>,<span class="hljs-number">0x4F</span>,<span class="hljs-number">0x66</span>,<span class="hljs-number">0x6D</span>,<span class="hljs-number">0x7D</span>,<span class="hljs-number">0x07</span>,<span class="hljs-number">0x7F</span>,<span class="hljs-number">0x6F</span>,<span class="hljs-number">0x77</span>,<span class="hljs-number">0x7C</span>,<span class="hljs-number">0x39</span>,<span class="hljs-number">0x5E</span>,<span class="hljs-number">0x79</span>,<span class="hljs-number">0x71</span>,<br><br><span class="hljs-comment">//black  -     H    J    K    L    N    o   P    U     t    G    Q    r   M    y</span><br><span class="hljs-number">0x00</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x76</span>,<span class="hljs-number">0x1E</span>,<span class="hljs-number">0x70</span>,<span class="hljs-number">0x38</span>,<span class="hljs-number">0x37</span>,<span class="hljs-number">0x5C</span>,<span class="hljs-number">0x73</span>,<span class="hljs-number">0x3E</span>,<span class="hljs-number">0x78</span>,<span class="hljs-number">0x3d</span>,<span class="hljs-number">0x67</span>,<span class="hljs-number">0x50</span>,<span class="hljs-number">0x37</span>,<span class="hljs-number">0x6e</span>,<br>    <br> <span class="hljs-comment">//0. 1. 2. 3. 4. 5. 6. 7. 8. 9. -1</span><br><span class="hljs-number">0xBF</span>,<span class="hljs-number">0x86</span>,<span class="hljs-number">0xDB</span>,<span class="hljs-number">0xCF</span>,<span class="hljs-number">0xE6</span>,<span class="hljs-number">0xED</span>,<span class="hljs-number">0xFD</span>,<span class="hljs-number">0x87</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xEF</span>,<span class="hljs-number">0x46</span>&#125;;    <br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//   0    1    2    3    4    5    6    7    8    9</span><br><br><span class="hljs-number">0x3F</span>,<span class="hljs-number">0x06</span>,<span class="hljs-number">0x5B</span>,<span class="hljs-number">0x4F</span>,<span class="hljs-number">0x66</span>,<span class="hljs-number">0x6D</span>,<span class="hljs-number">0x7D</span>,<span class="hljs-number">0x07</span>,<span class="hljs-number">0x7F</span>,<span class="hljs-number">0x6F</span>,<span class="hljs-number">0x77</span><br></code></pre></td></tr></table></figure><h2 id="ADC按键"><a href="#ADC按键" class="headerlink" title="ADC按键"></a>ADC按键</h2><h3 id="ADC-KEY-引脚"><a href="#ADC-KEY-引脚" class="headerlink" title="ADC KEY 引脚"></a>ADC KEY 引脚</h3><p> PA5      ADC_12_<strong>IN5</strong></p><h3 id="按键值"><a href="#按键值" class="headerlink" title="按键值"></a>按键值</h3><table><thead><tr><th align="left">ADC值</th><th>ADC按键区间</th></tr></thead><tbody><tr><td align="left">0</td><td>&lt;100</td></tr><tr><td align="left">200</td><td>&lt;400</td></tr><tr><td align="left">600</td><td>&lt;800</td></tr><tr><td align="left">1000</td><td>&lt;1200</td></tr><tr><td align="left">1300-1400</td><td>&lt;1600</td></tr><tr><td align="left">1700-1900</td><td>&lt;2000</td></tr><tr><td align="left">2100-2400</td><td>&lt;2600</td></tr><tr><td align="left">2800-3000</td><td>&lt;3200</td></tr></tbody></table><h2 id="DHT11模块"><a href="#DHT11模块" class="headerlink" title="DHT11模块"></a>DHT11模块</h2><h3 id="芯片性能"><a href="#芯片性能" class="headerlink" title="芯片性能"></a>芯片性能</h3><ul><li>温度测量范围：0－50℃</li><li>湿度测量范围：20－90％RH</li><li>采样周期 ：1S</li></ul><h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><table><thead><tr><th>Byte0</th><th>Byte1</th><th>Byte2</th><th>Byte3</th><th>Byte4</th></tr></thead><tbody><tr><td>湿度整数数据</td><td>湿度小数数据</td><td>温度整数数据</td><td>温度小数数据</td><td>校验和</td></tr></tbody></table><h3 id="编程思路"><a href="#编程思路" class="headerlink" title="编程思路"></a>编程思路</h3><ul><li>主机输出</li><li>主机拉  <strong>低</strong>  至少 <font color="red">18ms</font></li><li>主机拉  <strong>高</strong>  <font color="red">20-40us</font></li><li>主机输入</li><li>主机等待信号线拉 <strong>低</strong>   （DHT11发送持续  <strong>40-50us</strong> 的  <strong>低</strong>   响应信号）</li><li>主机等待信号线拉 <strong>高</strong>   （DHT11发送持续  <strong>40-50us</strong> 的  <strong>高</strong>   拉高信号）</li><li>for(){   &#x2F;&#x2F;40bit数据       5Byte<ul><li>主机等待数据线拉<strong>低</strong>    （数据Bit开始）</li><li>主机等待数据线拉<strong>高</strong>    </li><li>主机延时 时间大于<strong>28us</strong>小于<strong>70us</strong>    （ <font color="red">Type值 40us</font>）</li><li>主机读取数据</li></ul></li><li>}</li><li>主机输出</li><li>主机拉高</li></ul><h3 id="技巧-amp-TIP"><a href="#技巧-amp-TIP" class="headerlink" title="技巧&amp;TIP"></a>技巧&amp;TIP</h3><ul><li><p>DHT11分辨率都是整数级别的<strong>读取小数的数据部分没有意义</strong>。（全为0）</p></li><li><p>读取间隔建议大于100ms（采样 1S 过高的读取频率没有意义）</p></li><li><p>在72MHz频率下 <strong>Delay_LCD</strong> 运行一次大约 <strong>375us</strong></p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Delay_LCD</span><span class="hljs-params">(u16 n)</span><br>&#123;<br>u16 i,j;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>;i&lt;n;++i)<br><span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">3000</span>;++j);<br>&#125;<br><span class="hljs-comment">//将里面的 3000 改成 8 运行一次大概 1us </span><br><span class="hljs-comment">//运行次数越少比1us越多</span><br><span class="hljs-comment">//运行次数越多比1us越少</span><br></code></pre></td></tr></table></figure><h2 id="18B20模块"><a href="#18B20模块" class="headerlink" title="18B20模块"></a>18B20模块</h2><h3 id="芯片性能-1"><a href="#芯片性能-1" class="headerlink" title="芯片性能"></a>芯片性能</h3><ul><li>±0.5°C accuracy from -10°C to +85°C</li><li>Can be powered from data line. Power supply range is 3.0V to 5.5V</li><li>Converts 12-bit temperature to digital word in 750 ms (max.)</li></ul><h3 id="数据格式-1"><a href="#数据格式-1" class="headerlink" title="数据格式"></a>数据格式</h3><h4 id="数据格式-2"><a href="#数据格式-2" class="headerlink" title="数据格式"></a>数据格式</h4><ul><li><p>写Byte数据先写<strong>低位</strong></p></li><li><p>读Byte数据先读出的是<strong>低位</strong></p></li><li><p>读出来的温度先是  <strong>LSM 8bit</strong>  然后是 MSB 8bit</p></li></ul><h4 id="总线协议-amp-时序"><a href="#总线协议-amp-时序" class="headerlink" title="总线协议&amp;时序"></a>总线协议&amp;时序</h4><p><img src="/2022/b9b15cd2/01-1557625836489.png" alt="复位时序"></p><p><img src="/2022/b9b15cd2/02.png" alt="读写时序"></p><h3 id="编程思路-1"><a href="#编程思路-1" class="headerlink" title="编程思路"></a>编程思路</h3><p>0xCCOW_SKIP_ROM</p><p>0x44DS18B20_CONVERT</p><p>0xCCOW_SKIP_ROM</p><p>0xBEDS18B20_READ</p><h2 id="LIS302DL"><a href="#LIS302DL" class="headerlink" title="LIS302DL"></a>LIS302DL</h2><p>NULL</p><h2 id="光敏-D-amp-A"><a href="#光敏-D-amp-A" class="headerlink" title="光敏 D&amp;A"></a>光敏 D&amp;A</h2><h3 id="光敏D"><a href="#光敏D" class="headerlink" title="光敏D"></a>光敏D</h3><ul><li>GPIOA_Pin_3 </li><li>GPIO_Mode_IPU</li></ul><h3 id="光敏A"><a href="#光敏A" class="headerlink" title="光敏A"></a>光敏A</h3><ul><li><p>GPIOA_Pin_4</p></li><li><p>ADC1</p></li><li><p>ADC_Channel_4</p></li></ul><h2 id="电位器"><a href="#电位器" class="headerlink" title="电位器"></a>电位器</h2><p>NULL</p><h2 id="PULS-amp-PWM"><a href="#PULS-amp-PWM" class="headerlink" title="PULS&amp;PWM"></a>PULS&amp;PWM</h2><p>PA1        TIM2_CH2</p><p>PA2        TIM2_CH3</p><p>PA6        TIM3_CH1</p><p>PA7        TIM3_CH2</p><h2 id="界面颜色搭配"><a href="#界面颜色搭配" class="headerlink" title="界面颜色搭配"></a>界面颜色搭配</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">LCD_SetBackColor(Blue);<br>LCD_SetTextColor(White);<br><span class="hljs-comment">//Line01</span><br>LCD_SetBackColor(White);<br>LCD_SetTextColor(Blue);<br><span class="hljs-comment">//Line1-77</span><br>LCD_SetBackColor(Blue);<br>LCD_SetTextColor(Black);<br><span class="hljs-comment">//Line892</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;CT117E-EX-扩展板笔记&quot;&gt;&lt;a href=&quot;#CT117E-EX-扩展板笔记&quot; class=&quot;headerlink&quot; title=&quot;CT117E-EX 扩展板笔记&quot;&gt;&lt;/a&gt;CT117E-EX</summary>
        
      
    
    
    
    <category term="blog" scheme="https://www.oikiou.top/categories/blog/"/>
    
    
    <category term="STM32" scheme="https://www.oikiou.top/tags/STM32/"/>
    
    <category term="蓝桥杯" scheme="https://www.oikiou.top/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    <category term="国赛" scheme="https://www.oikiou.top/tags/%E5%9B%BD%E8%B5%9B/"/>
    
    <category term="CT117E" scheme="https://www.oikiou.top/tags/CT117E/"/>
    
  </entry>
  
  <entry>
    <title>解决 Github 无法打开</title>
    <link href="https://www.oikiou.top/2022/db5fa6fe/"/>
    <id>https://www.oikiou.top/2022/db5fa6fe/</id>
    <published>2022-08-21T14:57:15.000Z</published>
    <updated>2022-09-10T05:20:07.390Z</updated>
    
    <content type="html"><![CDATA[<h1 id="解决-Github-无法打开"><a href="#解决-Github-无法打开" class="headerlink" title="解决 Github 无法打开"></a>解决 Github 无法打开</h1><h2 id="SwitchHosts"><a href="#SwitchHosts" class="headerlink" title="SwitchHosts"></a>SwitchHosts</h2><ol><li><p>下载 SwitchHosts <a href="https://github.com/oldj/SwitchHosts">Github</a> 下载要是太慢可以 用gitee镜像一下github的库 这里放一个别人镜像过的 <a href="https://gitee.com/itas109/SwitchHosts?_from=gitee_search">Gitee</a></p></li><li><p>安装后新建一个配置</p><ul><li>Title: 随意  Type: Remote  URL:   Auto Refresh: 最好选 1 hour</li></ul><p><img src="/2022/db5fa6fe/image-20211015220230835.png" alt="image-20211015220230835"></p><ul><li>可选的URL：<ul><li>520Github <a href="https://raw.hellogithub.com/hosts">https://raw.hellogithub.com/hosts</a></li><li>ineo6 <a href="https://gitee.com/ineo6/hosts/raw/master/hosts">https://gitee.com/ineo6/hosts/raw/master/hosts</a></li><li>有看到网上还有多个网站同时更新的，但是看到更新速度不够快，也就放弃了。</li></ul></li></ul></li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://github.com/ineo6/hosts">https://github.com/ineo6/hosts</a></p><p><a href="https://github.com/521xueweihan/GitHub520">https://github.com/521xueweihan/GitHub520</a></p><h2 id="Chrome-插件方式"><a href="#Chrome-插件方式" class="headerlink" title="Chrome 插件方式"></a>Chrome 插件方式</h2><p><a href="https://github.com/gauseen/faster-hosts">FasterHosts</a> 是个 Chrome 插件，主要原理是拦截浏览器的某些请求，将 <code>domain</code> 替换成访问速度较快的那个。hosts 资源来自 <a href="https://github.com/521xueweihan/GitHub520">GitHub520</a>，每 1 小时更新一次。</p><blockquote><ol><li>下载 <a href="https://github.com/gauseen/faster-hosts/archive/master.zip">FasterHosts</a> 然后解压，找到 <code>extension</code> 子目录</li><li>打开 Chrome，输入: <code>chrome://extensions/</code></li><li>打开「开发者模式」</li><li>选择「加载已解压的扩展程序」，然后定位到刚才解压的文件夹里面的 <code>extension</code> 目录，确定</li><li>这就安装好了，关闭「开发者模式」</li></ol></blockquote>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;解决-Github-无法打开&quot;&gt;&lt;a href=&quot;#解决-Github-无法打开&quot; class=&quot;headerlink&quot; title=&quot;解决 Github 无法打开&quot;&gt;&lt;/a&gt;解决 Github 无法打开&lt;/h1&gt;&lt;h2</summary>
        
      
    
    
    
    <category term="blog" scheme="https://www.oikiou.top/categories/blog/"/>
    
    
    <category term="github" scheme="https://www.oikiou.top/tags/github/"/>
    
    <category term="hosts" scheme="https://www.oikiou.top/tags/hosts/"/>
    
  </entry>
  
  <entry>
    <title>C</title>
    <link href="https://www.oikiou.top/2022/3dd7ffa7/"/>
    <id>https://www.oikiou.top/2022/3dd7ffa7/</id>
    <published>2022-08-21T14:57:15.000Z</published>
    <updated>2022-09-10T05:20:07.414Z</updated>
    
    <content type="html"><![CDATA[<h1 id="标准库函数"><a href="#标准库函数" class="headerlink" title="标准库函数"></a>标准库函数</h1><h2 id="fprintf-输出到流中"><a href="#fprintf-输出到流中" class="headerlink" title="fprintf 输出到流中"></a>fprintf 输出到流中</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>C 库函数 <strong>int fprintf(FILE *stream, const char *format, …)</strong> 发送格式化输出到流 stream 中。</p><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>下面是 fprintf() 函数的声明。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fprintf</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span><br></code></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。</li><li><strong>format</strong> – 这是 C 字符串，包含了要被写入到流 stream 中的文本。它可以包含嵌入的 format 标签，format 标签可被随后的附加参数中指定的值替换，并按需求进行格式化。format 标签属性是 <strong>%[flags][width][.precision][length]specifier</strong>，具体讲解如下：</li></ul><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>如果成功，则返回写入的字符总数，否则返回一个负数。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>下面的实例演示了 fprintf() 函数的用法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>   FILE * fp;<br><br>   fp = fopen (<span class="hljs-string">&quot;file.txt&quot;</span>, <span class="hljs-string">&quot;w+&quot;</span>);<br>   <span class="hljs-built_in">fprintf</span>(fp, <span class="hljs-string">&quot;%s %s %s %d&quot;</span>, <span class="hljs-string">&quot;We&quot;</span>, <span class="hljs-string">&quot;are&quot;</span>, <span class="hljs-string">&quot;in&quot;</span>, <span class="hljs-number">2014</span>);<br>   <br>   fclose(fp);<br>   <br>   <span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>让我们编译并运行上面的程序，这将创建文件 <strong>file.txt</strong>，它的内容如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">We</span> are in <span class="hljs-number">2014</span><br></code></pre></td></tr></table></figure><h2 id="atoi-字符串转换成整数"><a href="#atoi-字符串转换成整数" class="headerlink" title="atoi 字符串转换成整数"></a>atoi 字符串转换成整数</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>C 库函数 <strong>int atoi(const char *str)</strong> 把参数 <strong>str</strong> 所指向的字符串转换为一个整数（类型为 int 型）。</p><h3 id="声明-1"><a href="#声明-1" class="headerlink" title="声明"></a>声明</h3><p>下面是 atoi() 函数的声明。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">atoi</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str)</span><br></code></pre></td></tr></table></figure><h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><ul><li><strong>str</strong> – 要转换为整数的字符串。</li></ul><h3 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h3><p>该函数返回转换后的长整数，如果没有执行有效的转换，则返回零。</p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>下面的实例演示了 atoi() 函数的用法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>   <span class="hljs-type">int</span> val;<br>   <span class="hljs-type">char</span> str[<span class="hljs-number">20</span>];<br>   <br>   <span class="hljs-built_in">strcpy</span>(str, <span class="hljs-string">&quot;98993489&quot;</span>);<br>   val = atoi(str);<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;字符串值 = %s, 整型值 = %d\n&quot;</span>, str, val);<br><br>   <span class="hljs-built_in">strcpy</span>(str, <span class="hljs-string">&quot;runoob.com&quot;</span>);<br>   val = atoi(str);<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;字符串值 = %s, 整型值 = %d\n&quot;</span>, str, val);<br><br>   <span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>让我们编译并运行上面的程序，这将产生以下结果：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">字符串值 = <span class="hljs-number">98993489</span>, 整型值 = <span class="hljs-number">98993489</span><br>字符串值 = runoob.com, 整型值 = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h1 id="杂乱"><a href="#杂乱" class="headerlink" title="杂乱"></a>杂乱</h1><h2 id="stderr-stdout"><a href="#stderr-stdout" class="headerlink" title="stderr stdout"></a>stderr stdout</h2><ul><li><p>stdout – 标准输出设备 stdout。 </p></li><li><p>stderr – 标准错误输出设备</p></li></ul><p>两者默认向屏幕输出。 但如果用转向标准输出到磁盘文件，则可看出两者区别。stdout输出到磁盘文件，stderr在屏幕。 </p><blockquote><p>转向标准输出到磁盘文件tmp.txt<br>my.exe &gt; tmp.txt</p></blockquote><p>在默认情况下，stdout是行缓冲的，他的输出会放在一个buffer里面，只有到换行的时候，才会输出到屏幕。而stderr是无缓冲的，会直接输出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stdout</span>,<span class="hljs-string">&quot;Group&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<span class="hljs-string">&quot;XiyouLinux&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">linux下，第一次会输出XiYouLinuxGroup,是因为stdout将输出的Group放到了缓冲区当中直到程序结束在将缓冲区中的数据刷新出来。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;标准库函数&quot;&gt;&lt;a href=&quot;#标准库函数&quot; class=&quot;headerlink&quot; title=&quot;标准库函数&quot;&gt;&lt;/a&gt;标准库函数&lt;/h1&gt;&lt;h2 id=&quot;fprintf-输出到流中&quot;&gt;&lt;a</summary>
        
      
    
    
    
    <category term="language" scheme="https://www.oikiou.top/categories/language/"/>
    
    
    <category term="C/C++" scheme="https://www.oikiou.top/tags/C-C/"/>
    
    <category term="C" scheme="https://www.oikiou.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>MS-DOS</title>
    <link href="https://www.oikiou.top/2022/ddff0c71/"/>
    <id>https://www.oikiou.top/2022/ddff0c71/</id>
    <published>2022-08-21T14:57:15.000Z</published>
    <updated>2022-09-10T05:20:07.414Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MS-DOS"><a href="#MS-DOS" class="headerlink" title="MS-DOS"></a>MS-DOS</h1><p><strong>CMD(windows-commands)</strong></p><p><a href="https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/windows-commands">Windowscommands</a></p><p>在cmd内<code>/?</code>即可获得帮助信息</p><h2 id="FOR"><a href="#FOR" class="headerlink" title="FOR"></a>FOR</h2><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs tex">对一组文件中的每一个文件执行某个特定命令。<br><br>FOR <span class="hljs-comment">%variable IN (set) DO command [command-parameters]</span><br><br>  <span class="hljs-comment">%variable  指定一个单一字母可替换的参数。</span><br>  (set)      指定一个或一组文件。可以使用通配符。<br>  command    指定对每个文件执行的命令。<br>  command-parameters <br>             为特定命令指定参数或命令行开关。<br><br>在批处理程序中使用 FOR 命令时，指定变量请使用 <span class="hljs-comment">%%variable</span><br>而不要用 <span class="hljs-comment">%variable。变量名称是区分大小写的，所以 %i 不同于 %I.</span><br><br>如果启用命令扩展，则会支持下列 FOR 命令的其他格式:<br><br>FOR /D <span class="hljs-comment">%variable IN (set) DO command [command-parameters]</span><br><br>    如果集中包含通配符，则指定与目录名匹配，而不与文件名匹配。<br><br>FOR /R [[drive:]path] <span class="hljs-comment">%variable IN (set) DO command [command-parameters]</span><br><br>    检查以 [drive:]path 为根的目录树，指向每个目录中的 FOR 语句。<br>    如果在 /R 后没有指定目录规范，则使用当前目录。如果集仅为一个单点(.)字符，<br>    则枚举该目录树。<br><br>FOR /L <span class="hljs-comment">%variable IN (start,step,end) DO command [command-parameters]</span><br><br>    该集表示以增量形式从开始到结束的一个数字序列。因此，(1,1,5)将产生序列<br>    1 2 3 4 5，(5,-1,1)将产生序列(5 4 3 2 1)<br><br>FOR /F [&quot;options&quot;] <span class="hljs-comment">%variable IN (file-set) DO command [command-parameters]</span><br>FOR /F [&quot;options&quot;] <span class="hljs-comment">%variable IN (&quot;string&quot;) DO command [command-parameters]</span><br>FOR /F [&quot;options&quot;] <span class="hljs-comment">%variable IN (&#x27;command&#x27;) DO command [command-parameters]</span><br><br>    或者，如果有 usebackq 选项:<br><br>FOR /F [&quot;options&quot;] <span class="hljs-comment">%variable IN (file-set) DO command [command-parameters]</span><br>FOR /F [&quot;options&quot;] <span class="hljs-comment">%variable IN (&quot;string&quot;) DO command [command-parameters]</span><br>FOR /F [&quot;options&quot;] <span class="hljs-comment">%variable IN (&#x27;command&#x27;) DO command [command-parameters]</span><br><br>    fileset 为一个或多个文件名。继续到 fileset 中的下一个文件之前，<br>    每份文件都被打开、读取并经过处理。处理包括读取文件，将其分成一行行的文字，<br>    然后将每行解析成零或更多的符号。然后用已找到的符号字符串变量值调用 For 循环。<br>    以默认方式，/F 通过每个文件的每一行中分开的第一个空白符号。跳过空白行。<br>    你可通过指定可选 &quot;options&quot; 参数替代默认解析操作。这个带引号的字符串包括一个<br>    或多个指定不同解析选项的关键字。这些关键字为:<br><br>        eol=c           - 指一个行注释字符的结尾(就一个)<br>        skip=n          - 指在文件开始时忽略的行数。<br>        delims=xxx      - 指分隔符集。这个替换了空格和制表符的<br>                          默认分隔符集。<br>        tokens=x,y,m-n  - 指每行的哪一个符号被传递到每个迭代<br>                          的 for 本身。这会导致额外变量名称的分配。m-n<br>                          格式为一个范围。通过 nth 符号指定 mth。如果<br>                          符号字符串中的最后一个字符星号，<br>                          那么额外的变量将在最后一个符号解析之后<br>                          分配并接受行的保留文本。<br>        usebackq        - 指定新语法已在下类情况中使用:<br>                          在作为命令执行一个后引号的字符串并且一个单<br>                          引号字符为文字字符串命令并允许在 file-set<br>                          中使用双引号扩起文件名称。<br><br>    某些范例可能有助:<br><br>FOR /F &quot;eol=; tokens=2,3* delims=, &quot; <span class="hljs-comment">%i in (myfile.txt) do @echo %i %j %k</span><br><br>    会分析 myfile.txt 中的每一行，忽略以分号打头的那些行，将<br>    每行中的第二个和第三个符号传递给 for 函数体，用逗号和/或<br>    空格分隔符号。请注意，此 for 函数体的语句引用 <span class="hljs-comment">%i 来</span><br>    获得第二个符号，引用 <span class="hljs-comment">%j 来获得第三个符号，引用 %k</span><br>    来获得第三个符号后的所有剩余符号。对于带有空格的文件<br>    名，你需要用双引号将文件名括起来。为了用这种方式来使<br>    用双引号，还需要使用 usebackq 选项，否则，双引号会<br>    被理解成是用作定义某个要分析的字符串的。<br><br>    <span class="hljs-comment">%i 在 for 语句中显式声明，%j 和 %k 是通过</span><br>    tokens= 选项隐式声明的。可以通过 tokens= 一行<br>    指定最多 26 个符号，只要不试图声明一个高于字母 &quot;z&quot; 或<br>    &quot;Z&quot; 的变量。请记住，FOR 变量是单一字母、分大小写和全局的变量；<br>    而且，不能同时使用超过 52 个。<br><br>    还可以在相邻字符串上使用 FOR /F 分析逻辑，方法是，<br>    用单引号将括号之间的 file-set 括起来。这样，该字符<br>    串会被当作一个文件中的一个单一输入行进行解析。<br><br>    最后，可以用 FOR /F 命令来分析命令的输出。方法是，将<br>    括号之间的 file-set 变成一个反括字符串。该字符串会<br>    被当作命令行，传递到一个子 CMD.EXE，其输出会被捕获到<br>    内存中，并被当作文件分析。如以下例子所示:<br><br>      FOR /F &quot;usebackq delims==&quot; <span class="hljs-comment">%i IN (`set`) DO @echo %i</span><br><br>    会枚举当前环境中的环境变量名称。<br><br>另外，FOR 变量参照的替换已被增强。你现在可以使用下列<br>选项语法:<br><br>     <span class="hljs-comment">%~I          - 删除任何引号(&quot;)，扩展 %I</span><br>     <span class="hljs-comment">%~fI        - 将 %I 扩展到一个完全合格的路径名</span><br>     <span class="hljs-comment">%~dI        - 仅将 %I 扩展到一个驱动器号</span><br>     <span class="hljs-comment">%~pI        - 仅将 %I 扩展到一个路径</span><br>     <span class="hljs-comment">%~nI        - 仅将 %I 扩展到一个文件名</span><br>     <span class="hljs-comment">%~xI        - 仅将 %I 扩展到一个文件扩展名</span><br>     <span class="hljs-comment">%~sI        - 扩展的路径只含有短名</span><br>     <span class="hljs-comment">%~aI        - 将 %I 扩展到文件的文件属性</span><br>     <span class="hljs-comment">%~tI        - 将 %I 扩展到文件的日期/时间</span><br>     <span class="hljs-comment">%~zI        - 将 %I 扩展到文件的大小</span><br>     <span class="hljs-comment">%~$PATH:I   - 查找列在路径环境变量的目录，并将 %I 扩展</span><br>                   到找到的第一个完全合格的名称。如果环境变量名<br>                   未被定义，或者没有找到文件，此组合键会扩展到<br>                   空字符串<br><br>可以组合修饰符来得到多重结果:<br><br>     <span class="hljs-comment">%~dpI       - 仅将 %I 扩展到一个驱动器号和路径</span><br>     <span class="hljs-comment">%~nxI       - 仅将 %I 扩展到一个文件名和扩展名</span><br>     <span class="hljs-comment">%~fsI       - 仅将 %I 扩展到一个带有短名的完整路径名</span><br>     <span class="hljs-comment">%~dp$PATH:I - 搜索列在路径环境变量的目录，并将 %I 扩展</span><br>                   到找到的第一个驱动器号和路径。<br>     <span class="hljs-comment">%~ftzaI     - 将 %I 扩展到类似输出线路的 DIR</span><br><br>在以上例子中，<span class="hljs-comment">%I 和 PATH 可用其他有效数值代替。%~ 语法</span><br>用一个有效的 FOR 变量名终止。选取类似 <span class="hljs-comment">%I 的大写变量名</span><br>比较易读，而且避免与不分大小写的组合键混淆。<br></code></pre></td></tr></table></figure><h2 id="dir"><a href="#dir" class="headerlink" title="dir"></a>dir</h2><p>列出文件</p><h2 id="cls"><a href="#cls" class="headerlink" title="cls"></a>cls</h2><p>清屏</p><h1 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE"></a>NOTE</h1><h2 id="mklinkC盘程序搬家"><a href="#mklinkC盘程序搬家" class="headerlink" title="mklinkC盘程序搬家"></a>mklinkC盘程序搬家</h2><p>命令参数</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">mklink<span class="hljs-string">[[/d]|[/h]|[/j]]</span>&lt;Link&gt;&lt;Target&gt;<br></code></pre></td></tr></table></figure><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>&#x2F;d</td><td>创建目录符号链接。默认情况下，mklink会创建文件符号链接。</td></tr><tr><td>&#x2F;H</td><td>创建硬链接而不是符号链接。</td></tr><tr><td>&#x2F;J</td><td>创建目录连接。</td></tr><tr><td>&lt;链接&gt;</td><td>指定正在创建的符号链接的名称。</td></tr><tr><td>&lt;目标&gt;</td><td>指定新符号链接引用的路径（相对或绝对）。</td></tr><tr><td>&#x2F;？</td><td>在命令提示符下显示帮助。</td></tr></tbody></table>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;MS-DOS&quot;&gt;&lt;a href=&quot;#MS-DOS&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="language" scheme="https://www.oikiou.top/categories/language/"/>
    
    
    <category term="Windows" scheme="https://www.oikiou.top/tags/Windows/"/>
    
    <category term="MS-DOS" scheme="https://www.oikiou.top/tags/MS-DOS/"/>
    
  </entry>
  
  <entry>
    <title>MicroPython</title>
    <link href="https://www.oikiou.top/2022/bf76c113/"/>
    <id>https://www.oikiou.top/2022/bf76c113/</id>
    <published>2022-08-21T14:57:15.000Z</published>
    <updated>2022-09-10T05:20:07.414Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MicroPython"><a href="#MicroPython" class="headerlink" title="MicroPython"></a>MicroPython</h1><p><a href="https://www.cirmall.com/articles/301308/p1">简单、方便、快速开发嵌入式实时系统——MicroPytho</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pyb <span class="hljs-keyword">import</span> uart<br><br><span class="hljs-keyword">from</span> pyb <span class="hljs-keyword">import</span> I2C <span class="hljs-comment">#工程师将从pyb库导入I2C</span><br><span class="hljs-comment">#这里的PYB库提供了接入到微控制器外围功能，如SPI，I2C以及UART</span><br><span class="hljs-comment">#在使用任何外设之前，工程师必须实例化外设类以创建可用于控制外设的对象。一旦外设类被初始化，工程师可以执行任何其他操作，例如在进入主应用程序循环之前验证设备是否存在，主要应用程序代码将会每秒采样一次传感器。</span><br><br>GlobalTemp = <span class="hljs-number">0.0</span><br><br>GlobalBarometer = <span class="hljs-number">0.0</span><br><br>＃初始化和实例化I2C外设<span class="hljs-number">2</span><br><br>I2C2 = I2C（<span class="hljs-number">2</span>，I2C.MASTER，波特率= <span class="hljs-number">100000</span>）<br><br>＃配置Uart1进行通信<br><br>Uart1 = pyb.UART（<span class="hljs-number">1</span>,<span class="hljs-number">115200</span>）<br><br>Uart1.init（<span class="hljs-number">115200</span>，bits = <span class="hljs-number">8</span>，parity = <span class="hljs-literal">None</span>，stop = <span class="hljs-number">1</span>）<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br><br>SampleSensor（）<br><br>pyb.delay（<span class="hljs-number">1000</span>）<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">SensorSample</span>（）：<br><br>＃读取温度数据<br><br>TempSample = I2C2.readfrom_mem（<span class="hljs-number">119</span>，<span class="hljs-number">0xFA</span>，<span class="hljs-number">3</span>）<br><br>＃读取压力数据<br><br>PressureSample = I2C2.readfrom_mem（<span class="hljs-number">119</span>，<span class="hljs-number">0xF7</span>,<span class="hljs-number">3</span>）<br><br>将样本数据转换为字符串<br><br>data =“＃，temperature =”<span class="hljs-built_in">str</span>（TempSample）+“，pressure”+ <span class="hljs-built_in">str</span>（PressureSample）+“，＃，\ n \ r”<br><br>＃将数据写入蓝牙<br><br>Uart1.write（data）<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;MicroPython&quot;&gt;&lt;a href=&quot;#MicroPython&quot; class=&quot;headerlink&quot; title=&quot;MicroPython&quot;&gt;&lt;/a&gt;MicroPython&lt;/h1&gt;&lt;p&gt;&lt;a</summary>
        
      
    
    
    
    <category term="language" scheme="https://www.oikiou.top/categories/language/"/>
    
    
    <category term="Embedded" scheme="https://www.oikiou.top/tags/Embedded/"/>
    
    <category term="MicroPython" scheme="https://www.oikiou.top/tags/MicroPython/"/>
    
    <category term="Python" scheme="https://www.oikiou.top/tags/Python/"/>
    
  </entry>
  
</feed>

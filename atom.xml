<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Oikiou&#39;s Blog</title>
  <icon>https://www.oikiou.top/img/favicon.ico</icon>
  <subtitle>花有重开日，人无再少年</subtitle>
  <link href="https://www.oikiou.top/atom.xml" rel="self"/>
  
  <link href="https://www.oikiou.top/"/>
  <updated>2022-11-14T14:01:13.064Z</updated>
  <id>https://www.oikiou.top/</id>
  
  <author>
    <name>Oikiou</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Ip 转换成 Location 的Api</title>
    <link href="https://www.oikiou.top/2022/4dd4ea8a/"/>
    <id>https://www.oikiou.top/2022/4dd4ea8a/</id>
    <published>2022-11-08T15:24:15.000Z</published>
    <updated>2022-11-14T14:01:13.064Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ip-to-location"><a href="#ip-to-location" class="headerlink" title="ip to location"></a>ip to location</h1><h2 id="ipwhois"><a href="#ipwhois" class="headerlink" title="ipwhois"></a>ipwhois</h2><p>IPWHOIS.IO的IP地理定位API的URL格式很简单。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">http://ipwhois.app/json/&#123;IP&#125;<br></code></pre></td></tr></table></figure><p>例如，我们可以用以下IP地址发出API请求：47.9.123.84。</p><p><img src="/2022/undefined/ipwhois-api.png" alt="img"></p><p><strong>参考链接:</strong></p><ul><li><a href="https://webdamn.com/ip-geolocation-api/">IP Geolocation API – IPWHOIS.IO</a></li><li><a href="https://webdamn.com/how-to-integrate-ip-geolocation-api-with-php/">How to Integrate IP Geolocation API with PHP</a></li><li><a href="https://webdamn.com/scrape-search-result-data-using-serpapi-with-python/">Scrape Search Result Data using SerpApi with Python</a></li><li><a href="https://webdamn.com/get-geocoding-using-positionstack-api-with-php/">Get Geocoding using Positionstack API with PHP</a></li><li><a href="https://webdamn.com/flight-data-using-aviationstack-api-with-php/">Flight Data using Aviationstack API with PHP</a></li><li><a href="https://webdamn.com/get-address-information-using-geocode-api-with-php/">Get Address Information using Geocode API with PHP</a></li><li><a href="https://webdamn.com/review-scraping-using-reviewapi-with-php/">Review Scraping using ReviewAPI with PHP</a></li><li><a href="https://webdamn.com/simple-web-scraping-with-zenscrape-api-using-php/">Simple Web Scraping with Zenscrape API using PHP</a></li><li><a href="https://webdamn.com/scrape-search-result-with-zenserp-api-using-php/">Scrape Search Result with Zenserp API using PHP</a></li><li><a href="https://webdamn.com/build-user-agent-lookup-system-using-userstack-api-with-php/">Build User Agent Lookup System using Userstack API with PHP</a></li><li><a href="https://webdamn.com/build-ip-lookup-website-using-ipapi-with-php/">Build IP Lookup Website using ipapi with PHP</a></li><li><a href="https://webdamn.com/build-weather-website-with-weatherstack-api-using-php/">Build Weather Website with Weatherstack API using PHP</a></li><li><a href="https://webdamn.com/get-website-visitors-info-using-ipstack-api-with-php/">Get Website Visitors Info using IPStack API with PHP</a></li><li><a href="https://webdamn.com/scrape-serp-data-using-serpstack-api-with-python/">Scrape SERP Data using SerpStack API with Python</a></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;ip-to-location&quot;&gt;&lt;a href=&quot;#ip-to-location&quot; class=&quot;headerlink&quot; title=&quot;ip to location&quot;&gt;&lt;/a&gt;ip to location&lt;/h1&gt;&lt;h2</summary>
        
      
    
    
    
    <category term="blog" scheme="https://www.oikiou.top/categories/blog/"/>
    
    
    <category term="ip" scheme="https://www.oikiou.top/tags/ip/"/>
    
    <category term="location" scheme="https://www.oikiou.top/tags/location/"/>
    
    <category term="api" scheme="https://www.oikiou.top/tags/api/"/>
    
  </entry>
  
  <entry>
    <title>单位换算</title>
    <link href="https://www.oikiou.top/2022/6fb71d96/"/>
    <id>https://www.oikiou.top/2022/6fb71d96/</id>
    <published>2022-11-01T14:57:15.000Z</published>
    <updated>2022-11-14T14:01:13.153Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单位换算"><a href="#单位换算" class="headerlink" title="单位换算"></a>单位换算</h1><h1 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">★ -----------------</span><br>1 km = 1000 m<br>1 m  = 100  cm<br>1 cm = 10   mm<br>1 mm = 1000 um<br><br>1    inch = 2.54 cm<br>1/10 inch = 2.54 mm<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">--------------------</span><br>1 km = 1000 m<br>1 m  = 10   dm<br>1 dm = 10   cm<br>1 cm = 10   mm<br>1 m  = 1000 mm<br>1 mm = 1000 um<br>1 um = 1000 nm<br>1 nm = 1000 pm <br>1 pm = 1000 fm<br>1 fm = 1000 am<br>...<br>1 inch              = 2.54 cm<br>1 cm                = 0.3937008 inch<br>...<br><span class="hljs-meta prompt_"># </span><span class="language-bash"></span><br><span class="language-bash">1 海里(nautical mile) = 1852 m = 1.852 km</span><br>1 km                = 0.5399568 海里(nautical mile)<br>...<br><span class="hljs-meta prompt_"># </span><span class="language-bash">英制长度单位</span><br>1 英里(mile)          = 1.609344 km<br>1 km                = 0.6213712 英里(mile)<br>...<br><span class="hljs-meta prompt_"># </span><span class="language-bash">天文学长度单位</span><br>1 光年                = 9.4653×10^12 km<br>1 天文单位 ≈ 1.496亿 千米<br>...<br><span class="hljs-meta prompt_"># </span><span class="language-bash">我国传统的长度单位</span><br>1 km                = 2 里<br>1 里                 = 150 丈 = 500 米<br>1 丈                 = 10尺<br>1 丈                 = 3.33米<br>1 尺                 = 3.33分米<br>1 m                 = 0.3 丈 = 3 尺 = 30 寸<br>1 cm                = 3 分 = 30 厘<br><br></code></pre></td></tr></table></figure><h1 id="时间单位"><a href="#时间单位" class="headerlink" title="时间单位"></a>时间单位</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">★ -----------------</span><br>1 s  = 1000 ms<br>1 ms = 1000 us<br>1 us = 1000 ns<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">   -----------------</span><br>1 minute = 60 s<br>1 s  = 1000 ms<br>1 ms = 1000 us<br>1 us = 1000 ns<br>1 ns = 1000 ps<br><br>100年      = 1世纪<br>365.25天   = 1年<br>1平太阳日     = 24小时3分56.555秒<br>1恒星日      = 23小时56分4.091秒<br>1太阳年(回归年) = 365.2422天(= 365天5小时48分46秒)<br>1恒星年      = 365.2564天(= 365天6小时9分9.5秒)<br>1朔望月      = 29.5306天<br>1恒星月      = 27.3712天<br>1太阳年      = 12个朔望日 = 354.36天<br></code></pre></td></tr></table></figure><h1 id="速度"><a href="#速度" class="headerlink" title="速度"></a>速度</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">★ -----------------</span><br>1 m/s  = 3.6 km/h<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">   -----------------</span><br>1 mph  = 1.609344 km/h<br>1 km/h = 0.6213712 mph<br><br></code></pre></td></tr></table></figure><h1 id="温度"><a href="#温度" class="headerlink" title="温度"></a>温度</h1><p>$$<br>℉ &#x3D; ℃ * (9&#x2F;5) + 32<br>$$</p><p>$$<br>℃ &#x3D; (℉ - 32)*(5&#x2F;9)<br>$$</p><p>$$<br>K &#x3D; ℃ + 273.15<br>$$</p><p>$$<br>℃ &#x3D; K - 273.15<br>$$</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">25 ℃ = 298.15 K = 77 F<br></code></pre></td></tr></table></figure><h1 id="电容单位"><a href="#电容单位" class="headerlink" title="电容单位"></a>电容单位</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>1 F  = 1000 mF<br>1 mF = 1000 uF<br>1 uF = 1000 nF<br>1 nF = 1000 pF<br></code></pre></td></tr></table></figure><p><img src="/Untitled/tutorials068_001_zh.gif" alt="img"></p><ul><li>数值中的<code>R</code>代表小数点<code>.</code></li></ul><table><thead><tr><th align="left">标示</th><th align="left">电阻</th><th align="left">电容</th><th align="left">电感</th></tr></thead><tbody><tr><td align="left">120</td><td align="left">12Ω</td><td align="left">12pF</td><td align="left">12μH</td></tr><tr><td align="left">122</td><td align="left">1.2kΩ</td><td align="left">1.2nF</td><td align="left">1.2mH</td></tr><tr><td align="left">124</td><td align="left">120kΩ</td><td align="left">120nF</td><td align="left">120mH</td></tr><tr><td align="left">126</td><td align="left">12MΩ</td><td align="left">12μF</td><td align="left">12H</td></tr><tr><td align="left">R15</td><td align="left">0.15Ω</td><td align="left">0.15pF</td><td align="left">0.15μH</td></tr><tr><td align="left">1R5</td><td align="left">1.5Ω</td><td align="left">1.5pF</td><td align="left">1.5μH</td></tr></tbody></table><table><thead><tr><th align="center">误差符号</th><th align="center">误差</th></tr></thead><tbody><tr><td align="center">Ｆ</td><td align="center">±1％</td></tr><tr><td align="center">Ｇ</td><td align="center">±2％</td></tr><tr><td align="center">Ｊ</td><td align="center">±5％</td></tr><tr><td align="center">Ｋ</td><td align="center">±10％</td></tr><tr><td align="center">Ｍ</td><td align="center">±20％</td></tr><tr><td align="center">Ｚ</td><td align="center">80%,－20%</td></tr></tbody></table>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;单位换算&quot;&gt;&lt;a href=&quot;#单位换算&quot; class=&quot;headerlink&quot; title=&quot;单位换算&quot;&gt;&lt;/a&gt;单位换算&lt;/h1&gt;&lt;h1 id=&quot;长度&quot;&gt;&lt;a href=&quot;#长度&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="tools" scheme="https://www.oikiou.top/categories/tools/"/>
    
    
    <category term="unit" scheme="https://www.oikiou.top/tags/unit/"/>
    
    <category term="m" scheme="https://www.oikiou.top/tags/m/"/>
    
    <category term="cm" scheme="https://www.oikiou.top/tags/cm/"/>
    
    <category term="mm" scheme="https://www.oikiou.top/tags/mm/"/>
    
    <category term="s" scheme="https://www.oikiou.top/tags/s/"/>
    
    <category term="us" scheme="https://www.oikiou.top/tags/us/"/>
    
  </entry>
  
  <entry>
    <title>Android 文件传输模式 电脑无法识别</title>
    <link href="https://www.oikiou.top/2022/3db44d04/"/>
    <id>https://www.oikiou.top/2022/3db44d04/</id>
    <published>2022-10-10T14:57:15.000Z</published>
    <updated>2022-11-14T14:01:13.063Z</updated>
    
    <content type="html"><![CDATA[<h1 id="android-文件传输模式-电脑无法识别"><a href="#android-文件传输模式-电脑无法识别" class="headerlink" title="android 文件传输模式 电脑无法识别"></a>android 文件传输模式 电脑无法识别</h1><p>最近android手机连接电脑选择传输文件模式，电脑不再识别手机。选择照片模式就没有问题。</p><p>手机选择文件传输模式后 选择自动搜索驱动程序 安装后会 提示“这个inf中的服务安装段落无效”。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li><p>按“Win+X” 点击 “设备管理器”</p></li><li><p>在设备管理器中找到你的手机，名字可能是你的手机型号，可能是未知设备 ，</p></li><li><p>右键选择更新驱动程序.</p></li><li><p>选择 “浏览计算机以查找驱动程序软件”</p></li><li><p>选择 “让我从计算机上的可用驱动程序列表中选取”</p></li><li><p>在列表里面找到“便携设备” (可能没有这一步操作)</p></li><li><p>选择 “MTP USB 设备”</p><p><img src="/2022/undefined/1636599848857.png" alt="win10系统识别不了USB设备解决方法介绍-Win10系统识别不了USB设备怎么办-53系统之家"></p></li><li><p>点击 “下一步”</p></li><li><p>回到设备管理器看到设备已经可用正确运作了</p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.android.com/studio/run/oem-usb">安装原始设备制造商 (OEM) USB 驱动程序</a></p><p><a href="https://developer.android.com/studio/run/win-usb">获取 Google USB 驱动程序</a></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;android-文件传输模式-电脑无法识别&quot;&gt;&lt;a href=&quot;#android-文件传输模式-电脑无法识别&quot; class=&quot;headerlink&quot; title=&quot;android 文件传输模式</summary>
        
      
    
    
    
    <category term="blog" scheme="https://www.oikiou.top/categories/blog/"/>
    
    
    <category term="windows" scheme="https://www.oikiou.top/tags/windows/"/>
    
    <category term="android" scheme="https://www.oikiou.top/tags/android/"/>
    
    <category term="mtp" scheme="https://www.oikiou.top/tags/mtp/"/>
    
    <category term="pc" scheme="https://www.oikiou.top/tags/pc/"/>
    
    <category term="driver" scheme="https://www.oikiou.top/tags/driver/"/>
    
  </entry>
  
  <entry>
    <title>Tmux 终端复用器(Terminal Multiplexer)</title>
    <link href="https://www.oikiou.top/2022/9d389561/"/>
    <id>https://www.oikiou.top/2022/9d389561/</id>
    <published>2022-09-29T15:57:15.000Z</published>
    <updated>2022-09-29T17:36:41.683Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tmux-终端复用器-terminal-multiplexer"><a href="#tmux-终端复用器-terminal-multiplexer" class="headerlink" title="tmux 终端复用器(terminal multiplexer)"></a>tmux 终端复用器(terminal multiplexer)</h1><p>☆为重要内容</p><h1 id="Tmux-简介"><a href="#Tmux-简介" class="headerlink" title="Tmux 简介"></a>Tmux 简介</h1><p>tmux 终端复用器(terminal multiplexer)</p><h2 id="tmux-能干什么"><a href="#tmux-能干什么" class="headerlink" title="tmux 能干什么"></a>tmux 能干什么</h2><p>命令行的典型使用方式是，打开一个终端窗口（terminal window，以下简称”窗口”），在里面输入命令。<strong>用户与计算机的这种临时的交互，称为一次”会话”（session）</strong> 。</p><p>会话的一个重要特点是，窗口与其中启动的进程是<a href="https://www.ruanyifeng.com/blog/2016/02/linux-daemon.html">连在一起</a>的。打开窗口，会话开始；关闭窗口，会话结束，会话内部的进程也会随之终止，不管有没有运行完。</p><p>一个典型的例子就是，<a href="https://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html">SSH 登录</a>远程计算机，打开一个远程窗口执行一个命令例如<code>iperf3 -s</code>。这时，关掉SSH，会发现<code>iperf3</code>进程也被关掉了。这是因为<code>iperf3</code>属于SSH的子进程，SSH作为父进程，如果父进程关掉了，子进程也就关掉了。</p><p>为了解决这个问题，会话与窗口可以”解绑”：窗口关闭时，会话并不终止，而是继续运行，等到以后需要的时候，再让会话”绑定”其他窗口。</p><p><strong>Tmux 就是会话与窗口的”解绑”工具，将它们彻底分离。</strong></p><blockquote><ul><li>它允许在单个窗口中，同时访问多个会话。这对于同时运行多个命令行程序很有用。</li><li>它可以让新窗口”接入”已经存在的会话。</li><li>它允许每个会话有多个连接窗口，因此可以多人实时共享会话。</li><li>它还支持窗口任意的垂直和水平拆分。</li></ul></blockquote><p>类似的终端复用器还有 GNU Screen。Tmux 与它功能相似，但是更易用，也更强大。</p><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p>Tmux 一般需要自己安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Ubuntu 或 Debian</span><br>$ sudo apt-get install tmux<br><br><span class="hljs-comment"># 启动</span><br>$ tmux<br><br><span class="hljs-comment"># 退出</span><br>$ <span class="hljs-built_in">exit</span><br></code></pre></td></tr></table></figure><p>启动后底部<u>左边</u>是<strong>窗口</strong>信息（编号和名称），<u>右侧</u>是系统信息。</p><p><img src="/2022/9d389561/image-20220929235001871.png" alt="image-20220929235001871"></p><p>按下<code>Ctrl+d</code>或者显式输入<code>exit</code>命令，就可以退出 Tmux 窗口。</p><h2 id="前缀键☆"><a href="#前缀键☆" class="headerlink" title="前缀键☆"></a><strong>前缀键</strong>☆</h2><p>Tmux 窗口有大量的快捷键。所有快捷键都要通过前缀键唤起。默认的前缀键是<code>Ctrl+b</code>，即先按下<code>Ctrl+b</code>，快捷键才会生效。</p><p>举例来说，帮助命令的快捷键是<code>Ctrl+b ?</code>。它的用法是，在 Tmux 窗口中，先按下<code>Ctrl+b</code>，再按下<code>?</code>，就会显示帮助信息。</p><p>然后，按下 ESC 键或<code>q</code>键，就可以退出帮助。</p><h2 id="会话-窗格-窗口-的概念☆"><a href="#会话-窗格-窗口-的概念☆" class="headerlink" title="会话  窗格  窗口  的概念☆"></a><strong>会话  窗格  窗口  的概念</strong>☆</h2><blockquote><p>  会话 session<br>  窗口 windows<br>  窗格 pane</p></blockquote><ul><li><code>tmux new</code>的是会话, 会话可以包括多个窗口, 窗口内可以有多个窗格</li></ul><ul><li><code>tmux ls</code> 列出的是会话</li></ul><p><img src="/2022/9d389561/image-20220930003505311.png" alt="image-20220930003505311"></p><h1 id="会话的管理"><a href="#会话的管理" class="headerlink" title="会话的管理"></a>会话的管理</h1><h2 id="快捷键☆"><a href="#快捷键☆" class="headerlink" title="快捷键☆"></a>快捷键☆</h2><p>下面是一些会话相关的快捷键。</p><blockquote><ul><li><code>Ctrl+b d</code>：分离当前会话。</li><li><code>Ctrl+b s</code>：列出所有会话。</li><li><code>Ctrl+b $</code>：重命名当前会话。</li></ul></blockquote><h2 id="3-1-new新建会话☆"><a href="#3-1-new新建会话☆" class="headerlink" title="3.1 new新建会话☆"></a>3.1 new新建会话☆</h2><p>第一个启动的 Tmux 窗口，编号是<code>0</code>，第二个窗口的编号是<code>1</code>，以此类推。这些窗口对应的会话，就是 0 号会话、1 号会话。</p><p>使用编号区分会话，不太直观，更好的方法是为会话起名。</p><blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 直接新建一个</span><br>$ tmux<br><span class="hljs-comment"># 新建并设置一个名字</span><br>$ tmux new -s &lt;session-name&gt;<br></code></pre></td></tr></table></figure></blockquote><p>上面命令新建一个指定名称的会话。</p><p>在<code>tmux</code>内应该是无法执行这个指令的, 需要分屏参考下面的窗格操作章节.</p><h2 id="3-2-detach分离会话☆"><a href="#3-2-detach分离会话☆" class="headerlink" title="3.2 detach分离会话☆"></a>3.2 detach分离会话☆</h2><p>在 Tmux 窗口中，按下<code>Ctrl+b d</code>或者输入<code>tmux detach</code>命令，就会将当前会话与窗口分离。</p><blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux detach<br></code></pre></td></tr></table></figure></blockquote><p>上面命令执行后，就会退出当前 Tmux 窗口，但是会话和里面的进程仍然在后台运行。</p><p><code>tmux ls</code>命令可以查看当前所有的 Tmux 会话。</p><blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux <span class="hljs-built_in">ls</span><br><span class="hljs-comment"># or</span><br>$ tmux list-session<br></code></pre></td></tr></table></figure></blockquote><h2 id="3-3-attach接入会话☆"><a href="#3-3-attach接入会话☆" class="headerlink" title="3.3 attach接入会话☆"></a>3.3 attach接入会话☆</h2><p><code>tmux attach</code>命令用于重新接入某个已存在的会话。</p><blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用会话编号</span><br>$ tmux attach -t 0<br><br><span class="hljs-comment"># 使用会话名称</span><br>$ tmux attach -t &lt;session-name&gt;<br></code></pre></td></tr></table></figure></blockquote><h2 id="3-4-kill-session杀死会话☆"><a href="#3-4-kill-session杀死会话☆" class="headerlink" title="3.4 kill-session杀死会话☆"></a>3.4 kill-session杀死会话☆</h2><p><code>tmux kill-session</code>命令用于杀死某个会话。</p><blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用会话编号</span><br>$ tmux kill-session -t 0<br><br><span class="hljs-comment"># 使用会话名称</span><br>$ tmux kill-session -t &lt;session-name&gt;<br></code></pre></td></tr></table></figure></blockquote><h2 id="3-5-切换会话"><a href="#3-5-切换会话" class="headerlink" title="3.5 切换会话"></a>3.5 切换会话</h2><p><code>tmux switch</code>命令用于切换会话。</p><blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用会话编号</span><br>$ tmux switch -t 0<br><br><span class="hljs-comment"># 使用会话名称</span><br>$ tmux switch -t &lt;session-name&gt;<br></code></pre></td></tr></table></figure></blockquote><h2 id="3-6-重命名会话"><a href="#3-6-重命名会话" class="headerlink" title="3.6 重命名会话"></a>3.6 重命名会话</h2><p><code>tmux rename-session</code>命令用于重命名会话。</p><blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux rename-session -t 0 &lt;new-name&gt;<br></code></pre></td></tr></table></figure></blockquote><p>上面命令将0号会话重命名。</p><h1 id="窗格操作"><a href="#窗格操作" class="headerlink" title="窗格操作"></a>窗格操作</h1><h2 id="快捷键☆-1"><a href="#快捷键☆-1" class="headerlink" title="快捷键☆"></a>快捷键☆</h2><blockquote><ul><li><code>Ctrl+b %</code>：划分左右两个窗格。☆</li><li><code>Ctrl+b &quot;</code>：划分上下两个窗格。☆</li><li><code>Ctrl+b &lt;arrow key&gt;</code>：光标切换到其他窗格。<code>&lt;arrow key&gt;</code>是指向要切换到的窗格的方向键，比如切换到下方窗格，就按方向键<code>↓</code>。☆</li><li><code>Ctrl+b ;</code>：光标切换到上一个窗格。</li><li><code>Ctrl+b o</code>：光标切换到下一个窗格。</li><li><code>Ctrl+b &#123;</code>：当前窗格与上一个窗格交换位置。☆</li><li><code>Ctrl+b &#125;</code>：当前窗格与下一个窗格交换位置。☆</li><li><code>Ctrl+b Ctrl+o</code>：所有窗格向前移动一个位置，第一个窗格变成最后一个窗格。</li><li><code>Ctrl+b Alt+o</code>：所有窗格向后移动一个位置，最后一个窗格变成第一个窗格。</li><li><code>Ctrl+b x</code>：关闭当前窗格。☆</li><li><code>Ctrl+b !</code>：将当前窗格拆分为一个独立窗口。</li><li><code>Ctrl+b z</code>：当前窗格全屏显示，再使用一次会变回原来大小。</li><li><code>Ctrl+b Ctrl+&lt;arrow key&gt;</code>：按箭头方向调整窗格大小。☆</li><li><code>Ctrl+b q</code>：显示窗格编号。</li></ul></blockquote><h2 id="5-1-划分窗格"><a href="#5-1-划分窗格" class="headerlink" title="5.1 划分窗格"></a>5.1 划分窗格</h2><p><code>tmux split-window</code>命令用来划分窗格。</p><blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 划分上下两个窗格</span><br>$ tmux split-window<br><br><span class="hljs-comment"># 划分左右两个窗格</span><br>$ tmux split-window -h<br></code></pre></td></tr></table></figure></blockquote><h2 id="5-2-移动光标"><a href="#5-2-移动光标" class="headerlink" title="5.2 移动光标"></a>5.2 移动光标</h2><p><code>tmux select-pane</code>命令用来移动光标位置。</p><blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 光标切换到上方窗格</span><br>$ tmux select-pane -U<br><br><span class="hljs-comment"># 光标切换到下方窗格</span><br>$ tmux select-pane -D<br><br><span class="hljs-comment"># 光标切换到左边窗格</span><br>$ tmux select-pane -L<br><br><span class="hljs-comment"># 光标切换到右边窗格</span><br>$ tmux select-pane -R<br></code></pre></td></tr></table></figure></blockquote><h2 id="5-3-交换窗格位置"><a href="#5-3-交换窗格位置" class="headerlink" title="5.3 交换窗格位置"></a>5.3 交换窗格位置</h2><p><code>tmux swap-pane</code>命令用来交换窗格位置。</p><blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 当前窗格上移</span><br>$ tmux swap-pane -U<br><br><span class="hljs-comment"># 当前窗格下移</span><br>$ tmux swap-pane -D<br></code></pre></td></tr></table></figure></blockquote><h1 id="窗口管理"><a href="#窗口管理" class="headerlink" title="窗口管理"></a>窗口管理</h1><h2 id="快捷键☆-2"><a href="#快捷键☆-2" class="headerlink" title="快捷键☆"></a>快捷键☆</h2><p>下面是一些窗口操作的快捷键。</p><blockquote><ul><li><code>Ctrl+b c</code>：创建一个新窗口，状态栏会显示多个窗口的信息。</li><li><code>Ctrl+b p</code>：切换到上一个窗口（按照状态栏上的顺序）。</li><li><code>Ctrl+b n</code>：切换到下一个窗口。</li><li><code>Ctrl+b &lt;number&gt;</code>：切换到指定编号的窗口，其中的<code>&lt;number&gt;</code>是状态栏上的窗口编号。</li><li><code>Ctrl+b w</code>：从列表中选择窗口。</li><li><code>Ctrl+b ,</code>：窗口重命名。</li></ul></blockquote><h2 id="6-1-新建窗口"><a href="#6-1-新建窗口" class="headerlink" title="6.1 新建窗口"></a>6.1 新建窗口</h2><p><code>tmux new-window</code>命令用来创建新窗口。</p><blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux new-window<br><br><span class="hljs-comment"># 新建一个指定名称的窗口</span><br>$ tmux new-window -n &lt;window-name&gt;<br></code></pre></td></tr></table></figure></blockquote><h2 id="6-2-切换窗口"><a href="#6-2-切换窗口" class="headerlink" title="6.2 切换窗口"></a>6.2 切换窗口</h2><p><code>tmux select-window</code>命令用来切换窗口。</p><blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 切换到指定编号的窗口</span><br>$ tmux select-window -t &lt;window-number&gt;<br><br><span class="hljs-comment"># 切换到指定名称的窗口</span><br>$ tmux select-window -t &lt;window-name&gt;<br></code></pre></td></tr></table></figure></blockquote><h2 id="6-3-重命名窗口"><a href="#6-3-重命名窗口" class="headerlink" title="6.3 重命名窗口"></a>6.3 重命名窗口</h2><p><code>tmux rename-window</code>命令用于为当前窗口起名（或重命名）。</p><blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux rename-window &lt;new-name&gt;<br></code></pre></td></tr></table></figure></blockquote><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><h2 id="一些其他的快捷键"><a href="#一些其他的快捷键" class="headerlink" title="一些其他的快捷键"></a>一些其他的快捷键</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 列出所有快捷键，及其对应的 Tmux 命令</span><br>$ tmux list-keys<br><br><span class="hljs-comment"># 列出所有 Tmux 命令及其参数</span><br>$ tmux list-commands<br><br><span class="hljs-comment"># 列出当前所有 Tmux 会话的信息</span><br>$ tmux info<br><br><span class="hljs-comment"># 重新加载当前的 Tmux 配置</span><br>$ tmux source-file ~/.tmux.conf<br></code></pre></td></tr></table></figure><h2 id="开启鼠标支持"><a href="#开启鼠标支持" class="headerlink" title="开启鼠标支持"></a>开启鼠标支持</h2><p>tmux2 以上版本和 tmux2 以上版本有所不同</p><blockquote><p>  查看版本<code>tmux -V</code></p><p>  注意大写</p></blockquote><h3 id="tmux2-以上"><a href="#tmux2-以上" class="headerlink" title="tmux2 以上"></a>tmux2 以上</h3><p><strong>写入配置文件</strong></p><p>在<code>~/.tmux.conf</code>中加入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Enable mouse mode (tmux 2.1 and above)</span><br><span class="hljs-built_in">set</span> -g mouse on<br><br><span class="hljs-comment"># Mouse based copy</span><br>bind-key -T copy-mode-vi MouseDragEnd1Pane send -X copy-pipe-and-cancel <span class="hljs-string">&quot;reattach-to-user-namespace pbcopy&quot;</span><br>bind-key -T copy-mode MouseDragEnd1Pane send -X copy-pipe-and-cancel <span class="hljs-string">&quot;reattach-to-user-namespace pbcopy&quot;</span> <br></code></pre></td></tr></table></figure><p><strong>临时使用</strong></p><p>按完前缀ctrl+B后，再按冒号：进入<code>命令行</code>模式，输入<code>set -g mouse on</code></p><h3 id="tmux2-以下"><a href="#tmux2-以下" class="headerlink" title="tmux2 以下"></a>tmux2 以下</h3><p><strong>写入配置文件</strong></p><p>在<code>~/.tmux.conf</code>中加入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">setw -g mouse-resize-pane on<br>setw -g mouse-select-pane on<br>setw -g mouse-select-window on<br>setw -g mode-mouse on<br></code></pre></td></tr></table></figure><blockquote><p>  这几行的作用分别是:<br>  开启用鼠标拖动调节pane的大小（拖动位置是pane之间的分隔线）<br>  开启用鼠标点击pane来激活该pane<br>  开启用鼠标点击来切换活动window（点击位置是状态栏的窗口名称）<br>  开启window&#x2F;pane里面的鼠标支持（也即可以用鼠标滚轮回滚显示窗口内容，此时还可以用鼠标选取文本）</p></blockquote><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.hamvocke.com/blog/a-quick-and-easy-guide-to-tmux/">A Quick and Easy Guide to tmux</a></li><li><a href="https://danielmiessler.com/study/tmux/">Tactical tmux: The 10 Most Important Commands</a></li><li><a href="https://linuxize.com/post/getting-started-with-tmux/">Getting started with Tmux</a></li><li><a href="https://www.ruanyifeng.com/blog/2019/10/tmux.html">阮一峰</a></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;tmux-终端复用器-terminal-multiplexer&quot;&gt;&lt;a href=&quot;#tmux-终端复用器-terminal-multiplexer&quot; class=&quot;headerlink&quot; title=&quot;tmux</summary>
        
      
    
    
    
    <category term="tools" scheme="https://www.oikiou.top/categories/tools/"/>
    
    
    <category term="linux" scheme="https://www.oikiou.top/tags/linux/"/>
    
    <category term="tmux" scheme="https://www.oikiou.top/tags/tmux/"/>
    
  </entry>
  
  <entry>
    <title>我的工作法</title>
    <link href="https://www.oikiou.top/2022/a1ed3941/"/>
    <id>https://www.oikiou.top/2022/a1ed3941/</id>
    <published>2022-09-19T12:54:03.000Z</published>
    <updated>2022-09-22T14:26:35.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="我的工作法"><a href="#我的工作法" class="headerlink" title="我的工作法"></a>我的工作法</h1><p><a href="https://unknwon.cn/2021/211013-boring-methodology-to-be-productive/">高效工作法的朴素方法论 -By无闻</a></p><p><a href="https://zhuanlan.zhihu.com/p/42694082">逗总出品：GTD最全面教程，从入门到精通</a></p><h1 id="出来玩最重要的是出来"><a href="#出来玩最重要的是出来" class="headerlink" title="出来玩最重要的是出来"></a>出来玩最重要的是出来</h1><p>不管今天一天做什么惊天地的大事, 第一步都是先起床.</p><h2 id="花三分钟安排一天"><a href="#花三分钟安排一天" class="headerlink" title="花三分钟安排一天"></a>花三分钟安排一天</h2><p>每天开始，先梳理一遍今日视图里的所有任务</p><p>梳理任务的关键在于对于自己实际的产出效率和可用时间上的正确评判</p><h2 id="创造仪式感"><a href="#创造仪式感" class="headerlink" title="创造仪式感"></a>创造仪式感</h2><p>有的人喜欢喝咖啡, 比如倒好一杯咖啡之后就放下手机, 避免去接触任何和当前手上事务不相关的内容(放下手机并让它远离自己).</p><h1 id="推送通知是互联网时代的毒药"><a href="#推送通知是互联网时代的毒药" class="headerlink" title="推送通知是互联网时代的毒药"></a>推送通知是互联网时代的毒药</h1><p>我注意到推送通知经常会带给人们焦虑的情绪，尤其是工作上的，我对此也深恶痛绝。</p><ul><li>在工作时间(专注的时间)关掉它们(尤其是手机), 别让他们打断你的工作节奏</li></ul><h1 id="异步沟通是健康的协作方式"><a href="#异步沟通是健康的协作方式" class="headerlink" title="异步沟通是健康的协作方式"></a>异步沟通是健康的协作方式</h1><p>实时沟通会打断各自的计划, 能够以异步沟通完成的事, 千万不要去同步沟通.  </p><p>马斯克同样推崇异步沟通</p><p><a href="https://www.youtube.com/watch?v=kLscv2VAQEE">https://www.youtube.com/watch?v=kLscv2VAQEE</a></p><h1 id="给自己放个假"><a href="#给自己放个假" class="headerlink" title="给自己放个假"></a>给自己放个假</h1><p>软件类属创造性工作，而人类大脑又是世界上最复杂、最精密的仪器。</p><p>超时长工作并不会使得大脑变得更具创造性，因为每个机械师都知道零部件需要定期检查和维护。</p><p><strong>恐怕你也无法想象你的航空公司会告诉你某架次飞机会因为长期没有检修而飞得更快吧？</strong></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;我的工作法&quot;&gt;&lt;a href=&quot;#我的工作法&quot; class=&quot;headerlink&quot; title=&quot;我的工作法&quot;&gt;&lt;/a&gt;我的工作法&lt;/h1&gt;&lt;p&gt;&lt;a</summary>
        
      
    
    
    
    <category term="life" scheme="https://www.oikiou.top/categories/life/"/>
    
    
    <category term="life" scheme="https://www.oikiou.top/tags/life/"/>
    
    <category term="workflow" scheme="https://www.oikiou.top/tags/workflow/"/>
    
  </entry>
  
  <entry>
    <title>JPEG JPEG2000 WebP PNG GIF对比</title>
    <link href="https://www.oikiou.top/2022/bc4a75ff/"/>
    <id>https://www.oikiou.top/2022/bc4a75ff/</id>
    <published>2022-09-18T05:47:15.000Z</published>
    <updated>2022-09-18T14:38:55.274Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图像的显示原理"><a href="#图像的显示原理" class="headerlink" title="图像的显示原理"></a>图像的显示原理</h1><h2 id="有损-x2F-无损压缩"><a href="#有损-x2F-无损压缩" class="headerlink" title="有损&#x2F;无损压缩"></a>有损&#x2F;无损压缩</h2><p>图片文件格式有可能会对图片的文件大小进行不同程度的压缩，图片的压缩分为有损压缩和无损压缩两种。</p><h3 id="有损压缩"><a href="#有损压缩" class="headerlink" title="有损压缩"></a>有损压缩</h3><p>对图像本身的改变，在保存图像时保留了较多的亮度信息，而将色相和色纯度的信息和周围的像素进行合并，合并的比例不同，压缩的比例也不同，由于信息量减少了，所以压缩比可以很高，图像质量也会相应的下降。并且这种损失是不可逆的，我们不可能从有一个有损压缩过的图片中恢复出全来的图片。常见的有损压缩手段，是按照一定的算法将临近的像素点进行合并。<br><strong>有损压缩的原理：</strong> <em>删除景物边缘的某些颜色部分，当人们在屏幕上观看这个场景图片，大脑会利用在景物上看到的颜色填补所丢失的颜色部分。</em><br><strong>有损压缩的优缺点：</strong> <em>是保持颜色的逐渐变化，删除图像中颜色的突然变化。生物学中的大量实验证明，人类大脑会利用与附近最接近的颜色来填补所丢失的颜色。例如，对于蓝色天空背景上的一朵白云，有损压缩的方法就是删除图像中景物边缘的某些颜色部分。当在·屏幕上看这幅图时，大脑会利用在景物上看到的颜色填补所丢失的颜色部分。利用有损压缩技术，某些数据被有意地删除了，而被取消的数据也不再恢复。 无可否认，利用有损压缩技术可以大大地压缩文件的数据，但是会影响图像质量。如果使用了有损压缩的图像仅在屏幕上显示，可能对图像质量影响不太大，至少对于人类眼睛的识别程度来说区别不大。可是，如果要把一幅经过有损压缩技术处理的图像用高分辨率打印机打印出来，那么图像质量就会有明显的受损痕迹。</em></p><h3 id="无损压缩"><a href="#无损压缩" class="headerlink" title="无损压缩"></a>无损压缩</h3><p>无损压缩的基本原理是相同的颜色信息只需保存一次。压缩图像的软件首先会确定图像中哪些区域是相同的，哪些是不同的。包括了重复数据的图像(如蓝天) 就可以被压缩，只有蓝天的起始点和终结点需要被记录下来。但是蓝色可能还会有不同的深浅，天空有时也可能被树木、山峰或其他的对象掩盖，这些就需要另外记录。从本质上看，无损压缩的方法可以删除一些重复数据，大大减少要在磁盘上保存的图像尺寸。但是，无损压缩的方法并不能减少图像的内存占用量，这是因为，当从磁盘上读取图像时，软件又会把丢失的像素用适当的颜色信息填充进来。如果要减少图像占用内存的容量，就必须使用有损压缩方法。<br><strong>无损压缩的特点：</strong> <em>相同的颜色信息只需保存一次。</em><br><strong>无损压缩的原理：</strong> <em>首先辨别出相同颜色的区域，然后把这些相同的数据信息进行压缩记录，也就是记录它的颜色信息、起始和终止位置。</em></p><h2 id="索引色-x2F-直接色"><a href="#索引色-x2F-直接色" class="headerlink" title="索引色&#x2F;直接色"></a>索引色&#x2F;直接色</h2><p>计算机在表示颜色的时候，有两种形式，一种称作索引颜色(Index Color)，一种称作直接颜色(Direct Color)。</p><h3 id="索引色。"><a href="#索引色。" class="headerlink" title="索引色。"></a>索引色。</h3><p>是一种以有限的方式管理数字图像颜色的技术，以节省计算机内存和文件存储，同时加速显示刷新和文件传输。即用一个数字来代表（索引）一种颜色，在存储图片的时候，存储一个数字的组合，同时存储数字到图片颜色的映射。这种方式只能存储有限种颜色，通常是256种颜色，对应到计算机系统中，使用一个字节的数字来索引一种颜色。</p><h3 id="直接色。"><a href="#直接色。" class="headerlink" title="直接色。"></a>直接色。</h3><p>使用四个数字来代表一种颜色，这四个数字分别代表这个颜色中红色、绿色、蓝色以及透明度（即rgba）。现在流行的显示设备可以在这四个维度分别支持256种变化，所以直接色可以表示2的32次方种颜色。当然并非所有的直接色都支持这么多种，为压缩空间使用，有可能只有表达红、绿、蓝的三个数字，每个数字也可能不支持256种变化之多</p><h2 id="位图-x2F-矢量图"><a href="#位图-x2F-矢量图" class="headerlink" title="位图&#x2F;矢量图"></a>位图&#x2F;矢量图</h2><h3 id="位图。"><a href="#位图。" class="headerlink" title="位图。"></a>位图。</h3><p>位图也叫做点阵图，栅格图像，像素图。简单的说，就是最小单位由像素构成的图，缩放会失真。构成位图的最小单位是像素，位图就是由像素阵列的排列来实现其显示效果的，每个像素有自己的颜色信息，在对位图图像进行编辑操作的时候，可操作的对象是每个像素，我们可以改变图像的色相、饱和度、明度，从而改变图像的显示效果。举个例子来说，位图图像就好比在巨大的沙盘上画好的画，当你从远处看的时候，画面细腻多彩，但是当你靠的非常近的时候，你就能看到组成画面的每粒沙子以及每个沙粒单纯的不可变化颜色。</p><h3 id="矢量图，"><a href="#矢量图，" class="headerlink" title="矢量图，"></a>矢量图，</h3><p>也叫做向量图。矢量图并不纪录画面上每一点的信息，而是纪录了元素形状及颜色的算法，当你打开一付矢量图的时候，软件对图形象对应的函数进行运算，将运算结果[图形的形状和颜色]显示给你看。无论显示画面是大还是小，画面上的对象对应的算法是不变的，所以，即使对画面进行倍数相当大的缩放，其显示效果仍然相同(不失真)。</p><h1 id="JPEG-JPEG2000-WebP"><a href="#JPEG-JPEG2000-WebP" class="headerlink" title="JPEG JPEG2000 WebP"></a>JPEG JPEG2000 WebP</h1><blockquote><p>  摘录自知乎: </p><p>  原文: <a href="https://zhuanlan.zhihu.com/p/19586108">https://zhuanlan.zhihu.com/p/19586108</a></p><p>  作者: <a href="https://www.zhihu.com/people/xhacker">柳东原</a> This Xhacker has super Big Cat power.</p></blockquote><p><strong>压缩性能综合看来，WebP 略好于 JPEG2000，而这两者都明显好于 JPEG。</strong></p><p>前段时间测试了一下这三种有损图像压缩算法的质量。（WebP 也能支持无损，不过这里只测试有损。）</p><p>测试结果（<a href="https://link.zhihu.com/?target=http://en.wikipedia.org/wiki/Structural_similarity">SSIM Index</a> 可理解为图片与原图片的相似度）：</p><p><img src="/2022/bc4a75ff/6dd37790364b1a5e709f8e67adab81d3_r.jpg" alt="img"></p><p><img src="/2022/bc4a75ff/868c8f801447ee85c0867556cdb1f705_r.jpg" alt="img"></p><p><img src="/2022/bc4a75ff/85ab2ef874126a10072e4669d9cd7c90_720w.jpg" alt="img"></p><p><img src="/2022/bc4a75ff/ea62d92a63b45aa121eb0ccfce4a97fd_720w.jpg" alt="img"></p><p><img src="/2022/bc4a75ff/6cdab6a9efdf3df3fba2657314d81734_720w.jpg" alt="img"></p><p><img src="/2022/bc4a75ff/323465387e562470441127b8f0cc992e_720w.jpg" alt="img"></p><p>测试细节：对于 JPEG 使用 libjpeg 压缩，JPEG 2000 使用 OpenJPEG，WebP 使用 libwebp。</p><h1 id="JPEG-PNG-GIF-WEBP"><a href="#JPEG-PNG-GIF-WEBP" class="headerlink" title="JPEG PNG GIF WEBP"></a>JPEG PNG GIF WEBP</h1><p><strong>综合看来</strong></p><ul><li>PNG 可以保存透明信息, 比较适合颜色单一, 主要是纯色的图像, ( logo&#x2F;icon&#x2F;透明图 )</li><li>JPEG 适用颜色种类多样 且颜色变化明显的图片 ( 一般照片 )</li><li>GIF 支持动画,透明, 只有8位颜色 ( 动图 )</li><li>WEBP 文件小, 支持透明, 有损无损压缩, 支持动画, 兼容性不好 ( 网页图像 )</li></ul><h2 id="JPEG"><a href="#JPEG" class="headerlink" title="JPEG"></a>JPEG</h2><p>JPEG是有损的、采用直接色的、位图。JPEG也是一种针对照片影像而广泛使用的有损压缩标准方法。JPEG图片格式的设计目标，是在不影响人类可分辨的图片质量的前提下，尽可能的压缩文件大小。这意味着JPEG去掉了一部分图片的原始信息，也即是进行了有损压缩。JPEG的图片的优点，是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，用来表达更生动的图像效果，比如颜色渐变。</p><ul><li>特性：适用于存储色彩丰富、层次分明的图片，不适合于线条绘图（drawing）和其他文字或图标（iconic）的图形，因为它的压缩方法用在这些类型的图形上，得到的结果并不好(PNG和GIF通常是用来存储这类的图形)</li></ul><h2 id="PNG"><a href="#PNG" class="headerlink" title="PNG"></a>PNG</h2><p>便携式网络图形是一种无损压缩的位图图形格式，支持索引、灰度、RGB三种颜色方案以及Alpha通道等特性</p><ul><li>特性：如果保存文本，线条或类似的边缘清晰，有大块相同颜色区域的图像，PNG格式的压缩效果就要比JPEG好很多，并且不会出现JPEG那样的高对比度区域的图像有损。如果图像既有清晰边缘，又有照片图像的特点，就需要在这两种格式之间权衡一下了。JPEG不支持透明度。<br>PNG格式有8位、24位、32位三种形式,其中8位PNG支持两种不同 的透明形式（索引透明和alpha透明）,24位PNG不支持透明,32位 PNG 在24位基础上增加了8位透明通道（32-24&#x3D;&#x3D;&#x3D;8）,因此可展现256级透明程度。</li></ul><h3 id="PNG8"><a href="#PNG8" class="headerlink" title="PNG8"></a>PNG8</h3><p>PNG8是<strong>无损的、使用索引色的、点阵图</strong>,支持不透明、索引透明、Alpha透明，都最多只能展示256（2的8次方）种颜色，所以“PNG8”格式更适合那些颜色比较单一的图像，例如纯色、logo、图标等；因为颜色数量少，所以图片的体积也会更小；</p><ul><li><p>PNG8(不透明),默认PNG8</p></li><li><p>PNG8(索引色透明),简单说可以理解为静态的GIF<br>指定一个像素点是不是透明<br>但是PNG由于算法的优势,体积比较少<br>所以,静态GIF完全可用PNG8取代</p></li><li><p>PNG8(Alpha透明),牛逼在可指定像素点的透明度,例如50%透明度<br>这种优点在于比PNG24&#x2F;32体积小,因为也只有256色嘛<br>缺点在于IE6支持不好,会把半透明的像素点显示成全透明</p></li></ul><h3 id="PNG24"><a href="#PNG24" class="headerlink" title="PNG24"></a>PNG24</h3><p>是PNG的直接色版本。PNG24是<strong>无损的、使用直接色的、点阵图</strong>,支持2的24次方种颜色，表现为不透明。用三个8bits分别去表示 R（红）、G（绿）、B（蓝）。R(0255),G(0255),B(0~255)，可以表达256乘以256乘以256&#x3D;16777216种颜色的图片，这样PNG24就能比PNG8表示色彩更丰富的图片,图片的清晰度也会更好，图片质量更高，当然图片的大小也会相应增加，所以“PNG24”的图片比较适合像摄影作品之类颜色比较丰富的图片<br>PNG24与JPG一样能表达丰富的图片细节，但并不能替代JPG。图片存储为PNG24比存储为JPG，文件大小至少是JPG的5倍，但在图片品质上的提升却微乎其微。所以除非对品质的要求极高，否则色彩丰富的网络图片还是推荐使用JPG</p><h3 id="PNG32"><a href="#PNG32" class="headerlink" title="PNG32"></a>PNG32</h3><p>支持2的32次方种颜色，32位是我们最常使用的格式，它是在PNG在24位的PNG基础上增加了8位的透明信息，支持不同程度的半透效果</p><h3 id="PNG8-PNG24-PNG32三者的区别在于："><a href="#PNG8-PNG24-PNG32三者的区别在于：" class="headerlink" title="PNG8\PNG24\PNG32三者的区别在于："></a>PNG8\PNG24\PNG32三者的区别在于：</h3><ul><li>PNG-32每个像素的深度为32bits，其中RGBA四个通道各占8bits。所谓的RGBA四个通道，就是红，绿，蓝，透明 这四种色值各自的大小，都用8bits来表示（0～255）。</li><li>PNG-24的像素深度为24bits，其中RGB三个通道各占8bits。</li><li>PNG-8则是使用8位的索引色。</li></ul><h2 id="GIF"><a href="#GIF" class="headerlink" title="GIF"></a>GIF</h2><p>GIF是一种<strong>无损、使用于索引色的、位图</strong>。由于采用了无损压缩，相比古老的bmp格式，尺寸较小，而且支持透明和动画。缺点是由于gif只存储8位索引（也就是最多能表达2^8&#x3D;256种颜色），色彩复杂、细节丰富的图片不适合保存为gif格式。色彩简单的logo、icon、线框图适合采用gif格式。</p><p>静态GIF完全可用PNG8取代</p><h2 id="WEBP"><a href="#WEBP" class="headerlink" title="WEBP"></a>WEBP</h2><p>WebP图片是一种同时提供了<strong>有损压缩与无损压缩、使用直接色的、位图</strong>，由Google开发。与png、jpg相比，相同的视觉体验下，WebP图像的尺寸缩小了大约30％。另外，WebP图像格式还支持有损压缩、无损压缩、透明和动画。理论上完全可以替代png、jpg、gif等图片格式，当然目前webp的还没有得到全面的支持。</p><p>WEBP与PNG压缩对比</p><p><img src="/2022/bc4a75ff/formatpng.png" alt="img"></p><p>可以得出结论：</p><blockquote><p>  PNG 转 WebP 的压缩率要高于 PNG 原图压缩率，同样支持有损与无损压缩<br>  转换后的 WebP 体积大幅减少，图片质量也得到保障（同时肉眼几乎无法看出差异）<br>  转换后的 WebP 支持 Alpha 透明和 24-bit 颜色数，不存在 PNG8 色彩不够丰富和在浏览器中可能会出现毛边的问题</p></blockquote>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;图像的显示原理&quot;&gt;&lt;a href=&quot;#图像的显示原理&quot; class=&quot;headerlink&quot; title=&quot;图像的显示原理&quot;&gt;&lt;/a&gt;图像的显示原理&lt;/h1&gt;&lt;h2 id=&quot;有损-x2F-无损压缩&quot;&gt;&lt;a</summary>
        
      
    
    
    
    <category term="blog" scheme="https://www.oikiou.top/categories/blog/"/>
    
    
    <category term="jpeg" scheme="https://www.oikiou.top/tags/jpeg/"/>
    
    <category term="webp" scheme="https://www.oikiou.top/tags/webp/"/>
    
    <category term="jpeg2000" scheme="https://www.oikiou.top/tags/jpeg2000/"/>
    
    <category term="image" scheme="https://www.oikiou.top/tags/image/"/>
    
  </entry>
  
  <entry>
    <title>文件后缀与文件</title>
    <link href="https://www.oikiou.top/2022/631793c8/"/>
    <id>https://www.oikiou.top/2022/631793c8/</id>
    <published>2022-09-15T09:47:15.000Z</published>
    <updated>2022-09-22T14:43:37.040Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件后缀与文件"><a href="#文件后缀与文件" class="headerlink" title="文件后缀与文件"></a>文件后缀与文件</h1><table><thead><tr><th>后缀</th><th>名称描述</th><th>简述</th></tr></thead><tbody><tr><td><code>.DS_Store</code></td><td>Desktop Services Store</td><td>Mac OS X操作系统所创造的隐藏文件，类似<code>desktop.ini</code></td></tr></tbody></table><h2 id="编辑历史"><a href="#编辑历史" class="headerlink" title="编辑历史"></a>编辑历史</h2><table><thead><tr><th>date</th><th>note</th></tr></thead><tbody><tr><td>2022.9.15</td><td>First Version</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h2 id="DS-Store"><a href="#DS-Store" class="headerlink" title=".DS_Store"></a>.DS_Store</h2><blockquote><p>  DS_Store，英文全称是 Desktop Services Store（桌面服务存储），开头的 DS 是 Desktop Services（桌面服务） 的缩写。它是一种由macOS系统自动创建的隐藏文件，存在于每一个用「Finder」打开过的文件夹下面。</p><p>  <code>.DS_Store</code> 是一种由苹果公司的Mac OS X操作系统所创造的隐藏文件，目的在于存贮目录的自定义属性，例如文件们的图标位置或者是背景色的选择。该文件由<code>Finder</code>创建并维护，类似于<code>Microsoft Windows</code>中的<code>desktop.ini</code>文件。</p></blockquote><h2 id="RTF"><a href="#RTF" class="headerlink" title=".RTF"></a>.RTF</h2><blockquote><p>  <strong>富文本格式</strong>（<strong>Rich Text Format</strong>）即<strong>RTF格式</strong>，又称<strong>多文本格式</strong>，是由<a href="https://zh.wikipedia.org/wiki/%E5%BE%AE%E8%BD%AF">微软</a>公司开发的跨平台<a href="https://zh.wikipedia.org/wiki/%E6%96%87%E6%A1%A3">文档</a>格式。大多数的<a href="https://zh.wikipedia.org/wiki/%E6%96%87%E5%AD%97%E5%A4%84%E7%90%86">文字处理</a>软件都能读取和保存RTF文档。</p><h2 id="支持软件"><a href="#支持软件" class="headerlink" title="支持软件"></a>支持软件</h2><ul><li><a href="https://zh.wikipedia.org/wiki/WordPad">WordPad</a>（<a href="https://zh.wikipedia.org/wiki/Microsoft_Windows">Microsoft Windows</a>）&#x2F; <a href="https://zh.wikipedia.org/wiki/%E6%96%87%E5%AD%97%E7%B7%A8%E8%BC%AF_(%E6%87%89%E7%94%A8%E7%A8%8B%E5%BC%8F)">文本编辑</a>（<a href="https://zh.wikipedia.org/wiki/Mac_OS">Mac OS</a>）</li><li><a href="https://zh.wikipedia.org/wiki/Microsoft_Word">Microsoft Word</a></li><li><a href="https://zh.wikipedia.org/wiki/Apache_OpenOffice">Apache OpenOffice</a> &#x2F; <a href="https://zh.wikipedia.org/wiki/LibreOffice">LibreOffice</a></li><li><a href="https://zh.wikipedia.org/zh-cn/WPS_Office">WPS Office</a></li><li><a href="https://zh.wikipedia.org/wiki/EIOffice">EIOffice</a></li></ul></blockquote>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;文件后缀与文件&quot;&gt;&lt;a href=&quot;#文件后缀与文件&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="blog" scheme="https://www.oikiou.top/categories/blog/"/>
    
    
    <category term="DS_Store" scheme="https://www.oikiou.top/tags/DS-Store/"/>
    
    <category term="rtf" scheme="https://www.oikiou.top/tags/rtf/"/>
    
    <category term="后缀" scheme="https://www.oikiou.top/tags/%E5%90%8E%E7%BC%80/"/>
    
  </entry>
  
  <entry>
    <title>Zip Gzip Bzip2 Tar 的区别和差异</title>
    <link href="https://www.oikiou.top/2022/613d8edd/"/>
    <id>https://www.oikiou.top/2022/613d8edd/</id>
    <published>2022-09-14T16:20:15.000Z</published>
    <updated>2022-09-16T05:10:53.788Z</updated>
    
    <content type="html"><![CDATA[<h1 id="zip-gzip-bzip2-tar-的区别和差异"><a href="#zip-gzip-bzip2-tar-的区别和差异" class="headerlink" title="zip gzip bzip2 tar 的区别和差异"></a>zip gzip bzip2 tar 的区别和差异</h1><ul><li><strong>gzip 和 bzip2</strong>用于压缩单个文件。bzip2 比 gzip 具有更高的压缩率，同样的也会需要更多时间来进行压缩。</li><li><strong>zip 和 tar</strong>用于压缩和归档文件夹。</li></ul><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>zip</td><td><code>.zip</code></td><td>可以压缩目录</td><td>源文件会保留</td><td>专门的压缩命令</td></tr><tr><td>gzip</td><td><code>.gz</code></td><td>只能压缩文件</td><td>压缩后源文件会被删除</td><td></td></tr><tr><td>bzip2</td><td><code>.bz2</code></td><td>只能压缩文件</td><td>加<code>-k</code>参数源文件可以保留</td><td></td></tr><tr><td>tar</td><td><code>.tar</code></td><td>可以压缩目录</td><td>源文件会保留</td><td>linux包大多是这形态<br>将目录打包成一个文件<code>Tape archive</code></td></tr><tr><td>xz</td><td><code>.xz</code></td><td></td><td></td><td></td></tr></tbody></table><h2 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h2><h2 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h2><p>该<code>gzip</code>程序用于压缩一个或多个文件。执行时，它将原始文件替换为原始文件的压缩版本。使用 gzip 压缩的文件具有扩展名<code>.gz</code></p><h2 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h2><p>该<code>bzip2</code>命令类似于 gzip，但使用不同的压缩算法，以牺牲压缩速度为代价归档更高级别的压缩。使用 bzip2 压缩的文件具有扩展名<code>.bz2</code></p><h2 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h2><p><code>tar</code>命令，首字母缩略词<em><strong>Tape archive</strong></em>用于创建存档文件。tar 存档可以由单独的文件、一个或多个目录层次结构或两者的混合组成。tar 文件有扩展名<code>.tar</code></p><h2 id="xz"><a href="#xz" class="headerlink" title="xz"></a>xz</h2><p><code>xz</code>是一个通用的数据压缩工具，命令行语法类似于 gzip 和 bzip2 。它根据选择的操作模式压缩或解压缩每个文件。用 xz 压缩的文件具有扩展名<code>.xz</code></p><h1 id="Zip-和-Unzip"><a href="#Zip-和-Unzip" class="headerlink" title="Zip 和 Unzip"></a>Zip 和 Unzip</h1><h2 id="zip-1"><a href="#zip-1" class="headerlink" title="zip"></a>zip</h2><p><strong>命令格式</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">zip [-r] [压缩后文件名] [文件或目录]<br></code></pre></td></tr></table></figure><p><strong>命令描述</strong></p><ul><li><code>zip</code>命令用来对文件进行打包操作。zip是个使用广泛的压缩程序，文件经它压缩后会另外产生具有“.zip”扩展名的压缩文件；</li><li>在linux压缩后的文件，基本都可以在Windows系统中解压；Windows中压缩的文件，在Linux中不一定可用，但是zip格式的压缩文件，可以做到可用；</li><li>zip的压缩比不是很高；</li></ul><p><strong>示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 压缩文件</span><br>$ zip a.zip a.txt<br><span class="hljs-comment"># 查看压缩后的文件</span><br>$ <span class="hljs-built_in">ls</span><br>a.txt  a.zip  <br><br><span class="hljs-comment"># 2. -r：压缩文件夹</span><br>$ zip -r test.zip testDir/<br>$ <span class="hljs-built_in">ls</span><br>testDir  test.zip<br><br><span class="hljs-comment"># 3. -x 排除文件</span><br>$ zip -r test2.zip testDir/ -x <span class="hljs-string">&quot;testDir/hello*&quot;</span> -x <span class="hljs-string">&quot;testDir/dir/*&quot;</span><br></code></pre></td></tr></table></figure><h2 id="unzip-解压"><a href="#unzip-解压" class="headerlink" title="unzip 解压"></a>unzip 解压</h2><p><strong>命令格式</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">unzip [选项] 文件名<br></code></pre></td></tr></table></figure><p><strong>命令描述</strong></p><p><code>unzip</code>命令用于解压缩由zip命令压缩的“.zip”压缩包。</p><p><strong>选项</strong></p><ul><li>-n：解压缩时不要覆盖原有的文件；</li><li>-o：不必先询问用户，unzip执行后覆盖原有的文件；</li><li>-d &lt;目录&gt;：指定文件解压缩后所要存储的目录(不指定目录，默认解压到当前目录)</li></ul><p><strong>示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 解压文件到家目录</span><br>$ unzip test.zip -d ~<br></code></pre></td></tr></table></figure><h1 id="Gzip-和-Gunzip"><a href="#Gzip-和-Gunzip" class="headerlink" title="Gzip 和 Gunzip"></a>Gzip 和 Gunzip</h1><h2 id="gzip-1"><a href="#gzip-1" class="headerlink" title="gzip"></a><strong>gzip</strong></h2><p><strong>命令格式</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">gzip [文件]<br></code></pre></td></tr></table></figure><p><strong>命令描述</strong></p><p><code>gzip</code>命令 用来压缩文件。gzip是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多处“<code>.gz</code>”扩展名。<code>gzip</code>只能压缩文件，不能压缩文件夹，压缩后原文件会被删除</p><p><code>gzip</code>是在Linux系统中经常使用的一个对文件进行压缩和解压缩的命令，既方便又好用。gzip不仅可以用来压缩大的、较少使用的文件以节省磁盘空间，还可以和tar命令一起构成Linux操作系统中比较流行的压缩文件格式。据统计，gzip命令对文本文件有60%～70%的压缩率。减少文件大小有两个明显的好处，一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间。</p><p><strong>示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 压缩文件</span><br>$ gzip a.txt<br><span class="hljs-comment"># 查看压缩后的文件，源文件被删除</span><br>$ <span class="hljs-built_in">ls</span><br>a.txt.gz<br></code></pre></td></tr></table></figure><h2 id="gunzip-解压"><a href="#gunzip-解压" class="headerlink" title="gunzip 解压"></a>gunzip 解压</h2><p><strong>命令格式</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">gzip [文件]<br></code></pre></td></tr></table></figure><p><strong>命令描述</strong></p><p><code>gunzip</code>命令用来解压缩文件。gunzip是个使用广泛的解压缩程序，它用于解开被gzip压缩过的文件，这些压缩文件预设最后的扩展名为<code>.gz</code>。</p><p><strong>示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 解压文件，解压后压缩文件被删除</span><br>$ gunzip a.txt.gz<br>$ <span class="hljs-built_in">ls</span><br>a.txt <br></code></pre></td></tr></table></figure><h1 id="Bzip2"><a href="#Bzip2" class="headerlink" title="Bzip2"></a>Bzip2</h1><h2 id="bzip2-1"><a href="#bzip2-1" class="headerlink" title="bzip2"></a>bzip2</h2><p><strong>命令格式</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">bzip2 [选项] [文件]<br></code></pre></td></tr></table></figure><p><strong>命令描述</strong></p><ul><li>bzip2命令用于压缩“<code>.bz2</code>”格式的压缩包，是<code>gzip</code>的升级版本，可以保留原文件；</li><li>bzip2的压缩比比较高，可用于压缩较大文件的压缩；</li><li>bzip2也是只对文件进行压缩，如果相对目录进行压缩的话，可以配合 <code>tar</code>命令使用，使用 <code>tar -jcvf</code> 文件名 完成打包压缩。</li></ul><p><strong>选项</strong></p><p>-k（keep）：保留原文件（不删除原文件）</p><p><strong>示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># bzip2 压缩文件</span><br>$ bzip2 -k a.txt<br>$ <span class="hljs-built_in">ls</span><br>a.txt  a.txt.bz2<br><br><span class="hljs-comment"># 配合使用tar 命令，完成打包压缩</span><br>$ <span class="hljs-built_in">mkdir</span> music<br>$ tar -jcvf music.tar.bz2 music/<br>$ <span class="hljs-built_in">ls</span><br>music  music.tar.bz2<br></code></pre></td></tr></table></figure><h2 id="bunzip2-解压"><a href="#bunzip2-解压" class="headerlink" title="bunzip2 解压"></a>bunzip2 解压</h2><p><strong>命令格式</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">bunzip2 [选项] [文件]<br></code></pre></td></tr></table></figure><p><strong>命令描述</strong></p><ul><li>解压缩“<code>.bz2</code>”格式的压缩文件；</li><li>gunzip的升级版，可以使用<code>-k</code>保留原文件；</li><li>可以配合使用tar命令，完成解压缩解包： <code>tar -jxvf 文件名</code></li></ul><p><strong>选项</strong></p><p>-k（keep）：保留原文件（不删除原文件）</p><p><strong>示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">ls</span><br>a.txt.bz2  music.tar.bz2<br><br><span class="hljs-comment"># 解压缩文件</span><br>$ bunzip2 -k a.txt.bz2<br>$ <span class="hljs-built_in">ls</span><br>a.txt  a.txt.bz2  music.tar.bz2<br><br><span class="hljs-comment"># 使用tar完成解压解包</span><br>$ tar -jxvf music.tar.bz2<br>$ <span class="hljs-built_in">ls</span><br>a.txt  a.txt.bz2  music  music.tar.bz2<br></code></pre></td></tr></table></figure><h1 id="tar-和-tar"><a href="#tar-和-tar" class="headerlink" title="tar 和 tar"></a>tar 和 tar</h1><h2 id="tar-1"><a href="#tar-1" class="headerlink" title="tar"></a>tar</h2><p><strong>命令格式</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">tar [选项] [压缩后文件名] [目录]<br></code></pre></td></tr></table></figure><p><strong>命令描述</strong></p><p>打包目录，将目录打包成一个文件，同时可以压缩，压缩后的拓展名为<code>.tar.gz</code>，这个拓展名在下载Linux相关安装包时很常见。</p><p>使用<code>tar</code>命令时，如果想要打包并压缩一个目录，可以有两种方法进行：</p><ol><li>先利用tar命令打包目录为一个文件，然后使用gzip压缩</li><li>直接利用tar命令打包并压缩 (简单方便，推荐使用)</li></ol><p>解压时也有两种方式：</p><ol><li>先使用gunzip解压缩，再使用tar解包</li><li>直接利用tar命令解压缩并解包 (简单方便，推荐使用)</li></ol><p><strong>选项</strong></p><ul><li>-c：打包(将所有文件变成一个文件 Create  a new archive)</li><li>-x：解包</li><li>-v：显示详细信息</li><li>-f：指定文件名</li><li>-z：打包同时压缩&#x2F;解压缩  ，gzip压缩</li><li>-j：生成压缩文件 ，bzip2压缩</li></ul><p><strong>示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 压缩</span><br>tar -zcvf movie2.tar.gz movie<br><span class="hljs-comment"># 解压</span><br>tar -zxvf movie2.tar.gz<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1、2为    打包压缩    的两种方法</span><br><span class="hljs-comment"># 1. 使用 tar -cvf 打包，然后使用gzip压缩</span><br>$ tar -cvf movie.tar movie/<br>$ <span class="hljs-built_in">ls</span><br>movie  movie.tar<br>$ gzip movie.tar<br>$ <span class="hljs-built_in">ls</span><br>movie  movie.tar.gz<br><br><span class="hljs-comment"># 2. 使用 tar -zcvf 打包并压缩</span><br>$ tar -zcvf movie2.tar.gz movie<br>$ <span class="hljs-built_in">ls</span><br>movie  movie2.tar.gz<br><br><span class="hljs-comment"># 3、4为     解压缩并解包     的两种方法</span><br><span class="hljs-comment"># 3. 先使用gunzip解压缩，然后 tar -xvf解包</span><br>$ gunzip movie.tar.gz<br>$ <span class="hljs-built_in">ls</span><br>movie2.tar.gz  movie.tar<br>$ tar -xvf movie.tar<br>movie/<br>$ <span class="hljs-built_in">ls</span><br>movie  movie2.tar.gz  movie.tar<br><br><span class="hljs-comment"># 4. 使用tar -zxvf 解压缩并解包</span><br>$ tar -zxvf movie2.tar.gz<br>$ <span class="hljs-built_in">ls</span><br>movie  movie2.tar.gz  movie.tar<br></code></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://techviewleo.com/compress-uncompress-files-tar-gzip-bzip2-xz-linux/">LPIC 101 – Compress and Uncompress Files Using tar, gzip, bzip2 and xz on Linux</a></p><p><a href="https://en.wikipedia.org/wiki/List_of_archive_formats#Comparison">List of archive formats</a></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;zip-gzip-bzip2-tar-的区别和差异&quot;&gt;&lt;a href=&quot;#zip-gzip-bzip2-tar-的区别和差异&quot; class=&quot;headerlink&quot; title=&quot;zip gzip bzip2 tar</summary>
        
      
    
    
    
    <category term="blog" scheme="https://www.oikiou.top/categories/blog/"/>
    
    
    <category term="zip" scheme="https://www.oikiou.top/tags/zip/"/>
    
    <category term="gzip" scheme="https://www.oikiou.top/tags/gzip/"/>
    
    <category term="bzip" scheme="https://www.oikiou.top/tags/bzip/"/>
    
    <category term="tar" scheme="https://www.oikiou.top/tags/tar/"/>
    
  </entry>
  
  <entry>
    <title>MD5</title>
    <link href="https://www.oikiou.top/2022/45a589a3/"/>
    <id>https://www.oikiou.top/2022/45a589a3/</id>
    <published>2022-09-14T14:57:15.000Z</published>
    <updated>2022-09-16T05:13:19.812Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h1><p><strong>MD5消息摘要算法</strong>（英语：MD5 Message-Digest Algorithm），一种被广泛使用的<a href="https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A2%BC%E9%9B%9C%E6%B9%8A%E5%87%BD%E6%95%B8">密码散列函数</a>，可以产生出一个128位（16个字符(BYTES)）的散列值（hash value），用于确保信息传输完整一致。将<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE">数据</a>（如一段文字）运算变为另一固定长度值，是散列算法的基础原理。</p><p><strong>参考</strong></p><p><a href="https://zhuanlan.zhihu.com/p/121492822">MD5破解的几种方法</a></p><p><a href="https://en.wikipedia.org/wiki/MD5">Wiki MD5</a></p><h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><ul><li><p>不可逆向的</p><blockquote><p>  我们没办法把MD5码还原对应的原文。道理很简单，任意长度的数据经过MD5处理后，所包含的信息量已经大大减少，那是不可能再次还原成为原始信息的。</p></blockquote></li><li><p>原文中作一个小变化其散列也会发生巨大的变化</p><blockquote>  <figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-symbol">MD5</span>(<span class="hljs-string">&quot;The quick brown fox jumps over the lazy dog&quot;</span>)<br>= <span class="hljs-number">9</span>e107d9d372bb6826bd81d3542a419d6<br></code></pre></td></tr></table></figure><p>  比如用c取代d, 其MD5值发生了巨大的变化</p>  <figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-symbol">MD5</span>(<span class="hljs-string">&quot;The quick brown fox jumps over the lazy cog&quot;</span>)<br>= <span class="hljs-number">1055</span>d3e698d289f2af8663725127bd4b<br></code></pre></td></tr></table></figure></blockquote></li><li><p>已被破解</p><blockquote><p>  通俗点讲就是，可以找到一个A和一个B，使hash（A）&#x3D;hash（B），而真正有用的是给定一个A能得到B，使hash（A）&#x3D;hash（B），而王小云能做到这样</p></blockquote></li></ul><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>MD5 摘要已在<a href="https://en.wikipedia.org/wiki/Software">软件</a>世界中广泛使用，以确保传输的文件已完好无损地到达。例如，文件服务器通常会为文件提供预先计算的 MD5（称为<a href="https://en.wikipedia.org/wiki/Md5sum">md5sum</a>）<a href="https://en.wikipedia.org/wiki/Checksum">校验和</a>，以便用户可以将下载文件的校验和与其进行比较。</p><p><img src="/2022/45a589a3/350px-CPT-Hashing-File-Transmission.png" alt="350px-CPT-Hashing-File-Transmission.svg"></p><p>由于很容易产生 MD5 冲突，因此创建文件的人可能会创建具有相同校验和的第二个文件，因此该技术无法防止某些形式的恶意篡改。</p><p>在某些情况下，校验和是不可信的（例如，如果它是通过与下载文件相同的渠道获得的，他人可能修改了文件后再次修改了MD5，使得MD5并不可信），在这种情况下，MD5 只能提供错误检查功能：“它会识别损坏或不完整的下载，这变成下载较大文件时更有可能。”</p><h1 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h1><h2 id="穷举法-amp-字典法"><a href="#穷举法-amp-字典法" class="headerlink" title="穷举法&amp;字典法"></a>穷举法&amp;字典法</h2><p><strong>穷举法非常简单，就是不停地尝试各种字符的排列组合，看哪一个组合的MD5码能对上。</strong>可惜缺点是太耗费时间了。我们举个栗子，假设我们要破解一个6位大小写字母和数字混合的密码，那么一共有(26+26+10)<sup>6</sup> 种组合。这个数的大小超过500亿。</p><p>既然计算如此费时，能不能考虑<strong>把计算结果以映射表的形式存放起来，一个萝卜一个坑</strong>，一个原文对应着一个MD5码呢？可以呀！这就是传说中的“字典法”。将已知的MD5码查表，直接反查出原文。<strong>字典法体现了算法设计的“以空间换时间”的思想。</strong>缺点是比较耗费空间。不过现在硬盘的价格变得白菜价了，空间开销不算什么。</p><p><a href="https://www.cmd5.com/password.aspx">CMD5 反查网站</a></p><p><a href="https://www.somd5.com/">SMD5 反查网站</a></p><h2 id="哈希链表-amp-彩虹表法"><a href="#哈希链表-amp-彩虹表法" class="headerlink" title="哈希链表&amp;彩虹表法"></a>哈希链表&amp;彩虹表法</h2><blockquote><p>  如果说穷举法太耗费时间，字典法太耗费存储空间的话，我们能不能考虑在时间消耗和空间消耗之间折中呢？我们可以考虑用链表将一系列有意义的原文和MD5码串起来。</p><p>  要构造这样的链表，我们需要两个函数：哈希函数H(x)和衰减函数（reduction function）R(x)。哈希函数可以是MD5，也可以是其他的消息摘要算法。H(x)的值域是R(x)的定义域，R(x)的值域是H(x)的定义域。<strong>R(x)不是H(x)的反函数。</strong></p><p>  将一个原文不停地使用H(x)和R(x)交替进行运算k次，再将原文本身和运算结果以链表的形式串接起来，就可以得到结点个数为2k+1的链表。实际存放的时候只存放首端和末端两个原文即可。<strong>这种链表叫做“哈希链表”，体现了算法设计的“时空权衡”（Space and Time Tradeoffs）。</strong></p><p>  举个栗子，假设原文s&#x3D;abcabc，经过2次交替运算，得到以下的链表：</p><p>  abcabc-&gt;H(x)-&gt;3C8B0D7A-&gt;R(x)-&gt;eopmca-&gt;H(x)-&gt;7E9F216C-&gt;R(x)-&gt;rapper</p><p>  以上数据均为举例编造的，仅为说明原理使用。那我们存放这个链表的时候，只需要记录abcabc和rapper两个原文即可。</p><p>  假设我们要破解的摘要值（哈希链表的H(x)不一定是MD5算法，这里用更准确的说法代替MD5码）是7E9F216C，经过R(x)运算得到rapper，说明我们要寻找的原文就在以rapper为末端的哈希链表中。从首端开始经过多次运算，我们发现eopmca的摘要值就是7E9F216C。于是就反查出7E9F216C对应的原文是eopmca。</p><p>  <strong>如果在生成哈希链表的时候依次使用多个不一样的R(x)，此时的哈希链表就是“彩虹表”。</strong></p><p>  这里有已经计算好的彩虹表：<a href="https://link.zhihu.com/?target=http://project-rainbowcrack.com/table.htm">http://project-rainbowcrack.com</a></p></blockquote><h2 id="差分攻击"><a href="#差分攻击" class="headerlink" title="差分攻击"></a>差分攻击</h2><p>上面介绍的穷举法、字典法和彩虹表法都是暴力破解，适用于任何的消息摘要算法。</p><p>真正意义上MD5算法的破解，是2004年山东大学王小云教授提出的MD5碰撞方法。她所用到的方法正是差分攻击。</p><p><a href="https://www.sohu.com/a/501560600_121106869">她是这样的“中国密码女神”！</a> </p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;MD5&quot;&gt;&lt;a href=&quot;#MD5&quot; class=&quot;headerlink&quot; title=&quot;MD5&quot;&gt;&lt;/a&gt;MD5&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;MD5消息摘要算法&lt;/strong&gt;（英语：MD5</summary>
        
      
    
    
    
    <category term="blog" scheme="https://www.oikiou.top/categories/blog/"/>
    
    
    <category term="md5" scheme="https://www.oikiou.top/tags/md5/"/>
    
  </entry>
  
  <entry>
    <title>SpaceDesk手机用作电脑屏幕</title>
    <link href="https://www.oikiou.top/2022/471570a6/"/>
    <id>https://www.oikiou.top/2022/471570a6/</id>
    <published>2022-08-29T14:57:15.000Z</published>
    <updated>2022-09-18T14:38:51.312Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpaceDesk"><a href="#SpaceDesk" class="headerlink" title="SpaceDesk"></a>SpaceDesk</h1><p>在windows主机上虚拟出一块屏幕, 通过网络传输到其他带屏设备上.</p><ul><li>投屏到手机支持触摸</li></ul><h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p><a href="https://www.spacedesk.net/">https://www.spacedesk.net/</a></p><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><h2 id="软件没有验证功能-不安全"><a href="#软件没有验证功能-不安全" class="headerlink" title="软件没有验证功能(不安全)"></a>软件没有验证功能(不安全)</h2><p>有一次在公司用手机客户端, 直接连接上了公司其他同事的电脑屏幕.</p><p>公司的网络ip是dhcp的无法固定, 而且网络质量并不好, 所以我选择电脑开热点 手机连电脑热点.</p><p>防火墙加规则,只允许热点网段的IP入站.</p><p><img src="/2022/471570a6/image-20220811195054454.png" alt="image-20220811195054454"></p><p><img src="/2022/471570a6/image-20220811194925793.png" alt="image-20220811194925793"></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;SpaceDesk&quot;&gt;&lt;a href=&quot;#SpaceDesk&quot; class=&quot;headerlink&quot; title=&quot;SpaceDesk&quot;&gt;&lt;/a&gt;SpaceDesk&lt;/h1&gt;&lt;p&gt;在windows主机上虚拟出一块屏幕,</summary>
        
      
    
    
    
    <category term="tools" scheme="https://www.oikiou.top/categories/tools/"/>
    
    
    <category term="windows" scheme="https://www.oikiou.top/tags/windows/"/>
    
    <category term="spacedesk" scheme="https://www.oikiou.top/tags/spacedesk/"/>
    
    <category term="投屏" scheme="https://www.oikiou.top/tags/%E6%8A%95%E5%B1%8F/"/>
    
  </entry>
  
  <entry>
    <title>使用Jlink 烧写SPI Flash存储芯片</title>
    <link href="https://www.oikiou.top/2022/fd90dc4c/"/>
    <id>https://www.oikiou.top/2022/fd90dc4c/</id>
    <published>2022-08-26T15:23:05.000Z</published>
    <updated>2022-09-18T14:38:51.352Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用Jlink-烧写SPI-Flash存储芯片"><a href="#使用Jlink-烧写SPI-Flash存储芯片" class="headerlink" title="使用Jlink 烧写SPI Flash存储芯片"></a>使用Jlink 烧写SPI Flash存储芯片</h1><p>参考:</p><p><a href="https://www.segger.com/products/debug-probes/j-link/tools/j-flash-spi/">https://www.segger.com/products/debug-probes/j-link/tools/j-flash-spi/</a></p><h1 id="硬件连接"><a href="#硬件连接" class="headerlink" title="硬件连接"></a>硬件连接</h1><h2 id="SPI-amp-Single"><a href="#SPI-amp-Single" class="headerlink" title="SPI &amp; Single"></a>SPI &amp; Single</h2><p><img src="/2022/fd90dc4c/formatpng.png" alt="img"></p><p><img src="/2022/fd90dc4c/pinout-spi-20-pin.gif" alt="引出线 spi 20 针"></p><h2 id="QSPI-amp-Quad"><a href="#QSPI-amp-Quad" class="headerlink" title="QSPI &amp; Quad"></a>QSPI &amp; Quad</h2><p><img src="/2022/fd90dc4c/pinout-qspi-20-pin.png" alt="img"></p><blockquote><p>  注意:</p><p>  这里要注意的一点，正版的Jlink仿真器1脚是输入引脚，是外部提供参考电平的，但由于现在大部分的JLink仿真器都是学习(dao)版的，1脚不是输入，而是3.3v的输出(并不确定也有可能是5V的, 盗版的Jlink真的是什么乱七八糟的都有)，所以正常情况下可以直接用这个管教来给SPI Flash供电。</p><p>  <strong>关于 nRESET 的注意事项</strong>：如果有另一个设备&#x2F;外围设备也控制 SPI 闪存（例如闪存连接到的 CPU），则 J-Link 的 nRESET 应连接到目标系统的复位或 CPU 的复位引脚确保 J-Link 可以在对 SPI 闪存进行编程时保持 CPU 处于复位状态。</p><p>  <strong>一开始没注意到这个功能, 现在回过头来再看, 有这个功能之后烧芯片简直不要太简单, 根本不需要拆芯片了, 直接用芯片夹就可以烧录了.</strong></p></blockquote><h1 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h1><p>安装Jlink套件的时候会自带<code>JFlashSPI.exe</code>在开始菜单名称应该类似<code>J-Flash SPI</code>, 这是J-Flash的GUI程序,还有一个命令行的不多做介绍.</p><blockquote><p>  如果没有找到自带的, 请更新Jlink套件, 旧版确实不带这个东西.</p><p>  Segger Jlink套件下载链接 <a href="https://www.segger.com/downloads/jlink/">https://www.segger.com/downloads/jlink/</a></p></blockquote><p><img src="/2022/fd90dc4c/image-20220826224742256.png" alt="image-20220826224742256"></p><p>点击<code>target -&gt; connet</code>连接到Jlink, 它会自动检测大部分SPI闪存, </p><blockquote><p>  有时候识别的具体型号并不准确, 但是这不重要他们参数类似, 可以正常完成编程的工作.</p><p>  Jlink支持的SPI Flash型号可以在<a href="https://www.segger.com/products/debug-probes/j-link/technology/cpus-and-devices/supported-spi-flashes/">点击这里</a>找到.</p></blockquote><p>点击<code>file -&gt; open data file </code>我们打开要烧录的文件.</p><blockquote><p>  bin 文件需要设定起始地址</p><p>  hex文件自带了位置信息</p></blockquote><p>点击<code>target -&gt; auto</code>可以自动将文件烧录进去 还会进行读回校验.</p><p>至此烧录完成.</p><p><strong>Tips:</strong></p><blockquote><p>  点击<code>target -&gt; read back</code> 可以将SPI Flash内的数据读取出来<br>  点击<code>options -&gt; settings -&gt; setup -&gt; interface speed</code>可以修改时钟速度. </p></blockquote><p><strong>Other:</strong></p><p>Jlink真的是超级牛的工具, J-Scope, RTT这些都很好用, 还有很多高级功能我还没用上.<br>我前面有写过RTT的笔记, 在调试一个项目的时候没法使用串口, 当时就是用RTT搭建了一个log平台.</p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="winbood-W25Q128封装"><a href="#winbood-W25Q128封装" class="headerlink" title="winbood W25Q128封装"></a>winbood W25Q128封装</h2><p><img src="/2022/fd90dc4c/image-20220826104542006.png" alt="image-20220826104542006"></p><p><img src="/2022/fd90dc4c/20210622091839750557.png" alt="img"></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;使用Jlink-烧写SPI-Flash存储芯片&quot;&gt;&lt;a href=&quot;#使用Jlink-烧写SPI-Flash存储芯片&quot; class=&quot;headerlink&quot; title=&quot;使用Jlink 烧写SPI</summary>
        
      
    
    
    
    <category term="tools" scheme="https://www.oikiou.top/categories/tools/"/>
    
    
    <category term="spi" scheme="https://www.oikiou.top/tags/spi/"/>
    
    <category term="j-link" scheme="https://www.oikiou.top/tags/j-link/"/>
    
    <category term="jlink" scheme="https://www.oikiou.top/tags/jlink/"/>
    
    <category term="flash" scheme="https://www.oikiou.top/tags/flash/"/>
    
    <category term="j-tag" scheme="https://www.oikiou.top/tags/j-tag/"/>
    
  </entry>
  
  <entry>
    <title>Tags Label Category</title>
    <link href="https://www.oikiou.top/2022/c65e1067/"/>
    <id>https://www.oikiou.top/2022/c65e1067/</id>
    <published>2022-08-25T14:57:15.000Z</published>
    <updated>2022-09-18T14:38:51.280Z</updated>
    
    <content type="html"><![CDATA[<p>知乎  <a href="https://www.zhihu.com/people/songvision">千鸟</a></p><blockquote><p>  这问题要分两个层面来解读：</p><p>  <strong>首先是Tag与Category的区别。</strong>Category往往限制在一个维度里，当树状结构复杂到不可调和时，出现瓶颈是迟早的事。Category的问题在于，既不能完全满足用户需求，也不能完全表达创建者对内容属性的认知。而Tag反之都成立，完全互补。</p><p>  <strong>其次是Label与Tag的区别。</strong>于对内容的概括出现偏差，但显然这种问题不是tag，在内容组织范畴那应该是什么？答案就是label，除产品描述，其应用范畴还涉及功能名称、模块名称、导航名称、引导文字等等场景。我认为tag与label之间有三个显著差异：</p><ol><li>label是本身的，tag是附加的；</li><li>label强调是一种标志，tag强调是一种记号；</li><li>label标明信息之间的归属，tag区别信息之间的差异。</li></ol></blockquote><p>知乎 郑讯</p><blockquote><p>  Tag，标签，一般包含一段内容的属性，可以是分类，可以是话题，也可以是作者，地理信息等。</p><p>  Label，标记，是网页框架中一个区域的功能概括。比如知乎首页上的“浏览”、“问题”、“通知”就是label。选择不同的标记，相应区域的功能就会发生变化。</p><p>  category，分类，可以理解为种属概念。一段内容有且只有一个种属的分类。和Tag不同的是一段内容可以有多个tag，并且tag是未预先设定的，一段内容可以有多个Tag，也可以没有Tag。但caterory在一个分类标准下只有一个。</p></blockquote><p>知乎 李楠</p><blockquote><p>  <strong>Category</strong></p><p>  Category 是非常理想化和一根筋的分类方式。图书馆这种死板到头的地方用的多。但是他们也遇到了问题：“苏菲的世界”到底是“哲学”，还是“文学”？</p><p>  物理世界无力从根本上解决这种问题（但似乎不少讨论）。问过我们学校的图书馆，似乎他们方式还比较靠谱：<strong>买两本，两处放。</strong></p><p>  分类对象数字化之后， Category 的影响还在（早期的门户找点跨界的东西就很悲剧）。直到 Web2.0 ， Tag 竟然才开始流行。</p><p>  <strong>Tag</strong></p><p>  Tag 是更好的分类方式的原因是：</p><p>  1</p><p>  “类别”本来就不应该事先定义：人不是上帝。</p><p>  从一个个具体对象的“属性”中，总结出“类别”是最自然的模式。也是“人”可以做到的事情。</p><p>  2</p><p>  “属性”本来就应该可以自然的表现为多个。</p><p>  苏菲的世界终于可以自然的打上“哲学”和“文学”的 Tag 了，或者再加个“少儿读物”。这种思考方式比 Category 优雅太多。</p><p>  Tag 最终普及，背后恐怕有<a href="https://www.zhihu.com/search?q=%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:12226710%7D">软件工程</a>上 OO 普及（面向对象）的因素。<strong>“面向对象”不仅仅是的程序构建方式，更是认识世界的方法论的进步。</strong></p><p>  “属性”跟随“对象”，比“对象”属于“类别”更自然，不机械。 。</p><p>  <strong>Tag 的改进</strong></p><p>  Tag 本身也可以看作“对象”。</p><p>  那么就有针对 Tag 的操作，比如“搜索”，“排序”，“关联对象”。也有 Tag 本身的属性，比如“使用次数”，“关注人数”等等。</p><p>  如何能在使用 Tag 的系统中，根据这些数据，计算出最适合的对象，就要靠算法的优化和运营的调整了。</p></blockquote><p>知乎 <a href="https://www.zhihu.com/people/zheng-wei-42-9">榆木脑袋</a></p><blockquote><p>  Catagory是逻辑清晰的。Tag是随意自由的。在看到一个信息的时候我们需要自由捕获自己头脑中的闪光。在重新审视或再利用我们收集的信息时，就需要清晰的逻辑条理。</p><p>  以文件管理为例：</p><p>  在标记Tag时需求有二：一是能够方便增加新的Tag，二是能够很方便的看到已有的Tag，并能同时把已有标签赋予当前信息。</p><p>  在查找文件时个人觉得需要有的功能是：一是有固定的几个入口，也就是根目录；二是可以增加根节点；三是根目录可以指定某几个Tag，也可以不是；三如果根目录不是Tag，需要定义关联到此根目录（分类）下的Tag；四（重点功能）根目录下不直接列出信息或文件（时间长了，某一Tag下文件会相当多），而是列出关联Tag的所有文件的其它Tag，显示为子目录，并标识出此子目录中的文件数量。五（作为管理功能）此时可以定义哪些Tag不在此根目录下出现。六设置某个Tag或某类Tag(文件数量大过一个数量)下仍不列出文件而是继续列出Tag；七子目录（Tag）下，上级目录Tag不再出现。</p><p>  我个人非常偏好使用树形目录结构，但苦恼于文件的多重分类和文件进行多重分类时的繁琐。经过多方搜索只找到三个比较符合的软件，一个是PinKM，一个是蓝码动力图片管理软件，一个是国外的Tabbles。但都因标签管理和整理的繁琐而放弃。</p></blockquote><p><strong>个人理解</strong></p><ul><li>Catagory 是属于严格的分类方法, 一个东西应当只属于一个Catagory内, 而且它是有层级关系的</li><li>Tags 是可有可无的, 一个东西可以有很多的Tags, 它是无层级关系的,</li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;知乎  &lt;a href=&quot;https://www.zhihu.com/people/songvision&quot;&gt;千鸟&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;  这问题要分两个层面来解读：&lt;/p&gt;
&lt;p&gt; </summary>
        
      
    
    
    
    <category term="blog" scheme="https://www.oikiou.top/categories/blog/"/>
    
    
    <category term="tags" scheme="https://www.oikiou.top/tags/tags/"/>
    
    <category term="label" scheme="https://www.oikiou.top/tags/label/"/>
    
    <category term="category" scheme="https://www.oikiou.top/tags/category/"/>
    
  </entry>
  
  <entry>
    <title>静态网页 静态博客</title>
    <link href="https://www.oikiou.top/2022/f96c3c41/"/>
    <id>https://www.oikiou.top/2022/f96c3c41/</id>
    <published>2022-08-21T14:57:15.000Z</published>
    <updated>2022-09-22T14:43:37.044Z</updated>
    
    <content type="html"><![CDATA[<h1 id="静态网页"><a href="#静态网页" class="headerlink" title="静态网页"></a>静态网页</h1><h1 id="静态网页生成器"><a href="#静态网页生成器" class="headerlink" title="静态网页生成器"></a>静态网页生成器</h1><p><a href="https://jekyllrb.com/">Jekyll</a>（由 Github 构建的用于为其 Github 页面提供支持的 Ruby 生成器）、</p><p><a href="https://gohugo.io/">Hugo</a>（构建在 Go 编程之上的极快静态生成器）语言）和</p><p><a href="https://hexo.io/">Hexo</a>（基于 Node.js 的快速网站生成器）。</p><p><strong>参考</strong></p><p><a href="https://www.techiediaries.com/jekyll-hugo-hexo/">How to Choose the Right Static Generator: Jekyll vs. Hugo vs. Hexo</a></p><p><a href="https://stackshare.io/stackups/hexo-vs-hugo-vs-jekyll">StackShare</a></p><h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><p>TBD</p><h2 id="Jekyll"><a href="#Jekyll" class="headerlink" title="Jekyll"></a>Jekyll</h2><p>TBD</p><h2 id="Hugo"><a href="#Hugo" class="headerlink" title="Hugo"></a>Hugo</h2><p>TBD</p><h1 id="Hexo-1"><a href="#Hexo-1" class="headerlink" title="Hexo"></a>Hexo</h1><h2 id="Hexo-部署"><a href="#Hexo-部署" class="headerlink" title="Hexo 部署"></a>Hexo 部署</h2><p><a href="https://hexo.io/zh-cn/docs/">HEXO文档_参考链接</a></p><p><strong>要求:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">Node.js (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)<br>Git<br></code></pre></td></tr></table></figure><p><strong>部署:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-cli -g<br>hexo init blog<br><span class="hljs-built_in">cd</span> blog<br>npm install<br>hexo server<br></code></pre></td></tr></table></figure><h2 id="Hexo-CMD"><a href="#Hexo-CMD" class="headerlink" title="Hexo CMD"></a>Hexo CMD</h2><h3 id="Init-初始化"><a href="#Init-初始化" class="headerlink" title="Init 初始化"></a>Init 初始化</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init [folder]<br></code></pre></td></tr></table></figure><p>新建一个网站。如果没有设置 <code>folder</code> ，Hexo 默认在目前的文件夹建立网站。</p><h3 id="new-新建"><a href="#new-新建" class="headerlink" title="new 新建"></a>new 新建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new [layout] &lt;title&gt;<br>hexo new <span class="hljs-string">&quot;post title with whitespace&quot;</span><br>hexo new page --path about/me <span class="hljs-string">&quot;About me&quot;</span><br>hexo new page -p     about/me <span class="hljs-string">&quot;About me&quot;</span><br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>, <code>--path</code></td><td align="left">自定义新文章的路径</td></tr><tr><td align="left"><code>-r</code>, <code>--replace</code></td><td align="left">如果存在同名文章，将其替换</td></tr><tr><td align="left"><code>-s</code>, <code>--slug</code></td><td align="left">文章的 Slug，作为新文章的文件名和发布后的 URL</td></tr></tbody></table><h3 id="generate-生成"><a href="#generate-生成" class="headerlink" title="generate 生成"></a>generate 生成</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 生成静态文件。</span><br>hexo generate<br><span class="hljs-comment"># 该命令可以简写为</span><br>hexo g<br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">选项</th><th></th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">-d</td><td>–deploy</td><td align="left"><strong>文件生成后立即部署网站</strong></td></tr><tr><td align="left">-w</td><td>–watch</td><td align="left"><strong>监视文件变动</strong></td></tr><tr><td align="left">-b</td><td>–bail</td><td align="left">生成过程中如果发生任何未处理的异常则抛出异常</td></tr><tr><td align="left">-f</td><td>–force</td><td align="left">强制重新生成文件 Hexo 引入了差分机制，<br>如果 <code>public</code> 目录存在，那么 <code>hexo g</code> 只会重新生成改动的文件。<br/>使用该参数的效果接近 <code>hexo clean &amp;&amp; hexo generate</code></td></tr><tr><td align="left">-c</td><td>–concurrency</td><td align="left">最大同时生成文件的数量，默认无限制</td></tr></tbody></table><h3 id="publish-草稿"><a href="#publish-草稿" class="headerlink" title="publish 草稿"></a>publish 草稿</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">hexo publish [layout] <span class="hljs-tag">&lt;<span class="hljs-name">filename</span>&gt;</span><br></code></pre></td></tr></table></figure><p>发表草稿。</p><h3 id="server-服务器"><a href="#server-服务器" class="headerlink" title="server 服务器"></a>server 服务器</h3><p>在服务器启动期间，Hexo 会监视文件变动并自动更新，您无须重启服务器。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta">hexo <span class="hljs-keyword">server</span><br>hexo s<br></code></pre></td></tr></table></figure><p>启动服务器。默认情况下，访问网址为： <code>http://localhost:4000/</code>。</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>, <code>--port</code></td><td align="left">重设端口</td></tr><tr><td align="left"><code>-s</code>, <code>--static</code></td><td align="left">只使用静态文件(不会更新)</td></tr><tr><td align="left"><code>-l</code>, <code>--log</code></td><td align="left">启动日记记录，使用覆盖记录格式</td></tr><tr><td align="left"><code>-i</code></td><td align="left"><code>hexo server -i 192.168.1.1</code> 指定监听的IP</td></tr></tbody></table><h3 id="deploy-部署"><a href="#deploy-部署" class="headerlink" title="deploy 部署"></a>deploy 部署</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment"># 部署网站。</span><br>hexo <span class="hljs-keyword">deploy</span><br><span class="hljs-comment"># 该命令可以简写为：</span><br>hexo d<br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-g</code>, <code>--generate</code></td><td align="left">部署之前预先生成静态文件</td></tr></tbody></table><h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prolog">hexo render &lt;file1&gt; [file2] ...<br></code></pre></td></tr></table></figure><p>渲染文件。</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-o</code>, <code>--output</code></td><td align="left">设置输出路径</td></tr></tbody></table><h3 id="migrate"><a href="#migrate" class="headerlink" title="migrate"></a>migrate</h3><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">hexo</span> migrate &lt;<span class="hljs-keyword">type</span>&gt;<br></code></pre></td></tr></table></figure><p>从其他博客系统 <a href="https://hexo.io/zh-cn/docs/migration">迁移内容</a>。</p><h3 id="clean-清理"><a href="#clean-清理" class="headerlink" title="clean 清理"></a>clean 清理</h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>hexo clean<br></code></pre></td></tr></table></figure><p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p><p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>hexo list &lt;<span class="hljs-keyword">type</span>&gt;<br></code></pre></td></tr></table></figure><p>列出网站资料。</p><h2 id="Hexo-Config-yml"><a href="#Hexo-Config-yml" class="headerlink" title="Hexo _Config.yml"></a>Hexo _Config.yml</h2><blockquote><h3 id="Home-page-setting"><a href="#Home-page-setting" class="headerlink" title="Home page setting"></a>Home page setting</h3><p>  <code>index_generator.order_by</code>  文章的顺序</p><ul><li><code>-date</code> 默认情况下按日期降序排序(从新到旧)。</li><li><code>-update</code> 按更新时间排序(<code>-</code> &#x3D; 从新到旧)。</li></ul></blockquote><h1 id="Hexo-Theme"><a href="#Hexo-Theme" class="headerlink" title="Hexo Theme"></a>Hexo Theme</h1><p>我是直接在github搜索 <code>hexo theme</code>看到了几个 star 比较多而且比较活跃的 repository </p><ul><li><p><strong><a href="https://github.com/ppoffice/hexo-theme-icarus">icarus</a></strong> 5.5K star</p><p><img src="/2022/f96c3c41/68747470733a2f2f70706f66666963652e6769746875622e696f2f6865786f2d7468656d652d6963617275732f67616c6c6572792f707265766965772e706e673f31.png" alt="img"></p></li><li><p><strong><a href="https://github.com/fluid-dev/hexo-theme-fluid">fluid</a></strong> 4.8K star</p><p><img src="/2022/f96c3c41/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666c7569642d6465762f737461746963406d61737465722f6865786f2d7468656d652d666c7569642f73637265656e73686f74732f696e6465782e706e67.png" alt="ScreenShot"></p></li><li><p><a href="https://github.com/blinkfox/hexo-theme-matery">matery</a>(blinkfox) 4.5K star</p><p><img src="/2022/f96c3c41/687474703a2f2f7374617469632e626c696e6b666f782e636f6d2f6d61746572792d32303138313230322d312e706e67.png" alt="首页"></p><p><img src="/2022/f96c3c41/687474703a2f2f7374617469632e626c696e6b666f782e636f6d2f6d61746572792d32303138313230322d332e706e67.png" alt="首页文章列表"></p></li><li><p><strong><a href="https://github.com/jerryc127/hexo-theme-butterfly">butterfly</a></strong> 4.3K star</p><p><img src="/2022/f96c3c41/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f6a65727279633132372f43444e406d322f696d672f7468656d652d627574746572666c792d726561646d652e706e67.png" alt="img"></p></li><li><p><a href="https://github.com/volantis-x/hexo-theme-volantis">volantis</a> 1.5k star</p><p><img src="/2022/f96c3c41/68747470733a2f2f692e6c6f6c692e6e65742f323032302f30332f31382f663550516c576973766d397a62674b2e6a7067.jpeg" alt="img"></p><p><img src="/2022/f96c3c41/68747470733a2f2f692e6c6f6c692e6e65742f323032302f30332f31382f585742476639354532743162646e6c2e6a7067.jpeg" alt="img"></p></li></ul><p>其中 <code>fluid</code> 和 <code>volantis</code> 最对我胃口, 最后选择的 <code>fluid</code>, 后期可能会改成<code>volantis</code>或者<code>icarus</code>试试看, 主要是喜欢简洁些, 又能有一定的观赏性的.</p><h2 id="Fluid"><a href="#Fluid" class="headerlink" title="Fluid"></a>Fluid</h2><p>参考文档</p><p><a href="https://hexo.fluid-dev.com/docs/guide/">https://hexo.fluid-dev.com/docs/guide/</a></p><p>theme 的 Github</p><p><a href="https://github.com/fluid-dev/hexo-theme-fluid">https://github.com/fluid-dev/hexo-theme-fluid</a></p><h3 id="自带的内置图标库"><a href="#自带的内置图标库" class="headerlink" title="自带的内置图标库"></a>自带的内置图标库</h3><p><a href="https://hexo.fluid-dev.com/docs/icon/#%E5%86%85%E7%BD%AE%E7%A4%BE%E4%BA%A4%E5%9B%BE%E6%A0%87">内置社交图标</a> </p><p><img src="/2022/f96c3c41/iconfont.f8319467.png" alt="内置图标"></p><h1 id="Hexo-Note"><a href="#Hexo-Note" class="headerlink" title="Hexo Note"></a>Hexo Note</h1><h2 id="Hexo-Permalink简化"><a href="#Hexo-Permalink简化" class="headerlink" title="Hexo Permalink简化"></a>Hexo Permalink简化</h2><p>参考:</p><p><a href="https://blog.csdn.net/Galahadzhou/article/details/105355733">Hexo Permalink简化</a></p><p>Note:</p><p>使用<code>hexo-abbrlink</code>插件实现</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># install</span><br>npm install hexo-abbrlink --save<br><span class="hljs-comment"># setting edit _config.yml</span><br>permalink: posts/:abbrlink.html<br>abbrlink:<br>  alg: crc32  <span class="hljs-comment"># 算法：crc16(default) and crc32</span><br>  rep: hex    <span class="hljs-comment"># 进制：dec(default) and hex</span><br><br></code></pre></td></tr></table></figure><h2 id="hexo-图片链接问题"><a href="#hexo-图片链接问题" class="headerlink" title="hexo 图片链接问题"></a>hexo 图片链接问题</h2><p><strong><code>hexo</code>本地图片显示问题</strong></p><p>使用<code>hexo</code>生成静态资源后,由于<code>url</code>的问题会出现图片加载的问题,现在网上的文章及官方的解决方案大概分为三种:</p><ol><li>将图片放入<code>source/images</code>目录下,每次<code>generate</code>都会生成图片,在使用相对或绝对路径进行引用</li><li>配置<code>hexo</code>的<code>_config.yml</code>文件, 将 <code>post_asset_folder</code> 设置为<code>true</code>, 这样每次new 生成一个文章时都会同步生成一个同名的文件夹,然后设置相对或绝对路径. </li><li>使用<code>hexo</code>官方的解决方案,使用模版变量, <code>&#123;% asset_img slug [title] %&#125; </code> </li><li>!new!. <code>hexo init</code>的时候会自动copy一个插件 <code>hexo-renderer-marked</code> 这个插件可以开启相对路径的支持,但是需要改一些代码</li></ol><p>但是在配置过程中发现这三种方式都多多少少存在一些问题,前两中首页跟内容页会有一个加载失败的问题,而第三种则失去了<code>markdown</code>的意义.</p><p><strong>方法四:</strong></p><p>官方手册上提到过, <a href="https://github.com/hexojs/hexo-renderer-marked">hexo-renderer-marked</a> 3.1.0已经开始支持相对路径了.但是可以看到它支持的路径似乎并不合理, 其他的md阅读器是不能识别这样的路径的.</p><p><img src="/2022/f96c3c41/image-20220815153651988.png" alt="image-20220815153651988"></p><p>参考: <a href="https://github.com/hexojs/hexo-renderer-marked/issues/216">https://github.com/hexojs/hexo-renderer-marked/issues/216</a></p><ol><li><p>修改<code>_config.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">marked:</span><br>  <span class="hljs-attr">prependRoot:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">postAsset:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li><li><p>修改文件<code>node_modules\hexo-renderer-marked\lib\renderer.js</code></p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (!<span class="hljs-regexp">/^(#|\/\/|http(s)?:)/</span>.<span class="hljs-title function_">test</span>(href) &amp;&amp; !relative_link &amp;&amp; prependRoot) &#123;<br>  <span class="hljs-keyword">if</span> (!href.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;/&#x27;</span>) &amp;&amp; !href.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;\\&#x27;</span>) &amp;&amp; postPath) &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title class_">PostAsset</span> = hexo.<span class="hljs-title function_">model</span>(<span class="hljs-string">&#x27;PostAsset&#x27;</span>);<br>    <span class="hljs-comment">// findById requires forward slash</span><br>    <span class="hljs-comment">// ***************** Add the following code *******************</span><br>    <span class="hljs-keyword">const</span> fixPostPath = <span class="hljs-title function_">join</span>(postPath, <span class="hljs-string">&#x27;../&#x27;</span>);<br>    <span class="hljs-keyword">const</span> asset = <span class="hljs-title class_">PostAsset</span>.<span class="hljs-title function_">findById</span>(<span class="hljs-title function_">join</span>(fixPostPath, href.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\\/g</span>, <span class="hljs-string">&#x27;/&#x27;</span>)));<br>    <span class="hljs-comment">// const asset = PostAsset.findById(join(postPath, href.replace(/\\/g, &#x27;/&#x27;)));</span><br>    <span class="hljs-comment">// ************************** End *****************************</span><br>    <span class="hljs-comment">// asset.path is backward slash in Windows</span><br>    <span class="hljs-keyword">if</span> (asset) href = asset.<span class="hljs-property">path</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\\/g</span>, <span class="hljs-string">&#x27;/&#x27;</span>);<br>  &#125;<br>  href = url_for.<span class="hljs-title function_">call</span>(hexo, href);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>enjoy it</li></ol><p><strong>方法二:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"># 设置<br><span class="hljs-attr">post_asset_folder</span>:<span class="hljs-literal">true</span><br># 安装插件 asset-image<br>npm install <span class="hljs-attr">https</span>:<span class="hljs-comment">//github.com/CodeFalling/hexo-asset-image  --save</span><br># typora中设置图片为相对路径 看下图<br>./$&#123;filename&#125;<br># 运行查看<br>hexo clean &amp;&amp; hexo generate &amp;&amp; hexo s <br></code></pre></td></tr></table></figure><p><img src="/2022/f96c3c41/image-20220815133503275.png" alt="image-20220815133503275"></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><blockquote><p>   Env:使用方法四</p><ul><li>文件名不能带有空格, title 可以带空格 (<code>hexo new</code>的时候需要注意这一点)<ul><li>修改 <code>node_modules\hexo-renderer-marked\lib\renderer.js</code>文件可能可以改善这点. -&gt; TBD</li></ul></li><li>md文件名要和图片等等资源文件夹同名 -&gt; 注定了不能使用 <code>./$&#123;filename&#125;.assets</code>这种方案, 一定要改成<code>./$&#123;filename&#125;</code>才行</li></ul></blockquote><h2 id="Hexo-跳过一些文件-不渲染某些文件"><a href="#Hexo-跳过一些文件-不渲染某些文件" class="headerlink" title="Hexo 跳过一些文件,不渲染某些文件"></a>Hexo 跳过一些文件,不渲染某些文件</h2><p>搜索引擎确认网站所有权时往往会提供一个html文件来进行验证，要是这个文件被渲染了，验证自然就会失败了。或者，有时候会写一些简单的html示例页面或<code>README.md</code>，这也是不希望Hexo渲染的。因此有必要针对某个文件或者目录进行排除。</p><p>Hexo博客的基本内容是一些Markdown文件，放在<code>source/_post</code>文件夹下，每个文件对应一篇文章。除此之外，放在<code>source</code>文件夹下的所有开头不是下划线的文件，在<code>hexo generate</code>的时候，都会被拷贝到<code>public</code>文件夹下。但是，Hexo默认会渲染所有的HTML和Markdown文件，导致我的README.md直接转成html格式了。。。</p><p>怎么样避开这个坑呢？如果只有一个HTML文件的话，可以简单地在文件开头加上<code>layout: false</code>一行即可：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">layout:</span> <span class="hljs-literal">false</span><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-string">&lt;html&gt;</span><br><span class="hljs-string">...</span><br></code></pre></td></tr></table></figure><p>如果有多个要避开渲染的md文件，显然是不可能使用这种方法的。这时候需要使用<code>skip_render</code>配置。根据<a href="https://hexo.io/zh-cn/docs/configuration.html">Hexo文档</a>中的说明，通过在<code>_config.yml</code>配置文件中使用<code>skip_render</code>参数，可以跳过指定文件的渲染。使用方式如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">skip_render: [games<span class="hljs-regexp">/**, depview/</span>**, knowledge/**]<br></code></pre></td></tr></table></figure><p>这里的路径匹配可以使用正则表达式。</p><p><strong>注意：<code>skip_render</code>参数设置的路径是相对于<code>source</code>目录的路径。</strong>例如，需要跳过渲染source&#x2F;README.md，只需要设置 <code>skip_render:README.md</code>。</p><p>在设置了跳过渲染之后，最好使用<code>hexo clean</code>清除以前的编译结果，保证配置生效。</p><h2 id="hexo-开启RSS订阅-feed-atom"><a href="#hexo-开启RSS订阅-feed-atom" class="headerlink" title="hexo 开启RSS订阅 feed atom"></a>hexo 开启RSS订阅 feed atom</h2><p>基于<code>hexo-generator-feed</code></p><p>先安装这个包:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-generator-feed<br></code></pre></td></tr></table></figure><p>然后在在<code>_config.yml</code>文件中配置该插件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feed:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">atom</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">atom.xml</span><br>    <span class="hljs-attr">limit:</span> <span class="hljs-number">20</span><br>    <span class="hljs-attr">hub:</span><br>    <span class="hljs-attr">content:</span><br>    <span class="hljs-attr">content_limit:</span><br>    <span class="hljs-attr">content_limit_delim:</span> <span class="hljs-string">&#x27; &#x27;</span><br>    <span class="hljs-attr">order_by:</span> <span class="hljs-string">-date</span><br>    <span class="hljs-attr">icon:</span> <span class="hljs-string">/images/favicon.png</span><br></code></pre></td></tr></table></figure><blockquote><p>  参数的含义：</p><ul><li><code>type</code>: <code>RSS</code>的类型(<code>atom/rss2</code>)</li><li><code>path</code>: 文件路径,默认是<code>atom.xml/rss2.xml</code></li><li><code>limit</code>: 展示文章的数量,使用<strong>0</strong>或则<strong>false</strong>代表展示全部</li><li><code>hub</code>:</li><li><code>content</code>: 在<code>RSS</code>文件中是否包含内容 ,有3个值 <code>true/false</code>默认不填为<code>false</code></li><li><code>content_limit</code>: 指定内容的长度作为摘要,仅仅在上面<code>content</code>设置为<code>false</code>和<code>没有自定义的描述出现</code></li><li><code>content_limit_delim</code>: 上面截取描述的分隔符,截取内容是以指定的这个分隔符作为截取结束的标志.在达到规定的内容长度之前最后出现的这个分隔符之前的内容,，防止从中间截断.</li><li><code>order_by</code>: 顺序排列方式</li><li><code>icon</code>: 图标路径</li></ul></blockquote><p>配置好之后运行<code>hexo clean &amp; hexo g</code>就可以找到你博客的<code>pubilc</code> 文件夹下发现<code>atom.xml</code>文件了</p><p>我们可以在<code>关于(about)</code>页面添加RSS源, 有些主题可以在头像下面自动开启, 这些都是后话了.</p><p>配置RSS的时候发现还有一些其他的推送方式, 比如邮件推送, 浏览器通知推送等等.</p><h3 id="RSS阅读器"><a href="#RSS阅读器" class="headerlink" title="RSS阅读器"></a>RSS阅读器</h3><p><a href="https://feedly.com/">Feedly.com</a> 这个比较满意, 文章显示和界面都不错</p><p><a href="https://www.inoreader.com/">inoreader</a>: 订阅的文章展示效果也还不错(卡片形式).</p><p><a href="https://theoldreader.com/">the old reader</a>: 这个是比较老牌的RSS阅读器了</p><p>参考链接:</p><p><a href="https://segmentfault.com/a/1190000012647294">为hexo博客添加RSS订阅功能</a></p><p><a href="https://sean10.github.io/2020/06/27/hexo%E5%BC%80%E5%90%AFatom%E8%AE%A2%E9%98%85/">hexo开启atom订阅</a></p><h2 id="hexo-静态网页压缩"><a href="#hexo-静态网页压缩" class="headerlink" title="hexo 静态网页压缩"></a>hexo 静态网页压缩</h2><p>了解到有三个插件可以做到这个功能(<code>hexo-neat</code>, <code>gulp</code>, <code>Hexo-all-minifier</code>)</p><p><code>gulp</code>存在各种乱七八糟的依赖关系, 推荐直接用<code>Hexo-all-minifier</code>一套走.</p><h3 id="1-hexo-neat"><a href="#1-hexo-neat" class="headerlink" title="1. hexo-neat"></a>1. hexo-neat</h3><blockquote><h2 id="集成插件-hexo-neat"><a href="#集成插件-hexo-neat" class="headerlink" title="集成插件 hexo-neat"></a>集成插件 hexo-neat</h2><p>  首先时所说集成压缩 HTML JS CSS 为一体的 <code>hexo-neat</code> 插件，该插件有以下几个问题：</p><ol><li>各种打印信息输出一大串，并且还不能去掉打印信息，而且还向编译后的文件加入私有注释 <code>rebuild by neat</code>，不太爽！</li><li><a href="https://www.npmjs.com/package/hexo-neat">npm包</a> 跟 <a href="https://github.com/rozbo/hexo-neat">github 包</a> 不统一，github 的 README 有 logger 配置选项，npm 包却没有这配置。</li><li>每次执行 <code>npm run build</code> html 都被重新构建，不能启用 hexo 缓存优化，看不到最新的 html 构建信息。</li><li>包长久不维护。</li></ol></blockquote><p>基于以上放弃了这个插件</p><h3 id="2-gulp"><a href="#2-gulp" class="headerlink" title="2. gulp"></a>2. gulp</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装gulp</span><br>npm install gulp --save<br><span class="hljs-comment"># 安装gulp依赖</span><br>npm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp-imagemin --save<br></code></pre></td></tr></table></figure><p><strong>创建 gulpfile.js 文件</strong></p><p>在<code>Hexo</code>站点根目录下创建<code>gulpfile.js</code>文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-keyword">var</span> gulp = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gulp&#x27;</span>);<br><span class="hljs-keyword">var</span> minifycss = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gulp-minify-css&#x27;</span>);<br><span class="hljs-keyword">var</span> uglify = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gulp-uglify&#x27;</span>);<br><span class="hljs-keyword">var</span> htmlmin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gulp-htmlmin&#x27;</span>);<br><span class="hljs-keyword">var</span> htmlclean = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gulp-htmlclean&#x27;</span>);<br><span class="hljs-keyword">var</span> imagemin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gulp-imagemin&#x27;</span>);<br><span class="hljs-comment">// 压缩css文件</span><br>gulp.<span class="hljs-title function_">task</span>(<span class="hljs-string">&#x27;minify-css&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> gulp.<span class="hljs-title function_">src</span>(<span class="hljs-string">&#x27;./public/**/*.css&#x27;</span>)<br>  .<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">minifycss</span>())<br>  .<span class="hljs-title function_">pipe</span>(gulp.<span class="hljs-title function_">dest</span>(<span class="hljs-string">&#x27;./public&#x27;</span>));<br>&#125;);<br><span class="hljs-comment">// 压缩html文件</span><br>gulp.<span class="hljs-title function_">task</span>(<span class="hljs-string">&#x27;minify-html&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> gulp.<span class="hljs-title function_">src</span>(<span class="hljs-string">&#x27;./public/**/*.html&#x27;</span>)<br>  .<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">htmlclean</span>())<br>  .<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">htmlmin</span>(&#123;<br>    <span class="hljs-attr">removeComments</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">minifyJS</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">minifyCSS</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">minifyURLs</span>: <span class="hljs-literal">true</span>,<br>  &#125;))<br>  .<span class="hljs-title function_">pipe</span>(gulp.<span class="hljs-title function_">dest</span>(<span class="hljs-string">&#x27;./public&#x27;</span>))<br>&#125;);<br><span class="hljs-comment">// 压缩js文件</span><br>gulp.<span class="hljs-title function_">task</span>(<span class="hljs-string">&#x27;minify-js&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> gulp.<span class="hljs-title function_">src</span>([<span class="hljs-string">&#x27;./public/**/.js&#x27;</span>,<span class="hljs-string">&#x27;!./public/js/**/*min.js&#x27;</span>])<br>        .<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">uglify</span>())<br>        .<span class="hljs-title function_">pipe</span>(gulp.<span class="hljs-title function_">dest</span>(<span class="hljs-string">&#x27;./public&#x27;</span>));<br>&#125;);<br><span class="hljs-comment">// 压缩 public/demo 目录内图片</span><br>gulp.<span class="hljs-title function_">task</span>(<span class="hljs-string">&#x27;minify-images&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    gulp.<span class="hljs-title function_">src</span>(<span class="hljs-string">&#x27;./public/demo/**/*.*&#x27;</span>)<br>        .<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">imagemin</span>(&#123;<br>           <span class="hljs-attr">optimizationLevel</span>: <span class="hljs-number">5</span>, <span class="hljs-comment">//类型：Number  默认：3  取值范围：0-7（优化等级）</span><br>           <span class="hljs-attr">progressive</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">//类型：Boolean 默认：false 无损压缩jpg图片</span><br>           <span class="hljs-attr">interlaced</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">//类型：Boolean 默认：false 隔行扫描gif进行渲染</span><br>           <span class="hljs-attr">multipass</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">//类型：Boolean 默认：false 多次优化svg直到完全优化</span><br>        &#125;))<br>        .<span class="hljs-title function_">pipe</span>(gulp.<span class="hljs-title function_">dest</span>(<span class="hljs-string">&#x27;./public/uploads&#x27;</span>));<br>&#125;);<br><span class="hljs-comment">// 默认任务 gulp 4.0 适用的方式</span><br>gulp.<span class="hljs-title function_">task</span>(<span class="hljs-string">&#x27;default&#x27;</span>, gulp.<span class="hljs-title function_">parallel</span>(<span class="hljs-string">&#x27;minify-html&#x27;</span>, <span class="hljs-string">&#x27;minify-css&#x27;</span>, <span class="hljs-string">&#x27;minify-js&#x27;</span><br> <span class="hljs-comment">//build the website</span><br>));<br></code></pre></td></tr></table></figure><p>只要每次在执行<code>hexo g</code>命令后执行<code>gulp</code>就可以进行静态资源压缩，压缩后再同步到github上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo cl &amp; hexo g &amp; gulp<br>hexo d<br></code></pre></td></tr></table></figure><h4 id="注意-这里部署的时候出了一个问题"><a href="#注意-这里部署的时候出了一个问题" class="headerlink" title="注意: 这里部署的时候出了一个问题"></a><strong>注意: 这里部署的时候出了一个问题</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">Error [ERR_REQUIRE_ESM]: require() of ES Module xxx\hexo\node_modules\gulp-imagemin\index.js from xxx\hexo\gulpfile.js not supported.<br>Instead change the require of index.js <span class="hljs-keyword">in</span> xxx\hexo\gulpfile.js to a dynamic import() <span class="hljs-built_in">which</span> is available <span class="hljs-keyword">in</span> all CommonJS modules.<br>    at Object.&lt;anonymous&gt; (xxx\hexo\gulpfile.js:6:16)<br>    at async Promise.all (index 0) &#123;<br>  code: <span class="hljs-string">&#x27;ERR_REQUIRE_ESM&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>  gulp-imagemin 8.0.0 and above are now ESM only. You can downgrade gulp-imagemin to 7.1.0 which is commonjs and it should work fine.</p><blockquote><p>  This package is now pure ESM. Please read this.</p></blockquote><p>  <a href="https://github.com/sindresorhus/gulp-imagemin/releases/tag/v8.0.0">https://github.com/sindresorhus/gulp-imagemin/releases/tag/v8.0.0</a></p></blockquote><p><strong>最终找到说是包的版本太高导致的</strong></p><p>重新安装特定版本的包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 先卸载掉这些包</span><br>npm uninstall gulp<br>npm uninstall gulp-htmlclean gulp-htmlmin gulp-clean-css gulp-uglify gulp-imagemin<br>npm uninstall gulp-minify-css <br><br><span class="hljs-comment"># 重新安装</span><br>npm install gulp@4.0.2 --save<br>npm install gulp-htmlclean@4.0.2 gulp-htmlmin@5.0.1 gulp-clean-css@4.2.0 gulp-uglify@3.0.2 gulp-imagemin@7.1.0 --save<br>npm install gulp-babel@8.0.0 babel-preset-env@1.7.0 babel-preset-mobx@2.0.0 --save<br>npm install gulp-miniify-css@1.2.4 -save<br></code></pre></td></tr></table></figure><blockquote><p>  包的版本可以参考这个<br>  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;babel-preset-env&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^1.7.0&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;babel-preset-mobx&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^2.0.0&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;gulp&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^4.0.2&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;gulp-babel&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^8.0.0&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;gulp-clean-css&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^4.2.0&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;gulp-htmlclean&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^2.7.22&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;gulp-htmlmin&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^5.0.1&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;gulp-imagemin&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^7.1.0&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;gulp-uglify&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^3.0.2&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;gulp-minify-css&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^1.2.4&quot;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure></p></blockquote><p>把<code>gulpfile.js</code>也改动了一下, </p><p>在<code>minify-images</code>项里面我的图片是随文章存放的, 并不是全部存放在<code>img</code>等文件夹下面, 所以只能用全文件匹配去做图片压缩, 代价就是速度很忙, 希望有大佬来指点一下如何更好的修改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> gulp      = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gulp&#x27;</span>)<br><span class="hljs-keyword">let</span> htmlmin   = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gulp-htmlmin&#x27;</span>)<br><span class="hljs-keyword">let</span> htmlclean = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gulp-htmlclean&#x27;</span>)<br><span class="hljs-keyword">let</span> uglify    = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gulp-uglify&#x27;</span>)<br><span class="hljs-keyword">let</span> imagemin  = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gulp-imagemin&#x27;</span>)<br><span class="hljs-keyword">var</span> minifycss = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gulp-minify-css&#x27;</span>);<br><br><span class="hljs-comment">// 压缩html</span><br>gulp.<span class="hljs-title function_">task</span>(<span class="hljs-string">&#x27;minify-html&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 匹配所有 .html结尾的文件</span><br>    <span class="hljs-keyword">return</span> gulp.<span class="hljs-title function_">src</span>(<span class="hljs-string">&#x27;./public/**/*.html&#x27;</span>)<br>        .<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">htmlclean</span>())<br>        .<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">htmlmin</span>(&#123;<br>            <span class="hljs-attr">removeComments</span>: <span class="hljs-literal">true</span>,<br>            <span class="hljs-attr">minifyJS</span>: <span class="hljs-literal">true</span>,<br>            <span class="hljs-attr">minifyCSS</span>: <span class="hljs-literal">true</span>,<br>            <span class="hljs-attr">minifyURLs</span>: <span class="hljs-literal">true</span>,<br>        &#125;))<br>        .<span class="hljs-title function_">pipe</span>(gulp.<span class="hljs-title function_">dest</span>(<span class="hljs-string">&#x27;./public&#x27;</span>))<br>&#125;);<br><br><span class="hljs-comment">// 压缩css</span><br>gulp.<span class="hljs-title function_">task</span>(<span class="hljs-string">&#x27;minify-css&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> gulp.<span class="hljs-title function_">src</span>(<span class="hljs-string">&#x27;./public/**/*.css&#x27;</span>)<br>        .<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">minifycss</span>())<br>        .<span class="hljs-title function_">pipe</span>(gulp.<span class="hljs-title function_">dest</span>(<span class="hljs-string">&#x27;./public&#x27;</span>));<br>&#125;);<br><br><span class="hljs-comment">// 压缩js</span><br>gulp.<span class="hljs-title function_">task</span>(<span class="hljs-string">&#x27;minify-js&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> gulp.<span class="hljs-title function_">src</span>([<span class="hljs-string">&#x27;./public/**/.js&#x27;</span>, <span class="hljs-string">&#x27;!./public/js/**/*min.js&#x27;</span>])<br>        .<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">uglify</span>())<br>        .<span class="hljs-title function_">pipe</span>(gulp.<span class="hljs-title function_">dest</span>(<span class="hljs-string">&#x27;./public&#x27;</span>));<br>&#125;)<br><br><span class="hljs-comment">// 压缩图片</span><br>gulp.<span class="hljs-title function_">task</span>(<span class="hljs-string">&#x27;minify-images&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> gulp.<span class="hljs-title function_">src</span>(<span class="hljs-string">&#x27;./public/**/*.*&#x27;</span>)<br>        .<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">imagemin</span>(&#123;<br>            <span class="hljs-attr">optimizationLevel</span>: <span class="hljs-number">5</span>, <span class="hljs-comment">//类型：Number  默认：3  取值范围：0-7（优化等级）</span><br>            <span class="hljs-attr">progressive</span>: <span class="hljs-literal">true</span>,    <span class="hljs-comment">//类型：Boolean 默认：false 无损压缩jpg图片</span><br>            <span class="hljs-attr">interlaced</span>: <span class="hljs-literal">false</span>,    <span class="hljs-comment">//类型：Boolean 默认：false 隔行扫描gif进行渲染</span><br>            <span class="hljs-attr">multipass</span>: <span class="hljs-literal">false</span>,     <span class="hljs-comment">//类型：Boolean 默认：false 多次优化svg直到完全优化</span><br>        &#125;))<br>        .<span class="hljs-title function_">pipe</span>(gulp.<span class="hljs-title function_">dest</span>(<span class="hljs-string">&#x27;./public&#x27;</span>));<br>&#125;)<br><br>gulp.<span class="hljs-title function_">task</span>(<span class="hljs-string">&#x27;default&#x27;</span>, gulp.<span class="hljs-title function_">series</span>(<span class="hljs-string">&#x27;minify-html&#x27;</span>, <span class="hljs-string">&#x27;minify-css&#x27;</span>, <span class="hljs-string">&#x27;minify-js&#x27;</span>, <span class="hljs-string">&#x27;minify-images&#x27;</span>))<br></code></pre></td></tr></table></figure><h3 id="3-Hexo-all-minifier"><a href="#3-Hexo-all-minifier" class="headerlink" title="3. Hexo-all-minifier"></a>3. Hexo-all-minifier</h3><blockquote><p>  <a href="https://github.com/chenzhutian/hexo-all-minifier">https://github.com/chenzhutian/hexo-all-minifier</a></p><p>  <a href="https://archive.vincent0700.com/2019/12/31/034_Usage_of_hexo-all-minifier_copy/">Hexo 资源压缩 | hexo-all-minifier</a></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装</span><br>npm install hexo-all-minifier --save<br><br><span class="hljs-comment"># 在_config.yml文件添加配置</span><br>all_minifier: <span class="hljs-literal">true</span><br><br><span class="hljs-comment"># </span><br>hexo cl &amp; hexo g <br></code></pre></td></tr></table></figure><h2 id="Hexo-Sitemap"><a href="#Hexo-Sitemap" class="headerlink" title="Hexo Sitemap"></a>Hexo Sitemap</h2><blockquote><p>   据网友所言: 谷歌就xx乱爬, 百度就xx乱删, 必应就xx不收录</p></blockquote><p>为了让博文能够被google或百度检索，需要先将网站收录到他们的库里面，我们可以在谷歌的站长平台里面提交我们的sitemap文件，告诉浏览器应该我们的站点有哪些页面，这样他就会去爬取收录了。</p><blockquote><p>  站点地图是一种文件，您可以在其中提供与您网站中的网页、视频或其他文件有关的信息，还可以说明这些内容之间的关系。Google 等搜索引擎会读取此文件，以便更高效地抓取您的网站。站点地图会告诉 Google 您认为网站中的哪些网页和文件比较重要，还会提供与这些文件有关的重要信息。例如，网页上次更新的时间和网页是否有任何备用的语言版本。</p><p>  您可以使用站点地图提供与特定类型的网页内容（包括<a href="https://developers.google.com/search/docs/advanced/sitemaps/video-sitemaps">视频</a>、<a href="https://developers.google.com/search/docs/advanced/sitemaps/image-sitemaps">图片</a>和<a href="https://developers.google.com/search/docs/advanced/sitemaps/news-sitemap">新闻</a>内容）有关的信息。例如：</p><ul><li>站点地图视频条目可以指定视频的时长、评分以及适合哪些年龄段的受众。</li><li>站点地图图片条目中可包含网页中所含图片的位置。</li><li>站点地图新闻条目中可包含报道标题和发布日期。</li></ul><p>  <strong>我需要站点地图吗？</strong></p><p>  如果您网站上的网页链接得当，那么 Google 通常能够发现其中的大多数网页。链接得当是指您认为重要的所有网页都可以通过某些形式的导航（例如您网站的菜单，或您放入网页中的链接）抵达。即便如此，站点地图仍有助于我们更加高效地抓取规模更大、更复杂的网站或更特殊的文件。</p></blockquote><h3 id="生成sitemap-xml"><a href="#生成sitemap-xml" class="headerlink" title="生成sitemap.xml"></a>生成<code>sitemap.xml</code></h3><p>首先我们安装生成sitemao的插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 谷歌的</span><br>npm install hexo-generator-sitemap --save<br><span class="hljs-comment"># 百度的</span><br>npm install hexo-generator-baidu-sitemap --save<br></code></pre></td></tr></table></figure><p>修改配置文件<code>_config.yml</code>增加下面这些内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">Plugins:<br>- hexo-generator-sitemap<br>- hexo-generator-baidu-sitemap<br><br>baidusitemap:<br>  path: baidusitemap.xml<br>sitemap:<br>  path: sitemap.xml<br></code></pre></td></tr></table></figure><p>生成<code>sitemap.xml</code>文件, 重新生成网站, 在网站根目录就可以看到<code>sitemap.xml</code>文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo cl &amp; hexo g <br></code></pre></td></tr></table></figure><h3 id="提交sitemap-xml"><a href="#提交sitemap-xml" class="headerlink" title="提交sitemap.xml"></a>提交<code>sitemap.xml</code></h3><p><a href="https://www.google.com/webmasters/tools">GoogleSearchConsole</a></p><p><a href="https://www.bing.com/webmasters/">BingWebMaster</a></p><p><a href="https://ziyuan.baidu.com/site/index">百度资源平台</a></p><p><strong>下面讲一下谷歌的</strong></p><p>登录<a href="https://www.google.com/webmasters/tools">GoogleSearchConsole</a>, 按照提示验证站点的所有权</p><p>打开谷歌控制台选择-&gt;<strong>索引</strong>-&gt;<strong>站点地图</strong>，在添加新的站点地图中填入你的<code>sitemap.xml</code>的路径, 这里直接写<code>sitemap.xml</code>即可。</p><p><img src="/2022/f96c3c41/image-20220918004138059.png" alt="image-20220918004138059"></p><blockquote><p>   这个谷歌真是让我大无语, 一直显示无法获取, 一直没法解决这个问题, 网址检查显示没什么问题, 但是一直显示无法获取真是麻了.</p><p>  求助群友后他们推荐使用 Hexo-SEO-AutoPush</p></blockquote><h3 id="收录查询"><a href="#收录查询" class="headerlink" title="收录查询"></a>收录查询</h3><ol><li><p>通过网站管理平台的控制台去看数据</p></li><li><p>搜索引擎直接搜索</p></li></ol><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">site:</span>oikiou.top<br></code></pre></td></tr></table></figure><h3 id="手动生成Sitemap文件"><a href="#手动生成Sitemap文件" class="headerlink" title="手动生成Sitemap文件"></a>手动生成Sitemap文件</h3><p><a href="https://www.xml-sitemaps.com/">https://www.xml-sitemaps.com/</a></p><h2 id="Hexo-SEO-AutoPush的使用"><a href="#Hexo-SEO-AutoPush的使用" class="headerlink" title="Hexo-SEO-AutoPush的使用"></a>Hexo-SEO-AutoPush的使用</h2><p><a href="https://github.com/Lete114/Hexo-SEO-AutoPush">https://github.com/Lete114/Hexo-SEO-AutoPush</a></p><blockquote><p>  注意以下几点: </p><ol><li>由于生成的 actions 是在<code>.github/workflows/HexoSeoAutoPush.yml</code>，点开头的文件或文件夹都会被视为隐藏文件，所以 hexo 不会将隐藏文件部署到 pages，需要新增配置<code>ignore_hidden</code></li></ol><pre><code class="hljs"> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">deploy:<br> ignore_hidden: <span class="hljs-literal">false</span> <span class="hljs-comment"># 忽略隐藏文件及文件夹(目录)</span><br></code></pre></td></tr></table></figure> </code></pre><ol start="2"><li><p>Bing的<code>API</code>在登录控制台后的<em>右上角齿轮上</em>可以找到, 如果找不到可能是界面更新导致的, 请参考官方文档</p></li><li><p>注意google的信息填写方式</p><p><code>google_private_key</code>是填写Json内的 <code>private_key </code> 不是<code>private_key_id </code>注意区分. </p><p>而且<code>google_private_key </code> 是带双引号的需要注意, 而<code>google_client_email</code>填写的时候是不带双引号的.</p><table><thead><tr><th>名称</th><th>形似</th><th>说明</th></tr></thead><tbody><tr><td>google_client_email</td><td><a href="mailto:&#120;&#120;&#x78;&#x40;&#120;&#120;&#120;&#46;&#x78;&#x78;&#x78;&#46;&#x67;&#115;&#x65;&#x72;&#118;&#x69;&#x63;&#101;&#97;&#99;&#99;&#x6f;&#x75;&#110;&#116;&#46;&#99;&#111;&#x6d;">&#120;&#120;&#x78;&#x40;&#120;&#120;&#120;&#46;&#x78;&#x78;&#x78;&#46;&#x67;&#115;&#x65;&#x72;&#118;&#x69;&#x63;&#101;&#97;&#99;&#99;&#x6f;&#x75;&#110;&#116;&#46;&#99;&#111;&#x6d;</a></td><td>【必填】Value 输入谷歌的 client_email</td></tr><tr><td>google_private_key</td><td>“—–BEGIN PRIVATE KEY—–\nxxxxxx\n—–END PRIVATE KEY—–\n”</td><td>【必填】Value 输入谷歌的 private_key （注意：填写的时候需要使用<strong>双引号</strong>包起来，如: <code>&quot;private_key&quot;</code>）</td></tr></tbody></table></li></ol></blockquote><p>在Github内点击Action-&gt;Hexo SEO Auto Push -&gt; 查看执行情况 没有报错就是执行的没问题, 稍等片刻刷新控制台就可以看到提交的信息.</p><p>打开<a href="https://www.bing.com/webmasters/">Home - Bing Webmaster Tools</a>, <code>URL提交</code>标签</p><p>在<a href="https://console.cloud.google.com/apis/dashboard">Google Cloud Platform</a> 中查看.</p><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意:"></a><strong>注意:</strong></h3><p>部署的时候报了下面这个错误, 当时弄这个东西的时候是半夜, 脑子不清醒(各位同学注意早睡早起, 熬夜效率是极其低下的), <code>private_key</code>填写错了发生了这个错误, 有相似错误的同学可以看看是不是<code>private_key</code>有问题.</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs awk">Run npx hexoautopush *** ***<br>Error: error:<span class="hljs-number">0909006</span>C:PEM routines:get_name:no start line<br>    at Sign.sign (internal<span class="hljs-regexp">/crypto/</span>sig.js:<span class="hljs-number">110</span>:<span class="hljs-number">29</span>)<br>    at Object.sign (<span class="hljs-regexp">/xxx/</span>node_modules<span class="hljs-regexp">/jwa/i</span>ndex.js:<span class="hljs-number">152</span>:<span class="hljs-number">45</span>)<br>    at Object.jwsSign [as sign] (<span class="hljs-regexp">/xxx/</span>node_modules<span class="hljs-regexp">/jws/</span>lib/sign-stream.js:<span class="hljs-number">32</span>:<span class="hljs-number">24</span>)<br>    at GoogleToken.requestToken (<span class="hljs-regexp">/xxx/</span>node_modules<span class="hljs-regexp">/gtoken/</span>build<span class="hljs-regexp">/src/i</span>ndex.js:<span class="hljs-number">225</span>:<span class="hljs-number">31</span>)<br>    at GoogleToken.getTokenAsyncInner (<span class="hljs-regexp">/xxx/</span>node_modules<span class="hljs-regexp">/gtoken/</span>build<span class="hljs-regexp">/src/i</span>ndex.js:<span class="hljs-number">163</span>:<span class="hljs-number">21</span>)<br>    at GoogleToken.getTokenAsync (<span class="hljs-regexp">/xxx/</span>node_modules<span class="hljs-regexp">/gtoken/</span>build<span class="hljs-regexp">/src/i</span>ndex.js:<span class="hljs-number">142</span>:<span class="hljs-number">55</span>)<br>    at GoogleToken.getToken (<span class="hljs-regexp">/xxx/</span>node_modules<span class="hljs-regexp">/gtoken/</span>build<span class="hljs-regexp">/src/i</span>ndex.js:<span class="hljs-number">94</span>:<span class="hljs-number">21</span>)<br>    at JWT.refreshTokenNoCache (<span class="hljs-regexp">/xxx/</span>node_modules<span class="hljs-regexp">/google-auth-library/</span>build<span class="hljs-regexp">/src/</span>auth/jwtclient.js:<span class="hljs-number">171</span>:<span class="hljs-number">36</span>)<br>    at JWT.refreshToken (<span class="hljs-regexp">/xxx/</span>node_modules<span class="hljs-regexp">/google-auth-library/</span>build<span class="hljs-regexp">/src/</span>auth/oauth2client.js:<span class="hljs-number">145</span>:<span class="hljs-number">25</span>)<br>    at JWT.authorizeAsync (<span class="hljs-regexp">/xxx/</span>node_modules<span class="hljs-regexp">/google-auth-library/</span>build<span class="hljs-regexp">/src/</span>auth/jwtclient.js:<span class="hljs-number">152</span>:<span class="hljs-number">35</span>) &#123;<br>  library: <span class="hljs-string">&#x27;PEM routines&#x27;</span>,<br>  <span class="hljs-keyword">function</span>: <span class="hljs-string">&#x27;get_name&#x27;</span>,<br>  reason: <span class="hljs-string">&#x27;no start line&#x27;</span>,<br>  code: <span class="hljs-string">&#x27;ERR_OSSL_PEM_NO_START_LINE&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Hexo博客修改Archive页面显示文章数量"><a href="#Hexo博客修改Archive页面显示文章数量" class="headerlink" title="Hexo博客修改Archive页面显示文章数量"></a>Hexo博客修改Archive页面显示文章数量</h2><p>默认情况下，Hexo无法对主页、Archive页面、标签页面每页显示文章数量进行单独设置</p><p>这里我们借助<code>hexo-generator-archive</code>来实现这个功能, 因为Archive分页的话看起来贼难受, 如果能将所有的文章全部显示那就舒服了.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 先安装包</span><br>npm install hexo-generator-archive --save<br></code></pre></td></tr></table></figure><p>编辑<code>_config.yml</code>新增以下内容</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Pagination</span><br><span class="hljs-comment">## Set per_page to 0 to disable pagination</span><br><span class="hljs-attr">index_generator:</span><br>  <span class="hljs-attr">per_page:</span> <span class="hljs-number">32</span><br><br><span class="hljs-attr">index_generator:</span><br>  <span class="hljs-attr">per_page:</span> <span class="hljs-number">5</span><br><br><span class="hljs-attr">archive_generator:</span><br>  <span class="hljs-attr">per_page:</span> <span class="hljs-number">20</span>  <span class="hljs-comment">#为0时表示不分页全展示</span><br>  <span class="hljs-attr">yearly:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment">#按年生成归档</span><br>  <span class="hljs-attr">monthly:</span> <span class="hljs-literal">false</span> <span class="hljs-comment">#按月生成归档</span><br><br><span class="hljs-attr">tag_generator:</span><br>  <span class="hljs-attr">per_page:</span> <span class="hljs-number">10</span><br><br><span class="hljs-attr">category_generator:</span><br>  <span class="hljs-attr">per_page:</span> <span class="hljs-number">50</span><br></code></pre></td></tr></table></figure><blockquote><p>  注意:上面归档设置中的按年或者按月，需要修改模板给出对应的链接入口，对于没有兴趣修改模板的同学，可以将此处设为false，减少生成页面时的工作量。</p></blockquote><h1 id="Comment-评论系统"><a href="#Comment-评论系统" class="headerlink" title="Comment 评论系统"></a>Comment 评论系统</h1><h2 id="cusdis-系统"><a href="#cusdis-系统" class="headerlink" title="cusdis 系统"></a>cusdis 系统</h2><p>功能较少,看起来非常轻量, 也可以私有部署,正打算私有部署的时候看到了<code>twikoo</code>所以就转入<code>twikoo</code>了,因为cusdis现阶段功能确实有些少.</p><h2 id="twikoo-系统"><a href="#twikoo-系统" class="headerlink" title="twikoo 系统"></a>twikoo 系统</h2><p><a href="https://twikoo.js.org/">https://twikoo.js.org/</a></p><p>私有docker部署部署半天还是不成功, 看起来像是需要HTTPS才行.</p><p>功能挺丰富的,<del>就是半天没部署成功</del></p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">部署后没有启用HTTPS<br>fluid 配置里面又启动了强行使用hTTPS, <br><span class="hljs-built_in">F12,</span>看consel发现,ERR_SSL_PROTOCOL_ERROR,被重定向到了HTTPS去了<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css">头像风格类型<br><span class="hljs-number">404</span>：如果没有任何图像与电子邮件哈希无关，则不加载任何图像，而是返回HTTP <span class="hljs-number">404</span>（找不到文件）响应<br>mp：（神秘人物）一个人的简单卡通风格的轮廓（不随电子邮件哈希值而变化）<br>identicon：基于电子邮件哈希的几何图案<br>monsterid：生成的具有不同颜色，面孔等的“怪物”<br>wavatar：生成的具有不同特征和背景的面孔<br>retro：生成的令人敬畏的<span class="hljs-number">8</span>位街机风格像素化面孔<br>robohash：具有不同颜色，面部等的生成的机器人<br>blank：透明的PNG图像（以下为演示目的添加到<span class="hljs-selector-tag">HTML</span>的边框）<br></code></pre></td></tr></table></figure><ul><li><p>Twikoo我是用的docker,nginx和ssl配置可以参考<a href="https://hub.docker.com/r/imaegoo/twikoo">DockerHub</a>, https的端口是可以更改的, 默认的443占用了换成别的就好.</p></li><li><p>twikoo的即时推送尝试了几个譬如 Qmsq, server酱等等发现又一系列的问题 都不尽如人意  最后选择的是最简单的邮件通知.</p></li></ul><h2 id="remark42"><a href="#remark42" class="headerlink" title="remark42"></a>remark42</h2><h1 id="部署平台-托管平台"><a href="#部署平台-托管平台" class="headerlink" title="部署平台(托管平台)"></a>部署平台(托管平台)</h1><p><a href="https://i.vince.pub/p/hexo-static/">常见静态网站托管平台使用及多节点部署方案</a></p><p><img src="/2022/f96c3c41/2fc062cb2.svg" alt="节点"></p><p>现阶段比较好的方案是<code>coding</code>和<code>github+netlify</code>.</p><h1 id="一些资源"><a href="#一些资源" class="headerlink" title="一些资源"></a>一些资源</h1><p><strong>字体族（<code>font-family</code>）</strong></p><blockquote><p>   <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-family">https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-family</a></p></blockquote><p><strong>调色板灵感</strong></p><blockquote><p>   <a href="https://www.webdesignrankings.com/resources/lolcolors/">https://www.webdesignrankings.com/resources/lolcolors/</a></p></blockquote><p><strong>ISO-8601 日期</strong></p><blockquote><p>  <a href="http://momentjs.cn/docs/#/parsing/string-format/">http://momentjs.cn/docs/#/parsing/string-format/</a></p></blockquote><p><strong>代码高亮风格</strong></p><blockquote><p>  highlightjs:  <a href="https://highlightjs.org/static/demo/">https://highlightjs.org/static/demo/</a></p><p>  prismjs:  <a href="https://prismjs.com/">https://prismjs.com/</a></p></blockquote><p><strong>Logo生成器</strong></p><blockquote><p>  adobe: <a href="https://www.adobe.com/express/create/logo">https://www.adobe.com/express/create/logo</a></p></blockquote><p><strong>图床</strong></p><blockquote><p>  <a href="https://postimg.cc/">https://postimg.cc/</a></p></blockquote><p><strong>壁纸</strong></p><blockquote><p>  <a href="https://wallpapercrafter.com/">https://wallpapercrafter.com/</a></p></blockquote><p><strong>实时获取网站的<code>Favicon.ion</code>文件</strong></p><blockquote><p>  <a href="https://tools.ly522.com/ico/">https://tools.ly522.com/ico/</a></p><p>  远程实时获取并显示网站的Favicon.ico文件，美化网站外链显示效果。</p></blockquote><h1 id="一些知识"><a href="#一些知识" class="headerlink" title="一些知识"></a>一些知识</h1><h2 id="Creative-Commons-licenses"><a href="#Creative-Commons-licenses" class="headerlink" title="Creative Commons licenses"></a>Creative Commons licenses</h2><p><a href="https://www.wur.nl/en/article/What-are-Creative-Commons-licenses.htm">What are Creative Commons licenses?</a></p><p><img src="/2022/f96c3c41/licences_3bf0e9af_670x502.jpg" alt="知识共享许可.jpg"></p><h2 id="Gravatar-amp-Cravatar"><a href="#Gravatar-amp-Cravatar" class="headerlink" title="Gravatar &amp; Cravatar"></a>Gravatar &amp; Cravatar</h2><p><a href="https://en.gravatar.com/">Gravatar</a> &amp; <a href="https://cravatar.cn/">Cravatar</a>的差异</p><h3 id="Gravatar"><a href="#Gravatar" class="headerlink" title="Gravatar"></a>Gravatar</h3><p>Gravatar是一项用于提供在全球范围内使用的头像服务。只要你在Gravatar的服务器上上传了你自己的头像，你便可以在其他任何支持Gravatar的博客、论坛等地方使用它。</p><h3 id="Cravatar-cn"><a href="#Cravatar-cn" class="headerlink" title="Cravatar  (cn)"></a>Cravatar  (cn)</h3><p>Cravatar 是 Gravatar 在中国的完美替代方案,从此你可以自由的上传和分享头像。</p><p><strong>与 Gravatar API 兼容</strong></p><p>为了降低你的使用成本，我们的 API 规范始终保持与 Gravatar 100% 兼容</p><p><strong>独有的三级头像匹配机制</strong></p><p>当访客请求自己的头像时，我们会按此顺序分三级匹配头像：<strong>Cravatar-&gt;Gravatar-&gt;QQ 头像</strong>，对于博客站，这平均可以为 70% 的访客提供准确的头像</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;静态网页&quot;&gt;&lt;a href=&quot;#静态网页&quot; class=&quot;headerlink&quot; title=&quot;静态网页&quot;&gt;&lt;/a&gt;静态网页&lt;/h1&gt;&lt;h1 id=&quot;静态网页生成器&quot;&gt;&lt;a href=&quot;#静态网页生成器&quot;</summary>
        
      
    
    
    
    <category term="tools" scheme="https://www.oikiou.top/categories/tools/"/>
    
    
    <category term="hexo" scheme="https://www.oikiou.top/tags/hexo/"/>
    
    <category term="jekyll" scheme="https://www.oikiou.top/tags/jekyll/"/>
    
    <category term="fluid" scheme="https://www.oikiou.top/tags/fluid/"/>
    
    <category term="cusdis" scheme="https://www.oikiou.top/tags/cusdis/"/>
    
    <category term="twikoo" scheme="https://www.oikiou.top/tags/twikoo/"/>
    
    <category term="blog" scheme="https://www.oikiou.top/tags/blog/"/>
    
    <category term="gravatar" scheme="https://www.oikiou.top/tags/gravatar/"/>
    
    <category term="cravatar" scheme="https://www.oikiou.top/tags/cravatar/"/>
    
  </entry>
  
  <entry>
    <title>字符集和字符编码</title>
    <link href="https://www.oikiou.top/2022/438d1de3/"/>
    <id>https://www.oikiou.top/2022/438d1de3/</id>
    <published>2022-08-14T14:12:34.000Z</published>
    <updated>2022-09-16T05:10:53.748Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字符集和字符编码"><a href="#字符集和字符编码" class="headerlink" title="字符集和字符编码"></a>字符集和字符编码</h1><p><a href="https://www.cnblogs.com/skynet/archive/2011/05/03/2035105.html">字符集和字符编码 (Charset &amp; Encoding)</a></p><p><a href="http://www.knowsky.com/resource/gb2312tbl.htm">GB2312简体中文编码表</a></p><p><a href="http://tools.jb51.net/table/gb2312">GB2312简体中文编码表</a></p><p><a href="https://www.unicode.org/charts/">Unicode码查询</a></p><p><a href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84">Unicode字符平面映射</a></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>字符集（Charset）</strong>：是一个系统支持的所有抽象字符的集合。字符是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等。</p><p>常见字符集：ASCII字符集、GB2312字符集、BIG5字符集、GB18030字符集、Unicode字符集等。计算机要准确的处理各种字符集文字，需要进行字符编码，以便计算机能够识别和存储各种文字。</p><p><strong>字符编码（Character Encoding）</strong>：是一套法则，使用该法则能够对自然语言的字符的一个集合（如字母表或音节表），与其他东西的一个集合（如号码、数字或电脉冲）进行配对。即在符号集合与数字系统之间建立对应关系，它是信息处理的一项基本技术。通常人们用符号集合（一般情况下就是文字）来表达信息。而以计算机为基础的信息处理系统则是利用元件（硬件）不同状态的组合来存储和处理信息的。元件不同状态的组合能代表数字系统的数字，因此字符编码就是将符号转换为计算机可以接受的数字系统的数，称为数字代码。</p><h2 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h2><p><strong>ASCII字符集</strong>：主要包括控制字符（回车键、退格、换行键等）；可显示字符（英文大小写字符、阿拉伯数字和西文符号）。</p><p><strong>ASCII编码</strong>：将ASCII字符集转换为计算机可以接受的数字系统的数的规则。使用7位（bits）表示一个字符，共128字符；但是7位编码的字符集只能支持128个字符，为了表示更多的常用字符欧洲对ASCII进行了扩展，ASCII扩展字符集使用8位（bits）表示一个字符，共256字符。ASCII字符集映射到数字编码规则如下图所示：</p><p><img src="/2022/438d1de3/2011050311372042.png" alt="img"></p><p><img src="/2022/438d1de3/201105031137219627.png" alt="img"></p><h2 id="GBxxx"><a href="#GBxxx" class="headerlink" title="GBxxx"></a>GBxxx</h2><p>中国把那些127号之后的奇异符号们（即EASCII、扩充ASCII）取消掉，规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字。前面的一个字节（他称之为高字节）从0xA1用到 0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。在这些编码里，还把数学符号、罗马希腊的 字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。</p><p>上述编码规则就是<strong>GB2312</strong>。<strong>GB2312</strong>或<strong>GB2312-80</strong>是<a href="http://zh.wikipedia.org/wiki/%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E5%9B%BD%E5%AE%B6%E6%A0%87%E5%87%86">中国国家标准</a><a href="http://zh.wikipedia.org/wiki/%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87">简体中文</a><a href="http://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E9%9B%86">字符集</a>，全称《<strong>信息交换用汉字编码字符集·基本集</strong>》，又称<a href="http://zh.wikipedia.org/wiki/%E5%9B%BD%E5%AE%B6%E6%A0%87%E5%87%86%E4%BB%A3%E7%A0%81"><strong>GB0</strong></a>，由<a href="http://zh.wikipedia.org/w/index.php?title=%E4%B8%AD%E5%9B%BD%E5%9B%BD%E5%AE%B6%E6%A0%87%E5%87%86%E6%80%BB%E5%B1%80&action=edit&redlink=1">中国国家标准总局</a>发布，<a href="http://zh.wikipedia.org/wiki/1981%E5%B9%B4">1981年</a><a href="http://zh.wikipedia.org/wiki/5%E6%9C%881%E6%97%A5">5月1日</a>实施。GB2312编码通行于中国大陆；<a href="http://zh.wikipedia.org/wiki/%E6%96%B0%E5%8A%A0%E5%9D%A1">新加坡</a>等地也采用此编码。GB2312的出现，基本满足了汉字的计算机处理需要，它所收录的汉字已经覆盖中国大陆99.75%的使用频率。对于<a href="http://zh.wikipedia.org/wiki/%E4%BA%BA%E5%90%8D">人名</a>、<a href="http://zh.wikipedia.org/wiki/%E5%8F%A4%E6%B1%89%E8%AF%AD">古汉语</a>等方面出现的<a href="http://zh.wikipedia.org/wiki/%E7%BD%95%E7%94%A8%E5%AD%97">罕用字</a>，GB2312不能处理，这导致了后来<a href="http://zh.wikipedia.org/wiki/GBK">GBK</a>及<a href="http://zh.wikipedia.org/wiki/GB_18030">GB 18030</a>汉字字符集的出现。</p><p><a href="http://www.knowsky.com/resource/gb2312tbl.htm">GB2312简体中文编码表</a></p><p><a href="http://tools.jb51.net/table/gb2312">GB2312简体中文编码表</a></p><h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p>Unicode编码系统为表达任意语言的任意字符而设计。它使用4字节的数字来表达每个字母、符号，或者表意文字(ideograph)。每个字符对应一个数字，每个数字对应一个字符，即不存在二义性，不再需要记录”模式”了。U+0041总是代表’A’，即使这种语言没有’A’这个字符。</p><p>在计算机科学领域中，<strong>Unicode</strong>（<strong>统一码</strong>、<strong>万国码</strong>、<strong>单一码</strong>、<strong>标准万国码</strong>）是业界的一种标准，它可以使电脑得以体现世界上数十种文字的系统。</p><p>（<strong>可以这样理解：Unicode是字符集，UTF-32&#x2F; UTF-16&#x2F; UTF-8是三种字符编码方案。</strong>）</p><p><a href="https://www.unicode.org/charts/">Unicode码查询</a></p><p><a href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84">Unicode字符平面映射</a></p><h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h3><p>EF BB BF　　　 UTF-8<br>FE FF　　　　　UTF-16&#x2F;UCS-2, little endian<br>FF FE　　　　　UTF-16&#x2F;UCS-2, big endian<br>FF FE 00 00　　UTF-32&#x2F;UCS-4, little endian.<br>00 00 FE FF　　UTF-32&#x2F;UCS-4, big-endian.</p><ul><li><strong>字符集和字符编码</strong></li></ul><p><img src="/2022/438d1de3/v2-aee5ae604328ab912b285d03b6c62273_720w.jpg" alt="img"></p><h3 id="UTF-32"><a href="#UTF-32" class="headerlink" title="UTF-32"></a>UTF-32</h3><p>上述使用4字节的数字来表达每个字母、符号，或者表意文字(ideograph)，每个数字代表唯一的至少在某种语言中使用的符号的编码方案，称为UTF-32。UTF-32又称<strong>UCS-4</strong>是一种将<a href="http://zh.wikipedia.org/wiki/Unicode">Unicode</a>字符编码的协定，对每个字符都使用4字节。就空间而言，是非常没有效率的。</p><p>这种方法有其优点，最重要的一点就是可以在常数时间内定位字符串里的第N个字符，因为第N个字符从第4×Nth个字节开始。虽然每一个码位使用固定长定的字节看似方便，它并不如其它Unicode编码使用得广泛。</p><h3 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h3><p>对于UTF-32和UTF-16编码方式还有一些其他不明显的缺点。不同的计算机系统会以不同的顺序保存字节。这意味着字符U+4E2D在UTF-16编码方式下可能被保存为4E 2D或者2D 4E，这取决于该系统使用的是大尾端(big-endian)还是小尾端(little-endian)。为了解决这个问题，多字节的Unicode编码方式定义了一个”字节顺序标记(Byte Order Mark)”，它是一个特殊的非打印字符，你可以把它包含在文档的开头来指示你所使用的字节顺序。对于UTF-16，字节顺序标记是U+FEFF。如果收到一个以字节FFFE开头的UTF-16编码的文档，你就能确定它的字节顺序是单向的(one way)的了；如果它以FEFF开头，则可以确定字节顺序反向了。</p><p><strong>具体编码方式</strong></p><p>Unicode范围<code>U+10000</code><del><code>U+10FFFF</code>：将Unicode值减去（0x10000），得到20bit长的值。再将Unicode分为高10位和低10位。<a href="https://www.zhihu.com/search?q=UTF-16%E7%BC%96%E7%A0%81&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:106379925%7D">UTF-16编码</a>的高位是2 Byte，高10位Unicode范围为<code>0</code>-<code>0x3FF</code>，将Unicode值加上<code>0XD800</code>，得到高位代理（或称为前导代理，存储高位）；低位也是2 Byte，低十位Unicode范围一样为<code>0</code></del><code>0x3FF</code>，将Unicode值加上<code>0xDC00</code>,得到低位代理（或称为后尾代理，存储低位）</p><p>根据上面的转换方式，我们就能够将Unicode码根据UTF-16的编码方式进行转换。下面我们仍然通过两个例子来看下：</p><ul><li><code>U+0020</code>，这个值的范围在第一部分，即经过UTF-16编码后，结果仍然为<code>U+0020</code>，在内存中的顺序为<code>00 20</code>。</li><li><code>U+12345</code>, 这个值的范围在第二部分，因此需要先减去<code>0x10000</code>，得到<code>0x02345</code>，拆分成高10位<code>00 0000 1000</code>和低10位<code>11 0100 0101</code>。根据上面规则加上特定值后，高位代理值为<code>D808</code>，低位代理值为<code>DF45</code>，最终内存中的顺序为<code>D8 08 DF 45</code>。</li></ul><h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><p><strong>UTF-8</strong>（8-bit Unicode Transformation Format）是一种针对<a href="http://zh.wikipedia.org/wiki/Unicode">Unicode</a>的可变长度<a href="http://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81">字符编码</a>（<a href="http://zh.wikipedia.org/w/index.php?title=%E5%AE%9A%E9%95%BF%E7%A0%81&action=edit&redlink=1">定长码</a>），也是一种<a href="http://zh.wikipedia.org/w/index.php?title=%E5%89%8D%E7%BC%80%E7%A0%81&action=edit&redlink=1">前缀码</a>。它可以用来表示Unicode标准中的任何字符，且其编码中的第一个<a href="http://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82">字节</a>仍与<a href="http://zh.wikipedia.org/wiki/ASCII">ASCII</a>兼容，这使得原来处理ASCII字符的<a href="http://zh.wikipedia.org/wiki/%E8%BB%9F%E9%AB%94">软件</a>无须或只须做少部份修改，即可继续使用。因此，它逐渐成为<a href="http://zh.wikipedia.org/wiki/%E9%9B%BB%E5%AD%90%E9%83%B5%E4%BB%B6">电子邮件</a>、<a href="http://zh.wikipedia.org/wiki/%E7%B6%B2%E9%A0%81">网页</a>及其他<a href="http://zh.wikipedia.org/wiki/%E5%84%B2%E5%AD%98%E8%A3%9D%E7%BD%AE">存储</a>或传送文字的应用中，优先采用的编码。<a href="http://zh.wikipedia.org/wiki/%E7%B6%B2%E9%9A%9B%E7%B6%B2%E8%B7%AF%E5%B7%A5%E7%A8%8B%E5%B7%A5%E4%BD%9C%E5%B0%8F%E7%B5%84">互联网工程工作小组</a>（IETF）要求所有<a href="http://zh.wikipedia.org/wiki/%E7%B6%B2%E9%9A%9B%E7%B6%B2%E8%B7%AF">互联网</a><a href="http://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE">协议</a>都必须支持UTF-8编码。</p><p>UTF-8使用一至四个<a href="http://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82">字节</a>为每个字符编码</p><p><strong>具体编码方式</strong></p><p><img src="/2022/438d1de3/v2-121a14291638f0b28e1dde7c95d2d379_720w.jpg" alt="img"></p><p>根据上表，解读 UTF-8 编码非常简单。如果一个字节的第一位是<code>0</code>，则这个字节单独就是一个字符；如果第一位是<code>1</code>，则连续有多少个<code>1</code>，就表示当前字符占用多少个字节。<br>下面，还是以汉字<code>严</code>为例，演示如何实现 <a href="https://www.zhihu.com/search?q=UTF-8+%E7%BC%96%E7%A0%81&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:790551384%7D">UTF-8 编码</a>。<br><code>严</code>的 Unicode 是<code>4E25</code>（<code>100111000100101</code>），根据上表，可以发现<code>4E25</code>处在第三行的范围内（<code>0000 0800 - 0000 FFFF</code>），因此<code>严</code>的 UTF-8 编码需要三个字节，即格式是<code>1110xxxx 10xxxxxx 10xxxxxx</code>。然后，从<code>严</code>的最右边<a href="https://www.zhihu.com/search?q=%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:790551384%7D">二进制位</a>开始，依次从右往左填入上边格式中的<code>x</code>，多出的位补<code>0</code>。这样就得到了，<code>严</code>的 UTF-8 编码是<code>11100100 10111000 10100101</code>，转换成<a href="https://www.zhihu.com/search?q=%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:790551384%7D">十六进制</a>就是<code>E4 B8 A5</code>。</p><p><strong>优点</strong></p><ul><li>UTF-8是ASCII的一个<a href="http://zh.wikipedia.org/wiki/%E8%B6%85%E9%9B%86">超集</a>。因为一个纯ASCII字符串也是一个合法的UTF-8字符串，所以现存的ASCII文本不需要转换。为传统的扩展ASCII字符集设计的软件通常可以不经修改或很少修改就能与UTF-8一起使用。</li><li>使用标准的面向字节的排序例程对UTF-8排序将产生与*于Unicode代码点排序相同的结果。（尽管这只有有限的有用性，因为在任何特定语言或文化下都不太可能有仍可接受的文字排列顺序。）</li><li>UTF-8和UTF-16都是<a href="http://zh.wikipedia.org/wiki/%E5%8F%AF%E6%89%A9%E5%B1%95%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80">可扩展标记语言</a>文档的标准编码。所有其它编码都必须通过显式或文本声明来指定。</li><li>任何<a href="http://zh.wikipedia.org/w/index.php?title=%E9%9D%A2%E5%90%91%E5%AD%97%E8%8A%82&action=edit&redlink=1">面向字节</a>的<a href="http://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95">字符串搜索算法</a>都可以用于UTF-8的数据（只要输入仅由完整的UTF-8字符组成）。但是，对于包含字符记数的正则表达式或其它结构必须小心。</li><li>UTF-8字符串可以由一个简单的算法可靠地识别出来。就是，一个字符串在任何其它编码中表现为合法的UTF-8的可能性很低，并随字符串长度增长而减小。举例说，字符值C0,C1,F5至FF从来没有出现。为了更好的可靠性，可以使用正则表达式来统计非法过长和替代值（可以查看<a href="http://www.w3.org/International/questions/qa-forms-utf-8">W3 FAQ: Multilingual Forms</a>上的验证UTF-8字符串的正则表达式）。</li></ul><p><strong>缺点</strong></p><p>因为每个字符使用不同数量的字节编码，所以寻找串中第N个字符是一个O(N)复杂度的操作 — 即，串越长，则需要更多的时间来定位特定的字符。同时，还需要位变换来把字符编码成字节，把字节解码成字符。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;字符集和字符编码&quot;&gt;&lt;a href=&quot;#字符集和字符编码&quot; class=&quot;headerlink&quot; title=&quot;字符集和字符编码&quot;&gt;&lt;/a&gt;字符集和字符编码&lt;/h1&gt;&lt;p&gt;&lt;a</summary>
        
      
    
    
    
    <category term="blog" scheme="https://www.oikiou.top/categories/blog/"/>
    
    
    <category term="character encoding" scheme="https://www.oikiou.top/tags/character-encoding/"/>
    
    <category term="gb2312" scheme="https://www.oikiou.top/tags/gb2312/"/>
    
    <category term="utf-8" scheme="https://www.oikiou.top/tags/utf-8/"/>
    
  </entry>
  
  <entry>
    <title>VScode插件CommentTranslate在WSL内无效</title>
    <link href="https://www.oikiou.top/2022/1d3ed0f3/"/>
    <id>https://www.oikiou.top/2022/1d3ed0f3/</id>
    <published>2022-08-10T14:57:15.000Z</published>
    <updated>2022-09-18T14:38:51.341Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VScode插件CommentTranslate在WSL内无效"><a href="#VScode插件CommentTranslate在WSL内无效" class="headerlink" title="VScode插件CommentTranslate在WSL内无效"></a>VScode插件CommentTranslate在WSL内无效</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/intellism/vscode-comment-translate/issues/64">https://github.com/intellism/vscode-comment-translate/issues/64</a></p><ol><li><p>找到相关语言语法规则文件。如C&#x2F;CPP、bat、css、java、python，这些文件都是在Windows版本的VSCode中内置的，文件路径在 <code>C:\Users\ **userNmae** \AppData\Local\Programs\Microsoft VS Code\resources\app\extensions</code>改过安装路径的是<code>Microsoft VS Code\resources\app\extensions</code></p><p><img src="/2022/1d3ed0f3/image-20220811202401467.png" alt="image-20220811202401467"></p></li></ol><p>​</p><ol><li><p>将语法规则的<strong>高亮规则</strong>文件夹拷贝到远程vscode的相关插件目录。以C语言为例，将<code>cpp</code>目录下的高亮规则文件夹<code>syntaxes</code>拷贝到远程C&#x2F;C++插件（<code>ms-vscode.cpptools-x.x.x</code>）目录下。如果你使用SSH远程，远程插件的目录在<code>~/.vscode-server/extensions/ms-vscode.cpptools-x.x.x</code>。</p><p><img src="/2022/1d3ed0f3/image-20220811202845203.png" alt="image-20220811202845203"></p></li><li><p>修改远程插件，添加语法高亮规则。修改远程插件的<code>package.json</code>文件，如C&#x2F;C++插件（<code>ms-vscode.cpptools-x.x.x</code>）目录下的<code>package.json</code>文件，将刚才cpp语法规则文件夹中的<code>package.json</code>文件的”<code>grammars</code>“部分拷贝出来，粘贴到远程插件的<code>package.json</code>的<code>contributes</code>部分中去。</p><p>如果遇到格式难以复制，可以全选内容然后按Shift+Alt+F格式化选定内容。<img src="/2022/1d3ed0f3/image-20220811202944334.png" alt="image-20220811202944334"></p></li></ol><p><img src="/2022/1d3ed0f3/image-20220811203114753.png" alt="image-20220811203114753"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-string">&quot;grammars&quot;</span>: [<br>          &#123;<br>              <span class="hljs-string">&quot;language&quot;</span>: <span class="hljs-string">&quot;c&quot;</span>,<br>              <span class="hljs-string">&quot;scopeName&quot;</span>: <span class="hljs-string">&quot;source.c&quot;</span>,<br>              <span class="hljs-string">&quot;path&quot;</span>: <span class="hljs-string">&quot;./syntaxes/c.tmLanguage.json&quot;</span><br>          &#125;,<br>          &#123;<br>              <span class="hljs-string">&quot;language&quot;</span>: <span class="hljs-string">&quot;cpp&quot;</span>,<br>              <span class="hljs-string">&quot;scopeName&quot;</span>: <span class="hljs-string">&quot;source.cpp.embedded.macro&quot;</span>,<br>              <span class="hljs-string">&quot;path&quot;</span>: <span class="hljs-string">&quot;./syntaxes/cpp.embedded.macro.tmLanguage.json&quot;</span><br>          &#125;,<br>          &#123;<br>              <span class="hljs-string">&quot;language&quot;</span>: <span class="hljs-string">&quot;cpp&quot;</span>,<br>              <span class="hljs-string">&quot;scopeName&quot;</span>: <span class="hljs-string">&quot;source.cpp&quot;</span>,<br>              <span class="hljs-string">&quot;path&quot;</span>: <span class="hljs-string">&quot;./syntaxes/cpp.tmLanguage.json&quot;</span><br>          &#125;,<br>          &#123;<br>              <span class="hljs-string">&quot;scopeName&quot;</span>: <span class="hljs-string">&quot;source.c.platform&quot;</span>,<br>              <span class="hljs-string">&quot;path&quot;</span>: <span class="hljs-string">&quot;./syntaxes/platform.tmLanguage.json&quot;</span><br>          &#125;,<br>          &#123;<br>              <span class="hljs-string">&quot;language&quot;</span>: <span class="hljs-string">&quot;cuda-cpp&quot;</span>,<br>              <span class="hljs-string">&quot;scopeName&quot;</span>: <span class="hljs-string">&quot;source.cuda-cpp&quot;</span>,<br>              <span class="hljs-string">&quot;path&quot;</span>: <span class="hljs-string">&quot;./syntaxes/cuda-cpp.tmLanguage.json&quot;</span><br>          &#125;<br>      ],<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;VScode插件CommentTranslate在WSL内无效&quot;&gt;&lt;a href=&quot;#VScode插件CommentTranslate在WSL内无效&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="tools" scheme="https://www.oikiou.top/categories/tools/"/>
    
    
    <category term="vscode" scheme="https://www.oikiou.top/tags/vscode/"/>
    
    <category term="commenttranslate" scheme="https://www.oikiou.top/tags/commenttranslate/"/>
    
    <category term="wsl" scheme="https://www.oikiou.top/tags/wsl/"/>
    
  </entry>
  
  <entry>
    <title>搭建KMS</title>
    <link href="https://www.oikiou.top/2022/3ef2a47d/"/>
    <id>https://www.oikiou.top/2022/3ef2a47d/</id>
    <published>2022-07-24T14:57:15.000Z</published>
    <updated>2022-09-18T14:53:32.794Z</updated>
    
    <content type="html"><![CDATA[<h1 id="KMS"><a href="#KMS" class="headerlink" title="KMS"></a>KMS</h1><p>KMS（Key Management Service），密钥管理服务</p><p>能够通过KMS进行激活的一般称为VL版,即VOLUME授权版，一般不会单独在零售市场进行发售，一般是直接向企业提供电子ISO映像进行批量授权安装，基于对KMS原理研究成果，我们可以自行搭建KMS激活服务器，实现每180天一次的自动激活，使得系统一直保持激活状态。</p><p>KMS可以激活VOL版本的windows系统和office软件</p><h1 id="Docker-部署KMS服务器"><a href="#Docker-部署KMS服务器" class="headerlink" title="Docker 部署KMS服务器"></a>Docker 部署KMS服务器</h1><p><a href="https://registry.hub.docker.com/r/teddysun/kms">https://registry.hub.docker.com/r/teddysun/kms</a></p><ol><li><p>Pull the image</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull teddysun/kms<br></code></pre></td></tr></table></figure><p>This pulls the latest release of KMS server. It can be found at Docker Hub.</p></li><li><p>Start a container</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d -p 1688:1688 --name kms --restart=always teddysun/kms<br></code></pre></td></tr></table></figure><p>Note: The TCP port number <code>1688</code> must be opened in firewall.</p></li></ol><h1 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h1><h2 id="激活windows"><a href="#激活windows" class="headerlink" title="激活windows"></a>激活windows</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 待激活的主机上指定KMS服务器</span><br>slmgr /skms service_address(你搭建的服务器的地址)<br><br><span class="hljs-comment"># 手动激活</span><br>slmgr /ato<br><br><span class="hljs-comment"># 如果激活失败 尝试更改成GVLK KEY再次激活</span><br><span class="hljs-comment"># 运行以下命令查看系统版本 </span><br>wmic os get caption<br><br><span class="hljs-comment"># 访问下面的网址获取key</span><br><span class="hljs-comment"># https://docs.microsoft.com/zh-cn/windows-server/get-started/kms-client-activation-keys</span><br><span class="hljs-comment"># https://technet.microsoft.com/en-us/library/jj612867.aspx</span><br><span class="hljs-comment"># 得到对应key之后，使用管理员权限运行cmd执行安装key：</span><br>slmgr /ipk xxxxx-xxxxx-xxxxx-xxxxx<br><br><span class="hljs-comment"># 手动激活</span><br>slmgr /ato<br></code></pre></td></tr></table></figure><h2 id="激活office"><a href="#激活office" class="headerlink" title="激活office"></a>激活office</h2><p>首先你的OFFICE必须是VOL版本，否则无法激活。 找到你的office安装目录，比如</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">C:<span class="hljs-string">\Program</span> Files (x86)<span class="hljs-string">\Microsoft</span> Office<span class="hljs-string">\Office16</span><br></code></pre></td></tr></table></figure><p>64位的就是</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">C:<span class="hljs-string">\Program</span> Files<span class="hljs-string">\Microsoft</span> Office<span class="hljs-string">\Office16</span><br></code></pre></td></tr></table></figure><p>office16是office2016，office15就是2013，office14就是2010.</p><p>然后目录对的话，该目录下面应该有个OSPP.VBS。</p><p>直接输入下面的指令去指定KMS服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">cscript <span class="hljs-string">&quot;C:\Program Files (x86)\Microsoft Office\Office16\OSPP.VBS&quot;</span> sethst:service_address(你搭建的服务器的地址)<br><span class="hljs-comment"># or</span><br>cscript <span class="hljs-string">&quot;C:\Program Files\Microsoft Office\Office16\OSPP.VBS&quot;</span> /sethst:service_address(你搭建的服务器的地址)<br></code></pre></td></tr></table></figure><p>一般来说，“一句命令已经完成了”，但一般office不会马上连接kms服务器进行激活，所以我们额外补充一条手动激活命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cscript ospp.vbs /act<br></code></pre></td></tr></table></figure><h1 id="如果遇到报错，请检查："><a href="#如果遇到报错，请检查：" class="headerlink" title="如果遇到报错，请检查："></a>如果遇到报错，请检查：</h1><blockquote><ol><li>你的系统&#x2F;OFFICE是否是批量VL版本</li><li>是否以管理员权限运行CMD</li><li>你的系统&#x2F;OFFICE是否修改过KEY&#x2F;未安装GVLK KEY</li><li>检查你的网络连接</li><li>服务器繁忙，多试试（点击检查KMS服务是否可用）</li><li>根据出错代码自己搜索出错原因</li></ol></blockquote><h2 id="windows没有密钥"><a href="#windows没有密钥" class="headerlink" title="windows没有密钥"></a>windows没有密钥</h2><ul><li>windows VOL KEY</li></ul><p><a href="https://docs.microsoft.com/zh-cn/windows-server/get-started/kmsclientkeys">https://docs.microsoft.com/zh-cn/windows-server/get-started/kmsclientkeys</a></p><h2 id="检查windows版本"><a href="#检查windows版本" class="headerlink" title="检查windows版本"></a>检查windows版本</h2><ul><li>检查office是否是VOL版本</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 命令提示符（管理员）执行：cd “office的安装目录”</span><br><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;C:\Program Files (x86)\Microsoft Office\Office16&quot;</span><br><span class="hljs-comment"># or</span><br><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;C:\Program Files\Microsoft Office\Office16&quot;</span><br><br><span class="hljs-comment"># 执行：</span><br>cscript ospp.vbs /dstatus<br></code></pre></td></tr></table></figure><p>在显示的信息中，如果有“VOLUME”字样就是VOL版，即支持KMS激活</p><h2 id="office-密钥"><a href="#office-密钥" class="headerlink" title="office 密钥"></a>office 密钥</h2><ul><li>卸载office的密钥</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 命令提示符（管理员）执行：cd “office的安装目录”</span><br><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;C:\Program Files (x86)\Microsoft Office\Office16&quot;</span><br><span class="hljs-comment"># or</span><br><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;C:\Program Files\Microsoft Office\Office16&quot;</span><br><br><span class="hljs-comment"># 查看当前状态</span><br>cscript ospp.vbs /dstatus<br><br><span class="hljs-comment"># 找到 Last 5 characters of installed product key:XXXXX 语句</span><br><span class="hljs-comment"># 卸载密钥</span><br>cscript ospp.vbs /unpkey:XXXXX<br></code></pre></td></tr></table></figure><ul><li>查找office的VOL KEY</li></ul><p><a href="https://docs.microsoft.com/zh-cn/DeployOffice/vlactivation/gvlks">https://docs.microsoft.com/zh-cn/DeployOffice/vlactivation/gvlks</a></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;KMS&quot;&gt;&lt;a href=&quot;#KMS&quot; class=&quot;headerlink&quot; title=&quot;KMS&quot;&gt;&lt;/a&gt;KMS&lt;/h1&gt;&lt;p&gt;KMS（Key Management</summary>
        
      
    
    
    
    <category term="blog" scheme="https://www.oikiou.top/categories/blog/"/>
    
    
    <category term="kms" scheme="https://www.oikiou.top/tags/kms/"/>
    
    <category term="office" scheme="https://www.oikiou.top/tags/office/"/>
    
    <category term="volume" scheme="https://www.oikiou.top/tags/volume/"/>
    
  </entry>
  
  <entry>
    <title>SSL证书的申请和自动续期</title>
    <link href="https://www.oikiou.top/2022/82aca4fc/"/>
    <id>https://www.oikiou.top/2022/82aca4fc/</id>
    <published>2022-07-21T14:57:15.000Z</published>
    <updated>2022-09-18T14:38:51.279Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SSL证书的申请和自动续期"><a href="#SSL证书的申请和自动续期" class="headerlink" title="SSL证书的申请和自动续期"></a>SSL证书的申请和自动续期</h1><p>Let’s Encrypt 证书续期</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/a2d0209fa3f5">https://www.jianshu.com/p/a2d0209fa3f5</a></p><p><a href="https://www.cnblogs.com/esofar/p/9291685.html">快速签发 Let’s Encrypt 证书指南</a></p><p><a href="https://certbot.eff.org/">https://certbot.eff.org/</a></p><h1 id="acme-sh-申请"><a href="#acme-sh-申请" class="headerlink" title="acme.sh 申请"></a>acme.sh 申请</h1><p>用 acme.sh申请来自动续期ssl证书<br> acme说明：<a href="https://links.jianshu.com/go?to=https://github.com/Neilpang/acme.sh/wiki/%E8%AF%B4%E6%98%8E">https://github.com/Neilpang/acme.sh/wiki/说明</a></p><ol><li>下载acme<code>curl https://get.acme.sh | sh</code>  安装完成后必须关闭当前终端，重新开启一个以使acme.sh命令生效</li><li>执行生成和自动更新命令：<code>acme.sh --issue -d mydomain.com -d www.mydomain.com --webroot /var/www/mydomain.com/</code></li><li>安装证书 <code>cd /etc/nginx; mkdir ssl</code></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">acme.sh  --installcert  -d  <span class="hljs-tag">&lt;<span class="hljs-name">domain</span>&gt;</span>.com   \<br>        --key-file   /etc/nginx/ssl/<span class="hljs-tag">&lt;<span class="hljs-name">domain</span>&gt;</span>.key \<br>        --fullchain-file /etc/nginx/ssl/fullchain.cer \<br>        --reloadcmd  &quot;service nginx force-reload&quot;<br></code></pre></td></tr></table></figure><ol start="4"><li>配置nginx使用ssl</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash">server &#123;<br>    listen 80 default_server;<br>    listen 443 http2 ssl;<br>    listen [::]:80 default_server;<br><br>    ssl_certificate /etc/nginx/ssl/fullchain.cer;<br>    ssl_certificate_key /etc/nginx/ssl/domain.key;<br>    <span class="hljs-comment">#http转https</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable">$scheme</span> = http ) &#123;<span class="hljs-built_in">return</span> 301 https://$host<span class="hljs-variable">$request_uri</span>;&#125;<br>    root /var/www/html;<br><br>    index index.html index.htm index.nginx-debian.html;<br>    server_name _;<br><br>    ssl_certificate /etc/nginx/ssl/fullchain.cer;<br>    ssl_certificate_key /etc/nginx/ssl/domain.key;<br><br>    location /test &#123;<br>          proxy_pass       http://127.0.0.1:3000;<br>          proxy_http_version 1.1;<br>          proxy_set_header Upgrade <span class="hljs-variable">$http_upgrade</span>;<br>          proxy_set_header Connection <span class="hljs-string">&quot;upgrade&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>前端的Upgrade请求发送给后端服务器，Upgrade和Connection的头信息必须被显式的设置。一旦我们完成以上设置，NGINX就可以处理WebSocket连接了。查看配置在哪里<code>ps -ef|grep nginx</code><br> 多个域名的话，配多个nginx.conf配置。</p><ol start="5"><li>查看是否有每日任务<br> <code>crontab -l #查看你的任务</code><br> 手动更新证书<code>acme.sh --renew -d domain.com</code></li></ol><h1 id="certbot"><a href="#certbot" class="headerlink" title="certbot"></a>certbot</h1><p><a href="https://certbot.eff.org/">文档</a></p><p>Ubuntu + nginx <a href="https://certbot.eff.org/instructions?ws=nginx&amp;os=ubuntufocal">https://certbot.eff.org/instructions?ws=nginx&amp;os=ubuntufocal</a></p><p>用certbot来自动续期ssl证书</p><ul><li>需要注意的是安装证书的时候最好把nginx关掉先</li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;SSL证书的申请和自动续期&quot;&gt;&lt;a href=&quot;#SSL证书的申请和自动续期&quot; class=&quot;headerlink&quot; title=&quot;SSL证书的申请和自动续期&quot;&gt;&lt;/a&gt;SSL证书的申请和自动续期&lt;/h1&gt;&lt;p&gt;Let’s</summary>
        
      
    
    
    
    <category term="blog" scheme="https://www.oikiou.top/categories/blog/"/>
    
    
    <category term="ssl" scheme="https://www.oikiou.top/tags/ssl/"/>
    
    <category term="https" scheme="https://www.oikiou.top/tags/https/"/>
    
  </entry>
  
  <entry>
    <title>Nintendo Switch</title>
    <link href="https://www.oikiou.top/2022/f15ac6f4/"/>
    <id>https://www.oikiou.top/2022/f15ac6f4/</id>
    <published>2022-07-21T14:57:15.000Z</published>
    <updated>2022-11-14T14:01:13.127Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TX-转-大气层"><a href="#TX-转-大气层" class="headerlink" title="TX 转 大气层"></a>TX 转 大气层</h1><p><a href="https://www.bilibili.com/video/BV1DZ4y1B777/?spm_id_from=333.788">https://www.bilibili.com/video/BV1DZ4y1B777/?spm_id_from=333.788</a></p><h1 id="SD卡内文件结构"><a href="#SD卡内文件结构" class="headerlink" title="SD卡内文件结构"></a>SD卡内文件结构</h1><p><img src="/2022/f15ac6f4/image-20221103090149675.png" alt="image-20221103090149675"></p><ul><li><ul><li></li></ul></li></ul><h1 id="OS相关"><a href="#OS相关" class="headerlink" title="OS相关"></a>OS相关</h1><h2 id="三种不同的OS"><a href="#三种不同的OS" class="headerlink" title="三种不同的OS"></a>三种不同的OS</h2><p><img src="/2022/f15ac6f4/image-20221103092334424.png" alt="image-20221103092334424"></p><ul><li>大气层-真实系统<ul><li>使用的是机身的正版系统, 插件是使用的是大气层的插件</li></ul></li><li>大气层-虚拟系统<ul><li>使用的是SD卡内全虚拟的系统</li></ul></li></ul><h2 id="查看当前OS版本和环境"><a href="#查看当前OS版本和环境" class="headerlink" title="查看当前OS版本和环境"></a>查看当前OS版本和环境</h2><p><img src="/2022/f15ac6f4/image-20221103090700699.png" alt="image-20221103090700699"></p><h2 id="系统升级"><a href="#系统升级" class="headerlink" title="系统升级"></a>系统升级</h2><p><img src="/2022/f15ac6f4/image-20221103090149675.png" alt="image-20221103090149675"></p><ul><li>系统升级相关<ul><li>一般来说<code>Nintendo</code>和<code>emuMMC</code>是需要保留的文件, 其他文件是大气层系统相关的文件</li><li>小版本升级可以直接在相册内用<code>daybreak</code>升级<code>14.1.1-&gt;14.1.2</code>, 大版本升级<code>14.1.2-&gt;15.0.0</code>因为可能需要升级大气层系统(atmosphere)所以需要把SD卡拆下来, 删掉除了<code>Nintendo</code>和<code>emuMMC</code>之外的全部文件, 然后找升级包去覆盖掉.</li></ul></li></ul><h2 id="资源及参考链接"><a href="#资源及参考链接" class="headerlink" title="资源及参考链接"></a>资源及参考链接</h2><p><a href="https://darthsternie.net/switch-firmwares/">Switch 离线升级固件(分为 大陆版 和 全球版)</a></p><p><a href="https://shipengliang.com/games/switch-%E5%A4%A7%E6%B0%94%E5%B1%82-atmosphere-%E5%A6%82%E4%BD%95%E7%A6%BB%E7%BA%BF%E5%8D%87%E7%BA%A7%E7%B3%BB%E7%BB%9F.html">Switch 大气层 Atmosphere 如何离线升降级系统</a></p><p><a href="https://shipengliang.com/games/switch-firmware-%e5%9b%ba%e4%bb%b6%e4%b8%8b%e8%bd%bd.html">Switch Firmware固件最新版、NS 历史版本下载列表：</a></p><h1 id="安装游戏"><a href="#安装游戏" class="headerlink" title="安装游戏"></a>安装游戏</h1><ul><li>需要准备的工具<ul><li>游戏资源</li><li>NS-Usbloader PC端程序</li><li>Awoo NS端</li><li>USB-C 线缆</li></ul></li></ul><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><ul><li>优先点击广告, 请勿白嫖, 为众人抱薪者，不可使其冻毙于风雪</li></ul><p><a href="https://xxxxx520.com/27637.html">https://xxxxx520.com/27637.html</a></p><p><a href="https://xxxxx520.net/3892.html">https://xxxxx520.net/3892.html</a></p><h2 id="NS-Usbloader-PC端"><a href="#NS-Usbloader-PC端" class="headerlink" title="NS-Usbloader PC端"></a>NS-Usbloader PC端</h2><ul><li>通过USB安装游戏, 以及电脑端开机注入都可用</li><li>这个需要java环境, 安装JRE(Java Runtime Environment)即可.</li></ul><p><a href="https://github.com/developersu/ns-usbloader/">https://github.com/developersu/ns-usbloader/</a></p><h2 id="Awoo-NS端"><a href="#Awoo-NS端" class="headerlink" title="Awoo NS端"></a>Awoo NS端</h2><ul><li>NS端安装游戏</li></ul><p><a href="https://github.com/Huntereb/Awoo-Installer">https://github.com/Huntereb/Awoo-Installer</a></p><h1 id="特斯拉插件-Tesla-Menu-类似快捷菜单"><a href="#特斯拉插件-Tesla-Menu-类似快捷菜单" class="headerlink" title="特斯拉插件(Tesla-Menu) 类似快捷菜单"></a>特斯拉插件(Tesla-Menu) 类似快捷菜单</h1><blockquote><p>  <strong>Switch特斯拉插件</strong>(Tesla-Menu)是一个很实用的功能插件的集合。可以直接在switch系统的任何界面通过组合按键调取左屏幕弹窗打开各种功能的快捷开关！目前已经实现的，开关switch硬件信息显示，开关FPS显示，<strong>开关超频</strong>，切换TV模式，这个平台就好比是简洁版相册，相册里面的各种软件就是完整版，这个Tesla-Menu平台提供的功能就相当于缩减版！不用复杂的操作，只是简单的开关，好处就是精简不占用太多资源！不用来返相册去开关软件！</p></blockquote><p>调出菜单: <code>L + ↓</code></p><p>FPS界面调出: 同时按下 <code>左右摇杆</code></p><h1 id="金手指-作弊器"><a href="#金手指-作弊器" class="headerlink" title="金手指(作弊器)"></a>金手指(作弊器)</h1><p>进入NS的相册, 将NS作为U盘挂载到电脑, <code>DBI -&gt; Run MTP responder</code>, 找到这个目录<code>此电脑\Switch\1: External SD Card\atmosphere\contents</code>这个目录就是NS的金手指存放位置.</p><p>目录下64位16进制的文件夹名, 这个序号就代表着不同的游戏.</p><p>我们找到对应游戏, 打开文件夹后, 里面会有一个<code>cheats</code>的文件夹, 我们打开它, 里面有一个<code>*.txt</code>文件, 这个文件应该记录的就是内存地址, 我们去网络上找到别人保存好的内存地址信息(<code>cheats</code>文件), 放到这个<code>atmosphere\contents</code>目录下, 在NS端就能看到对应的金手指修改选项了, 注意可能需要关掉游戏重新开一下.</p><h2 id="64位游戏ID-对应-游戏名查询"><a href="#64位游戏ID-对应-游戏名查询" class="headerlink" title="64位游戏ID 对应 游戏名查询"></a>64位游戏ID 对应 游戏名查询</h2><p>调出特斯拉界面选择金手指, 即可查到游戏ID</p><p><a href="https://github.com/ibnux/switch-cheat/blob/master/GAMES.md">https://github.com/ibnux/switch-cheat/blob/master/GAMES.md</a></p><p><a href="https://switchbrew.org/w/index.php?title=Title_list/Games">https://switchbrew.org/w/index.php?title=Title_list/Games</a></p><h2 id="cheats-金手指"><a href="#cheats-金手指" class="headerlink" title="cheats 金手指"></a>cheats 金手指</h2><p><a href="https://github.com/ibnux/switch-cheat">https://github.com/ibnux/switch-cheat</a></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;TX-转-大气层&quot;&gt;&lt;a href=&quot;#TX-转-大气层&quot; class=&quot;headerlink&quot; title=&quot;TX 转 大气层&quot;&gt;&lt;/a&gt;TX 转 大气层&lt;/h1&gt;&lt;p&gt;&lt;a</summary>
        
      
    
    
    
    <category term="more_interest" scheme="https://www.oikiou.top/categories/more-interest/"/>
    
    
    <category term="switch" scheme="https://www.oikiou.top/tags/switch/"/>
    
    <category term="nintendo" scheme="https://www.oikiou.top/tags/nintendo/"/>
    
    <category term="game" scheme="https://www.oikiou.top/tags/game/"/>
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="https://www.oikiou.top/2022/f5f9fa9b/"/>
    <id>https://www.oikiou.top/2022/f5f9fa9b/</id>
    <published>2022-07-21T13:38:15.000Z</published>
    <updated>2022-11-14T14:01:13.134Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h1 id="Docker是什么-amp-如何理解Docker"><a href="#Docker是什么-amp-如何理解Docker" class="headerlink" title="Docker是什么&amp;如何理解Docker"></a>Docker是什么&amp;如何理解Docker</h1><p>Docker的底层原理</p><p>cgroup</p><p>namespace</p><p>容器(container)有不同的状态, 停止状态</p><p>镜像(image)是docker生命周期中的构建或打包阶段, 而容器(container)则是启动或执行阶段.</p><p>docker hub</p><p>!!ADD ME!!</p><p><img src="/2022/undefined/architecture.svg" alt="Docker Architecture Diagram"></p><p><img src="/2022/undefined/mark4536000.image" alt="img"></p><p><img src="/2022/undefined/watermark16682557597978.png" alt="x"></p><p><img src="/2022/undefined/watermark.png" alt="xx"></p><p><img src="/2022/undefined/202111041612065293278565.png" alt="何種應用適合PaaS平台容器/微服務架構釋疑| 網管人"></p><h2 id="Docker-和-VM-的区别"><a href="#Docker-和-VM-的区别" class="headerlink" title="Docker 和 VM 的区别"></a>Docker 和 VM 的区别</h2><p>二者的不同：</p><ul><li>VM(VMware)在宿主机器、宿主机器操作系统的基础上创建虚拟层、虚拟化的操作系统、虚拟化的仓库，然后再安装应用；</li><li>Container(Docker容器)，在宿主机器、宿主机器操作系统上创建Docker引擎，在引擎的基础上再安装应用。</li></ul><p><img src="/2022/undefined/9114e4a753de14a7531e867b908e6660.png" alt="img"></p><p><strong>与传统VM特性对比：</strong><br>作为一种轻量级的虚拟化方式，Docker在运行应用上跟传统的虚拟机方式相比具有显著优势：</p><ul><li>Docker 容器很快，启动和停止可以在秒级实现，这相比传统的虚拟机方式要快得多。</li><li>Docker 容器对系统资源需求很少，一台主机上可以同时运行数千个Docker容器。</li><li>Docker 通过类似Git的操作来方便用户获取、分发和更新应用镜像，指令简明，学习成本较低。</li><li>Docker 通过Dockerfile配置文件来支持灵活的自动化创建和部署机制，提高工作效率。</li><li>Docker 容器除了运行其中的应用之外，基本不消耗额外的系统资源，保证应用性能的同时，尽量减小系统开销。</li><li>Docker 利用Linux系统上的多种防护机制实现了严格可靠的隔离。从1.3版本开始，Docker引入了安全选项和镜像签名机制，极大地提高了使用Docker的安全性。</li></ul><table><thead><tr><th>特性</th><th>Docker</th><th>VM</th></tr></thead><tbody><tr><td>启动速度</td><td>秒级</td><td>分钟级</td></tr><tr><td>硬盘使用</td><td>一般为MB</td><td>一般为GB</td></tr><tr><td>性能</td><td>接近原生</td><td>弱于原生</td></tr><tr><td>系统支持量</td><td>单机支持上千个容器</td><td>一般几十个</td></tr></tbody></table><h1 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h1><p>参考官方的安装<a href="https://docs.docker.com/get-docker/">文档</a></p><p>Ubuntu的安装参考<a href="https://docs.docker.com/desktop/install/ubuntu/">文档</a></p><h1 id="Docker入门-amp-命令"><a href="#Docker入门-amp-命令" class="headerlink" title="Docker入门&amp;命令"></a>Docker入门&amp;命令</h1><h2 id="☆-docker-run"><a href="#☆-docker-run" class="headerlink" title="☆ docker run"></a>☆ docker run</h2><p><strong>docker run ：</strong>创建一个新的容器并运行一个命令</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><strong>-a stdin:</strong> 指定标准输入输出内容类型，可选 STDIN&#x2F;STDOUT&#x2F;STDERR 三项；</li><li><strong>-d:</strong> 后台运行容器，并返回容器ID；</li><li>☆**-i:** 以交互模式运行容器，通常与 -t 同时使用；</li><li><strong>-P:</strong> 随机端口映射，容器内部端口<strong>随机</strong>映射到主机的端口</li><li><strong>-p:</strong> 指定端口映射，格式为：<strong>主机(宿主)端口:容器端口</strong></li><li>☆**-t:** 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</li><li>☆**–name&#x3D;”nginx-lb”:** 为容器指定一个名称；</li><li><strong>–dns 8.8.8.8:</strong> 指定容器使用的DNS服务器，默认和宿主一致；</li><li><strong>–dns-search example.com:</strong> 指定容器DNS搜索域名，默认和宿主一致；</li><li><strong>-h “mars”:</strong> 指定容器的hostname；</li><li>☆**-e username&#x3D;”ritchie”:** 设置环境变量；</li><li><strong>–env-file&#x3D;[]:</strong> 从指定文件读入环境变量；</li><li><strong>–cpuset&#x3D;”0-2” or –cpuset&#x3D;”0,1,2”:</strong> 绑定容器到指定CPU运行；</li><li>**-m :**设置容器使用内存最大值；</li><li><strong>–net&#x3D;”bridge”:</strong> 指定容器的网络连接类型，支持 bridge&#x2F;host&#x2F;none&#x2F;container: 四种类型；</li><li><strong>–link&#x3D;[]:</strong> 添加链接到另一个容器；</li><li><strong>–expose&#x3D;[]:</strong> 开放一个端口或一组端口；</li><li>☆**–volume , -v:** 绑定一个卷, (或者称作<strong>映射文件夹</strong>，将特定文件夹映射到特定目录)</li></ul><h3 id="设置工作目录-w"><a href="#设置工作目录-w" class="headerlink" title="设置工作目录 (-w)"></a>设置工作目录 (-w)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker  run -w /path/to/dir/ -i -t  ubuntu <span class="hljs-built_in">pwd</span><br>/path/to/dir<br></code></pre></td></tr></table></figure><p><code>-w</code> 允许命令在给定的目录中执行，这里是 <code>/path/to/dir/</code>。 如果路径不存在，则在容器内创建。</p><h3 id="挂载卷-v-–read-only"><a href="#挂载卷-v-–read-only" class="headerlink" title="挂载卷 (-v, –read-only)"></a>挂载卷 (-v, –read-only)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker  run  -v `<span class="hljs-built_in">pwd</span>`:`<span class="hljs-built_in">pwd</span>` -w `<span class="hljs-built_in">pwd</span>` -i -t  ubuntu <span class="hljs-built_in">pwd</span><br><br><span class="hljs-comment"># 只读(ro)和读写(rw)权限</span><br>docker run -v <span class="hljs-variable">$PWD</span>/web:var/www/html/web:ro<br></code></pre></td></tr></table></figure><p><code>-v</code>标志将当前工作目录挂载到容器中。 <code>-w</code> 让命令在当前工作目录中执行，方法是将工作目录更改为pwd返回的值。所以这个组合使用容器执行命令，但在当前工作目录中。</p><h3 id="发布或者暴露端口-p-–expose"><a href="#发布或者暴露端口-p-–expose" class="headerlink" title="发布或者暴露端口 (-p, –expose)"></a>发布或者暴露端口 (-p, –expose)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -p 127.0.0.1:80:8080/tcp ubuntu bash<br></code></pre></td></tr></table></figure><p>这将容器的端口8080绑定到主机的127.0.0.1上的TCP端口80。还可以指定udp和sctp端口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run --expose 80 ubuntu bash<br></code></pre></td></tr></table></figure><p>这会暴露容器的端口80，而不会将端口发布到主机系统接口。</p><h3 id="设置环境变量-e-–env-–env-file"><a href="#设置环境变量-e-–env-–env-file" class="headerlink" title="设置环境变量(-e, –env, –env-file)"></a>设置环境变量(-e, –env, –env-file)</h3><p>可以通过<code>-e, --env, --env-file</code> 设置容器的环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -e MYVAR1 --<span class="hljs-built_in">env</span> MYVAR2=foo --env-file ./env.list ubuntu bash<br></code></pre></td></tr></table></figure><p>本地已经export的环境变量，可以不用&#x3D;号和值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> VAR1=value1<br><span class="hljs-built_in">export</span> VAR2=value2<br><br>$ docker run --<span class="hljs-built_in">env</span> VAR1 --<span class="hljs-built_in">env</span> VAR2 ubuntu <span class="hljs-built_in">env</span> | grep VAR<br>VAR1=value1<br>VAR2=value2<br></code></pre></td></tr></table></figure><h3 id="在容器上设置元数据-l-–label-–label-file"><a href="#在容器上设置元数据-l-–label-–label-file" class="headerlink" title="在容器上设置元数据(-l, –label, –label-file)"></a>在容器上设置元数据(-l, –label, –label-file)</h3><p>可以通过<code>-l, --label, --label-file</code> 设置容器的label：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -l my-label --label com.example.foo=bar ubuntu bash<br></code></pre></td></tr></table></figure><h3 id="将容器连接到网络-–network"><a href="#将容器连接到网络-–network" class="headerlink" title="将容器连接到网络(–network)"></a>将容器连接到网络(–network)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -itd --network=my-net busybox<br>docker run -itd --network=my-net --ip=10.10.9.75 busybox<br></code></pre></td></tr></table></figure><p>也可以使用 <code>docker connect</code> 命令</p><h3 id="从容器挂载卷-–volumes-from"><a href="#从容器挂载卷-–volumes-from" class="headerlink" title="从容器挂载卷(–volumes-from)"></a>从容器挂载卷(–volumes-from)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run --volumes-from 777f7dc92da7 --volumes-from ba8c0c54f0f2:ro -i -t ubuntu <span class="hljs-built_in">pwd</span><br></code></pre></td></tr></table></figure><h2 id="☆-docker-start-x2F-stop-x2F-restart"><a href="#☆-docker-start-x2F-stop-x2F-restart" class="headerlink" title="☆ docker start&#x2F;stop&#x2F;restart"></a>☆ docker start&#x2F;stop&#x2F;restart</h2><p><strong>docker start</strong> :启动一个或多个已经被停止的容器</p><p><strong>docker stop</strong> :停止一个运行中的容器</p><p><strong>docker restart</strong> :重启容器</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker start [OPTIONS] CONTAINER [CONTAINER...]<br>docker stop [OPTIONS] CONTAINER [CONTAINER...]<br>docker restart [OPTIONS] CONTAINER [CONTAINER...]<br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><p>启动已被停止的容器myrunoob</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker start myrunoob<br></code></pre></td></tr></table></figure><p>停止运行中的容器myrunoob</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker stop myrunoob<br></code></pre></td></tr></table></figure><p>重启容器myrunoob</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker restart myrunoob<br></code></pre></td></tr></table></figure><h2 id="docker-kill"><a href="#docker-kill" class="headerlink" title="docker kill"></a>docker kill</h2><p><strong>docker kill</strong> :杀掉一个运行中的容器。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker kill [OPTIONS] CONTAINER [CONTAINER...]<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li>**-s :**向容器发送一个信号</li></ul><p><strong>实例</strong></p><p>杀掉运行中的容器“docker_ubuntu”</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">kill</span> -s KILL docker_ubuntu</span><br>docker_ubuntu<br></code></pre></td></tr></table></figure><h2 id="☆-docker-rm"><a href="#☆-docker-rm" class="headerlink" title="☆ docker rm"></a>☆ docker rm</h2><p><strong>docker rm ：</strong>删除一个或多个容器。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rm [OPTIONS] CONTAINER [CONTAINER...]<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li>**-f :**通过 SIGKILL 信号强制删除一个运行中的容器。</li><li>**-l :**移除容器间的网络连接，而非容器本身。</li><li>**-v :**删除与容器关联的卷。</li></ul><p><strong>实例</strong></p><p>强制删除容器 db01、db02：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rm -f db01 db02<br></code></pre></td></tr></table></figure><p>移除容器 nginx01 对容器 db01 的连接，连接名 db：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rm -l db <br></code></pre></td></tr></table></figure><p>删除容器 nginx01, 并删除容器挂载的数据卷：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rm -v nginx01<br></code></pre></td></tr></table></figure><p>删除所有已经停止的容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rm $(docker ps -a -q)<br></code></pre></td></tr></table></figure><h2 id="docker-pause-x2F-unpause"><a href="#docker-pause-x2F-unpause" class="headerlink" title="docker pause&#x2F;unpause"></a>docker pause&#x2F;unpause</h2><p><strong>docker pause</strong> :暂停容器中所有的进程。</p><p><strong>docker unpause</strong> :恢复容器中所有的进程。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pause CONTAINER [CONTAINER...]<br>docker unpause CONTAINER [CONTAINER...]<br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><p>暂停数据库容器db01提供服务。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pause db01<br></code></pre></td></tr></table></figure><p>恢复数据库容器 db01 提供服务。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker unpause db01<br></code></pre></td></tr></table></figure><h2 id="docker-create"><a href="#docker-create" class="headerlink" title="docker create"></a>docker create</h2><p><strong>docker create ：</strong>创建一个新的容器但不启动它</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker create [OPTIONS] IMAGE [COMMAND] [ARG...]<br></code></pre></td></tr></table></figure><p>语法同 <code>docker run</code></p><p><strong>实例</strong></p><p>使用docker镜像nginx:latest创建一个容器,并将容器命名为myrunoob</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker create  --name myrunoob  nginx:latest      <br>09b93464c2f75b7b69f83d56a9cfc23ceb50a48a9db7652ee4c27e3e2cb1961f<br></code></pre></td></tr></table></figure><h2 id="☆-docker-exec"><a href="#☆-docker-exec" class="headerlink" title="☆ docker exec"></a>☆ docker exec</h2><p><strong>docker exec ：</strong>在运行的容器中执行命令</p><ul><li>典型的使用, 在docker中运行<code>bash</code>, 所使用的命令就是<code>docker exec -ti my_container /bin/bash</code></li></ul><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec [OPTIONS] CONTAINER COMMAND [ARG...]<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li>**-d :**分离模式: 在后台运行</li><li>**-i :**即使没有附加也保持STDIN 打开</li><li>**-t :**分配一个伪终端</li></ul><p><strong>实例</strong></p><p>在容器 mynginx 中以交互模式执行容器内 &#x2F;root&#x2F;runoob.sh 脚本:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker exec -it mynginx /bin/sh /root/runoob.sh<br>http://www.runoob.com/<br></code></pre></td></tr></table></figure><p>在容器 mynginx 中开启一个交互模式的终端:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker exec -i -t  mynginx /bin/bash<br>root@b1a0703e41e7:/#<br></code></pre></td></tr></table></figure><p>也可以通过 <strong>docker ps -a</strong> 命令查看已经在运行的容器，然后使用容器 ID 进入容器。</p><p>查看已经在运行的容器 ID：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">docker ps -a</span> <br>...<br>9df70f9a0714        openjdk             &quot;/usercode/script.sh…&quot; <br>...<br></code></pre></td></tr></table></figure><p>第一列的 9df70f9a0714 就是容器 ID。</p><p>通过 exec 命令对指定的容器执行 bash:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">docker <span class="hljs-built_in">exec</span> -it 9df70f9a0714 /bin/bash</span><br></code></pre></td></tr></table></figure><h2 id="↓-容器管理-container-↓"><a href="#↓-容器管理-container-↓" class="headerlink" title="↓ 容器管理 container ↓"></a>↓ 容器管理 container ↓</h2><h2 id="☆-docker-ps"><a href="#☆-docker-ps" class="headerlink" title="☆ docker ps"></a>☆ docker ps</h2><p><strong>docker ps :</strong> 列出容器</p><ul><li>典型使用方法, 列出所有的容器(container), <code>docker ps -a</code></li></ul><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker ps [OPTIONS]<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li>**-a :**显示所有的容器，包括未运行的。</li><li>**-f :**根据条件过滤显示的内容。</li><li>**–format :**指定返回值的模板文件。</li><li>**-l :**显示最近创建的容器。</li><li>**-n :**列出最近创建的n个容器。</li><li>**–no-trunc :**不截断输出。</li><li>**-q :**静默模式，只显示容器编号。</li><li>**-s :**显示总的文件大小。</li></ul><p><strong>实例</strong></p><p>列出所有在运行的容器信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker ps<br>CONTAINER ID   IMAGE          COMMAND                ...  PORTS                    NAMES<br>09b93464c2f7   nginx:latest   &quot;nginx -g &#x27;daemon off&quot; ...  80/tcp, 443/tcp          myrunoob<br>96f7f14e99ab   mysql:5.6      &quot;docker-entrypoint.sh&quot; ...  0.0.0.0:3306-&gt;3306/tcp   mymysql<br></code></pre></td></tr></table></figure><p>输出详情介绍：</p><p><strong>CONTAINER ID:</strong> 容器 ID。</p><p><strong>IMAGE:</strong> 使用的镜像。</p><p><strong>COMMAND:</strong> 启动容器时运行的命令。</p><p><strong>CREATED:</strong> 容器的创建时间。</p><p><strong>STATUS:</strong> 容器状态。</p><p>状态有7种：</p><ul><li>created（已创建）</li><li>restarting（重启中）</li><li>running（运行中）</li><li>removing（迁移中）</li><li>paused（暂停）</li><li>exited（停止）</li><li>dead（死亡）</li></ul><p><strong>PORTS:</strong> 容器的端口信息和使用的连接类型（tcp\udp）。</p><p><strong>NAMES:</strong> 自动分配的容器名称。</p><p>列出最近创建的5个容器信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker ps -n 5<br>CONTAINER ID        IMAGE               COMMAND                   CREATED           <br>09b93464c2f7        nginx:latest        &quot;nginx -g &#x27;daemon off&quot;    2 days ago   ...     <br>b8573233d675        nginx:latest        &quot;/bin/bash&quot;               2 days ago   ...     <br>b1a0703e41e7        nginx:latest        &quot;nginx -g &#x27;daemon off&quot;    2 days ago   ...    <br>f46fb1dec520        5c6e1090e771        &quot;/bin/sh -c &#x27;set -x \t&quot;   2 days ago   ...   <br>a63b4a5597de        860c279d2fec        &quot;bash&quot;                    2 days ago   ...<br></code></pre></td></tr></table></figure><p>列出所有创建的容器ID。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker ps -a -q<br>09b93464c2f7<br>b8573233d675<br>b1a0703e41e7<br>f46fb1dec520<br>a63b4a5597de<br>6a4aa42e947b<br>de7bb36e7968<br>43a432b73776<br>664a8ab1a585<br>ba52eb632bbd<br>...<br></code></pre></td></tr></table></figure><h2 id="docker-inspect-获取容器信息"><a href="#docker-inspect-获取容器信息" class="headerlink" title="docker inspect 获取容器信息"></a>docker inspect 获取容器信息</h2><p><strong>docker inspect :</strong> 获取容器&#x2F;镜像的元数据。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker inspect [OPTIONS] NAME|ID [NAME|ID...]<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li>**-f :**指定返回值的模板文件。</li><li>**-s :**显示总的文件大小。</li><li>**–type :**为指定类型返回JSON。</li></ul><p><strong>实例</strong></p><p>获取镜像mysql:5.6的元信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker inspect mysql:5.6<br>[<br>    &#123;<br>        &quot;Id&quot;: &quot;sha256:2c0964ec182ae9a045f866bbc2553087f6e42bfc16074a74fb820af235f070ec&quot;,<br>        &quot;RepoTags&quot;: [<br>            &quot;mysql:5.6&quot;<br>        ],<br>        &quot;RepoDigests&quot;: [],<br>        &quot;Parent&quot;: &quot;&quot;,<br>        &quot;Comment&quot;: &quot;&quot;,<br>        &quot;Created&quot;: &quot;2016-05-24T04:01:41.168371815Z&quot;,<br>        &quot;Container&quot;: &quot;e0924bc460ff97787f34610115e9363e6363b30b8efa406e28eb495ab199ca54&quot;,<br>        &quot;ContainerConfig&quot;: &#123;<br>            &quot;Hostname&quot;: &quot;b0cf605c7757&quot;,<br>            &quot;Domainname&quot;: &quot;&quot;,<br>            &quot;User&quot;: &quot;&quot;,<br>            &quot;AttachStdin&quot;: false,<br>            &quot;AttachStdout&quot;: false,<br>            &quot;AttachStderr&quot;: false,<br>            &quot;ExposedPorts&quot;: &#123;<br>                &quot;3306/tcp&quot;: &#123;&#125;<br>            &#125;,<br>...<br></code></pre></td></tr></table></figure><p>获取正在运行的容器mymysql的 IP。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker inspect --format=&#x27;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27; mymysql<br>172.17.0.3<br></code></pre></td></tr></table></figure><h2 id="☆-docker-top-查看容器内进程信息"><a href="#☆-docker-top-查看容器内进程信息" class="headerlink" title="☆ docker top 查看容器内进程信息"></a>☆ docker top 查看容器内进程信息</h2><p>**docker top :**查看容器中运行的进程信息，支持 ps 命令参数。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker top [OPTIONS] CONTAINER [ps OPTIONS]<br></code></pre></td></tr></table></figure><p>容器运行时不一定有&#x2F;bin&#x2F;bash终端来交互执行top命令，而且容器还不一定有top命令，可以使用docker top来实现查看container中正在运行的进程。</p><p><strong>实例</strong></p><p>查看容器mymysql的进程信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~/mysql$ docker top mymysql<br>UID    PID    PPID    C      STIME   TTY  TIME       CMD<br>999    40347  40331   18     00:58   ?    00:00:02   mysqld<br></code></pre></td></tr></table></figure><p>查看所有运行容器的进程信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span>  `docker ps |grep Up|awk <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span>`;<span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span> \ &amp;&amp;docker top <span class="hljs-variable">$i</span>; <span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><h2 id="docker-attach-附着容器"><a href="#docker-attach-附着容器" class="headerlink" title="docker attach 附着容器"></a>docker attach 附着容器</h2><p>**docker attach :**附着到正在运行中的容器。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker attach [OPTIONS] CONTAINER<br></code></pre></td></tr></table></figure><p><code>--no-stdin=false</code> 不连接标准输入</p><p><code>--sig-proxy=true</code> 将所有信号传递给进程（非TTY模式时也一样）但不传送SIGCHLD、SIGKILL、SIGSTOP信号。经常使用的信号如下：</p><h4 id="detach"><a href="#detach" class="headerlink" title="detach"></a><strong>detach</strong></h4><p>要在不退出 shell 的情况下分离 tty，请使用转义序列<code>Ctrl+P</code>后跟<code>Ctrl+ Q</code>。更多细节<a href="https://docs.docker.com/engine/reference/commandline/attach/">在这里</a>。</p><ul><li>docker run -t -i → 可以<code>^P^Q</code>使用 docker attach 分离和重新附加</li><li>docker run -i → 不能用<code>^P^Q</code>;分离 会破坏标准输入</li><li>docker run → 不能用<code>^P^Q</code>;分离 可以 SIGKILL 客户端；可以使用 docker attach 重新附加</li><li><code>docker attach --sig-proxy=false</code> 可以使用 <code>^C</code>来进行detach, <code>CTRL+c</code></li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a><strong>注意</strong></h3><p>要attach上去的容器必须正在运行，可以同时连接上同一个container来共享屏幕（与screen命令的attach类似）。</p><blockquote><p>  官方文档中说attach后可以通过CTRL-C来detach，但实际上经过我的测试，如果container当前在运行bash，CTRL-C自然是当前行的输入，没有退出；如果container当前正在前台运行进程，如输出nginx的access.log日志，CTRL-C不仅会导致退出容器，而且还stop了。这不是我们想要的，detach的意思按理应该是脱离容器终端，但容器依然运行。好在attach是可以带上–sig-proxy&#x3D;false来确保CTRL-D或CTRL-C不会关闭容器。</p></blockquote><p><strong>实例</strong></p><p>容器mynginx将访问日志指到标准输出，连接到容器查看访问信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker attach --sig-proxy=false mynginx<br>192.168.239.1 - - [10/Jul/2016:16:54:26 +0000] &quot;GET / HTTP/1.1&quot; 304 0 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36&quot; &quot;-&quot;<br></code></pre></td></tr></table></figure><h2 id="docker-events"><a href="#docker-events" class="headerlink" title="docker events"></a>docker events</h2><p><strong>docker events :</strong> 从服务器获取实时事件</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker events [OPTIONS]<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><strong>-f ：</strong>根据条件过滤事件；</li><li><strong>–since ：</strong>从指定的时间戳后显示所有事件;</li><li><strong>–until ：</strong>流水时间显示到指定的时间为止；</li></ul><p><strong>实例</strong></p><p>显示docker 2016年7月1日后的所有事件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~/mysql$ docker events  --since=&quot;1467302400&quot;<br>2016-07-08T19:44:54.501277677+08:00 network connect 66f958fd13dc4314ad20034e576d5c5eba72e0849dcc38ad9e8436314a4149d4 (container=b8573233d675705df8c89796a2c2687cd8e36e03646457a15fb51022db440e64, name=bridge, type=bridge)<br>2016-07-08T19:44:54.723876221+08:00 container start b8573233d675705df8c89796a2c2687cd8e36e03646457a15fb51022db440e64 (image=nginx:latest, name=elegant_albattani)<br>2016-07-08T19:44:54.726110498+08:00 container resize b8573233d675705df8c89796a2c2687cd8e36e03646457a15fb51022db440e64 (height=39, image=nginx:latest, name=elegant_albattani, width=167)<br>2016-07-08T19:46:22.137250899+08:00 container die b8573233d675705df8c89796a2c2687cd8e36e03646457a15fb51022db440e64 (exitCode=0, image=nginx:latest, name=elegant_albattani)<br>...<br></code></pre></td></tr></table></figure><p>显示docker 镜像为mysql:5.6 2016年7月1日后的相关事件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~/mysql$ docker events -f &quot;image&quot;=&quot;mysql:5.6&quot; --since=&quot;1467302400&quot; <br>2016-07-11T00:38:53.975174837+08:00 container start 96f7f14e99ab9d2f60943a50be23035eda1623782cc5f930411bbea407a2bb10 (image=mysql:5.6, name=mymysql)<br>2016-07-11T00:51:17.022572452+08:00 container kill 96f7f14e99ab9d2f60943a50be23035eda1623782cc5f930411bbea407a2bb10 (image=mysql:5.6, name=mymysql, signal=9)<br>2016-07-11T00:51:17.132532080+08:00 container die 96f7f14e99ab9d2f60943a50be23035eda1623782cc5f930411bbea407a2bb10 (exitCode=137, image=mysql:5.6, name=mymysql)<br>2016-07-11T00:51:17.514661357+08:00 container destroy 96f7f14e99ab9d2f60943a50be23035eda1623782cc5f930411bbea407a2bb10 (image=mysql:5.6, name=mymysql)<br>2016-07-11T00:57:18.551984549+08:00 container create c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (image=mysql:5.6, name=mymysql)<br>2016-07-11T00:57:18.557405864+08:00 container attach c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (image=mysql:5.6, name=mymysql)<br>2016-07-11T00:57:18.844134112+08:00 container start c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (image=mysql:5.6, name=mymysql)<br>2016-07-11T00:57:19.140141428+08:00 container die c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (exitCode=1, image=mysql:5.6, name=mymysql)<br>2016-07-11T00:58:05.941019136+08:00 container destroy c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (image=mysql:5.6, name=mymysql)<br>2016-07-11T00:58:07.965128417+08:00 container create a404c6c174a21c52f199cfce476e041074ab020453c7df2a13a7869b48f2f37e (image=mysql:5.6, name=mymysql)<br>2016-07-11T00:58:08.188734598+08:00 container start a404c6c174a21c52f199cfce476e041074ab020453c7df2a13a7869b48f2f37e (image=mysql:5.6, name=mymysql)<br>2016-07-11T00:58:20.010876777+08:00 container top a404c6c174a21c52f199cfce476e041074ab020453c7df2a13a7869b48f2f37e (image=mysql:5.6, name=mymysql)<br>2016-07-11T01:06:01.395365098+08:00 container top a404c6c174a21c52f199cfce476e041074ab020453c7df2a13a7869b48f2f37e (image=mysql:5.6, name=mymysql)<br></code></pre></td></tr></table></figure><p>如果指定的时间是到秒级的，需要将时间转成时间戳。如果时间为日期的话，可以直接使用，如–since&#x3D;”2016-07-01”。</p><h2 id="☆-docker-logs"><a href="#☆-docker-logs" class="headerlink" title="☆ docker logs"></a>☆ docker logs</h2><p><strong>docker logs :</strong> 获取容器的日志</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker logs [OPTIONS] CONTAINER<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><strong>-f :</strong> 跟踪日志输出</li><li>**–since :**显示某个开始时间的所有日志</li><li><strong>-t :</strong> 显示时间戳</li><li>**–tail :**仅列出最新N条容器日志</li></ul><p><strong>实例</strong></p><p>跟踪查看容器mynginx的日志输出。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker logs -f mynginx<br>192.168.239.1 - - [10/Jul/2016:16:53:33 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36&quot; &quot;-&quot;<br>2016/07/10 16:53:33 [error] 5#5: *1 open() &quot;/usr/share/nginx/html/favicon.ico&quot; failed (2: No such file or directory), client: 192.168.239.1, server: localhost, request: &quot;GET /favicon.ico HTTP/1.1&quot;, host: &quot;192.168.239.130&quot;, referrer: &quot;http://192.168.239.130/&quot;<br>192.168.239.1 - - [10/Jul/2016:16:53:33 +0000] &quot;GET /favicon.ico HTTP/1.1&quot; 404 571 &quot;http://192.168.239.130/&quot; &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36&quot; &quot;-&quot;<br>192.168.239.1 - - [10/Jul/2016:16:53:59 +0000] &quot;GET / HTTP/1.1&quot; 304 0 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36&quot; &quot;-&quot;<br>...<br></code></pre></td></tr></table></figure><p>查看容器mynginx从2016年7月1日后的最新10条日志。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker logs --since=&quot;2016-07-01&quot; --tail=10 mynginx<br></code></pre></td></tr></table></figure><h2 id="docker-wait"><a href="#docker-wait" class="headerlink" title="docker wait"></a>docker wait</h2><p><strong>docker wait :</strong> 阻塞运行直到容器停止，然后打印出它的退出代码。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker wait [OPTIONS] CONTAINER [CONTAINER...]<br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker wait CONTAINER<br></code></pre></td></tr></table></figure><h2 id="docker-export-导出"><a href="#docker-export-导出" class="headerlink" title="docker export 导出"></a>docker export 导出</h2><p>**docker export :**将文件系统作为一个tar归档文件导出到STDOUT。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker export [OPTIONS] CONTAINER<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li>**-o :**将输入内容写到文件。</li></ul><p><strong>实例</strong></p><p>将id为a404c6c174a2的容器按日期保存为tar文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker export -o mysql-`date +%Y%m%d`.tar a404c6c174a2<br>runoob@runoob:~$ ls mysql-`date +%Y%m%d`.tar<br>mysql-20160711.tar<br></code></pre></td></tr></table></figure><h2 id="docker-port"><a href="#docker-port" class="headerlink" title="docker port"></a>docker port</h2><p>**docker port :**列出指定的容器的端口映射，或者查找将PRIVATE_PORT NAT到面向公众的端口。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker port [OPTIONS] CONTAINER [PRIVATE_PORT[/PROTO]]<br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><p>查看容器mynginx的端口映射情况。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker port mymysql<br>3306/tcp -&gt; 0.0.0.0:3306<br></code></pre></td></tr></table></figure><h2 id="docker-stats-统计"><a href="#docker-stats-统计" class="headerlink" title="docker stats 统计"></a>docker stats 统计</h2><p><strong>docker stats :</strong> 统计显示容器资源的使用情况，包括：CPU、内存、网络 I&#x2F;O 等。</p><p>stats: abbr. 统计（statistics）；</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker stats [OPTIONS] [CONTAINER...]<br></code></pre></td></tr></table></figure><p>OPTIONS 说明：</p><ul><li>**–all , -a :**显示所有的容器，包括未运行的。</li><li>**–format :**指定返回值的模板文件。</li><li>**–no-stream :**展示当前状态就直接退出了，不再实时更新。</li><li>**–no-trunc :**不截断输出。</li></ul><p><strong>实例</strong></p><p>列出所有在运行的容器信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$  docker stats<br>CONTAINER ID        NAME                                    CPU %               MEM USAGE / LIMIT     MEM %               NET I/O             BLOCK I/O           PIDS<br>b95a83497c91        awesome_brattain                        0.28%               5.629MiB / 1.952GiB   0.28%               916B / 0B           147kB / 0B          9<br>67b2525d8ad1        foobar                                  0.00%               1.727MiB / 1.952GiB   0.09%               2.48kB / 0B         4.11MB / 0B         2<br>e5c383697914        test-1951.1.kay7x1lh1twk9c0oig50sd5tr   0.00%               196KiB / 1.952GiB     0.01%               71.2kB / 0B         770kB / 0B          1<br>4bda148efbc0        random.1.vnc8on831idyr42slu578u3cr      0.00%               1.672MiB / 1.952GiB   0.08%               110kB / 0B          578kB / 0B          2<br></code></pre></td></tr></table></figure><p>输出详情介绍：</p><p><strong>CONTAINER ID 与 NAME:</strong> 容器 ID 与名称。</p><p><strong>CPU % 与 MEM %:</strong> 容器使用的 CPU 和内存的百分比。</p><p><strong>MEM USAGE &#x2F; LIMIT:</strong> 容器正在使用的总内存，以及允许使用的内存总量。</p><p><strong>NET I&#x2F;O:</strong> 容器通过其网络接口发送和接收的数据量。</p><p><strong>BLOCK I&#x2F;O:</strong> 容器从主机上的块设备读取和写入的数据量。</p><p><strong>PIDs:</strong> 容器创建的进程或线程数。</p><p>根据容器等 ID 或名称现实信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker stats awesome_brattain 67b2525d8ad1<br><br>CONTAINER ID        NAME                CPU %               MEM USAGE / LIMIT     MEM %               NET I/O             BLOCK I/O           PIDS<br>b95a83497c91        awesome_brattain    0.28%               5.629MiB / 1.952GiB   0.28%               916B / 0B           147kB / 0B          9<br>67b2525d8ad1        foobar              0.00%               1.727MiB / 1.952GiB   0.09%               2.48kB / 0B         4.11MB / 0B         2<br></code></pre></td></tr></table></figure><p>以 JSON 格式输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker stats nginx --no-stream --format &quot;&#123;&#123; json . &#125;&#125;&quot;<br>  &#123;&quot;BlockIO&quot;:&quot;0B / 13.3kB&quot;,&quot;CPUPerc&quot;:&quot;0.03%&quot;,&quot;Container&quot;:&quot;nginx&quot;,&quot;ID&quot;:&quot;ed37317fbf42&quot;,&quot;MemPerc&quot;:&quot;0.24%&quot;,&quot;MemUsage&quot;:&quot;2.352MiB / 982.5MiB&quot;,&quot;Name&quot;:&quot;nginx&quot;,&quot;NetIO&quot;:&quot;539kB / 606kB&quot;,&quot;PIDs&quot;:&quot;2&quot;&#125;<br></code></pre></td></tr></table></figure><p>输出指定的信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker stats --all --format &quot;table &#123;&#123;.Container&#125;&#125;\t&#123;&#123;.CPUPerc&#125;&#125;\t&#123;&#123;.MemUsage&#125;&#125;&quot; fervent_panini 5acfcb1b4fd1 drunk_visvesvaraya big_heisenberg<br>  &#123;&quot;BlockIO&quot;:&quot;0B / 13.3kB&quot;,&quot;CPUPerc&quot;:&quot;0.03%&quot;,&quot;Container&quot;:&quot;nginx&quot;,&quot;ID&quot;:&quot;ed37317fbf42&quot;,&quot;MemPerc&quot;:&quot;0.24%&quot;,&quot;MemUsage&quot;:&quot;2.352MiB / 982.5MiB&quot;,&quot;Name&quot;:&quot;nginx&quot;,&quot;NetIO&quot;:&quot;539kB / 606kB&quot;,&quot;PIDs&quot;:&quot;2&quot;&#125;<br><br>CONTAINER                CPU %               MEM USAGE / LIMIT<br>fervent_panini           0.00%               56KiB / 15.57GiB<br>5acfcb1b4fd1             0.07%               32.86MiB / 15.57GiB<br>drunk_visvesvaraya       0.00%               0B / 0B<br>big_heisenberg           0.00%               0B / 0B<br></code></pre></td></tr></table></figure><h2 id="↓-镜像管理-image-↓"><a href="#↓-镜像管理-image-↓" class="headerlink" title="↓ 镜像管理 image ↓"></a>↓ 镜像管理 image ↓</h2><h2 id="Docker-commit"><a href="#Docker-commit" class="headerlink" title="Docker commit"></a>Docker commit</h2><p><a href="https://yeasy.gitbook.io/docker_practice/image/commit">参考链接: 利用 commit 理解镜像构成</a></p><p>**docker commit :**从容器创建一个新的镜像。</p><blockquote><p>  我们并不推荐使用这个命令构建image, 我们会推荐使用更加强大的Dockerfile来进行构建</p></blockquote><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><p>**-a :**提交的镜像作者；</p></li><li><p>**-c :**使用Dockerfile指令来创建镜像；</p></li><li><p>**-m :**提交时的说明文字；</p></li><li><p>**-p :**在commit时，将容器暂停。</p></li></ul><p><strong>实例</strong></p><p>将容器a404c6c174a2 保存为新的镜像,并添加提交人信息和说明信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker commit -a &quot;runoob.com&quot; -m &quot;my apache&quot; a404c6c174a2  mymysql:v1 <br>sha256:37af1236adef1544e8886be23010b66577647a40bc02c0885a6600b33ee28057<br>runoob@runoob:~$ docker images mymysql:v1<br>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br>mymysql             v1                  37af1236adef        15 seconds ago      329 MB<br></code></pre></td></tr></table></figure><blockquote><p>  <strong><code>Docker commit</code>释义</strong></p><p>  要知道，当我们运行一个容器的时候（如果不使用卷的话），我们做的任何文件修改都会被记录于容器存储层里。而 Docker 提供了一个 <code>docker commit</code> 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。</p><p>  <strong>慎用 <code>docker commit</code></strong></p><p>  使用 <code>docker commit</code> 命令虽然可以比较直观的帮助理解镜像分层存储的概念，但是实际环境中并不会这样使用。</p><p>  首先，如果仔细观察之前的 <code>docker diff webserver</code> 的结果，你会发现除了真正想要修改的 <code>/usr/share/nginx/html/index.html</code> 文件外，由于命令的执行，还有很多文件被改动或添加了。这还仅仅是最简单的操作，如果是安装软件包、编译构建，那会有大量的无关内容被添加进来，将会导致镜像极为臃肿。</p><p>  此外，使用 <code>docker commit</code> 意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为 <strong>黑箱镜像</strong>，换句话说，就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知。而且，即使是这个制作镜像的人，过一段时间后也无法记清具体的操作。这种黑箱镜像的维护工作是非常痛苦的。</p><p>  而且，回顾之前提及的镜像所使用的分层存储的概念，除当前层外，之前的每一层都是不会发生改变的，换句话说，任何修改的结果仅仅是在当前层进行标记、添加、修改，而不会改动上一层。如果使用 <code>docker commit</code> 制作镜像，以及后期修改的话，每一次修改都会让镜像更加臃肿一次，所删除的上一层的东西并不会丢失，会一直如影随形的跟着这个镜像，即使根本无法访问到。这会让镜像更加臃肿。</p></blockquote><h2 id="☆-docker-cp-Copy-Data"><a href="#☆-docker-cp-Copy-Data" class="headerlink" title="☆ docker cp (Copy Data)"></a>☆ docker cp (Copy Data)</h2><p><code>docker cp</code> :用于容器与主机之间的数据拷贝。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-<br>docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li>**-L :**保持源目标中的链接</li></ul><p><strong>实例</strong></p><p>将主机&#x2F;www&#x2F;runoob目录拷贝到容器96f7f14e99ab的&#x2F;www目录下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker cp /www/runoob 96f7f14e99ab:/www/<br></code></pre></td></tr></table></figure><p>将主机&#x2F;www&#x2F;runoob目录拷贝到容器96f7f14e99ab中，目录重命名为www。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker cp /www/runoob 96f7f14e99ab:/www<br></code></pre></td></tr></table></figure><p>将容器96f7f14e99ab的&#x2F;www目录拷贝到主机的&#x2F;tmp目录中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker cp  96f7f14e99ab:/www /tmp/<br></code></pre></td></tr></table></figure><h2 id="docker-diff"><a href="#docker-diff" class="headerlink" title="docker diff"></a>docker diff</h2><p><code>docker diff</code> : 检查容器里文件结构的更改。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker diff [OPTIONS] CONTAINER<br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><p>查看容器mymysql的文件结构更改。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker diff mymysql<br>A /logs<br>A /mysql_data<br>C /run<br>C /run/mysqld<br>A /run/mysqld/mysqld.pid<br>A /run/mysqld/mysqld.sock<br>C /tmp<br></code></pre></td></tr></table></figure><h2 id="↓-镜像仓库管理-↓"><a href="#↓-镜像仓库管理-↓" class="headerlink" title="↓ 镜像仓库管理 ↓"></a>↓ 镜像仓库管理 ↓</h2><h2 id="docker-login-x2F-logout"><a href="#docker-login-x2F-logout" class="headerlink" title="docker login&#x2F;logout"></a>docker login&#x2F;logout</h2><p><strong>docker login :</strong> 登陆到一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub</p><p><strong>docker logout :</strong> 登出一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker login [OPTIONS] [SERVER]<br>docker logout [OPTIONS] [SERVER]<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li>**-u :**登陆的用户名</li><li>**-p :**登陆的密码</li></ul><p><strong>实例</strong></p><p>登陆到Docker Hub</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker login -u 用户名 -p 密码<br></code></pre></td></tr></table></figure><p>登出Docker Hub</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker logout<br></code></pre></td></tr></table></figure><h2 id="docker-pull"><a href="#docker-pull" class="headerlink" title="docker pull"></a>docker pull</h2><p><strong>docker pull :</strong> 从镜像仓库中拉取或者更新指定镜像</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull [OPTIONS] NAME[:TAG|@DIGEST]<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><p>**-a :**拉取所有 tagged 镜像</p></li><li><p>**–disable-content-trust :**忽略镜像的校验,默认开启</p></li></ul><p><strong>实例</strong></p><p>从Docker Hub下载java最新版镜像。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull java<br></code></pre></td></tr></table></figure><p>从Docker Hub下载REPOSITORY为java的所有镜像。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull -a java<br></code></pre></td></tr></table></figure><h2 id="docker-push"><a href="#docker-push" class="headerlink" title="docker push"></a>docker push</h2><p><strong>docker push :</strong> 将本地的镜像上传到镜像仓库,要先登陆到镜像仓库</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker push [OPTIONS] NAME[:TAG]<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li>**–disable-content-trust :**忽略镜像的校验,默认开启</li></ul><p><strong>实例</strong></p><p>上传本地镜像myapache:v1到镜像仓库中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker push myapache:v1<br></code></pre></td></tr></table></figure><h2 id="☆-docker-search"><a href="#☆-docker-search" class="headerlink" title="☆ docker search"></a>☆ docker search</h2><p><strong>docker search :</strong> 从Docker Hub查找镜像</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker search [OPTIONS] TERM<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li>**–automated :**只列出 automated build类型的镜像；</li><li>**–no-trunc :**显示完整的镜像描述；</li><li>**-f &lt;过滤条件&gt;:**列出收藏数不小于指定值的镜像。</li></ul><p><strong>实例</strong></p><p>从 Docker Hub 查找所有镜像名包含 java，并且收藏数大于 10 的镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker search -f stars=10 java<br>NAME                  DESCRIPTION                           STARS   OFFICIAL   AUTOMATED<br>java                  Java is a concurrent, class-based...   1037    [OK]       <br>anapsix/alpine-java   Oracle Java 8 (and 7) with GLIBC ...   115                [OK]<br>develar/java                                                 46                 [OK]<br>isuper/java-oracle    This repository contains all java...   38                 [OK]<br>lwieske/java-8        Oracle Java 8 Container - Full + ...   27                 [OK]<br>nimmis/java-centos    This is docker images of CentOS 7...   13                 [OK]<br></code></pre></td></tr></table></figure><p>参数说明：</p><p><strong>NAME:</strong> 镜像仓库源的名称</p><p><strong>DESCRIPTION:</strong> 镜像的描述</p><p><strong>OFFICIAL:</strong> 是否 docker 官方发布</p><p><strong>stars:</strong> 类似 Github 里面的 star，表示点赞、喜欢的意思。</p><p><strong>AUTOMATED:</strong> 自动构建。</p><h2 id="↓-本地镜像管理-↓"><a href="#↓-本地镜像管理-↓" class="headerlink" title="↓ 本地镜像管理 ↓"></a>↓ 本地镜像管理 ↓</h2><h2 id="☆-docker-images"><a href="#☆-docker-images" class="headerlink" title="☆ docker images"></a>☆ docker images</h2><p><strong>docker images :</strong> 列出本地镜像。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker images [OPTIONS] [REPOSITORY[:TAG]]<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><p>**-a :**列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；</p></li><li><p>**–digests :**显示镜像的摘要信息；</p></li><li><p>**-f :**显示满足条件的镜像；</p></li><li><p>**–format :**指定返回值的模板文件；</p></li><li><p>**–no-trunc :**显示完整的镜像信息；</p></li><li><p>**-q :**只显示镜像ID。</p></li></ul><p><strong>实例</strong></p><p>查看本地镜像列表。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker images<br>REPOSITORY              TAG                 IMAGE ID            CREATED             SIZE<br>mymysql                 v1                  37af1236adef        5 minutes ago       329 MB<br>runoob/ubuntu           v4                  1c06aa18edee        2 days ago          142.1 MB<br>&lt;none&gt;                  &lt;none&gt;              5c6e1090e771        2 days ago          165.9 MB<br>httpd                   latest              ed38aaffef30        11 days ago         195.1 MB<br>alpine                  latest              4e38e38c8ce0        2 weeks ago         4.799 MB<br>mongo                   3.2                 282fd552add6        3 weeks ago         336.1 MB<br>redis                   latest              4465e4bcad80        3 weeks ago         185.7 MB<br>php                     5.6-fpm             025041cd3aa5        3 weeks ago         456.3 MB<br>python                  3.5                 045767ddf24a        3 weeks ago         684.1 MB<br>...<br></code></pre></td></tr></table></figure><p>列出本地镜像中REPOSITORY为ubuntu的镜像列表。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@runoob:~# docker images  ubuntu<br>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br>ubuntu              14.04               90d5884b1ee0        9 weeks ago         188 MB<br>ubuntu              15.10               4e3b13c8a266        3 months ago        136.3 MB<br></code></pre></td></tr></table></figure><h2 id="docker-rmi"><a href="#docker-rmi" class="headerlink" title="docker rmi"></a>docker rmi</h2><p><strong>docker rmi :</strong> 删除本地一个或多个镜像。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rmi [OPTIONS] IMAGE [IMAGE...]<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><p>**-f :**强制删除；</p></li><li><p>**–no-prune :**不移除该镜像的过程镜像，默认移除；</p></li></ul><p><strong>实例</strong></p><p>强制删除本地镜像 runoob&#x2F;ubuntu:v4。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@runoob:~# docker rmi -f runoob/ubuntu:v4<br>Untagged: runoob/ubuntu:v4<br>Deleted: sha256:1c06aa18edee44230f93a90a7d88139235de12cd4c089d41eed8419b503072be<br>Deleted: sha256:85feb446e89a28d58ee7d80ea5ce367eebb7cec70f0ec18aa4faa874cbd97c73<br></code></pre></td></tr></table></figure><h2 id="docker-tag"><a href="#docker-tag" class="headerlink" title="docker tag"></a>docker tag</h2><p><strong>docker tag :</strong> 标记本地镜像，将其归入某一仓库。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker tag [OPTIONS] IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG]<br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><p>将镜像ubuntu:15.10标记为 runoob&#x2F;ubuntu:v3 镜像。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@runoob:~# docker tag ubuntu:15.10 runoob/ubuntu:v3<br>root@runoob:~# docker images   runoob/ubuntu:v3<br>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br>runoob/ubuntu       v3                  4e3b13c8a266        3 months ago        136.3 MB<br></code></pre></td></tr></table></figure><h2 id="☆-docker-build"><a href="#☆-docker-build" class="headerlink" title="☆ docker build"></a>☆ docker build</h2><p><strong>docker build</strong> 命令用于使用 Dockerfile 创建镜像。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build [OPTIONS] PATH | URL | -<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li>**–build-arg&#x3D;[] :**设置镜像创建时的变量；</li><li>**–cpu-shares :**设置 cpu 使用权重；</li><li>**–cpu-period :**限制 CPU CFS周期；</li><li>**–cpu-quota :**限制 CPU CFS配额；</li><li>**–cpuset-cpus :**指定使用的CPU id；</li><li>**–cpuset-mems :**指定使用的内存 id；</li><li>**–disable-content-trust :**忽略校验，默认开启；</li><li>**-f :**指定要使用的Dockerfile路径；</li><li>**–force-rm :**设置镜像过程中删除中间容器；</li><li>**–isolation :**使用容器隔离技术；</li><li>**–label&#x3D;[] :**设置镜像使用的元数据；</li><li>**-m :**设置内存最大值；</li><li>**–memory-swap :**设置Swap的最大值为内存+swap，”-1”表示不限swap；</li><li>**–no-cache :**创建镜像的过程不使用缓存；</li><li>**–pull :**尝试去更新镜像的新版本；</li><li>**–quiet, -q :**安静模式，成功后只输出镜像 ID；</li><li>**–rm :**设置镜像成功后删除中间容器；</li><li>**–shm-size :**设置&#x2F;dev&#x2F;shm的大小，默认值是64M；</li><li>**–ulimit :**Ulimit配置。</li><li>**–squash :**将 Dockerfile 中所有的操作压缩为一层。</li><li><strong>–tag, -t:</strong> 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。</li><li><strong>–network:</strong> 默认 default。在构建期间设置RUN指令的网络模式</li></ul><p><strong>实例</strong></p><p>使用当前目录的 Dockerfile 创建镜像，标签为 runoob&#x2F;ubuntu:v1。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build -t runoob/ubuntu:v1 . <br></code></pre></td></tr></table></figure><p>使用URL <strong>github.com&#x2F;creack&#x2F;docker-firefox</strong> 的 Dockerfile 创建镜像。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build github.com/creack/docker-firefox<br></code></pre></td></tr></table></figure><p>也可以通过 -f Dockerfile 文件的位置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker build -f /path/to/a/Dockerfile .</span><br></code></pre></td></tr></table></figure><p>在 Docker 守护进程执行 Dockerfile 中的指令前，首先会对 Dockerfile 进行语法检查，有语法错误时会返回：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker build -t <span class="hljs-built_in">test</span>/myapp .</span><br>Sending build context to Docker daemon 2.048 kB<br>Error response from daemon: Unknown instruction: RUNCMD<br></code></pre></td></tr></table></figure><h2 id="docker-history"><a href="#docker-history" class="headerlink" title="docker history"></a>docker history</h2><p><strong>docker history :</strong> 查看指定镜像的创建历史。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker history [OPTIONS] IMAGE<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><p>**-H :**以可读的格式打印镜像大小和日期，默认为true；</p></li><li><p>**–no-trunc :**显示完整的提交记录；</p></li><li><p>**-q :**仅列出提交记录ID。</p></li></ul><p><strong>实例</strong></p><p>查看本地镜像runoob&#x2F;ubuntu:v3的创建历史。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@runoob:~# docker history runoob/ubuntu:v3<br>IMAGE             CREATED           CREATED BY                                      SIZE      COMMENT<br>4e3b13c8a266      3 months ago      /bin/sh -c #(nop) CMD [&quot;/bin/bash&quot;]             0 B                 <br>&lt;missing&gt;         3 months ago      /bin/sh -c sed -i &#x27;s/^#\s*\(deb.*universe\)$/   1.863 kB            <br>&lt;missing&gt;         3 months ago      /bin/sh -c set -xe   &amp;&amp; echo &#x27;#!/bin/sh&#x27; &gt; /u   701 B               <br>&lt;missing&gt;         3 months ago      /bin/sh -c #(nop) ADD file:43cb048516c6b80f22   136.3 MB<br></code></pre></td></tr></table></figure><h2 id="docker-save"><a href="#docker-save" class="headerlink" title="docker save"></a>docker save</h2><p><strong>docker save :</strong> 将指定镜像保存成 tar 归档文件。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker save [OPTIONS] IMAGE [IMAGE...]<br></code></pre></td></tr></table></figure><p>OPTIONS 说明：</p><ul><li>**-o :**输出到的文件。</li></ul><p><strong>实例</strong></p><p>将镜像 runoob&#x2F;ubuntu:v3 生成 my_ubuntu_v3.tar 文档</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker save -o my_ubuntu_v3.tar runoob/ubuntu:v3<br>runoob@runoob:~$ ll my_ubuntu_v3.tar<br>-rw------- 1 runoob runoob 142102016 Jul 11 01:37 my_ubuntu_v3.ta<br></code></pre></td></tr></table></figure><h2 id="docker-load"><a href="#docker-load" class="headerlink" title="docker load"></a>docker load</h2><p><strong>docker load :</strong> 导入使用 <a href="https://www.runoob.com/docker/docker-save-command.html">docker save</a> 命令导出的镜像。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker load [OPTIONS]<br></code></pre></td></tr></table></figure><p>OPTIONS 说明：</p><ul><li><p><strong>–input , -i :</strong> 指定导入的文件，代替 STDIN。</p></li><li><p><strong>–quiet , -q :</strong> 精简输出信息。</p></li></ul><p><strong>实例</strong></p><p>导入镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker image <span class="hljs-built_in">ls</span></span><br><br>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker load &lt; busybox.tar.gz</span><br><br>Loaded image: busybox:latest<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker images</span><br>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br>busybox             latest              769b9341d937        7 weeks ago         2.489 MB<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker load --input fedora.tar</span><br><br>Loaded image: fedora:rawhide<br><br>Loaded image: fedora:20<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker images</span><br><br>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br>busybox             latest              769b9341d937        7 weeks ago         2.489 MB<br>fedora              rawhide             0d20aec6529d        7 weeks ago         387 MB<br>fedora              20                  58394af37342        7 weeks ago         385.5 MB<br>fedora              heisenbug           58394af37342        7 weeks ago         385.5 MB<br>fedora              latest              58394af37342        7 weeks ago         385.5 MB<br></code></pre></td></tr></table></figure><h2 id="docker-import"><a href="#docker-import" class="headerlink" title="docker import"></a>docker import</h2><p><strong>docker import :</strong> 从归档文件中创建镜像。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><p>**-c :**应用docker 指令创建镜像；</p></li><li><p>**-m :**提交时的说明文字；</p></li></ul><p><strong>实例</strong></p><p>从镜像归档文件my_ubuntu_v3.tar创建镜像，命名为runoob&#x2F;ubuntu:v4</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker import  my_ubuntu_v3.tar runoob/ubuntu:v4  <br>sha256:63ce4a6d6bc3fabb95dbd6c561404a309b7bdfc4e21c1d59fe9fe4299cbfea39<br>runoob@runoob:~$ docker images runoob/ubuntu:v4<br>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br>runoob/ubuntu       v4                  63ce4a6d6bc3        20 seconds ago      142.1 MB<br></code></pre></td></tr></table></figure><h2 id="docker-info"><a href="#docker-info" class="headerlink" title="docker info"></a>docker info</h2><p><code>docker info</code> : 显示 Docker 信息，主机详细系统信息，镜像和容器信息。</p><h2 id="docker-version"><a href="#docker-version" class="headerlink" title="docker version"></a>docker version</h2><p><code>docker version</code> :显示 Docker 版本信息。</p><h1 id="Dockerfile的使用"><a href="#Dockerfile的使用" class="headerlink" title="Dockerfile的使用"></a>Dockerfile的使用</h1><h3 id="什么是-Dockerfile？"><a href="#什么是-Dockerfile？" class="headerlink" title="什么是 Dockerfile？"></a>什么是 Dockerfile？</h3><p>Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。</p><h2 id="构建环境"><a href="#构建环境" class="headerlink" title="构建环境"></a>构建环境</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">❯ mkdir web_docker<br>❯ cd web_docker<br>❯ touch Dockerfile<br>❯ tree .. -f<br>..<br>└── ../web_docker<br>    └── ../web_docker/Dockerfile<br></code></pre></td></tr></table></figure><p>在上面的命令中, 我们创建了 <code>web_docker</code>文件夹, <code>web_docker</code>文件夹就是我们的构建环境(build environment), docker称此环境为上下文(context)，或者构建上下文(context), docker会在构建镜像时构建上下文和该上下文中的文件和目录，上传到docker守护进程，这样docker守护进程就能直接访问你想在镜像中存储的任何代码文件和其他数据。</p><h2 id="dockerfile-示例"><a href="#dockerfile-示例" class="headerlink" title="dockerfile 示例"></a>dockerfile 示例</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># version 0.0.1</span><br><span class="hljs-keyword">FROM</span> ubuntu:<span class="hljs-number">14.04</span><br><span class="hljs-keyword">MAINTAINER</span> James Turnbull <span class="hljs-string">&quot;james@example.com&quot;</span><br><span class="hljs-keyword">ENV</span> REFRESHED_AT <span class="hljs-number">2014</span>-<span class="hljs-number">06</span>-<span class="hljs-number">01</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get update</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get -y -q install nginx</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;Hi i am in you container&#x27;</span> &gt; /usr/share/nginx/html/index.html</span><br><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><blockquote><p>  Dockerfile也支持注释, 使用#开头就是注释了</p></blockquote><hr><h2 id="指令详解"><a href="#指令详解" class="headerlink" title="指令详解"></a>指令详解</h2><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><p>构建镜像基于哪个镜像</p><h3 id="MANTAINER"><a href="#MANTAINER" class="headerlink" title="MANTAINER"></a>MANTAINER</h3><p>镜像维护者 姓名 邮箱地址</p><h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><p>用于执行后面跟着的命令行命令。有以下俩种格式：</p><p>shell 格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">RUN &lt;命令行命令&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;命令行命令&gt; 等同于，在终端操作的 shell 命令。</span><br></code></pre></td></tr></table></figure><p>exec 格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]<br><span class="hljs-meta prompt_"># </span><span class="language-bash">例如：</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">RUN [<span class="hljs-string">&quot;./test.php&quot;</span>, <span class="hljs-string">&quot;dev&quot;</span>, <span class="hljs-string">&quot;offline&quot;</span>] 等价于 RUN ./test.php dev offline</span><br></code></pre></td></tr></table></figure><h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h3><p>复制指令，从上下文目录中复制文件或者目录到容器里指定路径。</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">COPY [--chown=<span class="hljs-tag">&lt;<span class="hljs-name">user</span>&gt;</span>:<span class="hljs-tag">&lt;<span class="hljs-name">group</span>&gt;</span>] <span class="hljs-tag">&lt;<span class="hljs-name">源路径1</span>&gt;</span>...  <span class="hljs-tag">&lt;<span class="hljs-name">目标路径</span>&gt;</span><br>COPY [--chown=<span class="hljs-tag">&lt;<span class="hljs-name">user</span>&gt;</span>:<span class="hljs-tag">&lt;<span class="hljs-name">group</span>&gt;</span>] [&quot;<span class="hljs-tag">&lt;<span class="hljs-name">源路径1</span>&gt;</span>&quot;,...  &quot;<span class="hljs-tag">&lt;<span class="hljs-name">目标路径</span>&gt;</span>&quot;]<br></code></pre></td></tr></table></figure><p>**[–chown&#x3D;<user>:<group>]**：可选参数，用户改变复制到容器内文件的拥有者和属组。</p><p>**&lt;源路径&gt;**：源文件或者源目录，这里可以是通配符表达式，其通配符规则要满足 Go 的 filepath.Match 规则。例如：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">COPY</span> hom* <span class="hljs-regexp">/mydir/</span><br><span class="hljs-keyword">COPY</span> hom?.txt <span class="hljs-regexp">/mydir/</span><br></code></pre></td></tr></table></figure><p>**&lt;目标路径&gt;**：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建。</p><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><p>ADD 指令和 COPY 的使用格类似（同样需求下，官方推荐使用 COPY）。功能也类似，不同之处如下：</p><ul><li>ADD 的优点：在执行 &lt;源文件&gt; 为 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，会自动复制并解压到 &lt;目标路径&gt;。</li><li>ADD 的缺点：在不解压的前提下，无法复制 tar 压缩文件。会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。具体是否使用，可以根据是否需要自动解压来决定。</li></ul><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p>类似于 RUN 指令，用于运行程序，但二者运行的时间点不同:</p><ul><li>CMD 在docker run 时运行。</li><li>RUN 是在 docker build。</li></ul><p><strong>作用</strong>：为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。</p><p><strong>注意</strong>：如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效。</p><p>格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">CMD</span><span class="language-bash"> &lt;shell 命令&gt; </span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;&lt;可执行文件或命令&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param1&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param2&gt;&quot;</span>,...] </span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;&lt;param1&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param2&gt;&quot;</span>,...]  <span class="hljs-comment"># 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数</span></span><br></code></pre></td></tr></table></figure><p>推荐使用第二种格式，执行过程比较明确。第一种格式实际上在运行的过程中也会自动转换成第二种格式运行，并且默认可执行文件是 sh。</p><h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><p>类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。</p><p>但是, 如果运行 docker run 时使用了 –entrypoint 选项，将覆盖 ENTRYPOINT 指令指定的程序。</p><p><strong>优点</strong>：在执行 docker run 的时候可以指定 ENTRYPOINT 运行所需的参数。</p><p><strong>注意</strong>：如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。</p><p>格式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">ENTRYPOINT <span class="hljs-selector-attr">[<span class="hljs-string">&quot;&lt;executeable&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param1&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param2&gt;&quot;</span>,...]</span><br></code></pre></td></tr></table></figure><p>可以搭配 CMD 命令使用：一般是变参才会使用 CMD ，这里的 CMD 等于是在给 ENTRYPOINT 传参，以下示例会提到。</p><p>示例：</p><p>假设已通过 Dockerfile 构建了 nginx:test 镜像：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> nginx<br><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;nginx&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>] <span class="hljs-comment"># 定参</span></span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;/etc/nginx/nginx.conf&quot;</span>] <span class="hljs-comment"># 变参 </span></span><br></code></pre></td></tr></table></figure><p>1、不传参运行</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">$ docker <span class="hljs-keyword">run</span><span class="language-bash">  nginx:<span class="hljs-built_in">test</span></span><br></code></pre></td></tr></table></figure><p>容器内会默认运行以下命令，启动主进程。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">nginx -c <span class="hljs-regexp">/etc/</span>nginx/nginx.conf<br></code></pre></td></tr></table></figure><p>2、传参运行</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">$ docker <span class="hljs-keyword">run</span><span class="language-bash">  nginx:<span class="hljs-built_in">test</span> -c /etc/nginx/new.conf</span><br></code></pre></td></tr></table></figure><p>容器内会默认运行以下命令，启动主进程(&#x2F;etc&#x2F;nginx&#x2F;new.conf:假设容器内已有此文件)</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">nginx -c <span class="hljs-regexp">/etc/</span>nginx/<span class="hljs-keyword">new</span>.conf<br></code></pre></td></tr></table></figure><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p>设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">ENV <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span><br>ENV <span class="hljs-tag">&lt;<span class="hljs-name">key1</span>&gt;</span>=<span class="hljs-tag">&lt;<span class="hljs-name">value1</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">key2</span>&gt;</span>=<span class="hljs-tag">&lt;<span class="hljs-name">value2</span>&gt;</span>...<br></code></pre></td></tr></table></figure><p>以下示例设置 NODE_VERSION &#x3D; 7.2.0 ， 在后续的指令中可以通过 $NODE_VERSION 引用：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENV</span> NODE_VERSION <span class="hljs-number">7.2</span>.<span class="hljs-number">0</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> curl -SLO <span class="hljs-string">&quot;https://nodejs.org/dist/v<span class="hljs-variable">$NODE_VERSION</span>/node-v<span class="hljs-variable">$NODE_VERSION</span>-linux-x64.tar.xz&quot;</span> \</span><br><span class="language-bash">  &amp;&amp; curl -SLO <span class="hljs-string">&quot;https://nodejs.org/dist/v<span class="hljs-variable">$NODE_VERSION</span>/SHASUMS256.txt.asc&quot;</span></span><br></code></pre></td></tr></table></figure><h3 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h3><p>构建参数，与 ENV 作用一致。不过作用域不一样。ARG 设置的环境变量仅对 Dockerfile 内有效，也就是说只有 docker build 的过程中有效，构建好的镜像内不存在此环境变量。</p><p>构建命令 docker build 中可以用 –build-arg &lt;参数名&gt;&#x3D;&lt;值&gt; 来覆盖。</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">ARG <span class="hljs-tag">&lt;<span class="hljs-name">参数名</span>&gt;</span>[=<span class="hljs-tag">&lt;<span class="hljs-name">默认值</span>&gt;</span>]<br></code></pre></td></tr></table></figure><h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><p>定义匿名数据卷。在启动容器时忘记挂载数据卷，会自动挂载到匿名卷。</p><p>作用：</p><ul><li>避免重要的数据，因容器重启而丢失，这是非常致命的。</li><li>避免容器不断变大。</li></ul><p>格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">VOLUME</span><span class="language-bash"> [<span class="hljs-string">&quot;&lt;路径1&gt;&quot;</span>, <span class="hljs-string">&quot;&lt;路径2&gt;&quot;</span>...]</span><br><span class="hljs-keyword">VOLUME</span><span class="language-bash"> &lt;路径&gt;</span><br></code></pre></td></tr></table></figure><p>在启动容器 docker run 的时候，我们可以通过 -v 参数修改挂载点。</p><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><p>仅仅只是声明端口。</p><p>作用：</p><ul><li>帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。</li><li>在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。</li></ul><p>格式：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">EXPOSE</span> &lt;端口<span class="hljs-number">1</span>&gt;<span class="hljs-meta"> [&lt;端口2&gt;...]</span><br></code></pre></td></tr></table></figure><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><p>指定工作目录。用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在。以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR 会帮你建立目录。</p><p>docker build 构建镜像过程中的，每一个 RUN 命令都是新建的一层。只有通过 WORKDIR 创建的目录才会一直存在。</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">WORKDIR <span class="hljs-tag">&lt;<span class="hljs-name">工作目录路径</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h3><p>用于指定执行后续命令的用户和用户组，这边只是切换后续命令执行的用户（用户和用户组必须提前已经存在）。</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">USER <span class="hljs-tag">&lt;<span class="hljs-name">用户名</span>&gt;</span>[:<span class="hljs-tag">&lt;<span class="hljs-name">用户组</span>&gt;</span>]<br></code></pre></td></tr></table></figure><h3 id="HEALTHCHECK"><a href="#HEALTHCHECK" class="headerlink" title="HEALTHCHECK"></a>HEALTHCHECK</h3><p>用于指定某个程序或者指令来监控 docker 容器服务的运行状态。</p><p>格式：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dos">HEALTHCHECK [选项] <span class="hljs-built_in">CMD</span> &lt;命令&gt;：设置检查容器健康状况的命令<br>HEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令<br><br>HEALTHCHECK [选项] <span class="hljs-built_in">CMD</span> &lt;命令&gt; : 这边 <span class="hljs-built_in">CMD</span> 后面跟随的命令使用，可以参考 <span class="hljs-built_in">CMD</span> 的用法。<br></code></pre></td></tr></table></figure><h3 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h3><p>用于延迟构建命令的执行。简单的说，就是 Dockerfile 里用 ONBUILD 指定的命令，在本次构建镜像的过程中不会执行（假设镜像为 test-build）。当有新的 Dockerfile 使用了之前构建的镜像 FROM test-build ，这时执行新镜像的 Dockerfile 构建时候，会执行 test-build 的 Dockerfile 里的 ONBUILD 指定的命令。</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">ONBUILD <span class="hljs-tag">&lt;<span class="hljs-name">其它指令</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h3><p>LABEL 指令用来给镜像添加一些元数据（metadata），以键值对的形式，语法格式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">LABEL <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>=<span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>=<span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>=<span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span> ...<br></code></pre></td></tr></table></figure><p>比如我们可以添加镜像的作者：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">LABEL org<span class="hljs-selector-class">.opencontainers</span><span class="hljs-selector-class">.image</span>.authors=<span class="hljs-string">&quot;runoob&quot;</span><br></code></pre></td></tr></table></figure><h1 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h1>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Docker&quot;&gt;&lt;a href=&quot;#Docker&quot; class=&quot;headerlink&quot; title=&quot;Docker&quot;&gt;&lt;/a&gt;Docker&lt;/h1&gt;&lt;h1 id=&quot;Docker是什么-amp-如何理解Docker&quot;&gt;&lt;a</summary>
        
      
    
    
    
    <category term="tools" scheme="https://www.oikiou.top/categories/tools/"/>
    
    
    <category term="docker" scheme="https://www.oikiou.top/tags/docker/"/>
    
    <category term="dockerfile" scheme="https://www.oikiou.top/tags/dockerfile/"/>
    
    <category term="namespace" scheme="https://www.oikiou.top/tags/namespace/"/>
    
    <category term="cgroup" scheme="https://www.oikiou.top/tags/cgroup/"/>
    
    <category term="dockerhub" scheme="https://www.oikiou.top/tags/dockerhub/"/>
    
  </entry>
  
  <entry>
    <title>RDPWrap</title>
    <link href="https://www.oikiou.top/2022/a8b000ae/"/>
    <id>https://www.oikiou.top/2022/a8b000ae/</id>
    <published>2022-07-20T14:57:15.000Z</published>
    <updated>2022-09-18T14:38:51.311Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RDPWrap"><a href="#RDPWrap" class="headerlink" title="RDPWrap"></a>RDPWrap</h1><ul><li>RDP程序源Github</li></ul><p><a href="https://github.com/stascorp/rdpwrap">https://github.com/stascorp/rdpwrap</a></p><ul><li>新版RDP配置文件</li></ul><p><a href="https://raw.githubusercontent.com/saurav-biswas/rdpwrap-1/master/res/rdpwrap.ini">https://raw.githubusercontent.com/saurav-biswas/rdpwrap-1/master/res/rdpwrap.ini</a></p><p><a href="https://github.com/affinityv/INI-RDPWRAP">https://github.com/affinityv/INI-RDPWRAP</a></p><p>win11可用 <a href="https://raw.githubusercontent.com/sebaxakerhtc/rdpwrap.ini/master/rdpwrap.ini">https://raw.githubusercontent.com/sebaxakerhtc/rdpwrap.ini/master/rdpwrap.ini</a></p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ol><li><p><code>install.bat</code>安装</p></li><li><p><code>RDPConf.exe</code>检查是否成功开启</p><p><img src="/2022/a8b000ae/image-20211209105711309.png" alt="image-20211209105711309"></p></li><li><p>新的操作系统一般来说第三项是红色的,如果是绿色的就表示正常可以使用了</p></li><li><p>如果异常按以下进行操作</p><ol><li>管理员打开<code>PowerShell</code>运行<code>get-service termservice|stop-service -force</code>停掉RDP进程</li><li>从<a href="https://raw.githubusercontent.com/saurav-biswas/rdpwrap-1/master/res/rdpwrap.ini">RDP配置文件</a>下载新的配置文件</li><li>将下载的配置文件复制到<code>C:\Program Files\RDP Wrapper\rdpwrap.ini</code>替换原文件</li><li>管理员打开<code>PowerShell</code>运行<code>get-service termservice|start-service</code>重新运行RDP</li><li><code>RDPConf.exe</code>检查已经成功开启</li></ol></li></ol>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;RDPWrap&quot;&gt;&lt;a href=&quot;#RDPWrap&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="tools" scheme="https://www.oikiou.top/categories/tools/"/>
    
    
    <category term="windows" scheme="https://www.oikiou.top/tags/windows/"/>
    
    <category term="rdpwrap" scheme="https://www.oikiou.top/tags/rdpwrap/"/>
    
    <category term="rdp" scheme="https://www.oikiou.top/tags/rdp/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
<<<<<<< HEAD
    <title>DSlogic协议开发笔记</title>
    <link href="/2022/08/5ced0506/"/>
    <url>/2022/08/5ced0506/</url>
    
    <content type="html"><![CDATA[<h1 id="参考资料-smiley"><a href="#参考资料-smiley" class="headerlink" title="参考资料:smiley:"></a>参考资料:smiley:</h1><p><a href="https://sigrok.org/wiki/Protocol_decoder_HOWTO">Protocol decoder HOWTO(新手指导)</a></p><p><a href="https://sigrok.org/wiki/Protocol_decoder_API#register-function">Protocol decoder API</a></p><p><a href="https://sigrok.org/wiki/Protocol_decoder_API/Queries">Protocol decoder API&#x2F;Queries</a></p><h1 id="名词解析"><a href="#名词解析" class="headerlink" title="名词解析"></a>名词解析</h1><ul><li><strong>Protocol Decoders (PDs)</strong></li></ul><p>协议解码器</p><ul><li><strong>libsigrokdecode</strong></li></ul><p>是一个采用C语言编写的共享库,提供了数据流协议解码功能。该协议解码器采用Python(&#x3D; 3.0)编写。 </p><h1 id="Decoder-class-functions"><a href="#Decoder-class-functions" class="headerlink" title="Decoder class functions"></a>Decoder class functions</h1><h2 id="必须的函数"><a href="#必须的函数" class="headerlink" title="必须的函数"></a>必须的函数</h2><ul><li>start(self)</li></ul><p> 这个函数在解码开始之前被调用。这里可以  [register()](#Decoder registration) 输出类型，检查用户提供的PD选项的有效性，等等。 </p><ul><li>decode(self) （解码）</li></ul><p>在 <strong>non-stacked</strong> 解码器中，这个函数由libsigrokdecode后端调用以开始解码。它不接受任何参数，而是进入一个无限循环，并通过调用更通用的wait()方法获取样本。这使得特定的协议解码器从繁琐但常见的任务中解放出来，比如检测边缘，或者在相对于当前位置的特定时间点采样信号。</p><p>  注意:这个decode(self)方法的签名已经在协议解码器API的第三版中引入，在以前的版本中只有decode(self、startsample、endsample、data)是可用的。</p><ul><li>decode(self, startsample, endsample, data)</li></ul><p>…</p><h2 id="可选的函数"><a href="#可选的函数" class="headerlink" title="可选的函数"></a>可选的函数</h2><ul><li>metadata(self, key, value)（  元数据 ）</li></ul><p> 用于传递关于数据流的解码器元数据。目前 <strong><code>key</code></strong>  的唯一值是sigrokdecode.SRD_CONF_SAMPLERATE， <strong><code>value</code></strong>  则为数据流的采样率（samplerate），单位为Hz。 </p><h1 id="Decoder-registration"><a href="#Decoder-registration" class="headerlink" title="Decoder registration"></a>Decoder registration</h1><p> 解码器类必须包含几个指定PD元数据的属性。可以使用以下关键字：</p><p><a href="https://sigrok.org/wiki/Protocol_decoder_API">原文查考 Decoder registration 章节</a></p><table><thead><tr><th>Key</th><th>Description</th></tr></thead><tbody><tr><td><strong><code>api_version</code></strong></td><td>这个模块使用的libsigrokdecode API版本。现在不是2就是3。</td></tr><tr><td><strong><code>id</code></strong></td><td>此协议解码器的简短唯一标识符。它应该是全小写的，只包含a-z, 0-9和下划线。这必须匹配PD的Python模块名(decoders目录中的子目录名)。siglock -cli工具使用它在命令行上指定PDs。例如:’jtag’， ‘sdcard_spi’， ‘uart’。</td></tr><tr><td><strong><code>name</code></strong></td><td>解码器的名称。当列出可用的PDs时使用。例如:“JTAG”，“SD卡(SPI模式)”，“UART”。</td></tr><tr><td><strong><code>longname</code></strong></td><td>译码器的(长)名。当列出可用的PDs时使用。Example: ‘Joint Test Action Group (IEEE 1149.1)’, ‘Secure Digital card (SPI mode)’, ‘Universal Asynchronous Receiver&#x2F;Transmitter（UART）’</td></tr><tr><td><strong><code>desc</code></strong></td><td>解码器的自由的一行描述。当列出可用的PDs时使用。应该以句号结束。Example: ‘Protocol for testing, debugging, and flashing ICs.’, ‘Secure Digital card (SPI mode) low-level protocol.’, ‘Asynchronous, serial bus.’.</td></tr><tr><td><strong><code>license</code></strong></td><td>提供模块的许可证。这必须是gplv2+(即GNU通用公共许可证2或更高版本)，或者gplv3+ (GNU通用公共许可证3或更高版本)。libsigrokdecode中不允许为模块提供其他许可证。</td></tr><tr><td><strong><code>inputs</code></strong></td><td>此解码器需要的输入类型列表。如果解码器从逻辑分析器驱动程序获取输入，则应将其设置为logic，该逻辑将映射到数据籽类型SR_DF_LOGIC。如果它从另一个PD获取输入，则应该将其设置为该PD的输出键的值。它应该符合与id键相同的规则(小写，没有空格，等等)。</td></tr><tr><td><strong><code>outputs</code></strong></td><td>此解码器产生的输出类型列表。如果这个解码器能够将解码后的数据反馈到数据流中，那么它的输出将被标识为该密钥的值。它应该与id键遵循相同的规则。</td></tr><tr><td><strong><code>channels</code></strong></td><td>该密钥包含有关<strong>必须</strong>提供给该PD的通道(pin)的信息;没有他们，PD将无法工作。例如，SPI解码器必须知道哪个信道有时钟信号。该键包含一个通道条目的元组，其中每个条目都是一个Python dict，其键为id、name和desc。Example: <strong><code>&#123;&#39;id&#39;: &#39;rx&#39;, &#39;name&#39;: &#39;RX&#39;, &#39;desc&#39;: &#39;UART receive line&#39;&#125;</code></strong>.</td></tr><tr><td><strong><code>optional_channels</code></strong></td><td>PD可选的通道，但不是必须的。该键的格式与上面的通道键相同(dicts的元组)。如果相应的协议解码器没有可选通道，则允许该元组为空。</td></tr><tr><td><strong><code>options</code></strong></td><td>描述此解码器的选项的元组。每个元组条目都是一个Python dict，其键id、desc、缺省值和值。如果PD没有可选的通道，则此元组可以为空。Example: <strong><code>&#123;&#39;id&#39;: &#39;bitorder&#39;, &#39;desc&#39;: &#39;Bit order&#39;, &#39;default&#39;: &#39;msb-first&#39;, &#39;values&#39;: (&#39;msb-first&#39;, &#39;lsb-first&#39;)&#125;</code></strong>.</td></tr><tr><td><strong><code>annotations</code></strong></td><td>此协议解码器可以输出的注释类的列表。此列表的元素是由标识符字符串和可读的描述字符串组成的元组。标识符字符串可以在siglock -cli选项中用于选择特定的注释类型，因此不应该包含空白或特殊字符。</td></tr><tr><td><strong><code>annotation_rows</code></strong></td><td>注释行用于将多个注释类型分组在一起。这个列表的元素是三个元素元组，包括: 1.注释行ID(与其他ID的命名规则相同)。2.注释行的人类可读的名称&#x2F;描述字符串。3. 包含注释元组中注释类的索引的元组。<a href="https://sigrok.org/wiki/Protocol_decoder_HOWTO#annotations_.26_annotation_rows">示例参考</a></td></tr><tr><td><strong><code>binary</code></strong></td><td>此协议解码器可以输出的二进制输出类型列表，格式与**<code>annotations</code>**列表相同。</td></tr></tbody></table><h1 id="self-put"><a href="#self-put" class="headerlink" title="self.put( )"></a>self.put( )</h1><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p><strong>put(startsample, endsample, output_id, data)</strong></p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>startsample：开始的序号</p><p>endsample：结束的序号</p><p>output_id：取值看下表</p><p>data：根据output_id的不同数据也不同</p><table><thead><tr><th>output_id</th><th>funcation</th></tr></thead><tbody><tr><td><strong>OUTPUT_ANN</strong></td><td>注释信息</td></tr><tr><td><strong>OUTPUT_PYTHON</strong></td><td></td></tr><tr><td><strong>OUTPUT_BINARY</strong></td><td></td></tr><tr><td><strong>OUTPUT_META</strong></td><td></td></tr></tbody></table><ol><li><strong>OUTPUT_ANN</strong>：</li></ol><ul><li><p>这个东西在显示bit数据时会在信号上有小点点指示。</p></li><li><p>不同缩放级别显示不同内容<br>Example: <code>self.put(10, 20, self.out_ann, [4, [&#39;Start&#39;, &#39;St&#39;, &#39;S&#39;]])</code></p></li><li><p>data参数是一个包含两个项的Python列表。第一项是注释索引(由解码器中项的顺序决定)。第二个是注释字符串列表。字符串应该是相同注释文本的长版本和短版本(按长度排序，最长优先)，可以由前端根据缩放级别显示不同的注释文本。</p></li></ul><ol start="2"><li><strong>OUTPUT_PYTHON</strong> ：</li></ol><ul><li><p>输出特定格式的数据么？（ 数据内容本身完全依赖于各自的解码器，应该在其pd.py文件中记录。 ）</p><p>Example: <em><code>self.put(10, 20, self.out_python, [&#39;PACKET&#39;, [&#39;Foo&#39;, 19.7, [1, 2, 3], (&#39;bar&#39;, &#39;baz&#39;)]])</code></em> </p></li><li><p>数据参数是将传递给堆叠解码器的任意Python对象。格式和内容完全依赖于解码器。通常，包含各种内容的Python列表被传递给堆叠的PDs。</p></li></ul><ol start="3"><li><p><strong>OUTPUT_BINARY</strong>：</p><ul><li><p>输出数据0x55 0xaa等等（ 二进制格式的索引为4，发出的字节分别为0xfe、0x55、0xaa）</p><p> Example: <em><code>self.put(10, 20, self.out_binary, [4, b&#39;\xfe\x55\xaa&#39;])</code></em> </p></li><li><p>data参数是一个包含两个项的Python列表。第一项是二进制格式的索引(由解码器中项的顺序决定)。第二个是Python bytes对象。</p></li></ul></li><li><p><strong>OUTPUT_META</strong> ：</p></li></ol><ul><li><p>输出解码出来的数字（ 在本例中数据本身是一个浮点数）</p><p> Example: <em><code>self.put(10, 20, self.out_meta, 15.7)</code></em> </p></li><li><p>数据参数是特定类型的Python对象，在各自的register()函数中定义</p></li></ul><h1 id="self-wait"><a href="#self-wait" class="headerlink" title="self.wait()"></a>self.wait()</h1><p>这是协议解码器用来将查询发送到libsigrokdecode后端的API调用。<br>从PD的角度来看，这是一个阻塞呼叫。它将阻塞，直到在样本数据中找到指定的条件，然后才将控制权返回给PD。</p><h2 id="原型-1"><a href="#原型-1" class="headerlink" title="原型"></a>原型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">wait</span>(<span class="hljs-params">self, conds</span>):<br>    <span class="hljs-comment"># 1. 等待，直到conds中的一个或多个条件匹配.</span><br>    <span class="hljs-comment"># 2. 设置 self.samplenum ，匹配样本的绝对样本数.</span><br>    <span class="hljs-comment"># 3. 根据 self.matched 条件匹配.</span><br>    <span class="hljs-comment"># 4. 返回一个包含匹配样本的pin值的元组.</span><br></code></pre></td></tr></table></figure><h2 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h2><h3 id="空参"><a href="#空参" class="headerlink" title="空参"></a>空参</h3><p>如果完全不提供conds，或者它是一个空列表[]，或者它只是一个“空”条件{}，那么后端将直接跳到下一个示例。 （相当于直接进入下一个样本）</p><p><strong>Examples:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Don&#x27;t wait for any condition, just skip to the next sample.</span><br>pins = self.wait()<br>pins = self.wait([])<br>pins = self.wait(&#123;&#125;)<br>pins = self.wait(&#123;<span class="hljs-string">&#x27;skip&#x27;</span>: <span class="hljs-number">1</span>&#125;) <span class="hljs-comment"># Skip one sample, see below.</span><br></code></pre></td></tr></table></figure><h3 id="conds-引脚状态条件-上下沿"><a href="#conds-引脚状态条件-上下沿" class="headerlink" title="conds 引脚状态条件(上下沿)"></a><strong>conds</strong> 引脚状态条件(上下沿)</h3><table><thead><tr><th>Value</th><th>Describe</th></tr></thead><tbody><tr><td>‘<strong>l’</strong></td><td>Low pin value (logical 0)</td></tr><tr><td>‘h’</td><td>High pin value (logical 1)</td></tr><tr><td>‘r’</td><td>Rising edge</td></tr><tr><td>‘f’</td><td>Falling edge</td></tr><tr><td>‘e’</td><td>Either edge (rising or falling)</td></tr><tr><td>‘s’</td><td>稳定状态 Stable state, the opposite of ‘e’. That is, there was no edge and the current and previous pin value were both low (or both high).</td></tr><tr><td>other</td><td>任何其他值都会产生错误。</td></tr></tbody></table><p><strong>Examples:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Wait until pin 7 has a falling edge.</span><br>pins = self.wait(&#123;<span class="hljs-number">7</span>: <span class="hljs-string">&#x27;f&#x27;</span>&#125;)<br><br><span class="hljs-comment"># Wait until pin 3 has a rising edge “and” pin 4 is high at the same time.</span><br>pins = self.wait(&#123;<span class="hljs-number">3</span>: <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-number">4</span>: <span class="hljs-string">&#x27;h&#x27;</span>&#125;)<br><br><span class="hljs-comment"># Wait until pins 2-4 are low and pin 16 has any edge.</span><br>pins = self.wait(&#123;<span class="hljs-number">2</span>: <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-number">3</span>: <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-number">4</span>: <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-number">16</span>: <span class="hljs-string">&#x27;e&#x27;</span>&#125;)<br></code></pre></td></tr></table></figure><h3 id="conds-样品跳过条-样本数量"><a href="#conds-样品跳过条-样本数量" class="headerlink" title="conds 样品跳过条(样本数量)"></a><strong>conds</strong> 样品跳过条(样本数量)</h3><p>后端另一个常见的查询是，当解码器想要跳过一定数量的样本时，而不管样本值是什么(因为它们与当前的协议无关)。<br>这可以通过条件dict中的一个特殊键来实现— ‘<strong>skip’</strong> 。 ‘<strong>skip’</strong> 键的值是要跳过的样本的整数。</p><p>解码器也可以跳过一定的时间，通过使用采样来计算 ‘<strong>skip’</strong> 键的正确值。</p><p><strong>Examples:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Skip over the next 100 samples.</span><br>pins = self.wait(&#123;<span class="hljs-string">&#x27;skip&#x27;</span>: <span class="hljs-number">100</span>&#125;)<br><br><span class="hljs-comment"># Skip over the next 20ms of samples.</span><br>pins = self.wait(&#123;<span class="hljs-string">&#x27;skip&#x27;</span>: <span class="hljs-number">20</span> * (<span class="hljs-number">1000</span> / self.samplerate)&#125;)<br><br><span class="hljs-comment"># Skip half a bitwidth of samples (e.g. for UART).</span><br>self.halfbitwidth = <span class="hljs-built_in">int</span>((self.samplerate / self.options[<span class="hljs-string">&#x27;baudrate&#x27;</span>]) / <span class="hljs-number">2.0</span>)<br>pins = self.wait(&#123;<span class="hljs-string">&#x27;skip&#x27;</span>: self.halfbitwidth&#125;)<br></code></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">pins = self.wait(&#123;<span class="hljs-string">&#x27;skip&#x27;</span>: <span class="hljs-number">100</span>&#125;)  <span class="hljs-comment">#这里的pins是元组，</span><br>(pins,) = self.wait(&#123;<span class="hljs-string">&#x27;skip&#x27;</span>: <span class="hljs-number">100</span>&#125;)<span class="hljs-comment">#可以写成这样</span><br></code></pre></td></tr></table></figure><h1 id="self-skip"><a href="#self-skip" class="headerlink" title="self.skip()"></a>self.skip()</h1><p><strong>这个函数不知道怎么回事，用了会报错</strong></p><p>注意这下面的skip不是wait</p><p>在相同的条件下混合通道索引键和“跳过”键通常没有多大意义，然而，在不同的情况下，混合索引键和“跳过”键是非常合理的: </p><p>（下面的语句应该是  <code>((pin7 e)和(pin12 l))或(skip 10000)</code> ）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Wait until there&#x27;s</span><br><span class="hljs-comment"># a) an edge on pin 7 and a low state on pin 12, and/or</span><br><span class="hljs-comment"># b) 1000 samples passed by,</span><br><span class="hljs-comment"># whichever occurs first (both conditions could occur at the same time too).</span><br><span class="hljs-comment"># This is basically &quot;wait for an edge on pin 7 and a low state on pin 12,</span><br><span class="hljs-comment"># with a timeout of 1000 samples&quot;.</span><br>pins = self.skip((&#123;<span class="hljs-number">7</span>: <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-number">12</span>: <span class="hljs-string">&#x27;l&#x27;</span>&#125;, &#123;<span class="hljs-string">&#x27;skip&#x27;</span>: <span class="hljs-number">1000</span>&#125;))<br></code></pre></td></tr></table></figure><h1 id="self-matched"><a href="#self-matched" class="headerlink" title="self.matched"></a>self.matched</h1><p>当解码器通过<strong>self.wait（）</strong>请求前端等待多个条件时，当该调用返回时，PD仅知道<strong>至少一个</strong>条件已匹配。但是，在大多数情况下，它还需要知道<strong>哪些</strong>条件匹配（或不匹配）。</p><p>这是<strong>self.matched</strong>提供的信息。它是布尔值（<strong>True</strong>或<strong>False</strong>）的元组，始终包含与上次<strong>self.wait（）</strong>调用中存在的条件一样多的条目。对于每个条件，各自的布尔值表示此特定条件是否匹配。</p><p><strong>Example:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 等待，直到引脚9的上升边 或 引脚27的高状态(逻辑1)， 或 经过一定的“时间”(这里:跳过1000个样本)。这意味着有一个1000个样本的“超时”之后self.wait()将返回(不管其他条件如何)。</span><br>pins = self.wait([&#123;<span class="hljs-number">9</span>: <span class="hljs-string">&#x27;r&#x27;</span>&#125;, &#123;<span class="hljs-number">27</span>: <span class="hljs-string">&#x27;h&#x27;</span>&#125;, &#123;<span class="hljs-string">&#x27;skip&#x27;</span>: <span class="hljs-number">1000</span>&#125;])<br><br><span class="hljs-keyword">if</span> self.matched == (<span class="hljs-literal">True</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>):<br>    <span class="hljs-comment"># 前两个条件是同时匹配的。</span><br>    <span class="hljs-comment"># Pin 9 contains a rising edge and pin 27 is high.</span><br><span class="hljs-keyword">elif</span> self.matched == (<span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>):<br>    <span class="hljs-comment"># Rising edge on pin 9, pin 27 is guaranteed to not be high.</span><br><span class="hljs-keyword">elif</span> self.matched == (<span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>):<br>    <span class="hljs-comment"># Pin 27 is high, pin 9 is guaranteed to not be a rising edge.</span><br><span class="hljs-keyword">elif</span> self.matched == (<span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>):<br>    <span class="hljs-comment"># Pin 9 is not a rising edge, pin 27 is not high, but 1000 samples were skipped.</span><br><span class="hljs-keyword">elif</span> self.matched == (<span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">True</span>):<br>    <span class="hljs-comment"># Pin 9 is not a rising edge, pin 27 is high, and it just so happens that</span><br>    <span class="hljs-comment"># exactly 1000 samples were skipped.</span><br><span class="hljs-keyword">elif</span> self.matched == (<span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>):<br>    <span class="hljs-comment"># Bug, this cannot happen. self.wait() only returns upon &gt;= 1 matches.</span><br></code></pre></td></tr></table></figure><p>对于’skip’键&#x2F;值对self。如果达到指定数目的样本，则匹配的tuple将包含一个真值。 </p><p><strong>Example:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Wait for a falling edge on channel 18, or until 25000 samples passed by.</span><br>pins = self.wait([&#123;<span class="hljs-number">18</span>: <span class="hljs-string">&#x27;f&#x27;</span>&#125;, &#123;<span class="hljs-string">&#x27;skip&#x27;</span>: <span class="hljs-number">25000</span>&#125;])<br><br><span class="hljs-keyword">if</span> self.matched[<span class="hljs-number">0</span>]:<br>    <span class="hljs-comment"># Pin 18 has a falling edge.</span><br><span class="hljs-keyword">if</span> self.matched[<span class="hljs-number">1</span>]:<br>    <span class="hljs-comment"># 25000 samples were skipped.</span><br></code></pre></td></tr></table></figure><h1 id="self-samplenum"><a href="#self-samplenum" class="headerlink" title="self.samplenum"></a>self.samplenum</h1><p><em>self.samplenum 相当于一个指针，指示当前解码器解码的样本的位置</em></p><p> <strong>self.samplenum</strong>是一个特殊属性，对于协议解码器来说是只读的，并且只能由libsigrokdecode后端设置。 </p><p> <strong>self.samplenum</strong> 总是在最后一次self.wait()调用返回后的当前绝对样本号(从0开始)。 </p><h1 id="self-samplerate"><a href="#self-samplerate" class="headerlink" title="self.samplerate"></a>self.samplerate</h1><p>采样率</p><h1 id="self-has-channel"><a href="#self-has-channel" class="headerlink" title="self.has_channel"></a>self.has_channel</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#code1 </span><br>...<br>self.have_cs = self.has_channel(<span class="hljs-number">3</span>)<br>...<br><br><span class="hljs-comment">#code2</span><br>...<br><span class="hljs-keyword">if</span> self.have_cs <span class="hljs-keyword">and</span> (first <span class="hljs-keyword">or</span> (self.matched &amp; (<span class="hljs-number">0b1</span> &lt;&lt; self.have_cs))):<br>    ....<br>...<br></code></pre></td></tr></table></figure><p>self.has_channel返回的值似乎是对应通道的值，比如这里返回的应该是3.</p><h1 id="一些奇怪的问题"><a href="#一些奇怪的问题" class="headerlink" title="一些奇怪的问题"></a>一些奇怪的问题</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">xxxxx</span>(<span class="hljs-params">self</span>):<br>    logging.info(<span class="hljs-string">&#x27;----- xxx start -----&#x27;</span>)<br>    data = <span class="hljs-number">0</span><br>    bit_count = <span class="hljs-number">5</span><br><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        pin_state = self.wait( [&#123;<span class="hljs-number">0</span>: <span class="hljs-string">&#x27;r&#x27;</span>&#125;, &#123;<span class="hljs-string">&#x27;skip&#x27;</span>: self.freq_half_samp &#125;] )<br>        <span class="hljs-keyword">if</span>( self.matched &amp; (<span class="hljs-number">0b1</span> &lt;&lt; <span class="hljs-number">0</span>) ):        <span class="hljs-comment">#r</span><br>            self.LS_2 |= <span class="hljs-number">0b0</span> &lt;&lt; bit_count<br>            self.wait( [&#123;<span class="hljs-string">&#x27;skip&#x27;</span>: (self.bit_samp-self.freq_quarter_samp) &#125;] )<br>        <span class="hljs-keyword">else</span>:<br>            self.LS_2 |= <span class="hljs-number">0b1</span> &lt;&lt; bit_count<br>            self.wait( [&#123;<span class="hljs-string">&#x27;skip&#x27;</span>: (self.bit_samp-self.freq_half_samp) &#125;] )<br>        <span class="hljs-keyword">if</span>( bit_count == <span class="hljs-number">0</span> ):<br>            <span class="hljs-keyword">break</span><br>        bit_count -= <span class="hljs-number">1</span><br>    logging.info(<span class="hljs-string">&#x27;----- xxx end -----&#x27;</span>)<br>    <span class="hljs-keyword">return</span> data<br><br><br></code></pre></td></tr></table></figure><p>注意到<code>pin_state = self.wait( [&#123;0: &#39;r&#39;&#125;, &#123;&#39;skip&#39;: self.freq_half_samp &#125;] )</code>语句，把pin_state删掉就可以正常运行，若没删if后面的self.wait就会一直出问题。</p><ul><li>原因应该是pin_state没打括号，pin_state变成了元组，所以出现这种情况</li></ul><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="一些快速处理数据的方法"><a href="#一些快速处理数据的方法" class="headerlink" title="一些快速处理数据的方法"></a>一些快速处理数据的方法</h2><ul><li>快速计算奇偶校验</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ones = <span class="hljs-built_in">bin</span>(<span class="hljs-number">0x55</span>).count(<span class="hljs-string">&#x27;1&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li>BCD转成整数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">bcd2int</span>(<span class="hljs-params">b</span>):<br>    <span class="hljs-keyword">return</span> (b &amp; <span class="hljs-number">0x0f</span>) + ((b &gt;&gt; <span class="hljs-number">4</span>) * <span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><ul><li>一种将总线引脚序列转换为数字值的好方法：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">reduce_bus</span>(<span class="hljs-params">bus</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-number">0xFF</span> <span class="hljs-keyword">in</span> bus:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span> <span class="hljs-comment"># unassigned bus channels</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> reduce(<span class="hljs-keyword">lambda</span> a, b: (a &lt;&lt; <span class="hljs-number">1</span>) | b, <span class="hljs-built_in">reversed</span>(bus))<br></code></pre></td></tr></table></figure><ul><li>根据协议命令构造方法名的一个好方法是(假设cmd是8，这将调用self.handle_cmd_0x08函数):</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">fn = <span class="hljs-built_in">getattr</span>(self, <span class="hljs-string">&#x27;handle_cmd_0x%02x&#x27;</span> % cmd);<br>fn(arg1, arg2, ...)<br></code></pre></td></tr></table></figure><ul><li>一种处理Python缺少枚举类型(对状态、pin索引、注释索引等有用)的方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cycle</span>:<br>    NONE, MEMRD, MEMWR, IORD, IOWR, FETCH, INTACK = <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>)<br></code></pre></td></tr></table></figure>]]></content>
=======
    <title>code</title>
    <link href="/2022/08/77153098/"/>
    <url>/2022/08/77153098/</url>
    
    <content type="html"><![CDATA[<h2 id="HTML-XML"><a href="#HTML-XML" class="headerlink" title="HTML, XML"></a>HTML, XML</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"><span class="hljs-selector-tag">body</span> &#123;<span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;&#125;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;application/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">$init</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">checked</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;title&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;title&#x27;</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- here goes the rest of the page --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="Bash"><a href="#Bash" class="headerlink" title="Bash"></a>Bash</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment">#dfasdf</span><br><span class="hljs-comment">#中文字体</span><br><span class="hljs-comment">###### CONFIG</span><br>ACCEPTED_HOSTS=<span class="hljs-string">&quot;/root/.hag_accepted.conf&quot;</span><br>BE_VERBOSE=<span class="hljs-literal">false</span><br><br><span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$UID</span>&quot;</span> -ne 0 ]<br><span class="hljs-keyword">then</span><br> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Superuser rights required&quot;</span><br> <span class="hljs-built_in">exit</span> 2<br><span class="hljs-keyword">fi</span><br><br><span class="hljs-function"><span class="hljs-title">genApacheConf</span></span>()&#123;<br> <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;# Host <span class="hljs-variable">$&#123;HOME_DIR&#125;</span><span class="hljs-variable">$1</span>/<span class="hljs-variable">$2</span> :&quot;</span><br>&#125;<br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;&quot;quoted&quot;&#x27;</span> | <span class="hljs-built_in">tr</span> -d \&quot; &gt; text.txt<br></code></pre></td></tr></table></figure><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br><br>  <span class="hljs-comment">/* An annoying &quot;Hello World&quot; example */</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0xFFFF</span>; i++)<br>    cout &lt;&lt; <span class="hljs-string">&quot;Hello, World!&quot;</span> &lt;&lt; endl;<br><br>  <span class="hljs-type">char</span> c = <span class="hljs-string">&#x27;\n&#x27;</span>;<br>  unordered_map &lt;string, vector&lt;string&gt; &gt; m;<br>  m[<span class="hljs-string">&quot;key&quot;</span>] = <span class="hljs-string">&quot;\\\\&quot;</span>; <span class="hljs-comment">// this is an error</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-2e3</span> + <span class="hljs-number">12l</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="C-1"><a href="#C-1" class="headerlink" title="C#"></a>C#</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.IO.Compression;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> <span class="hljs-keyword">warning</span> disable 414, 3021</span><br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">MyApplication</span><br>&#123;<br>    [<span class="hljs-meta">Obsolete(<span class="hljs-string">&quot;...&quot;</span>)</span>]<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span> : <span class="hljs-title">IInterface</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-title">JustDoIt</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> count</span>)</span><br>        &#123;<br>            Span&lt;<span class="hljs-built_in">int</span>&gt; numbers = <span class="hljs-keyword">stackalloc</span> <span class="hljs-built_in">int</span>[length];<br>            Console.WriteLine(<span class="hljs-string">$&quot;Hello <span class="hljs-subst">&#123;Name&#125;</span>!&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[] &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@font-face</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: Chunkfive; <span class="hljs-attribute">src</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;Chunkfive.otf&#x27;</span>);<br>&#125;<br><br><span class="hljs-selector-tag">body</span>, <span class="hljs-selector-class">.usertext</span> &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#F0F0F0</span>; <span class="hljs-attribute">background</span>: <span class="hljs-number">#600</span>;<br>  <span class="hljs-attribute">font-family</span>: Chunkfive, sans;<br>  <span class="hljs-attr">--heading-1</span>: <span class="hljs-number">30px</span>/<span class="hljs-number">32px</span> Helvetica, sans-serif;<br>&#125;<br><br><span class="hljs-keyword">@import</span> url(print.css);<br><span class="hljs-keyword">@media</span> print &#123;<br>  <span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[href^=http]</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-built_in">attr</span>(href)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># hello world</span><br><br>you can write text [<span class="hljs-string">with links</span>](<span class="hljs-link">http://example.com</span>) inline or [<span class="hljs-string">link references</span>][<span class="hljs-symbol">1</span>].<br><br><span class="hljs-bullet">*</span> one <span class="hljs-emphasis">_thing_</span> has <span class="hljs-emphasis">*em*</span>phasis<br><span class="hljs-bullet">*</span> two <span class="hljs-strong">__things__</span> are <span class="hljs-strong">**bold**</span><br><br>[<span class="hljs-symbol">1</span>]: <span class="hljs-link">http://example.com</span><br><br>---<br><br><span class="hljs-section">hello world</span><br><span class="hljs-section">===========</span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">this_is</span> <span class="hljs-attr">inline</span>=<span class="hljs-string">&quot;xml&quot;</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">this_is</span>&gt;</span></span><br><br><span class="hljs-quote">&gt; markdown is so cool</span><br><br><span class="hljs-code">    so are code segments</span><br><span class="hljs-code"></span><br><span class="hljs-bullet">1.</span> one thing (yeah!)<br><span class="hljs-bullet">2.</span> two thing <span class="hljs-code">`i can write code`</span>, and <span class="hljs-code">`more`</span> wipee!<br></code></pre></td></tr></table></figure><h2 id="Diff"><a href="#Diff" class="headerlink" title="Diff"></a>Diff</h2><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-comment">Index: languages/ini.js</span><br><span class="hljs-comment">===================================================================</span><br><span class="hljs-comment">--- languages/ini.js    (revision 199)</span><br><span class="hljs-comment">+++ languages/ini.js    (revision 200)</span><br><span class="hljs-meta">@@ -1,8 +1,7 @@</span><br> hljs.LANGUAGES.ini =<br> &#123;<br>   case_insensitive: true,<br><span class="hljs-deletion">-  defaultMode:</span><br><span class="hljs-deletion">-  &#123;</span><br><span class="hljs-addition">+  defaultMode: &#123;</span><br>     contains: [&#x27;comment&#x27;, &#x27;title&#x27;, &#x27;setting&#x27;],<br>     illegal: &#x27;[^\\s]&#x27;<br>   &#125;,<br><br><span class="hljs-comment">*** /path/to/original timestamp</span><br><span class="hljs-comment">--- /path/to/new      timestamp</span><br><span class="hljs-comment">***************</span><br><span class="hljs-meta">*** 1,3 ****</span><br><span class="hljs-meta">--- 1,9 ----</span><br><span class="hljs-addition">+ This is an important</span><br><span class="hljs-addition">+ notice! It should</span><br><span class="hljs-addition">+ therefore be located at</span><br><span class="hljs-addition">+ the beginning of this</span><br><span class="hljs-addition">+ document!</span><br><br><span class="hljs-addition">! compress the size of the</span><br><span class="hljs-addition">! changes.</span><br><br>  It is important to spell<br></code></pre></td></tr></table></figure><h2 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-comment"># The Greeter class</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Greeter</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">initialize</span>(<span class="hljs-params">name</span>)<br>    <span class="hljs-variable">@name</span> = name.capitalize<br>  <span class="hljs-keyword">end</span><br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">salute</span><br>    puts <span class="hljs-string">&quot;Hello <span class="hljs-subst">#&#123;<span class="hljs-variable">@name</span>&#125;</span>!&quot;</span><br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br>g = <span class="hljs-title class_">Greeter</span>.new(<span class="hljs-string">&quot;world&quot;</span>)<br>g.salute<br></code></pre></td></tr></table></figure><h2 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">float64</span>)<br>    ch &lt;- <span class="hljs-number">1.0e10</span>    <span class="hljs-comment">// magic number</span><br>    x, ok := &lt;- ch<br>    <span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">`exitting now\`</span>)<br>    <span class="hljs-keyword">go</span> <span class="hljs-built_in">println</span>(<span class="hljs-built_in">len</span>(<span class="hljs-string">&quot;hello world!&quot;</span>))<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
>>>>>>> main
    
    
    <categories>
      
<<<<<<< HEAD
      <category>Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DSlogic</tag>
      
      <tag>逻辑分析仪</tag>
      
      <tag>Pyhton</tag>
      
      <tag>decoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>J-Link RTT的使用方法</title>
    <link href="/2022/08/18d811b/"/>
    <url>/2022/08/18d811b/</url>
    
    <content type="html"><![CDATA[<h1 id="J-Link-RTT-amp-JTrace"><a href="#J-Link-RTT-amp-JTrace" class="headerlink" title="J-Link RTT &amp; JTrace"></a>J-Link RTT &amp; JTrace</h1><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>Jlink可用直接输出调试信息，省去串口工具（配置麻烦+硬件接线乱+占用IO）</p><p>Jlink输出调试信息有两种</p><ul><li>Jlink的Trace</li><li>Jlink的RTT (Real Time Transfer)</li></ul><h2 id="Jlink-Trace"><a href="#Jlink-Trace" class="headerlink" title="Jlink Trace"></a>Jlink Trace</h2><hr><p>！！！待完善！！！</p><hr><p>MDK 环境下：</p><p><img src="/2022/08/18d811b/132307095276873.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ITM_Port8(n)    (*((volatile unsigned char *)(0xE0000000+4*n)))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ITM_Port16(n)   (*((volatile unsigned short*)(0xE0000000+4*n)))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ITM_Port32(n)   (*((volatile unsigned long *)(0xE0000000+4*n)))</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEMCR           (*((volatile unsigned long *)(0xE000EDFC)))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TRCENA          0x01000000</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fputc</span><span class="hljs-params">(<span class="hljs-type">int</span> ch, FILE *f)</span> <br>&#123;<br>  <span class="hljs-keyword">if</span> (DEMCR &amp; TRCENA) &#123;<br>    <span class="hljs-keyword">while</span> (ITM_Port32(<span class="hljs-number">0</span>) == <span class="hljs-number">0</span>);<br>    ITM_Port8(<span class="hljs-number">0</span>) = ch;<br>  &#125;<br>  <span class="hljs-keyword">return</span>(ch);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="RTT"><a href="#RTT" class="headerlink" title="RTT"></a>RTT</h2><p><a href="https://www.segger.com/products/debug-probes/j-link/technology/about-real-time-transfer/">Jlink RTT 官网资料</a></p><p>RTT其实原理就是读取RAM上某个Buff的数据，这个Buff可以通过RTT的CB(control block)找到。</p><h3 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h3><p>下载Jlink的工具后，安装后程序目录有Samples文件夹(default: C:\Program Files\SEGGER\JLink\Samples)，文件夹内就有RTT的源码。</p><ol><li>将源码的<code>RTT/</code>目录下 <code>SEGGER_RTT_Printf.c</code>  <code>SEGGER_RTT.c</code> 两个文件添加到工程里，并解决头文件包含问题。</li><li>看 <code>Examples/</code>目录下就有使用历程，移植到你的工程就好。可以参考<code>Main_RTT_InputEchoApp.c</code>和<code>Main_RTT_PrintfTest.c</code>。</li><li>打开 <code>J-Link RTT Viewer</code>软件，选择<code>Device</code>，输入<code>RTT Control Block</code>的地址connect即可。<ol><li><code>RTT Control Block</code>的地址可以输入RAM的范围让<code>J-Link RTT Viewer</code>软件自己去搜索。</li><li>也可手动输入，而RTT_V754a的<code>RTT Control Block</code>是<code>_SEGGER_RTT</code> 在<code> file:SEGGER_RTT.c line:279</code>。<img src="/2022/08/18d811b/image-20210917214218565.png" alt="image-20210917214218565"></li></ol></li><li>一顿操作下来正常就可以收到数据了。</li></ol><h3 id="RTT-源码"><a href="#RTT-源码" class="headerlink" title="RTT 源码"></a>RTT 源码</h3><h4 id="Included-files"><a href="#Included-files" class="headerlink" title="Included files"></a>Included files</h4><ul><li><code>RTT/</code><ul><li><code>SEGGER_RTT.c</code>               - RTT的主要模块。</li><li><code>SEGGER_RTT.h</code>               - RTT的主要模块。</li><li><code>SEGGER_RTT_ASM_ARMv7M.S</code>    - ARMv7M 的优化实现</li><li><code>SEGGER_RTT_Printf.c</code>        - (‘ SEGGER_RTT_Printf() ‘)的简单实现。</li></ul></li><li><code>Syscalls/</code><ul><li><code>SEGGER_RTT_Syscalls_*.c</code>    - <code>printf()</code> 重定向</li></ul></li><li><code>Config/</code><ul><li><code>SEGGER_RTT_Conf.h</code>          - RTT配置文件。</li></ul></li><li><code>Examples/</code><ul><li><code>Main_RTT_InputEchoApp.c</code>    - Example application which echoes input on Channel 0.</li><li><code>Main_RTT_MenuApp.c</code>         - Example application to demonstrate RTT bi-directional functionality.</li><li><code>Main_RTT_PrintfTest.c</code>      - Example application to test RTT’s simple printf implementation.</li><li><code>Main_RTT_SpeedTestApp.c</code>    - Example application to measure RTT performance. (Requires embOS)</li></ul></li></ul><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><table><thead><tr><th align="center">函数名称</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">SEGGER_RTT_Read()</td><td align="center">从输入缓冲区读取数据。</td></tr><tr><td align="center">SEGGER_RTT_Write()</td><td align="center">将数据写入输出缓冲区。</td></tr><tr><td align="center">SEGGER_RTT_WriteString()</td><td align="center">将\0结尾字符串写入输出缓冲区。</td></tr><tr><td align="center">SEGGER_RTT_printf()</td><td align="center">将格式化的字符串写入输出缓冲区。</td></tr><tr><td align="center">SEGGER_RTT_GetKey()</td><td align="center">从输入缓冲区 0 中获取一个字符。</td></tr><tr><td align="center">SEGGER_RTT_HasKey()</td><td align="center">检查输入缓冲区 0 中是否有字符可用。</td></tr><tr><td align="center">SEGGER_RTT_WaitKey()</td><td align="center">等待输入缓冲区 0 中的字符可用并获取它。</td></tr><tr><td align="center">SEGGER_RTT_ConfigUpBuffer()</td><td align="center">配置向上（输出）缓冲区。</td></tr><tr><td align="center">SEGGER_RTT_ConfigDownBuffer()</td><td align="center">配置向下（输入）缓冲区。</td></tr><tr><td align="center">SEGGER_RTT_Init()</td><td align="center">仅使用 RAM 目标时初始化 RTT 控制块结构。</td></tr><tr><td align="center">SEGGER_RTT_SetTerminal()</td><td align="center">将“虚拟”终端设置为通过 Write 和 WriteString 用于通道 0 上的输出。</td></tr><tr><td align="center">SEGGER_RTT_TerminalOut()</td><td align="center">通过“虚拟”终端发送以\0结尾的字符串。</td></tr></tbody></table><h3 id="RTT-软件"><a href="#RTT-软件" class="headerlink" title="RTT 软件"></a>RTT 软件</h3><p><img src="/2022/08/18d811b/image-20210918101414512.png" alt="image-20210918101414512"></p><ul><li><p><code>J-Link RTT Viewer</code>软件用的比较多</p></li><li><p><code>J-Link RTT Logger</code>软件可以将输出的数据保存到文件，并显示通信速率和通信数据量。</p></li><li><p><code>J-Link RTT Client</code>可以在调试的时候，充当客户端，输出数据。据说支持中文</p></li></ul><h3 id="note："><a href="#note：" class="headerlink" title="note："></a>note：</h3><ul><li>程序如果跑在RAM中，J-Link可能会错误地识别出init部分中的块，而不是数据部分中的实际块。为了防止这种情况，将SEGGER_RTT_IN_RAM的定义设置为1。现在，J-Link将在应用程序中调用第一个SEGGER_RTT函数之后找到正确的RTT缓冲区。建议在应用程序开始时调用SEGGER_RTT_Init()。</li></ul><h4 id="不同通道输出数据"><a href="#不同通道输出数据" class="headerlink" title="不同通道输出数据"></a>不同通道输出数据</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">SEGGER_RTT_TerminalOut(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;SEGGER_RTT_TerminalOut 0\r\n&quot;</span>);<br>SEGGER_RTT_TerminalOut(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;SEGGER_RTT_TerminalOut 1\r\n&quot;</span>);<br>SEGGER_RTT_TerminalOut(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;SEGGER_RTT_TerminalOut 2\r\n&quot;</span>);<br><br><br><br>SEGGER_RTT_SetTerminal(<span class="hljs-number">0</span>);<br>SEGGER_RTT_printf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;SEGGER_RTT_printf 0\r\n&quot;</span>);<br>SEGGER_RTT_SetTerminal(<span class="hljs-number">1</span>);<br>SEGGER_RTT_printf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;SEGGER_RTT_printf 1\r\n&quot;</span>);<br>SEGGER_RTT_SetTerminal(<span class="hljs-number">2</span>);<br>SEGGER_RTT_printf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;SEGGER_RTT_printf 2\r\n&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="输出带颜色的字符"><a href="#输出带颜色的字符" class="headerlink" title="输出带颜色的字符"></a>输出带颜色的字符</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Control sequences, based on ANSI.</span><br><span class="hljs-comment">// Can be used to control color, and clear the screen</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_RESET                <span class="hljs-string">&quot;\x1B[0m&quot;</span>         <span class="hljs-comment">// Reset to default colors</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_CLEAR                <span class="hljs-string">&quot;\x1B[2J&quot;</span>         <span class="hljs-comment">// Clear screen, reposition cursor to top left</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_BLACK           <span class="hljs-string">&quot;\x1B[2;30m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_RED             <span class="hljs-string">&quot;\x1B[2;31m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_GREEN           <span class="hljs-string">&quot;\x1B[2;32m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_YELLOW          <span class="hljs-string">&quot;\x1B[2;33m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_BLUE            <span class="hljs-string">&quot;\x1B[2;34m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_MAGENTA         <span class="hljs-string">&quot;\x1B[2;35m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_CYAN            <span class="hljs-string">&quot;\x1B[2;36m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_WHITE           <span class="hljs-string">&quot;\x1B[2;37m&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_BRIGHT_BLACK    <span class="hljs-string">&quot;\x1B[1;30m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_BRIGHT_RED      <span class="hljs-string">&quot;\x1B[1;31m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_BRIGHT_GREEN    <span class="hljs-string">&quot;\x1B[1;32m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_BRIGHT_YELLOW   <span class="hljs-string">&quot;\x1B[1;33m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_BRIGHT_BLUE     <span class="hljs-string">&quot;\x1B[1;34m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_BRIGHT_MAGENTA  <span class="hljs-string">&quot;\x1B[1;35m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_BRIGHT_CYAN     <span class="hljs-string">&quot;\x1B[1;36m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_BRIGHT_WHITE    <span class="hljs-string">&quot;\x1B[1;37m&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_BLACK             <span class="hljs-string">&quot;\x1B[24;40m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_RED               <span class="hljs-string">&quot;\x1B[24;41m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_GREEN             <span class="hljs-string">&quot;\x1B[24;42m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_YELLOW            <span class="hljs-string">&quot;\x1B[24;43m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_BLUE              <span class="hljs-string">&quot;\x1B[24;44m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_MAGENTA           <span class="hljs-string">&quot;\x1B[24;45m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_CYAN              <span class="hljs-string">&quot;\x1B[24;46m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_WHITE             <span class="hljs-string">&quot;\x1B[24;47m&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_BRIGHT_BLACK      <span class="hljs-string">&quot;\x1B[4;40m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_BRIGHT_RED        <span class="hljs-string">&quot;\x1B[4;41m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_BRIGHT_GREEN      <span class="hljs-string">&quot;\x1B[4;42m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_BRIGHT_YELLOW     <span class="hljs-string">&quot;\x1B[4;43m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_BRIGHT_BLUE       <span class="hljs-string">&quot;\x1B[4;44m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_BRIGHT_MAGENTA    <span class="hljs-string">&quot;\x1B[4;45m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_BRIGHT_CYAN       <span class="hljs-string">&quot;\x1B[4;46m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_BRIGHT_WHITE      <span class="hljs-string">&quot;\x1B[4;47m&quot;</span></span><br><br><br>SEGGER_RTT_WriteString(<span class="hljs-number">0</span>,RTT_CTRL_RESET<span class="hljs-string">&quot;Red: &quot;</span>\<br>                       RTT_CTRL_TEXT_RED<span class="hljs-string">&quot;This text is red.&quot;</span>\<br>                       RTT_CTRL_BG_BRIGHT_GREEN<span class="hljs-string">&quot;This background is green.\r\n&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="输入字符"><a href="#输入字符" class="headerlink" title="输入字符"></a>输入字符</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(SEGGER_RTT_HasKey())<br>&#123;<br>    <span class="hljs-type">char</span> r = SEGGER_RTT_GetKey();<br>    SEGGER_RTT_WriteString(<span class="hljs-number">0</span>,<span class="hljs-string">&quot;input:%c\r\n&quot;</span>, r);<br>&#125;<br><br><br><span class="hljs-keyword">if</span>(SEGGER_RTT_HasKey())<br>&#123;<br>    ReadNum = SEGGER_RTT_Read(<span class="hljs-number">0</span>,&amp;acIn[<span class="hljs-number">0</span>], <span class="hljs-keyword">sizeof</span>(acIn));<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">20</span>;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">0x0A</span> != acIn[i])<br>        &#123;<br>            ReadNum++;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    SEGGER_RTT_Write(<span class="hljs-number">0</span>,acIn,ReadNum);<br>    ReadNum=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(acIn,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(acIn));<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>J-Link</tag>
      
      <tag>RTT</tag>
      
      <tag>Serial</tag>
      
      <tag>Debug</tag>
      
      <tag>Jlink</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SourceInsigh中Qicker的使用</title>
    <link href="/2022/08/4ade0b2f/"/>
    <url>/2022/08/4ade0b2f/</url>
    
    <content type="html"><![CDATA[<h1 id="Qicker-em"><a href="#Qicker-em" class="headerlink" title="Qicker.em"></a>Qicker.em</h1><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ol><li><p>代码补全：</p><ul><li><p>wh：       while（）</p></li><li><p>if，ife，ifs：     if，if else， if elseif else</p></li><li><p>for：      for</p></li><li><p>fo：自动生成for语句与for命令相比它直接会定义循环变量</p></li></ul>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> ( ulI = <span class="hljs-number">0</span>; ulI &lt; # ; ulI++ )<br>&#123;<br>    UINT32_T ulI = <span class="hljs-number">0</span>;<br>    #<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>do: do while</li><li>switch：</li><li>case：</li><li>#ifd: #ifdef</li><li>#if：</li><li>cpp ：自动生成适用于c++的c原型说明定义</li><li>struct：</li><li>enum：</li></ul></li><li><p>添加文件头注释： 命令：fi 解释：file  </p></li><li><p>添加函数头注释（.h）： 命令：fi 解释：file </p></li><li><p>增加修改历史列表： 命令：hi （会报错）</p></li><li><p>根据（.c）生成（.h）文件：命令：hdn</p></li><li><p>添加函数说明注释： 命令：fu 解释： function  </p></li><li><p>添加单行注释：（<span style="color:red">不知道为什么没用</span>）</p><ul><li>命令：as 解释： add start    (添加之后 <code>/* add by zhangsan, 20140504, Mantis号:d, 原: */</code> ) </li><li>命令：ms 解释： modify start  (添加之后：<code>/ modify by zhangsan, 20140504, Mantis号:d, 原因: */</code>  ) </li><li>命令：ds 解释： delete start  (添加之后：<code>/ delete by zhangsan, 20140504, Mantis号:d, 原因: */</code>  )</li></ul></li><li><p>添加标记注释： </p><ul><li><p>命令：ab 解释： add begin    (添加之后：<code>/* add begin by zhangsan, 20140504, Mantis号:d 原因: */</code>) </p></li><li><p>命令：mb 解释： modify begin  (添加之后：<code>/* modify begin by zhangsan, 20140504, Mantis号:d 原因: */</code>) </p></li><li><p>命令：me 解释： modify end    (添加之后：<code>/* modify end by zhangsan, 20140504 */</code>)  </p></li><li><p>命令：db 解释： delete begin  (添加之后：<code>/* delete begin by zhangsan, 20140504, Mantis号:d 原因: */</code>) </p></li><li><p>命令：de 解释： delete end    (添加之后：<code>/* delete end by zhangsan, 20140504 */</code>)</p></li></ul></li><li><p>配置命令：</p></li></ol><ul><li>命令：co 解释：config （修改相关配置信息）</li></ul><p> 如何使用呢，以为整个文件添加注释为例，在源文件的任何地方输入命令 fi 之后直接按ctrl + enter(配置的快捷键)即可。</p><h2 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h2><p> source insight有很多宏可以用，这里介绍的宏是quicker.em这个宏，它是华为的一个员工写的，很实用。</p><ol><li><p>安装quicker.em宏</p><ul><li><p>打开base这个工程Project-&gt;Open Project，选择base工程，即可打开；</p></li><li><p>将宏文件quicker.em添加到该base工程中；</p></li><li><p>设置宏的快捷方式：Options-&gt;Key Assignments，找到Marco:AutoExpand,添加快捷键即可，一般推介用Ctrl+Enter组合键。</p></li></ul></li><li><p>HeaderFileCreate，这个宏功能用于自动创建一个.c文件的头文件。</p><p>使用方法：</p><ul><li>创建自定义快捷菜单Options-&gt;Menu Assignments，选择Macro:HeaderFileCreate这一项，将它添加到右边Menu项的Work下，然后点Insert插入，点OK即可。</li><li>打开该.c文件，在work栏就能看到我们刚才添加的自定义快捷菜单HeaderFileCreate，点击它，就自动生产头文件了。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
=======
      <category>misc</category>
>>>>>>> main
      
    </categories>
    
    
    <tags>
      
<<<<<<< HEAD
      <tag>SourceInsigh</tag>
      
      <tag>SI</tag>
      
      <tag>IDE</tag>
=======
      <tag>untagged</tag>
>>>>>>> main
      
    </tags>
    
  </entry>
  
  
  
  <entry>
<<<<<<< HEAD
    <title>Visual Studio</title>
    <link href="/2022/08/9be43835/"/>
    <url>/2022/08/9be43835/</url>
    
    <content type="html"><![CDATA[<h1 id="VSCode"><a href="#VSCode" class="headerlink" title="VSCode"></a>VSCode</h1><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul><li>格式化代码 【Shift】+【Alt】+F</li></ul><h2 id="多行编辑"><a href="#多行编辑" class="headerlink" title="多行编辑"></a>多行编辑</h2><ul><li><p><code>Ctrl+Alt+UpArrow</code> <code>Ctrl+Alt+DownArrow</code></p></li><li><p><code>Alt+Click</code> 鼠标点击多行编辑</p></li><li><p><code>Ctrl+Shift+L</code> 对应文本多行编辑</p></li></ul><h2 id="行操作"><a href="#行操作" class="headerlink" title="行操作"></a>行操作</h2><ul><li><code>Shift+Alt+UpArrow</code> <code>Shift+Alt+DownArrow</code> 复制当前行</li><li><code>Alt+UpArrow</code> <code>Alt+DownArrow</code> 移动当前行</li></ul><h2 id="工作区配置"><a href="#工作区配置" class="headerlink" title="工作区配置"></a>工作区配置</h2><h3 id="setting-json"><a href="#setting-json" class="headerlink" title="setting.json"></a>setting.json</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;files.exclude&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;**/out/**&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>    <span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="c-cpp-properties-json"><a href="#c-cpp-properties-json" class="headerlink" title="c_cpp_properties.json"></a>c_cpp_properties.json</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;configurations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Linux&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;includePath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;browse&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;limitSymbolsToIncludedHeaders&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;databaseFilename&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceRoot&#125;/.vscode/.browse.c_cpp.db&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;path&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                    <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span><br>                <span class="hljs-punctuation">]</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;defines&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;IN_PTCMD&quot;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;compilerPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/usr/bin/gcc&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;cStandard&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;gnu17&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;cppStandard&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;gnu++14&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;intelliSenseMode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;linux-gcc-x64&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;configurationProvider&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ms-vscode.makefile-tools&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">4</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><h2 id="无法goto-define"><a href="#无法goto-define" class="headerlink" title="无法goto define"></a>无法goto define</h2><p>VSCode 不知道是什么设置问题，在使用跳转功能时，经常只能跳转到头文件，使用 <code>Go to References</code> 也找不到定义位置，搞得索引起来很麻烦。</p><p>切换成 <code>C++ Intellisense</code> 后，发现可以得到不错的效果。<br><img src="/2022/08/9be43835/watermark.png" alt="在这里插入图片描述"><br>在安装过程中，需要注意以下事项：<br>【1】 需要 <code>GNU Global</code>(&gt;&#x3D;6.5) 的依赖项并添加进路径中。可以通过以下方式安装：</p><blockquote><p>  sudo apt install global</p></blockquote><p>安装之后可使用以下命令确认是否成功：</p><blockquote><p>  global –version<br>  <img src="/2022/08/9be43835/11f3ab43797b44d9a9746b0676881339.png" alt="在这里插入图片描述"></p></blockquote><p>【2】在 C&#x2F;C++ 项目的工作空间文件夹，运行以下命令：</p><blockquote><p>  gtags</p></blockquote><p>这将会产生下列三个文件：<code>GTAGS</code>, <code>GRTAGS</code>, <code>GPATHS</code>。 如果代码有修改，再次运行 <code>gtags</code> 来更新这些 tag 文件。</p>]]></content>
=======
    <title>Git</title>
    <link href="/2022/08/69c3279c/"/>
    <url>/2022/08/69c3279c/</url>
    
    <content type="html"><![CDATA[<h1 id="Git-Bref"><a href="#Git-Bref" class="headerlink" title="Git Bref"></a>Git Bref</h1><p><img src="/2022/08/69c3279c/1352126739_7909.jpg" alt="img"></p><ul><li><p><strong>工作区：</strong>就是你在电脑里能看到的目录。</p></li><li><p><strong>暂存区：</strong>英文叫 stage 或 index。一般存放在 <strong>.git</strong> 目录下的 index 文件（.git&#x2F;index）中，所以我们把暂存区有时也叫作索引（index）。</p></li><li><p><strong>版本库：</strong>工作区有一个隐藏目录 <strong>.git</strong>，这个不算工作区，而是 Git 的版本库。</p></li></ul><p><img src="/2022/08/69c3279c/git-command.jpg" alt="img"></p><ul><li>workspace：工作区</li><li>staging area：暂存区&#x2F;缓存区</li><li>local repository：版本库或本地仓库</li><li>remote repository：远程仓库</li></ul><h2 id="Git-Workflows"><a href="#Git-Workflows" class="headerlink" title="Git Workflows"></a>Git Workflows</h2><p><a href="https://www.atlassian.com/git/tutorials/comparing-workflows">https://www.atlassian.com/git/tutorials/comparing-workflows</a></p><h3 id="Centralized-集中工作流"><a href="#Centralized-集中工作流" class="headerlink" title="Centralized 集中工作流"></a>Centralized 集中工作流</h3><p><img src="/2022/08/69c3279c/01.svg" alt="git workflow | Central and local repositories"></p><h3 id="Feature-Branch-功能分支"><a href="#Feature-Branch-功能分支" class="headerlink" title="Feature Branch 功能分支"></a>Feature Branch 功能分支</h3><p><a href="https://www.atlassian.com/git/tutorials/comparing-workflows/feature-branch-workflow">https://www.atlassian.com/git/tutorials/comparing-workflows/feature-branch-workflow</a></p><h3 id="Gitflow"><a href="#Gitflow" class="headerlink" title="Gitflow"></a>Gitflow</h3><p><a href="https://nvie.com/posts/a-successful-git-branching-model/">https://nvie.com/posts/a-successful-git-branching-model/</a></p><p><img src="/2022/08/69c3279c/git-model@2x.png" alt="img"></p><p><img src="/2022/08/69c3279c/04-Hotfix-branches.svg" alt="Git 流程工作流 - 修补程序分支"></p><h3 id="Forking-分叉"><a href="#Forking-分叉" class="headerlink" title="Forking 分叉"></a>Forking 分叉</h3><p><a href="https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow">Forking Workflow</a>通常遵循基于<a href="https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow">Gitflow Workflow</a>的分支模型。这意味着完整的功能分支将用于合并到原始项目维护者的存储库中。结果是一个分布式工作流，它为大型有机团队（包括不受信任的第三方）安全地协作提供了一种灵活的方式。这也使其成为开源项目的理想工作流程。</p><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><h3 id="创建仓库命令"><a href="#创建仓库命令" class="headerlink" title="创建仓库命令"></a>创建仓库命令</h3><p>下表列出了 git 创建仓库的命令：</p><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git init</code></td><td align="left">初始化仓库</td></tr><tr><td align="left"><code>git clone</code></td><td align="left">拷贝一份远程仓库，也就是下载一个项目。</td></tr></tbody></table><hr><h3 id="提交与修改"><a href="#提交与修改" class="headerlink" title="提交与修改"></a>提交与修改</h3><p>Git 的工作就是创建和保存你的项目的快照及与之后的快照进行对比。</p><p>下表列出了有关创建与提交你的项目的快照的命令：</p><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git add</code></td><td align="left">添加文件到仓库</td></tr><tr><td align="left"><code>git status</code></td><td align="left">查看仓库当前的状态，显示有变更的文件。</td></tr><tr><td align="left"><code>git diff</code></td><td align="left">比较文件的不同，即暂存区和工作区的差异。</td></tr><tr><td align="left"><code>git commit</code></td><td align="left">提交暂存区到本地仓库。</td></tr><tr><td align="left"><code>git reset</code></td><td align="left">回退版本。</td></tr><tr><td align="left"><code>git rm</code></td><td align="left">删除工作区文件。</td></tr><tr><td align="left"><code>git mv</code></td><td align="left">移动或重命名工作区文件。</td></tr></tbody></table><h3 id="提交日志"><a href="#提交日志" class="headerlink" title="提交日志"></a>提交日志</h3><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git log</code></td><td align="left">查看历史提交记录</td></tr><tr><td align="left"><code>git blame &lt;file&gt;</code></td><td align="left">以列表形式查看指定文件的历史修改记录</td></tr></tbody></table><h3 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h3><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git remote</code></td><td align="left">远程仓库操作</td></tr><tr><td align="left"><code>git fetch</code></td><td align="left">从远程获取代码库</td></tr><tr><td align="left"><code>git pull</code></td><td align="left">下载远程代码并合并</td></tr><tr><td align="left"><code>git push</code></td><td align="left">上传远程代码并合并</td></tr></tbody></table><h1 id="基本命令详细"><a href="#基本命令详细" class="headerlink" title="基本命令详细"></a>基本命令详细</h1><h2 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h2><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>-d</td><td>–delete：删除</td></tr><tr><td>-D</td><td>–delete –force的快捷键</td></tr><tr><td>-f</td><td>–force：强制</td></tr><tr><td>-m</td><td>–move：移动或重命名</td></tr><tr><td>-M</td><td>–move –force的快捷键</td></tr><tr><td>-r</td><td>–remote：远程</td></tr><tr><td>-a</td><td>–all：所有</td></tr></tbody></table><h2 id="Git-配置"><a href="#Git-配置" class="headerlink" title="Git 配置"></a>Git 配置</h2><h3 id="查看配置"><a href="#查看配置" class="headerlink" title="查看配置"></a>查看配置</h3><p>列出当前配置：<code>git config --list</code></p><p>列出repository配置：<code>git config --local --list</code></p><p>列出全局配置：<code>git config --global --list</code></p><p>列出系统配置：<code>git config --system --list</code></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>配置用户名：<code>git config --global user.name &quot;your name&quot;</code></p><p>配置用户邮箱：<code>git config --global user.email &quot;youremail@github.com&quot;</code></p><h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs \">ssh-keygen -t rsa -C &quot;youremail@github.com&quot;<br></code></pre></td></tr></table></figure><p>执行命令后需要进行3次或4次确认：</p><ol><li>确认秘钥的保存路径（如果不需要改路径则直接回车）；</li><li>如果上一步置顶的保存路径下已经有秘钥文件，则需要确认是否覆盖（如果之前的秘钥不再需要则直接回车覆盖，如需要则手动拷贝到其他目录后再覆盖）；</li><li>创建密码（如果不需要密码则直接回车）；</li><li>确认密码；</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> ~/.ssh/id_rsa.pub<br></code></pre></td></tr></table></figure><h2 id="创建仓库命令-1"><a href="#创建仓库命令-1" class="headerlink" title="创建仓库命令"></a>创建仓库命令</h2><h3 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h3><p>初始化版本库</p><h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><p>远程git仓库复制项目：<code>git clone &lt;url&gt;</code></p><h2 id="提交日志-1"><a href="#提交日志-1" class="headerlink" title="提交日志"></a>提交日志</h2><h3 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h3><p><code>git log --graph --pretty=oneline --abbrev-commit</code>可以看到分支的合并情况，包括分支合并图(–graph)、一行显示(–pretty&#x3D;oneline)、提交校验码缩略(–abbrev-commit)显示：</p><table><thead><tr><th align="left">选项</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>-&lt;n&gt;</code></td><td align="left">仅显示最近的 n 条提交。</td></tr><tr><td align="left"><code>--since</code>, <code>--after</code></td><td align="left">仅显示指定时间之后的提交。</td></tr><tr><td align="left"><code>--until</code>, <code>--before</code></td><td align="left">仅显示指定时间之前的提交。</td></tr><tr><td align="left"><code>--author</code></td><td align="left">仅显示作者匹配指定字符串的提交。</td></tr><tr><td align="left"><code>--committer</code></td><td align="left">仅显示提交者匹配指定字符串的提交。</td></tr><tr><td align="left"><code>--grep</code></td><td align="left">仅显示提交说明中包含指定字符串的提交。</td></tr><tr><td align="left"><code>-S</code></td><td align="left">仅显示添加或删除内容匹配指定字符串的提交。</td></tr></tbody></table><h3 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h3><h3 id="git-blame"><a href="#git-blame" class="headerlink" title="git blame"></a>git blame</h3><p>如果要查看指定文件的修改记录可以使用 git blame 命令，格式如下：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">git blame &lt;<span class="hljs-built_in">file</span>&gt;<br></code></pre></td></tr></table></figure><p>git blame用来追溯一个指定文件的历史修改记录。它能显示任何文件中每行最后一次修改的提交记录。 所以，如果你在代码中看到一个有 bug 的方法，你可以使用 git blame 标注这个文件，查看哪一次提交引入了这行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">可以使用 -L 指定文件的行数范围：</span><br>git blame -L n1,n2 filename<br></code></pre></td></tr></table></figure><h2 id="远程操作-1"><a href="#远程操作-1" class="headerlink" title="远程操作"></a>远程操作</h2><h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><p><strong>git pull</strong> 命令用于从远程获取代码并合并本地的版本。</p><p><strong>git pull</strong> 其实就是 <strong>git fetch</strong> 和 <strong>git merge FETCH_HEAD</strong> 的简写。 命令格式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">git pull <span class="hljs-tag">&lt;<span class="hljs-name">远程主机名</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">远程分支名</span>&gt;</span>:<span class="hljs-tag">&lt;<span class="hljs-name">本地分支名</span>&gt;</span><br></code></pre></td></tr></table></figure><p>更新操作：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git pull</span><br><span class="hljs-attribute">git pull origin</span><br></code></pre></td></tr></table></figure><p>将远程主机 origin 的 master 分支拉取过来，与本地的 brantest 分支合并。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git pull origin <span class="hljs-literal">master</span>:brantest<br></code></pre></td></tr></table></figure><h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><p><strong>git push</strong> 命用于从将本地的分支版本上传到远程并合并。</p><p>命令格式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">git push <span class="hljs-tag">&lt;<span class="hljs-name">远程主机名</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">本地分支名</span>&gt;</span>:<span class="hljs-tag">&lt;<span class="hljs-name">远程分支名</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果本地分支名与远程分支名相同，则可以省略冒号：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">git push <span class="hljs-tag">&lt;<span class="hljs-name">远程主机名</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">本地分支名</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果本地版本与远程版本有差异，但又要强制推送可以使用 –force 参数：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> --force <span class="hljs-built_in">origin</span> master<br></code></pre></td></tr></table></figure><p>删除主机的分支可以使用 –delete 参数，以下命令表示删除 origin 主机的 master 分支，(慎用)：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> --<span class="hljs-built_in">delete</span> master<br></code></pre></td></tr></table></figure><h3 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote add origin your_first_git_address //将第一个git address命名为origin<br></code></pre></td></tr></table></figure><h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><table><thead><tr><th>参数</th><th></th></tr></thead><tbody><tr><td>\–-all</td><td>把所有文件添加到版本控制里面</td></tr><tr><td>.</td><td>--all 同</td></tr></tbody></table><h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><p>git commit </p><table><thead><tr><th>参数</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>-a</td><td>all</td><td>受版本控制的所有文件<br>注意，新加的文件（即没有被git系统管理的文件）是不能被提交到本地仓库的</td><td></td></tr><tr><td>-m</td><td>message</td><td>提交的注释</td><td>git commit -m “this first commit”</td></tr><tr><td>- - amend</td><td></td><td>修改上次提交的注释</td><td></td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -m <span class="hljs-string">&#x27;    // 在这里直接输入回车即可</span><br><span class="hljs-string">1、第一项改动      // 以下的这些真正的comment可以在其他文本编辑器中写好粘贴过来</span><br><span class="hljs-string">2、第二项</span><br><span class="hljs-string">&#x27;</span>                // 输入这个结尾单引号后，再输入回车即可完成本次commit的提交<br></code></pre></td></tr></table></figure><h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h3><table><thead><tr><th>argv</th><th></th><th></th></tr></thead><tbody><tr><td>-u</td><td>mode</td><td></td></tr><tr><td>-uno</td><td>- 不显示未跟踪的文件。</td><td></td></tr><tr><td>-unormal</td><td>- 显示未跟踪的文件和目录。</td><td></td></tr><tr><td>-uall</td><td>- 还显示未跟踪目录中的单个文件。</td><td></td></tr></tbody></table><p>查看那些被修改那些没被修改</p><h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><p>查看与版本差异</p><h3 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h3><table><thead><tr><th>参数</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>git checkout &lt;branch&gt;</td><td></td><td>切换分支</td><td></td></tr><tr><td>git checkou -b &lt;branch&gt;</td><td>build</td><td>创建并切换分支</td><td></td></tr><tr><td>git checkout –orphan &lt;branch&gt;</td><td></td><td>创建切换到孤立的分支</td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>git checkout – &lt;file&gt;</td><td></td><td>从Staged恢复文件<br>重置全部文件用<code>-- .</code></td><td></td></tr><tr><td>git checkout HEAD – &lt;file&gt;</td><td></td><td>从HEAD恢复文件<br>重置全部文件用<code>-- .</code></td><td></td></tr></tbody></table><h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h3><table><thead><tr><th>参数</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>git branch &lt;branch&gt;</td><td></td><td>创建分支</td><td></td></tr><tr><td>git branch -d &lt;branch&gt;</td><td>delete</td><td>删除分支</td><td></td></tr><tr><td>git branch -D &lt;branch&gt;</td><td></td><td>强制删除</td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>git branch (-m | -M) &lt;oldbranch&gt; &lt;newbranch&gt;</td><td></td><td>重命名分支</td><td></td></tr><tr><td>git branch</td><td></td><td>查看当前分支</td><td></td></tr></tbody></table><h3 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h3><table><thead><tr><th>参数</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>git tag</td><td></td><td>查看标签</td><td></td></tr><tr><td>git show</td><td></td><td>查看指定标签的信息</td><td></td></tr><tr><td>git tag &lt;tag name&gt; &lt;commit id&gt;</td><td></td><td>创建 tag</td><td></td></tr><tr><td>-a</td><td></td><td>指定标签名</td><td></td></tr><tr><td>-m</td><td></td><td>指定说明文字</td><td></td></tr><tr><td>-l</td><td></td><td>列出特定版本 git tag -l “v1.4.2.*”</td><td></td></tr><tr><td>-d</td><td></td><td>删除</td><td></td></tr><tr><td>git push origin &lt;tag name&gt;</td><td></td><td>推送某个标签到远程</td><td></td></tr><tr><td>git push origin –tags</td><td></td><td>推送全部尚未推送到远程的本地标签</td><td></td></tr></tbody></table><h3 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h3><p>变基 </p><p>注: 需要切换到分支的后面, 再完成变基</p><p>git checkout &lt;branch&gt;</p><p>git rebae -d &lt;master branch&gt;</p><h3 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h3><p><img src="/2022/08/69c3279c/1102222-20171213190644254-2099705216.png" alt="img"></p><table><thead><tr><th>参数</th><th></th></tr></thead><tbody><tr><td>git merge &lt;branch&gt;</td><td>将分支合并到当前分支</td></tr><tr><td>git merge –no-ff  &lt;branch&gt;</td><td>禁用 快速合并模式（Fast forward）</td></tr><tr><td>git merge –ff-only  &lt;branch&gt;</td><td>快速合并(快进)</td></tr><tr><td><code>git merge --abort</code></td><td>中止这一次提交的合并(当遇到冲突时)</td></tr></tbody></table><h3 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h3><table><thead><tr><th>参数</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>git stash</td><td></td><td>将当前未提交内容藏匿</td><td></td></tr><tr><td>git stash list</td><td></td><td>藏匿 list</td><td></td></tr><tr><td>git stash drop</td><td></td><td>删除 藏匿</td><td></td></tr><tr><td>git stash apply</td><td></td><td>恢复 藏匿</td><td></td></tr><tr><td>git stash pop</td><td></td><td>恢复并删除 藏匿</td><td></td></tr></tbody></table><h3 id="git-restore-重置文件"><a href="#git-restore-重置文件" class="headerlink" title="git restore 重置文件"></a>git restore 重置文件</h3><p>类似 git checkout – &lt;file&gt;     重置文件</p><p>git restore &lt;file&gt;撤销工作区的修改，从暂存区恢复至工作区，如果工作区没有则从版本库恢复至工作区。</p><p>git restore –staged &lt;file&gt;用作清除暂存区的文件，不影响工作区以及版本库中的文件</p><p><img src="/2022/08/69c3279c/542.png" alt="img"></p><h3 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h3><p><strong>原理：</strong> git revert是用于“反做”某一个版本，以达到撤销该版本的修改的目的。比如，我们 commit 了三个版本（版本一、版本二、 版本三），突然发现版本二不行（如：有bug），想要撤销版本二，但又不想影响撤销版本三的提交，就可以用 git revert 命令来反做版本二，生成新的版本四，这个版本四里会保留版本三的东西，但撤销了版本二的东西。如下图所示：</p><p><img src="/2022/08/69c3279c/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwNDE0MjA1ODE2MTg4.png" alt="这里写图片描述"></p><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><p><strong>原理：</strong> git reset的作用是修改HEAD的位置，即将HEAD指向的位置改变为之前存在的某个版本，如下图所示，假设我们要回退到版本一</p><p><img src="/2022/08/69c3279c/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwNDE0MjEyMjIxMDMz.png" alt="这里写图片描述"></p><p>在Git中，用<code>HEAD</code>表示当前版本</p><p>版本回退 HEAD往前回退一个版本(同理这里可以写对应的版本号) <code>git reset -–hard HEAD^</code></p><table><thead><tr><th>参数</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>–- hard</td><td></td><td>硬重置</td><td></td></tr><tr><td>–- soft</td><td></td><td></td><td></td></tr><tr><td>–- mixed</td><td></td><td></td><td></td></tr><tr><td>–- merge</td><td></td><td></td><td></td></tr><tr><td>–- keep</td><td></td><td></td><td></td></tr></tbody></table><h3 id="git-ignore"><a href="#git-ignore" class="headerlink" title="git - .ignore"></a>git - .ignore</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">此为注释 – 将被 Git 忽略</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">忽略所有 .a 结尾的文件</span><br>*.a<br><span class="hljs-meta prompt_"># </span><span class="language-bash">但 lib.a 除外</span><br>!lib.a<br><span class="hljs-meta prompt_"># </span><span class="language-bash">仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span><br>/TODO<br><span class="hljs-meta prompt_"># </span><span class="language-bash">忽略 build/ 目录下的所有文件</span><br>build/<br><span class="hljs-meta prompt_"># </span><span class="language-bash">会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span><br>doc/*.txt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">忽略 doc/ 目录下所有扩展名为 txt 的文件</span><br>doc/**/*.txt<br></code></pre></td></tr></table></figure><h3 id="git-switch"><a href="#git-switch" class="headerlink" title="git switch"></a>git switch</h3><p>git switch 切换分支 远程有而本地没有的分支，而如果要从远程分支建一个同名的本地分支，并且关联远程分支</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xquery">git <span class="hljs-keyword">switch</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">branchName</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>git switch 创建一个新分支并切换到该新分支 </p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">git <span class="hljs-keyword">switch</span> -<span class="hljs-keyword">c</span> &lt;branchName&gt;<br></code></pre></td></tr></table></figure><p>git switch 以一个提交commit来创建一个分支</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">git <span class="hljs-keyword">switch</span> -<span class="hljs-keyword">c</span> test<span class="hljs-number">3</span> e<span class="hljs-number">053</span>cf<span class="hljs-number">128</span>d<span class="hljs-number">2</span>ad<span class="hljs-number">9</span>d<span class="hljs-number">35e2</span>f<span class="hljs-number">94878569596</span>fb<span class="hljs-number">32</span>f<span class="hljs-number">4306</span><br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">操作</th><th align="left">2.23-</th><th align="left">2.23+</th></tr></thead><tbody><tr><td align="left">管理分支</td><td align="left">git branch</td><td align="left">git branch</td></tr><tr><td align="left">切换分支</td><td align="left">git checkout</td><td align="left">git switch</td></tr><tr><td align="left">新建+切换分支</td><td align="left">git checkout -b</td><td align="left">git switch -c</td></tr><tr><td align="left">切换到commit id</td><td align="left">git checkout</td><td align="left">git checkout</td></tr></tbody></table><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><h2 id="修改分支指针"><a href="#修改分支指针" class="headerlink" title="修改分支指针"></a>修改分支指针</h2><p>git branch -f 分支名 commitID</p><p>作用是将其他分支上的本地代码硬重置到某个commitId下，不能重置本分支。比如我dev分支上某个节点的commitId叫 devID1</p><p>然后 git branch -f master devID1<br>那么master上的代码就会和dev一样，并且历史记录也会一样，只是dev分支上的代码可能会比master上的新一点，因为是重置的commitId</p><h2 id="git-status-显示不了汉字"><a href="#git-status-显示不了汉字" class="headerlink" title="git status 显示不了汉字"></a>git status 显示不了汉字</h2><p>git bash 终端输入命令：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">git config --global core.quotepath <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>在git仓库文件夹内打开git bash，在git branch的界面中右击空白处，弹出菜单，选择option，编码设定为 gb2312。</p><h2 id="git-ssh-非标端口"><a href="#git-ssh-非标端口" class="headerlink" title="git ssh 非标端口"></a>git ssh 非标端口</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone ssh://git@hostname:port/…/xxx.git<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">e.g.</span><br>git clone ssh://git@192.168.20.220:10022/frank/tools.git<br></code></pre></td></tr></table></figure><h2 id="验证ssh链接"><a href="#验证ssh链接" class="headerlink" title="验证ssh链接"></a>验证ssh链接</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh -T git@github.com<br>ssh -T ssh://git@192.168.20.220:10022<br></code></pre></td></tr></table></figure><h2 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push origin --delete branch_name<br></code></pre></td></tr></table></figure><h2 id="删除全部历史提交记录"><a href="#删除全部历史提交记录" class="headerlink" title="删除全部历史提交记录"></a>删除全部历史提交记录</h2><ol><li>尝试  运行 <code> git checkout --orphan latest_branch</code></li><li>添加所有文件<code>git add -A</code></li><li>提交更改<code>git commit -am &quot;commit message&quot;</code></li><li>删除分支<code>git branch -D master</code></li><li>将当前分支重命名<code>git branch -m master</code></li><li>最后，强制更新存储库。<code>git push -f origin master</code></li></ol><h2 id="清理仓库"><a href="#清理仓库" class="headerlink" title="!清理仓库!"></a>!清理仓库!</h2><p>!谨慎操作! !谨慎操作! !谨慎操作! !谨慎操作! !谨慎操作!</p><ol><li>移除本地仓库中指向旧提交的剩余refs，<code>git for-each-ref</code> 会打印仓库中匹配<code>refs/original</code>的所有refs，并使用<code>delete</code>作为前缀，此命令通过管道传送到 <code>git update-ref</code> 命令，该命令会移除所有指向旧commit的引用。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git for-each-ref --format=<span class="hljs-string">&#x27;delete %(refname)&#x27;</span> refs/original | git update-ref --stdin<br></code></pre></td></tr></table></figure><ol start="2"><li>以下命令会使reflog到期，因为它依然包含着对旧commit的引用。使用<code>--expire=now</code> 参数，确保它在目前为止到期了。如果没有该参数，只会移除超过90天的reflog。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reflog expire --expire=now --all<br></code></pre></td></tr></table></figure><ol start="3"><li>现在本地仓库依然包含着所有旧commit的对象，但已经没有引用指向它们了，这些对象需要被删除掉。此时可以使用 <code>git gc</code> 命令，Git的垃圾回收器会删除这些没有引用指向的对象。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git gc --prune=now<br></code></pre></td></tr></table></figure><p>​<code>gc</code>使用<code>--prune</code> 参数来清理特定时期的对象，默认情况下为2周，指定<code>now</code>将删除所有这些对象而没有时期限制。</p><ol start="4"><li><code>du -sh .git</code>此时，.git文件的大小只有104k了。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">du</span> -sh .git<br><span class="hljs-comment"># 104K    .git</span><br></code></pre></td></tr></table></figure><ol start="5"><li>如果确认所做的删除大文件操作没有问题，就可以提交到远程仓库了，一旦提交，再也没有办法恢复到原来的状态，一定要小心谨慎！一定要小心谨慎！一定要小心谨慎！</li><li>先进行备份工作，以免出现问题：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/Desktop/<br><span class="hljs-built_in">mkdir</span> gitthin_mirror &amp;&amp; <span class="hljs-built_in">cd</span> gitthin_mirror<br>git <span class="hljs-built_in">clone</span> --mirror git@gitee.com:coderhony/gitthin.git<br></code></pre></td></tr></table></figure><ol start="7"><li>再回到刚才做的已经瘦身的Git仓库</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/Desktop/gitthin/gitthin<br></code></pre></td></tr></table></figure><ol start="8"><li>把已瘦身的仓库同步到远程仓库，使用<code>—mirror</code>参数：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push --mirror &lt;url&gt;<br></code></pre></td></tr></table></figure><ol start="9"><li>为了确保都已同步，再执行以下命令：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push --all --force<br><span class="hljs-comment"># Everything up-to-date</span><br>git push --tags --force<br><span class="hljs-comment"># Everything up-to-date</span><br></code></pre></td></tr></table></figure><h2 id="一台电脑两个Github账号"><a href="#一台电脑两个Github账号" class="headerlink" title="一台电脑两个Github账号"></a>一台电脑两个Github账号</h2><ul><li><p>生成两个ssh key</p></li><li><p>编辑config文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Default GitHub</span><br>Host github.com<br>HostName github.com<br>User git<br>IdentityFile ~/.ssh/id_rsa<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"> Jack-InGitHub!</span> <br>Host pq.github.com<br>HostName github.com<br>User git<br>IdentityFile ~/.ssh/id_rsa_a<br></code></pre></td></tr></table></figure><ul><li>github.com 用id_rsa密钥</li><li>pq.github.com 用id_rsa_a密钥</li></ul></li></ul><ul><li><p>原来<code>git@github.com:Jack-InGitHub/test.git</code></p><p>现在<code>git@pq.github.com:Jack-InGitHub/test.git</code></p></li><li><p>记得再配置不同的邮箱名</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --<span class="hljs-built_in">local</span> user.name <span class="hljs-string">&quot;username&quot;</span><br>git config --<span class="hljs-built_in">local</span> user.email user@email.com<br></code></pre></td></tr></table></figure><h2 id="利用管道删除全部本地分支"><a href="#利用管道删除全部本地分支" class="headerlink" title="利用管道删除全部本地分支"></a>利用管道删除全部本地分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout master<br>git branch | grep -v <span class="hljs-string">&#x27;master&#x27;</span> | xargs git branch -D<br></code></pre></td></tr></table></figure><h2 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h2><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment"># 把旧仓库被分成本地git文件目录</span><br>git <span class="hljs-keyword">clone</span> <span class="hljs-title">--mirror</span> 旧的git地址<br><br><span class="hljs-comment"># 推动本地目录到新的地址</span><br>cd xxx.git<br>git push --mirror 新的git地址<br><br><span class="hljs-comment"># 以上就完成了单个仓库的迁移</span><br></code></pre></td></tr></table></figure><h2 id="删除未追踪的文件"><a href="#删除未追踪的文件" class="headerlink" title="删除未追踪的文件"></a>删除未追踪的文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">git clean -f -d<br><span class="hljs-comment"># -d 递归清理</span><br><span class="hljs-comment"># -f = --force 强制清理</span><br>-d<br>    Normally, when no &lt;path&gt; is specified, git clean will not recurse into untracked directories to avoid removing too much. Specify -d to have it recurse into such directories as well. If any paths are specified, -d is irrelevant; all untracked files matching the specified paths (with exceptions <span class="hljs-keyword">for</span> nested git directories mentioned under --force) will be removed.<br><br>-f<br>    --force<br>    If the Git configuration variable clean.requireForce is not <span class="hljs-built_in">set</span> to <span class="hljs-literal">false</span>, git clean will refuse to delete files or directories unless given -f or -i. Git will refuse to modify untracked nested git repositories (directories with a .git subdirectory) unless a second -f is given.<br></code></pre></td></tr></table></figure>]]></content>
>>>>>>> main
    
    
    <categories>
      
      <category>Tools</category>
      
    </categories>
    
    
    <tags>
      
<<<<<<< HEAD
      <tag>IDE</tag>
      
      <tag>VSCode</tag>
=======
      <tag>Git</tag>
>>>>>>> main
      
    </tags>
    
  </entry>
  
  
  
  <entry>
<<<<<<< HEAD
    <title>手动添加JLink不支持的芯片</title>
    <link href="/2022/08/30f8332a/"/>
    <url>/2022/08/30f8332a/</url>
    
    <content type="html"><![CDATA[<h1 id="手动添加JLink不支持的芯片"><a href="#手动添加JLink不支持的芯片" class="headerlink" title="手动添加JLink不支持的芯片"></a>手动添加JLink不支持的芯片</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>市场上的新芯片层出不穷，JLink的官方支持不可能完全跟得上，这就尴尬了。但是好在Segger在设计时就想到了这一点，允许用户自己添加新芯片或扩展官方已经支持的芯片。本文只讲如何添加新芯片，参考的资料为<code>UM08001_JLink.pdf</code>中的第12章——<code>Open Flashloader</code>。</p><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p>在添加前，JFlash里找不到BARROT的任何型号，</p><p>添加后如下图</p><p><img src="/2022/08/30f8332a/image-20211019164827957.png" alt="image-20211019164827957"></p><h2 id="添加方法"><a href="#添加方法" class="headerlink" title="添加方法"></a>添加方法</h2><ul><li><p>找到Jlink安装目录下的<code>JLinkDevices.xml</code>并打开；</p></li><li><p>默认位置<code>C:\Program Files\SEGGER\JLink</code></p><p>在打开的文件添加如下内容，因为这个文件里没有任何BARROT的芯片，所以我添加到文件末尾，如果文件已经有同厂家的其它芯片，建议还是放一起，方便维护。效果和代码放下面了，代码的解释在后面！</p><p><img src="/2022/08/30f8332a/image-20211019164859196.png" alt="image-20211019164859196"></p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--                  --&gt;</span><br><span class="hljs-comment">&lt;!-- BARROT (BR8551) --&gt;</span><br><span class="hljs-comment">&lt;!--                  --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Device</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">ChipInfo</span> <span class="hljs-attr">Vendor</span>=<span class="hljs-string">&quot;BARROT&quot;</span> <span class="hljs-attr">Name</span>=<span class="hljs-string">&quot;BR8551&quot;</span> <span class="hljs-attr">Core</span>=<span class="hljs-string">&quot;JLINK_CORE_CORTEX_M3&quot;</span> <span class="hljs-attr">WorkRAMAddr</span>=<span class="hljs-string">&quot;0x2000C000&quot;</span> <span class="hljs-attr">WorkRAMSize</span>=<span class="hljs-string">&quot;0x00004000&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">FlashBankInfo</span> <span class="hljs-attr">Name</span>=<span class="hljs-string">&quot;ROM&quot;</span> <span class="hljs-attr">BaseAddr</span>=<span class="hljs-string">&quot;0x00000000&quot;</span> <span class="hljs-attr">MaxSize</span>=<span class="hljs-string">&quot;0x00060000&quot;</span> <span class="hljs-attr">Loader</span>=<span class="hljs-string">&quot;D:\\Project\\Panda\\Code\\bamboo\\panda\\tools\\Keil\\VFlash.FLM&quot;</span> <span class="hljs-attr">LoaderType</span>=<span class="hljs-string">&quot;FLASH_ALGO_TYPE_OPEN&quot;</span> <span class="hljs-attr">AlwaysPresent</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">FlashBankInfo</span> <span class="hljs-attr">Name</span>=<span class="hljs-string">&quot;LR_IROM1&quot;</span> <span class="hljs-attr">BaseAddr</span>=<span class="hljs-string">&quot;0x10000000&quot;</span> <span class="hljs-attr">MaxSize</span>=<span class="hljs-string">&quot;0x00080000&quot;</span> <span class="hljs-attr">Loader</span>=<span class="hljs-string">&quot;D:\\Project\\Panda\\Code\\bamboo\\panda\\tools\\Keil\\VFlash.FLM&quot;</span> <span class="hljs-attr">LoaderType</span>=<span class="hljs-string">&quot;FLASH_ALGO_TYPE_OPEN&quot;</span> <span class="hljs-attr">AlwaysPresent</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Device</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>保存文件就添加完了，可以验证是否如文章开头的效果一样</li></ul></li></ul><h2 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h2><ul><li>最开始的三行是注释，注释嘛，随便写了，清晰明了就行；</li><li><code>&lt;Device&gt;</code>和<code>&lt;/Device&gt;</code>必须成对出现，而且没有属性表。每个（系列）芯片都对应着这么一对。</li><li><code>ChipInfo</code>是描述芯片的信息，必须在 <code>&lt;Device&gt;</code>和<code>&lt;/Device&gt;</code>内。</li></ul><table><thead><tr><th align="center">参数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Vendor</td><td align="center">芯片厂家的名字，比如这里的”BARROT”</td></tr><tr><td align="center">Name</td><td align="center">芯片的具体型号，我用的就是BR8551</td></tr><tr><td align="center">Core</td><td align="center">芯片的内核，这个必须是JLink支持的内核之一，具体的名字可以在文档里的12.5.3.1    Attribute values - Core章节找到。</td></tr><tr><td align="center">WorkRAMAddr</td><td align="center">芯片RAM的起始地址，这个可以在用户手册里找到，也可以打开SDK里的官方例程，然后在工程配置里找到</td></tr><tr><td align="center">WorkRAMSize</td><td align="center">芯片RAM的大小，同样可以在用户手册里找到，也可以打开SDK里的官方例程，然后在工程配置里找到</td></tr><tr><td align="center">Aliases</td><td align="center">同系列的相同RAM和FLASH的型号</td></tr><tr><td align="center">JLinkScriptFile</td><td align="center">高级用法，有些芯片操作比较特殊，可以通过脚本去实现，这里我用不上</td></tr></tbody></table><hr><ul><li><code>FlashBankInfo</code>描述芯片的Flash信息，有多块flash的话，每块对应一个<code>FlashBankInfo</code>。</li></ul><table><thead><tr><th align="center">参数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Name</td><td align="center">flash的名字，名字可以随便起</td></tr><tr><td align="center">BaseAddr</td><td align="center">flash的起始地址，可以在用户手册里找到</td></tr><tr><td align="center">MaxSize</td><td align="center">flash的大小，可以在用户手册里找到</td></tr><tr><td align="center">Loader</td><td align="center">烧录的算法，segger官方的是*.elf格式，*.flm是ARM的格式，keil里就用这个。这个路径可以是绝对地址也可以是相对地址，相对地址的话是从<code>JLinkDevices.xml</code>所在的路径为起始地址。</td></tr><tr><td align="center">LoaderType</td><td align="center">必须是12.5.4.1    Attribute values - LoaderType中列出的类型之一，目前只有FLASH_ALGO_TYPE_OPEN一个类型，而*.flm是支持这个类型的</td></tr><tr><td align="center">AlwaysPresent</td><td align="center">指示这个块flash是不是一直存在，本文是内部flash，当然一直存在</td></tr></tbody></table><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/d7fae221ac47">工欲善其事，必先利其器：动手给JLink添加官方不支持的芯片</a></p>]]></content>
=======
    <title>test_title</title>
    <link href="/2022/08/20e8de60/"/>
    <url>/2022/08/20e8de60/</url>
    
    <content type="html"><![CDATA[<h1 id="adfasdfasdf"><a href="#adfasdfasdf" class="headerlink" title="adfasdfasdf"></a>adfasdfasdf</h1><p>adfasdfasdf</p><p>a</p><p>sdf</p><p>as</p><p>df</p><p>asd</p><p>fa</p><p>sdfwqer4654asd65f456qwe</p><p>dsga</p><p><img src="/2022/08/20e8de60/be68da1412fe63ebe27defc4fee43e02.png" alt="1587305726201"></p><img src="/2022/08/20e8de60/1620.png" class="" title="This is an example image">]]></content>
>>>>>>> main
    
    
    <categories>
      
<<<<<<< HEAD
      <category>Tools</category>
=======
      <category>misc</category>
>>>>>>> main
      
    </categories>
    
    
    <tags>
      
<<<<<<< HEAD
      <tag>J-Link</tag>
      
      <tag>Jlink</tag>
=======
      <tag>untagged</tag>
>>>>>>> main
      
    </tags>
    
  </entry>
  
  
  
  <entry>
<<<<<<< HEAD
    <title>Git</title>
    <link href="/2022/08/69c3279c/"/>
    <url>/2022/08/69c3279c/</url>
    
    <content type="html"><![CDATA[<h1 id="Git-Bref"><a href="#Git-Bref" class="headerlink" title="Git Bref"></a>Git Bref</h1><p><img src="/2022/08/69c3279c/1352126739_7909.jpg" alt="img"></p><ul><li><p><strong>工作区：</strong>就是你在电脑里能看到的目录。</p></li><li><p><strong>暂存区：</strong>英文叫 stage 或 index。一般存放在 <strong>.git</strong> 目录下的 index 文件（.git&#x2F;index）中，所以我们把暂存区有时也叫作索引（index）。</p></li><li><p><strong>版本库：</strong>工作区有一个隐藏目录 <strong>.git</strong>，这个不算工作区，而是 Git 的版本库。</p></li></ul><p><img src="/2022/08/69c3279c/git-command.jpg" alt="img"></p><ul><li>workspace：工作区</li><li>staging area：暂存区&#x2F;缓存区</li><li>local repository：版本库或本地仓库</li><li>remote repository：远程仓库</li></ul><h2 id="Git-Workflows"><a href="#Git-Workflows" class="headerlink" title="Git Workflows"></a>Git Workflows</h2><p><a href="https://www.atlassian.com/git/tutorials/comparing-workflows">https://www.atlassian.com/git/tutorials/comparing-workflows</a></p><h3 id="Centralized-集中工作流"><a href="#Centralized-集中工作流" class="headerlink" title="Centralized 集中工作流"></a>Centralized 集中工作流</h3><p><img src="/2022/08/69c3279c/01.svg" alt="git workflow | Central and local repositories"></p><h3 id="Feature-Branch-功能分支"><a href="#Feature-Branch-功能分支" class="headerlink" title="Feature Branch 功能分支"></a>Feature Branch 功能分支</h3><p><a href="https://www.atlassian.com/git/tutorials/comparing-workflows/feature-branch-workflow">https://www.atlassian.com/git/tutorials/comparing-workflows/feature-branch-workflow</a></p><h3 id="Gitflow"><a href="#Gitflow" class="headerlink" title="Gitflow"></a>Gitflow</h3><p><a href="https://nvie.com/posts/a-successful-git-branching-model/">https://nvie.com/posts/a-successful-git-branching-model/</a></p><p><img src="/2022/08/69c3279c/git-model@2x.png" alt="img"></p><p><img src="/2022/08/69c3279c/04-Hotfix-branches.svg" alt="Git 流程工作流 - 修补程序分支"></p><h3 id="Forking-分叉"><a href="#Forking-分叉" class="headerlink" title="Forking 分叉"></a>Forking 分叉</h3><p><a href="https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow">Forking Workflow</a>通常遵循基于<a href="https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow">Gitflow Workflow</a>的分支模型。这意味着完整的功能分支将用于合并到原始项目维护者的存储库中。结果是一个分布式工作流，它为大型有机团队（包括不受信任的第三方）安全地协作提供了一种灵活的方式。这也使其成为开源项目的理想工作流程。</p><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><h3 id="创建仓库命令"><a href="#创建仓库命令" class="headerlink" title="创建仓库命令"></a>创建仓库命令</h3><p>下表列出了 git 创建仓库的命令：</p><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git init</code></td><td align="left">初始化仓库</td></tr><tr><td align="left"><code>git clone</code></td><td align="left">拷贝一份远程仓库，也就是下载一个项目。</td></tr></tbody></table><hr><h3 id="提交与修改"><a href="#提交与修改" class="headerlink" title="提交与修改"></a>提交与修改</h3><p>Git 的工作就是创建和保存你的项目的快照及与之后的快照进行对比。</p><p>下表列出了有关创建与提交你的项目的快照的命令：</p><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git add</code></td><td align="left">添加文件到仓库</td></tr><tr><td align="left"><code>git status</code></td><td align="left">查看仓库当前的状态，显示有变更的文件。</td></tr><tr><td align="left"><code>git diff</code></td><td align="left">比较文件的不同，即暂存区和工作区的差异。</td></tr><tr><td align="left"><code>git commit</code></td><td align="left">提交暂存区到本地仓库。</td></tr><tr><td align="left"><code>git reset</code></td><td align="left">回退版本。</td></tr><tr><td align="left"><code>git rm</code></td><td align="left">删除工作区文件。</td></tr><tr><td align="left"><code>git mv</code></td><td align="left">移动或重命名工作区文件。</td></tr></tbody></table><h3 id="提交日志"><a href="#提交日志" class="headerlink" title="提交日志"></a>提交日志</h3><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git log</code></td><td align="left">查看历史提交记录</td></tr><tr><td align="left"><code>git blame &lt;file&gt;</code></td><td align="left">以列表形式查看指定文件的历史修改记录</td></tr></tbody></table><h3 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h3><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git remote</code></td><td align="left">远程仓库操作</td></tr><tr><td align="left"><code>git fetch</code></td><td align="left">从远程获取代码库</td></tr><tr><td align="left"><code>git pull</code></td><td align="left">下载远程代码并合并</td></tr><tr><td align="left"><code>git push</code></td><td align="left">上传远程代码并合并</td></tr></tbody></table><h1 id="基本命令详细"><a href="#基本命令详细" class="headerlink" title="基本命令详细"></a>基本命令详细</h1><h2 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h2><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>-d</td><td>–delete：删除</td></tr><tr><td>-D</td><td>–delete –force的快捷键</td></tr><tr><td>-f</td><td>–force：强制</td></tr><tr><td>-m</td><td>–move：移动或重命名</td></tr><tr><td>-M</td><td>–move –force的快捷键</td></tr><tr><td>-r</td><td>–remote：远程</td></tr><tr><td>-a</td><td>–all：所有</td></tr></tbody></table><h2 id="Git-配置"><a href="#Git-配置" class="headerlink" title="Git 配置"></a>Git 配置</h2><h3 id="查看配置"><a href="#查看配置" class="headerlink" title="查看配置"></a>查看配置</h3><p>列出当前配置：<code>git config --list</code></p><p>列出repository配置：<code>git config --local --list</code></p><p>列出全局配置：<code>git config --global --list</code></p><p>列出系统配置：<code>git config --system --list</code></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>配置用户名：<code>git config --global user.name &quot;your name&quot;</code></p><p>配置用户邮箱：<code>git config --global user.email &quot;youremail@github.com&quot;</code></p><h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs \">ssh-keygen -t rsa -C &quot;youremail@github.com&quot;<br></code></pre></td></tr></table></figure><p>执行命令后需要进行3次或4次确认：</p><ol><li>确认秘钥的保存路径（如果不需要改路径则直接回车）；</li><li>如果上一步置顶的保存路径下已经有秘钥文件，则需要确认是否覆盖（如果之前的秘钥不再需要则直接回车覆盖，如需要则手动拷贝到其他目录后再覆盖）；</li><li>创建密码（如果不需要密码则直接回车）；</li><li>确认密码；</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> ~/.ssh/id_rsa.pub<br></code></pre></td></tr></table></figure><h2 id="创建仓库命令-1"><a href="#创建仓库命令-1" class="headerlink" title="创建仓库命令"></a>创建仓库命令</h2><h3 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h3><p>初始化版本库</p><h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><p>远程git仓库复制项目：<code>git clone &lt;url&gt;</code></p><h2 id="提交日志-1"><a href="#提交日志-1" class="headerlink" title="提交日志"></a>提交日志</h2><h3 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h3><p><code>git log --graph --pretty=oneline --abbrev-commit</code>可以看到分支的合并情况，包括分支合并图(–graph)、一行显示(–pretty&#x3D;oneline)、提交校验码缩略(–abbrev-commit)显示：</p><table><thead><tr><th align="left">选项</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>-&lt;n&gt;</code></td><td align="left">仅显示最近的 n 条提交。</td></tr><tr><td align="left"><code>--since</code>, <code>--after</code></td><td align="left">仅显示指定时间之后的提交。</td></tr><tr><td align="left"><code>--until</code>, <code>--before</code></td><td align="left">仅显示指定时间之前的提交。</td></tr><tr><td align="left"><code>--author</code></td><td align="left">仅显示作者匹配指定字符串的提交。</td></tr><tr><td align="left"><code>--committer</code></td><td align="left">仅显示提交者匹配指定字符串的提交。</td></tr><tr><td align="left"><code>--grep</code></td><td align="left">仅显示提交说明中包含指定字符串的提交。</td></tr><tr><td align="left"><code>-S</code></td><td align="left">仅显示添加或删除内容匹配指定字符串的提交。</td></tr></tbody></table><h3 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h3><h3 id="git-blame"><a href="#git-blame" class="headerlink" title="git blame"></a>git blame</h3><p>如果要查看指定文件的修改记录可以使用 git blame 命令，格式如下：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">git blame &lt;<span class="hljs-built_in">file</span>&gt;<br></code></pre></td></tr></table></figure><p>git blame用来追溯一个指定文件的历史修改记录。它能显示任何文件中每行最后一次修改的提交记录。 所以，如果你在代码中看到一个有 bug 的方法，你可以使用 git blame 标注这个文件，查看哪一次提交引入了这行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">可以使用 -L 指定文件的行数范围：</span><br>git blame -L n1,n2 filename<br></code></pre></td></tr></table></figure><h2 id="远程操作-1"><a href="#远程操作-1" class="headerlink" title="远程操作"></a>远程操作</h2><h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><p><strong>git pull</strong> 命令用于从远程获取代码并合并本地的版本。</p><p><strong>git pull</strong> 其实就是 <strong>git fetch</strong> 和 <strong>git merge FETCH_HEAD</strong> 的简写。 命令格式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">git pull <span class="hljs-tag">&lt;<span class="hljs-name">远程主机名</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">远程分支名</span>&gt;</span>:<span class="hljs-tag">&lt;<span class="hljs-name">本地分支名</span>&gt;</span><br></code></pre></td></tr></table></figure><p>更新操作：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git pull</span><br><span class="hljs-attribute">git pull origin</span><br></code></pre></td></tr></table></figure><p>将远程主机 origin 的 master 分支拉取过来，与本地的 brantest 分支合并。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git pull origin <span class="hljs-literal">master</span>:brantest<br></code></pre></td></tr></table></figure><h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><p><strong>git push</strong> 命用于从将本地的分支版本上传到远程并合并。</p><p>命令格式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">git push <span class="hljs-tag">&lt;<span class="hljs-name">远程主机名</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">本地分支名</span>&gt;</span>:<span class="hljs-tag">&lt;<span class="hljs-name">远程分支名</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果本地分支名与远程分支名相同，则可以省略冒号：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">git push <span class="hljs-tag">&lt;<span class="hljs-name">远程主机名</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">本地分支名</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果本地版本与远程版本有差异，但又要强制推送可以使用 –force 参数：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> --force <span class="hljs-built_in">origin</span> master<br></code></pre></td></tr></table></figure><p>删除主机的分支可以使用 –delete 参数，以下命令表示删除 origin 主机的 master 分支，(慎用)：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> --<span class="hljs-built_in">delete</span> master<br></code></pre></td></tr></table></figure><h3 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote add origin your_first_git_address //将第一个git address命名为origin<br></code></pre></td></tr></table></figure><h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><table><thead><tr><th>参数</th><th></th></tr></thead><tbody><tr><td>\–-all</td><td>把所有文件添加到版本控制里面</td></tr><tr><td>.</td><td>--all 同</td></tr></tbody></table><h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><p>git commit </p><table><thead><tr><th>参数</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>-a</td><td>all</td><td>受版本控制的所有文件<br>注意，新加的文件（即没有被git系统管理的文件）是不能被提交到本地仓库的</td><td></td></tr><tr><td>-m</td><td>message</td><td>提交的注释</td><td>git commit -m “this first commit”</td></tr><tr><td>- - amend</td><td></td><td>修改上次提交的注释</td><td></td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -m <span class="hljs-string">&#x27;    // 在这里直接输入回车即可</span><br><span class="hljs-string">1、第一项改动      // 以下的这些真正的comment可以在其他文本编辑器中写好粘贴过来</span><br><span class="hljs-string">2、第二项</span><br><span class="hljs-string">&#x27;</span>                // 输入这个结尾单引号后，再输入回车即可完成本次commit的提交<br></code></pre></td></tr></table></figure><h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h3><table><thead><tr><th>argv</th><th></th><th></th></tr></thead><tbody><tr><td>-u</td><td>mode</td><td></td></tr><tr><td>-uno</td><td>- 不显示未跟踪的文件。</td><td></td></tr><tr><td>-unormal</td><td>- 显示未跟踪的文件和目录。</td><td></td></tr><tr><td>-uall</td><td>- 还显示未跟踪目录中的单个文件。</td><td></td></tr></tbody></table><p>查看那些被修改那些没被修改</p><h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><p>查看与版本差异</p><h3 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h3><table><thead><tr><th>参数</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>git checkout &lt;branch&gt;</td><td></td><td>切换分支</td><td></td></tr><tr><td>git checkou -b &lt;branch&gt;</td><td>build</td><td>创建并切换分支</td><td></td></tr><tr><td>git checkout –orphan &lt;branch&gt;</td><td></td><td>创建切换到孤立的分支</td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>git checkout – &lt;file&gt;</td><td></td><td>从Staged恢复文件<br>重置全部文件用<code>-- .</code></td><td></td></tr><tr><td>git checkout HEAD – &lt;file&gt;</td><td></td><td>从HEAD恢复文件<br>重置全部文件用<code>-- .</code></td><td></td></tr></tbody></table><h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h3><table><thead><tr><th>参数</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>git branch &lt;branch&gt;</td><td></td><td>创建分支</td><td></td></tr><tr><td>git branch -d &lt;branch&gt;</td><td>delete</td><td>删除分支</td><td></td></tr><tr><td>git branch -D &lt;branch&gt;</td><td></td><td>强制删除</td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>git branch (-m | -M) &lt;oldbranch&gt; &lt;newbranch&gt;</td><td></td><td>重命名分支</td><td></td></tr><tr><td>git branch</td><td></td><td>查看当前分支</td><td></td></tr></tbody></table><h3 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h3><table><thead><tr><th>参数</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>git tag</td><td></td><td>查看标签</td><td></td></tr><tr><td>git show</td><td></td><td>查看指定标签的信息</td><td></td></tr><tr><td>git tag &lt;tag name&gt; &lt;commit id&gt;</td><td></td><td>创建 tag</td><td></td></tr><tr><td>-a</td><td></td><td>指定标签名</td><td></td></tr><tr><td>-m</td><td></td><td>指定说明文字</td><td></td></tr><tr><td>-l</td><td></td><td>列出特定版本 git tag -l “v1.4.2.*”</td><td></td></tr><tr><td>-d</td><td></td><td>删除</td><td></td></tr><tr><td>git push origin &lt;tag name&gt;</td><td></td><td>推送某个标签到远程</td><td></td></tr><tr><td>git push origin –tags</td><td></td><td>推送全部尚未推送到远程的本地标签</td><td></td></tr></tbody></table><h3 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h3><p>变基 </p><p>注: 需要切换到分支的后面, 再完成变基</p><p>git checkout &lt;branch&gt;</p><p>git rebae -d &lt;master branch&gt;</p><h3 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h3><p><img src="/2022/08/69c3279c/1102222-20171213190644254-2099705216.png" alt="img"></p><table><thead><tr><th>参数</th><th></th></tr></thead><tbody><tr><td>git merge &lt;branch&gt;</td><td>将分支合并到当前分支</td></tr><tr><td>git merge –no-ff  &lt;branch&gt;</td><td>禁用 快速合并模式（Fast forward）</td></tr><tr><td>git merge –ff-only  &lt;branch&gt;</td><td>快速合并(快进)</td></tr><tr><td><code>git merge --abort</code></td><td>中止这一次提交的合并(当遇到冲突时)</td></tr></tbody></table><h3 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h3><table><thead><tr><th>参数</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>git stash</td><td></td><td>将当前未提交内容藏匿</td><td></td></tr><tr><td>git stash list</td><td></td><td>藏匿 list</td><td></td></tr><tr><td>git stash drop</td><td></td><td>删除 藏匿</td><td></td></tr><tr><td>git stash apply</td><td></td><td>恢复 藏匿</td><td></td></tr><tr><td>git stash pop</td><td></td><td>恢复并删除 藏匿</td><td></td></tr></tbody></table><h3 id="git-restore-重置文件"><a href="#git-restore-重置文件" class="headerlink" title="git restore 重置文件"></a>git restore 重置文件</h3><p>类似 git checkout – &lt;file&gt;     重置文件</p><p>git restore &lt;file&gt;撤销工作区的修改，从暂存区恢复至工作区，如果工作区没有则从版本库恢复至工作区。</p><p>git restore –staged &lt;file&gt;用作清除暂存区的文件，不影响工作区以及版本库中的文件</p><p><img src="/2022/08/69c3279c/542.png" alt="img"></p><h3 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h3><p><strong>原理：</strong> git revert是用于“反做”某一个版本，以达到撤销该版本的修改的目的。比如，我们 commit 了三个版本（版本一、版本二、 版本三），突然发现版本二不行（如：有bug），想要撤销版本二，但又不想影响撤销版本三的提交，就可以用 git revert 命令来反做版本二，生成新的版本四，这个版本四里会保留版本三的东西，但撤销了版本二的东西。如下图所示：</p><p><img src="/2022/08/69c3279c/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwNDE0MjA1ODE2MTg4.png" alt="这里写图片描述"></p><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><p><strong>原理：</strong> git reset的作用是修改HEAD的位置，即将HEAD指向的位置改变为之前存在的某个版本，如下图所示，假设我们要回退到版本一</p><p><img src="/2022/08/69c3279c/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwNDE0MjEyMjIxMDMz.png" alt="这里写图片描述"></p><p>在Git中，用<code>HEAD</code>表示当前版本</p><p>版本回退 HEAD往前回退一个版本(同理这里可以写对应的版本号) <code>git reset -–hard HEAD^</code></p><table><thead><tr><th>参数</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>–- hard</td><td></td><td>硬重置</td><td></td></tr><tr><td>–- soft</td><td></td><td></td><td></td></tr><tr><td>–- mixed</td><td></td><td></td><td></td></tr><tr><td>–- merge</td><td></td><td></td><td></td></tr><tr><td>–- keep</td><td></td><td></td><td></td></tr></tbody></table><h3 id="git-ignore"><a href="#git-ignore" class="headerlink" title="git - .ignore"></a>git - .ignore</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">此为注释 – 将被 Git 忽略</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">忽略所有 .a 结尾的文件</span><br>*.a<br><span class="hljs-meta prompt_"># </span><span class="language-bash">但 lib.a 除外</span><br>!lib.a<br><span class="hljs-meta prompt_"># </span><span class="language-bash">仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span><br>/TODO<br><span class="hljs-meta prompt_"># </span><span class="language-bash">忽略 build/ 目录下的所有文件</span><br>build/<br><span class="hljs-meta prompt_"># </span><span class="language-bash">会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span><br>doc/*.txt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">忽略 doc/ 目录下所有扩展名为 txt 的文件</span><br>doc/**/*.txt<br></code></pre></td></tr></table></figure><h3 id="git-switch"><a href="#git-switch" class="headerlink" title="git switch"></a>git switch</h3><p>git switch 切换分支 远程有而本地没有的分支，而如果要从远程分支建一个同名的本地分支，并且关联远程分支</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xquery">git <span class="hljs-keyword">switch</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">branchName</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>git switch 创建一个新分支并切换到该新分支 </p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">git <span class="hljs-keyword">switch</span> -<span class="hljs-keyword">c</span> &lt;branchName&gt;<br></code></pre></td></tr></table></figure><p>git switch 以一个提交commit来创建一个分支</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">git <span class="hljs-keyword">switch</span> -<span class="hljs-keyword">c</span> test<span class="hljs-number">3</span> e<span class="hljs-number">053</span>cf<span class="hljs-number">128</span>d<span class="hljs-number">2</span>ad<span class="hljs-number">9</span>d<span class="hljs-number">35e2</span>f<span class="hljs-number">94878569596</span>fb<span class="hljs-number">32</span>f<span class="hljs-number">4306</span><br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">操作</th><th align="left">2.23-</th><th align="left">2.23+</th></tr></thead><tbody><tr><td align="left">管理分支</td><td align="left">git branch</td><td align="left">git branch</td></tr><tr><td align="left">切换分支</td><td align="left">git checkout</td><td align="left">git switch</td></tr><tr><td align="left">新建+切换分支</td><td align="left">git checkout -b</td><td align="left">git switch -c</td></tr><tr><td align="left">切换到commit id</td><td align="left">git checkout</td><td align="left">git checkout</td></tr></tbody></table><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><h2 id="修改分支指针"><a href="#修改分支指针" class="headerlink" title="修改分支指针"></a>修改分支指针</h2><p>git branch -f 分支名 commitID</p><p>作用是将其他分支上的本地代码硬重置到某个commitId下，不能重置本分支。比如我dev分支上某个节点的commitId叫 devID1</p><p>然后 git branch -f master devID1<br>那么master上的代码就会和dev一样，并且历史记录也会一样，只是dev分支上的代码可能会比master上的新一点，因为是重置的commitId</p><h2 id="git-status-显示不了汉字"><a href="#git-status-显示不了汉字" class="headerlink" title="git status 显示不了汉字"></a>git status 显示不了汉字</h2><p>git bash 终端输入命令：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">git config --global core.quotepath <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>在git仓库文件夹内打开git bash，在git branch的界面中右击空白处，弹出菜单，选择option，编码设定为 gb2312。</p><h2 id="git-ssh-非标端口"><a href="#git-ssh-非标端口" class="headerlink" title="git ssh 非标端口"></a>git ssh 非标端口</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone ssh://git@hostname:port/…/xxx.git<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">e.g.</span><br>git clone ssh://git@192.168.20.220:10022/frank/tools.git<br></code></pre></td></tr></table></figure><h2 id="验证ssh链接"><a href="#验证ssh链接" class="headerlink" title="验证ssh链接"></a>验证ssh链接</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh -T git@github.com<br>ssh -T ssh://git@192.168.20.220:10022<br></code></pre></td></tr></table></figure><h2 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push origin --delete branch_name<br></code></pre></td></tr></table></figure><h2 id="删除全部历史提交记录"><a href="#删除全部历史提交记录" class="headerlink" title="删除全部历史提交记录"></a>删除全部历史提交记录</h2><ol><li>尝试  运行 <code> git checkout --orphan latest_branch</code></li><li>添加所有文件<code>git add -A</code></li><li>提交更改<code>git commit -am &quot;commit message&quot;</code></li><li>删除分支<code>git branch -D master</code></li><li>将当前分支重命名<code>git branch -m master</code></li><li>最后，强制更新存储库。<code>git push -f origin master</code></li></ol><h2 id="清理仓库"><a href="#清理仓库" class="headerlink" title="!清理仓库!"></a>!清理仓库!</h2><p>!谨慎操作! !谨慎操作! !谨慎操作! !谨慎操作! !谨慎操作!</p><ol><li>移除本地仓库中指向旧提交的剩余refs，<code>git for-each-ref</code> 会打印仓库中匹配<code>refs/original</code>的所有refs，并使用<code>delete</code>作为前缀，此命令通过管道传送到 <code>git update-ref</code> 命令，该命令会移除所有指向旧commit的引用。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git for-each-ref --format=<span class="hljs-string">&#x27;delete %(refname)&#x27;</span> refs/original | git update-ref --stdin<br></code></pre></td></tr></table></figure><ol start="2"><li>以下命令会使reflog到期，因为它依然包含着对旧commit的引用。使用<code>--expire=now</code> 参数，确保它在目前为止到期了。如果没有该参数，只会移除超过90天的reflog。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reflog expire --expire=now --all<br></code></pre></td></tr></table></figure><ol start="3"><li>现在本地仓库依然包含着所有旧commit的对象，但已经没有引用指向它们了，这些对象需要被删除掉。此时可以使用 <code>git gc</code> 命令，Git的垃圾回收器会删除这些没有引用指向的对象。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git gc --prune=now<br></code></pre></td></tr></table></figure><p>​<code>gc</code>使用<code>--prune</code> 参数来清理特定时期的对象，默认情况下为2周，指定<code>now</code>将删除所有这些对象而没有时期限制。</p><ol start="4"><li><code>du -sh .git</code>此时，.git文件的大小只有104k了。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">du</span> -sh .git<br><span class="hljs-comment"># 104K    .git</span><br></code></pre></td></tr></table></figure><ol start="5"><li>如果确认所做的删除大文件操作没有问题，就可以提交到远程仓库了，一旦提交，再也没有办法恢复到原来的状态，一定要小心谨慎！一定要小心谨慎！一定要小心谨慎！</li><li>先进行备份工作，以免出现问题：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/Desktop/<br><span class="hljs-built_in">mkdir</span> gitthin_mirror &amp;&amp; <span class="hljs-built_in">cd</span> gitthin_mirror<br>git <span class="hljs-built_in">clone</span> --mirror git@gitee.com:coderhony/gitthin.git<br></code></pre></td></tr></table></figure><ol start="7"><li>再回到刚才做的已经瘦身的Git仓库</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/Desktop/gitthin/gitthin<br></code></pre></td></tr></table></figure><ol start="8"><li>把已瘦身的仓库同步到远程仓库，使用<code>—mirror</code>参数：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push --mirror &lt;url&gt;<br></code></pre></td></tr></table></figure><ol start="9"><li>为了确保都已同步，再执行以下命令：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push --all --force<br><span class="hljs-comment"># Everything up-to-date</span><br>git push --tags --force<br><span class="hljs-comment"># Everything up-to-date</span><br></code></pre></td></tr></table></figure><h2 id="一台电脑两个Github账号"><a href="#一台电脑两个Github账号" class="headerlink" title="一台电脑两个Github账号"></a>一台电脑两个Github账号</h2><ul><li><p>生成两个ssh key</p></li><li><p>编辑config文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Default GitHub</span><br>Host github.com<br>HostName github.com<br>User git<br>IdentityFile ~/.ssh/id_rsa<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"> Jack-InGitHub!</span> <br>Host pq.github.com<br>HostName github.com<br>User git<br>IdentityFile ~/.ssh/id_rsa_a<br></code></pre></td></tr></table></figure><ul><li>github.com 用id_rsa密钥</li><li>pq.github.com 用id_rsa_a密钥</li></ul></li></ul><ul><li><p>原来<code>git@github.com:Jack-InGitHub/test.git</code></p><p>现在<code>git@pq.github.com:Jack-InGitHub/test.git</code></p></li><li><p>记得再配置不同的邮箱名</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --<span class="hljs-built_in">local</span> user.name <span class="hljs-string">&quot;username&quot;</span><br>git config --<span class="hljs-built_in">local</span> user.email user@email.com<br></code></pre></td></tr></table></figure><h2 id="利用管道删除全部本地分支"><a href="#利用管道删除全部本地分支" class="headerlink" title="利用管道删除全部本地分支"></a>利用管道删除全部本地分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout master<br>git branch | grep -v <span class="hljs-string">&#x27;master&#x27;</span> | xargs git branch -D<br></code></pre></td></tr></table></figure><h2 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h2><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment"># 把旧仓库被分成本地git文件目录</span><br>git <span class="hljs-keyword">clone</span> <span class="hljs-title">--mirror</span> 旧的git地址<br><br><span class="hljs-comment"># 推动本地目录到新的地址</span><br>cd xxx.git<br>git push --mirror 新的git地址<br><br><span class="hljs-comment"># 以上就完成了单个仓库的迁移</span><br></code></pre></td></tr></table></figure><h2 id="删除未追踪的文件"><a href="#删除未追踪的文件" class="headerlink" title="删除未追踪的文件"></a>删除未追踪的文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">git clean -f -d<br><span class="hljs-comment"># -d 递归清理</span><br><span class="hljs-comment"># -f = --force 强制清理</span><br>-d<br>    Normally, when no &lt;path&gt; is specified, git clean will not recurse into untracked directories to avoid removing too much. Specify -d to have it recurse into such directories as well. If any paths are specified, -d is irrelevant; all untracked files matching the specified paths (with exceptions <span class="hljs-keyword">for</span> nested git directories mentioned under --force) will be removed.<br><br>-f<br>    --force<br>    If the Git configuration variable clean.requireForce is not <span class="hljs-built_in">set</span> to <span class="hljs-literal">false</span>, git clean will refuse to delete files or directories unless given -f or -i. Git will refuse to modify untracked nested git repositories (directories with a .git subdirectory) unless a second -f is given.<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
=======
    <title>Hello World</title>
    <link href="/2022/08/4a17b156/"/>
    <url>/2022/08/4a17b156/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
>>>>>>> main
    
  </entry>
  
  
  
  <entry>
    <title>字符集和字符编码</title>
    <link href="/2022/08/438d1de3/"/>
    <url>/2022/08/438d1de3/</url>
    
    <content type="html"><![CDATA[<h1 id="字符集和字符编码"><a href="#字符集和字符编码" class="headerlink" title="字符集和字符编码"></a>字符集和字符编码</h1><p><a href="https://www.cnblogs.com/skynet/archive/2011/05/03/2035105.html">字符集和字符编码 (Charset &amp; Encoding)</a></p><p><a href="http://www.knowsky.com/resource/gb2312tbl.htm">GB2312简体中文编码表</a></p><p><a href="http://tools.jb51.net/table/gb2312">GB2312简体中文编码表</a></p><p><a href="https://www.unicode.org/charts/">Unicode码查询</a></p><p><a href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84">Unicode字符平面映射</a></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>字符集（Charset）</strong>：是一个系统支持的所有抽象字符的集合。字符是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等。</p><p>常见字符集：ASCII字符集、GB2312字符集、BIG5字符集、GB18030字符集、Unicode字符集等。计算机要准确的处理各种字符集文字，需要进行字符编码，以便计算机能够识别和存储各种文字。</p><p><strong>字符编码（Character Encoding）</strong>：是一套法则，使用该法则能够对自然语言的字符的一个集合（如字母表或音节表），与其他东西的一个集合（如号码、数字或电脉冲）进行配对。即在符号集合与数字系统之间建立对应关系，它是信息处理的一项基本技术。通常人们用符号集合（一般情况下就是文字）来表达信息。而以计算机为基础的信息处理系统则是利用元件（硬件）不同状态的组合来存储和处理信息的。元件不同状态的组合能代表数字系统的数字，因此字符编码就是将符号转换为计算机可以接受的数字系统的数，称为数字代码。</p><h2 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h2><p><strong>ASCII字符集</strong>：主要包括控制字符（回车键、退格、换行键等）；可显示字符（英文大小写字符、阿拉伯数字和西文符号）。</p><p><strong>ASCII编码</strong>：将ASCII字符集转换为计算机可以接受的数字系统的数的规则。使用7位（bits）表示一个字符，共128字符；但是7位编码的字符集只能支持128个字符，为了表示更多的常用字符欧洲对ASCII进行了扩展，ASCII扩展字符集使用8位（bits）表示一个字符，共256字符。ASCII字符集映射到数字编码规则如下图所示：</p><p><img src="/2022/08/438d1de3/2011050311372042.png" alt="img"></p><p><img src="/2022/08/438d1de3/201105031137219627.png" alt="img"></p><h2 id="GBxxx"><a href="#GBxxx" class="headerlink" title="GBxxx"></a>GBxxx</h2><p>中国把那些127号之后的奇异符号们（即EASCII、扩充ASCII）取消掉，规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字。前面的一个字节（他称之为高字节）从0xA1用到 0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。在这些编码里，还把数学符号、罗马希腊的 字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。</p><p>上述编码规则就是<strong>GB2312</strong>。<strong>GB2312</strong>或<strong>GB2312-80</strong>是<a href="http://zh.wikipedia.org/wiki/%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E5%9B%BD%E5%AE%B6%E6%A0%87%E5%87%86">中国国家标准</a><a href="http://zh.wikipedia.org/wiki/%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87">简体中文</a><a href="http://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E9%9B%86">字符集</a>，全称《<strong>信息交换用汉字编码字符集·基本集</strong>》，又称<a href="http://zh.wikipedia.org/wiki/%E5%9B%BD%E5%AE%B6%E6%A0%87%E5%87%86%E4%BB%A3%E7%A0%81"><strong>GB0</strong></a>，由<a href="http://zh.wikipedia.org/w/index.php?title=%E4%B8%AD%E5%9B%BD%E5%9B%BD%E5%AE%B6%E6%A0%87%E5%87%86%E6%80%BB%E5%B1%80&action=edit&redlink=1">中国国家标准总局</a>发布，<a href="http://zh.wikipedia.org/wiki/1981%E5%B9%B4">1981年</a><a href="http://zh.wikipedia.org/wiki/5%E6%9C%881%E6%97%A5">5月1日</a>实施。GB2312编码通行于中国大陆；<a href="http://zh.wikipedia.org/wiki/%E6%96%B0%E5%8A%A0%E5%9D%A1">新加坡</a>等地也采用此编码。GB2312的出现，基本满足了汉字的计算机处理需要，它所收录的汉字已经覆盖中国大陆99.75%的使用频率。对于<a href="http://zh.wikipedia.org/wiki/%E4%BA%BA%E5%90%8D">人名</a>、<a href="http://zh.wikipedia.org/wiki/%E5%8F%A4%E6%B1%89%E8%AF%AD">古汉语</a>等方面出现的<a href="http://zh.wikipedia.org/wiki/%E7%BD%95%E7%94%A8%E5%AD%97">罕用字</a>，GB2312不能处理，这导致了后来<a href="http://zh.wikipedia.org/wiki/GBK">GBK</a>及<a href="http://zh.wikipedia.org/wiki/GB_18030">GB 18030</a>汉字字符集的出现。</p><p><a href="http://www.knowsky.com/resource/gb2312tbl.htm">GB2312简体中文编码表</a></p><p><a href="http://tools.jb51.net/table/gb2312">GB2312简体中文编码表</a></p><h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p>Unicode编码系统为表达任意语言的任意字符而设计。它使用4字节的数字来表达每个字母、符号，或者表意文字(ideograph)。每个字符对应一个数字，每个数字对应一个字符，即不存在二义性，不再需要记录”模式”了。U+0041总是代表’A’，即使这种语言没有’A’这个字符。</p><p>在计算机科学领域中，<strong>Unicode</strong>（<strong>统一码</strong>、<strong>万国码</strong>、<strong>单一码</strong>、<strong>标准万国码</strong>）是业界的一种标准，它可以使电脑得以体现世界上数十种文字的系统。</p><p>（<strong>可以这样理解：Unicode是字符集，UTF-32&#x2F; UTF-16&#x2F; UTF-8是三种字符编码方案。</strong>）</p><p><a href="https://www.unicode.org/charts/">Unicode码查询</a></p><p><a href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84">Unicode字符平面映射</a></p><h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h3><p>EF BB BF　　　 UTF-8<br>FE FF　　　　　UTF-16&#x2F;UCS-2, little endian<br>FF FE　　　　　UTF-16&#x2F;UCS-2, big endian<br>FF FE 00 00　　UTF-32&#x2F;UCS-4, little endian.<br>00 00 FE FF　　UTF-32&#x2F;UCS-4, big-endian.</p><ul><li><strong>字符集和字符编码</strong></li></ul><p><img src="/2022/08/438d1de3/v2-aee5ae604328ab912b285d03b6c62273_720w.jpg" alt="img"></p><h3 id="UTF-32"><a href="#UTF-32" class="headerlink" title="UTF-32"></a>UTF-32</h3><p>上述使用4字节的数字来表达每个字母、符号，或者表意文字(ideograph)，每个数字代表唯一的至少在某种语言中使用的符号的编码方案，称为UTF-32。UTF-32又称<strong>UCS-4</strong>是一种将<a href="http://zh.wikipedia.org/wiki/Unicode">Unicode</a>字符编码的协定，对每个字符都使用4字节。就空间而言，是非常没有效率的。</p><p>这种方法有其优点，最重要的一点就是可以在常数时间内定位字符串里的第N个字符，因为第N个字符从第4×Nth个字节开始。虽然每一个码位使用固定长定的字节看似方便，它并不如其它Unicode编码使用得广泛。</p><h3 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h3><p>对于UTF-32和UTF-16编码方式还有一些其他不明显的缺点。不同的计算机系统会以不同的顺序保存字节。这意味着字符U+4E2D在UTF-16编码方式下可能被保存为4E 2D或者2D 4E，这取决于该系统使用的是大尾端(big-endian)还是小尾端(little-endian)。为了解决这个问题，多字节的Unicode编码方式定义了一个”字节顺序标记(Byte Order Mark)”，它是一个特殊的非打印字符，你可以把它包含在文档的开头来指示你所使用的字节顺序。对于UTF-16，字节顺序标记是U+FEFF。如果收到一个以字节FFFE开头的UTF-16编码的文档，你就能确定它的字节顺序是单向的(one way)的了；如果它以FEFF开头，则可以确定字节顺序反向了。</p><p><strong>具体编码方式</strong></p><p>Unicode范围<code>U+10000</code><del><code>U+10FFFF</code>：将Unicode值减去（0x10000），得到20bit长的值。再将Unicode分为高10位和低10位。<a href="https://www.zhihu.com/search?q=UTF-16%E7%BC%96%E7%A0%81&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:106379925%7D">UTF-16编码</a>的高位是2 Byte，高10位Unicode范围为<code>0</code>-<code>0x3FF</code>，将Unicode值加上<code>0XD800</code>，得到高位代理（或称为前导代理，存储高位）；低位也是2 Byte，低十位Unicode范围一样为<code>0</code></del><code>0x3FF</code>，将Unicode值加上<code>0xDC00</code>,得到低位代理（或称为后尾代理，存储低位）</p><p>根据上面的转换方式，我们就能够将Unicode码根据UTF-16的编码方式进行转换。下面我们仍然通过两个例子来看下：</p><ul><li><code>U+0020</code>，这个值的范围在第一部分，即经过UTF-16编码后，结果仍然为<code>U+0020</code>，在内存中的顺序为<code>00 20</code>。</li><li><code>U+12345</code>, 这个值的范围在第二部分，因此需要先减去<code>0x10000</code>，得到<code>0x02345</code>，拆分成高10位<code>00 0000 1000</code>和低10位<code>11 0100 0101</code>。根据上面规则加上特定值后，高位代理值为<code>D808</code>，低位代理值为<code>DF45</code>，最终内存中的顺序为<code>D8 08 DF 45</code>。</li></ul><h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><p><strong>UTF-8</strong>（8-bit Unicode Transformation Format）是一种针对<a href="http://zh.wikipedia.org/wiki/Unicode">Unicode</a>的可变长度<a href="http://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81">字符编码</a>（<a href="http://zh.wikipedia.org/w/index.php?title=%E5%AE%9A%E9%95%BF%E7%A0%81&action=edit&redlink=1">定长码</a>），也是一种<a href="http://zh.wikipedia.org/w/index.php?title=%E5%89%8D%E7%BC%80%E7%A0%81&action=edit&redlink=1">前缀码</a>。它可以用来表示Unicode标准中的任何字符，且其编码中的第一个<a href="http://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82">字节</a>仍与<a href="http://zh.wikipedia.org/wiki/ASCII">ASCII</a>兼容，这使得原来处理ASCII字符的<a href="http://zh.wikipedia.org/wiki/%E8%BB%9F%E9%AB%94">软件</a>无须或只须做少部份修改，即可继续使用。因此，它逐渐成为<a href="http://zh.wikipedia.org/wiki/%E9%9B%BB%E5%AD%90%E9%83%B5%E4%BB%B6">电子邮件</a>、<a href="http://zh.wikipedia.org/wiki/%E7%B6%B2%E9%A0%81">网页</a>及其他<a href="http://zh.wikipedia.org/wiki/%E5%84%B2%E5%AD%98%E8%A3%9D%E7%BD%AE">存储</a>或传送文字的应用中，优先采用的编码。<a href="http://zh.wikipedia.org/wiki/%E7%B6%B2%E9%9A%9B%E7%B6%B2%E8%B7%AF%E5%B7%A5%E7%A8%8B%E5%B7%A5%E4%BD%9C%E5%B0%8F%E7%B5%84">互联网工程工作小组</a>（IETF）要求所有<a href="http://zh.wikipedia.org/wiki/%E7%B6%B2%E9%9A%9B%E7%B6%B2%E8%B7%AF">互联网</a><a href="http://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE">协议</a>都必须支持UTF-8编码。</p><p>UTF-8使用一至四个<a href="http://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82">字节</a>为每个字符编码</p><p><strong>具体编码方式</strong></p><p><img src="/2022/08/438d1de3/v2-121a14291638f0b28e1dde7c95d2d379_720w.jpg" alt="img"></p><p>根据上表，解读 UTF-8 编码非常简单。如果一个字节的第一位是<code>0</code>，则这个字节单独就是一个字符；如果第一位是<code>1</code>，则连续有多少个<code>1</code>，就表示当前字符占用多少个字节。<br>下面，还是以汉字<code>严</code>为例，演示如何实现 <a href="https://www.zhihu.com/search?q=UTF-8+%E7%BC%96%E7%A0%81&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:790551384%7D">UTF-8 编码</a>。<br><code>严</code>的 Unicode 是<code>4E25</code>（<code>100111000100101</code>），根据上表，可以发现<code>4E25</code>处在第三行的范围内（<code>0000 0800 - 0000 FFFF</code>），因此<code>严</code>的 UTF-8 编码需要三个字节，即格式是<code>1110xxxx 10xxxxxx 10xxxxxx</code>。然后，从<code>严</code>的最右边<a href="https://www.zhihu.com/search?q=%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:790551384%7D">二进制位</a>开始，依次从右往左填入上边格式中的<code>x</code>，多出的位补<code>0</code>。这样就得到了，<code>严</code>的 UTF-8 编码是<code>11100100 10111000 10100101</code>，转换成<a href="https://www.zhihu.com/search?q=%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:790551384%7D">十六进制</a>就是<code>E4 B8 A5</code>。</p><p><strong>优点</strong></p><ul><li>UTF-8是ASCII的一个<a href="http://zh.wikipedia.org/wiki/%E8%B6%85%E9%9B%86">超集</a>。因为一个纯ASCII字符串也是一个合法的UTF-8字符串，所以现存的ASCII文本不需要转换。为传统的扩展ASCII字符集设计的软件通常可以不经修改或很少修改就能与UTF-8一起使用。</li><li>使用标准的面向字节的排序例程对UTF-8排序将产生与*于Unicode代码点排序相同的结果。（尽管这只有有限的有用性，因为在任何特定语言或文化下都不太可能有仍可接受的文字排列顺序。）</li><li>UTF-8和UTF-16都是<a href="http://zh.wikipedia.org/wiki/%E5%8F%AF%E6%89%A9%E5%B1%95%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80">可扩展标记语言</a>文档的标准编码。所有其它编码都必须通过显式或文本声明来指定。</li><li>任何<a href="http://zh.wikipedia.org/w/index.php?title=%E9%9D%A2%E5%90%91%E5%AD%97%E8%8A%82&action=edit&redlink=1">面向字节</a>的<a href="http://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95">字符串搜索算法</a>都可以用于UTF-8的数据（只要输入仅由完整的UTF-8字符组成）。但是，对于包含字符记数的正则表达式或其它结构必须小心。</li><li>UTF-8字符串可以由一个简单的算法可靠地识别出来。就是，一个字符串在任何其它编码中表现为合法的UTF-8的可能性很低，并随字符串长度增长而减小。举例说，字符值C0,C1,F5至FF从来没有出现。为了更好的可靠性，可以使用正则表达式来统计非法过长和替代值（可以查看<a href="http://www.w3.org/International/questions/qa-forms-utf-8">W3 FAQ: Multilingual Forms</a>上的验证UTF-8字符串的正则表达式）。</li></ul><p><strong>缺点</strong></p><p>因为每个字符使用不同数量的字节编码，所以寻找串中第N个字符是一个O(N)复杂度的操作 — 即，串越长，则需要更多的时间来定位特定的字符。同时，还需要位变换来把字符编码成字节，把字节解码成字符。</p>]]></content>
    
    
    <categories>
      
      <category>computer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Character Encoding</tag>
      
      <tag>GB2312</tag>
      
      <tag>UTF-8</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

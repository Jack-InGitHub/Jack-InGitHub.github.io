<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>使用Jlink 烧写SPI Flash存储芯片</title>
    <link href="/2022/fd90dc4c/"/>
    <url>/2022/fd90dc4c/</url>
    
    <content type="html"><![CDATA[<h1 id="使用Jlink-烧写SPI-Flash存储芯片"><a href="#使用Jlink-烧写SPI-Flash存储芯片" class="headerlink" title="使用Jlink 烧写SPI Flash存储芯片"></a>使用Jlink 烧写SPI Flash存储芯片</h1><p>参考:</p><p><a href="https://www.segger.com/products/debug-probes/j-link/tools/j-flash-spi/">https://www.segger.com/products/debug-probes/j-link/tools/j-flash-spi/</a></p><h1 id="硬件连接"><a href="#硬件连接" class="headerlink" title="硬件连接"></a>硬件连接</h1><h2 id="SPI-amp-Single"><a href="#SPI-amp-Single" class="headerlink" title="SPI &amp; Single"></a>SPI &amp; Single</h2><p><img src="/2022/fd90dc4c/formatpng.png" alt="img"></p><p><img src="/2022/fd90dc4c/pinout-spi-20-pin.gif" alt="引出线 spi 20 针"></p><h2 id="QSPI-amp-Quad"><a href="#QSPI-amp-Quad" class="headerlink" title="QSPI &amp; Quad"></a>QSPI &amp; Quad</h2><p><img src="/2022/fd90dc4c/pinout-qspi-20-pin.png" alt="img"></p><blockquote><p>  注意:</p><p>  这里要注意的一点，正版的Jlink仿真器1脚是输入引脚，是外部提供参考电平的，但由于现在大部分的JLink仿真器都是学习(dao)版的，1脚不是输入，而是3.3v的输出(并不确定也有可能是5V的, 盗版的Jlink真的是什么乱七八糟的都有)，所以正常情况下可以直接用这个管教来给SPI Flash供电。</p><p>  <strong>关于 nRESET 的注意事项</strong>：如果有另一个设备&#x2F;外围设备也控制 SPI 闪存（例如闪存连接到的 CPU），则 J-Link 的 nRESET 应连接到目标系统的复位或 CPU 的复位引脚确保 J-Link 可以在对 SPI 闪存进行编程时保持 CPU 处于复位状态。</p></blockquote><h1 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h1><p>安装Jlink套件的时候会自带<code>JFlashSPI.exe</code>在开始菜单名称应该类似<code>J-Flash SPI</code>, 这是J-Flash的GUI程序,还有一个命令行的不多做介绍.</p><blockquote><p>  如果没有找到自带的, 请更新Jlink套件, 旧版确实不带这个东西.</p><p>  Segger Jlink套件下载链接 <a href="https://www.segger.com/downloads/jlink/">https://www.segger.com/downloads/jlink/</a></p></blockquote><p><img src="/2022/fd90dc4c/image-20220826224742256.png" alt="image-20220826224742256"></p><p>点击<code>target -&gt; connet</code>连接到Jlink, 它会自动检测大部分SPI闪存, </p><blockquote><p>  有时候识别的具体型号并不准确, 但是这不重要他们参数类似, 可以正常完成编程的工作.</p><p>  Jlink支持的SPI Flash型号可以在<a href="https://www.segger.com/products/debug-probes/j-link/technology/cpus-and-devices/supported-spi-flashes/">点击这里</a>找到.</p></blockquote><p>点击<code>file -&gt; open data file </code>我们打开要烧录的文件.</p><blockquote><p>  bin 文件需要设定起始地址</p><p>  hex文件自带了位置信息</p></blockquote><p>点击<code>target -&gt; auto</code>可以自动将文件烧录进去 还会进行读回校验.</p><p>至此烧录完成.</p><p><strong>Tips:</strong></p><blockquote><p>  点击<code>target -&gt; read back</code> 可以将SPI Flash内的数据读取出来<br>  点击<code>options -&gt; settings -&gt; setup -&gt; interface speed</code>可以修改时钟速度. </p></blockquote><p><strong>Other:</strong></p><p>Jlink真的是超级牛的工具, J-Scope, RTT这些都很好用, 还有很多高级功能我还没用上.<br>我前面有写过RTT的笔记, 在调试一个项目的时候没法使用串口, 当时就是用RTT搭建了一个log平台.</p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="winbood-W25Q128封装"><a href="#winbood-W25Q128封装" class="headerlink" title="winbood W25Q128封装"></a>winbood W25Q128封装</h2><p><img src="/2022/fd90dc4c/image-20220826104542006.png" alt="image-20220826104542006"></p><p><img src="/2022/fd90dc4c/20210622091839750557.png" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>J-Link</tag>
      
      <tag>SPI</tag>
      
      <tag>Flash</tag>
      
      <tag>J-Tag</tag>
      
      <tag>Jlink</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CC2530</title>
    <link href="/2022/8d6db935/"/>
    <url>/2022/8d6db935/</url>
    
    <content type="html"><![CDATA[<blockquote><p>CC2530是针对IEEE 802.15.4，Zigbee和RF4CE应用的真正片上系统（SoC）解决方案。 它能够以非常低的总物料成本构建强大的网络节点。 CC2530将领先的射频收发器的卓越性能与业界标准增强型8051 MCU，系统内可编程闪存，8 KB RAM以及许多其他强大功能相结合。 CC2530有四种不同的闪存版本：分别为CC2530F32 &#x2F; 64&#x2F;128&#x2F;256对应32&#x2F;64&#x2F;128&#x2F;256 KB的闪存。 CC2530具有多种工作模式，非常适合需要超低功耗的系统。 运行模式之间的短暂转换时间进一步确保了低能耗。</p><p>•CC2530是TI公司推出的用来实现嵌入式ZigBee应用的低功耗片上系统。</p><p>•在单个芯片上整合了ZigBee 射频(RF)前端、内存和微控制器。</p><p>•8 位MCU（增强型、标准8051指令集）。</p><p>•256 KB Flash和8 KB 的RAM，内部16MHz RC 和 32kHz RC 振荡器。</p><p>•8路12位ADC；18个中断源；4个Timer；硬件支持的AES128 ；WDT(1.9ms-1s)；32 kHz晶振的休眠模式定时器、POR(上电复位)、BOD(掉电检测)，以及21 个通用I&#x2F;O 。</p></blockquote><h1 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><img src="/2022/8d6db935/20180211202707601.png" alt="img"></p><p>I &#x2F; O端口具有以下主要功能：</p><ul><li>21个数字通用输入&#x2F;输出引脚</li><li>通用I &#x2F; O或外设I &#x2F; O</li><li>输入上拉或下拉功能</li><li>外部中断功能</li></ul><blockquote><p>所有21个I &#x2F; O引脚都具有外部中断功能。 因此，如果需要，外部设备可能会产生中断。 外部中断功能也可用于将器件从睡眠模式（电源模式PM1，PM2和PM3）中唤醒</p></blockquote><blockquote><p>通用IO：共21个，分成3组，<strong>P0组、P1组、P2组</strong>，其中P0\P1组各8个IO，P2组5个（P2_0、P2_1、 P2_2、P2_3、 P2_4）。其中P1_0、P1_1有20mA的输出驱动能力，其余的只有4mA。</p></blockquote><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><ol><li><p>GPIO<strong>功能</strong>选择寄存器——<strong>PxSEL</strong></p><p> 寄存器PxSEL（其中x是端口号0-2）用于将端口中的每个引脚配置为<strong>通用I&#x2F;O引脚</strong>或<strong>外设I&#x2F;O引脚</strong>，可位寻址。 默认情况下，复位后，所有数字输入&#x2F;输出引脚都配置为<strong>通用上拉输入引脚</strong>。</p><blockquote><p>其中，P2SEL只有第0位至第2位是端口2的功能选择控制位，第3位至第6位是端口1的外设优先级控制位。</p></blockquote></li></ol><ul><li>0&#x3D;通用</li><li>1&#x3D;外设I&#x2F;O</li></ul><ol><li><p>GPIO<strong>输入输出方向</strong>选择寄存器——<strong>PxDIR</strong></p><p>寄存器PxDIR用于将每个端口的引脚方向设置为<strong>输入方向</strong>或<strong>输出方向</strong>。 因此，将PxDIR中的相应位设置为1，相应的引脚就变成输出方向，可位寻址。复位后为<strong>输入引脚</strong>。</p><blockquote><p>其中，P2DIR只有第0位至第4位是端口2的方向选择控制位，第6位和第7位是端口0外设优先级控制位。</p></blockquote></li></ol><ul><li><p>0&#x3D;输入</p></li><li><p>1&#x3D;输出</p></li></ul><ol start="2"><li><p>GPIO<strong>输入模式</strong>寄存器——<strong>PxINP</strong></p><p>寄存器PxINP用于设置IO端口的<strong>输入模式</strong>，通用I &#x2F; O端口引脚可配置为具有<strong>上拉</strong>，<strong>下拉</strong>或<strong>三态</strong>操作模式。 默认情况下，复位后，输入配置为带有上拉的输入。如果要取消输入端口的上拉或下拉功能，必须将PxINP中的相应位设置为1。</p><ul><li>请注意，即使IO端口是外设功能输入，配置为外设I &#x2F; O信号的引脚也不具有上拉或下拉功能。</li></ul><blockquote><p>其中，P2INP中，第0位至第4位是端口2的输入模式选择位</p><p><strong>第5位至第7位是端口0、端口1、端口2的上下拉选择位。</strong></p><ul><li>0&#x3D;PullUp</li><li>1&#x3D;PullDown</li></ul></blockquote></li></ol><ul><li>0&#x3D;上拉或下拉</li><li>1&#x3D;三态</li></ul><h1 id="Z-Stack"><a href="#Z-Stack" class="headerlink" title="Z-Stack"></a>Z-Stack</h1><h2 id="创建一个任务-Create-Task"><a href="#创建一个任务-Create-Task" class="headerlink" title="创建一个任务 Create Task"></a>创建一个任务 Create Task</h2><ul><li>&#x2F;&#x2F; 任务列表<br>const pTaskEventHandlerFn tasksArr[] &#x3D; {…..}</li><li>&#x2F;&#x2F; 初始化任务<br>void osalInitTasks( void )<br>{…..}</li><li>&#x2F;&#x2F; 任务处理函数<br>uint16 Hello_ProcessEvent(uint8 task_id, uint16 events)<br>{…}</li></ul><h2 id="HAL库之LED"><a href="#HAL库之LED" class="headerlink" title="HAL库之LED"></a>HAL库之LED</h2><ol><li>uint8 HalLedSet (uint8 leds, uint8 mode)</li></ol><table><thead><tr><th>ModeName</th><th>作用</th></tr></thead><tbody><tr><td>HAL_LED_MODE_BLINK</td><td>闪烁  (一次)</td></tr><tr><td>HAL_LED_MODE_FLASH</td><td>闪烁</td></tr><tr><td>HAL_LED_MODE_ON</td><td></td></tr><tr><td>HAL_LED_MODE_OFF</td><td></td></tr><tr><td>HAL_LED_MODE_TOGGLE</td><td>触发</td></tr></tbody></table><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><ol><li><p>uint8 osal_start_timerEx( uint8 taskID, uint16 event_id, uint16 timeout_value )</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//为指定的任务设置定时器</span><br><br>osal_start_timerEx(task_id, <span class="hljs-number">0x0001</span>, <span class="hljs-number">10000</span>);<br></code></pre></td></tr></table></figure></li><li></li></ol><h2 id="PAN-ID"><a href="#PAN-ID" class="headerlink" title="PAN_ID"></a>PAN_ID</h2><ul><li><p>全称 Personal Area Network (网络标识符)</p></li><li><p>相当于网络号，网段。</p></li></ul><p>Tools\f8Config.cfgLine59</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Define the default PAN ID.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Setting this to a value other than 0xFFFF causes</span><br><span class="hljs-comment"> * ZDO_COORD to use this value as its PAN ID and</span><br><span class="hljs-comment"> * Routers and end devices to join PAN with this ID</span><br><span class="hljs-comment"> */</span><br>-DZDAPP_CONFIG_PAN_ID=<span class="hljs-number">0x0010</span><br></code></pre></td></tr></table></figure><h2 id="Z-Stack开发步骤"><a href="#Z-Stack开发步骤" class="headerlink" title="Z-Stack开发步骤"></a>Z-Stack开发步骤</h2><h3 id="功能类型定义"><a href="#功能类型定义" class="headerlink" title="功能类型定义"></a>功能类型定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 功能类型值定义</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    DevTemp = <span class="hljs-number">1</span>,<br>    DevHumm,<br><span class="hljs-comment">//略---------------------</span><br>    DevMaxNum<br>&#125;;<br></code></pre></td></tr></table></figure><p>枚举功能类型值，需要时添加即可。</p><h3 id="定义节点功能列表"><a href="#定义节点功能列表" class="headerlink" title="定义节点功能列表"></a>定义节点功能列表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/***************************************************/</span><br><span class="hljs-comment">/* 节点功能列表                                    */</span><br><span class="hljs-comment">/***************************************************/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ep_info_t</span> <span class="hljs-title">funcList</span>[] =</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(HAS_GAS)</span><br>    &#123;<br>        <span class="hljs-comment">//stat,income,timeout,resource</span><br>        <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, sensorGasTimeout, sensorGasResAvailable,<br>        &#123; DevGas, <span class="hljs-number">0</span>, <span class="hljs-number">3</span> &#125;,                   <span class="hljs-comment">// type, id, refresh cycle</span><br>    &#125;,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-comment">//略----------------</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(ZDO_COORDINATOR)</span><br>    &#123;   <span class="hljs-comment">// 协调器</span><br>        CoordinatorNwkStateChangeRoutine,<br>        CoordinatorIncomingRoutine,<br>        CoordinatorTimeoutRoutine,<br>        CoordinatorResAvailableRoutine,<br>        &#123; DevCoordinator, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;,<br>    &#125;,<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(RTR_NWK)</span><br>    &#123;   <span class="hljs-comment">// 路由器</span><br>        RouterNwkStateChangeRoutine,<br>        RouterIncomingRoutine,<br>        RouterTimeoutRoutine,<br>        RouterResAvailableRoutine,<br>        &#123; DevRouter, <span class="hljs-number">0</span>, <span class="hljs-number">30</span> &#125;,<br>    &#125;,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p>功能列表</p></li><li><p>参考下面的 <strong>ep_info_t</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 不能修改下面的内容!!!</span><br><span class="hljs-type">const</span> uint8 funcCount = <span class="hljs-keyword">sizeof</span>(funcList) / <span class="hljs-keyword">sizeof</span>(funcList[<span class="hljs-number">0</span>]);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><br></code></pre></td></tr></table></figure></li><li><p>功能数量</p></li><li></li></ul><h3 id="ep-info-t"><a href="#ep-info-t" class="headerlink" title="ep_info_t"></a>ep_info_t</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ep_info_t</span> &#123;</span><br>    <span class="hljs-comment">// 网络状态发生变化时会调用该函数</span><br>    <span class="hljs-type">void</span> (*nwk_stat_change)(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep);<br>    <span class="hljs-comment">// 接收到数据时会调用该函数</span><br>    <span class="hljs-type">void</span> (*incoming_data)(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg);<br>    <span class="hljs-comment">// 周期性调用的函数</span><br>    <span class="hljs-type">void</span> (*time_out)(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep);<br>    <span class="hljs-comment">// 系统资源可用时调用该函数,系统资源指的是:串口接收到数据/中断等等</span><br>    <span class="hljs-type">void</span> (*res_available)(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep, RES_TYPE type, <span class="hljs-type">void</span> *res);<br>    <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> cycle成员会被用来计数,并周期性调用time_out函数</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">func_info_t</span> <span class="hljs-title">function</span>;</span><br>    <br><span class="hljs-comment">//以下数据用户不能进行更改！！！！！</span><br>    <br>    <span class="hljs-comment">// 当前端点号</span><br>    uint8 ep;<br>    <span class="hljs-comment">// 与此端点绑定的任务ID</span><br>    uint8 task_id;<br>    <span class="hljs-comment">// 递减计数,为0时调用time_out函数,并重载初值=cycle</span><br>    uint8 timerTick;<br>    uint8 userTimer;<br>    endPointDesc_t SampleApp_epDesc;<br>    SimpleDescriptionFormat_t simpleDesc;<br>&#125;;<br><br><span class="hljs-comment">//一个典型的初始化</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(ZDO_COORDINATOR)</span><br>    &#123;   <span class="hljs-comment">// 协调器</span><br>        CoordinatorNwkStateChangeRoutine,<span class="hljs-comment">//节点加入网络完成后调用</span><br>        CoordinatorIncomingRoutine,<span class="hljs-comment">//端点接收到数据后会调用</span><br>        CoordinatorTimeoutRoutine,<span class="hljs-comment">//周期调用</span><br>        CoordinatorResAvailableRoutine,<span class="hljs-comment">//系统初始化、串口收到数据、用户定时器到时 会调用</span><br>        &#123; DevCoordinator, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;,<span class="hljs-comment">//功能类型、功能编号、刷新周期</span><br>    &#125;,<br><br></code></pre></td></tr></table></figure><h4 id="nwk-stat-change"><a href="#nwk-stat-change" class="headerlink" title="nwk_stat_change"></a>nwk_stat_change</h4><p><strong>节点加入网络完成后调用</strong></p><ul><li>可用于读取当前  端点  信息</li><li></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">xxNwkStateChange</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep)</span><br>    <br><span class="hljs-type">void</span> <span class="hljs-title function_">sensorVoiceNwkStateChange</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep)</span><br>&#123;<br>    voiceEndPoint = ep;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="incoming-data"><a href="#incoming-data" class="headerlink" title="incoming_data"></a>incoming_data</h4><p><strong>端点接收到数据后会调用</strong></p><ul><li>下发的指令的处理</li><li></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">xxReceiveData</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg)</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">testReceiveData</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg)</span><br>&#123;<br>    <span class="hljs-comment">//msg-&gt;Data[0] 是接受到的总  比特   数 </span><br><span class="hljs-keyword">if</span>( (msg-&gt;Data[<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;L&#x27;</span>)&amp;&amp;(msg-&gt;Data[<span class="hljs-number">2</span>]==<span class="hljs-string">&#x27;E&#x27;</span>)&amp;&amp;(msg-&gt;Data[<span class="hljs-number">3</span>]==<span class="hljs-string">&#x27;D&#x27;</span>) )<br>    &#123;<br><span class="hljs-keyword">if</span>( msg-&gt;Data[<span class="hljs-number">4</span>]==<span class="hljs-string">&#x27;1&#x27;</span> )<br>&#123;<br>HalUARTWrite(HAL_UART_PORT_0, <span class="hljs-string">&quot;LED_1\r\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;LED_1\r\n&quot;</span>) - <span class="hljs-number">1</span>);<br><span class="hljs-comment">//HalLedBlink(HAL_LED_1, 2, 50, 100);</span><br>&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="time-out"><a href="#time-out" class="headerlink" title="time_out"></a>time_out</h4><p><strong>周期调用</strong></p><ul><li>读取传感器数据</li><li></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">xxTimeout</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep)</span><br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">sensorFireTimeout</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep)</span><br>&#123;<br>    uint8 value = FireInfo();<br>    SendData(ep-&gt;ep, &amp;value, <span class="hljs-number">0x0000</span>, TRANSFER_ENDPOINT, <span class="hljs-keyword">sizeof</span>(value));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="res-available"><a href="#res-available" class="headerlink" title="res_available"></a>res_available</h4><p><strong>系统初始化、串口收到数据、用户定时器到时 会调用</strong></p><ul><li>初始化端口、</li><li></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">xxResAvailable</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep, RES_TYPE type, <span class="hljs-type">void</span> *res)</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">sensorRainResAvailable</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep, RES_TYPE type, <span class="hljs-type">void</span> *res)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(type == ResInit)<br>    &#123;<br>        RainInit();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="IAR学习笔记"><a href="#IAR学习笔记" class="headerlink" title="IAR学习笔记"></a>IAR学习笔记</h1><h2 id="无法观察局部变量"><a href="#无法观察局部变量" class="headerlink" title="无法观察局部变量"></a>无法观察局部变量</h2><p>在软件调试的时候发现Watch窗口中无法观察局部变量的值，总是显示<unavailable><br>　　设置IAR中的”<strong>Options — c&#x2F;c++ compiler — Optimization — Level</strong>“ 选项：<br>　　Level的缺省值为Low，当我把Level选为None之后，即不执行任何优化时，全局变量、静态局部变量、局部变量的值都可以看到。</p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
      <tag>CC2530</tag>
      
      <tag>Zigbee</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hex 文件格式解析</title>
    <link href="/2022/d3f98b78/"/>
    <url>/2022/d3f98b78/</url>
    
    <content type="html"><![CDATA[<h1 id="Hex-文件格式解析"><a href="#Hex-文件格式解析" class="headerlink" title="Hex 文件格式解析"></a>Hex 文件格式解析</h1><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://developer.arm.com/documentation/ka003292/1-0">Intel HEX File Format Keil</a></p><p><a href="https://en.wikipedia.org/wiki/Intel_HEX">Intel HEX Wiki</a></p><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><ul><li>以行为单位，每行以冒号开头，内容全部为16进制码（以ASCII码形式显示）</li><li>在HEX文件里面，每一行代表一个记录。记录的基本格式为如表所示</li></ul><table><thead><tr><th><strong>冒号</strong></th><th><strong>本行数据长度</strong></th><th><strong>本行数据起始地址</strong></th><th><strong>数据类型</strong></th><th><strong>数据</strong></th><th><strong>校验码</strong></th></tr></thead><tbody><tr><td></td><td>1 byte</td><td>2 bytes</td><td>1 byte</td><td>n byte</td><td>1 byte</td></tr></tbody></table><p><img src="/2022/d3f98b78/hex_format.jpg"></p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Start code</td><td>one character, an ASCII colon ‘:’</td></tr><tr><td>Byte count</td><td>两个十六进制数字（一个十六进制数字对），表示数据字段中的字节数（十六进制数字对）。最大字节数为 255 (0xFF)。16 (0x10) 和 32 (0x20) 是常用的字节数。</td></tr><tr><td>Address</td><td>四位十六进制数字，表示数据的 16 位起始内存地址偏移量。数据的物理地址是通过将此偏移量添加到先前建立的基地址来计算的，从而允许内存寻址超出 16 位地址的 64 KB 限制。默认为零的基地址可以通过各种类型的记录进行更改。基地址和地址偏移量始终表示为<a href="https://en.wikipedia.org/wiki/Big_endian">大端</a>值。</td></tr><tr><td>Record type</td><td>两个十六进制数字，<em>00</em>到<em>05</em>，定义数据字段的含义。参考下文</td></tr><tr><td>Data</td><td>一个由<em>n</em>个字节组成的数据序列，由 <em>2n</em> 个十六进制数字表示。一些记录省略了这个字段（<em>n</em>等于零）。数据字节的含义和解释取决于应用程序。</td></tr><tr><td>Checksum</td><td>two hex digits, a computed value that can be used to verify the record has no errors.计算校验和前所有16进制码的累加和。</td></tr></tbody></table><h3 id="指令类型-Record-type"><a href="#指令类型-Record-type" class="headerlink" title="指令类型 Record type"></a>指令类型 Record type</h3><p>指令类型<code>Record type</code>的值一般是<code>00~05</code>，这表示了，当前这行<code>hex</code>格式的数据，所代表的含义：</p><table><thead><tr><th>十六进制代码</th><th>记录类型</th><th align="center">描述</th><th align="center">Example</th></tr></thead><tbody><tr><td><strong>00</strong></td><td>数据</td><td align="center">包含数据和该数据的16位起始地址。字节计数指定记录中的数据字节数。右侧显示的示例为0B （十一）个数据字节（61， 64， 64， 72， 65， 73， 73， 20， 67， 61， 70）位于以地址开头的连续地址 0010。</td><td align="center"><code>:0B 0010 00 6164647265737320676170 A7</code></td></tr><tr><td><strong>01</strong></td><td>文件结束</td><td align="center">每个文件在文件的最后一行必须恰好发生一次。数据字段为空（因此字节数为00），并且地址字段通常为 0000。</td><td align="center"><code>:00 0000 01 FF</code></td></tr><tr><td><strong>02</strong></td><td>扩展段地址</td><td align="center">数据字段包含一个16位的段基址（因此字节数始终为02）与80x86实模式寻址兼容。地址字段（通常为0000）被忽略。最近的段地址02记录乘以16，然后加到每个后续数据记录地址，以形成数据的物理起始地址。这允许寻址多达1 MB的地址空间。</td><td align="center"><code>:02 0000 02 1200 EA</code></td></tr><tr><td><strong>03</strong></td><td>起始段地址</td><td align="center">对于80x86处理器，请指定CS：IP寄存器的初始内容（即起始执行地址）。地址字段是0000，字节数始终为04，前两个数据字节是CS值，后两个是IP值。</td><td align="center"><code>:04 0000 03 00003800 C1</code></td></tr><tr><td><strong>04</strong></td><td>扩展线性地址</td><td align="center">允许32位寻址（最大4GiB）。记录的地址字段将被忽略（通常是0000），其字节数始终为02。两个数据字节（大字节序）为所有后续类型指定32位绝对地址的高16位00记录; 这些高位地址位适用于下一个04记录。类型的绝对地址00 通过组合最近的高16位地址位形成记录 04 用低16位的地址记录 00记录。如果是类型00 记录之前没有任何类型 04 记录，然后其高16位地址位默认为0000。</td><td align="center"><code>:02 0000 04 FFFF FC</code></td></tr><tr><td><strong>05</strong></td><td>起始线性地址</td><td align="center">地址字段是 0000（未使用），字节数始终为04。四个数据字节代表一个32位地址值（big-endian）。对于80386和更高版本的CPU，此地址将加载到EIP寄存器中。<br/><strong>（仅限 MDK-ARM）</strong>起始线性地址记录指定应用程序的起始地址。这些记录包含完整的线性 32 位地址。</td><td align="center"><code>:04 0000 05 000000CD 2A</code></td></tr></tbody></table><h5 id="扩展线性地址记录-HEX386"><a href="#扩展线性地址记录-HEX386" class="headerlink" title="扩展线性地址记录 (HEX386)"></a>扩展线性地址记录 (HEX386)</h5><p>扩展线性地址记录也称为 32 位地址记录和 HEX386 记录。这些记录包含数据地址的高 16 位（位 16-31）。扩展线性地址记录总是有两个数据字节，如下所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">:02000004FFFFFC<br></code></pre></td></tr></table></figure><p>在哪里：</p><ul><li><strong>02</strong>是记录中的数据字节数。</li><li><strong>0000</strong>是地址字段。对于扩展线性地址记录，此字段始终为 0000。</li><li><strong>04</strong>是记录类型 04（扩展的线性地址记录）。</li><li><strong>FFFF</strong>是地址的高 16 位。</li><li><strong>FC</strong>是记录的校验和，计算方式为<br>01h + NOT(02h + 00h + 00h + 04h + FFh + FFh)。</li></ul><p>读取扩展线性地址记录时，存储在数据字段中的扩展线性地址将被保存并应用于从 Intel HEX 文件读取的后续记录。线性地址保持有效，直到被另一个扩展地址记录改变。</p><p>数据记录的绝对内存地址是通过将记录中的地址字段与扩展线性地址记录的移位地址数据相加得到的。下面的例子说明了这个过程。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-type">Address</span> from the <span class="hljs-class"><span class="hljs-keyword">data</span> record&#x27;s address field      2462</span><br><span class="hljs-type">Extended</span> linear address record <span class="hljs-class"><span class="hljs-keyword">data</span> field     <span class="hljs-type">FFFF</span></span><br>                                              <span class="hljs-comment">--------</span><br><span class="hljs-type">Absolute</span>-memory address                       <span class="hljs-type">FFFF2462</span><br></code></pre></td></tr></table></figure><h5 id="扩展段地址记录-HEX86"><a href="#扩展段地址记录-HEX86" class="headerlink" title="扩展段地址记录 (HEX86)"></a>扩展段地址记录 (HEX86)</h5><p>扩展段地址记录（也称为 HEX86 记录）包含数据地址段的第 4-19 位。扩展段地址记录总是有两个数据字节，如下所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">:020000021200EA<br></code></pre></td></tr></table></figure><p>在哪里：</p><ul><li><strong>02</strong>是记录中的数据字节数。</li><li><strong>0000</strong>是地址字段。对于扩展段地址记录，该字段始终为 0000。</li><li><strong>02</strong>是记录类型 02（扩展段地址记录）。</li><li><strong>1200</strong>是地址段。</li><li><strong>EA</strong>是记录的校验和，计算方式为<br>01h + NOT(02h + 00h + 00h + 02h + 12h + 00h)。</li></ul><p>当读取扩展段地址记录时，存储在数据字段中的扩展段地址被保存并应用于从 Intel HEX 文件读取的后续记录。段地址保持有效，直到被另一个扩展地址记录改变。</p><p>数据记录的绝对内存地址是通过将记录中的地址字段添加到来自扩展段地址记录的移位地址数据中获得的。以下示例说明了此过程。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-type">Address</span> from the <span class="hljs-class"><span class="hljs-keyword">data</span> record&#x27;s address field     2462</span><br><span class="hljs-type">Extended</span> segment address record <span class="hljs-class"><span class="hljs-keyword">data</span> field      1200</span><br>                                             <span class="hljs-comment">--------</span><br><span class="hljs-type">Absolute</span> memory address                      <span class="hljs-number">00014462</span><br></code></pre></td></tr></table></figure><h5 id="起始线性地址记录（仅限-MDK-ARM）"><a href="#起始线性地址记录（仅限-MDK-ARM）" class="headerlink" title="起始线性地址记录（仅限 MDK-ARM）"></a>起始线性地址记录（仅限 MDK-ARM）</h5><p>起始线性地址记录指定应用程序的起始地址。这些记录包含完整的线性 32 位地址。起始线性地址记录总是有四个数据字节，如下所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">:04000005000000CD2A<br></code></pre></td></tr></table></figure><p>在哪里：</p><ul><li><strong>04</strong>是记录中的数据字节数。</li><li><strong>0000</strong>是地址字段。对于起始线性地址记录，该字段始终为 0000。</li><li><strong>05</strong>是记录类型 05（起始线性地址记录）。</li><li><strong>000000CD</strong>是应用程序的 4 字节线性起始地址。</li><li><strong>2A</strong>是记录的校验和，计算方式为<br>01h + NOT(04h + 00h + 00h + 05h + 00h + 00h + 00h + CDh)。</li></ul><p>Start Linear Address 指定了 __main（pre-main）函数的地址，而不是通常在调用 SystemInit() 之后调用 __main 的启动代码的地址。奇数线性起始地址指定 __main 是为 Thumb 指令集编译的。</p><p>起始线性地址记录可以出现在 hex 文件中的任何位置。在大多数情况下，可以忽略此记录，因为它不包含对闪存进行编程所需的信息。</p><h5 id="文件结束-EOF-记录"><a href="#文件结束-EOF-记录" class="headerlink" title="文件结束 (EOF) 记录"></a>文件结束 (EOF) 记录</h5><p>英特尔 HEX 文件必须以文件结束 (EOF) 记录结尾。此记录在记录类型字段中必须具有值 01。EOF 记录始终如下所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">:00000001FF<br></code></pre></td></tr></table></figure><p>在哪里：</p><ul><li><strong>00</strong>是记录中的数据字节数。</li><li><strong>0000</strong>是数据在内存中的位置。文件尾记录中的地址是无意义的并且被忽略。地址 0000h 是典型的。</li><li><strong>01</strong>是记录类型 01（文件结束记录）。</li><li><strong>FF</strong>是记录的校验和，计算方式为<br>01h + NOT(00h + 00h + 00h + 01h)。</li></ul><h2 id="tip"><a href="#tip" class="headerlink" title="tip"></a>tip</h2><ul><li><strong>用Notepad++打开hex文件，会自动上色、换行</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MarkDown学习笔记</title>
    <link href="/2022/da7ed36c/"/>
    <url>/2022/da7ed36c/</url>
    
    <content type="html"><![CDATA[<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><p>asdasdasdasdassdasdas</p><h2 id="这是一段引用"><a href="#这是一段引用" class="headerlink" title="这是一段引用"></a>这是一段引用</h2><blockquote><p>这是一段引用</p></blockquote><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><ul><li>阿斯大声</li><li>阿斯大声打</li><li>阿斯大声问请问恶</li></ul><h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><ol><li><p>阿斯大声打</p></li><li><p>阿斯大声阿斯大声</p></li><li><p>dasd阿斯dasdaaa</p></li></ol><h2 id="斜体-和-加粗-强调"><a href="#斜体-和-加粗-强调" class="headerlink" title="斜体 和 加粗 (强调)"></a>斜体 和 加粗 (强调)</h2><p>这是<em>斜体</em>      这是<strong>加粗</strong>   这是_什么呢_  好像也__是一样的__</p><h2 id="这是上下标"><a href="#这是上下标" class="headerlink" title="这是上下标"></a>这是上下标</h2><p>  H<del>2</del>0   H^2^0</p><h2 id="这段是横线"><a href="#这段是横线" class="headerlink" title="这段是横线"></a>这段是横线</h2><hr><hr><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p><a href="./assets/00.jpg">这是超链接</a></p><p><a href=".%5Cassets%5C00.jpg">www.Baidu.com</a></p><p><a href="https://sigrok.org/wiki/Protocol_decoder_API">这是一个超链接 （注意链接前后不要留空格）</a></p><p>This is <a href="http://example.com/" title="Optional Title Here">an example</a> reference-style link.</p><h2 id="文章内的超链接"><a href="#文章内的超链接" class="headerlink" title="文章内的超链接"></a><a id="文章内的超链接">文章内的超链接</a></h2><p> <a href="##%E8%A1%A8%E6%A0%BC">这是一个文章内部的超链接</a></p><p> Ctrl+左键  </p><p><a href="#HTML跳转">回到-&gt;HTML 跳转</a></p><h2 id="Email-链接"><a href="#Email-链接" class="headerlink" title="Email 链接"></a>Email 链接</h2><p>作者的 Emal <a href="mailto:&#120;&#x78;&#x40;&#120;&#x78;&#46;&#x63;&#111;&#109;">&#120;&#x78;&#x40;&#120;&#x78;&#46;&#x63;&#111;&#109;</a> 链接</p><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><ul><li>内联风格</li></ul><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1557132849466&di=61258032fff80f7d4bfff0ad0b325b12&imgtype=0&src=http://s6.sinaimg.cn/middle/6dca756dhad5c3293f515&690" alt="iPhone"></p><ul><li>引用风格</li></ul><p><strong>一直没弄出来</strong></p><p>xxx<img src="/photo_id" alt="photo_id"></p><h2 id="代码块-与-代码行"><a href="#代码块-与-代码行" class="headerlink" title="代码块 与 代码行"></a>代码块 与 代码行</h2><p><code>  delay_init();     //延时函数初始化</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>delay_init();     <span class="hljs-comment">//延时函数初始化</span><br>TIM_ALL_Init();<br> LED_Init();     <span class="hljs-comment">//LED端口初始化</span><br>LCD_Init();<br>POINT_COLOR=WHITE;<br>BACK_COLOR = BLACK;<br>LCD_Clear(BLACK);<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><table><thead><tr><th>name</th><th>age</th><th>sex</th></tr></thead><tbody><tr><td>Done</td><td>20</td><td>0</td></tr><tr><td>Jack</td><td>21</td><td>0</td></tr><tr><td>Done<br/>这里换行了</td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><p><del>这是一条删除             线线线线线线线线线线线线线线线</del></p><h2 id="这是一个注释"><a href="#这是一个注释" class="headerlink" title="这是一个注释"></a>这是一个注释</h2><p>[注释] <a href="%E8%BF%99%E6%98%AF%E6%B3%A8%E9%87%8A%E7%9A%84%E8%A7%A3%E9%87%8A">^注释</a>:Somebody that I used to know.</p><h2 id="数学表达式"><a href="#数学表达式" class="headerlink" title="数学表达式"></a>数学表达式</h2><p>$ (h&#x2F;2)<em>(a+9)&#x2F;(b</em>9))*L $</p><p>$lim_{x \to \infty} \ exp(-x)&#x3D;0$</p><h2 id="修改文字颜色-HTLML"><a href="#修改文字颜色-HTLML" class="headerlink" title="修改文字颜色 HTLML"></a>修改文字颜色 HTLML</h2><p>You can use HTML to style content what pure Markdown does not support.</p><p><span style="color:red"><strong>TEXT Style</strong></span></p><p><span style="color:#29b6f6"> <strong>TEXT Style</strong> </span></p><p><span style="color:rgb(255, 255, 255)"><strong>TEXT Style</strong></span></p><p><span style="color:LightPink"> <strong>TEXT Style</strong> </span></p><p><span style="color:Thistle"> <strong>TEXT Style</strong> </span></p><p><span style="color:Gold"> <strong>TEXT Style</strong> </span></p><p><span style="color:Tomato"> <strong>TEXT Style</strong> </span></p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:red&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:#29b6f6&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:rgb(255, 255, 255)&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><br>https://www.5tu.cn/colors/yansezhongwenming.html<br></code></pre></td></tr></table></figure><p>For example, use <code>&lt;span style=&quot;color:red&quot;&gt;this text is red&lt;/span&gt;</code> to add text with red color.</p><h2 id="表情-Emoji-smile"><a href="#表情-Emoji-smile" class="headerlink" title="表情 Emoji :smile:"></a>表情 Emoji :smile:</h2><p>Input emoji with syntax <code>:smile:</code>.</p><p>User can trigger auto-complete suggestions for emoji by pressing <code>ESC</code> key, or trigger it automatically after enabling it on preference panel. Also, inputting UTF-8 emoji characters directly is also supported by going to <code>Edit</code> -&gt; <code>Emoji &amp; Symbols</code> in the menu bar (macOS).</p><h2 id="Task-List-带勾的计划任务-勾选框"><a href="#Task-List-带勾的计划任务-勾选框" class="headerlink" title="Task List 带勾的计划任务 勾选框"></a>Task List 带勾的计划任务 勾选框</h2><ul><li><input disabled="" type="checkbox"> a task list item</li><li><input disabled="" type="checkbox"> list syntax required </li><li><input checked="" disabled="" type="checkbox"> completed</li></ul><p>注意    [内有一个空格] </p><h2 id="Video"><a href="#Video" class="headerlink" title="Video"></a>Video</h2><p>You can use the <code>&lt;video&gt;</code> HTML tag to embed videos. For example:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Markdown"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;xxx.mp4&quot;</span> /&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">文字[^脚注1]文字.<br>[<span class="hljs-symbol">^脚注1</span>]:<span class="hljs-link">这是脚注1的内容</span><br></code></pre></td></tr></table></figure><p>文字<a href="%E8%BF%99%E6%98%AF%E8%84%9A%E6%B3%A81%E7%9A%84%E5%86%85%E5%AE%B9">^脚注1</a>文字.</p><h2 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h2><p><strong>1.实现下标与上标的三种方法：</strong></p><ul><li><p>方法1（符号）：(这是Markdown的拓展语法)</p><figure class="highlight parser3"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs parser3"><span class="language-xml">下标 ：θ~</span><span class="hljs-number">1</span><span class="language-xml">~ </span><br><span class="language-xml">上标 ：θ</span><span class="hljs-keyword">^2</span><span class="language-xml">^</span><br><span class="language-xml"></span><span class="hljs-number">12</span><br></code></pre></td></tr></table></figure></li><li><p>结果如下：<br>下标 ：θ<del>1</del><br>上标 ：θ^2^</p></li><li><p>方法2（HTML标签）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml">下标 ：θ<span class="hljs-tag">&lt;<span class="hljs-name">sub</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">sub</span>&gt;</span><br>上标 ：θ<span class="hljs-tag">&lt;<span class="hljs-name">sup</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">sup</span>&gt;</span><br>12<br></code></pre></td></tr></table></figure></li><li><p>结果如下：<br>下标 ：θ<sub>1</sub><br>上标 ：θ<sup>2</sup></p></li><li><p>方法3（公式块）：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br>下标 ：θ_1 ，上标 ：θ^<span class="hljs-number">2</span><br><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure></li><li><p>结果如下：</p></li><li><p>$$<br>下标 ：θ_1 ，上标 ：θ^2<br>$$</p></li></ul><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><h2 id="HTML-跳转"><a href="#HTML-跳转" class="headerlink" title="HTML 跳转"></a><a id="HTML跳转">HTML 跳转</a></h2><p><a href="#文章内的超链接">点击到达-&gt;文章内的超链接</a> </p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">&lt;<span class="hljs-keyword">a</span> href=<span class="hljs-string">&quot;#demo&quot;</span>&gt;点击到达跳转位置演示&lt;/<span class="hljs-keyword">a</span>&gt; <span class="hljs-comment"># 在需要跳转的地方添加此代码。</span><br>&lt;<span class="hljs-keyword">a</span> id=<span class="hljs-string">&quot;demo&quot;</span>&gt;跳转位置演示（跳转位置设置点）&lt;/<span class="hljs-keyword">a</span>&gt; <span class="hljs-comment"># 在跳转位置添加次代码。</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MarkDown</tag>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSL证书的申请和自动续期</title>
    <link href="/2022/82aca4fc/"/>
    <url>/2022/82aca4fc/</url>
    
    <content type="html"><![CDATA[<h1 id="SSL证书的申请和自动续期"><a href="#SSL证书的申请和自动续期" class="headerlink" title="SSL证书的申请和自动续期"></a>SSL证书的申请和自动续期</h1><p>Let’s Encrypt 证书续期</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/a2d0209fa3f5">https://www.jianshu.com/p/a2d0209fa3f5</a></p><p><a href="https://www.cnblogs.com/esofar/p/9291685.html">快速签发 Let’s Encrypt 证书指南</a></p><p><a href="https://certbot.eff.org/">https://certbot.eff.org/</a></p><h1 id="acme-sh-申请"><a href="#acme-sh-申请" class="headerlink" title="acme.sh 申请"></a>acme.sh 申请</h1><p>用 acme.sh申请来自动续期ssl证书<br> acme说明：<a href="https://links.jianshu.com/go?to=https://github.com/Neilpang/acme.sh/wiki/%E8%AF%B4%E6%98%8E">https://github.com/Neilpang/acme.sh/wiki/说明</a></p><ol><li>下载acme<code>curl https://get.acme.sh | sh</code>  安装完成后必须关闭当前终端，重新开启一个以使acme.sh命令生效</li><li>执行生成和自动更新命令：<code>acme.sh --issue -d mydomain.com -d www.mydomain.com --webroot /var/www/mydomain.com/</code></li><li>安装证书 <code>cd /etc/nginx; mkdir ssl</code></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">acme.sh  --installcert  -d  <span class="hljs-tag">&lt;<span class="hljs-name">domain</span>&gt;</span>.com   \<br>        --key-file   /etc/nginx/ssl/<span class="hljs-tag">&lt;<span class="hljs-name">domain</span>&gt;</span>.key \<br>        --fullchain-file /etc/nginx/ssl/fullchain.cer \<br>        --reloadcmd  &quot;service nginx force-reload&quot;<br></code></pre></td></tr></table></figure><ol start="4"><li>配置nginx使用ssl</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash">server &#123;<br>    listen 80 default_server;<br>    listen 443 http2 ssl;<br>    listen [::]:80 default_server;<br><br>    ssl_certificate /etc/nginx/ssl/fullchain.cer;<br>    ssl_certificate_key /etc/nginx/ssl/domain.key;<br>    <span class="hljs-comment">#http转https</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable">$scheme</span> = http ) &#123;<span class="hljs-built_in">return</span> 301 https://$host<span class="hljs-variable">$request_uri</span>;&#125;<br>    root /var/www/html;<br><br>    index index.html index.htm index.nginx-debian.html;<br>    server_name _;<br><br>    ssl_certificate /etc/nginx/ssl/fullchain.cer;<br>    ssl_certificate_key /etc/nginx/ssl/domain.key;<br><br>    location /test &#123;<br>          proxy_pass       http://127.0.0.1:3000;<br>          proxy_http_version 1.1;<br>          proxy_set_header Upgrade <span class="hljs-variable">$http_upgrade</span>;<br>          proxy_set_header Connection <span class="hljs-string">&quot;upgrade&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>前端的Upgrade请求发送给后端服务器，Upgrade和Connection的头信息必须被显式的设置。一旦我们完成以上设置，NGINX就可以处理WebSocket连接了。查看配置在哪里<code>ps -ef|grep nginx</code><br> 多个域名的话，配多个nginx.conf配置。</p><ol start="5"><li>查看是否有每日任务<br> <code>crontab -l #查看你的任务</code><br> 手动更新证书<code>acme.sh --renew -d domain.com</code></li></ol><h1 id="certbot"><a href="#certbot" class="headerlink" title="certbot"></a>certbot</h1><p><a href="https://certbot.eff.org/">文档</a></p><p>Ubuntu + nginx <a href="https://certbot.eff.org/instructions?ws=nginx&amp;os=ubuntufocal">https://certbot.eff.org/instructions?ws=nginx&amp;os=ubuntufocal</a></p><p>用certbot来自动续期ssl证书</p><ul><li>需要注意的是安装证书的时候最好把nginx关掉先</li></ul>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SSL</tag>
      
      <tag>HTTPS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OSI</title>
    <link href="/2022/1a11e44c/"/>
    <url>/2022/1a11e44c/</url>
    
    <content type="html"><![CDATA[<h1 id="OSI"><a href="#OSI" class="headerlink" title="OSI"></a>OSI</h1><p>开放系统互联参考模型(OSI Referenec Model)，即我们通常所说的网络互联的七层框架，它是国际标准组织(International Organization for Standization)于1977年提出的标准，又称为ISO&#x2F;IEC 7498或X.200建议。值得注意的是，OSI并没有提供一个可以实现的方法，它不是一个标准而只是一个制定标准时使用的概念性的框架，更不是一个网络协议。</p><ol><li>物理层(Physical Layer)：主要功能为定义了网络的物理结构，传输的电磁标准，Bit流的编码及网络的时间原则，如分时复用及分频复用。决定了网络连接类型(端到端或多端连接)及物理拓扑结构。说的通俗一些，这一层主要负责实际的<a href="https://product.pconline.com.cn/itbk/sjtx/sj/1203/2699254.html">信号</a>传输。</li><li>数据链路层(D<a href="https://product.pconline.com.cn/itbk/diy/mb/1107/2474080.html">ata</a> Link eview)：在两个主机上建立数据链路连接，向物理层传输数据信号，并对信号进行处理使之无差错并合理的传输</li><li>网络层(Network Layer)：主要负责路由，选择合适的路径，进行阻塞控制等功能。</li><li>传输层(Transfer Layer)：最关键的一层，向拥护提供可靠的端到端(End-to-End)服务，它屏蔽了下层的数据通信细节，让用户及应用程序不需要考虑实际的通信方法。</li><li>会话层(Session Layer)：主要负责两个会话进程之间的通信，即两个会话层实体之间的信息交换，管理数据的交换。</li><li>表示层(Presentation Layer)：处理通信信号的表示方法，进行不同的格式之间的翻译，并负责数据的加密解密，数据的压缩与恢复</li><li>应用层(Application Layer)：保持应用程序之间建立连接所需要的数据记录，为用户服务。 三大协议NetBEUI和 IPX&#x2F;SPX TCP&#x2F;IP</li></ol><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td></td></tr><tr><td>应用层(Application Layer)</td><td>消息</td></tr><tr><td>表示层(Presentation Layer)</td><td></td></tr><tr><td>会话层(Session Layer)</td><td></td></tr><tr><td>传输层(Transfer Layer)</td><td>数据段(segment)</td></tr><tr><td>网络层(Network Layer)</td><td>分组、数据包（packet）</td></tr><tr><td>链路层(Data Link eview)</td><td>帧（frame）</td></tr><tr><td>物理层(Physical Layer)</td><td>P-PDU（bit）</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OSI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tags Label Category</title>
    <link href="/2022/c65e1067/"/>
    <url>/2022/c65e1067/</url>
    
    <content type="html"><![CDATA[<p>知乎  <a href="https://www.zhihu.com/people/songvision">千鸟</a></p><blockquote><p>  这问题要分两个层面来解读：</p><p>  <strong>首先是Tag与Category的区别。</strong>Category往往限制在一个维度里，当树状结构复杂到不可调和时，出现瓶颈是迟早的事。Category的问题在于，既不能完全满足用户需求，也不能完全表达创建者对内容属性的认知。而Tag反之都成立，完全互补。</p><p>  <strong>其次是Label与Tag的区别。</strong>于对内容的概括出现偏差，但显然这种问题不是tag，在内容组织范畴那应该是什么？答案就是label，除产品描述，其应用范畴还涉及功能名称、模块名称、导航名称、引导文字等等场景。我认为tag与label之间有三个显著差异：</p><ol><li>label是本身的，tag是附加的；</li><li>label强调是一种标志，tag强调是一种记号；</li><li>label标明信息之间的归属，tag区别信息之间的差异。</li></ol></blockquote><p>知乎 郑讯</p><blockquote><p>  Tag，标签，一般包含一段内容的属性，可以是分类，可以是话题，也可以是作者，地理信息等。</p><p>  Label，标记，是网页框架中一个区域的功能概括。比如知乎首页上的“浏览”、“问题”、“通知”就是label。选择不同的标记，相应区域的功能就会发生变化。</p><p>  category，分类，可以理解为种属概念。一段内容有且只有一个种属的分类。和Tag不同的是一段内容可以有多个tag，并且tag是未预先设定的，一段内容可以有多个Tag，也可以没有Tag。但caterory在一个分类标准下只有一个。</p></blockquote><p>知乎 李楠</p><blockquote><p>  <strong>Category</strong></p><p>  Category 是非常理想化和一根筋的分类方式。图书馆这种死板到头的地方用的多。但是他们也遇到了问题：“苏菲的世界”到底是“哲学”，还是“文学”？</p><p>  物理世界无力从根本上解决这种问题（但似乎不少讨论）。问过我们学校的图书馆，似乎他们方式还比较靠谱：<strong>买两本，两处放。</strong></p><p>  分类对象数字化之后， Category 的影响还在（早期的门户找点跨界的东西就很悲剧）。直到 Web2.0 ， Tag 竟然才开始流行。</p><p>  <strong>Tag</strong></p><p>  Tag 是更好的分类方式的原因是：</p><p>  1</p><p>  “类别”本来就不应该事先定义：人不是上帝。</p><p>  从一个个具体对象的“属性”中，总结出“类别”是最自然的模式。也是“人”可以做到的事情。</p><p>  2</p><p>  “属性”本来就应该可以自然的表现为多个。</p><p>  苏菲的世界终于可以自然的打上“哲学”和“文学”的 Tag 了，或者再加个“少儿读物”。这种思考方式比 Category 优雅太多。</p><p>  Tag 最终普及，背后恐怕有<a href="https://www.zhihu.com/search?q=%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:12226710%7D">软件工程</a>上 OO 普及（面向对象）的因素。<strong>“面向对象”不仅仅是的程序构建方式，更是认识世界的方法论的进步。</strong></p><p>  “属性”跟随“对象”，比“对象”属于“类别”更自然，不机械。 。</p><p>  <strong>Tag 的改进</strong></p><p>  Tag 本身也可以看作“对象”。</p><p>  那么就有针对 Tag 的操作，比如“搜索”，“排序”，“关联对象”。也有 Tag 本身的属性，比如“使用次数”，“关注人数”等等。</p><p>  如何能在使用 Tag 的系统中，根据这些数据，计算出最适合的对象，就要靠算法的优化和运营的调整了。</p></blockquote><p>知乎 <a href="https://www.zhihu.com/people/zheng-wei-42-9">榆木脑袋</a></p><blockquote><p>  Catagory是逻辑清晰的。Tag是随意自由的。在看到一个信息的时候我们需要自由捕获自己头脑中的闪光。在重新审视或再利用我们收集的信息时，就需要清晰的逻辑条理。</p><p>  以文件管理为例：</p><p>  在标记Tag时需求有二：一是能够方便增加新的Tag，二是能够很方便的看到已有的Tag，并能同时把已有标签赋予当前信息。</p><p>  在查找文件时个人觉得需要有的功能是：一是有固定的几个入口，也就是根目录；二是可以增加根节点；三是根目录可以指定某几个Tag，也可以不是；三如果根目录不是Tag，需要定义关联到此根目录（分类）下的Tag；四（重点功能）根目录下不直接列出信息或文件（时间长了，某一Tag下文件会相当多），而是列出关联Tag的所有文件的其它Tag，显示为子目录，并标识出此子目录中的文件数量。五（作为管理功能）此时可以定义哪些Tag不在此根目录下出现。六设置某个Tag或某类Tag(文件数量大过一个数量)下仍不列出文件而是继续列出Tag；七子目录（Tag）下，上级目录Tag不再出现。</p><p>  我个人非常偏好使用树形目录结构，但苦恼于文件的多重分类和文件进行多重分类时的繁琐。经过多方搜索只找到三个比较符合的软件，一个是PinKM，一个是蓝码动力图片管理软件，一个是国外的Tabbles。但都因标签管理和整理的繁琐而放弃。</p></blockquote><p><strong>个人理解</strong></p><ul><li>Catagory 是属于严格的分类方法, 一个东西应当只属于一个Catagory内, 而且它是有层级关系的</li><li>Tags 是可有可无的, 一个东西可以有很多的Tags, 它是无层级关系的,</li></ul>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tags</tag>
      
      <tag>Label</tag>
      
      <tag>Category</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>USART硬件流控制</title>
    <link href="/2022/3b631eba/"/>
    <url>/2022/3b631eba/</url>
    
    <content type="html"><![CDATA[<h1 id="USART硬件流控制"><a href="#USART硬件流控制" class="headerlink" title="USART硬件流控制"></a>USART硬件流控制</h1><p><img src="/2022/3b631eba/SouthEast.jpeg"></p><p>RS232 DB9定义</p><p>1 CD ← Carrier Detect 载波检测</p><p>2 RXD ← Receive Data 接收数据</p><p>3 TXD → Transmit Data 发送数据</p><p>4 <strong>DTR → Data Terminal Ready数据终端就绪</strong></p><p>5 GND — System Ground 系统接地</p><p>6 DSR ← Data Set Ready 数据设备就绪</p><p>7 <strong>RTS → Request To Send 请求发送</strong></p><p>8 CTS ← Clear To Send 清除发送(允许发送)</p><p>9 RI → 振铃指示</p><h2 id="RTS-CTS"><a href="#RTS-CTS" class="headerlink" title="RTS CTS"></a>RTS CTS</h2><ul><li>RTS （Require ToSend，发送请求）为输出信号，用于指示本设备准备好可接收数据，低电平有效，低电平说明本设备可以接收数据。</li><li>CTS （Clear ToSend，发送允许）为输入信号，用于判断是否可以向对方发送数据，低电平有效，低电平说明本设备可以向对方发送数据。</li></ul><h2 id="DTR-DSR"><a href="#DTR-DSR" class="headerlink" title="DTR DSR"></a>DTR DSR</h2>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>USART</tag>
      
      <tag>RTS</tag>
      
      <tag>CTS</tag>
      
      <tag>DTR</tag>
      
      <tag>DSR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VScode插件CommentTranslate在WSL内无效</title>
    <link href="/2022/1d3ed0f3/"/>
    <url>/2022/1d3ed0f3/</url>
    
    <content type="html"><![CDATA[<h1 id="VScode插件CommentTranslate在WSL内无效"><a href="#VScode插件CommentTranslate在WSL内无效" class="headerlink" title="VScode插件CommentTranslate在WSL内无效"></a>VScode插件CommentTranslate在WSL内无效</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/intellism/vscode-comment-translate/issues/64">https://github.com/intellism/vscode-comment-translate/issues/64</a></p><ol><li><p>找到相关语言语法规则文件。如C&#x2F;CPP、bat、css、java、python，这些文件都是在Windows版本的VSCode中内置的，文件路径在 <code>C:\Users\ **userNmae** \AppData\Local\Programs\Microsoft VS Code\resources\app\extensions</code>改过安装路径的是<code>Microsoft VS Code\resources\app\extensions</code></p><p><img src="/2022/1d3ed0f3/image-20220811202401467.png" alt="image-20220811202401467"></p></li></ol><p>​</p><ol><li><p>将语法规则的<strong>高亮规则</strong>文件夹拷贝到远程vscode的相关插件目录。以C语言为例，将<code>cpp</code>目录下的高亮规则文件夹<code>syntaxes</code>拷贝到远程C&#x2F;C++插件（<code>ms-vscode.cpptools-x.x.x</code>）目录下。如果你使用SSH远程，远程插件的目录在<code>~/.vscode-server/extensions/ms-vscode.cpptools-x.x.x</code>。</p><p><img src="/2022/1d3ed0f3/image-20220811202845203.png" alt="image-20220811202845203"></p></li><li><p>修改远程插件，添加语法高亮规则。修改远程插件的<code>package.json</code>文件，如C&#x2F;C++插件（<code>ms-vscode.cpptools-x.x.x</code>）目录下的<code>package.json</code>文件，将刚才cpp语法规则文件夹中的<code>package.json</code>文件的”<code>grammars</code>“部分拷贝出来，粘贴到远程插件的<code>package.json</code>的<code>contributes</code>部分中去。</p><p>如果遇到格式难以复制，可以全选内容然后按Shift+Alt+F格式化选定内容。<img src="/2022/1d3ed0f3/image-20220811202944334.png" alt="image-20220811202944334"></p></li></ol><p><img src="/2022/1d3ed0f3/image-20220811203114753.png" alt="image-20220811203114753"></p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VSCode</tag>
      
      <tag>CommentTranslate</tag>
      
      <tag>WSL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows下使用Makefile</title>
    <link href="/2022/714f1d49/"/>
    <url>/2022/714f1d49/</url>
    
    <content type="html"><![CDATA[<h1 id="1-安装MinGW"><a href="#1-安装MinGW" class="headerlink" title="1.安装MinGW"></a>1.安装MinGW</h1><p>在MinGW的bin目录下有一个文件叫<code>mingw32-make.exe</code> 运行它就跟<code>make</code>指令类似</p><p><img src="/2022/714f1d49/watermarkpic_center.png" alt="在这里插入图片描述"></p><h1 id="2-CMD-终端运行Makefile-mingw32-make"><a href="#2-CMD-终端运行Makefile-mingw32-make" class="headerlink" title="2. CMD 终端运行Makefile (mingw32-make)"></a>2. CMD 终端运行Makefile (mingw32-make)</h1><p>在cmd终端下直接输入<code>mingw32-make</code>然后回车就可以进行编译了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">Microsoft Windows [版本 10.0.16299.967]<br>(c) 2017 Microsoft Corporation。保留所有权利。<br><br>D:\Project\Code\C++\hello&gt; mingw32-make.exe<br>g++    -c -o main.o main.cpp<br>g++ -std=c++17 -o main main.o<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>Makefile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>XIP 片内执行</title>
    <link href="/2022/2c1a46d6/"/>
    <url>/2022/2c1a46d6/</url>
    
    <content type="html"><![CDATA[<h1 id="XIP-eXecute-In-Place"><a href="#XIP-eXecute-In-Place" class="headerlink" title="XIP   eXecute In Place"></a>XIP   eXecute In Place</h1><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><p>eXecute In Place，即芯片内执行，是指CPU直接从存储器中读取程序代码执行。</p><p>应用程序可以直接在flash闪存内运行，不必再把代码读到系统RAM中。flash内执行是指nor flash不需要初始化，可以直接在flash内执行代码。但往往<strong>只执行部分代码</strong>，比如<strong>初始化RAM</strong>。好处即是程序代码无需占用内存，减少内存的要求。</p><p><strong>所谓片内执行不是说程序在存储器内执行，CPU的基本功能是取指、译码、运行。Nor Flash能在芯片内执行，指的是CPU能够直接从Nor flash中取指令，供后面的译码器和执行器来使用。</strong></p><p>为实现XIP，必须满足几个条件：</p><ol><li><p>存储器必须提供与内存相似的接口给CPU。</p></li><li><p>该接口必须提供足够快的读取操作，并具有随机访问模式。</p></li><li><p>如有文件系统，则需要提供合适的映射功能</p></li><li><p>程序链接时需要知道存储器的地址或地址与位置无关。</p></li><li><p>程序不能修改已加载映像中的数据。</p></li></ol><p>NOR Flash和EEPROM通常能满足上述要求。</p><h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p><strong>nandflash也可以实现XIP</strong></p><p>“所谓XIP,就是CODE是在FLASH上直接运行. NANDFLASH只是不适合做XIP,但并不是不能做XIP“要一段CODE能够正确的运行,要保证它的CODE是连续的,正确的.由于一些电气特性的原因,NOR FLASH能够做到这一点,不存在坏道或坏块,所以能够做XIP.</p><p><strong>NOR Flash 和 NAND Flash</strong></p><p>NOR Flash具备随机读取给一个地址就能读一个数据，NAND Flash是一次读一块数据，一个地址读出一块数据。</p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>XIP</tag>
      
      <tag>NOR</tag>
      
      <tag>NAND</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机智云通信</title>
    <link href="/2022/60aa39b4/"/>
    <url>/2022/60aa39b4/</url>
    
    <content type="html"><![CDATA[<table><thead><tr><th>包头(2B)</th><th>包长度(2B)</th><th>命令(1B)</th><th>包序号(1B)</th></tr></thead><tbody><tr><td>0xFFFF</td><td>(包长度)后面的数据长度</td><td></td><td></td></tr></tbody></table><table><thead><tr><th>Flag(2B)</th><th>xxx</th><th>校验和(1B)</th></tr></thead><tbody><tr><td></td><td></td><td>和校验</td></tr></tbody></table><p>因为包头为固定 0xFFFF，对于发送方，如检测到有出现 0xFF 的数据内容，需要在 0xFF 后添加 0x55。对于接收方，如检测到非包头部分出现 0xFF，需要把紧跟其后的 0x55 移除。</p><table><thead><tr><th>命令</th><th>内容</th></tr></thead><tbody><tr><td>0x01</td><td>设备向MCU请求信息</td></tr><tr><td>0x02</td><td>MCU回复设备</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
      <tag>机智云</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建KMS</title>
    <link href="/2022/3ef2a47d/"/>
    <url>/2022/3ef2a47d/</url>
    
    <content type="html"><![CDATA[<h1 id="KMS"><a href="#KMS" class="headerlink" title="KMS"></a>KMS</h1><p>KMS（Key Management Service），密钥管理服务</p><p>能够通过KMS进行激活的一般称为VL版,即VOLUME授权版，一般不会单独在零售市场进行发售，一般是直接向企业提供电子ISO映像进行批量授权安装，基于对KMS原理研究成果，我们可以自行搭建KMS激活服务器，实现每180天一次的自动激活，使得系统一直保持激活状态。</p><p>KMS可以激活VOL版本的windows系统和office软件</p><h1 id="Docker-部署KMS服务器"><a href="#Docker-部署KMS服务器" class="headerlink" title="Docker 部署KMS服务器"></a>Docker 部署KMS服务器</h1><p><a href="https://registry.hub.docker.com/r/teddysun/kms">https://registry.hub.docker.com/r/teddysun/kms</a></p><ol><li><p>Pull the image</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull teddysun/kms<br></code></pre></td></tr></table></figure><p>This pulls the latest release of KMS server. It can be found at Docker Hub.</p></li><li><p>Start a container</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d -p 1688:1688 --name kms --restart=always teddysun/kms<br></code></pre></td></tr></table></figure><p>Note: The TCP port number <code>1688</code> must be opened in firewall.</p></li></ol><h1 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h1><h2 id="激活windows"><a href="#激活windows" class="headerlink" title="激活windows"></a>激活windows</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 待激活的主机上指定KMS服务器</span><br>slmgr /skms service_address(你搭建的服务器的地址)<br><br><span class="hljs-comment"># 手动激活</span><br>slmgr /ato<br><br><span class="hljs-comment"># 如果激活失败 尝试更改成GVLK KEY再次激活</span><br><span class="hljs-comment"># 运行以下命令查看系统版本 </span><br>wmic os get caption<br><br><span class="hljs-comment"># 访问下面的网址获取key</span><br><span class="hljs-comment"># https://docs.microsoft.com/zh-cn/windows-server/get-started/kms-client-activation-keys</span><br><span class="hljs-comment"># https://technet.microsoft.com/en-us/library/jj612867.aspx</span><br><span class="hljs-comment"># 得到对应key之后，使用管理员权限运行cmd执行安装key：</span><br>slmgr /ipk xxxxx-xxxxx-xxxxx-xxxxx<br><br><span class="hljs-comment"># 手动激活</span><br>slmgr /ato<br></code></pre></td></tr></table></figure><h2 id="激活office"><a href="#激活office" class="headerlink" title="激活office"></a>激活office</h2><p>首先你的OFFICE必须是VOL版本，否则无法激活。 找到你的office安装目录，比如</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">C:<span class="hljs-string">\Program</span> Files (x86)<span class="hljs-string">\Microsoft</span> Office<span class="hljs-string">\Office16</span><br></code></pre></td></tr></table></figure><p>64位的就是</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">C:<span class="hljs-string">\Program</span> Files<span class="hljs-string">\Microsoft</span> Office<span class="hljs-string">\Office16</span><br></code></pre></td></tr></table></figure><p>office16是office2016，office15就是2013，office14就是2010.</p><p>然后目录对的话，该目录下面应该有个OSPP.VBS。</p><p>直接输入下面的指令去指定KMS服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">cscript <span class="hljs-string">&quot;C:\Program Files (x86)\Microsoft Office\Office16\OSPP.VBS&quot;</span> sethst:service_address(你搭建的服务器的地址)<br><span class="hljs-comment"># or</span><br>cscript <span class="hljs-string">&quot;C:\Program Files\Microsoft Office\Office16\OSPP.VBS&quot;</span> /sethst:service_address(你搭建的服务器的地址)<br></code></pre></td></tr></table></figure><p>一般来说，“一句命令已经完成了”，但一般office不会马上连接kms服务器进行激活，所以我们额外补充一条手动激活命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cscript ospp.vbs /act<br></code></pre></td></tr></table></figure><h1 id="如果遇到报错，请检查："><a href="#如果遇到报错，请检查：" class="headerlink" title="如果遇到报错，请检查："></a>如果遇到报错，请检查：</h1><blockquote><ol><li>你的系统&#x2F;OFFICE是否是批量VL版本</li><li>是否以管理员权限运行CMD</li><li>你的系统&#x2F;OFFICE是否修改过KEY&#x2F;未安装GVLK KEY</li><li>检查你的网络连接</li><li>服务器繁忙，多试试（点击检查KMS服务是否可用）</li><li>根据出错代码自己搜索出错原因</li></ol></blockquote><h2 id="windows没有密钥"><a href="#windows没有密钥" class="headerlink" title="windows没有密钥"></a>windows没有密钥</h2><ul><li>windows VOL KEY</li></ul><p><a href="https://docs.microsoft.com/zh-cn/windows-server/get-started/kmsclientkeys">https://docs.microsoft.com/zh-cn/windows-server/get-started/kmsclientkeys</a></p><h2 id="检查windows版本"><a href="#检查windows版本" class="headerlink" title="检查windows版本"></a>检查windows版本</h2><ul><li>检查office是否是VOL版本</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 命令提示符（管理员）执行：cd “office的安装目录”</span><br><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;C:\Program Files (x86)\Microsoft Office\Office16&quot;</span><br><span class="hljs-comment"># or</span><br><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;C:\Program Files\Microsoft Office\Office16&quot;</span><br><br><span class="hljs-comment"># 执行：</span><br>cscript ospp.vbs /dstatus<br></code></pre></td></tr></table></figure><p>在显示的信息中，如果有“VOLUME”字样就是VOL版，即支持KMS激活</p><h2 id="office-密钥"><a href="#office-密钥" class="headerlink" title="office 密钥"></a>office 密钥</h2><ul><li>卸载office的密钥</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 命令提示符（管理员）执行：cd “office的安装目录”</span><br><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;C:\Program Files (x86)\Microsoft Office\Office16&quot;</span><br><span class="hljs-comment"># or</span><br><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;C:\Program Files\Microsoft Office\Office16&quot;</span><br><br><span class="hljs-comment"># 查看当前状态</span><br>cscript ospp.vbs /dstatus<br><br><span class="hljs-comment"># 找到 Last 5 characters of installed product key:XXXXX 语句</span><br><span class="hljs-comment"># 卸载密钥</span><br>cscript ospp.vbs /unpkey:XXXXX<br></code></pre></td></tr></table></figure><ul><li>查找office的VOL KEY</li></ul><p><a href="https://docs.microsoft.com/zh-cn/DeployOffice/vlactivation/gvlks">https://docs.microsoft.com/zh-cn/DeployOffice/vlactivation/gvlks</a></p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>KMS</tag>
      
      <tag>office</tag>
      
      <tag>volume</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蓝桥杯STM32国赛笔记</title>
    <link href="/2022/b9b15cd2/"/>
    <url>/2022/b9b15cd2/</url>
    
    <content type="html"><![CDATA[<h1 id="CT117E-EX-扩展板笔记"><a href="#CT117E-EX-扩展板笔记" class="headerlink" title="CT117E-EX 扩展板笔记"></a>CT117E-EX 扩展板笔记</h1><h2 id="数码管（74HC595）"><a href="#数码管（74HC595）" class="headerlink" title="数码管（74HC595）"></a>数码管（74HC595）</h2><h3 id="RCLK-R-存储寄存器读取"><a href="#RCLK-R-存储寄存器读取" class="headerlink" title="RCLK(R:存储寄存器读取)"></a>RCLK(R:存储寄存器读取)</h3><ul><li>上升沿    移位寄存器进入存储寄存器</li><li>下降沿    数据保持不变</li></ul><h3 id="SCK-S-送入595"><a href="#SCK-S-送入595" class="headerlink" title="SCK(S:送入595)"></a>SCK(S:送入595)</h3><ul><li>上升沿    数据寄存器数据移位。Q0–&gt;Q1–&gt;Q2–&gt;Q3–&gt;…–&gt;Q7;</li><li>下降沿    移位寄存器数据不变</li></ul><h3 id="SER（数据脚）"><a href="#SER（数据脚）" class="headerlink" title="SER（数据脚）"></a>SER（数据脚）</h3><ul><li>串行数据输入端</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">SEG_DisplayValue</span><span class="hljs-params">(u8 Bit1,  u8 Bit2, u8 Bit3)</span><br>&#123;<br>u8 i = <span class="hljs-number">0</span>;<span class="hljs-comment">//</span><br>u8 code_tmp = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    *略过部分代码</span><br><span class="hljs-comment">    */</span><br><br>code_tmp = Seg7[Bit1];<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)&#123;<br><br><span class="hljs-keyword">if</span>(code_tmp &amp; <span class="hljs-number">0x80</span>)&#123;<br>SER_H;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>SER_L;<br>&#125;<br>SCK_H;<span class="hljs-comment">//数据移位</span><br>code_tmp = code_tmp &lt;&lt; <span class="hljs-number">1</span>;   <br>SCK_L;<br>&#125;<br>RCLK_H;<span class="hljs-comment">//上升沿时移位寄存器进入存储寄存器</span><br>RCLK_L;<span class="hljs-comment">//下降沿是数据保持不变</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数码管显示数组"><a href="#数码管显示数组" class="headerlink" title="数码管显示数组"></a>数码管显示数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">u8 code t_display[]=&#123;                       <span class="hljs-comment">//标准字库</span><br><span class="hljs-comment">//   0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F</span><br><span class="hljs-number">0x3F</span>,<span class="hljs-number">0x06</span>,<span class="hljs-number">0x5B</span>,<span class="hljs-number">0x4F</span>,<span class="hljs-number">0x66</span>,<span class="hljs-number">0x6D</span>,<span class="hljs-number">0x7D</span>,<span class="hljs-number">0x07</span>,<span class="hljs-number">0x7F</span>,<span class="hljs-number">0x6F</span>,<span class="hljs-number">0x77</span>,<span class="hljs-number">0x7C</span>,<span class="hljs-number">0x39</span>,<span class="hljs-number">0x5E</span>,<span class="hljs-number">0x79</span>,<span class="hljs-number">0x71</span>,<br><br><span class="hljs-comment">//black  -     H    J    K    L    N    o   P    U     t    G    Q    r   M    y</span><br><span class="hljs-number">0x00</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x76</span>,<span class="hljs-number">0x1E</span>,<span class="hljs-number">0x70</span>,<span class="hljs-number">0x38</span>,<span class="hljs-number">0x37</span>,<span class="hljs-number">0x5C</span>,<span class="hljs-number">0x73</span>,<span class="hljs-number">0x3E</span>,<span class="hljs-number">0x78</span>,<span class="hljs-number">0x3d</span>,<span class="hljs-number">0x67</span>,<span class="hljs-number">0x50</span>,<span class="hljs-number">0x37</span>,<span class="hljs-number">0x6e</span>,<br>    <br> <span class="hljs-comment">//0. 1. 2. 3. 4. 5. 6. 7. 8. 9. -1</span><br><span class="hljs-number">0xBF</span>,<span class="hljs-number">0x86</span>,<span class="hljs-number">0xDB</span>,<span class="hljs-number">0xCF</span>,<span class="hljs-number">0xE6</span>,<span class="hljs-number">0xED</span>,<span class="hljs-number">0xFD</span>,<span class="hljs-number">0x87</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xEF</span>,<span class="hljs-number">0x46</span>&#125;;    <br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//   0    1    2    3    4    5    6    7    8    9</span><br><br><span class="hljs-number">0x3F</span>,<span class="hljs-number">0x06</span>,<span class="hljs-number">0x5B</span>,<span class="hljs-number">0x4F</span>,<span class="hljs-number">0x66</span>,<span class="hljs-number">0x6D</span>,<span class="hljs-number">0x7D</span>,<span class="hljs-number">0x07</span>,<span class="hljs-number">0x7F</span>,<span class="hljs-number">0x6F</span>,<span class="hljs-number">0x77</span><br></code></pre></td></tr></table></figure><h2 id="ADC按键"><a href="#ADC按键" class="headerlink" title="ADC按键"></a>ADC按键</h2><h3 id="ADC-KEY-引脚"><a href="#ADC-KEY-引脚" class="headerlink" title="ADC KEY 引脚"></a>ADC KEY 引脚</h3><p> PA5      ADC_12_<strong>IN5</strong></p><h3 id="按键值"><a href="#按键值" class="headerlink" title="按键值"></a>按键值</h3><table><thead><tr><th align="left">ADC值</th><th>ADC按键区间</th></tr></thead><tbody><tr><td align="left">0</td><td>&lt;100</td></tr><tr><td align="left">200</td><td>&lt;400</td></tr><tr><td align="left">600</td><td>&lt;800</td></tr><tr><td align="left">1000</td><td>&lt;1200</td></tr><tr><td align="left">1300-1400</td><td>&lt;1600</td></tr><tr><td align="left">1700-1900</td><td>&lt;2000</td></tr><tr><td align="left">2100-2400</td><td>&lt;2600</td></tr><tr><td align="left">2800-3000</td><td>&lt;3200</td></tr></tbody></table><h2 id="DHT11模块"><a href="#DHT11模块" class="headerlink" title="DHT11模块"></a>DHT11模块</h2><h3 id="芯片性能"><a href="#芯片性能" class="headerlink" title="芯片性能"></a>芯片性能</h3><ul><li>温度测量范围：0－50℃</li><li>湿度测量范围：20－90％RH</li><li>采样周期 ：1S</li></ul><h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><table><thead><tr><th>Byte0</th><th>Byte1</th><th>Byte2</th><th>Byte3</th><th>Byte4</th></tr></thead><tbody><tr><td>湿度整数数据</td><td>湿度小数数据</td><td>温度整数数据</td><td>温度小数数据</td><td>校验和</td></tr></tbody></table><h3 id="编程思路"><a href="#编程思路" class="headerlink" title="编程思路"></a>编程思路</h3><ul><li>主机输出</li><li>主机拉  <strong>低</strong>  至少 <font color="red">18ms</font></li><li>主机拉  <strong>高</strong>  <font color="red">20-40us</font></li><li>主机输入</li><li>主机等待信号线拉 <strong>低</strong>   （DHT11发送持续  <strong>40-50us</strong> 的  <strong>低</strong>   响应信号）</li><li>主机等待信号线拉 <strong>高</strong>   （DHT11发送持续  <strong>40-50us</strong> 的  <strong>高</strong>   拉高信号）</li><li>for(){   &#x2F;&#x2F;40bit数据       5Byte<ul><li>主机等待数据线拉<strong>低</strong>    （数据Bit开始）</li><li>主机等待数据线拉<strong>高</strong>    </li><li>主机延时 时间大于<strong>28us</strong>小于<strong>70us</strong>    （ <font color="red">Type值 40us</font>）</li><li>主机读取数据</li></ul></li><li>}</li><li>主机输出</li><li>主机拉高</li></ul><h3 id="技巧-amp-TIP"><a href="#技巧-amp-TIP" class="headerlink" title="技巧&amp;TIP"></a>技巧&amp;TIP</h3><ul><li><p>DHT11分辨率都是整数级别的<strong>读取小数的数据部分没有意义</strong>。（全为0）</p></li><li><p>读取间隔建议大于100ms（采样 1S 过高的读取频率没有意义）</p></li><li><p>在72MHz频率下 <strong>Delay_LCD</strong> 运行一次大约 <strong>375us</strong></p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Delay_LCD</span><span class="hljs-params">(u16 n)</span><br>&#123;<br>u16 i,j;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>;i&lt;n;++i)<br><span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">3000</span>;++j);<br>&#125;<br><span class="hljs-comment">//将里面的 3000 改成 8 运行一次大概 1us </span><br><span class="hljs-comment">//运行次数越少比1us越多</span><br><span class="hljs-comment">//运行次数越多比1us越少</span><br></code></pre></td></tr></table></figure><h2 id="18B20模块"><a href="#18B20模块" class="headerlink" title="18B20模块"></a>18B20模块</h2><h3 id="芯片性能-1"><a href="#芯片性能-1" class="headerlink" title="芯片性能"></a>芯片性能</h3><ul><li>±0.5°C accuracy from -10°C to +85°C</li><li>Can be powered from data line. Power supply range is 3.0V to 5.5V</li><li>Converts 12-bit temperature to digital word in 750 ms (max.)</li></ul><h3 id="数据格式-1"><a href="#数据格式-1" class="headerlink" title="数据格式"></a>数据格式</h3><h4 id="数据格式-2"><a href="#数据格式-2" class="headerlink" title="数据格式"></a>数据格式</h4><ul><li><p>写Byte数据先写<strong>低位</strong></p></li><li><p>读Byte数据先读出的是<strong>低位</strong></p></li><li><p>读出来的温度先是  <strong>LSM 8bit</strong>  然后是 MSB 8bit</p></li></ul><h4 id="总线协议-amp-时序"><a href="#总线协议-amp-时序" class="headerlink" title="总线协议&amp;时序"></a>总线协议&amp;时序</h4><p><img src="/2022/b9b15cd2/01-1557625836489.png" alt="复位时序"></p><p><img src="/2022/b9b15cd2/02.png" alt="读写时序"></p><h3 id="编程思路-1"><a href="#编程思路-1" class="headerlink" title="编程思路"></a>编程思路</h3><p>0xCCOW_SKIP_ROM</p><p>0x44DS18B20_CONVERT</p><p>0xCCOW_SKIP_ROM</p><p>0xBEDS18B20_READ</p><h2 id="LIS302DL"><a href="#LIS302DL" class="headerlink" title="LIS302DL"></a>LIS302DL</h2><p>NULL</p><h2 id="光敏-D-amp-A"><a href="#光敏-D-amp-A" class="headerlink" title="光敏 D&amp;A"></a>光敏 D&amp;A</h2><h3 id="光敏D"><a href="#光敏D" class="headerlink" title="光敏D"></a>光敏D</h3><ul><li>GPIOA_Pin_3 </li><li>GPIO_Mode_IPU</li></ul><h3 id="光敏A"><a href="#光敏A" class="headerlink" title="光敏A"></a>光敏A</h3><ul><li><p>GPIOA_Pin_4</p></li><li><p>ADC1</p></li><li><p>ADC_Channel_4</p></li></ul><h2 id="电位器"><a href="#电位器" class="headerlink" title="电位器"></a>电位器</h2><p>NULL</p><h2 id="PULS-amp-PWM"><a href="#PULS-amp-PWM" class="headerlink" title="PULS&amp;PWM"></a>PULS&amp;PWM</h2><p>PA1        TIM2_CH2</p><p>PA2        TIM2_CH3</p><p>PA6        TIM3_CH1</p><p>PA7        TIM3_CH2</p><h2 id="界面颜色搭配"><a href="#界面颜色搭配" class="headerlink" title="界面颜色搭配"></a>界面颜色搭配</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">LCD_SetBackColor(Blue);<br>LCD_SetTextColor(White);<br><span class="hljs-comment">//Line01</span><br>LCD_SetBackColor(White);<br>LCD_SetTextColor(Blue);<br><span class="hljs-comment">//Line1-77</span><br>LCD_SetBackColor(Blue);<br>LCD_SetTextColor(Black);<br><span class="hljs-comment">//Line892</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STM32</tag>
      
      <tag>蓝桥杯</tag>
      
      <tag>国赛</tag>
      
      <tag>CT117E</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决 Github 无法打开</title>
    <link href="/2022/db5fa6fe/"/>
    <url>/2022/db5fa6fe/</url>
    
    <content type="html"><![CDATA[<h1 id="解决-Github-无法打开"><a href="#解决-Github-无法打开" class="headerlink" title="解决 Github 无法打开"></a>解决 Github 无法打开</h1><h2 id="SwitchHosts"><a href="#SwitchHosts" class="headerlink" title="SwitchHosts"></a>SwitchHosts</h2><ol><li><p>下载 SwitchHosts <a href="https://github.com/oldj/SwitchHosts">Github</a> 下载要是太慢可以 用gitee镜像一下github的库 这里放一个别人镜像过的 <a href="https://gitee.com/itas109/SwitchHosts?_from=gitee_search">Gitee</a></p></li><li><p>安装后新建一个配置</p><ul><li>Title: 随意  Type: Remote  URL:   Auto Refresh: 最好选 1 hour</li></ul><p><img src="/2022/db5fa6fe/image-20211015220230835.png" alt="image-20211015220230835"></p><ul><li>可选的URL：<ul><li>520Github <a href="https://raw.hellogithub.com/hosts">https://raw.hellogithub.com/hosts</a></li><li>ineo6 <a href="https://gitee.com/ineo6/hosts/raw/master/hosts">https://gitee.com/ineo6/hosts/raw/master/hosts</a></li><li>有看到网上还有多个网站同时更新的，但是看到更新速度不够快，也就放弃了。</li></ul></li></ul></li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://github.com/ineo6/hosts">https://github.com/ineo6/hosts</a></p><p><a href="https://github.com/521xueweihan/GitHub520">https://github.com/521xueweihan/GitHub520</a></p><h2 id="Chrome-插件方式"><a href="#Chrome-插件方式" class="headerlink" title="Chrome 插件方式"></a>Chrome 插件方式</h2><p><a href="https://github.com/gauseen/faster-hosts">FasterHosts</a> 是个 Chrome 插件，主要原理是拦截浏览器的某些请求，将 <code>domain</code> 替换成访问速度较快的那个。hosts 资源来自 <a href="https://github.com/521xueweihan/GitHub520">GitHub520</a>，每 1 小时更新一次。</p><blockquote><ol><li>下载 <a href="https://github.com/gauseen/faster-hosts/archive/master.zip">FasterHosts</a> 然后解压，找到 <code>extension</code> 子目录</li><li>打开 Chrome，输入: <code>chrome://extensions/</code></li><li>打开「开发者模式」</li><li>选择「加载已解压的扩展程序」，然后定位到刚才解压的文件夹里面的 <code>extension</code> 目录，确定</li><li>这就安装好了，关闭「开发者模式」</li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github</tag>
      
      <tag>hosts</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C</title>
    <link href="/2022/3dd7ffa7/"/>
    <url>/2022/3dd7ffa7/</url>
    
    <content type="html"><![CDATA[<h1 id="标准库函数"><a href="#标准库函数" class="headerlink" title="标准库函数"></a>标准库函数</h1><h2 id="fprintf-输出到流中"><a href="#fprintf-输出到流中" class="headerlink" title="fprintf 输出到流中"></a>fprintf 输出到流中</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>C 库函数 <strong>int fprintf(FILE *stream, const char *format, …)</strong> 发送格式化输出到流 stream 中。</p><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>下面是 fprintf() 函数的声明。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fprintf</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span><br></code></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。</li><li><strong>format</strong> – 这是 C 字符串，包含了要被写入到流 stream 中的文本。它可以包含嵌入的 format 标签，format 标签可被随后的附加参数中指定的值替换，并按需求进行格式化。format 标签属性是 <strong>%[flags][width][.precision][length]specifier</strong>，具体讲解如下：</li></ul><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>如果成功，则返回写入的字符总数，否则返回一个负数。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>下面的实例演示了 fprintf() 函数的用法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>   FILE * fp;<br><br>   fp = fopen (<span class="hljs-string">&quot;file.txt&quot;</span>, <span class="hljs-string">&quot;w+&quot;</span>);<br>   <span class="hljs-built_in">fprintf</span>(fp, <span class="hljs-string">&quot;%s %s %s %d&quot;</span>, <span class="hljs-string">&quot;We&quot;</span>, <span class="hljs-string">&quot;are&quot;</span>, <span class="hljs-string">&quot;in&quot;</span>, <span class="hljs-number">2014</span>);<br>   <br>   fclose(fp);<br>   <br>   <span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>让我们编译并运行上面的程序，这将创建文件 <strong>file.txt</strong>，它的内容如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">We</span> are in <span class="hljs-number">2014</span><br></code></pre></td></tr></table></figure><h2 id="atoi-字符串转换成整数"><a href="#atoi-字符串转换成整数" class="headerlink" title="atoi 字符串转换成整数"></a>atoi 字符串转换成整数</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>C 库函数 <strong>int atoi(const char *str)</strong> 把参数 <strong>str</strong> 所指向的字符串转换为一个整数（类型为 int 型）。</p><h3 id="声明-1"><a href="#声明-1" class="headerlink" title="声明"></a>声明</h3><p>下面是 atoi() 函数的声明。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">atoi</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str)</span><br></code></pre></td></tr></table></figure><h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><ul><li><strong>str</strong> – 要转换为整数的字符串。</li></ul><h3 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h3><p>该函数返回转换后的长整数，如果没有执行有效的转换，则返回零。</p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>下面的实例演示了 atoi() 函数的用法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>   <span class="hljs-type">int</span> val;<br>   <span class="hljs-type">char</span> str[<span class="hljs-number">20</span>];<br>   <br>   <span class="hljs-built_in">strcpy</span>(str, <span class="hljs-string">&quot;98993489&quot;</span>);<br>   val = atoi(str);<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;字符串值 = %s, 整型值 = %d\n&quot;</span>, str, val);<br><br>   <span class="hljs-built_in">strcpy</span>(str, <span class="hljs-string">&quot;runoob.com&quot;</span>);<br>   val = atoi(str);<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;字符串值 = %s, 整型值 = %d\n&quot;</span>, str, val);<br><br>   <span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>让我们编译并运行上面的程序，这将产生以下结果：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">字符串值 = <span class="hljs-number">98993489</span>, 整型值 = <span class="hljs-number">98993489</span><br>字符串值 = runoob.com, 整型值 = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h1 id="杂乱"><a href="#杂乱" class="headerlink" title="杂乱"></a>杂乱</h1><h2 id="stderr-stdout"><a href="#stderr-stdout" class="headerlink" title="stderr stdout"></a>stderr stdout</h2><ul><li><p>stdout – 标准输出设备 stdout。 </p></li><li><p>stderr – 标准错误输出设备</p></li></ul><p>两者默认向屏幕输出。 但如果用转向标准输出到磁盘文件，则可看出两者区别。stdout输出到磁盘文件，stderr在屏幕。 </p><blockquote><p>转向标准输出到磁盘文件tmp.txt<br>my.exe &gt; tmp.txt</p></blockquote><p>在默认情况下，stdout是行缓冲的，他的输出会放在一个buffer里面，只有到换行的时候，才会输出到屏幕。而stderr是无缓冲的，会直接输出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stdout</span>,<span class="hljs-string">&quot;Group&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<span class="hljs-string">&quot;XiyouLinux&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">linux下，第一次会输出XiYouLinuxGroup,是因为stdout将输出的Group放到了缓冲区当中直到程序结束在将缓冲区中的数据刷新出来。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MicroPython</title>
    <link href="/2022/bf76c113/"/>
    <url>/2022/bf76c113/</url>
    
    <content type="html"><![CDATA[<h1 id="MicroPython"><a href="#MicroPython" class="headerlink" title="MicroPython"></a>MicroPython</h1><p><a href="https://www.cirmall.com/articles/301308/p1">简单、方便、快速开发嵌入式实时系统——MicroPytho</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pyb <span class="hljs-keyword">import</span> uart<br><br><span class="hljs-keyword">from</span> pyb <span class="hljs-keyword">import</span> I2C <span class="hljs-comment">#工程师将从pyb库导入I2C</span><br><span class="hljs-comment">#这里的PYB库提供了接入到微控制器外围功能，如SPI，I2C以及UART</span><br><span class="hljs-comment">#在使用任何外设之前，工程师必须实例化外设类以创建可用于控制外设的对象。一旦外设类被初始化，工程师可以执行任何其他操作，例如在进入主应用程序循环之前验证设备是否存在，主要应用程序代码将会每秒采样一次传感器。</span><br><br>GlobalTemp = <span class="hljs-number">0.0</span><br><br>GlobalBarometer = <span class="hljs-number">0.0</span><br><br>＃初始化和实例化I2C外设<span class="hljs-number">2</span><br><br>I2C2 = I2C（<span class="hljs-number">2</span>，I2C.MASTER，波特率= <span class="hljs-number">100000</span>）<br><br>＃配置Uart1进行通信<br><br>Uart1 = pyb.UART（<span class="hljs-number">1</span>,<span class="hljs-number">115200</span>）<br><br>Uart1.init（<span class="hljs-number">115200</span>，bits = <span class="hljs-number">8</span>，parity = <span class="hljs-literal">None</span>，stop = <span class="hljs-number">1</span>）<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br><br>SampleSensor（）<br><br>pyb.delay（<span class="hljs-number">1000</span>）<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">SensorSample</span>（）：<br><br>＃读取温度数据<br><br>TempSample = I2C2.readfrom_mem（<span class="hljs-number">119</span>，<span class="hljs-number">0xFA</span>，<span class="hljs-number">3</span>）<br><br>＃读取压力数据<br><br>PressureSample = I2C2.readfrom_mem（<span class="hljs-number">119</span>，<span class="hljs-number">0xF7</span>,<span class="hljs-number">3</span>）<br><br>将样本数据转换为字符串<br><br>data =“＃，temperature =”<span class="hljs-built_in">str</span>（TempSample）+“，pressure”+ <span class="hljs-built_in">str</span>（PressureSample）+“，＃，\ n \ r”<br><br>＃将数据写入蓝牙<br><br>Uart1.write（data）<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
      <tag>MicroPython</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MS-DOS</title>
    <link href="/2022/ddff0c71/"/>
    <url>/2022/ddff0c71/</url>
    
    <content type="html"><![CDATA[<h1 id="MS-DOS"><a href="#MS-DOS" class="headerlink" title="MS-DOS"></a>MS-DOS</h1><p><strong>CMD(windows-commands)</strong></p><p><a href="https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/windows-commands">Windowscommands</a></p><p>在cmd内<code>/?</code>即可获得帮助信息</p><h2 id="FOR"><a href="#FOR" class="headerlink" title="FOR"></a>FOR</h2><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs tex">对一组文件中的每一个文件执行某个特定命令。<br><br>FOR <span class="hljs-comment">%variable IN (set) DO command [command-parameters]</span><br><br>  <span class="hljs-comment">%variable  指定一个单一字母可替换的参数。</span><br>  (set)      指定一个或一组文件。可以使用通配符。<br>  command    指定对每个文件执行的命令。<br>  command-parameters <br>             为特定命令指定参数或命令行开关。<br><br>在批处理程序中使用 FOR 命令时，指定变量请使用 <span class="hljs-comment">%%variable</span><br>而不要用 <span class="hljs-comment">%variable。变量名称是区分大小写的，所以 %i 不同于 %I.</span><br><br>如果启用命令扩展，则会支持下列 FOR 命令的其他格式:<br><br>FOR /D <span class="hljs-comment">%variable IN (set) DO command [command-parameters]</span><br><br>    如果集中包含通配符，则指定与目录名匹配，而不与文件名匹配。<br><br>FOR /R [[drive:]path] <span class="hljs-comment">%variable IN (set) DO command [command-parameters]</span><br><br>    检查以 [drive:]path 为根的目录树，指向每个目录中的 FOR 语句。<br>    如果在 /R 后没有指定目录规范，则使用当前目录。如果集仅为一个单点(.)字符，<br>    则枚举该目录树。<br><br>FOR /L <span class="hljs-comment">%variable IN (start,step,end) DO command [command-parameters]</span><br><br>    该集表示以增量形式从开始到结束的一个数字序列。因此，(1,1,5)将产生序列<br>    1 2 3 4 5，(5,-1,1)将产生序列(5 4 3 2 1)<br><br>FOR /F [&quot;options&quot;] <span class="hljs-comment">%variable IN (file-set) DO command [command-parameters]</span><br>FOR /F [&quot;options&quot;] <span class="hljs-comment">%variable IN (&quot;string&quot;) DO command [command-parameters]</span><br>FOR /F [&quot;options&quot;] <span class="hljs-comment">%variable IN (&#x27;command&#x27;) DO command [command-parameters]</span><br><br>    或者，如果有 usebackq 选项:<br><br>FOR /F [&quot;options&quot;] <span class="hljs-comment">%variable IN (file-set) DO command [command-parameters]</span><br>FOR /F [&quot;options&quot;] <span class="hljs-comment">%variable IN (&quot;string&quot;) DO command [command-parameters]</span><br>FOR /F [&quot;options&quot;] <span class="hljs-comment">%variable IN (&#x27;command&#x27;) DO command [command-parameters]</span><br><br>    fileset 为一个或多个文件名。继续到 fileset 中的下一个文件之前，<br>    每份文件都被打开、读取并经过处理。处理包括读取文件，将其分成一行行的文字，<br>    然后将每行解析成零或更多的符号。然后用已找到的符号字符串变量值调用 For 循环。<br>    以默认方式，/F 通过每个文件的每一行中分开的第一个空白符号。跳过空白行。<br>    你可通过指定可选 &quot;options&quot; 参数替代默认解析操作。这个带引号的字符串包括一个<br>    或多个指定不同解析选项的关键字。这些关键字为:<br><br>        eol=c           - 指一个行注释字符的结尾(就一个)<br>        skip=n          - 指在文件开始时忽略的行数。<br>        delims=xxx      - 指分隔符集。这个替换了空格和制表符的<br>                          默认分隔符集。<br>        tokens=x,y,m-n  - 指每行的哪一个符号被传递到每个迭代<br>                          的 for 本身。这会导致额外变量名称的分配。m-n<br>                          格式为一个范围。通过 nth 符号指定 mth。如果<br>                          符号字符串中的最后一个字符星号，<br>                          那么额外的变量将在最后一个符号解析之后<br>                          分配并接受行的保留文本。<br>        usebackq        - 指定新语法已在下类情况中使用:<br>                          在作为命令执行一个后引号的字符串并且一个单<br>                          引号字符为文字字符串命令并允许在 file-set<br>                          中使用双引号扩起文件名称。<br><br>    某些范例可能有助:<br><br>FOR /F &quot;eol=; tokens=2,3* delims=, &quot; <span class="hljs-comment">%i in (myfile.txt) do @echo %i %j %k</span><br><br>    会分析 myfile.txt 中的每一行，忽略以分号打头的那些行，将<br>    每行中的第二个和第三个符号传递给 for 函数体，用逗号和/或<br>    空格分隔符号。请注意，此 for 函数体的语句引用 <span class="hljs-comment">%i 来</span><br>    获得第二个符号，引用 <span class="hljs-comment">%j 来获得第三个符号，引用 %k</span><br>    来获得第三个符号后的所有剩余符号。对于带有空格的文件<br>    名，你需要用双引号将文件名括起来。为了用这种方式来使<br>    用双引号，还需要使用 usebackq 选项，否则，双引号会<br>    被理解成是用作定义某个要分析的字符串的。<br><br>    <span class="hljs-comment">%i 在 for 语句中显式声明，%j 和 %k 是通过</span><br>    tokens= 选项隐式声明的。可以通过 tokens= 一行<br>    指定最多 26 个符号，只要不试图声明一个高于字母 &quot;z&quot; 或<br>    &quot;Z&quot; 的变量。请记住，FOR 变量是单一字母、分大小写和全局的变量；<br>    而且，不能同时使用超过 52 个。<br><br>    还可以在相邻字符串上使用 FOR /F 分析逻辑，方法是，<br>    用单引号将括号之间的 file-set 括起来。这样，该字符<br>    串会被当作一个文件中的一个单一输入行进行解析。<br><br>    最后，可以用 FOR /F 命令来分析命令的输出。方法是，将<br>    括号之间的 file-set 变成一个反括字符串。该字符串会<br>    被当作命令行，传递到一个子 CMD.EXE，其输出会被捕获到<br>    内存中，并被当作文件分析。如以下例子所示:<br><br>      FOR /F &quot;usebackq delims==&quot; <span class="hljs-comment">%i IN (`set`) DO @echo %i</span><br><br>    会枚举当前环境中的环境变量名称。<br><br>另外，FOR 变量参照的替换已被增强。你现在可以使用下列<br>选项语法:<br><br>     <span class="hljs-comment">%~I          - 删除任何引号(&quot;)，扩展 %I</span><br>     <span class="hljs-comment">%~fI        - 将 %I 扩展到一个完全合格的路径名</span><br>     <span class="hljs-comment">%~dI        - 仅将 %I 扩展到一个驱动器号</span><br>     <span class="hljs-comment">%~pI        - 仅将 %I 扩展到一个路径</span><br>     <span class="hljs-comment">%~nI        - 仅将 %I 扩展到一个文件名</span><br>     <span class="hljs-comment">%~xI        - 仅将 %I 扩展到一个文件扩展名</span><br>     <span class="hljs-comment">%~sI        - 扩展的路径只含有短名</span><br>     <span class="hljs-comment">%~aI        - 将 %I 扩展到文件的文件属性</span><br>     <span class="hljs-comment">%~tI        - 将 %I 扩展到文件的日期/时间</span><br>     <span class="hljs-comment">%~zI        - 将 %I 扩展到文件的大小</span><br>     <span class="hljs-comment">%~$PATH:I   - 查找列在路径环境变量的目录，并将 %I 扩展</span><br>                   到找到的第一个完全合格的名称。如果环境变量名<br>                   未被定义，或者没有找到文件，此组合键会扩展到<br>                   空字符串<br><br>可以组合修饰符来得到多重结果:<br><br>     <span class="hljs-comment">%~dpI       - 仅将 %I 扩展到一个驱动器号和路径</span><br>     <span class="hljs-comment">%~nxI       - 仅将 %I 扩展到一个文件名和扩展名</span><br>     <span class="hljs-comment">%~fsI       - 仅将 %I 扩展到一个带有短名的完整路径名</span><br>     <span class="hljs-comment">%~dp$PATH:I - 搜索列在路径环境变量的目录，并将 %I 扩展</span><br>                   到找到的第一个驱动器号和路径。<br>     <span class="hljs-comment">%~ftzaI     - 将 %I 扩展到类似输出线路的 DIR</span><br><br>在以上例子中，<span class="hljs-comment">%I 和 PATH 可用其他有效数值代替。%~ 语法</span><br>用一个有效的 FOR 变量名终止。选取类似 <span class="hljs-comment">%I 的大写变量名</span><br>比较易读，而且避免与不分大小写的组合键混淆。<br></code></pre></td></tr></table></figure><h2 id="dir"><a href="#dir" class="headerlink" title="dir"></a>dir</h2><p>列出文件</p><h2 id="cls"><a href="#cls" class="headerlink" title="cls"></a>cls</h2><p>清屏</p><h1 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE"></a>NOTE</h1><h2 id="mklinkC盘程序搬家"><a href="#mklinkC盘程序搬家" class="headerlink" title="mklinkC盘程序搬家"></a>mklinkC盘程序搬家</h2><p>命令参数</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">mklink<span class="hljs-string">[[/d]|[/h]|[/j]]</span>&lt;Link&gt;&lt;Target&gt;<br></code></pre></td></tr></table></figure><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>&#x2F;d</td><td>创建目录符号链接。默认情况下，mklink会创建文件符号链接。</td></tr><tr><td>&#x2F;H</td><td>创建硬链接而不是符号链接。</td></tr><tr><td>&#x2F;J</td><td>创建目录连接。</td></tr><tr><td>&lt;链接&gt;</td><td>指定正在创建的符号链接的名称。</td></tr><tr><td>&lt;目标&gt;</td><td>指定新符号链接引用的路径（相对或绝对）。</td></tr><tr><td>&#x2F;？</td><td>在命令提示符下显示帮助。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>MS-DOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PyQT</title>
    <link href="/2022/7ecf7a99/"/>
    <url>/2022/7ecf7a99/</url>
    
    <content type="html"><![CDATA[<h1 id="PyQt"><a href="#PyQt" class="headerlink" title="PyQt"></a>PyQt</h1><h2 id="添加图标"><a href="#添加图标" class="headerlink" title="添加图标"></a>添加图标</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WindowGUI</span>(QMainWindow, Ui_MainWindow):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(WindowGUI, self).__init__()<br>        self.setupUi(self)<br>        <span class="hljs-comment">#这里添加了一个图标</span><br>        self.setWindowIcon(QIcon(<span class="hljs-string">&#x27;./Data/SerialBlack.ico&#x27;</span>))<br>        self.pushButton.clicked.connect(self.Butt)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 每一pyqt5应用程序必须创建一个应用程序对象。sys.argv参数是一个列表，从命令行输入参数。</span><br>    app = QApplication(sys.argv)<br>    window = WindowGUI()<br>    window.show()<br>    sys.exit(app.exec_())<br></code></pre></td></tr></table></figure><h2 id="退出确认"><a href="#退出确认" class="headerlink" title="退出确认"></a>退出确认</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WindowGUI</span>(QMainWindow, Ui_MainWindow):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(WindowGUI, self).__init__()<br>        self.setupUi(self)<br>    <span class="hljs-comment">#关闭窗口产生 QCloseEvent</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">closeEvent</span>(<span class="hljs-params">self, event</span>):<br>        reply = QMessageBox.question(self, <span class="hljs-string">&#x27;Message&#x27;</span>,<br>                                     <span class="hljs-string">&quot;Are you sure to quit?&quot;</span>, QMessageBox.Yes |<br>                                     QMessageBox.No, QMessageBox.No)<br>        <span class="hljs-keyword">if</span> reply == QMessageBox.Yes:<br>            event.accept()<br>        <span class="hljs-keyword">else</span>:<br>            event.ignore()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 每一pyqt5应用程序必须创建一个应用程序对象。sys.argv参数是一个列表，从命令行输入参数。</span><br>    app = QApplication(sys.argv)<br>    window = WindowGUI()<br>    window.show()<br>    sys.exit(app.exec_())<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>QT</tag>
      
      <tag>PyQT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python学习笔记</title>
    <link href="/2022/297a89d9/"/>
    <url>/2022/297a89d9/</url>
    
    <content type="html"><![CDATA[<h1 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h1><p>Python学习笔记</p><h1 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;第一行\n第二行&#x27;</span>)<br><br><br><span class="hljs-built_in">print</span>(a + <span class="hljs-string">&#x27; &#x27;</span> + b + <span class="hljs-string">&#x27; %d %d&#x27;</span>%(c,d))//连字符<br></code></pre></td></tr></table></figure><h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><h3 id="基本格式化"><a href="#基本格式化" class="headerlink" title="基本格式化"></a>基本格式化</h3><p>在Python中，采用的格式化方式和C语言是一致的，用%实现，举例如下</p><ul><li>单个</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;Hello, %s&#x27;</span> % <span class="hljs-string">&#x27;world&#x27;</span><br><span class="hljs-string">&#x27;Hello, world&#x27;</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>k=<span class="hljs-number">2</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;big&#x27;</span>, k)<br><span class="hljs-string">&#x27;big 2&#x27;</span><br></code></pre></td></tr></table></figure><ul><li><p>多个</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;Hi, %s, you have $%d.&#x27;</span> % (<span class="hljs-string">&#x27;Michael&#x27;</span>, <span class="hljs-number">1000000</span>)<br><span class="hljs-string">&#x27;Hi, Michael, you have $1000000.&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>如果你不太确定应该用什么，%s永远起作用，它会把任何数据类型转换为字符串</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;Age: %s. Gender: %s&#x27;</span> % (<span class="hljs-number">25</span>, <span class="hljs-literal">True</span>)<br><span class="hljs-string">&#x27;Age: 25. Gender: True&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="format-格式化"><a href="#format-格式化" class="headerlink" title="format 格式化"></a>format 格式化</h3><p>format()它会用传入的参数依次替换字符串内的占位符{0}、{1}……</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;Hello, &#123;0&#125;, 成绩提升了 &#123;1:.1f&#125;%&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-number">17.125</span>)<br><span class="hljs-string">&#x27;Hello, 小明, 成绩提升了 17.1%&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="字符转义"><a href="#字符转义" class="headerlink" title="字符转义"></a>字符转义</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#如果字符串里面有很多字符都需要转义，就需要加很多\，为了简化，Python还允许用``r&#x27;&#x27;表示&#x27;&#x27;``内部的字符串默认不转义</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\\\t\\&#x27;</span>)<br>\       \<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-string">r&#x27;\\\t\\&#x27;</span>)<br>\\\t\\<br><br><br><span class="hljs-comment">#如果字符串内部有很多换行，用\n写在一行里不好阅读，为了简化，Python允许用&#x27;&#x27;&#x27;...&#x27;&#x27;&#x27;的格式表示多行内容，可以自己试试：</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#x27;&#x27;line1</span><br><span class="hljs-string"><span class="hljs-meta">... </span>line2</span><br><span class="hljs-string"><span class="hljs-meta">... </span>line3&#x27;&#x27;&#x27;</span>)<br>line1<br>line2<br>line3<br></code></pre></td></tr></table></figure><h2 id="显示字符串的前部分长度"><a href="#显示字符串的前部分长度" class="headerlink" title="显示字符串的前部分长度"></a>显示字符串的前部分长度</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(pi_string[:<span class="hljs-number">52</span>] + <span class="hljs-string">&quot;...&quot;</span>)<br><span class="hljs-comment"># 3.14159265358979323846264338327950288419716939937510...</span><br></code></pre></td></tr></table></figure><h1 id="input"><a href="#input" class="headerlink" title="input"></a>input</h1><p>幸好，<code>input()</code>可以让你显示一个字符串来提示用户，于是我们把代码改成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;please enter your name: &#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;hello,&#x27;</span>, name)<br></code></pre></td></tr></table></figure><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 这是一段 行注释</span><br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">这是一段 段注释</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h1 id="数据类型-和-算数运算符"><a href="#数据类型-和-算数运算符" class="headerlink" title="数据类型 和 算数运算符"></a>数据类型 和 算数运算符</h1><p>整数、浮点数、字符串、布尔型（True、False（注意大小写））、空值</p><p>所谓常量就是不能变的变量，比如常用的数学常数π就是一个常量。在Python中，通常用全部大写的变量名表示，但是不能保证其不被改变</p><p>空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">+</td><td align="left">加 - 两个对象相加</td><td align="left">a + b 输出结果 30</td></tr><tr><td align="left">-</td><td align="left">减 - 得到负数或是一个数减去另一个数</td><td align="left">a - b 输出结果 -10</td></tr><tr><td align="left">*</td><td align="left">乘 - 两个数相乘或是返回一个被重复若干次的字符串</td><td align="left">a * b 输出结果 200</td></tr><tr><td align="left">&#x2F;</td><td align="left">除 - x除以y</td><td align="left">b &#x2F; a 输出结果 2</td></tr><tr><td align="left">%</td><td align="left">取模 - 返回除法的余数</td><td align="left">b % a 输出结果 0</td></tr><tr><td align="left">**</td><td align="left">幂 - 返回x的y次幂</td><td align="left">a**b 为10的20次方， 输出结果 100000000000000000000</td></tr><tr><td align="left">&#x2F;&#x2F;</td><td align="left">取整除 - 返回商的整数部分（<strong>向下取整</strong>）</td><td align="left"><code>&gt;&gt;&gt; 9//2 = 4 &gt;&gt;&gt; -9//2 = -5</code></td></tr></tbody></table><p>&#x2F;除法计算结果是浮点数</p><p>&#x2F;&#x2F;称为地板除，两个整数的除法仍然是整数（c整数除法）</p><h1 id="编码（数据转换）"><a href="#编码（数据转换）" class="headerlink" title="编码（数据转换）"></a>编码（数据转换）</h1><p>ord()函数获取字符的整数表示</p><p>&gt;&gt;&gt; ord(‘中’)</p><p>20013</p><p>chr()函数把编码转换为对应的字符</p><p>&gt;&gt;&gt; chr(25991)</p><p>‘文’</p><p>str通过encode()可以编码为bytes</p><p>&gt;&gt;&gt; ‘ABC’.encode(‘ascii’)</p><p>b’ABC’</p><p>&gt;&gt;&gt; ‘中文’.encode(‘utf-8’)</p><p>b’\xe4\xb8\xad\xe6\x96\x87’</p><p>要把bytes变为str，就需要用decode()</p><p>&gt;&gt;&gt; b’ABC’.decode(‘ascii’)</p><p>‘ABC’</p><p>要计算str包含多少个字符，可以用len()函数</p><p>&gt;&gt;&gt; len(‘ABC’)</p><p>3</p><p>&gt;&gt;&gt; len(‘中文’)</p><p>2</p><p>len()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数</p><p>&gt;&gt;&gt; len(b’ABC’)</p><p>3</p><p>&gt;&gt;&gt; len(b’\xe4\xb8\xad\xe6\x96\x87’)</p><p>6</p><p>&gt;&gt;&gt; len(‘中文’.encode(‘utf-8’))</p><p>6</p><hr><p>‘ABC’和b’ABC’，</p><p>前者是str，在内存中以Unicode表示，一个字符对应若干个字节</p><p>后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节</p><h1 id="List列表（类似数组）"><a href="#List列表（类似数组）" class="headerlink" title="List列表（类似数组）"></a>List列表（类似数组）</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">s = [<span class="hljs-number">0</span>]*<span class="hljs-number">10</span><span class="hljs-comment">#10个0</span><br>[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br><br>s = [<span class="hljs-string">&#x27;hello&#x27;</span>]*<span class="hljs-number">3</span>    <span class="hljs-comment">#10个&#x27;hello&#x27;</span><br>[<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-string">&#x27;hello&#x27;</span>]<br><br>s = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>))<span class="hljs-comment">#10个 从0到10</span><br>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]<br><br></code></pre></td></tr></table></figure><hr><p>Python内置的一种数据类型是list。list是一种有序的集合，可以随时添加和删除其中的元素。</p><p>&gt;&gt;&gt; classmates &#x3D; [‘Jack’, 180, 1.69]</p><p>&gt;&gt;&gt; classmates</p><p>[‘Jack’, 180, 1.69]</p><hr><p>如果要取最后一个元素，除了计算索引位置外，还可以用-1做索引，直接获取最后一个元素：</p><p>&gt;&gt;&gt; classmates[-1]</p><p>‘Tracy’</p><hr><p>list是一个可变的有序表，所以，可以往list中追加元素到末尾：</p><p>&gt;&gt;&gt; classmates.append(‘Adam’)</p><p>&gt;&gt;&gt; classmates</p><p>[‘Michael’, ‘Bob’, ‘Tracy’, ‘Adam’]</p><p>也可以把元素插入到指定的位置，比如索引号为1的位置：</p><p>&gt;&gt;&gt; classmates.insert(1, ‘Jack’)</p><p>&gt;&gt;&gt; classmates</p><p>[‘Michael’, ‘Jack’, ‘Bob’, ‘Tracy’, ‘Adam’]</p><p>要删除list末尾的元素，用pop()方法：</p><p>&gt;&gt;&gt; classmates.pop()</p><p>‘Adam’</p><p>&gt;&gt;&gt; classmates</p><p>[‘Michael’, ‘Jack’, ‘Bob’, ‘Tracy’]</p><p>要删除指定位置的元素，用pop(i)方法，其中i是索引位置：</p><p>&gt;&gt;&gt; classmates.pop(1)</p><p>‘Jack’</p><p>&gt;&gt;&gt; classmates</p><p>[‘Michael’, ‘Bob’, ‘Tracy’]</p><hr><p>-———————————————————————————————————————</p><p>list元素也可以是另一个list，比如：</p><p>&gt;&gt;&gt; s &#x3D; [‘python’, ‘java’, [‘asp’, ‘php’], ‘scheme’]</p><p>&gt;&gt;&gt; len(s)</p><p>4</p><p>要注意s只有4个元素，其中s[2]又是一个list，如果拆开写就更容易理解了</p><p>&gt;&gt;&gt; p &#x3D; [‘asp’, ‘php’]</p><p>&gt;&gt;&gt; s &#x3D; [‘python’, ‘java’, p, ‘scheme’]</p><p>要访问’php’可以写p[1]或者s[2][1]，因此s可以看成是一个二维数组</p><h1 id="Tuple元组（静态数组）"><a href="#Tuple元组（静态数组）" class="headerlink" title="Tuple元组（静态数组）"></a>Tuple元组（静态数组）</h1><p>另一种有序列表叫元组：tuple</p><p>。tuple和list非常类似，但是tuple一旦初始化就不能修改</p><p>&gt;&gt;&gt; classmates &#x3D; (‘Michael’, ‘Bob’, ‘Tracy’)</p><p>要定义一个只有1个元素的tuple，如果你这么定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>t = (<span class="hljs-number">1</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>t<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>定义的不是tuple，是<code>1</code>这个数！这是因为括号<code>()</code>既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是<code>1</code>。</p><p>所以，只有1个元素的tuple定义时必须加一个逗号<code>,</code>，来消除歧义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>t = (<span class="hljs-number">1</span>,)<br><span class="hljs-meta">&gt;&gt;&gt; </span>t<br>(<span class="hljs-number">1</span>,)<br></code></pre></td></tr></table></figure><p>Python在显示只有1个元素的tuple时，也会加一个逗号<code>,</code>，以免你误解成数学计算意义上的括号。</p><p>最后来看一个“可变的”tuple：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>t = (<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>])<br><span class="hljs-meta">&gt;&gt;&gt; </span>t[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;X&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>t[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;Y&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>t<br>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, [<span class="hljs-string">&#x27;X&#x27;</span>, <span class="hljs-string">&#x27;Y&#x27;</span>])<br></code></pre></td></tr></table></figure><h2 id="str-replace-替换"><a href="#str-replace-替换" class="headerlink" title="str.replace 替换"></a>str.replace 替换</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>message = <span class="hljs-string">&quot;I really like dogs.&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>message.replace(<span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-string">&#x27;cat&#x27;</span>)<br><span class="hljs-string">&#x27;I really like cats.&#x27;</span><br></code></pre></td></tr></table></figure><h1 id="if-、-for-、-while-、-range"><a href="#if-、-for-、-while-、-range" class="headerlink" title="if 、 for 、 while 、 range"></a>if 、 for 、 while 、 range</h1><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><p><strong>变体</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">ii = <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> ss == <span class="hljs-number">2</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br><br><span class="hljs-comment">#当ss == 2时 ii=1 否则 ii=0</span><br></code></pre></td></tr></table></figure><p>if age &gt;&#x3D; 18:</p><p>​    print(‘adult’)</p><p>else:</p><p>​    print(‘teenager’)</p><p>age &#x3D; 3</p><p>if age &gt;&#x3D; 18:</p><p>​    print(‘adult’)</p><p>elif age &gt;&#x3D; 6:</p><p>​    print(‘teenager’)</p><p>else:</p><p>​    print(‘kid’)</p><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p>所以for x in …循环就是把每个元素代入变量x，然后执行缩进块的语句。</p><p>再比如我们想计算1-10的整数之和，可以用一个sum变量做累加：</p><p>sum &#x3D; 0</p><p>for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]:</p><p>​    sum &#x3D; sum + x</p><p>print(sum)</p><hr><p>sum &#x3D; 0</p><p>for x in  range(101):</p><p>​    sum &#x3D; sum + x</p><p>print(sum)</p><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><p>while循环</p><p>sum &#x3D; 0</p><p>n &#x3D; 99</p><p>while n &gt; 0:</p><p>​    sum &#x3D; sum + n</p><p>​    n &#x3D; n - 2</p><p>print(sum)</p><h2 id="range"><a href="#range" class="headerlink" title="range"></a>range</h2><p>range(start, stop[, step])    可以生成一个整数序列，</p><p>start: 计数从 start 开始。默认是从 0 开始。例如range（5）等价于range（0， 5）;</p><p>stop: 计数到 stop 结束，但不包括 stop。例如：range（0， 5） 是[0, 1, 2, 3, 4]没有5</p><p>step：步长，默认为1。例如：range（0， 5） 等价于 range(0, 5, 1)</p><p>&gt;&gt;&gt; list(range(5))</p><p>[0, 1, 2, 3, 4]</p><p>&gt;&gt;&gt;range(10)        # 从 0 开始到 10</p><p>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</p><p>&gt;&gt;&gt; range(1, 11)     # 从 1 开始到 11</p><p>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</p><p>&gt;&gt;&gt; range(0, 30, 5)  # 步长为 5</p><p>[0, 5, 10, 15, 20, 25]</p><p>&gt;&gt;&gt; range(0, 10, 3)  # 步长为 3</p><p>[0, 3, 6, 9]</p><p>&gt;&gt;&gt; range(0, -10, -1) # 负数</p><p>[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]</p><p>&gt;&gt;&gt; range(0)</p><p>[]</p><p>&gt;&gt;&gt; range(1, 0)</p><p>[]</p><h1 id="Dict（字典）"><a href="#Dict（字典）" class="headerlink" title="Dict（字典）"></a>Dict（字典）</h1><p>Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。</p><p>如果用dict实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用Python写一个dict如下：</p><p>&gt;&gt;&gt; d &#x3D; {‘Michael’: 95, ‘Bob’: 75, ‘Tracy’: 85}</p><p>&gt;&gt;&gt; d[‘Michael’]</p><p>95 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">Kw = &#123;<span class="hljs-string">&#x27;city&#x27;</span>: <span class="hljs-number">22</span>, <span class="hljs-string">&#x27;job&#x27;</span>: <span class="hljs-number">33</span>&#125;: <br><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;city&#x27;</span> <span class="hljs-keyword">in</span> kw:<br><span class="hljs-comment"># 有city参数</span><br>    <span class="hljs-keyword">pass</span><br><br><br>&gt;&gt;&gt;kw.get(<span class="hljs-string">&#x27;city&#x27;</span>)<br><span class="hljs-number">22</span><br>&gt;&gt;&gt;kw.[<span class="hljs-string">&#x27;city&#x27;</span>]<br><span class="hljs-number">22</span><br></code></pre></td></tr></table></figure><h2 id="字典内置函数-amp-方法"><a href="#字典内置函数-amp-方法" class="headerlink" title="字典内置函数&amp;方法"></a>字典内置函数&amp;方法</h2><p>Python字典包含了以下内置函数：</p><table><thead><tr><th align="left">序号</th><th align="left">函数及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-cmp.html">cmp(dict1, dict2)</a> 比较两个字典元素。</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-len.html">len(dict)</a> 计算字典元素个数，即键的总数。</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-str.html">str(dict)</a> 输出字典可打印的字符串表示。</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-type.html">type(variable)</a> 返回输入的变量类型，如果变量是字典就返回字典类型。</td></tr></tbody></table><p>Python字典包含了以下内置方法：</p><table><thead><tr><th align="left">序号</th><th align="left">函数及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-clear.html">dict.clear()</a> 删除字典内所有元素</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-copy.html">dict.copy()</a> 返回一个字典的浅复制</td></tr><tr><td align="left">3</td><td align="left">[dict.fromkeys(seq<a href="https://www.runoob.com/python/att-dictionary-fromkeys.html">, val])</a> 创建一个新字典，以序列 seq 中元素做字典的键，val 为字典所有键对应的初始值</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-get.html">dict.get(key, default&#x3D;None)</a> 返回指定键的值，如果值不在字典中返回default值</td></tr><tr><td align="left">5</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-has_key.html">dict.has_key(key)</a> 如果键在字典dict里返回true，否则返回false</td></tr><tr><td align="left">6</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-items.html">dict.items()</a> 以列表返回可遍历的(键, 值) 元组数组</td></tr><tr><td align="left">7</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-keys.html">dict.keys()</a> 以列表返回一个字典所有的键</td></tr><tr><td align="left">8</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-setdefault.html">dict.setdefault(key, default&#x3D;None)</a> 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default</td></tr><tr><td align="left">9</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-update.html">dict.update(dict2)</a> 把字典dict2的键&#x2F;值对更新到dict里</td></tr><tr><td align="left">10</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-values.html">dict.values()</a> 以列表返回字典中的所有值</td></tr><tr><td align="left">11</td><td align="left">[pop(key<a href="https://www.runoob.com/python/python-att-dictionary-pop.html">,default])</a> 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。</td></tr><tr><td align="left">12</td><td align="left"><a href="https://www.runoob.com/python/python-att-dictionary-popitem.html">popitem()</a> 返回并删除字典中的最后一对键和值。</td></tr></tbody></table><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><h2 id="基本打开输出文件"><a href="#基本打开输出文件" class="headerlink" title="基本打开输出文件"></a>基本打开输出文件</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;pi_digits.txt&#x27;</span>) <span class="hljs-keyword">as</span> file_object:<br>    contents = file_object.read()<br>    <span class="hljs-built_in">print</span>(contents)<br></code></pre></td></tr></table></figure><p>在这个程序中，第1行代码做了大量的工作。我们先来看看函数open() 。要以任何方式使用文件——哪怕仅仅是打印其内容，都得先打开 文件，这样才能访问它。函数open()接受一个参数：要打开的文件的名称。Python在当前执行的文件所在的目录中查找指定的文件。在这个示例中，当前运行的是file_reader.py，因此Python在file_reader.py所在的目录中查找pi_digits.txt。函数open() 返回一个表示文件的对象。在这里，open(‘pi_digits.txt’) 返回一个表示文件pi_digits.txt 的对象；Python将这个对象存储在我们将在后面使用的变量中。</p><p>关键字with 在不再需要访问文件后将其关闭。在这个程序中，注意到我们调用了open() ，但没有调用close() ；你也可以调用open() 和close() 来打开和关闭文件，但这样做时，如果程序存在bug，导致close() 语句未执行，文件将不会关闭。这看似微不足道，但未妥善地关闭文件可能会导致数据丢失或受损。如果在程序中过早地调用close() ，你会发现需要使用文件时它已关闭 （无法访问），这会导致更多的错误。并非在任何情况下都能轻松确定关闭文件的恰当时机，但通过使用前面所示的结构，可让Python去确定：你只管打开文件，并在需要时使用它，Python自会在合适的时候自动将其关闭。</p><h2 id="删除字符串末尾的空白-rstrip"><a href="#删除字符串末尾的空白-rstrip" class="headerlink" title="删除字符串末尾的空白 rstrip"></a>删除字符串末尾的空白 rstrip</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;pi_digits.txt&#x27;</span>) <span class="hljs-keyword">as</span> file_object:<br>    contents = file_object.read()<br>    <span class="hljs-built_in">print</span>(contents.rstrip())<br></code></pre></td></tr></table></figure><p>相比于原始文件，该输出唯一不同的地方是末尾多了一个空行。为何会多出这个空行呢？因为read() 到达文件末尾时返回一个空字符串，而将这个空字符串显示出来时就是一个空行。要删除多出来的空行，可在print 语句中使用rstrip() ：</p><p>每行左边的空格，为删除这些空格，可使用strip() </p><h2 id="逐行读取文件"><a href="#逐行读取文件" class="headerlink" title="逐行读取文件"></a>逐行读取文件</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">filename = <span class="hljs-string">&#x27;pi_digits.txt&#x27;</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename) <span class="hljs-keyword">as</span> file_object:<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> file_object:<br>    <span class="hljs-built_in">print</span>(line.rstrip())<br></code></pre></td></tr></table></figure><h2 id="文件打开模式"><a href="#文件打开模式" class="headerlink" title="文件打开模式"></a>文件打开模式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">filename = <span class="hljs-string">&#x27;programming.txt&#x27;</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> file_object:<br>    file_object.write(<span class="hljs-string">&quot;I love programming.&quot;</span>)<br></code></pre></td></tr></table></figure><p>在这个示例中，调用open() 时提供了两个实参（见❶）。第一个实参也是要打开的文件的名称；第二个实参（’w’ ）告诉Python，我们要以写入模式 打开这个文件。打开文件时，<strong>可指定读取模式 （’r’ ）、写入模式 （’w’ ）、附加模式 （’a’ ）附加到文件末尾、让你能够读取和写入文件的模式（’r+’ ）</strong>。如果你省略了模式实参，Python将以默认的只读模式打开文件。</p><h2 id="异常处理-try-except"><a href="#异常处理-try-except" class="headerlink" title="异常处理 try-except"></a>异常处理 try-except</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">filename = <span class="hljs-string">&#x27;alice.txt&#x27;</span><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename) <span class="hljs-keyword">as</span> f_obj:<br>    contents = f_obj.read()<br><span class="hljs-keyword">except</span> FileNotFoundError:<br>    msg = <span class="hljs-string">&quot;Sorry, the file &quot;</span> + filename + <span class="hljs-string">&quot; does not exist.&quot;</span><br><span class="hljs-built_in">print</span>(msg)<br></code></pre></td></tr></table></figure><p>在这个示例中，try 代码块引发FileNotFoundError 异常，因此Python找出与该错误匹配的except 代码块，并运行其中的代码。最终的结果是显示一条友好的错误消息，而不是traceback：</p><h1 id="一些方法"><a href="#一些方法" class="headerlink" title="一些方法"></a>一些方法</h1><h2 id="count"><a href="#count" class="headerlink" title=".count()"></a>.count()</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>Python count() 方法用于统计字符串里某个字符出现的次数。可选参数为在字符串搜索的开始与结束位置。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>count()方法语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span>.count(sub, start= <span class="hljs-number">0</span>,end=<span class="hljs-built_in">len</span>(string))<br></code></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li>sub – 搜索的子字符串</li><li>start – 字符串开始搜索的位置。默认为第一个字符,第一个字符索引值为0。</li><li>end – 字符串中结束搜索的位置。字符中第一个字符的索引为 0。默认为字符串的最后一个位置。</li></ul><h2 id="to-bytes"><a href="#to-bytes" class="headerlink" title=".to_bytes()"></a>.to_bytes()</h2><p>(0x12).to_bytes(10, byteorder&#x3D; ‘big’, signed &#x3D; ‘true’)</p><ul><li><p>10：表示转换后的数据占10个字节</p></li><li><p>byteorder：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;(<span class="hljs-number">0x12</span>).to_bytes(<span class="hljs-number">10</span>, byteorder = <span class="hljs-string">&#x27;big&#x27;</span>)<br><br><span class="hljs-comment">#b&#x27;\xf8\x12\x00\x00&#x27;</span><br><br>&gt;&gt;&gt;(<span class="hljs-number">0x12</span>).to_bytes(<span class="hljs-number">10</span>, byteorder = <span class="hljs-string">&#x27;little&#x27;</span>)<br><br><span class="hljs-comment">#b&#x27;\x00\x00\x12\xf8&#x27;</span><br></code></pre></td></tr></table></figure><ul><li>signed： 表示有符号和无符号</li></ul><h2 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h2><p>函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：(类似于指针？？？？准确描述应该是类似 tpyedef )</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-built_in">abs</span> <span class="hljs-comment"># 变量a指向abs函数</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a(-<span class="hljs-number">1</span>) <span class="hljs-comment"># 所以也可以通过a调用abs函数1</span><br></code></pre></td></tr></table></figure><h2 id="abs-绝对值"><a href="#abs-绝对值" class="headerlink" title="abs 绝对值"></a>abs 绝对值</h2><p>abs( x )函数 取绝对值</p><p>x – 数值表达式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">abs</span>(<span class="hljs-number">100</span>)<span class="hljs-number">100</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">abs</span>(-<span class="hljs-number">20</span>)<span class="hljs-number">20</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">abs</span>(<span class="hljs-number">12.34</span>)<span class="hljs-number">12.34</span><br></code></pre></td></tr></table></figure><h2 id="max-找平均值"><a href="#max-找平均值" class="headerlink" title="max 找平均值"></a>max 找平均值</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><br>list1 = [<span class="hljs-number">123</span>, <span class="hljs-number">568</span>, <span class="hljs-number">423</span>, <span class="hljs-number">365</span>]<br><br><span class="hljs-built_in">print</span>( np.mean(list1) )<br></code></pre></td></tr></table></figure><h2 id="max-找最大-x2F-小值"><a href="#max-找最大-x2F-小值" class="headerlink" title="max 找最大&#x2F;小值"></a>max 找最大&#x2F;小值</h2><p>max( x, y, z, …. )  可以接收任意多个参数，并返回最大的那个（可以传入list）：</p><p>x – 数值表达式。y – 数值表达式。z – 数值表达式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><span class="hljs-number">2</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">max</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">5</span>)<br><span class="hljs-number">3</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>list1 = [<span class="hljs-number">123</span>, <span class="hljs-number">568</span>, <span class="hljs-number">423</span>, <span class="hljs-number">365</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Max value element : &quot;</span>, <span class="hljs-built_in">max</span>(list1))<br>Max value element :  <span class="hljs-number">568</span><br></code></pre></td></tr></table></figure><h2 id="exal-执行字符串类型的表达式"><a href="#exal-执行字符串类型的表达式" class="headerlink" title="exal 执行字符串类型的表达式"></a>exal 执行字符串类型的表达式</h2><p>eval(expression[, globals[, locals]])函数   函数用来执行一个字符串表达式，并返回表达式的值。</p><p>expression – 表达式。</p><p>globals – 变量作用域，全局命名空间，如果被提供，则必须是一个字典对象。</p><p>locals – 变量作用域，局部命名空间，如果被提供，可以是任何映射对象。</p><p>&gt;&gt;&gt;x &#x3D; 7</p><p>&gt;&gt;&gt; eval( ‘3 * x’ )</p><p>21</p><p>&gt;&gt;&gt; eval(‘pow(2,2)’)</p><p>4</p><p>a&#x3D;eval(input(“请输入一个整数”))           #（自动类型转换）</p><h2 id="int-强制转换"><a href="#int-强制转换" class="headerlink" title="int 强制转换"></a>int 强制转换</h2><p>class int(x, base&#x3D;10)    强制转换返回整型数据。</p><p>x – 字符串或数字。base – 进制数，默认十进制。</p><p>&gt;&gt;&gt; int(‘0xa’,16)  </p><p>10  </p><p>&gt;&gt;&gt; int(‘10’,8)  </p><p>8</p><p>a&#x3D;int(input(“请输入一个整数”))             #（强制类型转换）</p><h2 id="type-判断对象类型"><a href="#type-判断对象类型" class="headerlink" title="type 判断对象类型"></a>type 判断对象类型</h2><p>首先，我们来判断对象类型，使用<code>type()</code>函数：</p><p>基本类型都可以用<code>type()</code>判断：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haskell">&gt;&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">type</span>(123)</span><br>&lt;<span class="hljs-keyword">class</span> &#x27;int&#x27;&gt;<br>&gt;&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">type</span>(&#x27;<span class="hljs-title">str&#x27;</span>)</span><br>&lt;<span class="hljs-keyword">class</span> &#x27;str&#x27;&gt;<br>&gt;&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">type</span>(<span class="hljs-type">None</span>)</span><br>&lt;<span class="hljs-class"><span class="hljs-keyword">type</span>(<span class="hljs-type">None</span>) &#x27;<span class="hljs-type">NoneType&#x27;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果一个变量指向函数或者类，也可以用<code>type()</code>判断：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(<span class="hljs-built_in">abs</span>)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;builtin_function_or_method&#x27;</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(a)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.Animal&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>但是<code>type()</code>函数返回的是什么类型呢？它返回对应的Class类型。如果我们要在<code>if</code>语句中判断，就需要比较两个变量的type类型是否相同：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">type</span>(<span class="hljs-number">123</span>)==<span class="hljs-built_in">type</span>(<span class="hljs-number">456</span>)</span><br>True<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">type</span>(<span class="hljs-number">123</span>)==<span class="hljs-built_in">int</span></span><br>True<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">type</span>(<span class="hljs-string">&#x27;abc&#x27;</span>)==<span class="hljs-built_in">type</span>(<span class="hljs-string">&#x27;123&#x27;</span>)</span><br>True<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">type</span>(<span class="hljs-string">&#x27;abc&#x27;</span>)==<span class="hljs-built_in">str</span></span><br>True<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">type</span>(<span class="hljs-string">&#x27;abc&#x27;</span>)==<span class="hljs-built_in">type</span>(<span class="hljs-number">123</span>)</span><br>False<br></code></pre></td></tr></table></figure><p>判断基本数据类型可以直接写<code>int</code>，<code>str</code>等，但如果要判断一个对象是否是函数怎么办？可以使用<code>types</code>模块中定义的常量：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">import</span> types</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fn</span>():</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    <span class="hljs-keyword">pass</span></span><br><span class="hljs-meta prompt_">...</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">type</span>(fn)==types.FunctionType</span><br>True<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">type</span>(<span class="hljs-built_in">abs</span>)==types.BuiltinFunctionType</span><br>True<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">type</span>(<span class="hljs-keyword">lambda</span> x: x)==types.LambdaType</span><br>True<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">type</span>((x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)))==types.GeneratorType</span><br>True<br></code></pre></td></tr></table></figure><h2 id="isinstance-判断类型是否相同"><a href="#isinstance-判断类型是否相同" class="headerlink" title="isinstance 判断类型是否相同"></a>isinstance 判断类型是否相同</h2><p>isinstance(object, classinfo)     如果对象的类型与参数二的类型（classinfo）相同则返回 True，否则返回 False</p><p>object – 实例对象。</p><p>classinfo – 可以是直接或间接类名、基本类型或者由它们组成的元组。</p><p>能用<code>type()</code>判断的基本类型也可以用<code>isinstance()</code>判断：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-built_in">str</span>)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(<span class="hljs-number">123</span>, <span class="hljs-built_in">int</span>)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(<span class="hljs-string">b&#x27;a&#x27;</span>, <span class="hljs-built_in">bytes</span>)<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>并且还可以判断一个变量是否是某些类型中的一种，比如下面的代码就可以判断是否是list或者tuple：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], (<span class="hljs-built_in">list</span>, <span class="hljs-built_in">tuple</span>))<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>), (<span class="hljs-built_in">list</span>, <span class="hljs-built_in">tuple</span>))<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#判断传入的参数是否正确</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(x, (<span class="hljs-built_in">int</span>, <span class="hljs-built_in">float</span>)):<br>        <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&#x27;bad operand type&#x27;</span>)<br></code></pre></td></tr></table></figure><p>isinstance() 与 type() 区别：</p><p>type() 不会认为子类是一种父类类型，不考虑继承关系。</p><p>isinstance() 会认为子类是一种父类类型，考虑继承关系。</p><p>如果要判断两个类型是否相同推荐使用 isinstance()。</p><h2 id="dir-获得对象的所有属性和方法"><a href="#dir-获得对象的所有属性和方法" class="headerlink" title="dir 获得对象的所有属性和方法"></a>dir 获得对象的所有属性和方法</h2><p>如果要获得一个对象的所有属性和方法，可以使用<code>dir()</code>函数，它返回一个包含字符串的list，比如，获得一个str对象的所有属性和方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">dir</span>(<span class="hljs-string">&#x27;ABC&#x27;</span>)<br>[<span class="hljs-string">&#x27;__add__&#x27;</span>, <span class="hljs-string">&#x27;__class__&#x27;</span>,..., <span class="hljs-string">&#x27;__subclasshook__&#x27;</span>, <span class="hljs-string">&#x27;capitalize&#x27;</span>, <span class="hljs-string">&#x27;casefold&#x27;</span>,..., <span class="hljs-string">&#x27;zfill&#x27;</span>]<br></code></pre></td></tr></table></figure><p>类似<code>__xxx__</code>的属性和方法在Python中都是有特殊用途的，比如<code>__len__</code>方法返回长度。在Python中，如果你调用<code>len()</code>函数试图获取一个对象的长度，实际上，在<code>len()</code>函数内部，它自动去调用该对象的<code>__len__()</code>方法，所以，下面的代码是等价的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">len</span>(<span class="hljs-string">&#x27;ABC&#x27;</span>)<br><span class="hljs-number">3</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;ABC&#x27;</span>.__len__()<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h2 id="二次三次方根"><a href="#二次三次方根" class="headerlink" title="二次三次方根"></a>二次三次方根</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">9</span>*<span class="hljs-number">9</span><br>== <span class="hljs-number">9</span>**<span class="hljs-number">2</span><br><br><span class="hljs-number">9</span>*<span class="hljs-number">9</span>*<span class="hljs-number">9</span><br>== <span class="hljs-number">9</span>**<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h1 id="math模块的一些方法"><a href="#math模块的一些方法" class="headerlink" title="math模块的一些方法"></a>math模块的一些方法</h1><h2 id="math-modf-分离小数和整数部分"><a href="#math-modf-分离小数和整数部分" class="headerlink" title="math.modf(分离小数和整数部分)"></a>math.modf(分离小数和整数部分)</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>modf() 方法返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>以下展示了使用 modf() 方法的实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math   <span class="hljs-comment"># This will import math module</span><br><br><span class="hljs-built_in">print</span>( math.modf(-<span class="hljs-number">100.12</span>) )<br><span class="hljs-built_in">print</span>( math.modf(-<span class="hljs-number">100.12</span>)[<span class="hljs-number">0</span>] )<br></code></pre></td></tr></table></figure><p>以上实例运行后输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">(-<span class="hljs-number">0.12000000000000455</span>, -<span class="hljs-number">100.0</span>)<br>-<span class="hljs-number">0.12000000000000455</span><br></code></pre></td></tr></table></figure><h1 id="用户自定义函数"><a href="#用户自定义函数" class="headerlink" title="用户自定义函数"></a>用户自定义函数</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_abs</span>(<span class="hljs-params">x</span>):<br><br>   <span class="hljs-keyword">if</span> x &gt;= <span class="hljs-number">0</span>:<br><br>      <span class="hljs-keyword">return</span> x<br><br>   <span class="hljs-keyword">else</span>:<br><br>       <span class="hljs-keyword">return</span> -x<br></code></pre></td></tr></table></figure><p>（导入其他文件内的函数的方法）如果你已经把<code>my_abs()</code>的函数定义保存为<code>abs.py</code>文件了，那么，可以在该文件的当前目录下启动Python解释器，用<code>from abs import my_abs</code>来导入<code>my_abs()</code>函数，注意<code>abs</code>是文件名（不含<code>.py</code>扩展名）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> <span class="hljs-built_in">abs</span> <span class="hljs-keyword">import</span> my_abs<br><span class="hljs-meta">&gt;&gt;&gt; </span>my_abs(-<span class="hljs-number">9</span>) <br><span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><h2 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#pass语句，实际上pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来。但是缺少了pass，代码运行就会有语法错误。</span><br><span class="hljs-keyword">if</span> age &gt;= <span class="hljs-number">18</span>:<br><span class="hljs-keyword">pass</span><br> <br>函数返回多个值<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_two</span>(<span class="hljs-params">x, y</span>):<br>    x = x + <span class="hljs-number">1</span><br>    y = y + <span class="hljs-number">2</span><br><span class="hljs-keyword">return</span> x, y<br> <br><span class="hljs-meta">&gt;&gt;&gt; </span>x = y = <span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>x, y = add_two(x,y)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(x, y)<br><span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>r = add_two(x,y)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(r)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>其实返回值是一个tuple(静态数组)！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。</p><p>函数的传入参数<br>函数传入list要特别小心，函数内的修改会影响其本身，类似C中的指针对list产生了修改。<br>关键字传值(带**的传值)传入的是值，不会影响原来的内容。</p><h2 id="函数的输入"><a href="#函数的输入" class="headerlink" title="函数的输入"></a>函数的输入</h2><h3 id="函数的默认参数"><a href="#函数的默认参数" class="headerlink" title="函数的默认参数"></a>函数的默认参数</h3><p>默认参数。由于我们经常计算x2，所以，完全可以把第二个参数n的默认值设定为2：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">power</span>(<span class="hljs-params">x, n=<span class="hljs-number">2</span></span>):<br>    s = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> n &gt; <span class="hljs-number">0</span>:<br>        n = n - <span class="hljs-number">1</span><br>        s = s * x<br>    <span class="hljs-keyword">return</span> s<br></code></pre></td></tr></table></figure><p>调用时可以 power(5) 直接计算5的2次方，也可以power(5,3)计算5的3次方。即默认参数可以传入也可以不传入。<br>定义默认参数要牢记一点：默认参数必须指向不变对象！</p><p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431752945034eb82ac80a3e64b9bb4929b16eeed1eb9000">具体可以点击此处参考</a></p><h3 id="输入可变长变量"><a href="#输入可变长变量" class="headerlink" title="输入可变长变量"></a>输入可变长变量</h3><p>可变长度的传入变量，加了星号（*）的变量名会存放所有未命名的变量参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">printinfo</span>(<span class="hljs-params"> *vartuple </span>):<br>   <span class="hljs-string">&quot;打印任何传入的参数&quot;</span><br>   <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;输出: &quot;</span><br>   <span class="hljs-keyword">for</span> var <span class="hljs-keyword">in</span> vartuple:<br>      <span class="hljs-built_in">print</span> var<br>   <span class="hljs-keyword">return</span>;<br><br> <br><span class="hljs-comment"># 调用printinfo 函数</span><br>printinfo( <span class="hljs-number">10</span> );<br>printinfo( <span class="hljs-number">70</span>, <span class="hljs-number">60</span>, <span class="hljs-number">50</span> );<br></code></pre></td></tr></table></figure><h3 id="关键字参数（字典-dict-参数）"><a href="#关键字参数（字典-dict-参数）" class="headerlink" title="关键字参数（字典(dict)参数）"></a>关键字参数（字典(dict)参数）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">person</span>(<span class="hljs-params">name, age, **kw</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;name:&#x27;</span>, name, <span class="hljs-string">&#x27;age:&#x27;</span>, age, <span class="hljs-string">&#x27;other:&#x27;</span>, kw)<br> <br><span class="hljs-meta">&gt;&gt;&gt; </span>person(<span class="hljs-string">&#x27;Michael&#x27;</span>, <span class="hljs-number">30</span>)<br>name: Michael age: <span class="hljs-number">30</span> other: &#123;&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>person(<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-number">35</span>, city=<span class="hljs-string">&#x27;Beijing&#x27;</span>)<br>name: Bob age: <span class="hljs-number">35</span> other: &#123;<span class="hljs-string">&#x27;city&#x27;</span>: <span class="hljs-string">&#x27;Beijing&#x27;</span>&#125;<br><span class="hljs-comment">#如果函数内使用了某个关键字参数，但调用时没有传入，代码会有异常</span><br><span class="hljs-comment">#如果要限制只能传指定名字的参数，则可以使用命名关键字参数</span><br></code></pre></td></tr></table></figure><h3 id="命名关键词参数"><a href="#命名关键词参数" class="headerlink" title="命名关键词参数"></a>命名关键词参数</h3> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#命名关键字参数，是对关键字参数方式的进一步约束，更安全了</span><br><span class="hljs-comment">#定义需要一个*号作为分隔符，*后面的参数表示只能传递该名字的参数</span><br><span class="hljs-comment">#如下表示两个位置参数，还有两个名为city和job的关键字参数，调用时传其它名字会报错</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">person</span>(<span class="hljs-params">name, age, *, city, job</span>):<br>    <span class="hljs-built_in">print</span>(name, age, city, job)<br></code></pre></td></tr></table></figure><p>和关键字参数<code>**kw</code>不同，命名关键字参数需要一个特殊分隔符<code>*</code>，<code>*</code>后面的参数被视为命名关键字参数。</p><p>调用方式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>person(<span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-number">24</span>, city=<span class="hljs-string">&#x27;Beijing&#x27;</span>, job=<span class="hljs-string">&#x27;Engineer&#x27;</span>)<br>Jack <span class="hljs-number">24</span> Beijing Engineer<br></code></pre></td></tr></table></figure><p>添加缺省值，从而简化调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">person</span>(<span class="hljs-params">name, age, *, city=<span class="hljs-string">&#x27;Beijing&#x27;</span>, job</span>):<br>    <span class="hljs-built_in">print</span>(name, age, city, job)<br></code></pre></td></tr></table></figure><p>由于命名关键字参数<code>city</code>具有默认值，调用时，可不传入<code>city</code>参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>person(<span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-number">24</span>, job=<span class="hljs-string">&#x27;Engineer&#x27;</span>)<br>Jack <span class="hljs-number">24</span> Beijing Engineer<br></code></pre></td></tr></table></figure><h1 id="匿名函数lambda"><a href="#匿名函数lambda" class="headerlink" title="匿名函数lambda"></a>匿名函数lambda</h1><p>python 使用 lambda 来创建匿名函数。</p><ul><li>lambda只是一个表达式，函数体比def简单很多。</li><li>lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。</li><li>lambda函数拥有自己的命名空间，且不能访问自有参数列表之外或全局命名空间里的参数。</li><li>虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。</li></ul><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p>lambda函数的语法只包含一个语句，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">lambda</span> [arg1 [,arg2,.....argn]]:expression<br></code></pre></td></tr></table></figure><p>如下实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 可写函数说明</span><br><span class="hljs-built_in">sum</span> = <span class="hljs-keyword">lambda</span> arg1, arg2: arg1 + arg2;<br> <br><span class="hljs-comment"># 调用sum函数</span><br><span class="hljs-built_in">print</span>( <span class="hljs-string">&quot;相加后的值为 : &quot;</span>, <span class="hljs-built_in">sum</span>( <span class="hljs-number">10</span>, <span class="hljs-number">20</span> ))<br><span class="hljs-built_in">print</span>( <span class="hljs-string">&quot;相加后的值为 : &quot;</span>, <span class="hljs-built_in">sum</span>( <span class="hljs-number">20</span>, <span class="hljs-number">20</span> ))<br></code></pre></td></tr></table></figure><h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><h2 id="面向过程-和-面向对象的对比"><a href="#面向过程-和-面向对象的对比" class="headerlink" title="面向过程 和 面向对象的对比"></a>面向过程 和 面向对象的对比</h2><p>Q：存储学生的信息并打印出来</p><p><strong>面向过程</strong></p><p> 假设我们要处理学生的成绩表，为了表示一个学生的成绩，面向过程的程序可以用一个dict表示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">std1 = &#123; <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Michael&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">98</span> &#125;<br>std2 = &#123; <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">81</span> &#125;<br></code></pre></td></tr></table></figure><p>而处理学生成绩可以通过函数实现，比如打印学生的成绩：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_score</span>(<span class="hljs-params">std</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%s: %s&#x27;</span> % (std[<span class="hljs-string">&#x27;name&#x27;</span>], std[<span class="hljs-string">&#x27;score&#x27;</span>]))<br></code></pre></td></tr></table></figure><p><strong>面向对象</strong></p><p>如果采用面向对象的程序设计思想，我们首选思考的不是程序的执行流程，而是<code>Student</code>这种数据类型应该被视为一个对象，这个对象拥有<code>name</code>和<code>score</code>这两个属性（Property）。如果要打印一个学生的成绩，首先必须创建出这个学生对应的对象，然后，给对象发一个<code>print_score</code>消息，让对象自己把自己的数据打印出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, score</span>):<br>        self.name = name<br>        self.score = score<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">print_score</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%s: %s&#x27;</span> % (self.name, self.score))<br></code></pre></td></tr></table></figure><p>给对象发消息实际上就是调用对象对应的关联函数，我们称之为对象的方法（Method）。面向对象的程序写出来就像这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">bart = Student(<span class="hljs-string">&#x27;Bart Simpson&#x27;</span>, <span class="hljs-number">59</span>)<br>lisa = Student(<span class="hljs-string">&#x27;Lisa Simpson&#x27;</span>, <span class="hljs-number">87</span>)<br>bart.print_score()<br>lisa.print_score()<br></code></pre></td></tr></table></figure><h2 id="类、实例、方法和属性"><a href="#类、实例、方法和属性" class="headerlink" title="类、实例、方法和属性"></a>类、实例、方法和属性</h2><ul><li>类 Student</li><li>实例 jack</li><li>方法 print_score</li><li>属性 obj_name</li><li>增加属性 gender</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>): <span class="hljs-comment">#Student是类</span><br>    obj_name = <span class="hljs-string">&#x27;this is obj name str！&#x27;</span><span class="hljs-comment">#这个类有一个属性（类属性）</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, score</span>):  <span class="hljs-comment">#特殊方法“__init__”前后分别有两个下划线！！！</span><br>        self.name = name<br>        self.score = score<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">print_score</span>(<span class="hljs-params">self</span>):<span class="hljs-comment">#print_score 这个函数就是方法</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%s: %s&#x27;</span> % (self.name, self.score))<br>        <br>jack = Student(<span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-number">95</span>)  <span class="hljs-comment">#jack是实例</span><br>jack.gender = <span class="hljs-string">&#x27;man&#x27;</span> <span class="hljs-comment">#此处加了一个属性（实例属性）</span><br><br><span class="hljs-built_in">print</span> (<span class="hljs-string">&#x27;%s is a %s&#x27;</span> % (jack.name, jack.gender))<span class="hljs-comment">#输出 增加的实例属性</span><br><span class="hljs-built_in">print</span> (<span class="hljs-string">&#x27;%s&#x27;</span> % (jack.obj_name))<span class="hljs-comment">#输出类属性</span><br><span class="hljs-built_in">print</span> (<span class="hljs-string">&#x27;Hi,%s your score is %s&#x27;</span> % (jack.name, jack.score))<span class="hljs-comment">#输出实例的属性</span><br><span class="hljs-comment">#运行结果</span><br>Jack <span class="hljs-keyword">is</span> a man<br>this <span class="hljs-keyword">is</span> obj name <span class="hljs-built_in">str</span>！<br>Hi，Jack yours score <span class="hljs-keyword">is</span> <span class="hljs-number">95</span><br></code></pre></td></tr></table></figure><h3 id="类-实例"><a href="#类-实例" class="headerlink" title="类 实例"></a>类 实例</h3><p>类是创建实例的模板，而实例则是一个一个具体的对象，各个实例拥有的数据都互相独立，互不影响；</p><hr><p>面向对象最重要的概念就是<strong>类（Class）</strong>和<strong>实例（Instance）</strong>，必须牢记类是抽象的模板，比如Student类，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的<strong>方法</strong>，但各自的数据可能不同。</p><p>仍以Student类为例，在Python中，定义类是通过<code>class</code>关键字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>): <span class="hljs-comment">#Student是类</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, score</span>):  <span class="hljs-comment">#特殊方法“__init__”前后分别有两个下划线！！！</span><br>        self.name = name<br>        self.score = score<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">print_score</span>(<span class="hljs-params">self</span>):<span class="hljs-comment">#这就是方法</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%s: %s&#x27;</span> % (self.name, self.score))<br></code></pre></td></tr></table></figure><p><code>class</code>后面紧接着是类名，即<code>Student</code>，类名通常是大写开头的单词，紧接着是<code>(object)</code>，表示该类是从哪个类继承下来的，继承的概念我们后面再讲，通常，如果没有合适的继承类，就使用<code>object</code>类，这是所有类最终都会继承的类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">jack = Student(<span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-number">95</span>)     <span class="hljs-comment">#jack是实例</span><br></code></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p><strong>方法</strong>就是与实例绑定的函数，和普通函数不同，方法可以直接访问实例的数据；</p><hr><p>面向对象编程的一个重要特点就是数据封装。在上面的<code>Student</code>类中，每个实例就拥有各自的<code>name</code>和<code>score</code>这些数据。我们可以通过函数来访问这些数据，比如打印一个学生的成绩：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_score</span>(<span class="hljs-params">std</span>):<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%s: %s&#x27;</span> % (std.name, std.score))<br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>print_score(bart)<br>Bart Simpson: <span class="hljs-number">59</span><br></code></pre></td></tr></table></figure><p>但是，既然<code>Student</code>实例本身就拥有这些数据，要访问这些数据，就没有必要从外面的函数去访问，可以直接在<code>Student</code>类的内部定义访问数据的函数，这样，就把“数据”给封装起来了。这些封装数据的函数是和<code>Student</code>类本身是关联起来的，我们称之为类的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, score</span>):<br>        self.name = name<br>        self.score = score<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">print_score</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%s: %s&#x27;</span> % (self.name, self.score))<br></code></pre></td></tr></table></figure><p>要定义一个方法，除了第一个参数是<code>self</code>外，其他和普通函数一样。要调用一个方法，只需要在实例变量上直接调用，除了<code>self</code>不用传递，其他参数正常传入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bart.print_score()<br>Bart Simpson: <span class="hljs-number">59</span><br></code></pre></td></tr></table></figure><h3 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h3><ul><li>实例增加属性</li></ul><p>类相当于一个模板，用模板（类）定义实例后，实例还可以再加其他属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>): <span class="hljs-comment">#Student是类</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, score</span>):  <span class="hljs-comment">#特殊方法“__init__”前后分别有两个下划线！！！</span><br>        self.name = name<br>        self.score = score<br><br>jack = Student(<span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-number">95</span>)<br>jack.gender = <span class="hljs-string">&#x27;man&#x27;</span> <span class="hljs-comment">#此处加了一个属性</span><br><br><br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;%s is a %s&quot;</span> % (jack.name, jack.gender))<br></code></pre></td></tr></table></figure><h2 id="访问限制-private"><a href="#访问限制-private" class="headerlink" title="访问限制 private"></a>访问限制 private</h2><p>外部无法访问，只能通过方法访问（私有变量）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, score</span>):<br>        self.__name = name<span class="hljs-comment">#变成私有变量（private）了</span><br>        self.__score = score<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">print_score</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%s: %s&#x27;</span> % (self.__name, self.__score))<br></code></pre></td></tr></table></figure><hr><p>需要注意的是，在Python中，变量名类似<code>__xxx__</code>的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用<code>__name__</code>、<code>__score__</code>这样的变量名。</p><p>有些时候，你会看到以一个下划线开头的实例变量名，比如<code>_name</code>，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。</p><p>双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问<code>__name</code>是因为Python解释器对外把<code>__name</code>变量改成了<code>_Student__name</code>，所以，仍然可以通过<code>_Student__name</code>来访问<code>__name</code>变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bart._Student__name<br><span class="hljs-string">&#x27;Bart Simpson&#x27;</span><br></code></pre></td></tr></table></figure><p>但是强烈建议你不要这么干，因为不同版本的Python解释器可能会把<code>__name</code>改成不同的变量名。</p><p>总的来说就是，Python本身没有任何机制阻止你干坏事，一切全靠自觉。</p><p>最后注意下面的这种<strong>错误写法</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bart = Student(<span class="hljs-string">&#x27;Bart Simpson&#x27;</span>, <span class="hljs-number">59</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bart.get_name()<br><span class="hljs-string">&#x27;Bart Simpson&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>bart.__name = <span class="hljs-string">&#x27;New Name&#x27;</span> <span class="hljs-comment"># 设置__name变量！</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>bart.__name<br><span class="hljs-string">&#x27;New Name&#x27;</span><br></code></pre></td></tr></table></figure><p>表面上看，外部代码“成功”地设置了<code>__name</code>变量，但实际上这个<code>__name</code>变量和class内部的<code>__name</code>变量<em>不是</em>一个变量！内部的<code>__name</code>变量已经被Python解释器自动改成了<code>_Student__name</code>，而外部代码给<code>bart</code>新增了一个<code>__name</code>变量。不信试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bart.get_name() <span class="hljs-comment"># get_name()内部返回self.__name</span><br><span class="hljs-string">&#x27;Bart Simpson&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p><strong>用组合的方式建立了类与组合的类之间的关系，它是一种‘有’的关系,比如教授有生日，教授教python课程</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BirthDate</span>:    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,year,month,day</span>):<br>        self.year=year<br>        self.month=month<br>        self.day=day<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Couse</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,name,price,period</span>):<br>        self.name=name<br>        self.price=price<br>        self.period=period<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,name,gender,birth,course</span>):<br>        self.name=name <br>        self.gender=gender<br>        self.birth=birth<br>        self.course=course<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">teach</span>(<span class="hljs-params">self</span>): <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;teaching&#x27;</span>)<br>p1=Teacher(<span class="hljs-string">&#x27;egon&#x27;</span>,<span class="hljs-string">&#x27;male&#x27;</span>, <br>            BirthDate(<span class="hljs-string">&#x27;1995&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;27&#x27;</span>), <br>            Couse(<span class="hljs-string">&#x27;python&#x27;</span>,<span class="hljs-string">&#x27;28000&#x27;</span>,<span class="hljs-string">&#x27;4 months&#x27;</span>)<br>           ) <br><br><span class="hljs-built_in">print</span>(p1.birth.year,p1.birth.month,p1.birth.day) <br><br><span class="hljs-built_in">print</span>(p1.course.name,p1.course.price,p1.course.period)<br><span class="hljs-string">&#x27;&#x27;&#x27; </span><br><span class="hljs-string">运行结果: </span><br><span class="hljs-string">1 27 </span><br><span class="hljs-string">python 28000 4 months </span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>当类之间有显著不同，并且较小的类是较大的类所需要的组件时，用组合比较好</strong></p><h2 id="继承-多态"><a href="#继承-多态" class="headerlink" title="继承 多态"></a>继承 多态</h2><ul><li>抽象：抽象即抽取类似或者说比较像的部分。是一个从具题到抽象的过程。</li><li>继承：子类继承了父类的方法和属性</li><li>派生：子类在父类方法和属性的基础上产生了新的方法和属性</li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li>建立一个新类（子类 Subclass）可以copy一份原来类（父类 基类或超类 Base class、Super class）的全部功能（方法、变量 等）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-title class_ inherited__">object</span>):<span class="hljs-comment">#父类</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Animal is running...&#x27;</span>)<br>        <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-title class_ inherited__">Animal</span>):<span class="hljs-comment">#子类</span><br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment">#运行结果</span><br>Animal <span class="hljs-keyword">is</span> running...<span class="hljs-comment">#子类有了父类的方法</span><br></code></pre></td></tr></table></figure><ul><li>当子类和父类都存在相同的<code>run()</code>方法时，我们说，子类的<code>run()</code>覆盖了父类的<code>run()</code>，在代码运行的时候，总是会调用子类的<code>run()</code>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-title class_ inherited__">object</span>):<span class="hljs-comment">#父类</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Animal is running...&#x27;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-title class_ inherited__">Animal</span>):<span class="hljs-comment">#子类</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Dog is running...&#x27;</span>)<br><br><span class="hljs-comment">#运行结果</span><br>Dog <span class="hljs-keyword">is</span> running...<span class="hljs-comment">#子类覆盖了父类的方法</span><br></code></pre></td></tr></table></figure><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p><strong>就是一个集合的概念，子类包含了父类，子类比父类范围更大，这种好处是通用性更强</strong></p><ul><li>子类继承了父类的类型，子类既是  <strong>子类类型</strong>  也是  <strong>父类类型</strong>  </li><li>传入类型设置为  父类   可以有很好的通用性</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-title class_ inherited__">object</span>):<span class="hljs-comment">#父类</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Animal is running...&#x27;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-title class_ inherited__">Animal</span>):<span class="hljs-comment">#子类</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Dog is running...&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run_twice</span>(<span class="hljs-params">animal</span>):<span class="hljs-comment">#因为传入的是 父类 所以子类父类都可以用    有很好通用性</span><br>    animal.run()<br>    animal.run()<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>run_twice(Animal())<br>Animal <span class="hljs-keyword">is</span> running...<br>Animal <span class="hljs-keyword">is</span> running...<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>run_twice(Dog())<br>Dog <span class="hljs-keyword">is</span> running...<br>Dog <span class="hljs-keyword">is</span> running...<br></code></pre></td></tr></table></figure><hr><p>要理解什么是多态，我们首先要对数据类型再作一点说明。当我们定义一个class的时候，我们实际上就定义了一种数据类型。我们定义的数据类型和Python自带的数据类型，比如str、list、dict没什么两样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-built_in">list</span>() <span class="hljs-comment"># a是list类型</span><br>b = Animal() <span class="hljs-comment"># b是Animal类型</span><br>c = Dog() <span class="hljs-comment"># c是Dog类型</span><br></code></pre></td></tr></table></figure><p>判断一个变量是否是某个类型可以用<code>isinstance()</code>判断：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(a, <span class="hljs-built_in">list</span>)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(b, Animal)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(c, Dog)<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>看来<code>a</code>、<code>b</code>、<code>c</code>确实对应着<code>list</code>、<code>Animal</code>、<code>Dog</code>这3种类型。</p><p>但是等等，试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(c, Animal)<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>看来<code>c</code>不仅仅是<code>Dog</code>，<code>c</code>还是<code>Animal</code>！</p><p>不过仔细想想，这是有道理的，因为<code>Dog</code>是从<code>Animal</code>继承下来的，当我们创建了一个<code>Dog</code>的实例<code>c</code>时，我们认为<code>c</code>的数据类型是<code>Dog</code>没错，但<code>c</code>同时也是<code>Animal</code>也没错，<code>Dog</code>本来就是<code>Animal</code>的一种！</p><p>所以，在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。但是，反过来就不行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>b = Animal()<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(b, Dog)<br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p><code>Dog</code>可以看成<code>Animal</code>，但<code>Animal</code>不可以看成<code>Dog</code>。</p><p>要理解多态的好处，我们还需要再编写一个函数，这个函数接受一个<code>Animal</code>类型的变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">run_twice</span>(<span class="hljs-params">animal</span>):<br>    animal.run()<br>    animal.run()<br></code></pre></td></tr></table></figure><p>当我们传入<code>Animal</code>的实例时，<code>run_twice()</code>就打印出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>run_twice(Animal())<br>Animal <span class="hljs-keyword">is</span> running...<br>Animal <span class="hljs-keyword">is</span> running...<br></code></pre></td></tr></table></figure><p>当我们传入<code>Dog</code>的实例时，<code>run_twice()</code>就打印出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>run_twice(Dog())<br>Dog <span class="hljs-keyword">is</span> running...<br>Dog <span class="hljs-keyword">is</span> running...<br></code></pre></td></tr></table></figure><p>当我们传入<code>Cat</code>的实例时，<code>run_twice()</code>就打印出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>run_twice(Cat())<br>Cat <span class="hljs-keyword">is</span> running...<br>Cat <span class="hljs-keyword">is</span> running...<br></code></pre></td></tr></table></figure><p>看上去没啥意思，但是仔细想想，现在，如果我们再定义一个<code>Tortoise</code>类型，也从<code>Animal</code>派生：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tortoise</span>(<span class="hljs-title class_ inherited__">Animal</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Tortoise is running slowly...&#x27;</span>)<br></code></pre></td></tr></table></figure><p>当我们调用<code>run_twice()</code>时，传入<code>Tortoise</code>的实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>run_twice(Tortoise())<br>Tortoise <span class="hljs-keyword">is</span> running slowly...<br>Tortoise <span class="hljs-keyword">is</span> running slowly...<br></code></pre></td></tr></table></figure><p>你会发现，新增一个<code>Animal</code>的子类，不必对<code>run_twice()</code>做任何修改，实际上，任何依赖<code>Animal</code>作为参数的函数或者方法都可以不加修改地正常运行，原因就在于多态。</p><p>多态的好处就是，当我们需要传入<code>Dog</code>、<code>Cat</code>、<code>Tortoise</code>……时，我们只需要接收<code>Animal</code>类型就可以了，因为<code>Dog</code>、<code>Cat</code>、<code>Tortoise</code>……都是<code>Animal</code>类型，然后，按照<code>Animal</code>类型进行操作即可。由于<code>Animal</code>类型有<code>run()</code>方法，因此，传入的任意类型，只要是<code>Animal</code>类或者子类，就会自动调用实际类型的<code>run()</code>方法，这就是多态的意思：</p><p>对于一个变量，我们只需要知道它是<code>Animal</code>类型，无需确切地知道它的子类型，就可以放心地调用<code>run()</code>方法，而具体调用的<code>run()</code>方法是作用在<code>Animal</code>、<code>Dog</code>、<code>Cat</code>还是<code>Tortoise</code>对象上，由运行时该对象的确切类型决定，这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种<code>Animal</code>的子类时，只要确保<code>run()</code>方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则：</p><p>对扩展开放：允许新增<code>Animal</code>子类；</p><p>对修改封闭：不需要修改依赖<code>Animal</code>类型的<code>run_twice()</code>等函数。</p><p>继承还可以一级一级地继承下来，就好比从爷爷到爸爸、再到儿子这样的关系。而任何类，最终都可以追溯到根类object，这些继承关系看上去就像一颗倒着的树。比如如下的继承树：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ascii">                ┌───────────────┐<br>                │    object     │<br>                └───────────────┘<br>                        │<br>           ┌────────────┴────────────┐<br>           │                         │<br>           ▼                         ▼<br>    ┌─────────────┐           ┌─────────────┐<br>    │   Animal    │           │    Plant    │<br>    └─────────────┘           └─────────────┘<br>           │                         │<br>     ┌─────┴──────┐            ┌─────┴──────┐<br>     │            │            │            │<br>     ▼            ▼            ▼            ▼<br>┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐<br>│   Dog   │  │   Cat   │  │  Tree   │  │ Flower  │<br>└─────────┘  └─────────┘  └─────────┘  └─────────┘<br></code></pre></td></tr></table></figure><h4 id="静态语言-vs-动态语言"><a href="#静态语言-vs-动态语言" class="headerlink" title="静态语言 vs 动态语言"></a>静态语言 vs 动态语言</h4><p>对于静态语言（例如Java）来说，如果需要传入<code>Animal</code>类型，则传入的对象必须是<code>Animal</code>类型或者它的子类，否则，将无法调用<code>run()</code>方法。</p><p>对于Python这样的动态语言来说，则不一定需要传入<code>Animal</code>类型。我们只需要保证传入的对象有一个<code>run()</code>方法就可以了：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Timer</span>(object):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>        print(<span class="hljs-string">&#x27;Start...&#x27;</span>)<br></code></pre></td></tr></table></figure><p>这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</p><p>Python的“file-like object“就是一种鸭子类型。对真正的文件对象，它有一个<code>read()</code>方法，返回其内容。但是，许多对象，只要有<code>read()</code>方法，都被视为“file-like object“。许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了<code>read()</code>方法的对象。</p><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p><strong>抽象类是一个特殊的类，它的特殊之处在于只能被继承，不能被实例化</strong></p><p><em>比如我们有香蕉的类，有苹果的类，有桃子的类，从这些类抽取相同的内容就是水果这个抽象的类，你吃水果时，要么是吃一个具体的香蕉，要么是吃一个具体的桃子。。。。。。你永远无法吃到一个叫做水果的东西</em></p><p><em>从实现角度来看，抽象类与普通类的不同之处在于：抽象类中有抽象方法，该类不能被实例化，只能被继承，且子类必须实现抽象方法。这一点与接口有点类似，但其实是不同的，即将揭晓答案</em></p><h2 id="经典类和新式类"><a href="#经典类和新式类" class="headerlink" title="经典类和新式类"></a>经典类和新式类</h2><p><img src="/2022/297a89d9/1610094679745.jpg" alt="1610094679745"></p>]]></content>
    
    
    <categories>
      
      <category>language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式</title>
    <link href="/2022/2f57a694/"/>
    <url>/2022/2f57a694/</url>
    
    <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="正则表达式语法"><a href="#正则表达式语法" class="headerlink" title="正则表达式语法"></a>正则表达式语法</h2><ul><li><strong>runoo+b</strong>，可以匹配 runoob、runooob、runoooooob 等，+ 号代表前面的字符必须至少出现一次（1次或多次）。</li><li><strong>runoo*b</strong>，可以匹配 runob、runoob、runoooooob 等，* 号代表前面的字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次）。</li><li><strong>colou?r</strong> 可以匹配 color 或者 colour，? 问号代表前面的字符最多只可以出现一次（0次、或1次）。</li></ul><h2 id="正则表达式替换"><a href="#正则表达式替换" class="headerlink" title="正则表达式替换"></a>正则表达式替换</h2><p>VSCode不可用，notepad++可用</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs inform7">原始串 <br>str<span class="hljs-comment">[1]</span>abc<span class="hljs-comment">[991]</span>; <br>str<span class="hljs-comment">[2]</span>abc<span class="hljs-comment">[992]</span>; <br>str<span class="hljs-comment">[11]</span>abc<span class="hljs-comment">[993]</span>; <br>str<span class="hljs-comment">[22]</span>abc<span class="hljs-comment">[994]</span>; <br>str<span class="hljs-comment">[111]</span>abc<span class="hljs-comment">[995]</span>; <br>str<span class="hljs-comment">[222]</span>abc<span class="hljs-comment">[996]</span>; <br>str<span class="hljs-comment">[1111]</span>abc<span class="hljs-comment">[997]</span>; <br>str<span class="hljs-comment">[2222]</span>abc<span class="hljs-comment">[999]</span>; <br><br>目标串： <br>abc<span class="hljs-comment">[1]</span>; <br>abc<span class="hljs-comment">[2]</span>; <br>abc<span class="hljs-comment">[11]</span>; <br>abc<span class="hljs-comment">[22]</span>; <br>abc<span class="hljs-comment">[111]</span>; <br>abc<span class="hljs-comment">[222]</span>; <br>abc<span class="hljs-comment">[1111]</span>; <br>abc<span class="hljs-comment">[2222]</span>; <br><br>处理： <br>查找串：str/<span class="hljs-comment">[(<span class="hljs-comment">[0-9]</span>+)/]</span>abc/<span class="hljs-comment">[<span class="hljs-comment">[0-9]</span>+/]</span> <br>替换串：abc<span class="hljs-comment">[/1]</span> <br></code></pre></td></tr></table></figure><p><img src="/2022/2f57a694/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzMzc5Mzc0MDAw,size_16,color_FFFFFF,t_70.png" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>正则表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CAD</title>
    <link href="/2022/154e1146/"/>
    <url>/2022/154e1146/</url>
    
    <content type="html"><![CDATA[<h1 id="CAD"><a href="#CAD" class="headerlink" title="CAD"></a>CAD</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul><li><p>对象捕捉：端点、中点、圆心、、、、、</p></li><li></li><li><p>shift正交</p></li><li><p>shift按住，取消选择</p></li><li><p>连续画直线，空格取消</p></li><li><p>画直线，c键闭合</p></li></ul><h1 id="形状"><a href="#形状" class="headerlink" title="形状"></a>形状</h1><h2 id="直线"><a href="#直线" class="headerlink" title="直线"></a>直线</h2><p>L键</p><h2 id="圆"><a href="#圆" class="headerlink" title="圆"></a>圆</h2><p>C键</p><h3 id="圆心-半径"><a href="#圆心-半径" class="headerlink" title="圆心 半径"></a>圆心 半径</h3><p>D键切换成直径</p><h3 id="两点"><a href="#两点" class="headerlink" title="两点"></a>两点</h3><h3 id="三点"><a href="#三点" class="headerlink" title="三点"></a>三点</h3><h3 id="相切-相切-半径"><a href="#相切-相切-半径" class="headerlink" title="相切 相切 半径"></a>相切 相切 半径</h3><h3 id="相切-相切-相切"><a href="#相切-相切-相切" class="headerlink" title="相切 相切 相切"></a>相切 相切 相切</h3><p>快捷键不详</p><h2 id="圆弧"><a href="#圆弧" class="headerlink" title="圆弧"></a>圆弧</h2><p>ARC键</p><p>逆时针画圆弧</p><h2 id="多段线"><a href="#多段线" class="headerlink" title="多段线"></a>多段线</h2><p>PLI键</p><ul><li>可以赋予宽度</li></ul><h3 id="合并多段线"><a href="#合并多段线" class="headerlink" title="合并多段线"></a>合并多段线</h3><ol><li>PE (pedit 多段线编辑)</li><li>m 选择多段线</li><li>选中后空格确认</li><li>y 转换</li><li>j 合并</li><li></li></ol><h2 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h2><h2 id="多边形"><a href="#多边形" class="headerlink" title="多边形"></a>多边形</h2><p>POL 键</p><h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><h2 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h2><p>m 键 move</p><h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>co </p><h2 id="拉伸"><a href="#拉伸" class="headerlink" title="拉伸"></a>拉伸</h2><p>s</p><h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>ro </p><ul><li>起点开始 逆时针</li><li>c 复制，原来的保留并复制</li><li>r 参照，参照线旋转</li></ul><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p>mi</p><h2 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h2><p>sc</p><ul><li>r参照，参照边长缩放</li></ul><h2 id="对齐缩放"><a href="#对齐缩放" class="headerlink" title="对齐缩放"></a>对齐缩放</h2><p>al</p><ul><li>根据边对齐，根据边长缩放</li></ul><h2 id="修剪"><a href="#修剪" class="headerlink" title="修剪"></a>修剪</h2><p>tr</p><ul><li>不选基线默认修剪</li></ul><h2 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h2><p>ex</p><ul><li>不选基线默认延伸</li></ul><h2 id="倒角"><a href="#倒角" class="headerlink" title="倒角"></a>倒角</h2><p>cha</p><h2 id="圆角"><a href="#圆角" class="headerlink" title="圆角"></a>圆角</h2><p>f</p><h2 id="光顺曲线"><a href="#光顺曲线" class="headerlink" title="光顺曲线"></a>光顺曲线</h2><p>两个曲线光滑连接</p><h2 id="矩形阵列"><a href="#矩形阵列" class="headerlink" title="矩形阵列"></a>矩形阵列</h2><h2 id="路径阵列"><a href="#路径阵列" class="headerlink" title="路径阵列"></a>路径阵列</h2><h2 id="圆形阵列"><a href="#圆形阵列" class="headerlink" title="圆形阵列"></a>圆形阵列</h2><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><h2 id="修改注释标准-gt"><a href="#修改注释标准-gt" class="headerlink" title="修改注释标准 (,-&gt;.)"></a>修改注释标准 (,-&gt;.)</h2><p>标注样式-&gt;修改-&gt;主单位-&gt;逗号改成点号</p><h2 id="空心字-文字转换成线"><a href="#空心字-文字转换成线" class="headerlink" title="空心字 文字转换成线"></a>空心字 文字转换成线</h2><p><strong>注意：</strong>安装默认不安装拓展工具，如果txtexp找不到命令，需要重装，安装的时候选择组件的时候选上Express Tools。</p><ol><li>mt 创建文字</li><li>txtexp 将文字分解成文字轮廓</li></ol>]]></content>
    
    
    <categories>
      
      <category>more_interest</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CAD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CatDrive猫盘</title>
    <link href="/2022/eae787f0/"/>
    <url>/2022/eae787f0/</url>
    
    <content type="html"><![CDATA[<h1 id="刷机"><a href="#刷机" class="headerlink" title="刷机"></a>刷机</h1><p>刷机教程很多很多，这边就不赘述了</p><p><a href="https://www.jianshu.com/p/77e529fb35f9">https://www.jianshu.com/p/77e529fb35f9</a></p><p><a href="https://www.huakings.cn/post/283.html">https://www.huakings.cn/post/283.html</a></p><ul><li>建议备好串口刷砖必备</li><li>猫盘ssh 用户名 <strong>root</strong> 密码 <strong>Etech12</strong></li></ul><h1 id="变砖刷机"><a href="#变砖刷机" class="headerlink" title="变砖刷机"></a>变砖刷机</h1><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.bilibili.com/video/av73492887">https://www.bilibili.com/video/av73492887</a></p><p><a href="https://www.huakings.cn/post/186.html">https://www.huakings.cn/post/186.html</a></p><p><a href="http://wiki.espressobin.net/tiki-index.php?page=Bootloader+recovery+via+UART">http://wiki.espressobin.net/tiki-index.php?page=Bootloader+recovery+via+UART</a></p><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p><strong>猫盘引导过程</strong></p><p><img src="/2022/eae787f0/image-20211225204417854.png" alt="image-20211225204417854"></p><p>从 A3720 机器引导，再到SPI FLASH引导，再到SATA硬盘或者EMMC启动</p><p>出现<code>&gt;E</code>就是SPI引导没了，需要用厂商工具把SPI引导刷一遍。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p><img src="/2022/eae787f0/image-20211225203501999.png" alt="image-20211225203501999"></p><p>发现出现<code>&gt;E</code>，这就说明猫盘SPI引导没了，需要重新刷入uboot，进行救砖。</p><p>首先，需要预装VM启用厂商的Linux环境(ezremaster.iso)，安装VM这步跳过。</p><blockquote><p>创建虚拟机的时候操作系统可以选择Linux 2.2.x内核，</p></blockquote><p>串口的USB设备加到VM内，然后开机。</p><p>输入如下代码，回车运行后会让输入port，<code>/dev/ttyUSB0</code>一般是<code>0</code>输入0回车就会开始刷SPI，然后会出现++++++++，在此期间可以按几下回车。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo sh /wtpd/shua.sh<br></code></pre></td></tr></table></figure><p><img src="/2022/eae787f0/image-20211225204613427.png" alt="image-20211225204613427"></p><p>等一段时间就会出现<code>marvell&gt;&gt;</code>，至此就已经救砖成功。</p><p><img src="/2022/eae787f0/image-20211225205017895.png" alt="image-20211225205017895"></p><p>接下来就可以用<code>bubt</code>命令正常刷SPI引导了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">bubt full.bin spi usb<br></code></pre></td></tr></table></figure><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><h2 id="LED-FAN-控制脚本"><a href="#LED-FAN-控制脚本" class="headerlink" title="LED FAN 控制脚本"></a>LED FAN 控制脚本</h2><p>参考: <a href="https://bbs.nas66.com/thread-9007-1-1.html">https://bbs.nas66.com/thread-9007-1-1.html</a></p><p>参考: <a href="https://bbs.nas66.com/thread-13810-1-1.html">https://bbs.nas66.com/thread-13810-1-1.html</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir -p /a_usr<br>cat &gt; /a_usr/ledfan.sh &lt;&lt;EOF<br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/sh</span><br>if [ ! -d /sys/class/gpio/gpio450 ] ; then<br>echo 450 &gt; /sys/class/gpio/export<br>fi<br>echo out &gt; /sys/class/gpio/gpio450/direction<br>i2cset -y -f 0 0x45 0x00 0x55<br>i2cset -y -f 0 0x45 0x01 0x01<br>i2cset -y -f 0 0x45 0x30 0x07 <br>rm -r /tmp/led/<br>mkdir /tmp/led/<br>echo 1 &gt; /tmp/led/leds.flag<br>while true<br>do<br>sata_temp=&quot;\$(smartctl -a /dev/hda -d ata | sed -n &#x27;/Temperature_Celsius/p&#x27; | awk &#x27;&#123;print $10&#125;&#x27;)&quot;<br>sata=&quot;\$(hdparm -C /dev/sda |grep &#x27;drive&#x27;|awk &#x27;&#123;print \$4&#125;&#x27;)&quot;<br>ledss=&quot;\$(cat /tmp/led/leds.flag)&quot;<br>if [ \$sata = standby ];then<br>led=&quot;0x03&quot;<br>leds=&quot;0&quot;<br>fi<br>if [ \$sata = active/idle ];then<br>led=&quot;0x73&quot;<br>leds=&quot;1&quot;<br>fi<br>if [ \$sata_temp -ge 55 ];then<br>if [ -f &quot;/tmp/led/led31.flag&quot; ] &amp;&amp; [ \$ledss = \$leds ];then <br>sleep 15<br>continue<br>fi<br>i2cset -y -f 0 0x45 0x32 0x00<br>i2cset -y -f 0 0x45 0x33 0x00<br>i2cset -y -f 0 0x45 0x31 \$&#123;led&#125;<br>i2cset -y -f 0 0x45 0x34 255<br>echo 1 &gt; /sys/class/gpio/gpio450/value<br>rm -rf /tmp/led/led*.flag<br>touch /tmp/led/led31.flag<br>echo \$&#123;leds&#125; &gt; /tmp/led/leds.flag<br>fi<br>if [ \$sata_temp -ge 45 ] &amp;&amp; [ \$sata_temp -lt 55 ];then<br>if [ -f &quot;/tmp/led/led33.flag&quot; ] &amp;&amp; [ \$ledss = \$leds ];then<br>sleep 15 <br>continue<br>fi<br>i2cset -y -f 0 0x45 0x31 0x00<br>i2cset -y -f 0 0x45 0x32 0x00<br>i2cset -y -f 0 0x45 0x33 \$&#123;led&#125;<br>i2cset -y -f 0 0x45 0x36 255<br>echo 1 &gt; /sys/class/gpio/gpio450/value<br>rm -rf /tmp/led/led*.flag<br>touch /tmp/led/led33.flag<br>echo \$&#123;leds&#125; &gt; /tmp/led/leds.flag<br>fi<br>if [ \$sata_temp -lt 45 ];then<br>if [ -f &quot;/tmp/led/led32.flag&quot; ] &amp;&amp; [ \$ledss = \$leds ];then<br>sleep 15 <br>continue<br>fi<br>i2cset -y -f 0 0x45 0x31 0x00<br>i2cset -y -f 0 0x45 0x33 0x00<br>i2cset -y -f 0 0x45 0x32 \$&#123;led&#125;<br>i2cset -y -f 0 0x45 0x35 255<br>echo 0 &gt; /sys/class/gpio/gpio450/value<br>rm -rf /tmp/led/led*.flag<br>touch /tmp/led/led32.flag<br>echo \$&#123;leds&#125; &gt; /tmp/led/leds.flag<br>fi<br>sleep 15<br>done<br>EOF<br>bash /a_usr/ledfan.sh<br></code></pre></td></tr></table></figure><h2 id="修改SN半白脚本"><a href="#修改SN半白脚本" class="headerlink" title="修改SN半白脚本"></a>修改SN半白脚本</h2><p>下面的<code>00:11:32:12:34:56</code>最好改成壳子上自己的MAC</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd ~ &amp;&amp; wget -N --no-check-certificate https://www.huakings.cn/mp202003/macsn.sh &amp;&amp; chmod +x macsn.sh &amp;&amp; bash macsn.sh 00:11:32:12:34:56 1860ABCDE1860 &amp;&amp; rm -f /root/macsn.sh<br></code></pre></td></tr></table></figure><p>macsn.sh脚本详细内容如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs shell">macstr=$1<br>sn=$2<br>mac=($&#123;macstr//:/ &#125;)<br>if [ $&#123;#mac[@]&#125; != 6 ];<br>then<br>echo mac address error!<br>exit<br>fi<br>for var in $&#123;mac[@]&#125;<br>do<br>if echo $var | grep -q &#x27;[^0-9A-F]&#x27;<br>then <br>echo mac address error!<br>exit<br>fi <br>if  [[ $&#123;#var&#125; != 2  ]] <br>then<br>echo mac address error!!<br>exit<br>fi<br>done<br>if  [[ $&#123;#sn&#125; != 13  ]] <br>then<br>echo sn error:The SN Length must be 13<br>exit<br>fi<br><br>for((i=0;i&lt;6;i++));<br>do <br>declare -i macchecksum+=0x$&#123;mac[i]&#125;<br>done<br>declare -i macchecksum=$macchecksum%256<br>for((i=0;i&lt;13;i++));<br>do <br>declare -i checksum+=$(printf &#x27;%d&#x27; &quot;&#x27;$&#123;sn:$i:1&#125;&quot;)<br>done<br>if [ $&#123;#checksum&#125; == 3 ];<br>then<br>echo -e -n &quot;\x$&#123;mac[0]&#125;\x$&#123;mac[1]&#125;\x$&#123;mac[2]&#125;\x$&#123;mac[3]&#125;\x$&#123;mac[4]&#125;\x$&#123;mac[5]&#125;\<br>\x$(printf &#x27;%x&#x27; $macchecksum)\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0&quot;\<br>\SN=$sn&quot;,CHK=&quot;$checksum\<br>&quot;\x0\x0\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x3C\x0\x0\x0\<br>\x0\x0\x0\x0\x1\x1\x0\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x1\x1\x1\x1\<br>\x0\x1\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x1\x1\x1\x1\<br>\x1\x0\x1\x1\x1\x1\x1\x0\<br>\x1\x1\x1\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x1\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0&quot; &gt; vender.bin<br>else<br>echo -e -n &quot;\x$&#123;mac[0]&#125;\x$&#123;mac[1]&#125;\x$&#123;mac[2]&#125;\x$&#123;mac[3]&#125;\x$&#123;mac[4]&#125;\x$&#123;mac[5]&#125;\<br>\x$(printf &#x27;%x&#x27; $macchecksum)\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0&quot;\<br>\SN=$sn&quot;,CHK=&quot;$checksum\<br>&quot;\x0\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x3C\x0\x0\x0\<br>\x0\x0\x0\x0\x1\x1\x0\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x1\x1\x1\x1\<br>\x0\x1\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x1\x1\x1\x1\<br>\x1\x0\x1\x1\x1\x1\x1\x0\<br>\x1\x1\x1\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x1\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0&quot; &gt; vender.bin<br>fi<br>dd if=vender.bin of=/dev/mtdblock3<br>rm vender.bin<br>echo Update Success! MAC:$macstr SN:$sn<br></code></pre></td></tr></table></figure><h2 id="解决猫盘掉ip问题"><a href="#解决猫盘掉ip问题" class="headerlink" title="解决猫盘掉ip问题"></a>解决猫盘掉ip问题</h2><h3 id="最蠢的办法，检查无IP重启"><a href="#最蠢的办法，检查无IP重启" class="headerlink" title="最蠢的办法，检查无IP重启"></a>最蠢的办法，检查无IP重启</h3><p>将下面脚本添加到，群晖的开机启动</p><p>控制面板-任务计划-新增-触发的任务-用户自定义脚本-开机启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>dt=`date &#x27;+%d/%m/%Y %H:%M:%S&#x27;`<br>echo &quot;$dt&quot;<br>sleep 60<br>num=`ping -c20 223.5.5.5 | tail -2 | head -1 | cut -f 3 -d&quot;,&quot; | cut -f 1 -d&quot;%&quot; | cut -f 2 -d&quot; &quot;`<br>echo $num<br>echo $?<br>if [ $? -eq 0 -a $num -eq 0 ]; then<br>echo &quot;$dt ok&quot; &gt;&gt; /result.txt<br>else<br>echo &quot;$dt noip loss $num reboot&quot; &gt;&gt; /result.txt<br>reboot<br>fi<br></code></pre></td></tr></table></figure><h3 id="其它办法"><a href="#其它办法" class="headerlink" title="其它办法"></a>其它办法</h3><p><a href="https://bbs.nas66.com/thread-17505-1-1.html">https://bbs.nas66.com/thread-17505-1-1.html</a></p><p><a href="https://bbs.nas66.com/thread-16639-1-1.html">https://bbs.nas66.com/thread-16639-1-1.html</a></p><p><a href="https://bbs.nas66.com/thread-7843-1-1.html">https://bbs.nas66.com/thread-7843-1-1.html</a></p><p><a href="https://bbs.nas66.com/thread-9350-1-1.html">https://bbs.nas66.com/thread-9350-1-1.html</a></p><p><a href="https://bbs.nas66.com/thread-4593-5-3.html">https://bbs.nas66.com/thread-4593-5-3.html</a></p><h2 id="群晖回退x3p"><a href="#群晖回退x3p" class="headerlink" title="群晖回退x3p"></a>群晖回退x3p</h2><p><a href="https://bbs.nas66.com/forum.php?mod=viewthread&amp;tid=2661">https://bbs.nas66.com/forum.php?mod=viewthread&amp;tid=2661</a></p><p>主要就是刷x3p的UBOOT，插U盘，U盘放x3p的自动安装镜像</p>]]></content>
    
    
    <categories>
      
      <category>more_interest</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CatDrive</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nintendo Switch</title>
    <link href="/2022/f15ac6f4/"/>
    <url>/2022/f15ac6f4/</url>
    
    <content type="html"><![CDATA[<h1 id="NS-Usbloader"><a href="#NS-Usbloader" class="headerlink" title="NS-Usbloader"></a>NS-Usbloader</h1><p><a href="https://github.com/developersu/ns-usbloader/">https://github.com/developersu/ns-usbloader/</a></p><h1 id="TX-转-大气层"><a href="#TX-转-大气层" class="headerlink" title="TX 转 大气层"></a>TX 转 大气层</h1><p><a href="https://www.bilibili.com/video/BV1DZ4y1B777/?spm_id_from=333.788">https://www.bilibili.com/video/BV1DZ4y1B777/?spm_id_from=333.788</a></p><h1 id="安装游戏"><a href="#安装游戏" class="headerlink" title="安装游戏"></a>安装游戏</h1><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p><a href="https://switch520.com/27637.html">https://switch520.com/27637.html</a></p><p><a href="https://switch520.net/3892.html">https://switch520.net/3892.html</a></p><h2 id="NS-Usbloader-1"><a href="#NS-Usbloader-1" class="headerlink" title="NS-Usbloader"></a>NS-Usbloader</h2><p><a href="https://github.com/developersu/ns-usbloader/">https://github.com/developersu/ns-usbloader/</a></p><h2 id="Awoo"><a href="#Awoo" class="headerlink" title="Awoo"></a>Awoo</h2><p><a href="https://github.com/Huntereb/Awoo-Installer">https://github.com/Huntereb/Awoo-Installer</a></p><h1 id="金手指"><a href="#金手指" class="headerlink" title="金手指"></a>金手指</h1><h2 id="特斯拉插件"><a href="#特斯拉插件" class="headerlink" title="特斯拉插件"></a>特斯拉插件</h2><p>调出菜单: L + ↓</p><p>FPS界面调出: 按下左右摇杆</p><h2 id="64位游戏ID-对应-游戏名查询"><a href="#64位游戏ID-对应-游戏名查询" class="headerlink" title="64位游戏ID 对应 游戏名查询"></a>64位游戏ID 对应 游戏名查询</h2><p>调出特斯拉界面选择金手指, 即可查到游戏ID</p><p><a href="https://github.com/ibnux/switch-cheat/blob/master/GAMES.md">https://github.com/ibnux/switch-cheat/blob/master/GAMES.md</a></p><p><a href="https://switchbrew.org/w/index.php?title=Title_list/Games">https://switchbrew.org/w/index.php?title=Title_list/Games</a></p><h2 id="cheat"><a href="#cheat" class="headerlink" title="cheat"></a>cheat</h2><p><a href="https://github.com/ibnux/switch-cheat">https://github.com/ibnux/switch-cheat</a></p>]]></content>
    
    
    <categories>
      
      <category>more_interest</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Switch</tag>
      
      <tag>Nintendo</tag>
      
      <tag>Game</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PC Hardware</title>
    <link href="/2022/86880617/"/>
    <url>/2022/86880617/</url>
    
    <content type="html"><![CDATA[<h1 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h1><h2 id="ITX-主板的孔位图"><a href="#ITX-主板的孔位图" class="headerlink" title="ITX 主板的孔位图"></a>ITX 主板的孔位图</h2><p>括号中的数值单位是mm，下面的数值单位是inch。</p><p><img src="/2022/86880617/v2-adfa6cb86a379f8ea31c62416c3a9b93_720w.jpg" alt="img"></p><h2 id="ATX-孔位图"><a href="#ATX-孔位图" class="headerlink" title="ATX 孔位图"></a>ATX 孔位图</h2><p>数值单位是inch</p><p><img src="/2022/86880617/v2-19cb957be912ef88b779a7ed04de4eaf_720w.jpg" alt="img"></p><h1 id="DISK"><a href="#DISK" class="headerlink" title="DISK"></a>DISK</h1><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.snia.org/technology-communities/sff/specifications">SNIA协会定义</a></li><li>SFF-8301 (3.5” Form Factor Drive Dimensions)</li><li>SFF-8201 (2.5” Form Factor Drive Dimensions)</li></ul><h2 id="2-5”"><a href="#2-5”" class="headerlink" title="2.5”"></a>2.5”</h2><p>定义于SFF-8201, 长度为101.85mm (max), 宽度为69.85，厚度有不同规格，从5mm到19.05mm不等。常用的笔记本硬盘是7mm厚度，企业级硬盘是15mm，螺丝孔为公制M3标准。</p><p><img src="/2022/86880617/image-20211026113925717.png" alt="image-20211026113925717"></p><p><img src="/2022/86880617/image-20211026113951361.png" alt="image-20211026113951361"></p><p><img src="/2022/86880617/image-20211026114009000.png" alt="image-20211026114009000"></p><p><img src="/2022/86880617/image-20211026114023653.png" alt="image-20211026114023653"></p><h2 id="3-5”"><a href="#3-5”" class="headerlink" title="3.5”"></a>3.5”</h2><p>定义于SFF-8301,长度为147.00mm, 宽度为101.60mm，厚度有不同规格：17.80-42.00mm。通常硬盘的厚度都是小于26.10mm，螺丝孔为6-32 UNC-2B英制标准，公制M3.5也能凑合用。</p><p><img src="/2022/86880617/image-20211026114433027.png" alt="image-20211026114433027"></p><p><img src="/2022/86880617/image-20211026114447507.png" alt="image-20211026114447507"></p><h1 id="Lenovo-私有定义"><a href="#Lenovo-私有定义" class="headerlink" title="Lenovo 私有定义"></a>Lenovo 私有定义</h1><h2 id="主板-1"><a href="#主板-1" class="headerlink" title="主板"></a>主板</h2><h3 id="USB2-0-接口"><a href="#USB2-0-接口" class="headerlink" title="USB2.0 接口"></a>USB2.0 接口</h3><p><img src="/2022/86880617/image-20211026120339401.png" alt="image-20211026120339401"></p><p><img src="/2022/86880617/image-20211026120205476.png" alt="image-20211026120205476"></p><h3 id="F-PANEL"><a href="#F-PANEL" class="headerlink" title="F_PANEL"></a>F_PANEL</h3><p><img src="/2022/86880617/image-20211026120411691.png" alt="image-20211026120411691"></p><p><img src="/2022/86880617/image-20211026120130016.png" alt="image-20211026120130016"></p>]]></content>
    
    
    <categories>
      
      <category>more_interest</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hardware</tag>
      
      <tag>PC</tag>
      
      <tag>Lenovo</tag>
      
      <tag>Disk</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PC Software</title>
    <link href="/2022/fc18738/"/>
    <url>/2022/fc18738/</url>
    
    <content type="html"><![CDATA[<h1 id="PC-Windows"><a href="#PC-Windows" class="headerlink" title="PC Windows"></a>PC Windows</h1><h1 id="扫描修复系统"><a href="#扫描修复系统" class="headerlink" title="扫描修复系统"></a>扫描修复系统</h1><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">sfc <span class="hljs-string">/SCANNOW</span><br></code></pre></td></tr></table></figure><h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><h3 id="刷新DNS"><a href="#刷新DNS" class="headerlink" title="刷新DNS"></a>刷新DNS</h3><p><code>ipconfig /flushdns</code></p><h3 id="nslookup"><a href="#nslookup" class="headerlink" title="nslookup"></a>nslookup</h3><p><img src="/2022/fc18738/image-20220402175405670.png" alt="image-20220402175405670"></p><p><img src="/2022/fc18738/image-20220402175432533.png" alt="image-20220402175432533"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs bash">nslookup<br><br><span class="hljs-comment"># 设置查询类型 name server</span><br><span class="hljs-built_in">set</span> <span class="hljs-built_in">type</span>=ns<br><br><span class="hljs-comment"># 查询根服务器</span><br>.<br><br><span class="hljs-comment"># Non-authoritative 代表非权威应答 一般是缓存来的</span><br><span class="hljs-comment"># authoritative 表权威应答 根服务器直接返回的</span><br><br><span class="hljs-comment"># 设置查询类型 a ipv4地址</span><br><span class="hljs-built_in">set</span> <span class="hljs-built_in">type</span>=a<br><br><span class="hljs-comment"># 查询根服务器的ipv4地址</span><br>.<br><br><span class="hljs-comment"># 设置dns服务器地址</span><br>server 198.41.0.4<br><br><span class="hljs-comment"># 设置查询类型 name server</span><br><span class="hljs-built_in">set</span> <span class="hljs-built_in">type</span>=ns<br><br><span class="hljs-comment"># 查询cf域名服务器</span><br>cf.<br><br><span class="hljs-comment"># 设置查询类型 a ipv4地址</span><br><span class="hljs-built_in">set</span> <span class="hljs-built_in">type</span>=a<br><br><span class="hljs-comment"># 查询cf域名服务器的ipv4地址</span><br>cf.<br><br>..........<br><br><br>lager.cf.<br></code></pre></td></tr></table></figure><h1 id="硬链接-amp-符号链接"><a href="#硬链接-amp-符号链接" class="headerlink" title="硬链接&amp;符号链接"></a>硬链接&amp;符号链接</h1><blockquote><p>  mklink<br>  创建符号链接。</p><p>  MKLINK [[&#x2F;D] | [&#x2F;H] | [&#x2F;J]] Link Target</p><pre><code class="hljs">      /D      创建目录符号链接。默认为文件              符号链接。      /H      创建硬链接而非符号链接。      /J      创建目录联接。      Link    指定新的符号链接名称。      Target  指定新链接引用的路径              (相对或绝对)。</code></pre></blockquote><table><thead><tr><th></th><th>硬链接（Hard Link）</th><th>目录联接（Junction Point）</th><th>符号链接（Symbolic Link）</th></tr></thead><tbody><tr><td>命令</td><td><code>mklink /H Link Target</code></td><td><code>mklink /J Link Target</code></td><td><code>mklink /D Link Target</code></td></tr><tr><td>作用</td><td>为某文件创建别名，可让不同的路径对应同一个文件的数据。</td><td></td><td></td></tr><tr><td>链接到文件</td><td>✔️</td><td>❌</td><td>❌</td></tr><tr><td>链接到文件夹</td><td>❌</td><td>✔️</td><td>✔️</td></tr><tr><td>需要提升为管理员权限</td><td>需要</td><td>不需要</td><td>通常需要 <code>[坑1]</code></td></tr><tr><td>跨驱动器卷（盘符）</td><td>❌</td><td>✔️（仅本地计算机）</td><td>✔️（包括 SMB 文件或路径）</td></tr><tr><td>操作系统支持</td><td>Windows NT 3.1 开始支持 Windows 2000 开始有 API <code>CreateHardLink()</code> Windows NT 6.0 开始能使用 <code>mklink /H</code></td><td>Windows 2000+</td><td>Windows Vista+</td></tr><tr><td>可链接到不存在的目标</td><td>❌</td><td>✔️</td><td>✔️</td></tr><tr><td>可链接到相对目录</td><td>❌</td><td>❌（可以使用相对路径创建，但创建完即变绝对路径）</td><td>✔️</td></tr><tr><td>删除方法</td><td>del</td><td>rd</td><td>rd &#x2F; del</td></tr><tr><td>当链接被单独删除后</td><td>只有所有指向原始文件的硬链接和原始文件全部删除后文件数据才会被删除。</td><td>Windows Vista 之后原始文件夹不受影响；Windows 2000&#x2F;XP&#x2F;2003 会导致原始子文件夹被删除。</td><td>原始文件夹不受影响。</td></tr><tr><td>当原始文件被单独删除后</td><td>硬链接依然能正常访问到文件的数据。</td><td>目录联接失效，指向不存在的目录。</td><td>符号链接失效，指向不存在的目录</td></tr></tbody></table><p>比较 Windows 上四种不同的文件（夹）链接方式（NTFS 的硬链接、目录联接、符号链接，和大家熟知的快捷方式）</p><p><a href="https://blog.walterlv.com/post/ntfs-link-comparisons.html">https://blog.walterlv.com/post/ntfs-link-comparisons.html</a></p><p>Windows中的硬链接和软链接（hard link 和 Symbolic link）</p><p><a href="https://www.cnblogs.com/Naylor/p/7597869.html">https://www.cnblogs.com/Naylor/p/7597869.html</a></p><p>Windows下mklink使用, 硬链接, 软链接和快捷方式的区别</p><p><a href="https://blog.csdn.net/guyue35/article/details/49761347">https://blog.csdn.net/guyue35/article/details/49761347</a></p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dos">创建链接:<br>mklink /j D:\System\Desktop\Project  D:\Project<br><br><br><br>删除的命令：<br><span class="hljs-built_in">rmdir</span> 链接名称<br>例如：<span class="hljs-built_in">rmdir</span> d:\recivefiles <span class="hljs-built_in">rmdir</span> d:\develop<br>删除虚拟链接目录，并不会删除真实文件，注意，不能使用<span class="hljs-built_in">del</span>命令，<span class="hljs-built_in">del</span>命令会删除真实文件<br></code></pre></td></tr></table></figure><p>拓展 :  linux下的软链接和硬链接</p><blockquote><p>  同样，在Windows下，链接的功能也是被实现了的（虽然我们不会经常发现）。在Linux下，我们都知道链接有两种形式：硬链接和软链接。所谓硬链接，我们可以理解为硬链接持有的是文件本身（而不是路径）的引用。也就是说，当我们给一个名为a.txt的文件建立硬链接（b.txt）后，那么b.txt指向的位置就是a.txt这个文件本身，而此时，a.txt和b.txt是同级平行的，这个文本文件此时同时拥有两个文件名。当我们删除a.txt时，只是删除了a.txt这个文件名，这个文件仍然被b.txt所引用，所以我们还能够通过b.txt访问。而软链接，持有的则是原链接路径。比如a.txt位于 <del>&#x2F;Document&#x2F;a.txt ，那么为其建立软链接b.txt的内容就是”</del>&#x2F;Document&#x2F;a.txt”，此时，我们访问b.txt，其实是在按照a.txt的路径去访问a.txt。如果我们这时删除a.txt这个文件，那么b.txt也会无效，因为路径已经断掉。</p></blockquote><h1 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE"></a>NOTE</h1><h2 id="窗口主题色-活动和非活动窗口"><a href="#窗口主题色-活动和非活动窗口" class="headerlink" title="窗口主题色 活动和非活动窗口"></a>窗口主题色 活动和非活动窗口</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">regedit 编辑<br>计算机\HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\DWM<br><br><span class="hljs-comment"># 活动窗口颜色 </span><br><span class="hljs-comment"># 32位值就是 颜色的RGB 注意的是这里不知道是大小端的问题还是其他什么问题需要RGB数值转换成BGR样式</span><br>AccentColor <br><br><span class="hljs-comment"># 非活动窗口颜色 </span><br>AccentColorInactive <br></code></pre></td></tr></table></figure><h2 id="添加永久路由"><a href="#添加永久路由" class="headerlink" title="添加永久路由"></a>添加永久路由</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">route -p add <br><br>route ADD 157.0.0.0 MASK 255.0.0.0  157.55.80.1 METRIC 3 IF 2<br>       destination^      ^mask      ^gateway     metric^    ^<br>                                                   Interface^<br></code></pre></td></tr></table></figure><h2 id="各类特定文件夹"><a href="#各类特定文件夹" class="headerlink" title="各类特定文件夹"></a>各类特定文件夹</h2><p><code>win+r</code>输入对应内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">启动文件夹</span><br>shell:startup<br><span class="hljs-meta prompt_"># </span><span class="language-bash">发送到右键菜单</span><br>shell:sendto<br></code></pre></td></tr></table></figure><h2 id="修改WIFI位置"><a href="#修改WIFI位置" class="headerlink" title="修改WIFI位置"></a>修改WIFI位置</h2><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\NetworkList\Profiles<br></code></pre></td></tr></table></figure><ul><li>展开“Profiles”项，其下面的子项是都是一个网络连接，可以通过查看“ProfilesName”来分辨，双击打开“<code>Category</code>”，</li><li>打开编辑窗口后，修改“数值数据”，这里数值0代表公用网络，1代表专用网络，2代表域网络，设置完后点击确定即可。</li></ul><h2 id="填加开机启动"><a href="#填加开机启动" class="headerlink" title="填加开机启动"></a>填加开机启动</h2><ol><li>添加<code>Windows</code>开机自动执行<code>init-wsl.bat</code>脚本</li></ol><p><code>Windows</code>键+<code>R</code>，输入<code>regedit</code>打开注册列表，在地址栏输入<code>计算机\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run</code>定位到对应注册表位置，右键新建一个字符串值，键入<code>init-wsl.bat</code>脚本绝对路径即可，如下图！</p><p><img src="/2022/fc18738/regedit-add-init-wsl.png" alt="set regedit service"></p><p>重启计算机即可发现，<code>WSL</code>中的<code>Docker</code>服务已经被启动，通过<code>192.168.33.10</code>可以直接访问到<code>WSL</code>内部的网络！</p>]]></content>
    
    
    <categories>
      
      <category>more_interest</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>PC</tag>
      
      <tag>Software</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>摄影</title>
    <link href="/2022/bda63754/"/>
    <url>/2022/bda63754/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/bda63754/1e3bb3da2c76d5c2ed546428edc1cd4e_720w.jpg" alt="1e3bb3da2c76d5c2ed546428edc1cd4e_720w"></p><p><img src="/2022/bda63754/%E8%89%B2%E7%8E%AF3.png" alt="色环3"></p><h1 id="调色"><a href="#调色" class="headerlink" title="调色"></a>调色</h1><h2 id="马卡龙糖果色"><a href="#马卡龙糖果色" class="headerlink" title="马卡龙糖果色"></a>马卡龙糖果色</h2><h3 id="形式"><a href="#形式" class="headerlink" title="形式"></a>形式</h3><p>高明度、低对比、高饱和、高明度</p><ul><li><p>暖色—橙色、黄色、粉色</p></li><li><p>冷色—绿色、蓝色、青色、建议青蓝色为主色调</p></li></ul><h3 id="适合场景"><a href="#适合场景" class="headerlink" title="适合场景"></a>适合场景</h3><ul><li>建议晴天的白天、避免大光比、复杂的色彩组成、</li><li>建议有蓝色元素(天空)、橙色黄色粉色等暖色系元素、</li></ul><h2 id="青橙色调色"><a href="#青橙色调色" class="headerlink" title="青橙色调色"></a>青橙色调色</h2><h3 id="形式-1"><a href="#形式-1" class="headerlink" title="形式"></a>形式</h3><p>青色橙色作为主色调</p><p>拉高白色、降低黑色增强对比</p><ul><li>降低高光、提升阴影恢复细节</li><li>拉高白色、降低黑色增强对比</li></ul><h3 id="适合场景-1"><a href="#适合场景-1" class="headerlink" title="适合场景"></a>适合场景</h3><p>天空、大海等蓝色元素 和 肤色、灯光等的橙色元素。</p><p><img src="/2022/bda63754/%E9%9D%92%E6%A9%99%E6%A1%88%E4%BE%8B-1.jpg" alt="青橙案例-1"></p><h2 id="日系蓝黄色调"><a href="#日系蓝黄色调" class="headerlink" title="日系蓝黄色调"></a>日系蓝黄色调</h2><p>画面本身有蓝、黄橙绿元素、</p><p>白天的街景、建筑最佳</p><ul><li>降低对比度（降低高光和白色、提升阴影），操作后照片会偏灰，降低黑色压实影调</li><li>曲线压缩最亮部分（右顶点向下偏），使得白色更加柔和</li><li>主色调为蓝黄色及相邻色（），基本不含其他色</li></ul><p><img src="/2022/bda63754/%E6%97%A5%E7%B3%BB%E8%93%9D%E9%BB%84%E8%89%B2%E8%B0%83-Frank.jpg" alt="日系蓝黄色调-Frank"></p><h2 id="黑金色调"><a href="#黑金色调" class="headerlink" title="黑金色调"></a>黑金色调</h2>]]></content>
    
    
    <categories>
      
      <category>more_interest</category>
      
    </categories>
    
    
    <tags>
      
      <tag>摄影</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Synology 群晖</title>
    <link href="/2022/ee60585b/"/>
    <url>/2022/ee60585b/</url>
    
    <content type="html"><![CDATA[<h1 id="群晖"><a href="#群晖" class="headerlink" title="群晖"></a>群晖</h1><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="https://www.openos.org/threads/dsm-6-2-3-2020-12-27.29/">https://www.openos.org/threads/dsm-6-2-3-2020-12-27.29/</a></p><h2 id="SSH访问启动盘"><a href="#SSH访问启动盘" class="headerlink" title="SSH访问启动盘"></a>SSH访问启动盘</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir /mnt/boot<br>cd /dev<br>sudo mount -t vfat synoboot1 /mnt/boot<br>cd /mnt/boot<br></code></pre></td></tr></table></figure><h2 id="半洗白-SN"><a href="#半洗白-SN" class="headerlink" title="半洗白 SN"></a>半洗白 SN</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li>全黑版本的群晖VideoStation不能离线转码，PhotoStation和Moments的略缩图和人像识别也会有问题</li><li>半洗白就是转码和缩略图一类的可用</li><li>全白就是多了QC，这个就没必要了(白嫖个系统就好了,就不要去嫖别人的服务器了)</li><li>主要通过Docker+DDSM来获得SN</li><li>群辉新版的Docker 18.09.0-0506已经关闭了DDSM安装，可下载17.05.0版本的Docker</li></ul><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li><p>下载17.05.0的Docker，可以在<a href="https://archive.synology.com/download/Package/Docker/17.05.0-0401">群晖官网下载</a>。</p></li><li><p>下载DDSM，可在<a href="https://archive.synology.com/download/Os/DSM/6.2.3-25426">群晖官网下载</a>，注意要对应自己DSM的版本。</p></li><li><p>首先在套件中心点手动安装把第一步下载的17.05.0的Docker放进去。</p></li><li><p>打开Docker-左侧DSM-点击新增-下一步-下一步-下一步-手动上传，把刚刚下载的DDSM放进去，等待他安装完成。</p></li><li><p>安装完成后，进入DDSM群晖的控制面板。</p></li><li><p>在信息栏可看到SN和MAC，复制DDSM的SN和MAC保存下来。</p></li><li><p>SSH接入DSM群晖，挂载启动盘BOOT，修改<code>/grub/grub.cfg</code>文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">挂载启动盘BOOT</span><br>mkdir /mnt/boot<br>cd /dev<br>sudo mount -t vfat synoboot1 /mnt/boot<br>cd /mnt/boot<br></code></pre></td></tr></table></figure></li><li><p>重启。</p></li></ol><p><img src="/2022/ee60585b/image-20211018141146176.png" alt="image-20211018141146176"></p><h2 id="半洗白后moments人脸识别不出来"><a href="#半洗白后moments人脸识别不出来" class="headerlink" title="半洗白后moments人脸识别不出来"></a>半洗白后moments人脸识别不出来</h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>当群晖系统升级到6.22-24922以后，Moments也升级到了1.3.X，新的bug也随着版本升级来了”人物或者主题经常识别不出来“，经查日志后发现是Moments1.3插件有bug引导的，有问题的插件为“<strong>libsynophoto-plugin-detection.so</strong>”，经测试该插件在Moments1.2版本中是正常的。</p><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><ol><li><p>群晖上启用SSH，并将moments停用</p></li><li><p>MobaXterm连接群晖，启用root登录</p><ol><li><code>sudo -i</code></li><li><code>vi /etc/ssh/sshd_config</code></li><li>找到#PermitRootLogin prohibit password，这一行最后，按回车，然后输入 <code>PermitRootLogin yes</code></li><li>修改root密码<code>synouser --setpw root 你的密码</code></li><li>重启</li></ol></li><li><p>用root重新登录，将libsynophoto-plugin-detection.so插件替换掉</p><ol><li>找到目录：&#x2F;var&#x2F;packages&#x2F;SynologyMoments&#x2F;target&#x2F;usr&#x2F;lib&#x2F;libsynophoto-plugin-detection.so</li><li>将原文件先备份一下</li><li>用现有新文件将他替换掉</li><li>新文件权限修改一下</li></ol></li><li><p>将moments启用，问题解决</p></li></ol><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.zhihu.com/question/428454266/answer/1681110862?ivk_sa=1024320u">https://www.zhihu.com/question/428454266/answer/1681110862?ivk_sa=1024320u</a></p><p><a href="https://blog.csdn.net/weixin_36059505/article/details/112766321">https://blog.csdn.net/weixin_36059505/article/details/112766321</a></p><h2 id="群晖安装-ipkg-包管理"><a href="#群晖安装-ipkg-包管理" class="headerlink" title="群晖安装 ipkg 包管理"></a>群晖安装 ipkg 包管理</h2><p><strong>仅适用于x86平台，ARM平台需要修改链接</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">以 root 用户执行</span><br>sudo -i<br>cd /volume1/@tmp<br>wget http://ipkg.nslu2-linux.org/feeds/optware/syno-i686/cross/unstable/syno-i686-bootstrap_1.2-7_i686.xsh<br>chmod +x syno-i686-bootstrap_1.2-7_i686.xsh<br>sh syno-i686-bootstrap_1.2-7_i686.xsh<br>rm syno-i686-bootstrap_1.2-7_i686.xsh<br>ipkg update<br>reboot<br></code></pre></td></tr></table></figure><h2 id="CPU频率调整"><a href="#CPU频率调整" class="headerlink" title="CPU频率调整"></a>CPU频率调整</h2><ol><li><p>Linux的&#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpu*&#x2F;cpufreq目录存储着第*个CPU的一些参数，例如最小最大平均频率，bios限制频率。</p></li><li><p>使用如下命令可以查看支持的工作模式：</p> <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/sys/</span>devices<span class="hljs-regexp">/system/</span>cpu<span class="hljs-regexp">/cpu0/</span>cpufreq/scaling_available_governors<br></code></pre></td></tr></table></figure><table><thead><tr><th>模式</th><th>介绍</th></tr></thead><tbody><tr><td>powersave</td><td>只会保持最低频率，节能省电</td></tr><tr><td>userspace</td><td>自定义频率</td></tr><tr><td>ondemand</td><td>一有cpu计算量的任务，就会立即达到最大频率运行，等执行完毕就立即回到最低频率</td></tr><tr><td>conservative</td><td>根据负载状态自动在频率上下限调整</td></tr><tr><td>performance</td><td>保持以最大频率运行</td></tr></tbody></table></li><li><p>通过下面指令可以看第*个CPU核心的工作状态，</p> <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/sys/</span>devices<span class="hljs-regexp">/system/</span>cpu<span class="hljs-regexp">/cpu*/</span>cpufreq/scaling_governor<br></code></pre></td></tr></table></figure></li></ol><p>安装cpufreq-info：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">ipkg update<br>ipkg <span class="hljs-keyword">install</span> cpufrequtils<br></code></pre></td></tr></table></figure><p>查看CPU频率和模式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cpufreq-info<br></code></pre></td></tr></table></figure><p>修改模式：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">cpufreq-<span class="hljs-built_in">set</span> -c * -g <span class="hljs-built_in">MODE</span><br></code></pre></td></tr></table></figure><p>例如将四个核心全部ondemand：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gams">cpufreq-<span class="hljs-keyword">set</span> -c <span class="hljs-comment">0 -g ondemand</span><br>cpufreq-<span class="hljs-keyword">set</span> <span class="hljs-comment">-c 1 -g ondemand</span><br>cpufreq-<span class="hljs-keyword">set</span> <span class="hljs-comment">-c 2 -g ondemand</span><br>cpufreq-<span class="hljs-keyword">set</span> <span class="hljs-comment">-c 3 -g ondemand</span><br></code></pre></td></tr></table></figure><p>为了下次开机也自动生效，可以手动添加启动脚本。将其存成.sh，开启启动即可</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle">#<span class="hljs-regexp">/bin/</span>bash<br><span class="hljs-regexp">/opt/</span>bin/cpufreq-set -c <span class="hljs-number">0</span> -g ondemand<br><span class="hljs-regexp">/opt/</span>bin/cpufreq-set -c <span class="hljs-number">1</span> -g ondemand<br><span class="hljs-regexp">/opt/</span>bin/cpufreq-set -c <span class="hljs-number">2</span> -g ondemand<br><span class="hljs-regexp">/opt/</span>bin/cpufreq-set -c <span class="hljs-number">3</span> -g ondemand<br></code></pre></td></tr></table></figure><h2 id="lm-sensors-风扇控制"><a href="#lm-sensors-风扇控制" class="headerlink" title="lm-sensors 风扇控制"></a>lm-sensors 风扇控制</h2><p>执行安装命令</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">ipkg <span class="hljs-keyword">install</span> lm-sensors<br></code></pre></td></tr></table></figure><p>查看温度</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sensors</span><br></code></pre></td></tr></table></figure><p>配置风扇控制，这块主要的目的只检测风扇在那一路，一般主板会涉及到多个风扇，但不一定都会安装，所以通过pwmconfig来检测与测试风扇的转速控制。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo pwmconfig</span><br></code></pre></td></tr></table></figure><p>使用fancontrol自动控制风扇转速，他的原理就是定时执行脚本，监控CPU温度、根据不同的温度区间控制PWM值，从而改变风扇的转速。<br>当转速降低了后，噪音自然就解决了。</p><p>fancontrol会依赖pwmconfig命令生成的配置文件。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/etc/</span>fancontrol<br><br>-----------配置内容如下--------------<br><span class="hljs-comment"># Configuration file generated by pwmconfig, changes will be lost</span><br>INTERVAL=<span class="hljs-number">10</span><br>DEVPATH=hwmon0=devices<span class="hljs-regexp">/platform/</span>coretemp.<span class="hljs-number">0</span> hwmon1=devices<span class="hljs-regexp">/platform/i</span>t87.<span class="hljs-number">2624</span><br>DEVNAME=hwmon0=coretemp hwmon1=it8772<br>FCTEMPS=hwmon1<span class="hljs-regexp">/device/</span>pwm2=hwmon0<span class="hljs-regexp">/device/</span>temp3_input<br>FCFANS= hwmon1<span class="hljs-regexp">/device/</span>pwm2=hwmon1<span class="hljs-regexp">/device/</span>fan2_input<br>MINTEMP=hwmon1<span class="hljs-regexp">/device/</span>pwm2=<span class="hljs-number">20</span><br>MAXTEMP=hwmon1<span class="hljs-regexp">/device/</span>pwm2=<span class="hljs-number">60</span><br>MINSTART=hwmon1<span class="hljs-regexp">/device/</span>pwm2=<span class="hljs-number">150</span><br>MINSTOP=hwmon1<span class="hljs-regexp">/device/</span>pwm2=<span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p>默认生成的配置基本能够满足需求，经过测试风扇在2000转左右噪音相对能够接受。</p><h2 id="VideoStation"><a href="#VideoStation" class="headerlink" title="VideoStation"></a>VideoStation</h2><p>参考：</p><p><a href="https://zhuanlan.zhihu.com/p/357332211">关于群晖NAS video station TMDB连接测试失败及搜刮结果下载失败的解决方案</a></p><p><a href="https://zhuanlan.zhihu.com/p/152351243">（群晖）关于Video Station内电影及电视剧封面简介为空白的处理方法</a></p><h3 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h3><ul><li><p>TMDB的图片服务器被屏蔽需要修改hosts 加上 api.themoviedb.org 的ip</p></li><li><p>修改hosts后即可测试，已经连通</p></li><li><p>搜刮信息会出现下载失败，主要是下载图片的url需要切换一下</p><p>  编辑 util_themoviedb.php 文件</p>  <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">cd /var/packages/VideoStation/target/plugins<br>vi util_themoviedb.php<br></code></pre></td></tr></table></figure>  <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text"># 找到下面的语句<br>define(&#x27;API_URL&#x27;, &#x27;https://api.themoviedb.org/3/&#x27;);<br>define(&#x27;BANNER_URL&#x27;, &#x27;https://image.tmdb.org/t/p/w500&#x27;);<br>define(&#x27;BACKDROUP_URL&#x27;, &#x27;https://image.tmdb.org/t/p/original&#x27;);<br><br># 我们只需要把改为<br>image.tmdb.org<br># 改为<br>www.themoviedb.org<br></code></pre></td></tr></table></figure></li></ul><h2 id="Gogs"><a href="#Gogs" class="headerlink" title="Gogs"></a>Gogs</h2><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/cfan927/article/details/100862989">【工具】群晖利用docker安装Gogs代码管理平台</a></p><h3 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤"></a>步骤</h3><ol><li><p>打开“Docker”-&gt;”注册表”，搜索Gogs并“右键”-&gt;“下载此映像”</p><p><img src="/2022/ee60585b/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NmYW45Mjc=,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p></li><li><p>在”映像“页面中安装Gogs容器后，切换到”容器“页面，然后双击打开Gogs详情页</p><ol><li>设定容器的本地端口</li><li>设定桌面快捷方式</li></ol></li><li><p>Gogs配置</p><ol><li><p>Windows中用ssh登录群晖服务器，cd到mariaDB目录下：</p><p><code>cd /volume1/@appstore/MariaDB10/usr/local/mariadb10/bin/</code></p></li><li><p>输入命令 <code>./mysql -u root -p</code>，然后输入密码，连接数据库</p></li><li><p>输入命令 <code>use mysql</code>切换到mysql数据库</p></li><li><p>创建数据库gogs<br> <code>CREATE DATABASE IF NOT EXISTS gogs;</code></p></li><li><p>输入下面的命令获取数据库远程访问权限 ：</p><p><code>GRANT ALL PRIVILEGES ON gogs.* TO &#39;user&#39;@&#39;%&#39; IDENTIFIED BY &#39;password&#39; WITH GRANT OPTION;</code><br>其中user为用户名<br>password为用户密码</p></li><li><p>然后用<code>show databases;</code>命令查看一下结果</p></li></ol></li><li><p>gogs:port 设定相关参数即可</p></li><li><p>着重需要说明的是：</p></li><li><p>tips</p><ol><li>删除数据库  <code>DROP DATABASE gogs;</code></li></ol></li></ol><h3 id="Note-1"><a href="#Note-1" class="headerlink" title="Note"></a>Note</h3><ul><li>gogs 的配置保存在<code>/data/gogs/conf/app.ini</code> 参考下图</li></ul><p><img src="/2022/ee60585b/image-20211103161058734.png" alt="image-20211103161058734"></p><ul><li><strong>注意</strong> MariaDB的port默认是不开的，需要去套件里面打开。</li></ul><blockquote><ol><li><strong>Domain</strong> 填写Docker宿主机的物理IP地址，或者域名地址,注意这里是不带 http的 如： 192.168.137.140 或 git.mydomain.com</li><li><strong>SSH port</strong> 假如Docker映射的端口是 10022:22 那么这里就填写宿主机开放的端口 10022</li><li><strong>HTTP port</strong> 假如Docker映射的端口是 10080:3000 这里要填容器内的监听端口 3000</li><li><strong>Application URL</strong> 这里要填写的格式为 http(s)?&#x2F; + Domain + HTTP port ，比如：<a href="http://git.mydomain.com/10080">http://git.mydomain.com/10080</a> 。还需要注意的一点是，如果你用了nginx来映射宿主机的 10080 端口，这里要去掉后面的端口，即 <a href="http://git.mydomain.com/%EF%BC%8C%E8%AF%B4%E7%99%BD%E4%BA%86%E5%B0%B1%E6%98%AF%E4%BD%A0%E5%9C%A8%E5%A4%96%E9%83%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8A%E8%AE%BF%E9%97%AE%E7%9A%84%E5%9C%B0%E5%9D%80%E3%80%82">http://git.mydomain.com/，说白了就是你在外部浏览器上访问的地址。</a></li></ol></blockquote><ul><li><strong>注意</strong>非标准port的ssh需要注意clone地址是否正确</li></ul><h4 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h4><p><a href="https://github.com/gogs/gogs/discussions/6876">https://github.com/gogs/gogs/discussions/6876</a></p><ul><li><p><strong>数据备份</strong></p></li><li><p>因为容器内的 <code>/data</code> 目录是直接挂载到宿主机的，我们把容器内备份目录设置为 <code>/data</code> ， 方便宿主机将备份文件同步到远程备份服务器。</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker container exec gogs su - git -s /bin/ash \<br>-c &quot;/app/gogs/gogs backup \<br>--config=/data/gogs/conf/app.ini \<br>--target=/gogs&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">注意挂载目录的权限</span><br></code></pre></td></tr></table></figure><ul><li><p><strong>数据恢复</strong></p></li><li><p>用docker完成gogs部署之后，进入容器，执行下面命令</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker container exec -it gogs su - git -s /bin/ash \<br>-c &quot;/app/gogs/gogs restore \<br>--config=/data/gogs/conf/app.ini \<br>--tempdir=/data \<br>--from=/data/gogs-backup-20211230091744.zip&quot;<br><br></code></pre></td></tr></table></figure><ul><li><p><strong>注意：</strong></p></li><li><p>备份和恢复时，使用的 gogs 版本必须是一致的</p></li><li><p>备份和恢复时，使用的 mysql 版本必须是一致的</p></li></ul><h4 id="自述文档"><a href="#自述文档" class="headerlink" title="自述文档"></a>自述文档</h4><p>Create a plain text file then move to directory <code>custom/conf/readme/README</code> and <strong>restart Gogs.</strong></p><ul><li><code>&#123;Name&#125;</code>: Repository name</li><li><code>&#123;Description&#125;</code>: Repository description</li><li><code>&#123;CloneURL.SSH&#125;</code>: Repository SSH clone address</li><li><code>&#123;CloneURL.HTTPS&#125;</code>: Repository HTTP&#x2F;HTTPS clone address</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">&#123;Name&#125;</span><br>&#123;Name&#125; Repository<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># Tip</span></span><br>You can get the development version of this repo via<br>**git clone &#123;CloneURL.SSH&#125;**<br>or<br>**git clone &#123;CloneURL.HTTPS&#125;**<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># Bref</span></span><br>&#123;Description&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># Details</span></span><br><br></code></pre></td></tr></table></figure><h2 id="zerotier"><a href="#zerotier" class="headerlink" title="zerotier"></a>zerotier</h2><table><thead><tr><th>img name</th><th>last version</th><th>notes</th></tr></thead><tbody><tr><td>henrist-zerotier-one1</td><td>1.6.6</td><td>没有自动配置路由</td></tr><tr><td>bltavares zerotier</td><td>1.6.6</td><td>网络不通</td></tr><tr><td>zyclonite&#x2F;zerotier&#x2F;</td><td>1.8.4</td><td>没有自动配置路由 配置路由后正常</td></tr><tr><td>spikhalskiy-zerotier1</td><td>1.8.2</td><td>运行会报错<code>zerotier-cli: /usr/lib/libstdc++.so.6: no version information available (required by zerotier-cli)</code>, 没有自动配置路由 配置路由后正常</td></tr><tr><td>zerotier-zerotier-synology</td><td>1.8.4</td><td>没有自动配置路由 配置路由后正常</td></tr></tbody></table><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs livescript">docker run <span class="hljs-string">\</span><br>  -d <span class="hljs-string">\</span><br>  --restart always <span class="hljs-string">\</span><br>  --name zerotier-one <span class="hljs-string">\</span><br>  --device /dev/net/tun <span class="hljs-string">\</span><br>  --net host <span class="hljs-string">\</span><br>  --cap-add NET_ADMIN <span class="hljs-string">\</span><br>  --cap-add SYS_ADMIN <span class="hljs-string">\</span><br>  -v /<span class="hljs-keyword">var</span>/lib/zerotier-one:/<span class="hljs-keyword">var</span>/lib/zerotier-one <span class="hljs-string">\</span><br>  zerotier/zerotier-synology<br></code></pre></td></tr></table></figure><h2 id="第三方套件"><a href="#第三方套件" class="headerlink" title="第三方套件"></a>第三方套件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">矿神</span><br>https://spk.imnks.com/<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>more_interest</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Synology</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RDPWrap</title>
    <link href="/2022/a8b000ae/"/>
    <url>/2022/a8b000ae/</url>
    
    <content type="html"><![CDATA[<h1 id="RDPWrap"><a href="#RDPWrap" class="headerlink" title="RDPWrap"></a>RDPWrap</h1><ul><li>RDP程序源Github</li></ul><p><a href="https://github.com/stascorp/rdpwrap">https://github.com/stascorp/rdpwrap</a></p><ul><li>新版RDP配置文件</li></ul><p><a href="https://raw.githubusercontent.com/saurav-biswas/rdpwrap-1/master/res/rdpwrap.ini">https://raw.githubusercontent.com/saurav-biswas/rdpwrap-1/master/res/rdpwrap.ini</a></p><p><a href="https://github.com/affinityv/INI-RDPWRAP">https://github.com/affinityv/INI-RDPWRAP</a></p><p>win11可用 <a href="https://raw.githubusercontent.com/sebaxakerhtc/rdpwrap.ini/master/rdpwrap.ini">https://raw.githubusercontent.com/sebaxakerhtc/rdpwrap.ini/master/rdpwrap.ini</a></p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ol><li><p><code>install.bat</code>安装</p></li><li><p><code>RDPConf.exe</code>检查是否成功开启</p><p><img src="/2022/a8b000ae/image-20211209105711309.png" alt="image-20211209105711309"></p></li><li><p>新的操作系统一般来说第三项是红色的,如果是绿色的就表示正常可以使用了</p></li><li><p>如果异常按以下进行操作</p><ol><li>管理员打开<code>PowerShell</code>运行<code>get-service termservice|stop-service -force</code>停掉RDP进程</li><li>从<a href="https://raw.githubusercontent.com/saurav-biswas/rdpwrap-1/master/res/rdpwrap.ini">RDP配置文件</a>下载新的配置文件</li><li>将下载的配置文件复制到<code>C:\Program Files\RDP Wrapper\rdpwrap.ini</code>替换原文件</li><li>管理员打开<code>PowerShell</code>运行<code>get-service termservice|start-service</code>重新运行RDP</li><li><code>RDPConf.exe</code>检查已经成功开启</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>RDPWrap</tag>
      
      <tag>RDP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpaceDesk手机用作电脑屏幕</title>
    <link href="/2022/471570a6/"/>
    <url>/2022/471570a6/</url>
    
    <content type="html"><![CDATA[<h1 id="SpaceDesk"><a href="#SpaceDesk" class="headerlink" title="SpaceDesk"></a>SpaceDesk</h1><p>在windows主机上虚拟出一块屏幕, 通过网络传输到其他带屏设备上.</p><ul><li>投屏到手机支持触摸</li></ul><h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p><a href="https://www.spacedesk.net/">https://www.spacedesk.net/</a></p><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><h2 id="软件没有验证功能-不安全"><a href="#软件没有验证功能-不安全" class="headerlink" title="软件没有验证功能(不安全)"></a>软件没有验证功能(不安全)</h2><p>有一次在公司用手机客户端, 直接连接上了公司其他同事的电脑屏幕.</p><p>公司的网络ip是dhcp的无法固定, 而且网络质量并不好, 所以我选择电脑开热点 手机连电脑热点.</p><p>防火墙加规则,只允许热点网段的IP入站.</p><p><img src="/2022/471570a6/image-20220811195054454.png" alt="image-20220811195054454"></p><p><img src="/2022/471570a6/image-20220811194925793.png" alt="image-20220811194925793"></p>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>SpaceDesk</tag>
      
      <tag>投屏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Wordpress</title>
    <link href="/2022/aa858de8/"/>
    <url>/2022/aa858de8/</url>
    
    <content type="html"><![CDATA[<h1 id="Wordpress"><a href="#Wordpress" class="headerlink" title="Wordpress"></a>Wordpress</h1><h2 id="LNMP安装"><a href="#LNMP安装" class="headerlink" title="LNMP安装"></a>LNMP安装</h2><p><a href="https://lnmp.org/">https://lnmp.org/</a></p><p><strong>LNMP一键安装包是什么?</strong></p><p>LNMP一键安装包是一个用Linux Shell编写的可以为CentOS&#x2F;RHEL&#x2F;Fedora&#x2F;Aliyun&#x2F;Amazon、Debian&#x2F;Ubuntu&#x2F;Raspbian&#x2F;Deepin&#x2F;Mint Linux VPS或独立主机安装LNMP(Nginx&#x2F;MySQL&#x2F;PHP)、LNMPA(Nginx&#x2F;MySQL&#x2F;PHP&#x2F;Apache)、LAMP(Apache&#x2F;MySQL&#x2F;PHP)生产环境的Shell程序。</p><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 登录</span><br>mysql -u root -p<br><br><span class="hljs-comment"># 如果报找不到命令 cd到对应目录去登录</span><br><span class="hljs-built_in">cd</span> /usr/local/mariadb10/bin/<br>./mysql -u root -p<br><br><span class="hljs-comment"># 切换到mysql数据库</span><br>use mysql<br><br><span class="hljs-comment"># 执行以下命令，创建 MariaDB 数据库。例如 “wordpress”。</span><br>CREATE DATABASE IF NOT EXISTS wordpress;<br><br><span class="hljs-comment"># 执行以下命令，创建一个新用户。例如 “user”，登录密码为 123456。</span><br>CREATE USER <span class="hljs-string">&#x27;user&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> IDENTIFIED BY <span class="hljs-string">&#x27;123456&#x27;</span>;<br><br><span class="hljs-comment"># 执行以下命令，赋予用户对 “wordpress” 数据库的全部权限。</span><br>GRANT ALL PRIVILEGES ON wordpress.* TO <span class="hljs-string">&#x27;user&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> IDENTIFIED BY <span class="hljs-string">&#x27;123456&#x27;</span>;<br><br><span class="hljs-comment"># 执行以下命令，设置 root 帐户密码</span><br>ALTER USER root@localhost IDENTIFIED VIA mysql_native_password USING PASSWORD(<span class="hljs-string">&#x27;输入您的密码&#x27;</span>);<br><br><span class="hljs-comment"># 执行以下命令，使所有配置生效。</span><br>FLUSH PRIVILEGES;<br><br><span class="hljs-comment"># 退出</span><br>\q<br></code></pre></td></tr></table></figure><h2 id="Wordpress-1"><a href="#Wordpress-1" class="headerlink" title="Wordpress"></a>Wordpress</h2><h4 id="修改-WordPress-配置文件"><a href="#修改-WordPress-配置文件" class="headerlink" title="修改 WordPress 配置文件"></a>修改 WordPress 配置文件</h4><ol><li><p>依次执行以下命令，进入 WordPress 安装目录，将<code>wp-config-sample.php</code>文件复制到<code>wp-config.php</code>文件中，并将原先的示例配置文件保留作为备份。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd <span class="hljs-regexp">/home/</span>wwwroot/wordpress<br></code></pre></td></tr></table></figure><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">cp</span> <span class="hljs-keyword">wp</span>-config-sample.php <span class="hljs-keyword">wp</span>-config.php<br></code></pre></td></tr></table></figure></li><li><p>执行以下命令，打开并编辑新创建的配置文件。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">vim</span> <span class="hljs-keyword">wp</span>-config.php<br></code></pre></td></tr></table></figure></li><li><p>按 <strong>i</strong> 切换至编辑模式，找到文件中 MySQL 的部分，并将相关配置信息修改为 <a href="https://cloud.tencent.com/document/product/213/8044#database">配置 WordPress 数据库</a> 中的内容。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-comment">// ** MySQL settings - You can get this info from your web host ** //</span><br><span class="hljs-comment">/** The name of the database for WordPress */</span><br><span class="hljs-class"><span class="hljs-keyword">define</span></span>(<span class="hljs-string">&#x27;DB_NAME&#x27;</span>, <span class="hljs-string">&#x27;wordpress&#x27;</span>);<br>    <br><span class="hljs-comment">/** MySQL database username */</span><br><span class="hljs-class"><span class="hljs-keyword">define</span></span>(<span class="hljs-string">&#x27;DB_USER&#x27;</span>, <span class="hljs-string">&#x27;user&#x27;</span>);<br>    <br><span class="hljs-comment">/** MySQL database password */</span><br><span class="hljs-class"><span class="hljs-keyword">define</span></span>(<span class="hljs-string">&#x27;DB_PASSWORD&#x27;</span>, <span class="hljs-string">&#x27;123456&#x27;</span>);<br>    <br><span class="hljs-comment">/** MySQL hostname */</span><br><span class="hljs-class"><span class="hljs-keyword">define</span></span>(<span class="hljs-string">&#x27;DB_HOST&#x27;</span>, <span class="hljs-string">&#x27;localhost&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>修改完成后，按 <strong>Esc</strong>，输入 <strong>:wq</strong>，保存文件返回。</p></li></ol><h3 id="开启HTTPS支持"><a href="#开启HTTPS支持" class="headerlink" title="开启HTTPS支持"></a>开启HTTPS支持</h3><h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><h2 id="获取域名"><a href="#获取域名" class="headerlink" title="获取域名"></a>获取域名</h2><p>这里有一个免费的域名, 先凑合用着吧</p><p><a href="https://www.freenom.com/">https://www.freenom.com/</a></p><blockquote><p>  freenom 注册方法</p><p>  <a href="https://zhuanlan.zhihu.com/p/115535965">https://zhuanlan.zhihu.com/p/115535965</a></p><p>  Freenom常见问题解决方法</p><p>  <a href="http://www.360doc.com/content/21/0124/00/30583588_958609144.shtml">http://www.360doc.com/content/21/0124/00/30583588_958609144.shtml</a></p></blockquote><ul><li><p>注册的时候搜索要加上后缀不然会显示  不可用</p></li><li><p>checkout 到购物车改成 12月 free</p></li><li><p>谷歌邮箱直接登录 登录后要更改自己的个人信息里面的地址(改成ip所在地) 不然无法成功注册</p></li><li><p>菜单栏 servers -&gt; my domains 就可以看到地址了</p></li><li><p>最后再修改一下NS服务器</p><ul><li><p>Manage Domain -&gt; Management Tools -&gt; nameserver -&gt; Use custom nameservers (enter below)</p></li><li><p>这里填写cloudflare 或者 dnspod 给出来的 Nameservers 就好了</p></li><li><p>类似于</p></li><li><table><thead><tr><th align="left">Type</th><th align="left">Value</th></tr></thead><tbody><tr><td align="left">NS</td><td align="left">katja.ns.cloudflare.com</td></tr><tr><td align="left">NS</td><td align="left">kirk.ns.cloudflare.com</td></tr></tbody></table></li></ul></li></ul><h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><p>域名的<a href="https://www.vpsgo.com/tag/ns%E8%AE%B0%E5%BD%95">NS记录</a>（<a href="https://www.vpsgo.com/tag/name-server">Name Server</a>）是指处理域名解析的服务器，说白点就是你的域名由谁家来解析。一般购买了域名后，默认的NS记录就是指向域名提供商的（例如NameSilo的默认就由它自己解析）。你可以修改域名的NS记录，让它由不同的解析服务商来解析，例如可以指向<a href="https://www.vpsgo.com/tag/cloudflare">Cloudflare</a>或者<a href="https://www.vpsgo.com/tag/dnspod">DNSPod</a>。</p><p>之后DNS（Domain Name System），常用的<a href="https://www.vpsgo.com/tag/dns%E8%AE%B0%E5%BD%95">DNS记录</a>包括域名解析中A记录、CNAME、MX记录。<a href="https://www.vpsgo.com/tag/%E5%9F%9F%E5%90%8Da%E8%AE%B0%E5%BD%95">域名A记录</a>又称为IP指向，就是说你这个域名代表什么IP；域名CNAME是指别名指向，就是说指向另一个域名，例如可以设置test.vpsgo.com指向<a href="http://www.vpsgo.com;域名的mx记录就是邮件交换记录,是做邮件服务器需要设置的.本文主要介绍域名a记录解析./">www.vpsgo.com；域名的MX记录就是邮件交换记录，是做邮件服务器需要设置的。本文主要介绍域名A记录解析。</a></p><blockquote><p>  cloudflare 解析</p><p>  <a href="https://zhuanlan.zhihu.com/p/56423186">https://zhuanlan.zhihu.com/p/56423186</a></p><p>  <a href="https://www.vpsgo.com/domain-ns-cloudflare-dnspod.html#NS">https://www.vpsgo.com/domain-ns-cloudflare-dnspod.html#NS</a></p></blockquote><h1 id="HTTPS-SSL-x2F-TLS"><a href="#HTTPS-SSL-x2F-TLS" class="headerlink" title="HTTPS SSL&#x2F;TLS"></a>HTTPS SSL&#x2F;TLS</h1><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><h3 id="acme-sh"><a href="#acme-sh" class="headerlink" title="acme.sh"></a>acme.sh</h3><p><a href="https://ruby-china.org/topics/31983">https://ruby-china.org/topics/31983</a></p><p><a href="https://ruby-china.org/topics/28471">https://ruby-china.org/topics/28471</a></p><p><a href="https://ruby-china.org/topics/25543">https://ruby-china.org/topics/25543</a></p><p><a href="https://ruby-china.org/topics/31942">https://ruby-china.org/topics/31942</a></p><h3 id="caddy"><a href="#caddy" class="headerlink" title="caddy"></a>caddy</h3><p><a href="https://caddyserver.com/docs/quick-starts/https">https://caddyserver.com/docs/quick-starts/https</a></p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装 acme.sh</span><br>curl https://get.acme.sh | sh<br><br><span class="hljs-comment"># 然后重新载入一下 .bashrc</span><br><span class="hljs-built_in">source</span> ~/.bashrc <br><br><span class="hljs-comment"># 至此acme安装完成</span><br>acme.sh<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 注册账号</span><br>sudo ~/.acme.sh/acme.sh --register-account -m jackliuworkemail@gmail.com  --server zerossl<br><br><span class="hljs-comment"># 为lager.cf创建密钥</span><br><span class="hljs-comment"># -k 表示密钥长度，后面的值可以是 ec-256 、ec-384、2048、3072、4096、8192，带有 ec 表示生成的是 ECC 证书，没有则是 RSA 证书。在安全性上 256 位的 ECC 证书等同于 3072 位的 RSA 证书。</span><br>sudo ~/.acme.sh/acme.sh --issue -d lager.cf --standalone -k ec-256<br><br><span class="hljs-comment"># 由于 Let&#x27;s Encrypt 的证书有效期只有 3 个月，因此需要 90 天至少要更新一次证书，acme.sh 脚本会每 60 天自动更新证书。也可以手动更新。</span><br><span class="hljs-comment"># 查看计划任务</span><br> crontab -l<br><span class="hljs-comment"># 手动更新 ECC 证书，执行：</span><br>sudo ~/.acme.sh/acme.sh --renew -d lager.cf --force --ecc<br><br><span class="hljs-comment"># 请注意：reloadcmd非常重要。证书可以自动续订，但是，如果没有正确的“reloadcmd”，证书可能无法刷新到您的服务器（如nginx或apache），那么您的网站将无法在60天内显示续订证书。</span><br><span class="hljs-comment"># 注意：无论什么情况，密钥(即上面的lager.cf.key)都不能泄漏，如果你不幸泄漏了密钥，可以使用 acme.sh 将原证书吊销，再生成新的证书，吊销方法请自行参考 acme.sh 的手册</span><br>acme.sh --installcert -d lager.cf \<br>--keypath       /usr/local/nginx/ssl/lager.cf.key \<br>--fullchainpath /usr/local/nginx/ssl/lager.cf.cer \<br>--reloadcmd     <span class="hljs-string">&quot;sudo service nginx force-reload&quot;</span>  --force --ecc<br><br><span class="hljs-comment"># 生成 dhparam.pem 文件</span><br>openssl dhparam -out /usr/local/nginx/ssl/lager.cf.pem 2048<br><br><br><span class="hljs-comment"># 配置nginx 启用 https</span><br>vim /usr/local/nginx/conf/nginx.conf<br><br><span class="hljs-comment"># 检查配置</span><br>sudo service nginx configtest<br><span class="hljs-comment"># 重启服务</span><br>sudo service nginx restart<br><br><br><span class="hljs-comment">#验证 SSL</span><br><span class="hljs-comment">#访问 ssllabs.com 输入你的域名，检查 SSL 的配置是否都正常：</span><br>https://ssllabs.com/ssltest/analyze.html?d=ruby-china.org<br></code></pre></td></tr></table></figure><h3 id="一些注意事项"><a href="#一些注意事项" class="headerlink" title="一些注意事项"></a>一些注意事项</h3><ul><li><code>ssl_dhparam</code> 未配置，将导致 ssllabs.com 的评分降到 B，并给 <code>This server supports weak Diffie-Hellman (DH) key exchange parameters. Grade capped to B.</code> 的警告。</li><li><code>ssl_prefer_server_ciphers on</code> 也是一个必要的配置，否则会 A+ 变成 A-;</li><li>如果你需要兼容老系统或老浏览器的话，你需要配置 <code>ssl_ciphers</code>，详见 <a href="https://wiki.mozilla.org/Security/Server_Side_TLS">Mozilla Server_Side_TLS 的介绍</a>，Nginx 里面 <code>ssl_ciphers</code> 默认值是 <code>HIGH:!aNULL:!MD5;</code> <a href="https://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_ciphers">ref</a></li></ul><h2 id="acme-sh-1"><a href="#acme-sh-1" class="headerlink" title="acme.sh"></a>acme.sh</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看证书列表</span><br>acme.sh --list<br><br><span class="hljs-comment"># 删除证书</span><br>acme.sh remove Main_Domain (证书的主域名，上述证书列表中可看见)<br><br><span class="hljs-comment"># 升级 acme.sh 到最新版 :</span><br>acme.sh --upgrade<br><br><span class="hljs-comment"># 如果你不想手动升级, 可以开启自动升级:</span><br>acme.sh --upgrade --auto-upgrade<br><br><span class="hljs-comment">#你也可以随时关闭自动更新:</span><br>acme.sh --upgrade --auto-upgrade 0 <br><br><span class="hljs-comment"># 如果出错, 请添加 debug log：</span><br>acme.sh --issue ..... --debug <br><span class="hljs-comment"># 或者：</span><br>acme.sh --issue ..... --debug 2<br></code></pre></td></tr></table></figure><h2 id="ngix"><a href="#ngix" class="headerlink" title="ngix"></a>ngix</h2><h3 id="nginx-config-1"><a href="#nginx-config-1" class="headerlink" title="nginx config 1"></a>nginx config 1</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">server &#123;<br>    listen 80; <span class="hljs-comment">#如果硬性要求全部走https协议，这一行去除</span><br>    listen 443 ssl http2; <span class="hljs-comment">#如果硬性要求全部走https协议，这里去除ssl</span><br>    server_name chandao.test.com;<br><br>    ssl_certificate /usr/local/nginx/ssl_cert/test.com/chandao.test.com.cer;<br>    ssl_certificate_key /usr/local/nginx/ssl_cert/test.com/chandao.test.com.key;<br>    ssl_dhparam /usr/local/nginx/ssl/lager.cf.pem;<br><br>    <span class="hljs-comment">#ssl性能调优</span><br>    <span class="hljs-comment">#nginx 1.13.0支持了TLSv1.3,TLSv1.3相比之前的TLSv1.2、TLSv1.1等性能大幅提升</span><br>    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;<br>    <span class="hljs-comment"># ssl_ciphers EECDH+CHACHA20:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5;</span><br>    <span class="hljs-comment"># ssl_prefer_server_ciphers on|off 作用：是否由服务器决定采用哪种加密算法</span><br>    <span class="hljs-comment"># 如果ssl协议支持tlsv1 tls1.1这种老协议，设置为 on ，并配合ssl_ciphers使用</span><br>    <span class="hljs-comment"># 如果ssl协议只支持tlsv1.2 tlsv1.3新协议，设置为 off （nginx默认为off），因为新协议不再采纳此参数</span><br>    ssl_prefer_server_ciphers on;<br>    ssl_session_timeout 10m;<br>    <span class="hljs-comment">#使用ssl_session_cache优化https下Nginx的性能</span><br>    ssl_session_cache <span class="hljs-built_in">builtin</span>:1000 shared:SSL:10m;<br>    <span class="hljs-comment">#OCSP Stapling 开启。OCSP是用于在线查询证书吊销情况的服务，使用OCSP Stapling能将证书有效状态的信息缓存到服务器，提高 TLS 握手速度</span><br>    ssl_stapling on;<br>    <span class="hljs-comment">#OCSP Stapling 验证开启</span><br>    ssl_stapling_verify on;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="nginx-config-2"><a href="#nginx-config-2" class="headerlink" title="nginx config 2"></a>nginx config 2</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs awk">http &#123;<br>  <span class="hljs-comment"># 新增</span><br>  ssl_protocols TLSv1 TLSv1.<span class="hljs-number">1</span> TLSv1.<span class="hljs-number">2</span>;<br>  ssl_prefer_server_ciphers on;<br>  <span class="hljs-comment"># 兼容其他老浏览器的 ssl_ciphers 设置请访问 https://wiki.mozilla.org/Security/Server_Side_TLS</span><br><br>  server &#123;<br>    listen <span class="hljs-number">80</span> default_server;<br>    <span class="hljs-comment"># 新增</span><br>    listen <span class="hljs-number">443</span> ssl;<br>    ssl_certificate         <span class="hljs-regexp">/home/u</span>buntu<span class="hljs-regexp">/www/</span>ssl/www.your-app.com.key.pem;<br>    ssl_certificate_key     <span class="hljs-regexp">/home/u</span>buntu<span class="hljs-regexp">/www/</span>ssl/www.your-app.com.key;<br>    <span class="hljs-comment"># ssl_dhparam </span><br>    ssl_dhparam             <span class="hljs-regexp">/home/u</span>buntu<span class="hljs-regexp">/www/</span>ssl/dhparam.pem;<br><br>    <span class="hljs-comment"># 其他省略</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>80 重定向到 443</p><p>这些办法试了好多次都不太行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">server &#123;<br>  listen       80 default_server;<br>  server_name  www.lager.cf;<br>  <span class="hljs-built_in">return</span> 301 https://$server_name<span class="hljs-variable">$request_uri</span>;<br>&#125;<br><br><br>server &#123;<br>    listen      80;<br>    server_name    www.awesomes.cn,awesomes.cn;<br>    rewrite ^(.*)$  https://$host<span class="hljs-variable">$1</span> permanent;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="v2ray-tls-websocket-流量伪装"><a href="#v2ray-tls-websocket-流量伪装" class="headerlink" title="v2ray + tls + websocket 流量伪装"></a>v2ray + tls + websocket 流量伪装</h1><p><a href="https://www.bwgss.org/616.html">https://www.bwgss.org/616.html</a></p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><ol><li><p>证书(Certificate) – *.cer *.crt</p></li><li><p>私钥(Private Key) – *.key</p></li><li><p>证书签名请求(Certificate signing request) – *.csr</p></li><li><p>编码方式: 1. pem - base64编码 2. der - 二进制编码(少见), cer,key,csr 均可用这两种编码方式</p></li><li><p>证书吊销列表(Certificate Revocation List) – *.crl</p></li><li><p>jks（javakeystone）— 是JAVA的keytools证书工具支持的证书私钥格式，javakeystone 里面存放着key和信任的CA，key和CA可以有多个。</p></li></ol><p><img src="/2022/aa858de8/1606053801673.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SSL</tag>
      
      <tag>HTTPS</tag>
      
      <tag>Wordpress</tag>
      
      <tag>Web</tag>
      
      <tag>MySQL</tag>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>静态网页</title>
    <link href="/2022/f96c3c41/"/>
    <url>/2022/f96c3c41/</url>
    
    <content type="html"><![CDATA[<h1 id="静态网页"><a href="#静态网页" class="headerlink" title="静态网页"></a>静态网页</h1><h1 id="静态网页生成器"><a href="#静态网页生成器" class="headerlink" title="静态网页生成器"></a>静态网页生成器</h1><p><a href="https://jekyllrb.com/">Jekyll</a>（由 Github 构建的用于为其 Github 页面提供支持的 Ruby 生成器）、</p><p><a href="https://gohugo.io/">Hugo</a>（构建在 Go 编程之上的极快静态生成器）语言）和</p><p><a href="https://hexo.io/">Hexo</a>（基于 Node.js 的快速网站生成器）。</p><p><strong>参考</strong></p><p><a href="https://www.techiediaries.com/jekyll-hugo-hexo/">How to Choose the Right Static Generator: Jekyll vs. Hugo vs. Hexo</a></p><p><a href="https://stackshare.io/stackups/hexo-vs-hugo-vs-jekyll">StackShare</a></p><h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><p>TBD</p><h2 id="Jekyll"><a href="#Jekyll" class="headerlink" title="Jekyll"></a>Jekyll</h2><p>TBD</p><h2 id="Hugo"><a href="#Hugo" class="headerlink" title="Hugo"></a>Hugo</h2><p>TBD</p><h1 id="Hexo-1"><a href="#Hexo-1" class="headerlink" title="Hexo"></a>Hexo</h1><h2 id="Hexo-部署"><a href="#Hexo-部署" class="headerlink" title="Hexo 部署"></a>Hexo 部署</h2><p><a href="https://hexo.io/zh-cn/docs/">HEXO文档_参考链接</a></p><p><strong>要求:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">Node.js (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)<br>Git<br></code></pre></td></tr></table></figure><p><strong>部署:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-cli -g<br>hexo init blog<br><span class="hljs-built_in">cd</span> blog<br>npm install<br>hexo server<br></code></pre></td></tr></table></figure><h2 id="Hexo-CMD"><a href="#Hexo-CMD" class="headerlink" title="Hexo CMD"></a>Hexo CMD</h2><h3 id="Init-初始化"><a href="#Init-初始化" class="headerlink" title="Init 初始化"></a>Init 初始化</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init [folder]<br></code></pre></td></tr></table></figure><p>新建一个网站。如果没有设置 <code>folder</code> ，Hexo 默认在目前的文件夹建立网站。</p><h3 id="new-新建"><a href="#new-新建" class="headerlink" title="new 新建"></a>new 新建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new [layout] &lt;title&gt;<br>hexo new <span class="hljs-string">&quot;post title with whitespace&quot;</span><br>hexo new page --path about/me <span class="hljs-string">&quot;About me&quot;</span><br>hexo new page -p     about/me <span class="hljs-string">&quot;About me&quot;</span><br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>, <code>--path</code></td><td align="left">自定义新文章的路径</td></tr><tr><td align="left"><code>-r</code>, <code>--replace</code></td><td align="left">如果存在同名文章，将其替换</td></tr><tr><td align="left"><code>-s</code>, <code>--slug</code></td><td align="left">文章的 Slug，作为新文章的文件名和发布后的 URL</td></tr></tbody></table><h3 id="generate-生成"><a href="#generate-生成" class="headerlink" title="generate 生成"></a>generate 生成</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 生成静态文件。</span><br>hexo generate<br><span class="hljs-comment"># 该命令可以简写为</span><br>hexo g<br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">选项</th><th></th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">-d</td><td>–deploy</td><td align="left"><strong>文件生成后立即部署网站</strong></td></tr><tr><td align="left">-w</td><td>–watch</td><td align="left"><strong>监视文件变动</strong></td></tr><tr><td align="left">-b</td><td>–bail</td><td align="left">生成过程中如果发生任何未处理的异常则抛出异常</td></tr><tr><td align="left">-f</td><td>–force</td><td align="left">强制重新生成文件 Hexo 引入了差分机制，<br>如果 <code>public</code> 目录存在，那么 <code>hexo g</code> 只会重新生成改动的文件。<br/>使用该参数的效果接近 <code>hexo clean &amp;&amp; hexo generate</code></td></tr><tr><td align="left">-c</td><td>–concurrency</td><td align="left">最大同时生成文件的数量，默认无限制</td></tr></tbody></table><h3 id="publish-草稿"><a href="#publish-草稿" class="headerlink" title="publish 草稿"></a>publish 草稿</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">hexo publish [layout] <span class="hljs-tag">&lt;<span class="hljs-name">filename</span>&gt;</span><br></code></pre></td></tr></table></figure><p>发表草稿。</p><h3 id="server-服务器"><a href="#server-服务器" class="headerlink" title="server 服务器"></a>server 服务器</h3><p>在服务器启动期间，Hexo 会监视文件变动并自动更新，您无须重启服务器。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta">hexo <span class="hljs-keyword">server</span><br>hexo s<br></code></pre></td></tr></table></figure><p>启动服务器。默认情况下，访问网址为： <code>http://localhost:4000/</code>。</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>, <code>--port</code></td><td align="left">重设端口</td></tr><tr><td align="left"><code>-s</code>, <code>--static</code></td><td align="left">只使用静态文件(不会更新)</td></tr><tr><td align="left"><code>-l</code>, <code>--log</code></td><td align="left">启动日记记录，使用覆盖记录格式</td></tr><tr><td align="left"><code>-i</code></td><td align="left"><code>hexo server -i 192.168.1.1</code> 指定监听的IP</td></tr></tbody></table><h3 id="deploy-部署"><a href="#deploy-部署" class="headerlink" title="deploy 部署"></a>deploy 部署</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment"># 部署网站。</span><br>hexo <span class="hljs-keyword">deploy</span><br><span class="hljs-comment"># 该命令可以简写为：</span><br>hexo d<br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-g</code>, <code>--generate</code></td><td align="left">部署之前预先生成静态文件</td></tr></tbody></table><h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prolog">hexo render &lt;file1&gt; [file2] ...<br></code></pre></td></tr></table></figure><p>渲染文件。</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-o</code>, <code>--output</code></td><td align="left">设置输出路径</td></tr></tbody></table><h3 id="migrate"><a href="#migrate" class="headerlink" title="migrate"></a>migrate</h3><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">hexo</span> migrate &lt;<span class="hljs-keyword">type</span>&gt;<br></code></pre></td></tr></table></figure><p>从其他博客系统 <a href="https://hexo.io/zh-cn/docs/migration">迁移内容</a>。</p><h3 id="clean-清理"><a href="#clean-清理" class="headerlink" title="clean 清理"></a>clean 清理</h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>hexo clean<br></code></pre></td></tr></table></figure><p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p><p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>hexo list &lt;<span class="hljs-keyword">type</span>&gt;<br></code></pre></td></tr></table></figure><p>列出网站资料。</p><h1 id="Hexo-Theme"><a href="#Hexo-Theme" class="headerlink" title="Hexo Theme"></a>Hexo Theme</h1><p>我是直接在github搜索 <code>hexo theme</code>看到了几个 star 比较多而且比较活跃的 repository </p><ul><li><p><strong><a href="https://github.com/ppoffice/hexo-theme-icarus">icarus</a></strong> 5.5K star</p><p><img src="/2022/f96c3c41/68747470733a2f2f70706f66666963652e6769746875622e696f2f6865786f2d7468656d652d6963617275732f67616c6c6572792f707265766965772e706e673f31.png" alt="img"></p></li><li><p><strong><a href="https://github.com/fluid-dev/hexo-theme-fluid">fluid</a></strong> 4.8K star</p><p><img src="/2022/f96c3c41/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666c7569642d6465762f737461746963406d61737465722f6865786f2d7468656d652d666c7569642f73637265656e73686f74732f696e6465782e706e67.png" alt="ScreenShot"></p></li><li><p><a href="https://github.com/blinkfox/hexo-theme-matery">matery</a>(blinkfox) 4.5K star</p><p><img src="/2022/f96c3c41/687474703a2f2f7374617469632e626c696e6b666f782e636f6d2f6d61746572792d32303138313230322d312e706e67.png" alt="首页"></p><p><img src="/2022/f96c3c41/687474703a2f2f7374617469632e626c696e6b666f782e636f6d2f6d61746572792d32303138313230322d332e706e67.png" alt="首页文章列表"></p></li><li><p><strong><a href="https://github.com/jerryc127/hexo-theme-butterfly">butterfly</a></strong> 4.3K star</p><p><img src="/2022/f96c3c41/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f6a65727279633132372f43444e406d322f696d672f7468656d652d627574746572666c792d726561646d652e706e67.png" alt="img"></p></li><li><p><a href="https://github.com/volantis-x/hexo-theme-volantis">volantis</a> 1.5k star</p><p><img src="/2022/f96c3c41/68747470733a2f2f692e6c6f6c692e6e65742f323032302f30332f31382f663550516c576973766d397a62674b2e6a7067.jpeg" alt="img"></p><p><img src="/2022/f96c3c41/68747470733a2f2f692e6c6f6c692e6e65742f323032302f30332f31382f585742476639354532743162646e6c2e6a7067.jpeg" alt="img"></p></li></ul><p>其中 <code>fluid</code> 和 <code>volantis</code> 最对我胃口, 最后选择的 <code>fluid</code>, 后期可能会改成<code>volantis</code>或者<code>icarus</code>试试看, 主要是喜欢简洁些, 又能有一定的观赏性的.</p><h2 id="Fluid"><a href="#Fluid" class="headerlink" title="Fluid"></a>Fluid</h2><p>参考文档</p><p><a href="https://hexo.fluid-dev.com/docs/guide/">https://hexo.fluid-dev.com/docs/guide/</a></p><p>theme 的 Github</p><p><a href="https://github.com/fluid-dev/hexo-theme-fluid">https://github.com/fluid-dev/hexo-theme-fluid</a></p><h1 id="Hexo-Note"><a href="#Hexo-Note" class="headerlink" title="Hexo Note"></a>Hexo Note</h1><h2 id="Hexo-Permalink简化"><a href="#Hexo-Permalink简化" class="headerlink" title="Hexo Permalink简化"></a>Hexo Permalink简化</h2><p>参考:</p><p><a href="https://blog.csdn.net/Galahadzhou/article/details/105355733">Hexo Permalink简化</a></p><p>Note:</p><p>使用<code>hexo-abbrlink</code>插件实现</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># install</span><br>npm install hexo-abbrlink --save<br><span class="hljs-comment"># setting edit _config.yml</span><br>permalink: posts/:abbrlink.html<br>abbrlink:<br>  alg: crc32  <span class="hljs-comment"># 算法：crc16(default) and crc32</span><br>  rep: hex    <span class="hljs-comment"># 进制：dec(default) and hex</span><br><br></code></pre></td></tr></table></figure><h2 id="图片链接问题"><a href="#图片链接问题" class="headerlink" title="图片链接问题"></a>图片链接问题</h2><p><strong><code>hexo</code>本地图片显示问题</strong></p><p>使用<code>hexo</code>生成静态资源后,由于<code>url</code>的问题会出现图片加载的问题,现在网上的文章及官方的解决方案大概分为三种:</p><ol><li>将图片放入<code>source/images</code>目录下,每次<code>generate</code>都会生成图片,在使用相对或绝对路径进行引用</li><li>配置<code>hexo</code>的<code>_config.yml</code>文件, 将 <code>post_asset_folder</code> 设置为<code>true</code>, 这样每次new 生成一个文章时都会同步生成一个同名的文件夹,然后设置相对或绝对路径. </li><li>使用<code>hexo</code>官方的解决方案,使用模版变量, <code>&#123;% asset_img slug [title] %&#125; </code> </li><li>!new!. <code>hexo init</code>的时候会自动copy一个插件 <code>hexo-renderer-marked</code> 这个插件可以开启相对路径的支持,但是需要改一些代码</li></ol><p>但是在配置过程中发现这三种方式都多多少少存在一些问题,前两中首页跟内容页会有一个加载失败的问题,而第三种则失去了<code>markdown</code>的意义.</p><p><strong>方法四:</strong></p><p>官方手册上提到过, <a href="https://github.com/hexojs/hexo-renderer-marked">hexo-renderer-marked</a> 3.1.0已经开始支持相对路径了.但是可以看到它支持的路径似乎并不合理, 其他的md阅读器是不能识别这样的路径的.</p><p><img src="/2022/f96c3c41/image-20220815153651988.png" alt="image-20220815153651988"></p><p>参考: <a href="https://github.com/hexojs/hexo-renderer-marked/issues/216">https://github.com/hexojs/hexo-renderer-marked/issues/216</a></p><ol><li><p>修改<code>_config.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">marked:</span><br>  <span class="hljs-attr">prependRoot:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">postAsset:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li><li><p>修改文件<code>node_modules\hexo-renderer-marked\lib\renderer.js</code></p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (!<span class="hljs-regexp">/^(#|\/\/|http(s)?:)/</span>.<span class="hljs-title function_">test</span>(href) &amp;&amp; !relative_link &amp;&amp; prependRoot) &#123;<br>  <span class="hljs-keyword">if</span> (!href.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;/&#x27;</span>) &amp;&amp; !href.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;\\&#x27;</span>) &amp;&amp; postPath) &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title class_">PostAsset</span> = hexo.<span class="hljs-title function_">model</span>(<span class="hljs-string">&#x27;PostAsset&#x27;</span>);<br>    <span class="hljs-comment">// findById requires forward slash</span><br>    <span class="hljs-comment">// ***************** Add the following code *******************</span><br>    <span class="hljs-keyword">const</span> fixPostPath = <span class="hljs-title function_">join</span>(postPath, <span class="hljs-string">&#x27;../&#x27;</span>);<br>    <span class="hljs-keyword">const</span> asset = <span class="hljs-title class_">PostAsset</span>.<span class="hljs-title function_">findById</span>(<span class="hljs-title function_">join</span>(fixPostPath, href.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\\/g</span>, <span class="hljs-string">&#x27;/&#x27;</span>)));<br>    <span class="hljs-comment">// const asset = PostAsset.findById(join(postPath, href.replace(/\\/g, &#x27;/&#x27;)));</span><br>    <span class="hljs-comment">// ************************** End *****************************</span><br>    <span class="hljs-comment">// asset.path is backward slash in Windows</span><br>    <span class="hljs-keyword">if</span> (asset) href = asset.<span class="hljs-property">path</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\\/g</span>, <span class="hljs-string">&#x27;/&#x27;</span>);<br>  &#125;<br>  href = url_for.<span class="hljs-title function_">call</span>(hexo, href);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>enjoy it</li></ol><p><strong>方法二:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"># 设置<br><span class="hljs-attr">post_asset_folder</span>:<span class="hljs-literal">true</span><br># 安装插件 asset-image<br>npm install <span class="hljs-attr">https</span>:<span class="hljs-comment">//github.com/CodeFalling/hexo-asset-image  --save</span><br># typora中设置图片为相对路径 看下图<br>./$&#123;filename&#125;<br># 运行查看<br>hexo clean &amp;&amp; hexo generate &amp;&amp; hexo s <br></code></pre></td></tr></table></figure><p><img src="/2022/f96c3c41/image-20220815133503275.png" alt="image-20220815133503275"></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><blockquote><p>   Env:使用方法四</p><ul><li>文件名不能带有空格, title 可以带空格 (<code>hexo new</code>的时候需要注意这一点)<ul><li>修改 <code>node_modules\hexo-renderer-marked\lib\renderer.js</code>文件可能可以改善这点. -&gt; TBD</li></ul></li><li>md文件名要和图片等等资源文件夹同名 -&gt; 注定了不能使用 <code>./$&#123;filename&#125;.assets</code>这种方案, 一定要改成<code>./$&#123;filename&#125;</code>才行</li></ul></blockquote><h2 id="Hexo跳过一些文件-不渲染某些文件"><a href="#Hexo跳过一些文件-不渲染某些文件" class="headerlink" title="Hexo跳过一些文件,不渲染某些文件"></a>Hexo跳过一些文件,不渲染某些文件</h2><p>搜索引擎确认网站所有权时往往会提供一个html文件来进行验证，要是这个文件被渲染了，验证自然就会失败了。或者，有时候会写一些简单的html示例页面或<code>README.md</code>，这也是不希望Hexo渲染的。因此有必要针对某个文件或者目录进行排除。</p><p>Hexo博客的基本内容是一些Markdown文件，放在<code>source/_post</code>文件夹下，每个文件对应一篇文章。除此之外，放在<code>source</code>文件夹下的所有开头不是下划线的文件，在<code>hexo generate</code>的时候，都会被拷贝到<code>public</code>文件夹下。但是，Hexo默认会渲染所有的HTML和Markdown文件，导致我的README.md直接转成html格式了。。。</p><p>怎么样避开这个坑呢？如果只有一个HTML文件的话，可以简单地在文件开头加上<code>layout: false</code>一行即可：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">layout:</span> <span class="hljs-literal">false</span><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-string">&lt;html&gt;</span><br><span class="hljs-string">...</span><br></code></pre></td></tr></table></figure><p>如果有多个要避开渲染的md文件，显然是不可能使用这种方法的。这时候需要使用<code>skip_render</code>配置。根据<a href="https://hexo.io/zh-cn/docs/configuration.html">Hexo文档</a>中的说明，通过在<code>_config.yml</code>配置文件中使用<code>skip_render</code>参数，可以跳过指定文件的渲染。使用方式如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">skip_render: [games<span class="hljs-regexp">/**, depview/</span>**, knowledge/**]<br></code></pre></td></tr></table></figure><p>这里的路径匹配可以使用正则表达式。</p><p><strong>注意：<code>skip_render</code>参数设置的路径是相对于<code>source</code>目录的路径。</strong>例如，需要跳过渲染source&#x2F;README.md，只需要设置 <code>skip_render:README.md</code>。</p><p>在设置了跳过渲染之后，最好使用<code>hexo clean</code>清除以前的编译结果，保证配置生效。</p><h1 id="Comment-评论系统"><a href="#Comment-评论系统" class="headerlink" title="Comment 评论系统"></a>Comment 评论系统</h1><h2 id="cusdis-系统"><a href="#cusdis-系统" class="headerlink" title="cusdis 系统"></a>cusdis 系统</h2><p>功能较少,看起来非常轻量, 也可以私有部署,正打算私有部署的时候看到了<code>twikoo</code>所以就转入<code>twikoo</code>了,因为cusdis现阶段功能确实有些少.</p><h2 id="twikoo-系统"><a href="#twikoo-系统" class="headerlink" title="twikoo 系统"></a>twikoo 系统</h2><p><a href="https://twikoo.js.org/">https://twikoo.js.org/</a></p><p>私有docker部署部署半天还是不成功, 看起来像是需要HTTPS才行.</p><p>功能挺丰富的,<del>就是半天没部署成功</del></p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">部署后没有启用HTTPS<br>fluid 配置里面又启动了强行使用hTTPS, <br><span class="hljs-built_in">F12,</span>看consel发现,ERR_SSL_PROTOCOL_ERROR,被重定向到了HTTPS去了<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css">头像风格类型<br><span class="hljs-number">404</span>：如果没有任何图像与电子邮件哈希无关，则不加载任何图像，而是返回HTTP <span class="hljs-number">404</span>（找不到文件）响应<br>mp：（神秘人物）一个人的简单卡通风格的轮廓（不随电子邮件哈希值而变化）<br>identicon：基于电子邮件哈希的几何图案<br>monsterid：生成的具有不同颜色，面孔等的“怪物”<br>wavatar：生成的具有不同特征和背景的面孔<br>retro：生成的令人敬畏的<span class="hljs-number">8</span>位街机风格像素化面孔<br>robohash：具有不同颜色，面部等的生成的机器人<br>blank：透明的PNG图像（以下为演示目的添加到<span class="hljs-selector-tag">HTML</span>的边框）<br></code></pre></td></tr></table></figure><ul><li><p>Twikoo我是用的docker,nginx和ssl配置可以参考<a href="https://hub.docker.com/r/imaegoo/twikoo">DockerHub</a>, https的端口是可以更改的, 默认的443占用了换成别的就好.</p></li><li><p>twikoo的即时推送尝试了几个譬如 Qmsq, server酱等等发现又一系列的问题 都不尽如人意  最后选择的是最简单的邮件通知.</p></li></ul><h2 id="remark42"><a href="#remark42" class="headerlink" title="remark42"></a>remark42</h2><h1 id="部署-托管"><a href="#部署-托管" class="headerlink" title="部署(托管)"></a>部署(托管)</h1><p><a href="https://i.vince.pub/p/hexo-static/">常见静态网站托管平台使用及多节点部署方案</a></p><p><img src="/2022/f96c3c41/2fc062cb2.svg" alt="节点"></p><p>现阶段比较好的方案是<code>coding</code>和<code>github+netlify</code>.</p><h1 id="一些资源"><a href="#一些资源" class="headerlink" title="一些资源"></a>一些资源</h1><p><strong>字体族（<code>font-family</code>）</strong></p><blockquote><p>   <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-family">https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-family</a></p></blockquote><p><strong>调色板灵感</strong></p><blockquote><p>   <a href="https://www.webdesignrankings.com/resources/lolcolors/">https://www.webdesignrankings.com/resources/lolcolors/</a></p></blockquote><p><strong>ISO-8601 日期</strong></p><blockquote><p>  <a href="http://momentjs.cn/docs/#/parsing/string-format/">http://momentjs.cn/docs/#/parsing/string-format/</a></p></blockquote><p><strong>代码高亮风格</strong></p><blockquote><p>  highlightjs:  <a href="https://highlightjs.org/static/demo/">https://highlightjs.org/static/demo/</a></p><p>  prismjs:  <a href="https://prismjs.com/">https://prismjs.com/</a></p></blockquote><h1 id="一些知识"><a href="#一些知识" class="headerlink" title="一些知识"></a>一些知识</h1><p><a href="https://www.wur.nl/en/article/What-are-Creative-Commons-licenses.htm">What are Creative Commons licenses?</a></p><p><img src="/2022/f96c3c41/licences_3bf0e9af_670x502.jpg" alt="知识共享许可.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HEXO</tag>
      
      <tag>Jekyll</tag>
      
      <tag>Fluid</tag>
      
      <tag>Cusdis</tag>
      
      <tag>Twikoo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DSlogic协议开发笔记</title>
    <link href="/2022/5ced0506/"/>
    <url>/2022/5ced0506/</url>
    
    <content type="html"><![CDATA[<h1 id="参考资料-smiley"><a href="#参考资料-smiley" class="headerlink" title="参考资料:smiley:"></a>参考资料:smiley:</h1><p><a href="https://sigrok.org/wiki/Protocol_decoder_HOWTO">Protocol decoder HOWTO(新手指导)</a></p><p><a href="https://sigrok.org/wiki/Protocol_decoder_API#register-function">Protocol decoder API</a></p><p><a href="https://sigrok.org/wiki/Protocol_decoder_API/Queries">Protocol decoder API&#x2F;Queries</a></p><h1 id="名词解析"><a href="#名词解析" class="headerlink" title="名词解析"></a>名词解析</h1><ul><li><strong>Protocol Decoders (PDs)</strong></li></ul><p>协议解码器</p><ul><li><strong>libsigrokdecode</strong></li></ul><p>是一个采用C语言编写的共享库,提供了数据流协议解码功能。该协议解码器采用Python(&#x3D; 3.0)编写。 </p><h1 id="Decoder-class-functions"><a href="#Decoder-class-functions" class="headerlink" title="Decoder class functions"></a>Decoder class functions</h1><h2 id="必须的函数"><a href="#必须的函数" class="headerlink" title="必须的函数"></a>必须的函数</h2><ul><li>start(self)</li></ul><p> 这个函数在解码开始之前被调用。这里可以  [register()](#Decoder registration) 输出类型，检查用户提供的PD选项的有效性，等等。 </p><ul><li>decode(self) （解码）</li></ul><p>在 <strong>non-stacked</strong> 解码器中，这个函数由libsigrokdecode后端调用以开始解码。它不接受任何参数，而是进入一个无限循环，并通过调用更通用的wait()方法获取样本。这使得特定的协议解码器从繁琐但常见的任务中解放出来，比如检测边缘，或者在相对于当前位置的特定时间点采样信号。</p><p>  注意:这个decode(self)方法的签名已经在协议解码器API的第三版中引入，在以前的版本中只有decode(self、startsample、endsample、data)是可用的。</p><ul><li>decode(self, startsample, endsample, data)</li></ul><p>…</p><h2 id="可选的函数"><a href="#可选的函数" class="headerlink" title="可选的函数"></a>可选的函数</h2><ul><li>metadata(self, key, value)（  元数据 ）</li></ul><p> 用于传递关于数据流的解码器元数据。目前 <strong><code>key</code></strong>  的唯一值是sigrokdecode.SRD_CONF_SAMPLERATE， <strong><code>value</code></strong>  则为数据流的采样率（samplerate），单位为Hz。 </p><h1 id="Decoder-registration"><a href="#Decoder-registration" class="headerlink" title="Decoder registration"></a>Decoder registration</h1><p> 解码器类必须包含几个指定PD元数据的属性。可以使用以下关键字：</p><p><a href="https://sigrok.org/wiki/Protocol_decoder_API">原文查考 Decoder registration 章节</a></p><table><thead><tr><th>Key</th><th>Description</th></tr></thead><tbody><tr><td><strong><code>api_version</code></strong></td><td>这个模块使用的libsigrokdecode API版本。现在不是2就是3。</td></tr><tr><td><strong><code>id</code></strong></td><td>此协议解码器的简短唯一标识符。它应该是全小写的，只包含a-z, 0-9和下划线。这必须匹配PD的Python模块名(decoders目录中的子目录名)。siglock -cli工具使用它在命令行上指定PDs。例如:’jtag’， ‘sdcard_spi’， ‘uart’。</td></tr><tr><td><strong><code>name</code></strong></td><td>解码器的名称。当列出可用的PDs时使用。例如:“JTAG”，“SD卡(SPI模式)”，“UART”。</td></tr><tr><td><strong><code>longname</code></strong></td><td>译码器的(长)名。当列出可用的PDs时使用。Example: ‘Joint Test Action Group (IEEE 1149.1)’, ‘Secure Digital card (SPI mode)’, ‘Universal Asynchronous Receiver&#x2F;Transmitter（UART）’</td></tr><tr><td><strong><code>desc</code></strong></td><td>解码器的自由的一行描述。当列出可用的PDs时使用。应该以句号结束。Example: ‘Protocol for testing, debugging, and flashing ICs.’, ‘Secure Digital card (SPI mode) low-level protocol.’, ‘Asynchronous, serial bus.’.</td></tr><tr><td><strong><code>license</code></strong></td><td>提供模块的许可证。这必须是gplv2+(即GNU通用公共许可证2或更高版本)，或者gplv3+ (GNU通用公共许可证3或更高版本)。libsigrokdecode中不允许为模块提供其他许可证。</td></tr><tr><td><strong><code>inputs</code></strong></td><td>此解码器需要的输入类型列表。如果解码器从逻辑分析器驱动程序获取输入，则应将其设置为logic，该逻辑将映射到数据籽类型SR_DF_LOGIC。如果它从另一个PD获取输入，则应该将其设置为该PD的输出键的值。它应该符合与id键相同的规则(小写，没有空格，等等)。</td></tr><tr><td><strong><code>outputs</code></strong></td><td>此解码器产生的输出类型列表。如果这个解码器能够将解码后的数据反馈到数据流中，那么它的输出将被标识为该密钥的值。它应该与id键遵循相同的规则。</td></tr><tr><td><strong><code>channels</code></strong></td><td>该密钥包含有关<strong>必须</strong>提供给该PD的通道(pin)的信息;没有他们，PD将无法工作。例如，SPI解码器必须知道哪个信道有时钟信号。该键包含一个通道条目的元组，其中每个条目都是一个Python dict，其键为id、name和desc。Example: <strong><code>&#123;&#39;id&#39;: &#39;rx&#39;, &#39;name&#39;: &#39;RX&#39;, &#39;desc&#39;: &#39;UART receive line&#39;&#125;</code></strong>.</td></tr><tr><td><strong><code>optional_channels</code></strong></td><td>PD可选的通道，但不是必须的。该键的格式与上面的通道键相同(dicts的元组)。如果相应的协议解码器没有可选通道，则允许该元组为空。</td></tr><tr><td><strong><code>options</code></strong></td><td>描述此解码器的选项的元组。每个元组条目都是一个Python dict，其键id、desc、缺省值和值。如果PD没有可选的通道，则此元组可以为空。Example: <strong><code>&#123;&#39;id&#39;: &#39;bitorder&#39;, &#39;desc&#39;: &#39;Bit order&#39;, &#39;default&#39;: &#39;msb-first&#39;, &#39;values&#39;: (&#39;msb-first&#39;, &#39;lsb-first&#39;)&#125;</code></strong>.</td></tr><tr><td><strong><code>annotations</code></strong></td><td>此协议解码器可以输出的注释类的列表。此列表的元素是由标识符字符串和可读的描述字符串组成的元组。标识符字符串可以在siglock -cli选项中用于选择特定的注释类型，因此不应该包含空白或特殊字符。</td></tr><tr><td><strong><code>annotation_rows</code></strong></td><td>注释行用于将多个注释类型分组在一起。这个列表的元素是三个元素元组，包括: 1.注释行ID(与其他ID的命名规则相同)。2.注释行的人类可读的名称&#x2F;描述字符串。3. 包含注释元组中注释类的索引的元组。<a href="https://sigrok.org/wiki/Protocol_decoder_HOWTO#annotations_.26_annotation_rows">示例参考</a></td></tr><tr><td><strong><code>binary</code></strong></td><td>此协议解码器可以输出的二进制输出类型列表，格式与**<code>annotations</code>**列表相同。</td></tr></tbody></table><h1 id="self-put"><a href="#self-put" class="headerlink" title="self.put( )"></a>self.put( )</h1><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p><strong>put(startsample, endsample, output_id, data)</strong></p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>startsample：开始的序号</p><p>endsample：结束的序号</p><p>output_id：取值看下表</p><p>data：根据output_id的不同数据也不同</p><table><thead><tr><th>output_id</th><th>funcation</th></tr></thead><tbody><tr><td><strong>OUTPUT_ANN</strong></td><td>注释信息</td></tr><tr><td><strong>OUTPUT_PYTHON</strong></td><td></td></tr><tr><td><strong>OUTPUT_BINARY</strong></td><td></td></tr><tr><td><strong>OUTPUT_META</strong></td><td></td></tr></tbody></table><ol><li><strong>OUTPUT_ANN</strong>：</li></ol><ul><li><p>这个东西在显示bit数据时会在信号上有小点点指示。</p></li><li><p>不同缩放级别显示不同内容<br>Example: <code>self.put(10, 20, self.out_ann, [4, [&#39;Start&#39;, &#39;St&#39;, &#39;S&#39;]])</code></p></li><li><p>data参数是一个包含两个项的Python列表。第一项是注释索引(由解码器中项的顺序决定)。第二个是注释字符串列表。字符串应该是相同注释文本的长版本和短版本(按长度排序，最长优先)，可以由前端根据缩放级别显示不同的注释文本。</p></li></ul><ol start="2"><li><strong>OUTPUT_PYTHON</strong> ：</li></ol><ul><li><p>输出特定格式的数据么？（ 数据内容本身完全依赖于各自的解码器，应该在其pd.py文件中记录。 ）</p><p>Example: <em><code>self.put(10, 20, self.out_python, [&#39;PACKET&#39;, [&#39;Foo&#39;, 19.7, [1, 2, 3], (&#39;bar&#39;, &#39;baz&#39;)]])</code></em> </p></li><li><p>数据参数是将传递给堆叠解码器的任意Python对象。格式和内容完全依赖于解码器。通常，包含各种内容的Python列表被传递给堆叠的PDs。</p></li></ul><ol start="3"><li><p><strong>OUTPUT_BINARY</strong>：</p><ul><li><p>输出数据0x55 0xaa等等（ 二进制格式的索引为4，发出的字节分别为0xfe、0x55、0xaa）</p><p> Example: <em><code>self.put(10, 20, self.out_binary, [4, b&#39;\xfe\x55\xaa&#39;])</code></em> </p></li><li><p>data参数是一个包含两个项的Python列表。第一项是二进制格式的索引(由解码器中项的顺序决定)。第二个是Python bytes对象。</p></li></ul></li><li><p><strong>OUTPUT_META</strong> ：</p></li></ol><ul><li><p>输出解码出来的数字（ 在本例中数据本身是一个浮点数）</p><p> Example: <em><code>self.put(10, 20, self.out_meta, 15.7)</code></em> </p></li><li><p>数据参数是特定类型的Python对象，在各自的register()函数中定义</p></li></ul><h1 id="self-wait"><a href="#self-wait" class="headerlink" title="self.wait()"></a>self.wait()</h1><p>这是协议解码器用来将查询发送到libsigrokdecode后端的API调用。<br>从PD的角度来看，这是一个阻塞呼叫。它将阻塞，直到在样本数据中找到指定的条件，然后才将控制权返回给PD。</p><h2 id="原型-1"><a href="#原型-1" class="headerlink" title="原型"></a>原型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">wait</span>(<span class="hljs-params">self, conds</span>):<br>    <span class="hljs-comment"># 1. 等待，直到conds中的一个或多个条件匹配.</span><br>    <span class="hljs-comment"># 2. 设置 self.samplenum ，匹配样本的绝对样本数.</span><br>    <span class="hljs-comment"># 3. 根据 self.matched 条件匹配.</span><br>    <span class="hljs-comment"># 4. 返回一个包含匹配样本的pin值的元组.</span><br></code></pre></td></tr></table></figure><h2 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h2><h3 id="空参"><a href="#空参" class="headerlink" title="空参"></a>空参</h3><p>如果完全不提供conds，或者它是一个空列表[]，或者它只是一个“空”条件{}，那么后端将直接跳到下一个示例。 （相当于直接进入下一个样本）</p><p><strong>Examples:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Don&#x27;t wait for any condition, just skip to the next sample.</span><br>pins = self.wait()<br>pins = self.wait([])<br>pins = self.wait(&#123;&#125;)<br>pins = self.wait(&#123;<span class="hljs-string">&#x27;skip&#x27;</span>: <span class="hljs-number">1</span>&#125;) <span class="hljs-comment"># Skip one sample, see below.</span><br></code></pre></td></tr></table></figure><h3 id="conds-引脚状态条件-上下沿"><a href="#conds-引脚状态条件-上下沿" class="headerlink" title="conds 引脚状态条件(上下沿)"></a><strong>conds</strong> 引脚状态条件(上下沿)</h3><table><thead><tr><th>Value</th><th>Describe</th></tr></thead><tbody><tr><td>‘<strong>l’</strong></td><td>Low pin value (logical 0)</td></tr><tr><td>‘h’</td><td>High pin value (logical 1)</td></tr><tr><td>‘r’</td><td>Rising edge</td></tr><tr><td>‘f’</td><td>Falling edge</td></tr><tr><td>‘e’</td><td>Either edge (rising or falling)</td></tr><tr><td>‘s’</td><td>稳定状态 Stable state, the opposite of ‘e’. That is, there was no edge and the current and previous pin value were both low (or both high).</td></tr><tr><td>other</td><td>任何其他值都会产生错误。</td></tr></tbody></table><p><strong>Examples:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Wait until pin 7 has a falling edge.</span><br>pins = self.wait(&#123;<span class="hljs-number">7</span>: <span class="hljs-string">&#x27;f&#x27;</span>&#125;)<br><br><span class="hljs-comment"># Wait until pin 3 has a rising edge “and” pin 4 is high at the same time.</span><br>pins = self.wait(&#123;<span class="hljs-number">3</span>: <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-number">4</span>: <span class="hljs-string">&#x27;h&#x27;</span>&#125;)<br><br><span class="hljs-comment"># Wait until pins 2-4 are low and pin 16 has any edge.</span><br>pins = self.wait(&#123;<span class="hljs-number">2</span>: <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-number">3</span>: <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-number">4</span>: <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-number">16</span>: <span class="hljs-string">&#x27;e&#x27;</span>&#125;)<br></code></pre></td></tr></table></figure><h3 id="conds-样品跳过条-样本数量"><a href="#conds-样品跳过条-样本数量" class="headerlink" title="conds 样品跳过条(样本数量)"></a><strong>conds</strong> 样品跳过条(样本数量)</h3><p>后端另一个常见的查询是，当解码器想要跳过一定数量的样本时，而不管样本值是什么(因为它们与当前的协议无关)。<br>这可以通过条件dict中的一个特殊键来实现— ‘<strong>skip’</strong> 。 ‘<strong>skip’</strong> 键的值是要跳过的样本的整数。</p><p>解码器也可以跳过一定的时间，通过使用采样来计算 ‘<strong>skip’</strong> 键的正确值。</p><p><strong>Examples:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Skip over the next 100 samples.</span><br>pins = self.wait(&#123;<span class="hljs-string">&#x27;skip&#x27;</span>: <span class="hljs-number">100</span>&#125;)<br><br><span class="hljs-comment"># Skip over the next 20ms of samples.</span><br>pins = self.wait(&#123;<span class="hljs-string">&#x27;skip&#x27;</span>: <span class="hljs-number">20</span> * (<span class="hljs-number">1000</span> / self.samplerate)&#125;)<br><br><span class="hljs-comment"># Skip half a bitwidth of samples (e.g. for UART).</span><br>self.halfbitwidth = <span class="hljs-built_in">int</span>((self.samplerate / self.options[<span class="hljs-string">&#x27;baudrate&#x27;</span>]) / <span class="hljs-number">2.0</span>)<br>pins = self.wait(&#123;<span class="hljs-string">&#x27;skip&#x27;</span>: self.halfbitwidth&#125;)<br></code></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">pins = self.wait(&#123;<span class="hljs-string">&#x27;skip&#x27;</span>: <span class="hljs-number">100</span>&#125;)  <span class="hljs-comment">#这里的pins是元组，</span><br>(pins,) = self.wait(&#123;<span class="hljs-string">&#x27;skip&#x27;</span>: <span class="hljs-number">100</span>&#125;)<span class="hljs-comment">#可以写成这样</span><br></code></pre></td></tr></table></figure><h1 id="self-skip"><a href="#self-skip" class="headerlink" title="self.skip()"></a>self.skip()</h1><p><strong>这个函数不知道怎么回事，用了会报错</strong></p><p>注意这下面的skip不是wait</p><p>在相同的条件下混合通道索引键和“跳过”键通常没有多大意义，然而，在不同的情况下，混合索引键和“跳过”键是非常合理的: </p><p>（下面的语句应该是  <code>((pin7 e)和(pin12 l))或(skip 10000)</code> ）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Wait until there&#x27;s</span><br><span class="hljs-comment"># a) an edge on pin 7 and a low state on pin 12, and/or</span><br><span class="hljs-comment"># b) 1000 samples passed by,</span><br><span class="hljs-comment"># whichever occurs first (both conditions could occur at the same time too).</span><br><span class="hljs-comment"># This is basically &quot;wait for an edge on pin 7 and a low state on pin 12,</span><br><span class="hljs-comment"># with a timeout of 1000 samples&quot;.</span><br>pins = self.skip((&#123;<span class="hljs-number">7</span>: <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-number">12</span>: <span class="hljs-string">&#x27;l&#x27;</span>&#125;, &#123;<span class="hljs-string">&#x27;skip&#x27;</span>: <span class="hljs-number">1000</span>&#125;))<br></code></pre></td></tr></table></figure><h1 id="self-matched"><a href="#self-matched" class="headerlink" title="self.matched"></a>self.matched</h1><p>当解码器通过<strong>self.wait（）</strong>请求前端等待多个条件时，当该调用返回时，PD仅知道<strong>至少一个</strong>条件已匹配。但是，在大多数情况下，它还需要知道<strong>哪些</strong>条件匹配（或不匹配）。</p><p>这是<strong>self.matched</strong>提供的信息。它是布尔值（<strong>True</strong>或<strong>False</strong>）的元组，始终包含与上次<strong>self.wait（）</strong>调用中存在的条件一样多的条目。对于每个条件，各自的布尔值表示此特定条件是否匹配。</p><p><strong>Example:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 等待，直到引脚9的上升边 或 引脚27的高状态(逻辑1)， 或 经过一定的“时间”(这里:跳过1000个样本)。这意味着有一个1000个样本的“超时”之后self.wait()将返回(不管其他条件如何)。</span><br>pins = self.wait([&#123;<span class="hljs-number">9</span>: <span class="hljs-string">&#x27;r&#x27;</span>&#125;, &#123;<span class="hljs-number">27</span>: <span class="hljs-string">&#x27;h&#x27;</span>&#125;, &#123;<span class="hljs-string">&#x27;skip&#x27;</span>: <span class="hljs-number">1000</span>&#125;])<br><br><span class="hljs-keyword">if</span> self.matched == (<span class="hljs-literal">True</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>):<br>    <span class="hljs-comment"># 前两个条件是同时匹配的。</span><br>    <span class="hljs-comment"># Pin 9 contains a rising edge and pin 27 is high.</span><br><span class="hljs-keyword">elif</span> self.matched == (<span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>):<br>    <span class="hljs-comment"># Rising edge on pin 9, pin 27 is guaranteed to not be high.</span><br><span class="hljs-keyword">elif</span> self.matched == (<span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>):<br>    <span class="hljs-comment"># Pin 27 is high, pin 9 is guaranteed to not be a rising edge.</span><br><span class="hljs-keyword">elif</span> self.matched == (<span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>):<br>    <span class="hljs-comment"># Pin 9 is not a rising edge, pin 27 is not high, but 1000 samples were skipped.</span><br><span class="hljs-keyword">elif</span> self.matched == (<span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">True</span>):<br>    <span class="hljs-comment"># Pin 9 is not a rising edge, pin 27 is high, and it just so happens that</span><br>    <span class="hljs-comment"># exactly 1000 samples were skipped.</span><br><span class="hljs-keyword">elif</span> self.matched == (<span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>):<br>    <span class="hljs-comment"># Bug, this cannot happen. self.wait() only returns upon &gt;= 1 matches.</span><br></code></pre></td></tr></table></figure><p>对于’skip’键&#x2F;值对self。如果达到指定数目的样本，则匹配的tuple将包含一个真值。 </p><p><strong>Example:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Wait for a falling edge on channel 18, or until 25000 samples passed by.</span><br>pins = self.wait([&#123;<span class="hljs-number">18</span>: <span class="hljs-string">&#x27;f&#x27;</span>&#125;, &#123;<span class="hljs-string">&#x27;skip&#x27;</span>: <span class="hljs-number">25000</span>&#125;])<br><br><span class="hljs-keyword">if</span> self.matched[<span class="hljs-number">0</span>]:<br>    <span class="hljs-comment"># Pin 18 has a falling edge.</span><br><span class="hljs-keyword">if</span> self.matched[<span class="hljs-number">1</span>]:<br>    <span class="hljs-comment"># 25000 samples were skipped.</span><br></code></pre></td></tr></table></figure><h1 id="self-samplenum"><a href="#self-samplenum" class="headerlink" title="self.samplenum"></a>self.samplenum</h1><p><em>self.samplenum 相当于一个指针，指示当前解码器解码的样本的位置</em></p><p> <strong>self.samplenum</strong>是一个特殊属性，对于协议解码器来说是只读的，并且只能由libsigrokdecode后端设置。 </p><p> <strong>self.samplenum</strong> 总是在最后一次self.wait()调用返回后的当前绝对样本号(从0开始)。 </p><h1 id="self-samplerate"><a href="#self-samplerate" class="headerlink" title="self.samplerate"></a>self.samplerate</h1><p>采样率</p><h1 id="self-has-channel"><a href="#self-has-channel" class="headerlink" title="self.has_channel"></a>self.has_channel</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#code1 </span><br>...<br>self.have_cs = self.has_channel(<span class="hljs-number">3</span>)<br>...<br><br><span class="hljs-comment">#code2</span><br>...<br><span class="hljs-keyword">if</span> self.have_cs <span class="hljs-keyword">and</span> (first <span class="hljs-keyword">or</span> (self.matched &amp; (<span class="hljs-number">0b1</span> &lt;&lt; self.have_cs))):<br>    ....<br>...<br></code></pre></td></tr></table></figure><p>self.has_channel返回的值似乎是对应通道的值，比如这里返回的应该是3.</p><h1 id="一些奇怪的问题"><a href="#一些奇怪的问题" class="headerlink" title="一些奇怪的问题"></a>一些奇怪的问题</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">xxxxx</span>(<span class="hljs-params">self</span>):<br>    logging.info(<span class="hljs-string">&#x27;----- xxx start -----&#x27;</span>)<br>    data = <span class="hljs-number">0</span><br>    bit_count = <span class="hljs-number">5</span><br><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        pin_state = self.wait( [&#123;<span class="hljs-number">0</span>: <span class="hljs-string">&#x27;r&#x27;</span>&#125;, &#123;<span class="hljs-string">&#x27;skip&#x27;</span>: self.freq_half_samp &#125;] )<br>        <span class="hljs-keyword">if</span>( self.matched &amp; (<span class="hljs-number">0b1</span> &lt;&lt; <span class="hljs-number">0</span>) ):        <span class="hljs-comment">#r</span><br>            self.LS_2 |= <span class="hljs-number">0b0</span> &lt;&lt; bit_count<br>            self.wait( [&#123;<span class="hljs-string">&#x27;skip&#x27;</span>: (self.bit_samp-self.freq_quarter_samp) &#125;] )<br>        <span class="hljs-keyword">else</span>:<br>            self.LS_2 |= <span class="hljs-number">0b1</span> &lt;&lt; bit_count<br>            self.wait( [&#123;<span class="hljs-string">&#x27;skip&#x27;</span>: (self.bit_samp-self.freq_half_samp) &#125;] )<br>        <span class="hljs-keyword">if</span>( bit_count == <span class="hljs-number">0</span> ):<br>            <span class="hljs-keyword">break</span><br>        bit_count -= <span class="hljs-number">1</span><br>    logging.info(<span class="hljs-string">&#x27;----- xxx end -----&#x27;</span>)<br>    <span class="hljs-keyword">return</span> data<br><br><br></code></pre></td></tr></table></figure><p>注意到<code>pin_state = self.wait( [&#123;0: &#39;r&#39;&#125;, &#123;&#39;skip&#39;: self.freq_half_samp &#125;] )</code>语句，把pin_state删掉就可以正常运行，若没删if后面的self.wait就会一直出问题。</p><ul><li>原因应该是pin_state没打括号，pin_state变成了元组，所以出现这种情况</li></ul><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="一些快速处理数据的方法"><a href="#一些快速处理数据的方法" class="headerlink" title="一些快速处理数据的方法"></a>一些快速处理数据的方法</h2><ul><li>快速计算奇偶校验</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ones = <span class="hljs-built_in">bin</span>(<span class="hljs-number">0x55</span>).count(<span class="hljs-string">&#x27;1&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li>BCD转成整数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">bcd2int</span>(<span class="hljs-params">b</span>):<br>    <span class="hljs-keyword">return</span> (b &amp; <span class="hljs-number">0x0f</span>) + ((b &gt;&gt; <span class="hljs-number">4</span>) * <span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><ul><li>一种将总线引脚序列转换为数字值的好方法：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">reduce_bus</span>(<span class="hljs-params">bus</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-number">0xFF</span> <span class="hljs-keyword">in</span> bus:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span> <span class="hljs-comment"># unassigned bus channels</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> reduce(<span class="hljs-keyword">lambda</span> a, b: (a &lt;&lt; <span class="hljs-number">1</span>) | b, <span class="hljs-built_in">reversed</span>(bus))<br></code></pre></td></tr></table></figure><ul><li>根据协议命令构造方法名的一个好方法是(假设cmd是8，这将调用self.handle_cmd_0x08函数):</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">fn = <span class="hljs-built_in">getattr</span>(self, <span class="hljs-string">&#x27;handle_cmd_0x%02x&#x27;</span> % cmd);<br>fn(arg1, arg2, ...)<br></code></pre></td></tr></table></figure><ul><li>一种处理Python缺少枚举类型(对状态、pin索引、注释索引等有用)的方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cycle</span>:<br>    NONE, MEMRD, MEMWR, IORD, IOWR, FETCH, INTACK = <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DSlogic</tag>
      
      <tag>逻辑分析仪</tag>
      
      <tag>Pyhton</tag>
      
      <tag>decoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>J-Link RTT的使用方法</title>
    <link href="/2022/18d811b/"/>
    <url>/2022/18d811b/</url>
    
    <content type="html"><![CDATA[<h1 id="J-Link-RTT-amp-JTrace"><a href="#J-Link-RTT-amp-JTrace" class="headerlink" title="J-Link RTT &amp; JTrace"></a>J-Link RTT &amp; JTrace</h1><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>Jlink可用直接输出调试信息，省去串口工具（配置麻烦+硬件接线乱+占用IO）</p><p>Jlink输出调试信息有两种</p><ul><li>Jlink的Trace</li><li>Jlink的RTT (Real Time Transfer)</li></ul><h2 id="Jlink-Trace"><a href="#Jlink-Trace" class="headerlink" title="Jlink Trace"></a>Jlink Trace</h2><hr><p>！！！待完善！！！</p><hr><p>MDK 环境下：</p><p><img src="/2022/18d811b/132307095276873.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ITM_Port8(n)    (*((volatile unsigned char *)(0xE0000000+4*n)))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ITM_Port16(n)   (*((volatile unsigned short*)(0xE0000000+4*n)))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ITM_Port32(n)   (*((volatile unsigned long *)(0xE0000000+4*n)))</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEMCR           (*((volatile unsigned long *)(0xE000EDFC)))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TRCENA          0x01000000</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fputc</span><span class="hljs-params">(<span class="hljs-type">int</span> ch, FILE *f)</span> <br>&#123;<br>  <span class="hljs-keyword">if</span> (DEMCR &amp; TRCENA) &#123;<br>    <span class="hljs-keyword">while</span> (ITM_Port32(<span class="hljs-number">0</span>) == <span class="hljs-number">0</span>);<br>    ITM_Port8(<span class="hljs-number">0</span>) = ch;<br>  &#125;<br>  <span class="hljs-keyword">return</span>(ch);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="RTT"><a href="#RTT" class="headerlink" title="RTT"></a>RTT</h2><p><a href="https://www.segger.com/products/debug-probes/j-link/technology/about-real-time-transfer/">Jlink RTT 官网资料</a></p><p>RTT其实原理就是读取RAM上某个Buff的数据，这个Buff可以通过RTT的CB(control block)找到。</p><h3 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h3><p>下载Jlink的工具后，安装后程序目录有Samples文件夹(default: C:\Program Files\SEGGER\JLink\Samples)，文件夹内就有RTT的源码。</p><ol><li>将源码的<code>RTT/</code>目录下 <code>SEGGER_RTT_Printf.c</code>  <code>SEGGER_RTT.c</code> 两个文件添加到工程里，并解决头文件包含问题。</li><li>看 <code>Examples/</code>目录下就有使用历程，移植到你的工程就好。可以参考<code>Main_RTT_InputEchoApp.c</code>和<code>Main_RTT_PrintfTest.c</code>。</li><li>打开 <code>J-Link RTT Viewer</code>软件，选择<code>Device</code>，输入<code>RTT Control Block</code>的地址connect即可。<ol><li><code>RTT Control Block</code>的地址可以输入RAM的范围让<code>J-Link RTT Viewer</code>软件自己去搜索。</li><li>也可手动输入，而RTT_V754a的<code>RTT Control Block</code>是<code>_SEGGER_RTT</code> 在<code> file:SEGGER_RTT.c line:279</code>。<img src="/2022/18d811b/image-20210917214218565.png" alt="image-20210917214218565"></li></ol></li><li>一顿操作下来正常就可以收到数据了。</li></ol><h3 id="RTT-源码"><a href="#RTT-源码" class="headerlink" title="RTT 源码"></a>RTT 源码</h3><h4 id="Included-files"><a href="#Included-files" class="headerlink" title="Included files"></a>Included files</h4><ul><li><code>RTT/</code><ul><li><code>SEGGER_RTT.c</code>               - RTT的主要模块。</li><li><code>SEGGER_RTT.h</code>               - RTT的主要模块。</li><li><code>SEGGER_RTT_ASM_ARMv7M.S</code>    - ARMv7M 的优化实现</li><li><code>SEGGER_RTT_Printf.c</code>        - (‘ SEGGER_RTT_Printf() ‘)的简单实现。</li></ul></li><li><code>Syscalls/</code><ul><li><code>SEGGER_RTT_Syscalls_*.c</code>    - <code>printf()</code> 重定向</li></ul></li><li><code>Config/</code><ul><li><code>SEGGER_RTT_Conf.h</code>          - RTT配置文件。</li></ul></li><li><code>Examples/</code><ul><li><code>Main_RTT_InputEchoApp.c</code>    - Example application which echoes input on Channel 0.</li><li><code>Main_RTT_MenuApp.c</code>         - Example application to demonstrate RTT bi-directional functionality.</li><li><code>Main_RTT_PrintfTest.c</code>      - Example application to test RTT’s simple printf implementation.</li><li><code>Main_RTT_SpeedTestApp.c</code>    - Example application to measure RTT performance. (Requires embOS)</li></ul></li></ul><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><table><thead><tr><th align="center">函数名称</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">SEGGER_RTT_Read()</td><td align="center">从输入缓冲区读取数据。</td></tr><tr><td align="center">SEGGER_RTT_Write()</td><td align="center">将数据写入输出缓冲区。</td></tr><tr><td align="center">SEGGER_RTT_WriteString()</td><td align="center">将\0结尾字符串写入输出缓冲区。</td></tr><tr><td align="center">SEGGER_RTT_printf()</td><td align="center">将格式化的字符串写入输出缓冲区。</td></tr><tr><td align="center">SEGGER_RTT_GetKey()</td><td align="center">从输入缓冲区 0 中获取一个字符。</td></tr><tr><td align="center">SEGGER_RTT_HasKey()</td><td align="center">检查输入缓冲区 0 中是否有字符可用。</td></tr><tr><td align="center">SEGGER_RTT_WaitKey()</td><td align="center">等待输入缓冲区 0 中的字符可用并获取它。</td></tr><tr><td align="center">SEGGER_RTT_ConfigUpBuffer()</td><td align="center">配置向上（输出）缓冲区。</td></tr><tr><td align="center">SEGGER_RTT_ConfigDownBuffer()</td><td align="center">配置向下（输入）缓冲区。</td></tr><tr><td align="center">SEGGER_RTT_Init()</td><td align="center">仅使用 RAM 目标时初始化 RTT 控制块结构。</td></tr><tr><td align="center">SEGGER_RTT_SetTerminal()</td><td align="center">将“虚拟”终端设置为通过 Write 和 WriteString 用于通道 0 上的输出。</td></tr><tr><td align="center">SEGGER_RTT_TerminalOut()</td><td align="center">通过“虚拟”终端发送以\0结尾的字符串。</td></tr></tbody></table><h3 id="RTT-软件"><a href="#RTT-软件" class="headerlink" title="RTT 软件"></a>RTT 软件</h3><p><img src="/2022/18d811b/image-20210918101414512.png" alt="image-20210918101414512"></p><ul><li><p><code>J-Link RTT Viewer</code>软件用的比较多</p></li><li><p><code>J-Link RTT Logger</code>软件可以将输出的数据保存到文件，并显示通信速率和通信数据量。</p></li><li><p><code>J-Link RTT Client</code>可以在调试的时候，充当客户端，输出数据。据说支持中文</p></li></ul><h3 id="note："><a href="#note：" class="headerlink" title="note："></a>note：</h3><ul><li>程序如果跑在RAM中，J-Link可能会错误地识别出init部分中的块，而不是数据部分中的实际块。为了防止这种情况，将SEGGER_RTT_IN_RAM的定义设置为1。现在，J-Link将在应用程序中调用第一个SEGGER_RTT函数之后找到正确的RTT缓冲区。建议在应用程序开始时调用SEGGER_RTT_Init()。</li></ul><h4 id="不同通道输出数据"><a href="#不同通道输出数据" class="headerlink" title="不同通道输出数据"></a>不同通道输出数据</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">SEGGER_RTT_TerminalOut(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;SEGGER_RTT_TerminalOut 0\r\n&quot;</span>);<br>SEGGER_RTT_TerminalOut(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;SEGGER_RTT_TerminalOut 1\r\n&quot;</span>);<br>SEGGER_RTT_TerminalOut(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;SEGGER_RTT_TerminalOut 2\r\n&quot;</span>);<br><br><br><br>SEGGER_RTT_SetTerminal(<span class="hljs-number">0</span>);<br>SEGGER_RTT_printf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;SEGGER_RTT_printf 0\r\n&quot;</span>);<br>SEGGER_RTT_SetTerminal(<span class="hljs-number">1</span>);<br>SEGGER_RTT_printf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;SEGGER_RTT_printf 1\r\n&quot;</span>);<br>SEGGER_RTT_SetTerminal(<span class="hljs-number">2</span>);<br>SEGGER_RTT_printf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;SEGGER_RTT_printf 2\r\n&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="输出带颜色的字符"><a href="#输出带颜色的字符" class="headerlink" title="输出带颜色的字符"></a>输出带颜色的字符</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Control sequences, based on ANSI.</span><br><span class="hljs-comment">// Can be used to control color, and clear the screen</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_RESET                <span class="hljs-string">&quot;\x1B[0m&quot;</span>         <span class="hljs-comment">// Reset to default colors</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_CLEAR                <span class="hljs-string">&quot;\x1B[2J&quot;</span>         <span class="hljs-comment">// Clear screen, reposition cursor to top left</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_BLACK           <span class="hljs-string">&quot;\x1B[2;30m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_RED             <span class="hljs-string">&quot;\x1B[2;31m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_GREEN           <span class="hljs-string">&quot;\x1B[2;32m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_YELLOW          <span class="hljs-string">&quot;\x1B[2;33m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_BLUE            <span class="hljs-string">&quot;\x1B[2;34m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_MAGENTA         <span class="hljs-string">&quot;\x1B[2;35m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_CYAN            <span class="hljs-string">&quot;\x1B[2;36m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_WHITE           <span class="hljs-string">&quot;\x1B[2;37m&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_BRIGHT_BLACK    <span class="hljs-string">&quot;\x1B[1;30m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_BRIGHT_RED      <span class="hljs-string">&quot;\x1B[1;31m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_BRIGHT_GREEN    <span class="hljs-string">&quot;\x1B[1;32m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_BRIGHT_YELLOW   <span class="hljs-string">&quot;\x1B[1;33m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_BRIGHT_BLUE     <span class="hljs-string">&quot;\x1B[1;34m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_BRIGHT_MAGENTA  <span class="hljs-string">&quot;\x1B[1;35m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_BRIGHT_CYAN     <span class="hljs-string">&quot;\x1B[1;36m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_BRIGHT_WHITE    <span class="hljs-string">&quot;\x1B[1;37m&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_BLACK             <span class="hljs-string">&quot;\x1B[24;40m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_RED               <span class="hljs-string">&quot;\x1B[24;41m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_GREEN             <span class="hljs-string">&quot;\x1B[24;42m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_YELLOW            <span class="hljs-string">&quot;\x1B[24;43m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_BLUE              <span class="hljs-string">&quot;\x1B[24;44m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_MAGENTA           <span class="hljs-string">&quot;\x1B[24;45m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_CYAN              <span class="hljs-string">&quot;\x1B[24;46m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_WHITE             <span class="hljs-string">&quot;\x1B[24;47m&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_BRIGHT_BLACK      <span class="hljs-string">&quot;\x1B[4;40m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_BRIGHT_RED        <span class="hljs-string">&quot;\x1B[4;41m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_BRIGHT_GREEN      <span class="hljs-string">&quot;\x1B[4;42m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_BRIGHT_YELLOW     <span class="hljs-string">&quot;\x1B[4;43m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_BRIGHT_BLUE       <span class="hljs-string">&quot;\x1B[4;44m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_BRIGHT_MAGENTA    <span class="hljs-string">&quot;\x1B[4;45m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_BRIGHT_CYAN       <span class="hljs-string">&quot;\x1B[4;46m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_BRIGHT_WHITE      <span class="hljs-string">&quot;\x1B[4;47m&quot;</span></span><br><br><br>SEGGER_RTT_WriteString(<span class="hljs-number">0</span>,RTT_CTRL_RESET<span class="hljs-string">&quot;Red: &quot;</span>\<br>                       RTT_CTRL_TEXT_RED<span class="hljs-string">&quot;This text is red.&quot;</span>\<br>                       RTT_CTRL_BG_BRIGHT_GREEN<span class="hljs-string">&quot;This background is green.\r\n&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="输入字符"><a href="#输入字符" class="headerlink" title="输入字符"></a>输入字符</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(SEGGER_RTT_HasKey())<br>&#123;<br>    <span class="hljs-type">char</span> r = SEGGER_RTT_GetKey();<br>    SEGGER_RTT_WriteString(<span class="hljs-number">0</span>,<span class="hljs-string">&quot;input:%c\r\n&quot;</span>, r);<br>&#125;<br><br><br><span class="hljs-keyword">if</span>(SEGGER_RTT_HasKey())<br>&#123;<br>    ReadNum = SEGGER_RTT_Read(<span class="hljs-number">0</span>,&amp;acIn[<span class="hljs-number">0</span>], <span class="hljs-keyword">sizeof</span>(acIn));<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">20</span>;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">0x0A</span> != acIn[i])<br>        &#123;<br>            ReadNum++;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    SEGGER_RTT_Write(<span class="hljs-number">0</span>,acIn,ReadNum);<br>    ReadNum=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(acIn,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(acIn));<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>J-Link</tag>
      
      <tag>Jlink</tag>
      
      <tag>RTT</tag>
      
      <tag>Serial</tag>
      
      <tag>Debug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SourceInsigh中Qicker的使用</title>
    <link href="/2022/4ade0b2f/"/>
    <url>/2022/4ade0b2f/</url>
    
    <content type="html"><![CDATA[<h1 id="Qicker-em"><a href="#Qicker-em" class="headerlink" title="Qicker.em"></a>Qicker.em</h1><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ol><li><p>代码补全：</p><ul><li><p>wh：       while（）</p></li><li><p>if，ife，ifs：     if，if else， if elseif else</p></li><li><p>for：      for</p></li><li><p>fo：自动生成for语句与for命令相比它直接会定义循环变量</p></li></ul>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> ( ulI = <span class="hljs-number">0</span>; ulI &lt; # ; ulI++ )<br>&#123;<br>    UINT32_T ulI = <span class="hljs-number">0</span>;<br>    #<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>do: do while</li><li>switch：</li><li>case：</li><li>#ifd: #ifdef</li><li>#if：</li><li>cpp ：自动生成适用于c++的c原型说明定义</li><li>struct：</li><li>enum：</li></ul></li><li><p>添加文件头注释： 命令：fi 解释：file  </p></li><li><p>添加函数头注释（.h）： 命令：fi 解释：file </p></li><li><p>增加修改历史列表： 命令：hi （会报错）</p></li><li><p>根据（.c）生成（.h）文件：命令：hdn</p></li><li><p>添加函数说明注释： 命令：fu 解释： function  </p></li><li><p>添加单行注释：（<span style="color:red">不知道为什么没用</span>）</p><ul><li>命令：as 解释： add start    (添加之后 <code>/* add by zhangsan, 20140504, Mantis号:d, 原: */</code> ) </li><li>命令：ms 解释： modify start  (添加之后：<code>/ modify by zhangsan, 20140504, Mantis号:d, 原因: */</code>  ) </li><li>命令：ds 解释： delete start  (添加之后：<code>/ delete by zhangsan, 20140504, Mantis号:d, 原因: */</code>  )</li></ul></li><li><p>添加标记注释： </p><ul><li><p>命令：ab 解释： add begin    (添加之后：<code>/* add begin by zhangsan, 20140504, Mantis号:d 原因: */</code>) </p></li><li><p>命令：mb 解释： modify begin  (添加之后：<code>/* modify begin by zhangsan, 20140504, Mantis号:d 原因: */</code>) </p></li><li><p>命令：me 解释： modify end    (添加之后：<code>/* modify end by zhangsan, 20140504 */</code>)  </p></li><li><p>命令：db 解释： delete begin  (添加之后：<code>/* delete begin by zhangsan, 20140504, Mantis号:d 原因: */</code>) </p></li><li><p>命令：de 解释： delete end    (添加之后：<code>/* delete end by zhangsan, 20140504 */</code>)</p></li></ul></li><li><p>配置命令：</p></li></ol><ul><li>命令：co 解释：config （修改相关配置信息）</li></ul><p> 如何使用呢，以为整个文件添加注释为例，在源文件的任何地方输入命令 fi 之后直接按ctrl + enter(配置的快捷键)即可。</p><h2 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h2><p> source insight有很多宏可以用，这里介绍的宏是quicker.em这个宏，它是华为的一个员工写的，很实用。</p><ol><li><p>安装quicker.em宏</p><ul><li><p>打开base这个工程Project-&gt;Open Project，选择base工程，即可打开；</p></li><li><p>将宏文件quicker.em添加到该base工程中；</p></li><li><p>设置宏的快捷方式：Options-&gt;Key Assignments，找到Marco:AutoExpand,添加快捷键即可，一般推介用Ctrl+Enter组合键。</p></li></ul></li><li><p>HeaderFileCreate，这个宏功能用于自动创建一个.c文件的头文件。</p><p>使用方法：</p><ul><li>创建自定义快捷菜单Options-&gt;Menu Assignments，选择Macro:HeaderFileCreate这一项，将它添加到右边Menu项的Work下，然后点Insert插入，点OK即可。</li><li>打开该.c文件，在work栏就能看到我们刚才添加的自定义快捷菜单HeaderFileCreate，点击它，就自动生产头文件了。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SourceInsigh</tag>
      
      <tag>SI</tag>
      
      <tag>IDE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Visual Studio</title>
    <link href="/2022/9be43835/"/>
    <url>/2022/9be43835/</url>
    
    <content type="html"><![CDATA[<h1 id="VSCode"><a href="#VSCode" class="headerlink" title="VSCode"></a>VSCode</h1><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul><li>格式化代码 【Shift】+【Alt】+F</li></ul><h2 id="多行编辑"><a href="#多行编辑" class="headerlink" title="多行编辑"></a>多行编辑</h2><ul><li><p><code>Ctrl+Alt+UpArrow</code> <code>Ctrl+Alt+DownArrow</code></p></li><li><p><code>Alt+Click</code> 鼠标点击多行编辑</p></li><li><p><code>Ctrl+Shift+L</code> 对应文本多行编辑</p></li></ul><h2 id="行操作"><a href="#行操作" class="headerlink" title="行操作"></a>行操作</h2><ul><li><code>Shift+Alt+UpArrow</code> <code>Shift+Alt+DownArrow</code> 复制当前行</li><li><code>Alt+UpArrow</code> <code>Alt+DownArrow</code> 移动当前行</li></ul><h2 id="工作区配置"><a href="#工作区配置" class="headerlink" title="工作区配置"></a>工作区配置</h2><h3 id="setting-json"><a href="#setting-json" class="headerlink" title="setting.json"></a>setting.json</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;files.exclude&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;**/out/**&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>    <span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="c-cpp-properties-json"><a href="#c-cpp-properties-json" class="headerlink" title="c_cpp_properties.json"></a>c_cpp_properties.json</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;configurations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Linux&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;includePath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;browse&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;limitSymbolsToIncludedHeaders&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;databaseFilename&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceRoot&#125;/.vscode/.browse.c_cpp.db&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;path&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                    <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span><br>                <span class="hljs-punctuation">]</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;defines&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;IN_PTCMD&quot;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;compilerPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/usr/bin/gcc&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;cStandard&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;gnu17&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;cppStandard&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;gnu++14&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;intelliSenseMode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;linux-gcc-x64&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;configurationProvider&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ms-vscode.makefile-tools&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">4</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><h2 id="无法goto-define"><a href="#无法goto-define" class="headerlink" title="无法goto define"></a>无法goto define</h2><p>VSCode 不知道是什么设置问题，在使用跳转功能时，经常只能跳转到头文件，使用 <code>Go to References</code> 也找不到定义位置，搞得索引起来很麻烦。</p><p>切换成 <code>C++ Intellisense</code> 后，发现可以得到不错的效果。<br><img src="/2022/9be43835/watermark.png" alt="在这里插入图片描述"><br>在安装过程中，需要注意以下事项：<br>【1】 需要 <code>GNU Global</code>(&gt;&#x3D;6.5) 的依赖项并添加进路径中。可以通过以下方式安装：</p><blockquote><p>  sudo apt install global</p></blockquote><p>安装之后可使用以下命令确认是否成功：</p><blockquote><p>  global –version<br>  <img src="/2022/9be43835/11f3ab43797b44d9a9746b0676881339.png" alt="在这里插入图片描述"></p></blockquote><p>【2】在 C&#x2F;C++ 项目的工作空间文件夹，运行以下命令：</p><blockquote><p>  gtags</p></blockquote><p>这将会产生下列三个文件：<code>GTAGS</code>, <code>GRTAGS</code>, <code>GPATHS</code>。 如果代码有修改，再次运行 <code>gtags</code> 来更新这些 tag 文件。</p>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VSCode</tag>
      
      <tag>IDE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手动添加JLink不支持的芯片</title>
    <link href="/2022/30f8332a/"/>
    <url>/2022/30f8332a/</url>
    
    <content type="html"><![CDATA[<h1 id="手动添加JLink不支持的芯片"><a href="#手动添加JLink不支持的芯片" class="headerlink" title="手动添加JLink不支持的芯片"></a>手动添加JLink不支持的芯片</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>市场上的新芯片层出不穷，JLink的官方支持不可能完全跟得上，这就尴尬了。但是好在Segger在设计时就想到了这一点，允许用户自己添加新芯片或扩展官方已经支持的芯片。本文只讲如何添加新芯片，参考的资料为<code>UM08001_JLink.pdf</code>中的第12章——<code>Open Flashloader</code>。</p><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p>在添加前，JFlash里找不到BARROT的任何型号，</p><p>添加后如下图</p><p><img src="/2022/30f8332a/image-20211019164827957.png" alt="image-20211019164827957"></p><h2 id="添加方法"><a href="#添加方法" class="headerlink" title="添加方法"></a>添加方法</h2><ul><li><p>找到Jlink安装目录下的<code>JLinkDevices.xml</code>并打开；</p></li><li><p>默认位置<code>C:\Program Files\SEGGER\JLink</code></p><p>在打开的文件添加如下内容，因为这个文件里没有任何BARROT的芯片，所以我添加到文件末尾，如果文件已经有同厂家的其它芯片，建议还是放一起，方便维护。效果和代码放下面了，代码的解释在后面！</p><p><img src="/2022/30f8332a/image-20211019164859196.png" alt="image-20211019164859196"></p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--                  --&gt;</span><br><span class="hljs-comment">&lt;!-- BARROT (BR8551) --&gt;</span><br><span class="hljs-comment">&lt;!--                  --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Device</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">ChipInfo</span> <span class="hljs-attr">Vendor</span>=<span class="hljs-string">&quot;BARROT&quot;</span> <span class="hljs-attr">Name</span>=<span class="hljs-string">&quot;BR8551&quot;</span> <span class="hljs-attr">Core</span>=<span class="hljs-string">&quot;JLINK_CORE_CORTEX_M3&quot;</span> <span class="hljs-attr">WorkRAMAddr</span>=<span class="hljs-string">&quot;0x2000C000&quot;</span> <span class="hljs-attr">WorkRAMSize</span>=<span class="hljs-string">&quot;0x00004000&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">FlashBankInfo</span> <span class="hljs-attr">Name</span>=<span class="hljs-string">&quot;ROM&quot;</span> <span class="hljs-attr">BaseAddr</span>=<span class="hljs-string">&quot;0x00000000&quot;</span> <span class="hljs-attr">MaxSize</span>=<span class="hljs-string">&quot;0x00060000&quot;</span> <span class="hljs-attr">Loader</span>=<span class="hljs-string">&quot;D:\\Project\\Panda\\Code\\bamboo\\panda\\tools\\Keil\\VFlash.FLM&quot;</span> <span class="hljs-attr">LoaderType</span>=<span class="hljs-string">&quot;FLASH_ALGO_TYPE_OPEN&quot;</span> <span class="hljs-attr">AlwaysPresent</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">FlashBankInfo</span> <span class="hljs-attr">Name</span>=<span class="hljs-string">&quot;LR_IROM1&quot;</span> <span class="hljs-attr">BaseAddr</span>=<span class="hljs-string">&quot;0x10000000&quot;</span> <span class="hljs-attr">MaxSize</span>=<span class="hljs-string">&quot;0x00080000&quot;</span> <span class="hljs-attr">Loader</span>=<span class="hljs-string">&quot;D:\\Project\\Panda\\Code\\bamboo\\panda\\tools\\Keil\\VFlash.FLM&quot;</span> <span class="hljs-attr">LoaderType</span>=<span class="hljs-string">&quot;FLASH_ALGO_TYPE_OPEN&quot;</span> <span class="hljs-attr">AlwaysPresent</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Device</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>保存文件就添加完了，可以验证是否如文章开头的效果一样</li></ul></li></ul><h2 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h2><ul><li>最开始的三行是注释，注释嘛，随便写了，清晰明了就行；</li><li><code>&lt;Device&gt;</code>和<code>&lt;/Device&gt;</code>必须成对出现，而且没有属性表。每个（系列）芯片都对应着这么一对。</li><li><code>ChipInfo</code>是描述芯片的信息，必须在 <code>&lt;Device&gt;</code>和<code>&lt;/Device&gt;</code>内。</li></ul><table><thead><tr><th align="center">参数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Vendor</td><td align="center">芯片厂家的名字，比如这里的”BARROT”</td></tr><tr><td align="center">Name</td><td align="center">芯片的具体型号，我用的就是BR8551</td></tr><tr><td align="center">Core</td><td align="center">芯片的内核，这个必须是JLink支持的内核之一，具体的名字可以在文档里的12.5.3.1    Attribute values - Core章节找到。</td></tr><tr><td align="center">WorkRAMAddr</td><td align="center">芯片RAM的起始地址，这个可以在用户手册里找到，也可以打开SDK里的官方例程，然后在工程配置里找到</td></tr><tr><td align="center">WorkRAMSize</td><td align="center">芯片RAM的大小，同样可以在用户手册里找到，也可以打开SDK里的官方例程，然后在工程配置里找到</td></tr><tr><td align="center">Aliases</td><td align="center">同系列的相同RAM和FLASH的型号</td></tr><tr><td align="center">JLinkScriptFile</td><td align="center">高级用法，有些芯片操作比较特殊，可以通过脚本去实现，这里我用不上</td></tr></tbody></table><hr><ul><li><code>FlashBankInfo</code>描述芯片的Flash信息，有多块flash的话，每块对应一个<code>FlashBankInfo</code>。</li></ul><table><thead><tr><th align="center">参数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Name</td><td align="center">flash的名字，名字可以随便起</td></tr><tr><td align="center">BaseAddr</td><td align="center">flash的起始地址，可以在用户手册里找到</td></tr><tr><td align="center">MaxSize</td><td align="center">flash的大小，可以在用户手册里找到</td></tr><tr><td align="center">Loader</td><td align="center">烧录的算法，segger官方的是*.elf格式，*.flm是ARM的格式，keil里就用这个。这个路径可以是绝对地址也可以是相对地址，相对地址的话是从<code>JLinkDevices.xml</code>所在的路径为起始地址。</td></tr><tr><td align="center">LoaderType</td><td align="center">必须是12.5.4.1    Attribute values - LoaderType中列出的类型之一，目前只有FLASH_ALGO_TYPE_OPEN一个类型，而*.flm是支持这个类型的</td></tr><tr><td align="center">AlwaysPresent</td><td align="center">指示这个块flash是不是一直存在，本文是内部flash，当然一直存在</td></tr></tbody></table><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/d7fae221ac47">工欲善其事，必先利其器：动手给JLink添加官方不支持的芯片</a></p>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>J-Link</tag>
      
      <tag>Jlink</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2022/69c3279c/"/>
    <url>/2022/69c3279c/</url>
    
    <content type="html"><![CDATA[<h1 id="Git-Bref"><a href="#Git-Bref" class="headerlink" title="Git Bref"></a>Git Bref</h1><p><img src="/2022/69c3279c/1352126739_7909.jpg" alt="img"></p><ul><li><p><strong>工作区：</strong>就是你在电脑里能看到的目录。</p></li><li><p><strong>暂存区：</strong>英文叫 stage 或 index。一般存放在 <strong>.git</strong> 目录下的 index 文件（.git&#x2F;index）中，所以我们把暂存区有时也叫作索引（index）。</p></li><li><p><strong>版本库：</strong>工作区有一个隐藏目录 <strong>.git</strong>，这个不算工作区，而是 Git 的版本库。</p></li></ul><p><img src="/2022/69c3279c/git-command.jpg" alt="img"></p><ul><li>workspace：工作区</li><li>staging area：暂存区&#x2F;缓存区</li><li>local repository：版本库或本地仓库</li><li>remote repository：远程仓库</li></ul><h2 id="Git-Workflows"><a href="#Git-Workflows" class="headerlink" title="Git Workflows"></a>Git Workflows</h2><p><a href="https://www.atlassian.com/git/tutorials/comparing-workflows">https://www.atlassian.com/git/tutorials/comparing-workflows</a></p><h3 id="Centralized-集中工作流"><a href="#Centralized-集中工作流" class="headerlink" title="Centralized 集中工作流"></a>Centralized 集中工作流</h3><p><img src="/2022/69c3279c/01.svg" alt="git workflow | Central and local repositories"></p><h3 id="Feature-Branch-功能分支"><a href="#Feature-Branch-功能分支" class="headerlink" title="Feature Branch 功能分支"></a>Feature Branch 功能分支</h3><p><a href="https://www.atlassian.com/git/tutorials/comparing-workflows/feature-branch-workflow">https://www.atlassian.com/git/tutorials/comparing-workflows/feature-branch-workflow</a></p><h3 id="Gitflow"><a href="#Gitflow" class="headerlink" title="Gitflow"></a>Gitflow</h3><p><a href="https://nvie.com/posts/a-successful-git-branching-model/">https://nvie.com/posts/a-successful-git-branching-model/</a></p><p><img src="/2022/69c3279c/git-model@2x.png" alt="img"></p><p><img src="/2022/69c3279c/04-Hotfix-branches.svg" alt="Git 流程工作流 - 修补程序分支"></p><h3 id="Forking-分叉"><a href="#Forking-分叉" class="headerlink" title="Forking 分叉"></a>Forking 分叉</h3><p><a href="https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow">Forking Workflow</a>通常遵循基于<a href="https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow">Gitflow Workflow</a>的分支模型。这意味着完整的功能分支将用于合并到原始项目维护者的存储库中。结果是一个分布式工作流，它为大型有机团队（包括不受信任的第三方）安全地协作提供了一种灵活的方式。这也使其成为开源项目的理想工作流程。</p><h2 id="基本命令list"><a href="#基本命令list" class="headerlink" title="基本命令list"></a>基本命令list</h2><h3 id="创建仓库命令"><a href="#创建仓库命令" class="headerlink" title="创建仓库命令"></a>创建仓库命令</h3><p>下表列出了 git 创建仓库的命令：</p><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git init</code></td><td align="left">初始化仓库</td></tr><tr><td align="left"><code>git clone</code></td><td align="left">拷贝一份远程仓库，也就是下载一个项目。</td></tr></tbody></table><hr><h3 id="提交与修改"><a href="#提交与修改" class="headerlink" title="提交与修改"></a>提交与修改</h3><p>Git 的工作就是创建和保存你的项目的快照及与之后的快照进行对比。</p><p>下表列出了有关创建与提交你的项目的快照的命令：</p><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git add</code></td><td align="left">添加文件到仓库</td></tr><tr><td align="left"><code>git status</code></td><td align="left">查看仓库当前的状态，显示有变更的文件。</td></tr><tr><td align="left"><code>git diff</code></td><td align="left">比较文件的不同，即暂存区和工作区的差异。</td></tr><tr><td align="left"><code>git commit</code></td><td align="left">提交暂存区到本地仓库。</td></tr><tr><td align="left"><code>git reset</code></td><td align="left">回退版本。</td></tr><tr><td align="left"><code>git rm</code></td><td align="left">删除工作区文件。</td></tr><tr><td align="left"><code>git mv</code></td><td align="left">移动或重命名工作区文件。</td></tr></tbody></table><h3 id="提交日志"><a href="#提交日志" class="headerlink" title="提交日志"></a>提交日志</h3><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git log</code></td><td align="left">查看历史提交记录</td></tr><tr><td align="left"><code>git blame &lt;file&gt;</code></td><td align="left">以列表形式查看指定文件的历史修改记录</td></tr></tbody></table><h3 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h3><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git remote</code></td><td align="left">远程仓库操作</td></tr><tr><td align="left"><code>git fetch</code></td><td align="left">从远程获取代码库</td></tr><tr><td align="left"><code>git pull</code></td><td align="left">下载远程代码并合并</td></tr><tr><td align="left"><code>git push</code></td><td align="left">上传远程代码并合并</td></tr></tbody></table><h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><p><img src="/2022/69c3279c/Honeyview_Ey7f6ftXIAEOd8M.jpg" alt="Honeyview_Ey7f6ftXIAEOd8M"></p><h2 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h2><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>-d</td><td>–delete：删除</td></tr><tr><td>-D</td><td>–delete –force的快捷键</td></tr><tr><td>-f</td><td>–force：强制</td></tr><tr><td>-m</td><td>–move：移动或重命名</td></tr><tr><td>-M</td><td>–move –force的快捷键</td></tr><tr><td>-r</td><td>–remote：远程</td></tr><tr><td>-a</td><td>–all：所有</td></tr></tbody></table><h2 id="Git-配置"><a href="#Git-配置" class="headerlink" title="Git 配置"></a>Git 配置</h2><h3 id="查看配置"><a href="#查看配置" class="headerlink" title="查看配置"></a>查看配置</h3><p>列出当前配置：<code>git config --list</code></p><p>列出repository配置：<code>git config --local --list</code></p><p>列出全局配置：<code>git config --global --list</code></p><p>列出系统配置：<code>git config --system --list</code></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>配置用户名：<code>git config --global user.name &quot;your name&quot;</code></p><p>配置用户邮箱：<code>git config --global user.email &quot;youremail@github.com&quot;</code></p><p>修改默认branch名: <code>git config --global init.defaultBranch main</code></p><p>git走代理: <code>git config --global http.proxy &#39;socks5://127.0.0.1:1080&#39;</code></p><h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs \">ssh-keygen -t rsa -C &quot;youremail@github.com&quot;<br></code></pre></td></tr></table></figure><p>执行命令后需要进行3次或4次确认：</p><ol><li>确认秘钥的保存路径（如果不需要改路径则直接回车）；</li><li>如果上一步置顶的保存路径下已经有秘钥文件，则需要确认是否覆盖（如果之前的秘钥不再需要则直接回车覆盖，如需要则手动拷贝到其他目录后再覆盖）；</li><li>创建密码（如果不需要密码则直接回车）；</li><li>确认密码；</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> ~/.ssh/id_rsa.pub<br></code></pre></td></tr></table></figure><h2 id="Git命令"><a href="#Git命令" class="headerlink" title="Git命令"></a>Git命令</h2><h3 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h3><p>初始化版本库</p><h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> [--template=&lt;template_directory&gt;]<br>          [-l] [-s] [--no-hardlinks] [-q] [-n] [--bare] [--mirror]<br>          [-o &lt;name&gt;] [-b &lt;name&gt;] [-u &lt;upload-pack&gt;] [--reference &lt;repository&gt;]<br>          [--dissociate] [--separate-git-dir &lt;git <span class="hljs-built_in">dir</span>&gt;]<br>          [--depth &lt;depth&gt;] [--[no-]single-branch] [--no-tags]<br>          [--recurse-submodules[=&lt;pathspec&gt;]] [--[no-]shallow-submodules]<br>          [--[no-]remote-submodules] [--<span class="hljs-built_in">jobs</span> &lt;n&gt;] [--sparse] [--[no-]reject-shallow]<br>          [--filter=&lt;filter&gt;] [--] &lt;repository&gt;<br>          [&lt;directory&gt;]<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># git clone 后面接文件夹名可以修改clone到本地的文件夹名称</span><br>git <span class="hljs-built_in">clone</span> xxxx directory<br></code></pre></td></tr></table></figure><p>远程git仓库复制项目：<code>git clone &lt;url&gt;</code></p><h3 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h3><p><code>git log --graph --pretty=oneline --abbrev-commit</code>可以看到分支的合并情况，包括分支合并图(–graph)、一行显示(–pretty&#x3D;oneline)、提交校验码缩略(–abbrev-commit)显示：</p><table><thead><tr><th align="left">选项</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>-&lt;n&gt;</code></td><td align="left">仅显示最近的 n 条提交。</td></tr><tr><td align="left"><code>--since</code>, <code>--after</code></td><td align="left">仅显示指定时间之后的提交。</td></tr><tr><td align="left"><code>--until</code>, <code>--before</code></td><td align="left">仅显示指定时间之前的提交。</td></tr><tr><td align="left"><code>--author</code></td><td align="left">仅显示作者匹配指定字符串的提交。</td></tr><tr><td align="left"><code>--committer</code></td><td align="left">仅显示提交者匹配指定字符串的提交。</td></tr><tr><td align="left"><code>--grep</code></td><td align="left">仅显示提交说明中包含指定字符串的提交。</td></tr><tr><td align="left"><code>-S</code></td><td align="left">仅显示添加或删除内容匹配指定字符串的提交。</td></tr></tbody></table><h3 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h3><h3 id="git-blame"><a href="#git-blame" class="headerlink" title="git blame"></a>git blame</h3><p>如果要查看指定文件的修改记录可以使用 git blame 命令，格式如下：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">git blame &lt;<span class="hljs-built_in">file</span>&gt;<br></code></pre></td></tr></table></figure><p>git blame用来追溯一个指定文件的历史修改记录。它能显示任何文件中每行最后一次修改的提交记录。 所以，如果你在代码中看到一个有 bug 的方法，你可以使用 git blame 标注这个文件，查看哪一次提交引入了这行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">可以使用 -L 指定文件的行数范围：</span><br>git blame -L n1,n2 filename<br></code></pre></td></tr></table></figure><h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><p><strong>git pull</strong> 命令用于从远程获取代码并合并本地的版本。</p><p><strong>git pull</strong> 其实就是 <strong>git fetch</strong> 和 <strong>git merge FETCH_HEAD</strong> 的简写。 命令格式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">git pull <span class="hljs-tag">&lt;<span class="hljs-name">远程主机名</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">远程分支名</span>&gt;</span>:<span class="hljs-tag">&lt;<span class="hljs-name">本地分支名</span>&gt;</span><br></code></pre></td></tr></table></figure><p>更新操作：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git pull</span><br><span class="hljs-attribute">git pull origin</span><br></code></pre></td></tr></table></figure><p>将远程主机 origin 的 master 分支拉取过来，与本地的 brantest 分支合并。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git pull origin <span class="hljs-literal">master</span>:brantest<br></code></pre></td></tr></table></figure><h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><p><strong>git push</strong> 命用于从将本地的分支版本上传到远程并合并。</p><p>命令格式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">git push <span class="hljs-tag">&lt;<span class="hljs-name">远程主机名</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">本地分支名</span>&gt;</span>:<span class="hljs-tag">&lt;<span class="hljs-name">远程分支名</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果本地分支名与远程分支名相同，则可以省略冒号：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">git push <span class="hljs-tag">&lt;<span class="hljs-name">远程主机名</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">本地分支名</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果本地版本与远程版本有差异，但又要强制推送可以使用 –force 参数：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> --force <span class="hljs-built_in">origin</span> master<br></code></pre></td></tr></table></figure><p>删除主机的分支可以使用 –delete 参数，以下命令表示删除 origin 主机的 master 分支，(慎用)：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> --<span class="hljs-built_in">delete</span> master<br></code></pre></td></tr></table></figure><h3 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote add origin your_first_git_address //将第一个git address命名为origin<br></code></pre></td></tr></table></figure><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><table><thead><tr><th>参数</th><th></th></tr></thead><tbody><tr><td>\–-all</td><td>把所有文件添加到版本控制里面</td></tr><tr><td>.</td><td>--all 同</td></tr></tbody></table><h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><p>git commit </p><table><thead><tr><th>参数</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>-a</td><td>all</td><td>受版本控制的所有文件<br>注意，新加的文件（即没有被git系统管理的文件）是不能被提交到本地仓库的</td><td></td></tr><tr><td>-m</td><td>message</td><td>提交的注释</td><td>git commit -m “this first commit”</td></tr><tr><td>- - amend</td><td></td><td>修改上次提交的注释</td><td></td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -m <span class="hljs-string">&#x27;    // 在这里直接输入回车即可</span><br><span class="hljs-string">1、第一项改动      // 以下的这些真正的comment可以在其他文本编辑器中写好粘贴过来</span><br><span class="hljs-string">2、第二项</span><br><span class="hljs-string">&#x27;</span>                // 输入这个结尾单引号后，再输入回车即可完成本次commit的提交<br></code></pre></td></tr></table></figure><h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h3><table><thead><tr><th>argv</th><th></th><th></th></tr></thead><tbody><tr><td>-u</td><td>mode</td><td></td></tr><tr><td>-uno</td><td>- 不显示未跟踪的文件。</td><td></td></tr><tr><td>-unormal</td><td>- 显示未跟踪的文件和目录。</td><td></td></tr><tr><td>-uall</td><td>- 还显示未跟踪目录中的单个文件。</td><td></td></tr></tbody></table><p>查看那些被修改那些没被修改</p><h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><p>查看与版本差异</p><h3 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h3><table><thead><tr><th>参数</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>git checkout &lt;branch&gt;</td><td></td><td>切换分支</td><td></td></tr><tr><td>git checkou -b &lt;branch&gt;</td><td>build</td><td>创建并切换分支</td><td></td></tr><tr><td>git checkout –orphan &lt;branch&gt;</td><td></td><td>创建切换到孤立的分支</td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>git checkout – &lt;file&gt;</td><td></td><td>从Staged恢复文件<br>重置全部文件用<code>-- .</code></td><td></td></tr><tr><td>git checkout HEAD – &lt;file&gt;</td><td></td><td>从HEAD恢复文件<br>重置全部文件用<code>-- .</code></td><td></td></tr></tbody></table><h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h3><table><thead><tr><th>参数</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>git branch &lt;branch&gt;</td><td></td><td>创建分支</td><td></td></tr><tr><td>git branch -d &lt;branch&gt;</td><td>delete</td><td>删除分支</td><td></td></tr><tr><td>git branch -D &lt;branch&gt;</td><td></td><td>强制删除</td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>git branch (-m | -M) &lt;oldbranch&gt; &lt;newbranch&gt;</td><td></td><td>重命名分支</td><td></td></tr><tr><td>git branch</td><td></td><td>查看当前分支</td><td></td></tr></tbody></table><h3 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h3><table><thead><tr><th>参数</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>git tag</td><td></td><td>查看标签</td><td></td></tr><tr><td>git show</td><td></td><td>查看指定标签的信息</td><td></td></tr><tr><td>git tag &lt;tag name&gt; &lt;commit id&gt;</td><td></td><td>创建 tag</td><td></td></tr><tr><td>-a</td><td></td><td>指定标签名</td><td></td></tr><tr><td>-m</td><td></td><td>指定说明文字</td><td></td></tr><tr><td>-l</td><td></td><td>列出特定版本 git tag -l “v1.4.2.*”</td><td></td></tr><tr><td>-d</td><td></td><td>删除</td><td></td></tr><tr><td>git push origin &lt;tag name&gt;</td><td></td><td>推送某个标签到远程</td><td></td></tr><tr><td>git push origin –tags</td><td></td><td>推送全部尚未推送到远程的本地标签</td><td></td></tr></tbody></table><h3 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h3><p>变基 </p><p>注: 需要切换到分支的后面, 再完成变基</p><p>git checkout &lt;branch&gt;</p><p>git rebae -d &lt;master branch&gt;</p><h3 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h3><p><img src="/2022/69c3279c/1102222-20171213190644254-2099705216.png" alt="img"></p><table><thead><tr><th>参数</th><th></th></tr></thead><tbody><tr><td>git merge &lt;branch&gt;</td><td>将分支合并到当前分支</td></tr><tr><td>git merge –no-ff  &lt;branch&gt;</td><td>禁用 快速合并模式（Fast forward）</td></tr><tr><td>git merge –ff-only  &lt;branch&gt;</td><td>快速合并(快进)</td></tr><tr><td><code>git merge --abort</code></td><td>中止这一次提交的合并(当遇到冲突时)</td></tr></tbody></table><h3 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h3><table><thead><tr><th>参数</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>git stash</td><td></td><td>将当前未提交内容藏匿</td><td></td></tr><tr><td>git stash list</td><td></td><td>藏匿 list</td><td></td></tr><tr><td>git stash drop</td><td></td><td>删除 藏匿</td><td></td></tr><tr><td>git stash apply</td><td></td><td>恢复 藏匿</td><td></td></tr><tr><td>git stash pop</td><td></td><td>恢复并删除 藏匿</td><td></td></tr></tbody></table><h3 id="git-restore-重置文件"><a href="#git-restore-重置文件" class="headerlink" title="git restore 重置文件"></a>git restore 重置文件</h3><p>类似 git checkout – &lt;file&gt;     重置文件</p><p>git restore &lt;file&gt;撤销工作区的修改，从暂存区恢复至工作区，如果工作区没有则从版本库恢复至工作区。</p><p>git restore –staged &lt;file&gt;用作清除暂存区的文件，不影响工作区以及版本库中的文件</p><p><img src="/2022/69c3279c/542.png" alt="img"></p><h3 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h3><p><strong>原理：</strong> git revert是用于“反做”某一个版本，以达到撤销该版本的修改的目的。比如，我们 commit 了三个版本（版本一、版本二、 版本三），突然发现版本二不行（如：有bug），想要撤销版本二，但又不想影响撤销版本三的提交，就可以用 git revert 命令来反做版本二，生成新的版本四，这个版本四里会保留版本三的东西，但撤销了版本二的东西。如下图所示：</p><p><img src="/2022/69c3279c/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwNDE0MjA1ODE2MTg4.png" alt="这里写图片描述"></p><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><p><strong>原理：</strong> git reset的作用是修改HEAD的位置，即将HEAD指向的位置改变为之前存在的某个版本，如下图所示，假设我们要回退到版本一</p><p><img src="/2022/69c3279c/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwNDE0MjEyMjIxMDMz.png" alt="这里写图片描述"></p><p>在Git中，用<code>HEAD</code>表示当前版本</p><p>版本回退 HEAD往前回退一个版本(同理这里可以写对应的版本号) <code>git reset -–hard HEAD^</code></p><table><thead><tr><th>参数</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>–- hard</td><td></td><td>硬重置</td><td></td></tr><tr><td>–- soft</td><td></td><td></td><td></td></tr><tr><td>–- mixed</td><td></td><td></td><td></td></tr><tr><td>–- merge</td><td></td><td></td><td></td></tr><tr><td>–- keep</td><td></td><td></td><td></td></tr></tbody></table><h3 id="git-ignore"><a href="#git-ignore" class="headerlink" title="git - .ignore"></a>git - .ignore</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">此为注释 – 将被 Git 忽略</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">忽略所有 .a 结尾的文件</span><br>*.a<br><span class="hljs-meta prompt_"># </span><span class="language-bash">但 lib.a 除外</span><br>!lib.a<br><span class="hljs-meta prompt_"># </span><span class="language-bash">仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span><br>/TODO<br><span class="hljs-meta prompt_"># </span><span class="language-bash">忽略 build/ 目录下的所有文件</span><br>build/<br><span class="hljs-meta prompt_"># </span><span class="language-bash">会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span><br>doc/*.txt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">忽略 doc/ 目录下所有扩展名为 txt 的文件</span><br>doc/**/*.txt<br></code></pre></td></tr></table></figure><h3 id="git-switch"><a href="#git-switch" class="headerlink" title="git switch"></a>git switch</h3><p>git switch 切换分支 远程有而本地没有的分支，而如果要从远程分支建一个同名的本地分支，并且关联远程分支</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xquery">git <span class="hljs-keyword">switch</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">branchName</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>git switch 创建一个新分支并切换到该新分支 </p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">git <span class="hljs-keyword">switch</span> -<span class="hljs-keyword">c</span> &lt;branchName&gt;<br></code></pre></td></tr></table></figure><p>git switch 以一个提交commit来创建一个分支</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">git <span class="hljs-keyword">switch</span> -<span class="hljs-keyword">c</span> test<span class="hljs-number">3</span> e<span class="hljs-number">053</span>cf<span class="hljs-number">128</span>d<span class="hljs-number">2</span>ad<span class="hljs-number">9</span>d<span class="hljs-number">35e2</span>f<span class="hljs-number">94878569596</span>fb<span class="hljs-number">32</span>f<span class="hljs-number">4306</span><br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">操作</th><th align="left">2.23-</th><th align="left">2.23+</th></tr></thead><tbody><tr><td align="left">管理分支</td><td align="left">git branch</td><td align="left">git branch</td></tr><tr><td align="left">切换分支</td><td align="left">git checkout</td><td align="left">git switch</td></tr><tr><td align="left">新建+切换分支</td><td align="left">git checkout -b</td><td align="left">git switch -c</td></tr><tr><td align="left">切换到commit id</td><td align="left">git checkout</td><td align="left">git checkout</td></tr></tbody></table><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><h2 id="修改分支指针"><a href="#修改分支指针" class="headerlink" title="修改分支指针"></a>修改分支指针</h2><p>git branch -f 分支名 commitID</p><p>作用是将其他分支上的本地代码硬重置到某个commitId下，不能重置本分支。比如我dev分支上某个节点的commitId叫 devID1</p><p>然后 git branch -f master devID1<br>那么master上的代码就会和dev一样，并且历史记录也会一样，只是dev分支上的代码可能会比master上的新一点，因为是重置的commitId</p><h2 id="git-status-显示不了汉字"><a href="#git-status-显示不了汉字" class="headerlink" title="git status 显示不了汉字"></a>git status 显示不了汉字</h2><p>git bash 终端输入命令：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">git config --global core.quotepath <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>在git仓库文件夹内打开git bash，在git branch的界面中右击空白处，弹出菜单，选择option，编码设定为 gb2312。</p><h2 id="git-ssh-非标端口"><a href="#git-ssh-非标端口" class="headerlink" title="git ssh 非标端口"></a>git ssh 非标端口</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone ssh://git@hostname:port/…/xxx.git<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">e.g.</span><br>git clone ssh://git@192.168.1.220:10022/frank/tools.git<br></code></pre></td></tr></table></figure><h2 id="验证ssh链接"><a href="#验证ssh链接" class="headerlink" title="验证ssh链接"></a>验证ssh链接</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh -T git@github.com<br>ssh -T ssh://git@192.168.1.220:10022<br></code></pre></td></tr></table></figure><h2 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push origin --delete branch_name<br></code></pre></td></tr></table></figure><h2 id="删除全部历史提交记录"><a href="#删除全部历史提交记录" class="headerlink" title="删除全部历史提交记录"></a>删除全部历史提交记录</h2><ol><li>尝试  运行 <code> git checkout --orphan latest_branch</code></li><li>添加所有文件<code>git add -A</code></li><li>提交更改<code>git commit -am &quot;commit message&quot;</code></li><li>删除分支<code>git branch -D main</code></li><li>将当前分支重命名<code>git branch -m main</code></li><li>最后，强制更新存储库。<code>git push -f origin main</code></li></ol><h2 id="清理仓库"><a href="#清理仓库" class="headerlink" title="!清理仓库!"></a>!清理仓库!</h2><p>!谨慎操作! !谨慎操作! !谨慎操作! !谨慎操作! !谨慎操作!</p><ol start="0"><li>可以先查看一下本地仓库的大小</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">du</span> -sh .git<br></code></pre></td></tr></table></figure><ol><li>移除本地仓库中指向旧提交的剩余refs，<code>git for-each-ref</code> 会打印仓库中匹配<code>refs/original</code>的所有refs，并使用<code>delete</code>作为前缀，此命令通过管道传送到 <code>git update-ref</code> 命令，该命令会移除所有指向旧commit的引用。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git for-each-ref --format=<span class="hljs-string">&#x27;delete %(refname)&#x27;</span> refs/original | git update-ref --stdin<br></code></pre></td></tr></table></figure><ol start="2"><li>以下命令会使reflog到期，因为它依然包含着对旧commit的引用。使用<code>--expire=now</code> 参数，确保它在目前为止到期了。如果没有该参数，只会移除超过90天的reflog。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reflog expire --expire=now --all<br></code></pre></td></tr></table></figure><ol start="3"><li>现在本地仓库依然包含着所有旧commit的对象，但已经没有引用指向它们了，这些对象需要被删除掉。此时可以使用 <code>git gc</code> 命令，Git的垃圾回收器会删除这些没有引用指向的对象。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git gc --prune=now<br></code></pre></td></tr></table></figure><p>​<code>gc</code>使用<code>--prune</code> 参数来清理特定时期的对象，默认情况下为2周，指定<code>now</code>将删除所有这些对象而没有时期限制。</p><ol start="4"><li><code>du -sh .git</code>此时，.git文件的大小只有104k了。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">du</span> -sh .git<br><span class="hljs-comment"># 104K    .git</span><br></code></pre></td></tr></table></figure><ol start="5"><li>如果确认所做的删除大文件操作没有问题，就可以提交到远程仓库了，一旦提交，再也没有办法恢复到原来的状态，一定要小心谨慎！一定要小心谨慎！一定要小心谨慎！</li><li>先进行备份工作，以免出现问题：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/Desktop/<br><span class="hljs-built_in">mkdir</span> gitthin_mirror &amp;&amp; <span class="hljs-built_in">cd</span> gitthin_mirror<br>git <span class="hljs-built_in">clone</span> --mirror git@gitee.com:coderhony/gitthin.git<br></code></pre></td></tr></table></figure><ol start="7"><li>再回到刚才做的已经瘦身的Git仓库</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/Desktop/gitthin/gitthin<br></code></pre></td></tr></table></figure><ol start="8"><li>把已瘦身的仓库同步到远程仓库，使用<code>—mirror</code>参数：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push --mirror &lt;url&gt;<br></code></pre></td></tr></table></figure><ol start="9"><li>为了确保都已同步，再执行以下命令：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push --all --force<br><span class="hljs-comment"># Everything up-to-date</span><br>git push --tags --force<br><span class="hljs-comment"># Everything up-to-date</span><br></code></pre></td></tr></table></figure><h2 id="一台电脑两个Github账号"><a href="#一台电脑两个Github账号" class="headerlink" title="一台电脑两个Github账号"></a>一台电脑两个Github账号</h2><ul><li><p>生成两个ssh key</p></li><li><p>编辑config文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Default GitHub</span><br>Host github.com<br>HostName github.com<br>User git<br>IdentityFile ~/.ssh/id_rsa<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"> Jack-InGitHub!</span> <br>Host pq.github.com<br>HostName github.com<br>User git<br>IdentityFile ~/.ssh/id_rsa_a<br></code></pre></td></tr></table></figure><ul><li>github.com 用id_rsa密钥</li><li>pq.github.com 用id_rsa_a密钥</li></ul></li></ul><ul><li><p>原来<code>git@github.com:Jack-InGitHub/test.git</code></p><p>现在<code>git@pq.github.com:Jack-InGitHub/test.git</code></p></li><li><p>记得再配置不同的邮箱名</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --<span class="hljs-built_in">local</span> user.name <span class="hljs-string">&quot;username&quot;</span><br>git config --<span class="hljs-built_in">local</span> user.email user@email.com<br></code></pre></td></tr></table></figure><h2 id="利用管道删除全部本地分支"><a href="#利用管道删除全部本地分支" class="headerlink" title="利用管道删除全部本地分支"></a>利用管道删除全部本地分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout master<br>git branch | grep -v <span class="hljs-string">&#x27;master&#x27;</span> | xargs git branch -D<br></code></pre></td></tr></table></figure><h2 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h2><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment"># 把旧仓库被分成本地git文件目录</span><br>git <span class="hljs-keyword">clone</span> <span class="hljs-title">--mirror</span> 旧的git地址<br><br><span class="hljs-comment"># 推动本地目录到新的地址</span><br>cd xxx.git<br>git push --mirror 新的git地址<br><br><span class="hljs-comment"># 以上就完成了单个仓库的迁移</span><br></code></pre></td></tr></table></figure><h2 id="删除未追踪的文件"><a href="#删除未追踪的文件" class="headerlink" title="删除未追踪的文件"></a>删除未追踪的文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">git clean -f -d<br><span class="hljs-comment"># -d 递归清理</span><br><span class="hljs-comment"># -f = --force 强制清理</span><br>-d<br>    Normally, when no &lt;path&gt; is specified, git clean will not recurse into untracked directories to avoid removing too much. Specify -d to have it recurse into such directories as well. If any paths are specified, -d is irrelevant; all untracked files matching the specified paths (with exceptions <span class="hljs-keyword">for</span> nested git directories mentioned under --force) will be removed.<br><br>-f<br>    --force<br>    If the Git configuration variable clean.requireForce is not <span class="hljs-built_in">set</span> to <span class="hljs-literal">false</span>, git clean will refuse to delete files or directories unless given -f or -i. Git will refuse to modify untracked nested git repositories (directories with a .git subdirectory) unless a second -f is given.<br></code></pre></td></tr></table></figure><h2 id="子模块-子仓库"><a href="#子模块-子仓库" class="headerlink" title="子模块 子仓库"></a>子模块 子仓库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git submodule <span class="hljs-built_in">help</span><br>usage: git submodule [--quiet] [--cached]<br>   or: git submodule [--quiet] add [-b &lt;branch&gt;] [-f|--force] [--name &lt;name&gt;] [--reference &lt;repository&gt;] [--] &lt;repository&gt; [&lt;path&gt;]<br>   or: git submodule [--quiet] status [--cached] [--recursive] [--] [&lt;path&gt;...]<br>   or: git submodule [--quiet] init [--] [&lt;path&gt;...]<br>   or: git submodule [--quiet] deinit [-f|--force] (--all| [--] &lt;path&gt;...)<br>   or: git submodule [--quiet] update [--init] [--remote] [-N|--no-fetch] [-f|--force] [--checkout|--merge|--rebase] [--[no-]recommend-shallow] [--reference &lt;repository&gt;] [--recursive] [--[no-]single-branch] [--] [&lt;path&gt;...]<br>   or: git submodule [--quiet] set-branch (--default|--branch &lt;branch&gt;) [--] &lt;path&gt;<br>   or: git submodule [--quiet] set-url [--] &lt;path&gt; &lt;newurl&gt;<br>   or: git submodule [--quiet] summary [--cached|--files] [--summary-limit &lt;n&gt;] [commit] [--] [&lt;path&gt;...]<br>   or: git submodule [--quiet] foreach [--recursive] &lt;<span class="hljs-built_in">command</span>&gt;<br>   or: git submodule [--quiet] <span class="hljs-built_in">sync</span> [--recursive] [--] [&lt;path&gt;...]<br>   or: git submodule [--quiet] absorbgitdirs [--] [&lt;path&gt;...]<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 子模块的添加</span><br>git submodule add [-b branch] &lt;url&gt; &lt;path&gt;<br><span class="hljs-comment"># 子模块的初始化&amp;更新下载</span><br>git submodule init<br>git submodule update<br><span class="hljs-comment"># </span><br></code></pre></td></tr></table></figure><ul><li>还有更简单一点的方式。 如果给 <code>git clone</code> 命令传递 <code>--recurse-submodules</code> 选项，它就会自动初始化并更新仓库中的每一个子模块， 包括可能存在的嵌套子模块。</li></ul><h2 id="合并没有相关历史的提交"><a href="#合并没有相关历史的提交" class="headerlink" title="合并没有相关历史的提交"></a>合并没有相关历史的提交</h2><p>将test2分支合并到master分支中 <code>git merge test2 --allow-unrelated-histories </code></p><h4 id="合并两个没有相同历史的Git仓库"><a href="#合并两个没有相同历史的Git仓库" class="headerlink" title="合并两个没有相同历史的Git仓库"></a><a href="https://www.cnblogs.com/masahiro/p/12155758.html">合并两个没有相同历史的Git仓库</a></h4><p>首先在需要合并的仓库中增加另外一个远程仓库 <code>git remote add test2 http://git.xxx.xxx/test2 </code></p><p>然后将test2的仓库拉取到本地 <code>git fetch test2 </code></p><p>创建本地分支 <code>git checkout -b test2 test2/master </code></p><p>切换到目标分区 <code>git checkout master </code></p><p>将test2分支合并到master分支中<code>git merge test2 --allow-unrelated-histories</code></p><p>至此分支合并完成,只需将分支提交到服务器即可</p><h2 id="将init后默认branch设定成为main"><a href="#将init后默认branch设定成为main" class="headerlink" title="将init后默认branch设定成为main"></a>将init后默认branch设定成为main</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global init.defaultBranch main<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 把当前master分支改名为main 其中-M的意思是移动或者重命名当前分支</span><br>git branch -M main<br></code></pre></td></tr></table></figure><h2 id="让git流量走代理"><a href="#让git流量走代理" class="headerlink" title="让git流量走代理"></a>让git流量走代理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># socks代理</span><br>git config --global http.proxy <span class="hljs-string">&#x27;socks5://127.0.0.1:1080&#x27;</span><br>git config --global https.proxy <span class="hljs-string">&#x27;socks5://127.0.0.1:1080&#x27;</span><br><span class="hljs-comment"># http/https代理</span><br>git config --global http.proxy http://127.0.0.1:8080<br>git config --global https.proxy https://127.0.0.1:8080<br></code></pre></td></tr></table></figure><p>也可以直接修改~&#x2F;.gitconfig文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi ~/.gitconfig<br></code></pre></td></tr></table></figure><p>新建或修改这两项配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">[http]<br>proxy = socks5://127.0.0.1:1080<br><br>[https]<br>proxy = socks5://127.0.0.1:1080<br></code></pre></td></tr></table></figure><p>如果要取消代理：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global --<span class="hljs-built_in">unset</span> http.proxy<br>git config --global --<span class="hljs-built_in">unset</span> https.proxy<br></code></pre></td></tr></table></figure><p>带参数是临时的，修改配置文件是永久变更，修改后最好重启git 设置生效。</p><p>查看配置信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config -l --global<br></code></pre></td></tr></table></figure><p>执行查看代理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config -l<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符集和字符编码</title>
    <link href="/2022/438d1de3/"/>
    <url>/2022/438d1de3/</url>
    
    <content type="html"><![CDATA[<h1 id="字符集和字符编码"><a href="#字符集和字符编码" class="headerlink" title="字符集和字符编码"></a>字符集和字符编码</h1><p><a href="https://www.cnblogs.com/skynet/archive/2011/05/03/2035105.html">字符集和字符编码 (Charset &amp; Encoding)</a></p><p><a href="http://www.knowsky.com/resource/gb2312tbl.htm">GB2312简体中文编码表</a></p><p><a href="http://tools.jb51.net/table/gb2312">GB2312简体中文编码表</a></p><p><a href="https://www.unicode.org/charts/">Unicode码查询</a></p><p><a href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84">Unicode字符平面映射</a></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>字符集（Charset）</strong>：是一个系统支持的所有抽象字符的集合。字符是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等。</p><p>常见字符集：ASCII字符集、GB2312字符集、BIG5字符集、GB18030字符集、Unicode字符集等。计算机要准确的处理各种字符集文字，需要进行字符编码，以便计算机能够识别和存储各种文字。</p><p><strong>字符编码（Character Encoding）</strong>：是一套法则，使用该法则能够对自然语言的字符的一个集合（如字母表或音节表），与其他东西的一个集合（如号码、数字或电脉冲）进行配对。即在符号集合与数字系统之间建立对应关系，它是信息处理的一项基本技术。通常人们用符号集合（一般情况下就是文字）来表达信息。而以计算机为基础的信息处理系统则是利用元件（硬件）不同状态的组合来存储和处理信息的。元件不同状态的组合能代表数字系统的数字，因此字符编码就是将符号转换为计算机可以接受的数字系统的数，称为数字代码。</p><h2 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h2><p><strong>ASCII字符集</strong>：主要包括控制字符（回车键、退格、换行键等）；可显示字符（英文大小写字符、阿拉伯数字和西文符号）。</p><p><strong>ASCII编码</strong>：将ASCII字符集转换为计算机可以接受的数字系统的数的规则。使用7位（bits）表示一个字符，共128字符；但是7位编码的字符集只能支持128个字符，为了表示更多的常用字符欧洲对ASCII进行了扩展，ASCII扩展字符集使用8位（bits）表示一个字符，共256字符。ASCII字符集映射到数字编码规则如下图所示：</p><p><img src="/2022/438d1de3/2011050311372042.png" alt="img"></p><p><img src="/2022/438d1de3/201105031137219627.png" alt="img"></p><h2 id="GBxxx"><a href="#GBxxx" class="headerlink" title="GBxxx"></a>GBxxx</h2><p>中国把那些127号之后的奇异符号们（即EASCII、扩充ASCII）取消掉，规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字。前面的一个字节（他称之为高字节）从0xA1用到 0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。在这些编码里，还把数学符号、罗马希腊的 字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。</p><p>上述编码规则就是<strong>GB2312</strong>。<strong>GB2312</strong>或<strong>GB2312-80</strong>是<a href="http://zh.wikipedia.org/wiki/%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E5%9B%BD%E5%AE%B6%E6%A0%87%E5%87%86">中国国家标准</a><a href="http://zh.wikipedia.org/wiki/%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87">简体中文</a><a href="http://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E9%9B%86">字符集</a>，全称《<strong>信息交换用汉字编码字符集·基本集</strong>》，又称<a href="http://zh.wikipedia.org/wiki/%E5%9B%BD%E5%AE%B6%E6%A0%87%E5%87%86%E4%BB%A3%E7%A0%81"><strong>GB0</strong></a>，由<a href="http://zh.wikipedia.org/w/index.php?title=%E4%B8%AD%E5%9B%BD%E5%9B%BD%E5%AE%B6%E6%A0%87%E5%87%86%E6%80%BB%E5%B1%80&action=edit&redlink=1">中国国家标准总局</a>发布，<a href="http://zh.wikipedia.org/wiki/1981%E5%B9%B4">1981年</a><a href="http://zh.wikipedia.org/wiki/5%E6%9C%881%E6%97%A5">5月1日</a>实施。GB2312编码通行于中国大陆；<a href="http://zh.wikipedia.org/wiki/%E6%96%B0%E5%8A%A0%E5%9D%A1">新加坡</a>等地也采用此编码。GB2312的出现，基本满足了汉字的计算机处理需要，它所收录的汉字已经覆盖中国大陆99.75%的使用频率。对于<a href="http://zh.wikipedia.org/wiki/%E4%BA%BA%E5%90%8D">人名</a>、<a href="http://zh.wikipedia.org/wiki/%E5%8F%A4%E6%B1%89%E8%AF%AD">古汉语</a>等方面出现的<a href="http://zh.wikipedia.org/wiki/%E7%BD%95%E7%94%A8%E5%AD%97">罕用字</a>，GB2312不能处理，这导致了后来<a href="http://zh.wikipedia.org/wiki/GBK">GBK</a>及<a href="http://zh.wikipedia.org/wiki/GB_18030">GB 18030</a>汉字字符集的出现。</p><p><a href="http://www.knowsky.com/resource/gb2312tbl.htm">GB2312简体中文编码表</a></p><p><a href="http://tools.jb51.net/table/gb2312">GB2312简体中文编码表</a></p><h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p>Unicode编码系统为表达任意语言的任意字符而设计。它使用4字节的数字来表达每个字母、符号，或者表意文字(ideograph)。每个字符对应一个数字，每个数字对应一个字符，即不存在二义性，不再需要记录”模式”了。U+0041总是代表’A’，即使这种语言没有’A’这个字符。</p><p>在计算机科学领域中，<strong>Unicode</strong>（<strong>统一码</strong>、<strong>万国码</strong>、<strong>单一码</strong>、<strong>标准万国码</strong>）是业界的一种标准，它可以使电脑得以体现世界上数十种文字的系统。</p><p>（<strong>可以这样理解：Unicode是字符集，UTF-32&#x2F; UTF-16&#x2F; UTF-8是三种字符编码方案。</strong>）</p><p><a href="https://www.unicode.org/charts/">Unicode码查询</a></p><p><a href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84">Unicode字符平面映射</a></p><h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h3><p>EF BB BF　　　 UTF-8<br>FE FF　　　　　UTF-16&#x2F;UCS-2, little endian<br>FF FE　　　　　UTF-16&#x2F;UCS-2, big endian<br>FF FE 00 00　　UTF-32&#x2F;UCS-4, little endian.<br>00 00 FE FF　　UTF-32&#x2F;UCS-4, big-endian.</p><ul><li><strong>字符集和字符编码</strong></li></ul><p><img src="/2022/438d1de3/v2-aee5ae604328ab912b285d03b6c62273_720w.jpg" alt="img"></p><h3 id="UTF-32"><a href="#UTF-32" class="headerlink" title="UTF-32"></a>UTF-32</h3><p>上述使用4字节的数字来表达每个字母、符号，或者表意文字(ideograph)，每个数字代表唯一的至少在某种语言中使用的符号的编码方案，称为UTF-32。UTF-32又称<strong>UCS-4</strong>是一种将<a href="http://zh.wikipedia.org/wiki/Unicode">Unicode</a>字符编码的协定，对每个字符都使用4字节。就空间而言，是非常没有效率的。</p><p>这种方法有其优点，最重要的一点就是可以在常数时间内定位字符串里的第N个字符，因为第N个字符从第4×Nth个字节开始。虽然每一个码位使用固定长定的字节看似方便，它并不如其它Unicode编码使用得广泛。</p><h3 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h3><p>对于UTF-32和UTF-16编码方式还有一些其他不明显的缺点。不同的计算机系统会以不同的顺序保存字节。这意味着字符U+4E2D在UTF-16编码方式下可能被保存为4E 2D或者2D 4E，这取决于该系统使用的是大尾端(big-endian)还是小尾端(little-endian)。为了解决这个问题，多字节的Unicode编码方式定义了一个”字节顺序标记(Byte Order Mark)”，它是一个特殊的非打印字符，你可以把它包含在文档的开头来指示你所使用的字节顺序。对于UTF-16，字节顺序标记是U+FEFF。如果收到一个以字节FFFE开头的UTF-16编码的文档，你就能确定它的字节顺序是单向的(one way)的了；如果它以FEFF开头，则可以确定字节顺序反向了。</p><p><strong>具体编码方式</strong></p><p>Unicode范围<code>U+10000</code><del><code>U+10FFFF</code>：将Unicode值减去（0x10000），得到20bit长的值。再将Unicode分为高10位和低10位。<a href="https://www.zhihu.com/search?q=UTF-16%E7%BC%96%E7%A0%81&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:106379925%7D">UTF-16编码</a>的高位是2 Byte，高10位Unicode范围为<code>0</code>-<code>0x3FF</code>，将Unicode值加上<code>0XD800</code>，得到高位代理（或称为前导代理，存储高位）；低位也是2 Byte，低十位Unicode范围一样为<code>0</code></del><code>0x3FF</code>，将Unicode值加上<code>0xDC00</code>,得到低位代理（或称为后尾代理，存储低位）</p><p>根据上面的转换方式，我们就能够将Unicode码根据UTF-16的编码方式进行转换。下面我们仍然通过两个例子来看下：</p><ul><li><code>U+0020</code>，这个值的范围在第一部分，即经过UTF-16编码后，结果仍然为<code>U+0020</code>，在内存中的顺序为<code>00 20</code>。</li><li><code>U+12345</code>, 这个值的范围在第二部分，因此需要先减去<code>0x10000</code>，得到<code>0x02345</code>，拆分成高10位<code>00 0000 1000</code>和低10位<code>11 0100 0101</code>。根据上面规则加上特定值后，高位代理值为<code>D808</code>，低位代理值为<code>DF45</code>，最终内存中的顺序为<code>D8 08 DF 45</code>。</li></ul><h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><p><strong>UTF-8</strong>（8-bit Unicode Transformation Format）是一种针对<a href="http://zh.wikipedia.org/wiki/Unicode">Unicode</a>的可变长度<a href="http://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81">字符编码</a>（<a href="http://zh.wikipedia.org/w/index.php?title=%E5%AE%9A%E9%95%BF%E7%A0%81&action=edit&redlink=1">定长码</a>），也是一种<a href="http://zh.wikipedia.org/w/index.php?title=%E5%89%8D%E7%BC%80%E7%A0%81&action=edit&redlink=1">前缀码</a>。它可以用来表示Unicode标准中的任何字符，且其编码中的第一个<a href="http://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82">字节</a>仍与<a href="http://zh.wikipedia.org/wiki/ASCII">ASCII</a>兼容，这使得原来处理ASCII字符的<a href="http://zh.wikipedia.org/wiki/%E8%BB%9F%E9%AB%94">软件</a>无须或只须做少部份修改，即可继续使用。因此，它逐渐成为<a href="http://zh.wikipedia.org/wiki/%E9%9B%BB%E5%AD%90%E9%83%B5%E4%BB%B6">电子邮件</a>、<a href="http://zh.wikipedia.org/wiki/%E7%B6%B2%E9%A0%81">网页</a>及其他<a href="http://zh.wikipedia.org/wiki/%E5%84%B2%E5%AD%98%E8%A3%9D%E7%BD%AE">存储</a>或传送文字的应用中，优先采用的编码。<a href="http://zh.wikipedia.org/wiki/%E7%B6%B2%E9%9A%9B%E7%B6%B2%E8%B7%AF%E5%B7%A5%E7%A8%8B%E5%B7%A5%E4%BD%9C%E5%B0%8F%E7%B5%84">互联网工程工作小组</a>（IETF）要求所有<a href="http://zh.wikipedia.org/wiki/%E7%B6%B2%E9%9A%9B%E7%B6%B2%E8%B7%AF">互联网</a><a href="http://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE">协议</a>都必须支持UTF-8编码。</p><p>UTF-8使用一至四个<a href="http://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82">字节</a>为每个字符编码</p><p><strong>具体编码方式</strong></p><p><img src="/2022/438d1de3/v2-121a14291638f0b28e1dde7c95d2d379_720w.jpg" alt="img"></p><p>根据上表，解读 UTF-8 编码非常简单。如果一个字节的第一位是<code>0</code>，则这个字节单独就是一个字符；如果第一位是<code>1</code>，则连续有多少个<code>1</code>，就表示当前字符占用多少个字节。<br>下面，还是以汉字<code>严</code>为例，演示如何实现 <a href="https://www.zhihu.com/search?q=UTF-8+%E7%BC%96%E7%A0%81&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:790551384%7D">UTF-8 编码</a>。<br><code>严</code>的 Unicode 是<code>4E25</code>（<code>100111000100101</code>），根据上表，可以发现<code>4E25</code>处在第三行的范围内（<code>0000 0800 - 0000 FFFF</code>），因此<code>严</code>的 UTF-8 编码需要三个字节，即格式是<code>1110xxxx 10xxxxxx 10xxxxxx</code>。然后，从<code>严</code>的最右边<a href="https://www.zhihu.com/search?q=%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:790551384%7D">二进制位</a>开始，依次从右往左填入上边格式中的<code>x</code>，多出的位补<code>0</code>。这样就得到了，<code>严</code>的 UTF-8 编码是<code>11100100 10111000 10100101</code>，转换成<a href="https://www.zhihu.com/search?q=%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:790551384%7D">十六进制</a>就是<code>E4 B8 A5</code>。</p><p><strong>优点</strong></p><ul><li>UTF-8是ASCII的一个<a href="http://zh.wikipedia.org/wiki/%E8%B6%85%E9%9B%86">超集</a>。因为一个纯ASCII字符串也是一个合法的UTF-8字符串，所以现存的ASCII文本不需要转换。为传统的扩展ASCII字符集设计的软件通常可以不经修改或很少修改就能与UTF-8一起使用。</li><li>使用标准的面向字节的排序例程对UTF-8排序将产生与*于Unicode代码点排序相同的结果。（尽管这只有有限的有用性，因为在任何特定语言或文化下都不太可能有仍可接受的文字排列顺序。）</li><li>UTF-8和UTF-16都是<a href="http://zh.wikipedia.org/wiki/%E5%8F%AF%E6%89%A9%E5%B1%95%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80">可扩展标记语言</a>文档的标准编码。所有其它编码都必须通过显式或文本声明来指定。</li><li>任何<a href="http://zh.wikipedia.org/w/index.php?title=%E9%9D%A2%E5%90%91%E5%AD%97%E8%8A%82&action=edit&redlink=1">面向字节</a>的<a href="http://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95">字符串搜索算法</a>都可以用于UTF-8的数据（只要输入仅由完整的UTF-8字符组成）。但是，对于包含字符记数的正则表达式或其它结构必须小心。</li><li>UTF-8字符串可以由一个简单的算法可靠地识别出来。就是，一个字符串在任何其它编码中表现为合法的UTF-8的可能性很低，并随字符串长度增长而减小。举例说，字符值C0,C1,F5至FF从来没有出现。为了更好的可靠性，可以使用正则表达式来统计非法过长和替代值（可以查看<a href="http://www.w3.org/International/questions/qa-forms-utf-8">W3 FAQ: Multilingual Forms</a>上的验证UTF-8字符串的正则表达式）。</li></ul><p><strong>缺点</strong></p><p>因为每个字符使用不同数量的字节编码，所以寻找串中第N个字符是一个O(N)复杂度的操作 — 即，串越长，则需要更多的时间来定位特定的字符。同时，还需要位变换来把字符编码成字节，把字节解码成字符。</p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Character Encoding</tag>
      
      <tag>GB2312</tag>
      
      <tag>UTF-8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++</title>
    <link href="/2022/5751eea2/"/>
    <url>/2022/5751eea2/</url>
    
    <content type="html"><![CDATA[<h1 id="C-Bref"><a href="#C-Bref" class="headerlink" title="C++ Bref"></a>C++ Bref</h1><p>C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。</p><p>C++ 被认为是一种<strong>中级</strong>语言，它综合了高级语言和低级语言的特点。</p><p>C++ 是由 Bjarne Stroustrup 于 1979 年在新泽西州美利山贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，最初命名为带类的C，后来在 1983 年更名为 C++。</p><p>C++ 是 C 的一个超集，事实上，任何合法的 C 程序都是合法的 C++ 程序。</p><p><strong>注意：</strong>使用静态类型的编程语言是在编译时执行类型检查，而不是在运行时执行类型检查。</p><h2 id="类-Class"><a href="#类-Class" class="headerlink" title="类 Class"></a>类 Class</h2><p>类是虚拟的, 统称, 对象是类的实体</p><h2 id="对象-Objects"><a href="#对象-Objects" class="headerlink" title="对象 Objects"></a>对象 Objects</h2><p>objects &#x3D; attributes + services &#x3D; data + operations</p><p>对象 &#x3D; 属性 + 服务 &#x3D; 数据 + 操作</p><p><img src="/2022/5751eea2/image-20220506211131674.png" alt="image-20220506211131674"></p><ul><li>Data 要避免去直接操作, 应该通过Operations去交互</li></ul><p> 三个特性</p><ul><li>封装</li><li>继承</li><li>多态</li></ul><h2 id="Objects-amp-Class"><a href="#Objects-amp-Class" class="headerlink" title="Objects &amp; Class"></a>Objects &amp; Class</h2><p>类是虚拟的, 统称, 对象是类的实体</p><p>猫 -&gt; 种类 -&gt; Class</p><p>这只猫 -&gt; 实体 -&gt; Objects</p><p><img src="/2022/5751eea2/image-20220506210930554.png" alt="image-20220506210930554"></p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>C++ 完全支持面向对象的程序设计，包括面向对象开发的四大特性：</p><ul><li>封装</li><li>抽象</li><li>继承</li><li>多态</li></ul><p>C++ 程序可以定义为对象的集合，这些对象通过调用彼此的方法进行交互。</p><h2 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h2><p>标准的 C++ 由三个重要部分组成：</p><ul><li>核心语言，提供了所有构件块，包括变量、数据类型和常量，等等。</li><li>C++ 标准库，提供了大量的函数，用于操作文件、字符串等。</li><li>标准模板库（STL），提供了大量的方法，用于操作数据结构等。</li></ul><h1 id="hello-word"><a href="#hello-word" class="headerlink" title="hello word"></a>hello word</h1><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span><span class="hljs-comment">// include io stream 后缀是不必要的是Windows的错觉</span></span><br><span class="hljs-comment">// 如果这里包含的是 iostream.h 则不再需要 using namespace std; 标准库也会有所不同</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-comment">// Standard 标准命名空间</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Hello world!&quot;</span> &lt;&lt; endl;<span class="hljs-comment">// c out   end line</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">g++ -v<br><span class="hljs-comment"># 使用gcc编译</span><br>gcc main.cpp -lstdc++ -o main<br><span class="hljs-comment"># g++ 程序 g++ 是将 gcc 默认语言设为 C++ 的一个特殊的版本</span><br>g++ main.cpp -o main<br><span class="hljs-comment"># 运行它</span><br>./main<br></code></pre></td></tr></table></figure><h3 id="g-编译器"><a href="#g-编译器" class="headerlink" title="g++编译器"></a>g++编译器</h3><p>g++ 有些系统默认是使用 C++98，我们可以指定使用 C++11 来编译 main.cpp 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">g++ -g -Wall -std=c++11 main.cpp<br></code></pre></td></tr></table></figure><h4 id="g-常用命令选项"><a href="#g-常用命令选项" class="headerlink" title="g++ 常用命令选项"></a>g++ 常用命令选项</h4><table><thead><tr><th align="left">选项</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">-ansi</td><td align="left">只支持 ANSI 标准的 C 语法。这一选项将禁止 GNU C 的某些特色， 例如 asm 或 typeof 关键词。</td></tr><tr><td align="left">-c</td><td align="left">只编译并生成目标文件。</td></tr><tr><td align="left">-DMACRO</td><td align="left">以字符串”1”定义 MACRO 宏。</td></tr><tr><td align="left">-DMACRO&#x3D;DEFN</td><td align="left">以字符串”DEFN”定义 MACRO 宏。</td></tr><tr><td align="left">-E</td><td align="left">只运行 C 预编译器。</td></tr><tr><td align="left">-g</td><td align="left">生成调试信息。GNU 调试器可利用该信息。</td></tr><tr><td align="left">-IDIRECTORY</td><td align="left">指定额外的头文件搜索路径DIRECTORY。</td></tr><tr><td align="left">-LDIRECTORY</td><td align="left">指定额外的函数库搜索路径DIRECTORY。</td></tr><tr><td align="left">-lLIBRARY</td><td align="left">连接时搜索指定的函数库LIBRARY。</td></tr><tr><td align="left">-m486</td><td align="left">针对 486 进行代码优化。</td></tr><tr><td align="left">-o</td><td align="left">FILE 生成指定的输出文件。用在生成可执行文件时。</td></tr><tr><td align="left">-O0</td><td align="left">不进行优化处理。</td></tr><tr><td align="left">-O</td><td align="left">或 -O1 优化生成代码。</td></tr><tr><td align="left">-O2</td><td align="left">进一步优化。</td></tr><tr><td align="left">-O3</td><td align="left">比 -O2 更进一步优化，包括 inline 函数。</td></tr><tr><td align="left">-shared</td><td align="left">生成共享目标文件。通常用在建立共享库时。</td></tr><tr><td align="left">-static</td><td align="left">禁止使用共享连接。</td></tr><tr><td align="left">-UMACRO</td><td align="left">取消对 MACRO 宏的定义。</td></tr><tr><td align="left">-w</td><td align="left">不生成任何警告信息。</td></tr><tr><td align="left">-Wall</td><td align="left">生成所有警告信息。</td></tr></tbody></table><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h2><p>基本语法和c非常类似,   ;   结尾等等</p><h2 id="三字符组-x3D-etc"><a href="#三字符组-x3D-etc" class="headerlink" title="三字符组(??&#x3D; etc.)"></a>三字符组(??&#x3D; etc.)</h2><p><strong>一种古老的语法</strong></p><p>三字符组就是用于表示另一个字符的三个字符序列，又称为三字符序列。三字符序列总是以两个问号开头。</p><table><thead><tr><th align="left">三字符组</th><th align="left">替换</th></tr></thead><tbody><tr><td align="left">??&#x3D;</td><td align="left">#</td></tr><tr><td align="left">…..</td><td align="left">….</td></tr></tbody></table><h2 id="数据类型-bool-etc"><a href="#数据类型-bool-etc" class="headerlink" title="数据类型(bool etc.)"></a>数据类型(bool etc.)</h2><p>C++ 就是在以前的c拓展了一个 bool</p><p>C++ 为程序员提供了种类丰富的内置数据类型和用户自定义的数据类型。下表列出了七种基本的 C++ 数据类型：</p><table><thead><tr><th align="left">类型</th><th align="left">关键字</th></tr></thead><tbody><tr><td align="left">布尔型</td><td align="left">bool</td></tr><tr><td align="left">字符型</td><td align="left">char</td></tr><tr><td align="left">整型</td><td align="left">int</td></tr><tr><td align="left">浮点型</td><td align="left">float</td></tr><tr><td align="left">双浮点型</td><td align="left">double</td></tr><tr><td align="left">无类型</td><td align="left">void</td></tr><tr><td align="left">宽字符型</td><td align="left">wchar_t</td></tr></tbody></table><p>其实 wchar_t 是这样来的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> <span class="hljs-type">wchar_t</span>;<br></code></pre></td></tr></table></figure><h2 id="存储类-auto-register-etc"><a href="#存储类-auto-register-etc" class="headerlink" title="存储类(auto register etc.)"></a>存储类(auto register etc.)</h2><p>存储类定义 C++ 程序中变量&#x2F;函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C++ 程序中可用的存储类：</p><ul><li>auto</li><li>register</li><li>static</li><li>extern</li><li>mutable</li><li>thread_local (C++11)</li></ul><p>从 C++ 17 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用。</p><h3 id="auto-存储类"><a href="#auto-存储类" class="headerlink" title="auto 存储类"></a>auto 存储类</h3><p>自 C++ 11 以来，<strong>auto</strong> 关键字用于两种情况：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。</p><p>C++98标准中auto关键字用于自动变量的声明，但由于使用极少且多余，在 C++17 中已删除这一用法。</p><p>根据初始化表达式自动推断被声明的变量的类型，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">auto</span> f=<span class="hljs-number">3.14</span>;      <span class="hljs-comment">//double </span><br><span class="hljs-keyword">auto</span> <span class="hljs-title function_">s</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>)</span>;  <span class="hljs-comment">//const char* </span><br><span class="hljs-keyword">auto</span> z = new <span class="hljs-keyword">auto</span>(<span class="hljs-number">9</span>); <span class="hljs-comment">// int* </span><br><span class="hljs-keyword">auto</span> x1 = <span class="hljs-number">5</span>, x2 = <span class="hljs-number">5.0</span>, x3=<span class="hljs-string">&#x27;r&#x27;</span>;<span class="hljs-comment">//错误，必须是初始化为同一类型</span><br></code></pre></td></tr></table></figure><h3 id="register-存储类"><a href="#register-存储类" class="headerlink" title="register 存储类"></a>register 存储类</h3><p><strong>register</strong> 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 ‘&amp;’ 运算符（因为它没有内存位置）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">&#123;   <br><span class="hljs-keyword">register</span> <span class="hljs-type">int</span>  miles; <br>&#125;<br></code></pre></td></tr></table></figure><p>寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 ‘register’ 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。</p><h3 id="mutable-存储类"><a href="#mutable-存储类" class="headerlink" title="mutable 存储类"></a>mutable 存储类</h3><p><strong>mutable</strong> 说明符仅适用于类的对象，这将在本教程的最后进行讲解。它允许对象的成员替代常量。也就是说，mutable 成员可以通过 const 成员函数修改。</p><h3 id="thread-local-存储类"><a href="#thread-local-存储类" class="headerlink" title="thread_local 存储类"></a>thread_local 存储类</h3><p>使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。</p><p>thread_local 说明符可以与 static 或 extern 合并。</p><p>可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。</p><p>以下演示了可以被声明为 thread_local 的变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">thread_local</span> <span class="hljs-type">int</span> x;  <span class="hljs-comment">// 命名空间下的全局变量 </span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span> &#123;</span>    <br>    <span class="hljs-type">static</span> <span class="hljs-keyword">thread_local</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s; <span class="hljs-comment">// 类的static成员变量 </span><br>&#125;; <br><span class="hljs-type">static</span> <span class="hljs-keyword">thread_local</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> X::s;  <span class="hljs-comment">// X::s 是需要定义的  </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123;    <br>    <span class="hljs-keyword">thread_local</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; v;  <span class="hljs-comment">// 本地变量 </span><br>&#125;<br><br><br></code></pre></td></tr></table></figure><h2 id="数学运算-cos-sin-etc"><a href="#数学运算-cos-sin-etc" class="headerlink" title="数学运算(cos sin etc.)"></a>数学运算(cos sin etc.)</h2><p>C++ 内置了丰富的数学函数，可对各种数字进行运算。下表列出了 C++ 中一些有用的内置的数学函数。</p><p>为了利用这些函数，您需要引用数学头文件 **<cmath>**。</p><table><thead><tr><th align="left">序号</th><th align="left">函数 &amp; 描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>double cos(double);</strong> 该函数返回弧度角（double 型）的余弦。</td></tr><tr><td align="left">2</td><td align="left"><strong>double sin(double);</strong> 该函数返回弧度角（double 型）的正弦。</td></tr><tr><td align="left">3</td><td align="left"><strong>double tan(double);</strong> 该函数返回弧度角（double 型）的正切。</td></tr><tr><td align="left">4</td><td align="left"><strong>double log(double);</strong> 该函数返回参数的自然对数。</td></tr><tr><td align="left">5</td><td align="left"><strong>double pow(double, double);</strong> 假设第一个参数为 x，第二个参数为 y，则该函数返回 x 的 y 次方。</td></tr><tr><td align="left">6</td><td align="left"><strong>double hypot(double, double);</strong> 该函数返回两个参数的平方总和的平方根，也就是说，参数为一个直角三角形的两个直角边，函数会返回斜边的长度。</td></tr><tr><td align="left">7</td><td align="left"><strong>double sqrt(double);</strong> 该函数返回参数的平方根。</td></tr><tr><td align="left">8</td><td align="left"><strong>int abs(int);</strong> 该函数返回整数的绝对值。</td></tr><tr><td align="left">9</td><td align="left"><strong>double fabs(double);</strong> 该函数返回任意一个浮点数的绝对值。</td></tr><tr><td align="left">10</td><td align="left"><strong>double floor(double);</strong> 该函数返回一个小于或等于传入参数的最大整数。</td></tr></tbody></table><h2 id="随机数-rand-etc"><a href="#随机数-rand-etc" class="headerlink" title="随机数(rand etc.)"></a>随机数(rand etc.)</h2><p>在许多情况下，需要生成随机数。关于随机数生成器，有两个相关的函数。一个是 **rand()**，该函数只返回一个伪随机数。生成随机数之前必须先调用 <strong>srand()</strong> 函数。</p><p>下面是一个关于生成随机数的简单实例。实例中使用了 <strong>time()</strong> 函数来获取系统时间的秒数，通过调用 rand() 函数来生成随机数</p><h2 id="字符串-string-etc"><a href="#字符串-string-etc" class="headerlink" title="字符串(string etc.)"></a>字符串(string etc.)</h2><p>C++ 提供了以下两种类型的字符串表示形式：</p><ul><li>C 风格字符串</li><li><strong>C++ 引入的 string 类类型</strong></li></ul><p>C++ 标准库提供了 <strong>string</strong> 类类型，支持上述所有的操作，另外还增加了其他更多的功能。我们将学习 C++ 标准库中的这个类，现在让我们先来看看下面这个实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string str1 = <span class="hljs-string">&quot;str1&quot;</span>;<br>    string str2 = <span class="hljs-string">&quot;str2&quot;</span>;<br>    string str3 = <span class="hljs-string">&quot;str3&quot;</span>;<br>    <span class="hljs-comment">// 无法实现 string str3 = &quot;str3&quot; + &quot;str3949499&quot;;  两个静态的string无法相加</span><br><br>    <span class="hljs-comment">// 字符串可以 直接相加</span><br>    str3 = str1 + str2;<br>    cout &lt;&lt; <span class="hljs-string">&quot;str3 : &quot;</span> &lt;&lt; str3 &lt;&lt; endl;<br>    <span class="hljs-comment">// 字符串可以 追加</span><br>    str3 += str1;<br>    cout &lt;&lt; <span class="hljs-string">&quot;str3 : &quot;</span> &lt;&lt; str3 &lt;&lt; endl;<br>    <span class="hljs-comment">// 从cin中直接获取</span><br>    cin &gt;&gt; str3;<br>    cout &lt;&lt; <span class="hljs-string">&quot;str3 : &quot;</span> &lt;&lt; str3 &lt;&lt; endl;<br>    <span class="hljs-comment">// 直接get到size</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;str3.size() : &quot;</span> &lt;&lt; str3.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="基本输入输出-cin-cout-cerr-clog"><a href="#基本输入输出-cin-cout-cerr-clog" class="headerlink" title="基本输入输出(cin cout cerr clog)"></a>基本输入输出(cin cout cerr clog)</h2><h3 id="I-x2F-O-库头文件"><a href="#I-x2F-O-库头文件" class="headerlink" title="I&#x2F;O 库头文件"></a>I&#x2F;O 库头文件</h3><table><thead><tr><th align="left">头文件</th><th align="left">函数和描述</th></tr></thead><tbody><tr><td align="left"><iostream></td><td align="left">该文件定义了 <strong>cin、cout、cerr</strong> 和 <strong>clog</strong> 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。</td></tr><tr><td align="left"><iomanip></td><td align="left">该文件通过所谓的参数化的流操纵器（比如 <strong>setw</strong> 和 <strong>setprecision</strong>），来声明对执行标准化 I&#x2F;O 有用的服务。</td></tr><tr><td align="left"><fstream></td><td align="left">该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。</td></tr></tbody></table><h3 id="标准输出流（cout）"><a href="#标准输出流（cout）" class="headerlink" title="标准输出流（cout）"></a>标准输出流（cout）</h3><p>预定义的对象 <strong>cout</strong> 是 <strong>iostream</strong> 类的一个实例。cout 对象”连接”到标准输出设备，通常是显示屏。<strong>cout</strong> 是与流插入运算符 &lt;&lt; 结合使用的，C++ 编译器根据要输出变量的数据类型，选择合适的流插入运算符来显示值。&lt;&lt; 运算符被重载来输出内置类型（整型、浮点型、double 型、字符串和指针）的数据项。</p><p>流插入运算符 &lt;&lt; 在一个语句中可以多次使用，如上面实例中所示，<strong>endl</strong> 用于在行末添加一个换行符。</p><p><code>cout &lt;&lt; str_cin &lt;&lt; endl;</code></p><h4 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h4><h5 id="ostream-类的成员方法"><a href="#ostream-类的成员方法" class="headerlink" title="ostream 类的成员方法"></a>ostream 类的成员方法</h5><table><thead><tr><th>成员函数</th><th>说明</th></tr></thead><tbody><tr><td>flags(fmtfl)</td><td>当前格式状态全部替换为 fmtfl。注意，fmtfl 可以表示一种格式，也可以表示多种格式。</td></tr><tr><td>precision(n)</td><td>设置输出浮点数的精度为 n。</td></tr><tr><td>width(w)</td><td>指定输出宽度为 w 个字符。</td></tr><tr><td>fill(c)</td><td>在指定输出宽度的情况下，输出的宽度不足时用字符 c 填充（默认情况是用空格填充）。</td></tr><tr><td>setf(fmtfl, mask)</td><td>在当前格式的基础上，追加 fmtfl 格式，并删除 mask 格式。其中，mask 参数可以省略。</td></tr><tr><td>unsetf(mask)</td><td>在当前格式的基础上，删除 mask 格式。</td></tr></tbody></table><h5 id="fmtfl-和-mask-参数可选值"><a href="#fmtfl-和-mask-参数可选值" class="headerlink" title="fmtfl 和 mask 参数可选值"></a>fmtfl 和 mask 参数可选值</h5><table><thead><tr><th>标 志</th><th>作 用</th></tr></thead><tbody><tr><td>ios::boolapha</td><td>把 true 和 false 输出为字符串</td></tr><tr><td>ios::left</td><td>输出数据在本域宽范围内向左对齐</td></tr><tr><td>ios::right</td><td>输出数据在本域宽范围内向右对齐</td></tr><tr><td>ios::internal</td><td>数值的符号位在域宽内左对齐，数值右对齐，中间由填充字符填充</td></tr><tr><td>ios::dec</td><td>设置整数的基数为 10</td></tr><tr><td>ios::oct</td><td>设置整数的基数为 8</td></tr><tr><td>ios::hex</td><td>设置整数的基数为 16</td></tr><tr><td>ios::showbase</td><td>强制输出整数的基数（八进制数以 0 开头，十六进制数以 0x 打头）</td></tr><tr><td>ios::showpoint</td><td>强制输出浮点数的小点和尾数 0</td></tr><tr><td>ios::uppercase</td><td>在以科学记数法格式 E 和以十六进制输出字母时以大写表示</td></tr><tr><td>ios::showpos</td><td>对正数显示“+”号</td></tr><tr><td>ios::scientific</td><td>浮点数以科学记数法格式输出</td></tr><tr><td>ios::fixed</td><td>浮点数以定点格式（小数形式）输出</td></tr><tr><td>ios::unitbuf</td><td>每次输出之后刷新所有的流</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">double</span> a = <span class="hljs-number">1.23</span>;<br>    <span class="hljs-comment">//设定后续输出的浮点数的精度为 4</span><br>    <span class="hljs-built_in">cout</span>.precision(<span class="hljs-number">4</span>);<br>    <span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-string">&quot;precision: &quot;</span>&lt;&lt; a &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-comment">//设定后续以科学计数法的方式输出浮点数</span><br>    <span class="hljs-built_in">cout</span>.setf(ios::scientific);<br>    <span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-string">&quot;scientific：&quot;</span>&lt;&lt; a &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="iomanip-格式化输出"><a href="#iomanip-格式化输出" class="headerlink" title="iomanip 格式化输出"></a>iomanip 格式化输出</h4><table><thead><tr><th>流操纵算子</th><th>作  用</th><th></th></tr></thead><tbody><tr><td>*dec</td><td>以十进制形式输出整数</td><td></td></tr><tr><td>hex</td><td>以十六进制形式输出整数</td><td></td></tr><tr><td>oct</td><td>以八进制形式输出整数</td><td></td></tr><tr><td>fixed</td><td>以普通小数形式输出浮点数</td><td></td></tr><tr><td>scientific</td><td>以科学计数法形式输出浮点数</td><td></td></tr><tr><td>left</td><td>左对齐，即在宽度不足时将填充字符添加到右边</td><td></td></tr><tr><td>*right</td><td>右对齐，即在宽度不足时将填充字符添加到左边</td><td></td></tr><tr><td>setbase(b)</td><td>设置输出整数时的进制，b&#x3D;8、10 或 16</td><td></td></tr><tr><td>setw(w)</td><td>指定输出宽度为 w 个字符，或输入字符串时读入 w 个字符。注意，该函数所起的作用是一次性的，即只影响下一次 cout 输出。</td><td></td></tr><tr><td>setfill(c)</td><td>在指定输出宽度的情况下，输出的宽度不足时用字符 c 填充（默认情况是用空格填充）</td><td></td></tr><tr><td>setprecision(n)</td><td>设置输出浮点数的精度为 n。  在使用非 fixed 且非 scientific 方式输出的情况下，n 即为有效数字最多的位数，如果有效数字位数超过 n，则小数部分四舍五人，或自动变为科学计 数法输出并保留一共 n 位有效数字。  在使用 fixed 方式和 scientific 方式输出的情况下，n 是小数点后面应保留的位数。</td><td></td></tr><tr><td>setiosflags(mask)</td><td>在当前格式状态下，追加 mask 格式，mask 参数可选择表 2 中的所有值。</td><td></td></tr><tr><td>resetiosflags(mask)</td><td>在当前格式状态下，删除 mask 格式，mask 参数可选择表 2 中的所有值。</td><td></td></tr><tr><td>boolapha</td><td>把 true 和 false 输出为字符串</td><td></td></tr><tr><td>*noboolalpha</td><td>把 true 和 false 输出为 0、1</td><td></td></tr><tr><td>showbase</td><td>输出表示数值的进制的前缀</td><td></td></tr><tr><td>*noshowbase</td><td>不输出表示数值的进制.的前缀</td><td></td></tr><tr><td>showpoint</td><td>总是输出小数点</td><td></td></tr><tr><td>*noshowpoint</td><td>只有当小数部分存在时才显示小数点</td><td></td></tr><tr><td>showpos</td><td>在非负数值中显示 +</td><td></td></tr><tr><td>*noshowpos</td><td>在非负数值中不显示 +</td><td></td></tr><tr><td>uppercase</td><td>十六进制数中使用 A~E。若输出前缀，则前缀输出 0X，科学计数法中输出 E</td><td></td></tr><tr><td>*nouppercase</td><td>十六进制数中使用 a~e。若输出前缀，则前缀输出 0x，科学计数法中输出 e。</td><td></td></tr><tr><td>internal</td><td>数值的符号（正负号）在指定宽度内左对齐，数值右对 齐，中间由填充字符填充。</td><td></td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">//以十六进制输出整数</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; hex &lt;&lt; <span class="hljs-number">16</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-comment">//删除之前设定的进制格式，以默认的 10 进制输出整数</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; resetiosflags(ios::basefield)&lt;&lt; <span class="hljs-number">16</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-type">double</span> a = <span class="hljs-number">123</span>;<br>    <span class="hljs-comment">//以科学计数法的方式输出浮点数</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; scientific &lt;&lt; a &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-comment">//删除之前设定的科学计数法的方法</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; resetiosflags(ios::scientific) &lt;&lt; a &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="标准输入流（cin）"><a href="#标准输入流（cin）" class="headerlink" title="标准输入流（cin）"></a>标准输入流（cin）</h3><p>预定义的对象 <strong>cin</strong> 是 <strong>iostream</strong> 类的一个实例。cin 对象附属到标准输入设备，通常是键盘。<strong>cin</strong> 是与流提取运算符 &gt;&gt; 结合使用的，</p><p><code>cin &gt;&gt; str_cin;</code></p><h3 id="标准错误流（cerr）"><a href="#标准错误流（cerr）" class="headerlink" title="标准错误流（cerr）"></a>标准错误流（cerr）</h3><p>预定义的对象 <strong>cerr</strong> 是 <strong>iostream</strong> 类的一个实例。cerr 对象附属到标准输出设备，通常也是显示屏，但是 <strong>cerr</strong> 对象是非缓冲的，且每个流插入到 cerr 都会立即输出。</p><h3 id="标准日志流（clog）"><a href="#标准日志流（clog）" class="headerlink" title="标准日志流（clog）"></a>标准日志流（clog）</h3><p>预定义的对象 <strong>clog</strong> 是 <strong>iostream</strong> 类的一个实例。clog 对象附属到标准输出设备，通常也是显示屏，但是 <strong>clog</strong> 对象是缓冲的。这意味着每个流插入到 clog 都会先存储在缓冲区，直到缓冲填满或者缓冲区刷新时才会输出。</p><h2 id="引用-amp-注意区别于指针"><a href="#引用-amp-注意区别于指针" class="headerlink" title="引用&amp; (注意区别于指针)"></a>引用&amp; (注意区别于指针)</h2><h4 id="C-引用-vs-指针"><a href="#C-引用-vs-指针" class="headerlink" title="C++ 引用 vs 指针"></a>C++ 引用 vs 指针</h4><p>引用很容易与指针混淆，它们之间有三个主要的不同：</p><ul><li>不存在空引用。引用必须连接到一块合法的内存。</li><li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。</li><li>引用必须在创建时被初始化。指针可以在任何时间被初始化。</li></ul><p><strong>引用符号:&amp;</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span>&amp; j=i;<span class="hljs-comment">//引用</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Max</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; a, <span class="hljs-type">int</span>&amp; b)</span></span>;<span class="hljs-comment">//引用传参</span><br></code></pre></td></tr></table></figure><h2 id="new-delete-动态内存分配"><a href="#new-delete-动态内存分配" class="headerlink" title="new delete 动态内存分配"></a>new delete 动态内存分配</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> * pi = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">225</span>); <span class="hljs-comment">//分配的同时 初始化值</span><br><br><span class="hljs-type">int</span> * pia = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>]; <span class="hljs-comment">//数据的new和delete</span><br><span class="hljs-keyword">delete</span> []pia;<span class="hljs-comment">// 带方括号释放</span><br></code></pre></td></tr></table></figure><p>具体差别可以参考</p><p>[new delete malloc free]: ..\embedded!Main\嵌入式编程学习笔记.md#C类##newdeletemallocfree“new delete malloc free”</p><p>[new delete malloc free](..\embedded!Main\嵌入式编程学习笔记.md##new delete malloc free)</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的<strong>形式参数</strong>。</p><p>形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。</p><p>当调用函数时，有三种向函数传递参数的方式：</p><table><thead><tr><th align="left">调用类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/cplusplus/cpp-function-call-by-value.html">传值调用</a></td><td align="left">该方法把参数的实际值赋值给函数的形式参数。<br>在这种情况下，修改函数内的形式参数对实际参数没有影响。</td></tr><tr><td align="left"><a href="https://www.runoob.com/cplusplus/cpp-function-call-by-pointer.html">指针调用</a></td><td align="left">该方法把参数的地址赋值给形式参数。<br/>在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。</td></tr><tr><td align="left"><a href="https://www.runoob.com/cplusplus/cpp-function-call-by-reference.html">引用调用</a></td><td align="left">该方法把参数的引用赋值给形式参数。<br/>在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。</td></tr></tbody></table><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>当您定义一个函数，您可以为参数列表中后边的每一个参数指定默认值。当调用函数时，如果实际参数的值留空，则使用这个默认值。</p><p>这是通过在函数定义中使用赋值运算符来为参数赋值的。调用函数时，如果未传递参数的值，则会使用默认值，如果指定了值，则会忽略默认值，使用传递的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> a=<span class="hljs-number">1</span>, <span class="hljs-type">int</span> b=<span class="hljs-number">2</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//do thing</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Lambda函数-匿名函数"><a href="#Lambda函数-匿名函数" class="headerlink" title="Lambda函数 匿名函数"></a>Lambda函数 匿名函数</h3><p>C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。</p><p>Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。</p><p>Lambda 表达式本质上与函数声明非常类似。Lambda 表达式具体形式如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 有返回值</span><br>[capture](parameters)-&gt;<span class="hljs-keyword">return</span>-type&#123;body&#125;<br><span class="hljs-comment">// 无返回值</span><br>[capture](parameters)&#123;body&#125;<br><br><span class="hljs-comment">// 例子</span><br>[](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)&#123; <span class="hljs-keyword">return</span> x &lt; y ; &#125;<br><span class="hljs-comment">// 如果没有参数,空的圆括号()可以省略。</span><br>[]&#123; ++global_x; &#125; <br><span class="hljs-comment">// 在一个更为复杂的例子中，返回类型可以被明确的指定</span><br>[](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) -&gt; <span class="hljs-type">int</span> &#123; <span class="hljs-type">int</span> z = x + y; <span class="hljs-keyword">return</span> z + x; &#125;<br></code></pre></td></tr></table></figure><p>关于capture里面的值如何获取：</p><blockquote><p>  []      &#x2F;&#x2F; 沒有定义任何变量。使用未定义变量会引发错误。<br>  [x, &amp;y] &#x2F;&#x2F; x以传值方式传入（默认），y以引用方式传入。<br>  [&amp;]     &#x2F;&#x2F; 任何被使用到的外部变量都隐式地以引用方式加以引用。<br>  [&#x3D;]     &#x2F;&#x2F; 任何被使用到的外部变量都隐式地以传值方式加以引用。<br>  [&amp;, x]  &#x2F;&#x2F; x显式地以传值方式加以引用。其余变量以引用方式加以引用。<br>  [&#x3D;, &amp;z] &#x2F;&#x2F; z显式地以引用方式加以引用。其余变量以传值方式加以引用。</p></blockquote><ul><li><p>值捕获 与函数中的值传递类似。lambda表达式捕获的是变量的一个拷贝，因此我们如果在lambda表达式后面改变该变量值的话，不会影响捕获前的该变量值，这就是所谓的值捕获</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br>[a]()&#123;<span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, a;);&#125;<br></code></pre></td></tr></table></figure></li><li><p>引用捕获 引用捕获和值捕获形式完全一样，只是在捕获列表中传的是变量的引用，类似于函数中的引用传递，变成下面这个样子</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br>[&amp;a]()&#123;<span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, a;);&#125;<br></code></pre></td></tr></table></figure></li><li><p>隐式捕获的方式，就是捕获的列表可以用<code>=</code>和<code>&amp;</code>代替，让编译器隐式的推断你使用的是哪个变量，然后这两个字符表示捕获的类型<code>=</code>表示值捕获，<code>&amp;</code>是引用捕获；写出来之后就变成了如下的形式：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br>[=]()&#123;<span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, a);&#125;;<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 捕获</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string str1 = <span class="hljs-string">&quot;str1&quot;</span>;<br>    string str2 = <span class="hljs-string">&quot;str2&quot;</span>;<br>    string str3 = <span class="hljs-string">&quot;str3&quot;</span>;<br>    <br>    <span class="hljs-comment">// 这是传值捕获</span><br>    <span class="hljs-keyword">auto</span> fun = [str1, str2]() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;5 str1 : &quot;</span> &lt;&lt; str1 &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;5 str2 : &quot;</span> &lt;&lt; str2 &lt;&lt; endl;<br>    &#125;;<br>    cout &lt;&lt; <span class="hljs-string">&quot;1 str1 : &quot;</span> &lt;&lt; str1 &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;1 str2 : &quot;</span> &lt;&lt; str2 &lt;&lt; endl;<br>    str1 += str2;<br>    str2 += str1;<br>    <span class="hljs-built_in">fun</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;2 str1 : &quot;</span> &lt;&lt; str1 &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;2 str2 : &quot;</span> &lt;&lt; str2 &lt;&lt; endl;<br>    <br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 输出</span><br><span class="hljs-number">1</span> str1 : str1<br><span class="hljs-number">1</span> str2 : str2<br><span class="hljs-number">5</span> str1 : str1<br><span class="hljs-number">5</span> str2 : str2<br><span class="hljs-number">2</span> str1 : str1str2<br><span class="hljs-number">2</span> str2 : str2str1str2<br><br><span class="hljs-comment">// 被当成普通函数使用了</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string str1 = <span class="hljs-string">&quot;str1&quot;</span>;<br>    string str2 = <span class="hljs-string">&quot;str2&quot;</span>;<br>    string str3 = <span class="hljs-string">&quot;str3&quot;</span>;<br>    <br>    <span class="hljs-keyword">auto</span> stradd = [&amp;](string&amp; stra,string&amp; strb) &#123;<br>        cout &lt;&lt; stra &lt;&lt; endl;<br>        cout &lt;&lt; strb &lt;&lt; endl;<br>        stra += strb;<br>        strb += stra;<br>    &#125;;<br>    <br>    cout &lt;&lt; <span class="hljs-string">&quot;1 str1 : &quot;</span> &lt;&lt; str1 &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;1 str2 : &quot;</span> &lt;&lt; str2 &lt;&lt; endl;<br>    <span class="hljs-built_in">stradd</span>(str1, str2);<br>    cout &lt;&lt; <span class="hljs-string">&quot;2 str1 : &quot;</span> &lt;&lt; str1 &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;2 str2 : &quot;</span> &lt;&lt; str2 &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//输出</span><br><span class="hljs-number">1</span> str1 : str1<br><span class="hljs-number">1</span> str2 : str2<br>str1<br>str2<br><span class="hljs-number">2</span> str1 : str1str2<br><span class="hljs-number">2</span> str2 : str2str1str2<br></code></pre></td></tr></table></figure><ul><li>这个知识点没看懂是匿了什么名, 不知所云, 难道和匿名没关系?只是捕获的功能?</li></ul><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><ul><li>确保函数名一致，在调用时根据参数来判断调用那个函数。</li><li>其参数个数或类型有所不同。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Max</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Max</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span></span>;<br><br><br><span class="hljs-built_in">Max</span>(<span class="hljs-number">112</span>, <span class="hljs-number">223</span>)<br><span class="hljs-built_in">Max</span>(<span class="hljs-number">1.2</span>, <span class="hljs-number">2.3</span>)<br></code></pre></td></tr></table></figure><h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><ul><li>对象是类的实例</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>;<span class="hljs-comment">//类的声明，在被引用前声明，被其他类引用相互引用</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span><br>&#123;<br>    <span class="hljs-type">int</span> a;<span class="hljs-comment">//默认私有属性，数据成员不能初始化 //int a(20);错误</span><br><span class="hljs-keyword">public</span>:<span class="hljs-comment">//公有成员</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Fun</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<span class="hljs-comment">//这里放声明，或者直接定义在类里面(直接定义在类里面默认内联)</span><br><span class="hljs-keyword">private</span>:<span class="hljs-comment">//私有成员</span><br><span class="hljs-keyword">protected</span>:<span class="hljs-comment">//保护成员</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MyClass::Fun</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><span class="hljs-comment">//可以定义在类里面，也可以定义在外面</span></span><br><span class="hljs-function"></span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ul><li><strong>与类同名</strong></li><li>(有但不指定)返回值</li><li><strong>可重载</strong></li><li>可以有传入参数</li><li>创建对象时自动调用</li><li>初始化由类中声明顺序决定，与初始化列表顺序无关</li><li>初始化列表优先于构造函数内的赋值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Line</span><br>&#123;<br>   <span class="hljs-keyword">public</span>:<br>      <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setLength</span><span class="hljs-params">( <span class="hljs-type">double</span> len )</span></span>;<br>      <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getLength</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span></span>;<br>      <span class="hljs-built_in">Line</span>(<span class="hljs-type">double</span> len);  <span class="hljs-comment">// 这是构造函数</span><br> <br>   <span class="hljs-keyword">private</span>:<br>      <span class="hljs-type">double</span> length;<br>&#125;;<br><span class="hljs-comment">// 成员函数定义，包括构造函数</span><br>Line::<span class="hljs-built_in">Line</span>( <span class="hljs-type">double</span> len)<br>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Object is being created, length = &quot;</span> &lt;&lt; len &lt;&lt; endl;<br>    length = len;<br>&#125;<br> <br></code></pre></td></tr></table></figure><h4 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h4><p>使用初始化列表来初始化字段：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">Line::<span class="hljs-built_in">Line</span>( <span class="hljs-type">double</span> len): <span class="hljs-built_in">length</span>(len)<br>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Object is being created, length = &quot;</span> &lt;&lt; len &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的语法等同于如下语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">Line::<span class="hljs-built_in">Line</span>( <span class="hljs-type">double</span> len)<br>&#123;<br>    length = len;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Object is being created, length = &quot;</span> &lt;&lt; len &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>假设有一个类 C，具有多个字段 X、Y、Z 等需要进行初始化，同理地，您可以使用上面的语法，只需要在不同的字段使用逗号进行分隔，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">C::<span class="hljs-built_in">C</span>( <span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b, <span class="hljs-type">double</span> c): <span class="hljs-built_in">X</span>(a), <span class="hljs-built_in">Y</span>(b), <span class="hljs-built_in">Z</span>(c)<br>&#123;<br>  ....<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><ul><li>类名前加 ~</li><li>不能有返回值</li><li>无参数，不重载</li><li>销毁系统自动调用</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">~<span class="hljs-built_in">MyClass</span>()<br>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Delete MyClass:&quot;</span> &lt;&lt; name &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h3><ul><li>与类同名</li><li>只有一个参数即对同类引用</li></ul><p><strong>被调用的情况</strong></p><ul><li>用类的已知对象初始化另一个正在创建的对象</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">MyClass</span>( <span class="hljs-type">const</span> MyClass&amp; cIn )<br>&#123;<br>    x = cIn.x;<br>    y = cIn.y;<br>    name = cIn.name;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Copy MyClass&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h2><p>this指针指向类对象的地址</p><p><strong>以下两函数等价</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MyClass::Fun</span><span class="hljs-params">( <span class="hljs-type">int</span> in )</span></span><br><span class="hljs-function"></span>&#123;<br>x = in;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MyClass::Fun</span><span class="hljs-params">( <span class="hljs-type">int</span> in )</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">this</span>-&gt;x = in;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="静态成员-static"><a href="#静态成员-static" class="headerlink" title="静态成员 static"></a>静态成员 static</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>所有类的对象有一个相同唯一的  数据成员 (共同点)</p><ul><li><p>static 声明的 数据成员(初始化不加static)</p></li><li><p>作用域是类范围类</p></li><li><p>必须要进行初始化，文件作用域进行初始化</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<span class="hljs-comment">//公有成员</span><br>    <span class="hljs-built_in">MyClass</span>( xxx ):xxx <span class="hljs-comment">//构造函数</span><br>&#123;<br>cont++;<span class="hljs-comment">//静态与非静态 数据成员访问方式一致，每构造一个类就会++</span><br>&#125;<br><span class="hljs-keyword">private</span>:<span class="hljs-comment">//私有成员</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> cont;<br>&#125;<br><br><span class="hljs-type">int</span> MyClass::cont = <span class="hljs-number">0</span>;<span class="hljs-comment">//文件作用范围 初始化</span><br><br></code></pre></td></tr></table></figure><h3 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h3><p>所有类的对象有一个相同唯一的   函数 (操作)，该函数不能直接访问非静态成员(static 变量)。</p><ul><li>static 声明的函数(类外定义不能加static)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<span class="hljs-comment">//公有成员</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span></span>;<br><span class="hljs-keyword">private</span>:<span class="hljs-comment">//私有成员</span><br><span class="hljs-type">int</span> x, y;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> cont;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyClass::Print</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><span class="hljs-comment">//不加static</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Print1&quot;</span> &lt;&lt; cont &lt;&lt; endl;<span class="hljs-comment">//不能使用 this ，不能引用 x、y</span><br>&#125;<br><br><br>MyClass A,B;<br><br>MyClass.<span class="hljs-built_in">Print</span>();<span class="hljs-comment">//建议访问方式 (表明该成员属于类，而不是对象)</span><br>A.<span class="hljs-built_in">Print</span>();<span class="hljs-comment">//效果一致不建议使用</span><br>B.<span class="hljs-built_in">Print</span>();<span class="hljs-comment">//效果一致不建议使用</span><br></code></pre></td></tr></table></figure><h2 id="常成员-const"><a href="#常成员-const" class="headerlink" title="常成员 const"></a>常成员 const</h2><h3 id="常对象"><a href="#常对象" class="headerlink" title="常对象"></a>常对象</h3><ul><li>不可更改</li><li>定义时必须初始化</li><li>只能调用 常成员函数(有const)，不能调用一般的成员函数(没有const的一般函数)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">&lt;类名&gt; <span class="hljs-type">const</span> &lt;对象名&gt;<br><span class="hljs-type">const</span> &lt;类名&gt; &lt;对象名&gt;<br><br><span class="hljs-function"><span class="hljs-type">const</span> MyClass <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="常数据成员"><a href="#常数据成员" class="headerlink" title="常数据成员"></a>常数据成员</h3><ul><li>只能通过构造函数成员初始化列表显式初始化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<span class="hljs-comment">//公有成员</span><br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> i):<span class="hljs-built_in">a</span>(i) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetCont</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">private</span>:<span class="hljs-comment">//私有成员</span><br><span class="hljs-type">int</span> x, y;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> a;<br>&#125;;<br><br><span class="hljs-type">int</span> MyClass::a = <span class="hljs-number">9</span>;<span class="hljs-comment">//初始化</span><br></code></pre></td></tr></table></figure><h3 id="常成员函数"><a href="#常成员函数" class="headerlink" title="常成员函数"></a>常成员函数</h3><ul><li>声明 定义都需要const</li><li>常成员函数 不能更改对象的数据成员</li><li>可重载</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++">&lt;返回类型&gt; &lt;成员函数名&gt; (&lt;参数表&gt;) <span class="hljs-type">const</span>;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<span class="hljs-comment">//公有成员</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetCont</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">private</span>:<span class="hljs-comment">//私有成员</span><br><span class="hljs-type">int</span> x, y;<br>    <span class="hljs-type">int</span> cont;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MyClass::GetCont</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span> <span class="hljs-type">const</span><span class="hljs-comment">//需要加const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//return cont++;//不允许更改 数据成员</span><br>    <span class="hljs-keyword">return</span> cont;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h1 id="Lib"><a href="#Lib" class="headerlink" title="Lib"></a>Lib</h1><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><ul><li>每个头文件只声明一个类</li><li>#ifndef 防止重复包含</li><li>cpp 和 h 文件应该同名</li></ul><h2 id="读取文件发现数据长度不对"><a href="#读取文件发现数据长度不对" class="headerlink" title="读取文件发现数据长度不对"></a>读取文件发现数据长度不对</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 方法一</span><br>InLogFile.<span class="hljs-built_in">seekg</span>(<span class="hljs-number">0</span>, ios::end);<br>streampos pos = InLogFile.<span class="hljs-built_in">tellg</span>();<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> length = pos;<br><br>InLogFile.<span class="hljs-built_in">seekg</span>(<span class="hljs-number">0</span>, ios::beg);<br><span class="hljs-type">char</span> * pBuffer = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[length];<br><span class="hljs-built_in">memset</span>(pBuffer, <span class="hljs-number">0</span>, length);<br>InLogFile.<span class="hljs-built_in">read</span>(pBuffer, length);<br><br><br><span class="hljs-comment">// 方法二</span><br>std::string strr;<br>&#123; <span class="hljs-comment">// 读出全部文件</span><br>    <span class="hljs-function">std::ifstream <span class="hljs-title">in</span><span class="hljs-params">(InFilePath)</span></span>;<br>    std::ostringstream tmp;<br>    tmp &lt;&lt; in.<span class="hljs-built_in">rdbuf</span>();<br>    strr = tmp.<span class="hljs-built_in">str</span>();<br>&#125;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;length&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; length &lt;&lt; endl;<br>cout &lt;&lt; strr.<span class="hljs-built_in">length</span>() &lt;&lt; endl;<br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">12552<br>12352<br></code></pre></td></tr></table></figure><p>他们的输出结果似乎不太一样, 好像是对 <code>0D 0A</code> 的数量计算方法不太一致导致的.</p><h2 id="读取文件全部内容"><a href="#读取文件全部内容" class="headerlink" title="读取文件全部内容"></a>读取文件全部内容</h2><p>iostream著名专家Dietmar Kuehl给出了两个读取方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::ifstream <span class="hljs-title">in</span><span class="hljs-params">(<span class="hljs-string">&quot;some.file&quot;</span>)</span></span>;<br><span class="hljs-function">std::isreambuf_iterator&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title">begin</span><span class="hljs-params">(in)</span></span>;<br>std::isreambuf_iterator&lt;<span class="hljs-type">char</span>&gt; end;<br><span class="hljs-function">std::string <span class="hljs-title">some_str</span><span class="hljs-params">(begin, end)</span></span>;<span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::ifstream <span class="hljs-title">in</span><span class="hljs-params">(<span class="hljs-string">&quot;some.file&quot;</span>)</span></span>;<br>std::ostringstream tmp;<br>tmp &lt;&lt; in.<span class="hljs-built_in">rdbuf</span>();<br>std::string str = tmp.<span class="hljs-built_in">str</span>();<br></code></pre></td></tr></table></figure><h2 id="C-x2F-C-调用exe文件"><a href="#C-x2F-C-调用exe文件" class="headerlink" title="C&#x2F;C++调用exe文件"></a>C&#x2F;C++调用exe文件</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C 此为命令行控制台方法</span><br><span class="hljs-type">char</span>* a1 = (<span class="hljs-type">char</span>*)<span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-type">char</span>* a2 = (<span class="hljs-type">char</span>*)<span class="hljs-string">&quot;world&quot;</span>;<br><span class="hljs-type">char</span>* a3 = (<span class="hljs-type">char</span>*)<span class="hljs-string">&quot;!&quot;</span>;<br><span class="hljs-type">char</span> s[<span class="hljs-number">100</span>];<br>sprintf_s(s,<span class="hljs-string">&quot;%s %s %s %s &quot;</span>,<span class="hljs-string">&quot;./ceshi.exe&quot;</span>,a1,a2,a3);<br>system(s);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WSL</title>
    <link href="/2021/784ee20b/"/>
    <url>/2021/784ee20b/</url>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>若要检查 Windows 版本及内部版本号，选择 Windows 徽标键 + R，然后键入“winver”，选择“确定”。更新到“设置”菜单中的<a href="ms-settings:windowsupdate">最新 Windows 版本</a>。</p><p><em><strong>IF</strong></em> (Windows 10 版本 2004 及更高版本（内部版本 19041 及更高版本）或 Windows 11)</p><p><a href="https://docs.microsoft.com/zh-cn/windows/wsl/install">一键自动安装 WSL</a></p><p><em><strong>ELSE</strong></em></p><p><a href="https://docs.microsoft.com/zh-cn/windows/wsl/install-manual">旧版 WSL 的手动安装步骤(可以更改WSL系统的存放位置)</a></p><h2 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h2><p>以下指令需要在<strong>管理员</strong>下的 powershell 运行</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 1 开启Microsoft-Windows-Subsystem-Linux</span><br>dism.exe <span class="hljs-regexp">/online /</span>enable-feature <span class="hljs-regexp">/featurename:Microsoft-Windows-Subsystem-Linux /</span>all /norestart<br><br><span class="hljs-comment"># 2 开启VirtualMachinePlatform</span><br>dism.exe <span class="hljs-regexp">/online /</span>enable-feature <span class="hljs-regexp">/featurename:VirtualMachinePlatform /</span>all /norestart<br><br><span class="hljs-comment"># 3 重启</span><br><span class="hljs-comment"># reboot</span><br><br><span class="hljs-comment"># 4 安装WLS2内核更新包</span><br>https:<span class="hljs-regexp">//</span>wslstorestorage.blob.core.windows.net<span class="hljs-regexp">/wslblob/</span>wsl_update_x64.msi<br><br><span class="hljs-comment"># 5 将WSL2设为默认</span><br>wsl --set-default-version <span class="hljs-number">2</span><br><br><span class="hljs-comment"># 6 下载离线包(可以避免将WSL的系统装在C盘)</span><br>https:<span class="hljs-regexp">//</span>docs.microsoft.com<span class="hljs-regexp">/zh-cn/</span>windows<span class="hljs-regexp">/wsl/i</span>nstall-manual<br><span class="hljs-comment"># example</span><br>https:<span class="hljs-regexp">//</span>aka.ms/wslubuntu2004<br>https:<span class="hljs-regexp">//</span>aka.ms/wsl-ubuntu-<span class="hljs-number">1804</span><br>https:<span class="hljs-regexp">//</span>aka.ms/wsl-debian-gnulinux<br><span class="hljs-comment"># 离线包下载完成后解压缩 运行目录内的ubuntu.exe</span><br><span class="hljs-comment"># 会提示输入用户名和密码</span><br><br><span class="hljs-comment"># 7 (可选)安装 windows终端</span><br>https:<span class="hljs-regexp">//</span>docs.microsoft.com<span class="hljs-regexp">/en-us/</span>windows<span class="hljs-regexp">/terminal/g</span>et-started 可选 <br></code></pre></td></tr></table></figure><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><h2 id="U盘挂载"><a href="#U盘挂载" class="headerlink" title="U盘挂载"></a>U盘挂载</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1 新建文件夹g</span><br>sudo mkdir /mnt/g<br><span class="hljs-meta prompt_"># </span><span class="language-bash">2 挂载盘符g</span><br>sudo mount -t drvfs g: /mnt/g<br><span class="hljs-meta prompt_"># </span><span class="language-bash">大功告成。进入/mnt/g即可操作</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">弹出移动硬盘，这样才能在windows下正常弹出，否则是会一直占用的。</span><br>sudo umount /mnt/g<br></code></pre></td></tr></table></figure><h2 id="映射wsl文件系统"><a href="#映射wsl文件系统" class="headerlink" title="映射wsl文件系统"></a>映射wsl文件系统</h2><p><img src="/2021/784ee20b/image-20211129131237501.png" alt="image-20211129131237501"></p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">\\wsl<span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure><p>通过 <code>\\wsl$</code> 访问 Linux 文件时将使用 WSL 分发版的默认用户。 因此，任何访问 Linux 文件的 Windows 应用都具有与默认用户相同的权限。</p><h2 id="wsl关机"><a href="#wsl关机" class="headerlink" title="wsl关机"></a>wsl关机</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wsl --shutdown<br></code></pre></td></tr></table></figure><h2 id="wsl-配置文件"><a href="#wsl-配置文件" class="headerlink" title="wsl 配置文件"></a>wsl 配置文件</h2><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># Settings apply across all Linux distros running on WSL 2</span><br><span class="hljs-section">[wsl2]</span><br><br><span class="hljs-comment"># Limits VM memory to use no more than 4 GB, this can be set as whole numbers using GB or MB</span><br><span class="hljs-attr">memory</span>=<span class="hljs-number">4</span>GB <br><br><span class="hljs-comment"># Sets the VM to use two virtual processors</span><br><span class="hljs-attr">processors</span>=<span class="hljs-number">2</span><br><br><span class="hljs-comment"># Specify a custom Linux kernel to use with your installed distros. The default kernel used can be found at https://github.com/microsoft/WSL2-Linux-Kernel</span><br><span class="hljs-attr">kernel</span>=C:\\temp\\myCustomKernel<br><br><span class="hljs-comment"># Sets additional kernel parameters, in this case enabling older Linux base images such as Centos 6</span><br><span class="hljs-attr">kernelCommandLine</span> = vsyscall=emulate<br><br><span class="hljs-comment"># Sets amount of swap storage space to 8GB, default is 25% of available RAM</span><br><span class="hljs-comment"># 虚拟内存</span><br><span class="hljs-attr">swap</span>=<span class="hljs-number">8</span>GB<br><br><span class="hljs-comment"># Sets swapfile path location, default is %USERPROFILE%\AppData\Local\Temp\swap.vhdx</span><br><span class="hljs-attr">swapfile</span>=C:\\temp\\wsl-swap.vhdx<br><br><span class="hljs-comment"># Disable page reporting so WSL retains all allocated memory claimed from Windows and releases none back when free</span><br><span class="hljs-attr">pageReporting</span>=<span class="hljs-literal">false</span><br><br><span class="hljs-comment"># Turn off default connection to bind WSL 2 localhost to Windows localhost</span><br><span class="hljs-attr">localhostforwarding</span>=<span class="hljs-literal">true</span><br><br><span class="hljs-comment"># Disables nested virtualization</span><br><span class="hljs-attr">nestedVirtualization</span>=<span class="hljs-literal">false</span><br><br><span class="hljs-comment"># Turns on output console showing contents of dmesg when opening a WSL 2 distro for debugging</span><br><span class="hljs-attr">debugConsole</span>=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>打开powershell输入<code>~</code>切换目录</p><p><code>code .wslconfig</code>编辑配置</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[wsl2]</span><br><span class="hljs-attr">memory</span>=<span class="hljs-number">2</span>GB<br><span class="hljs-attr">swap</span>=<span class="hljs-number">2</span>GB<br><span class="hljs-attr">localhostForwarding</span>=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h2 id="WSL-配置代理"><a href="#WSL-配置代理" class="headerlink" title="WSL 配置代理"></a>WSL 配置代理</h2><p><strong>获取主机 IP      主机 IP 保存在 &#x2F;etc&#x2F;resolv.conf 中</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> hostip=$(<span class="hljs-built_in">cat</span> /etc/resolv.conf |grep -oP <span class="hljs-string">&#x27;(?&lt;=nameserver\ ).*&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> https_proxy=<span class="hljs-string">&quot;http://<span class="hljs-variable">$&#123;hostip&#125;</span>:10881&quot;</span><br><span class="hljs-built_in">export</span> http_proxy=<span class="hljs-string">&quot;http://<span class="hljs-variable">$&#123;hostip&#125;</span>:10881&quot;</span><br><br><span class="hljs-built_in">export</span> http_proxy=<span class="hljs-string">&quot;socks5://<span class="hljs-variable">$&#123;hostip&#125;</span>:7890&quot;</span><br><span class="hljs-built_in">export</span> https_proxy=<span class="hljs-string">&quot;socks5://<span class="hljs-variable">$&#123;hostip&#125;</span>:7890&quot;</span><br><br><span class="hljs-built_in">export</span> all_proxy=<span class="hljs-string">&quot;socks5://<span class="hljs-variable">$&#123;hostip&#125;</span>:10880&quot;</span><br><span class="hljs-built_in">export</span> all_proxy=<span class="hljs-string">&quot;http://<span class="hljs-variable">$&#123;hostip&#125;</span>:10881&quot;</span><br></code></pre></td></tr></table></figure><ul><li>在wsl尝试用<code>export all_proxy</code>socks5做代理感觉总是调不通, 换成http就好了  不知道是为啥</li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WSL</tag>
      
      <tag>Windows</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bluetooth蓝牙</title>
    <link href="/2021/95869d00/"/>
    <url>/2021/95869d00/</url>
    
    <content type="html"><![CDATA[<h1 id="蓝牙分类"><a href="#蓝牙分类" class="headerlink" title="蓝牙分类"></a>蓝牙分类</h1><pre><code class=" mermaid">graph LRBluetooth_3.0 --&gt;BRBluetooth_3.0 --&gt;EDRBluetooth_3.0 --&gt;AMP_HS</code></pre><pre><code class=" mermaid">graph LRBluetooth_4.0 --&gt;BRBluetooth_4.0 --&gt;EDRBluetooth_4.0 --&gt;AMP_HSBluetooth_4.0 --&gt;LE</code></pre><p>只有一种蓝牙即 Bluetooth SIG。</p><p>但是蓝牙技术本身包括四种类型：BR、EDR、AMP 和 LE。</p><p>为了方便，人们将以前的 BR&#x2F;EDR&#x2F;AMP 技术称为“经典蓝牙”（BT）技术。</p><p>LE也即低功耗蓝牙BLE。</p><h1 id="SPP"><a href="#SPP" class="headerlink" title="SPP"></a>SPP</h1><p>SPP（Serial Port Profile）串口</p>]]></content>
    
    
    <categories>
      
      <category>Communication</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
      <tag>Bluetooth</tag>
      
      <tag>蓝牙</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RT-Thread</title>
    <link href="/2021/42e53028/"/>
    <url>/2021/42e53028/</url>
    
    <content type="html"><![CDATA[<h1 id="RT-Thread-目录"><a href="#RT-Thread-目录" class="headerlink" title="RT-Thread 目录"></a>RT-Thread 目录</h1><p>[TOC]</p><h1 id="内核简介"><a href="#内核简介" class="headerlink" title="内核简介"></a>内核简介</h1><h2 id="自动初始化机制"><a href="#自动初始化机制" class="headerlink" title="自动初始化机制"></a>自动初始化机制</h2><table><thead><tr><th><strong>初始化顺序</strong></th><th><strong>宏接口</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>1</td><td>INIT_BOARD_EXPORT(fn)</td><td>非常早期的初始化，此时调度器还未启动</td></tr><tr><td>2</td><td>INIT_PREV_EXPORT(fn)</td><td>主要是用于纯软件的初始化、没有太多依赖的函数</td></tr><tr><td>3</td><td>INIT_DEVICE_EXPORT(fn)</td><td>外设驱动初始化相关，比如网卡设备</td></tr><tr><td>4</td><td>INIT_COMPONENT_EXPORT(fn)</td><td>组件初始化，比如文件系统或者 LWIP</td></tr><tr><td>5</td><td>INIT_ENV_EXPORT(fn)</td><td>系统环境初始化，比如挂载文件系统</td></tr><tr><td>6</td><td>INIT_APP_EXPORT(fn)</td><td>应用初始化，比如 GUI 应用</td></tr></tbody></table><h2 id="内核对象管理架构"><a href="#内核对象管理架构" class="headerlink" title="内核对象管理架构"></a>内核对象管理架构</h2><p>派生和继承</p><p><img src="/2021/42e53028/03kernel_object-1608970713169.png" alt="RT-Thread 的内核对象容器及链表"></p><p><img src="/2021/42e53028/03kernel_object2-1608970663476.png" alt="03kernel_object2"></p><h2 id="内核rtconfig-h配置"><a href="#内核rtconfig-h配置" class="headerlink" title="内核rtconfig.h配置"></a>内核rtconfig.h配置</h2><p>（1）RT-Thread 内核部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 表示内核对象的名称的最大长度，若代码中对象名称的最大长度大于宏定义的长度，</span><br><span class="hljs-comment"> * 多余的部分将被截掉。*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_NAME_MAX 8</span><br><br><span class="hljs-comment">/* 字节对齐时设定对齐的字节个数。常使用 ALIGN(RT_ALIGN_SIZE) 进行字节对齐。*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_ALIGN_SIZE 4</span><br><br><span class="hljs-comment">/* 定义系统线程优先级数；通常用 RT_THREAD_PRIORITY_MAX-1 定义空闲线程的优先级 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_THREAD_PRIORITY_MAX 32</span><br><br><span class="hljs-comment">/* 定义时钟节拍，为 100 时表示 100 个 tick 每秒，一个 tick 为 10ms */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_TICK_PER_SECOND 100</span><br><br><span class="hljs-comment">/* 检查栈是否溢出，未定义则关闭 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USING_OVERFLOW_CHECK</span><br><br><span class="hljs-comment">/* 定义该宏开启 debug 模式，未定义则关闭 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_DEBUG</span><br><span class="hljs-comment">/* 开启 debug 模式时：该宏定义为 0 时表示关闭打印组件初始化信息，定义为 1 时表示启用 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_DEBUG_INIT 0</span><br><span class="hljs-comment">/* 开启 debug 模式时：该宏定义为 0 时表示关闭打印线程切换信息，定义为 1 时表示启用 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_DEBUG_THREAD 0</span><br><br><span class="hljs-comment">/* 定义该宏表示开启钩子函数的使用，未定义则关闭 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USING_HOOK</span><br><br><span class="hljs-comment">/* 定义了空闲线程的栈大小 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IDLE_THREAD_STACK_SIZE 256</span><br></code></pre></td></tr></table></figure><p>（2）线程间同步与通信部分，该部分会使用到的对象有信号量、互斥量、事件、邮箱、消息队列、信号等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 定义该宏可开启信号量的使用，未定义则关闭 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USING_SEMAPHORE</span><br><br><span class="hljs-comment">/* 定义该宏可开启互斥量的使用，未定义则关闭 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USING_MUTEX</span><br><br><span class="hljs-comment">/* 定义该宏可开启事件集的使用，未定义则关闭 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USING_EVENT</span><br><br><span class="hljs-comment">/* 定义该宏可开启邮箱的使用，未定义则关闭 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USING_MAILBOX</span><br><br><span class="hljs-comment">/* 定义该宏可开启消息队列的使用，未定义则关闭 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USING_MESSAGEQUEUE</span><br><br><span class="hljs-comment">/* 定义该宏可开启信号的使用，未定义则关闭 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USING_SIGNALS</span><br></code></pre></td></tr></table></figure><p>（3）内存管理部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 开启静态内存池的使用 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USING_MEMPOOL</span><br><br><span class="hljs-comment">/* 定义该宏可开启两个或以上内存堆拼接的使用，未定义则关闭 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USING_MEMHEAP</span><br><br><span class="hljs-comment">/* 开启小内存管理算法 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USING_SMALL_MEM</span><br><br><span class="hljs-comment">/* 关闭 SLAB 内存管理算法 */</span><br><span class="hljs-comment">/* #define RT_USING_SLAB */</span><br><br><span class="hljs-comment">/* 开启堆的使用 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USING_HEAP</span><br></code></pre></td></tr></table></figure><p>（4）内核设备对象</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 表示开启了系统设备的使用 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USING_DEVICE</span><br><br><span class="hljs-comment">/* 定义该宏可开启系统控制台设备的使用，未定义则关闭 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USING_CONSOLE</span><br><span class="hljs-comment">/* 定义控制台设备的缓冲区大小 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_CONSOLEBUF_SIZE 128</span><br><span class="hljs-comment">/* 控制台设备的名称 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_CONSOLE_DEVICE_NAME <span class="hljs-string">&quot;uart1&quot;</span></span><br></code></pre></td></tr></table></figure><p>（5）自动初始化方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 定义该宏开启自动初始化机制，未定义则关闭 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USING_COMPONENTS_INIT</span><br><br><span class="hljs-comment">/* 定义该宏开启设置应用入口为 main 函数 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USING_USER_MAIN</span><br><span class="hljs-comment">/* 定义 main 线程的栈大小 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_MAIN_THREAD_STACK_SIZE 2048</span><br></code></pre></td></tr></table></figure><p>（6）FinSH</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 定义该宏可开启系统 FinSH 调试工具的使用，未定义则关闭 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USING_FINSH</span><br><br><span class="hljs-comment">/* 开启系统 FinSH 时：将该线程名称定义为 tshell */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FINSH_THREAD_NAME <span class="hljs-string">&quot;tshell&quot;</span></span><br><br><span class="hljs-comment">/* 开启系统 FinSH 时：使用历史命令 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FINSH_USING_HISTORY</span><br><span class="hljs-comment">/* 开启系统 FinSH 时：对历史命令行数的定义 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FINSH_HISTORY_LINES 5</span><br><br><span class="hljs-comment">/* 开启系统 FinSH 时：定义该宏开启使用 Tab 键，未定义则关闭 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FINSH_USING_SYMTAB</span><br><br><span class="hljs-comment">/* 开启系统 FinSH 时：定义该线程的优先级 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FINSH_THREAD_PRIORITY 20</span><br><span class="hljs-comment">/* 开启系统 FinSH 时：定义该线程的栈大小 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FINSH_THREAD_STACK_SIZE 4096</span><br><span class="hljs-comment">/* 开启系统 FinSH 时：定义命令字符长度 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FINSH_CMD_SIZE 80</span><br><br><span class="hljs-comment">/* 开启系统 FinSH 时：定义该宏开启 MSH 功能 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FINSH_USING_MSH</span><br><span class="hljs-comment">/* 开启系统 FinSH 时：开启 MSH 功能时，定义该宏默认使用 MSH 功能 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FINSH_USING_MSH_DEFAULT</span><br><span class="hljs-comment">/* 开启系统 FinSH 时：定义该宏，仅使用 MSH 功能 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FINSH_USING_MSH_ONLY</span><br></code></pre></td></tr></table></figure><p>（7）关于 MCU</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 定义该工程使用的 MCU 为 STM32F103ZE；系统通过对芯片类型的定义，来定义芯片的管脚 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STM32F103ZE</span><br><br><span class="hljs-comment">/* 定义时钟源频率 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_HSE_VALUE 8000000</span><br><br><span class="hljs-comment">/* 定义该宏开启 UART1 的使用 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USING_UART1</span><br></code></pre></td></tr></table></figure><h2 id="常见宏定义说明"><a href="#常见宏定义说明" class="headerlink" title="常见宏定义说明"></a>常见宏定义说明</h2><p>1）rt_inline，定义如下，static 关键字的作用是令函数只能在当前的文件中使用；inline 表示内联，用 static 修饰后在调用函数时会建议编译器进行内联展开。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> rt_inline                   static __inline</span><br></code></pre></td></tr></table></figure><p>2）RT_USED，定义如下，该宏的作用是向编译器说明这段代码有用，即使函数中没有调用也要保留编译。例如 RT-Thread 自动初始化功能使用了自定义的段，使用 RT_USED 会将自定义的代码段保留。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USED                     __attribute__((used))</span><br></code></pre></td></tr></table></figure><p>3）RT_UNUSED，定义如下，表示函数或变量可能不使用，这个属性可以避免编译器产生警告信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_UNUSED                   __attribute__((unused))</span><br></code></pre></td></tr></table></figure><p>4）RT_WEAK，定义如下，常用于定义函数，编译器在链接函数时会优先链接没有该关键字前缀的函数，如果找不到则再链接由 weak 修饰的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_WEAK                     __weak</span><br></code></pre></td></tr></table></figure><p>5）ALIGN(n)，定义如下，作用是在给某对象分配地址空间时，将其存放的地址按照 n 字节对齐，这里 n 可取 2 的幂次方。字节对齐的作用不仅是便于 CPU 快速访问，同时合理的利用字节对齐可以有效地节省存储空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ALIGN(n)                    __attribute__((aligned(n)))</span><br></code></pre></td></tr></table></figure><p>6）RT_ALIGN(size,align)，定义如下，作用是将 size 提升为 align 定义的整数的倍数，例如，RT_ALIGN(13,4) 将返回 16。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_ALIGN(size, align)      (((size) + (align) - 1) &amp; ~((align) - 1))</span><br></code></pre></td></tr></table></figure><h1 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h1><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><table><thead><tr><th><strong>状态</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>初始状态</td><td>当线程刚开始创建还没开始运行时就处于初始状态；<br/>在初始状态下，线程不参与调度。<br/>此状态在 RT-Thread 中的宏定义为 RT_THREAD_INIT</td></tr><tr><td>就绪状态</td><td>在就绪状态下，线程按照优先级排队，等待被执行；<br/>一旦当前线程运行完毕让出处理器，操作系统会马上寻找最高优先级的就绪态线程运行。<br/>此状态在 RT-Thread 中的宏定义为 RT_THREAD_READY</td></tr><tr><td>运行状态</td><td>线程当前正在运行。在单核系统中，只有 rt_thread_self() 函数返回的线程处于运行状态；<br/>在多核系统中，可能就不止这一个线程处于运行状态。<br/>此状态在 RT-Thread 中的宏定义为 RT_THREAD_RUNNING</td></tr><tr><td>挂起状态</td><td>也称阻塞态。它可能因为资源不可用而挂起等待，或线程主动延时一段时间而挂起。<br/>在挂起状态下，线程不参与调度。<br/>此状态在 RT-Thread 中的宏定义为 RT_THREAD_SUSPEND</td></tr><tr><td>关闭状态</td><td>当线程运行结束时将处于关闭状态。<br/>关闭状态的线程不参与线程的调度。<br/>此状态在 RT-Thread 中的宏定义为 RT_THREAD_CLOSE</td></tr></tbody></table><h2 id="线程状态的切换"><a href="#线程状态的切换" class="headerlink" title="线程状态的切换"></a>线程状态的切换</h2><p><img src="/2021/42e53028/04thread_sta.png" alt="线程状态转换图"></p><h2 id="线程的管理API"><a href="#线程的管理API" class="headerlink" title="线程的管理API"></a>线程的管理API</h2><p><img src="/2021/42e53028/04thread_ops.png" alt="线程相关操作"></p><h3 id="创建删除-create"><a href="#创建删除-create" class="headerlink" title="创建删除-create"></a>创建删除-create</h3><p>系统会从动态堆内存中分配一个线程句柄以及按照参数中指定的栈大小从动态堆内存中分配相应的空间。分配出来的栈空间是按照 rtconfig.h 中配置的 <strong>RT_ALIGN_SIZE</strong> 方式对齐</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_thread_t</span> <span class="hljs-title function_">rt_thread_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name,</span><br><span class="hljs-params">                            <span class="hljs-type">void</span> (*entry)(<span class="hljs-type">void</span>* parameter),</span><br><span class="hljs-params">                            <span class="hljs-type">void</span>* parameter,</span><br><span class="hljs-params">                            <span class="hljs-type">rt_uint32_t</span> stack_size,</span><br><span class="hljs-params">                            <span class="hljs-type">rt_uint8_t</span> priority,</span><br><span class="hljs-params">                            <span class="hljs-type">rt_uint32_t</span> tick)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>name</td><td>线程的名称；<br/>线程名称的最大长度由 rtconfig.h 中的宏 RT_NAME_MAX 指定，多余部分会被自动截掉</td></tr><tr><td>entry</td><td>线程入口函数</td></tr><tr><td>parameter</td><td>线程入口函数参数</td></tr><tr><td>stack_size</td><td>线程栈大小，单位是字节</td></tr><tr><td>priority</td><td>线程的优先级。<br/>优先级范围根据系统配置情况（rtconfig.h 中的 RT_THREAD_PRIORITY_MAX 宏定义），如果支持的是 256 级优先级，那么范围是从 0~255，数值越小优先级越高，0 代表最高优先级</td></tr><tr><td>tick</td><td>线程的时间片大小。<br/>时间片（tick）的单位是操作系统的时钟节拍。当系统中存在相同优先级线程时，这个参数指定线程一次调度能够运行的最大时间长度。这个时间片运行结束时，调度器自动选择下一个就绪态的同优先级线程进行运行</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>thread</td><td>线程创建成功，返回线程句柄</td></tr><tr><td>RT_NULL</td><td>线程创建失败</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_delete</span><span class="hljs-params">(<span class="hljs-type">rt_thread_t</span> thread)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>thread</td><td>要删除的线程句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>删除线程成功</td></tr><tr><td>-RT_ERROR</td><td>删除线程失败</td></tr></tbody></table><h3 id="初始化和脱离-init"><a href="#初始化和脱离-init" class="headerlink" title="初始化和脱离-init"></a>初始化和脱离-init</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_init</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> rt_thread* thread,</span><br><span class="hljs-params">                        <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name,</span><br><span class="hljs-params">                        <span class="hljs-type">void</span> (*entry)(<span class="hljs-type">void</span>* parameter), <span class="hljs-type">void</span>* parameter,</span><br><span class="hljs-params">                        <span class="hljs-type">void</span>* stack_start, <span class="hljs-type">rt_uint32_t</span> stack_size,</span><br><span class="hljs-params">                        <span class="hljs-type">rt_uint8_t</span> priority, <span class="hljs-type">rt_uint32_t</span> tick)</span>;<br></code></pre></td></tr></table></figure><p>静态线程的线程句柄（或者说线程控制块指针）、线程栈由用户提供。静态线程是指线程控制块、线程运行栈一般都设置为全局变量，在编译时就被确定、被分配处理，内核不负责动态分配内存空间。需要注意的是，用户提供的栈首地址需做<strong>系统对齐</strong>（例如 ARM 上需要做 4 字节对齐）。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>thread</td><td>线程句柄。线程句柄由用户提供出来，并指向对应的线程控制块内存地址</td></tr><tr><td>name</td><td>线程的名称；线程名称的最大长度由 rtconfig.h 中定义的 RT_NAME_MAX 宏指定，多余部分会被自动截掉</td></tr><tr><td>entry</td><td>线程入口函数</td></tr><tr><td>parameter</td><td>线程入口函数参数</td></tr><tr><td>stack_start</td><td>线程栈起始地址</td></tr><tr><td>stack_size</td><td>线程栈大小，单位是字节。在大多数系统中需要做栈空间地址对齐（例如 ARM 体系结构中需要向 4 字节地址对齐）</td></tr><tr><td>priority</td><td>线程的优先级。优先级范围根据系统配置情况（rtconfig.h 中的 RT_THREAD_PRIORITY_MAX 宏定义），如果支持的是 256 级优先级，那么范围是从 0 ～ 255，数值越小优先级越高，0 代表最高优先级</td></tr><tr><td>tick</td><td>线程的时间片大小。时间片（tick）的单位是操作系统的时钟节拍。当系统中存在相同优先级线程时，这个参数指定线程一次调度能够运行的最大时间长度。这个时间片运行结束时，调度器自动选择下一个就绪态的同优先级线程进行运行</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>线程创建成功</td></tr><tr><td>-RT_ERROR</td><td>线程创建失败</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_detach</span> <span class="hljs-params">(<span class="hljs-type">rt_thread_t</span> thread)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>thread</td><td>线程句柄，它应该是由 rt_thread_init 进行初始化的线程句柄。</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>线程脱离成功</td></tr><tr><td>-RT_ERROR</td><td>线程脱离失败</td></tr></tbody></table><h3 id="线程启动-startup"><a href="#线程启动-startup" class="headerlink" title="线程启动-startup"></a>线程启动-startup</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_startup</span><span class="hljs-params">(<span class="hljs-type">rt_thread_t</span> thread)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>thread</td><td>线程句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>线程启动成功</td></tr><tr><td>-RT_ERROR</td><td>线程起动失败</td></tr></tbody></table><h3 id="获取当前线程-self"><a href="#获取当前线程-self" class="headerlink" title="获取当前线程-self"></a>获取当前线程-self</h3><p>在程序的运行过程中，相同的一段代码可能会被多个线程执行，在执行的时候可以通过下面的函数接口获得当前执行的线程句柄：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_thread_t</span> <span class="hljs-title function_">rt_thread_self</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>返回</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>thread</td><td>当前运行的线程句柄</td></tr><tr><td>RT_NULL</td><td>失败，调度器还未启动</td></tr></tbody></table><h3 id="使线程让出处理器资源-yield"><a href="#使线程让出处理器资源-yield" class="headerlink" title="使线程让出处理器资源-yield"></a>使线程让出处理器资源-yield</h3><p>（如果当前优先级只有这一个线程，则这个线程继续执行，不进行上下文切换动作）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_yield</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><p>rt_thread_yield() 和 rt_schedule() 比较相像，有相同优先级的其他就绪态线程存在时其行为<strong>有所差异</strong>。</p><h3 id="使线程睡眠-延时-sleep"><a href="#使线程睡眠-延时-sleep" class="headerlink" title="使线程睡眠(延时)-sleep"></a>使线程睡眠(延时)-sleep</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_sleep</span><span class="hljs-params">(<span class="hljs-type">rt_tick_t</span> tick)</span>;<br><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_delay</span><span class="hljs-params">(<span class="hljs-type">rt_tick_t</span> tick)</span>;<br><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_mdelay</span><span class="hljs-params">(<span class="hljs-type">rt_int32_t</span> ms)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>tick&#x2F;ms</td><td>线程睡眠的时间： sleep&#x2F;delay 的传入参数 tick 以 1 个 OS Tick 为单位 ； mdelay 的传入参数 ms 以 1ms 为单位；</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>操作成功</td></tr></tbody></table><h3 id="挂起和恢复线程-suspend"><a href="#挂起和恢复线程-suspend" class="headerlink" title="挂起和恢复线程-suspend"></a>挂起和恢复线程-suspend</h3><blockquote><p>通常不应该使用这个函数来挂起线程本身，如果确实需要采用 rt_thread_suspend() 函数挂起当前任务，需要在调用 rt_thread_suspend() 函数后立刻调用 rt_schedule() 函数进行手动的线程上下文切换。用户只需要了解该接口的作用，不推荐使用该接口。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_suspend</span> <span class="hljs-params">(<span class="hljs-type">rt_thread_t</span> thread)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>thread</td><td>线程句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>线程挂起成功</td></tr><tr><td>-RT_ERROR</td><td>线程挂起失败，因为该线程的状态并不是就绪状态</td></tr></tbody></table><p>恢复线程就是让挂起的线程重新进入就绪状态，并将线程放入系统的就绪队列中；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_resume</span> <span class="hljs-params">(<span class="hljs-type">rt_thread_t</span> thread)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>thread</td><td>线程句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>线程恢复成功</td></tr><tr><td>-RT_ERROR</td><td>线程恢复失败，因为该个线程的状态并不是 RT_THREAD_SUSPEND 状态</td></tr></tbody></table><h3 id="控制线程-control"><a href="#控制线程-control" class="headerlink" title="控制线程-control"></a>控制线程-control</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_control</span><span class="hljs-params">(<span class="hljs-type">rt_thread_t</span> thread, <span class="hljs-type">rt_uint8_t</span> cmd, <span class="hljs-type">void</span>* arg)</span>;<br></code></pre></td></tr></table></figure><p>线程控制接口 rt_thread_control() 的参数和返回值见下表：</p><table><thead><tr><th><strong>函数参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>thread</td><td>线程句柄</td></tr><tr><td>cmd</td><td>指示控制命令</td></tr><tr><td>arg</td><td>控制参数</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>控制执行正确</td></tr><tr><td>-RT_ERROR</td><td>失败</td></tr></tbody></table><blockquote><p>指示控制命令 cmd 当前支持的命令包括：</p><p>RT_THREAD_CTRL_CHANGE_PRIORITY：动态更改线程的优先级；</p><p>RT_THREAD_CTRL_STARTUP：开始运行一个线程，等同于 rt_thread_startup() 函数调用；</p><p>RT_THREAD_CTRL_CLOSE：关闭一个线程，等同于 rt_thread_delete() 函数调用。</p></blockquote><h3 id="设置和删除空闲钩子-idle"><a href="#设置和删除空闲钩子-idle" class="headerlink" title="设置和删除空闲钩子-idle"></a>设置和删除空闲钩子-idle</h3><p>空闲钩子函数是空闲线程的钩子函数，如果设置了空闲钩子函数，就可以在系统执行空闲线程时，自动执行空闲钩子函数来做一些其他事情，比如系统指示灯。<strong>钩子函数必须保证空闲线程在任何时刻都不会处于挂起状态。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_idle_sethook</span><span class="hljs-params">(<span class="hljs-type">void</span> (*hook)(<span class="hljs-type">void</span>))</span>;<br><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_idle_delhook</span><span class="hljs-params">(<span class="hljs-type">void</span> (*hook)(<span class="hljs-type">void</span>))</span>;<br></code></pre></td></tr></table></figure><p>设置空闲钩子函数 rt_thread_idle_sethook() </p><table><thead><tr><th><strong>函数参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>hook</td><td>设置的钩子函数</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>设置成功</td></tr><tr><td>-RT_EFULL</td><td>设置失败</td></tr></tbody></table><p>删除空闲钩子函数 rt_thread_idle_delhook() </p><table><thead><tr><th><strong>函数参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>hook</td><td>删除的钩子函数</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>删除成功</td></tr><tr><td>-RT_ENOSYS</td><td>删除失败</td></tr></tbody></table><h3 id="设置调度器钩子-scheduler"><a href="#设置调度器钩子-scheduler" class="headerlink" title="设置调度器钩子-scheduler"></a>设置调度器钩子-scheduler</h3><p>有时用户可能会想知道在一个时刻发生了什么样的线程切换，可以通过调用下面的函数接口设置一个相应的钩子函数。在系统线程切换时，这个钩子函数将被调用：<strong>请仔细编写你的钩子函数，稍有不慎将很可能导致整个系统运行不正常（在这个钩子函数中，基本上不允许调用系统 API，更不应该导致当前运行的上下文挂起）。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">rt_scheduler_sethook</span><span class="hljs-params">(<span class="hljs-type">void</span> (*hook)(<span class="hljs-keyword">struct</span> rt_thread* from, <span class="hljs-keyword">struct</span> rt_thread* to))</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>函数参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>hook</td><td>表示用户定义的钩子函数指针</td></tr></tbody></table><p>钩子函数 hook() 的声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">hook</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> rt_thread* from, <span class="hljs-keyword">struct</span> rt_thread* to)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>函数参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>from</td><td>表示系统所要切换出的线程控制块指针</td></tr><tr><td>to</td><td>表示系统所要切换到的线程控制块指针</td></tr></tbody></table><h2 id="API应用示例"><a href="#API应用示例" class="headerlink" title="API应用示例"></a>API应用示例</h2><p>线程 2 计数到一定值会执行完毕，线程 2 被系统自动删除，计数停止。线程 1 一直打印计数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;rtthread.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_PRIORITY         25</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_STACK_SIZE       512</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_TIMESLICE        5</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">rt_thread_t</span> tid1 = RT_NULL;<br><br><span class="hljs-comment">/* 线程 1 的入口函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">thread1_entry</span><span class="hljs-params">(<span class="hljs-type">void</span> *parameter)</span><br>&#123;<br>    <span class="hljs-type">rt_uint32_t</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">/* 线程 1 采用低优先级运行，一直打印计数值 */</span><br>        rt_kprintf(<span class="hljs-string">&quot;thread1 count: %d\n&quot;</span>, count ++);<br>        rt_thread_mdelay(<span class="hljs-number">500</span>);<br>    &#125;<br>&#125;<br><br>ALIGN(RT_ALIGN_SIZE)<br><span class="hljs-type">static</span> <span class="hljs-type">char</span> thread2_stack[<span class="hljs-number">1024</span>];<br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_thread</span> <span class="hljs-title">thread2</span>;</span><br><span class="hljs-comment">/* 线程 2 入口 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">thread2_entry</span><span class="hljs-params">(<span class="hljs-type">void</span> *param)</span><br>&#123;<br>    <span class="hljs-type">rt_uint32_t</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* 线程 2 拥有较高的优先级，以抢占线程 1 而获得执行 */</span><br>    <span class="hljs-keyword">for</span> (count = <span class="hljs-number">0</span>; count &lt; <span class="hljs-number">10</span> ; count++)<br>    &#123;<br>        <span class="hljs-comment">/* 线程 2 打印计数值 */</span><br>        rt_kprintf(<span class="hljs-string">&quot;thread2 count: %d\n&quot;</span>, count);<br>    &#125;<br>    rt_kprintf(<span class="hljs-string">&quot;thread2 exit\n&quot;</span>);<br>    <span class="hljs-comment">/* 线程 2 运行结束后也将自动被系统脱离 */</span><br>&#125;<br><br><span class="hljs-comment">/* 线程示例 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">thread_sample</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/* 创建线程 1，名称是 thread1，入口是 thread1_entry*/</span><br>    tid1 = rt_thread_create(<span class="hljs-string">&quot;thread1&quot;</span>,<br>                            thread1_entry, RT_NULL,<br>                            THREAD_STACK_SIZE,<br>                            THREAD_PRIORITY, THREAD_TIMESLICE);<br><br>    <span class="hljs-comment">/* 如果获得线程控制块，启动这个线程 */</span><br>    <span class="hljs-keyword">if</span> (tid1 != RT_NULL)<br>        rt_thread_startup(tid1);<br><br>    <span class="hljs-comment">/* 初始化线程 2，名称是 thread2，入口是 thread2_entry */</span><br>    rt_thread_init(&amp;thread2,<br>                   <span class="hljs-string">&quot;thread2&quot;</span>,<br>                   thread2_entry,<br>                   RT_NULL,<br>                   &amp;thread2_stack[<span class="hljs-number">0</span>],<br>                   <span class="hljs-keyword">sizeof</span>(thread2_stack),<br>                   THREAD_PRIORITY - <span class="hljs-number">1</span>, THREAD_TIMESLICE);<br>    rt_thread_startup(&amp;thread2);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 导出到 msh 命令列表中 */</span><br>MSH_CMD_EXPORT(thread_sample, thread sample);<br></code></pre></td></tr></table></figure><p>仿真运行结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c">\ | /<br>- RT -     Thread Operating System<br> / | \     <span class="hljs-number">3.1</span><span class="hljs-number">.0</span> build Aug <span class="hljs-number">24</span> <span class="hljs-number">2018</span><br> <span class="hljs-number">2006</span> - <span class="hljs-number">2018</span> Copyright by rt-thread team<br>msh &gt;thread_sample<br>msh &gt;thread2 count: <span class="hljs-number">0</span><br>thread2 count: <span class="hljs-number">1</span><br>thread2 count: <span class="hljs-number">2</span><br>thread2 count: <span class="hljs-number">3</span><br>thread2 count: <span class="hljs-number">4</span><br>thread2 count: <span class="hljs-number">5</span><br>thread2 count: <span class="hljs-number">6</span><br>thread2 count: <span class="hljs-number">7</span><br>thread2 count: <span class="hljs-number">8</span><br>thread2 count: <span class="hljs-number">9</span><br>thread2 <span class="hljs-built_in">exit</span><br>thread1 count: <span class="hljs-number">0</span><br>thread1 count: <span class="hljs-number">1</span><br>thread1 count: <span class="hljs-number">2</span><br>thread1 count: <span class="hljs-number">3</span><br>…<br></code></pre></td></tr></table></figure><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><ul><li>若某线程运行完毕，系统将自动删除线程：自动执行 rt_thread_exit() 函数，先将该线程从系统就绪队列中删除，再将该线程的状态更改为关闭状态，不再参与系统调度，然后挂入 rt_thread_defunct 僵尸队列（资源未回收、处于关闭状态的线程队列）中，最后空闲线程会回收被删除线程的资源。</li><li></li></ul><h1 id="时钟管理"><a href="#时钟管理" class="headerlink" title="时钟管理"></a>时钟管理</h1><h2 id="获取时钟节拍API"><a href="#获取时钟节拍API" class="headerlink" title="获取时钟节拍API"></a>获取时钟节拍API</h2><p>由于全局变量 rt_tick 在每经过一个时钟节拍时，值就会加 1，通过调用 rt_tick_get 会返回当前 rt_tick 的值，即可以获取到当前的时钟节拍值。此接口可用于记录系统的运行时间长短，或者测量某任务运行的时间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_tick_t</span> <span class="hljs-title function_">rt_tick_get</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>返回</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>rt_tick</td><td>当前时钟节拍值</td></tr></tbody></table><h2 id="软件定时器管理"><a href="#软件定时器管理" class="headerlink" title="软件定时器管理"></a>软件定时器管理</h2><p>RT-Thread 操作系统提供软件实现的定时器，以时钟节拍（OS Tick）的时间长度为单位，即定时数值必须是 OS Tick 的整数倍。它构建在硬件定时器基础之上，使系统能够提供不受数目限制的定时器服务。</p><p>RT-Thread 的定时器提供两类定时器机制：</p><ul><li>第一类是单次触发定时器，这类定时器在启动后只会触发一次定时器事件，然后定时器自动停止。</li><li>第二类是周期触发定时器，这类定时器会周期性的触发定时器事件，直到用户手动的停止，否则将永远持续执行下去。</li></ul><p>另外，根据超时函数执行时所处的上下文环境，RT-Thread 的定时器可以分为 <strong>HARD_TIMER</strong> 模式与 <strong>SOFT_TIMER</strong> 模式，如下图。使用<strong>RT_TIMER_FLAG_HARD_TIMER</strong> 和 **RT_TIMER_FLAG_SOFT_TIMER ** 来决定使用的模式</p><p><img src="/2021/42e53028/05timer_env.png" alt="定时器上下文环境"></p><p>系统新创建并激活的定时器都会按照以超时时间排序的方式插入到 rt_timer_list 链表中。</p><p><img src="/2021/42e53028/05timer_linked_list.png" alt="定时器链表示意图"></p><p>rt_tick(当前系统tick) 从 20 增长到 70，与 Timer1 的 timeout 值相等，这时会触发与 Timer1 定时器相关联的超时函数，同时将 Timer1 从 rt_timer_list 链表上删除。</p><p>如果系统当前定时器状态在 10 个 tick 以后（rt_tick&#x3D;30）有一个任务新创建了一个 tick 值为 300 的 Timer4 定时器，由于 Timer4 定时器的 timeout&#x3D;rt_tick+300&#x3D;330, 因此它将被插入到 Timer2 和 Timer3 定时器中间如下图,所示：</p><p><img src="/2021/42e53028/05timer_linked_list2.png" alt="定时器链表插入示意图"></p><h2 id="定时器API"><a href="#定时器API" class="headerlink" title="定时器API"></a>定时器API</h2><p><img src="/2021/42e53028/05timer_ops.png" alt="定时器相关操作"></p><p>在系统启动时需要初始化定时器管理系统。可以通过下面的函数接口完成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">rt_system_timer_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><p>如果需要使用 SOFT_TIMER，则系统初始化时，应该调用下面这个函数接口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">rt_system_timer_thread_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><h3 id="创建和删除-create"><a href="#创建和删除-create" class="headerlink" title="创建和删除-create"></a>创建和删除-create</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_timer_t</span> <span class="hljs-title function_">rt_timer_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name,</span><br><span class="hljs-params">                           <span class="hljs-type">void</span> (*timeout)(<span class="hljs-type">void</span>* parameter),</span><br><span class="hljs-params">                           <span class="hljs-type">void</span>* parameter,</span><br><span class="hljs-params">                           <span class="hljs-type">rt_tick_t</span> time,</span><br><span class="hljs-params">                           <span class="hljs-type">rt_uint8_t</span> flag)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>name</td><td>定时器的名称</td></tr><tr><td>void (timeout) (void parameter)</td><td>定时器超时函数指针（当定时器超时时，系统会调用这个函数）</td></tr><tr><td>parameter</td><td>定时器超时函数的入口参数（当定时器超时时，调用超时回调函数会把这个参数做为入口参数传递给超时函数）</td></tr><tr><td>time</td><td>定时器的超时时间，单位是时钟节拍</td></tr><tr><td>flag</td><td>定时器创建时的参数，支持的值包括单次定时、周期定时、硬件定时器、软件定时器等（可以用 “或” 关系取多个值）</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_NULL</td><td>创建失败（通常会由于系统内存不够用而返回 RT_NULL）</td></tr><tr><td>定时器的句柄</td><td>定时器创建成功</td></tr></tbody></table><p>如下2 组值可以以 “或” 逻辑的方式赋给 flag。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_TIMER_FLAG_ONE_SHOT      0x0     <span class="hljs-comment">/* 单次定时     */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_TIMER_FLAG_PERIODIC      0x2     <span class="hljs-comment">/* 周期定时     */</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_TIMER_FLAG_HARD_TIMER    0x0     <span class="hljs-comment">/* 时钟中断的服务例程上下文中被调用 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_TIMER_FLAG_SOFT_TIMER    0x4     <span class="hljs-comment">/* timer 线程的上下文中被调用 */</span></span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_timer_delete</span><span class="hljs-params">(<span class="hljs-type">rt_timer_t</span> timer)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>timer</td><td>定时器句柄，指向要删除的定时器</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>删除成功（如果参数 timer 句柄是一个 RT_NULL，将会导致一个 ASSERT 断言）</td></tr></tbody></table><h3 id="初始化和脱离定时器-init"><a href="#初始化和脱离定时器-init" class="headerlink" title="初始化和脱离定时器-init"></a>初始化和脱离定时器-init</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">rt_timer_init</span><span class="hljs-params">(<span class="hljs-type">rt_timer_t</span> timer,</span><br><span class="hljs-params">                   <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name,</span><br><span class="hljs-params">                   <span class="hljs-type">void</span> (*timeout)(<span class="hljs-type">void</span>* parameter),</span><br><span class="hljs-params">                   <span class="hljs-type">void</span>* parameter,</span><br><span class="hljs-params">                   <span class="hljs-type">rt_tick_t</span> time, <span class="hljs-type">rt_uint8_t</span> flag)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>timer</td><td>定时器句柄，指向要初始化的定时器控制块</td></tr><tr><td>name</td><td>定时器的名称</td></tr><tr><td>void (timeout) (void parameter)</td><td>定时器超时函数指针（当定时器超时时，系统会调用这个函数）</td></tr><tr><td>parameter</td><td>定时器超时函数的入口参数（当定时器超时时，调用超时回调函数会把这个参数做为入口参数传递给超时函数）</td></tr><tr><td>time</td><td>定时器的超时时间，单位是时钟节拍</td></tr><tr><td>flag</td><td>定时器创建时的参数，支持的值包括单次定时、周期定时、硬件定时器、软件定时器（可以用 “或” 关系取多个值），详见上面 <strong>创建和删除</strong></td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_timer_detach</span><span class="hljs-params">(<span class="hljs-type">rt_timer_t</span> timer)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>timer</td><td>定时器句柄，指向要脱离的定时器控制块</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>脱离成功</td></tr></tbody></table><h3 id="启动和停止定时器-start"><a href="#启动和停止定时器-start" class="headerlink" title="启动和停止定时器-start"></a>启动和停止定时器-start</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_timer_start</span><span class="hljs-params">(<span class="hljs-type">rt_timer_t</span> timer)</span>;<br></code></pre></td></tr></table></figure><p>调用接口后，定时器的状态将更改为激活状态（RT_TIMER_FLAG_ACTIVATED），并按照超时顺序插入到 rt_timer_list 队列链表中。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>timer</td><td>定时器句柄，指向要启动的定时器控制块</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>启动成功</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_timer_stop</span><span class="hljs-params">(<span class="hljs-type">rt_timer_t</span> timer)</span>;<br></code></pre></td></tr></table></figure><p>当一个（周期性）定时器超时时，可以调用这个函数接口停止这个（周期性）定时器本身。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>timer</td><td>定时器句柄，指向要停止的定时器控制块</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功停止定时器</td></tr><tr><td>- RT_ERROR</td><td>timer 已经处于停止状态</td></tr></tbody></table><h3 id="控制定时器-control"><a href="#控制定时器-control" class="headerlink" title="控制定时器-control"></a>控制定时器-control</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_timer_control</span><span class="hljs-params">(<span class="hljs-type">rt_timer_t</span> timer, <span class="hljs-type">rt_uint8_t</span> cmd, <span class="hljs-type">void</span>* arg)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>timer</td><td>定时器句柄，指向要停止的定时器控制块</td></tr><tr><td>cmd</td><td>用于控制定时器的命令，当前支持四个命令，分别是设置定时时间，查看定时时间，设置单次触发，设置周期触发</td></tr><tr><td>arg</td><td>与 cmd 相对应的控制命令参数 比如，cmd 为设定超时时间时，就可以将超时时间参数通过 arg 进行设定</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr></tbody></table><p>函数参数 cmd 支持的命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_TIMER_CTRL_SET_TIME      0x0     <span class="hljs-comment">/* 设置定时器超时时间       */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_TIMER_CTRL_GET_TIME      0x1     <span class="hljs-comment">/* 获得定时器超时时间       */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_TIMER_CTRL_SET_ONESHOT   0x2     <span class="hljs-comment">/* 设置定时器为单次定时器   */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_TIMER_CTRL_SET_PERIODIC  0x3     <span class="hljs-comment">/* 设置定时器为周期型定时器 */</span></span><br></code></pre></td></tr></table></figure><h2 id="API应用示例-1"><a href="#API应用示例-1" class="headerlink" title="API应用示例"></a>API应用示例</h2><p>这是一个创建定时器的例子，这个例程会创建两个动态定时器，一个是单次定时，一个是周期性定时并让周期定时器运行一段时间后停止运行，如下所示：周期性定时器 1 的超时函数，每 10 个 OS Tick 运行 1 次，共运行 10 次（10 次后调用 rt_timer_stop 使定时器 1 停止运行）；单次定时器 2 的超时函数在第 30 个 OS Tick 时运行一次。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;rtthread.h&gt;</span></span><br><br><span class="hljs-comment">/* 定时器的控制块 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">rt_timer_t</span> timer1;<br><span class="hljs-type">static</span> <span class="hljs-type">rt_timer_t</span> timer2;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/* 定时器 1 超时函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">timeout1</span><span class="hljs-params">(<span class="hljs-type">void</span> *parameter)</span><br>&#123;<br>    rt_kprintf(<span class="hljs-string">&quot;periodic timer is timeout %d\n&quot;</span>, cnt);<br><br>    <span class="hljs-comment">/* 运行第 10 次，停止周期定时器 */</span><br>    <span class="hljs-keyword">if</span> (cnt++&gt;= <span class="hljs-number">9</span>)<br>    &#123;<br>        rt_timer_stop(timer1);<br>        rt_kprintf(<span class="hljs-string">&quot;periodic timer was stopped! \n&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* 定时器 2 超时函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">timeout2</span><span class="hljs-params">(<span class="hljs-type">void</span> *parameter)</span><br>&#123;<br>    rt_kprintf(<span class="hljs-string">&quot;one shot timer is timeout\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">timer_sample</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/* 创建定时器 1  周期定时器 */</span><br>    timer1 = rt_timer_create(<span class="hljs-string">&quot;timer1&quot;</span>, timeout1,<br>                             RT_NULL, <span class="hljs-number">10</span>,<br>                             RT_TIMER_FLAG_PERIODIC);<br><br>    <span class="hljs-comment">/* 启动定时器 1 */</span><br>    <span class="hljs-keyword">if</span> (timer1 != RT_NULL) rt_timer_start(timer1);<br><br>    <span class="hljs-comment">/* 创建定时器 2 单次定时器 */</span><br>    timer2 = rt_timer_create(<span class="hljs-string">&quot;timer2&quot;</span>, timeout2,<br>                             RT_NULL,  <span class="hljs-number">30</span>,<br>                             RT_TIMER_FLAG_ONE_SHOT);<br><br>    <span class="hljs-comment">/* 启动定时器 2 */</span><br>    <span class="hljs-keyword">if</span> (timer2 != RT_NULL) rt_timer_start(timer2);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 导出到 msh 命令列表中 */</span><br>MSH_CMD_EXPORT(timer_sample, timer sample);<br></code></pre></td></tr></table></figure><p>仿真运行结果如下：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs applescript"> \ | /<br>- RT -     Thread Operating System<br> / | \     <span class="hljs-number">3.1</span><span class="hljs-number">.0</span> build Aug <span class="hljs-number">24</span> <span class="hljs-number">2018</span><br> <span class="hljs-number">2006</span> - <span class="hljs-number">2018</span> Copyright <span class="hljs-keyword">by</span> rt-thread team<br>msh &gt;timer_sample<br>msh &gt;periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span> <span class="hljs-number">0</span><br>periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span> <span class="hljs-number">1</span><br>one shot timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span><br>periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span> <span class="hljs-number">2</span><br>periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span> <span class="hljs-number">3</span><br>periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span> <span class="hljs-number">4</span><br>periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span> <span class="hljs-number">5</span><br>periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span> <span class="hljs-number">6</span><br>periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span> <span class="hljs-number">7</span><br>periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span> <span class="hljs-number">8</span><br>periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span> <span class="hljs-number">9</span><br>periodic timer was stopped!<br></code></pre></td></tr></table></figure><p>初始化定时器的例子与创建定时器的例子类似，这个程序会初始化 2 个静态定时器，一个是单次定时，一个是周期性的定时，如下代码所示：周期性定时器 1 的超时函数，每 10 个 OS Tick 运行 1 次，共运行 10 次（10 次后调用 rt_timer_stop 使定时器 1 停止运行）；单次定时器 2 的超时函数在第 30 个 OS Tick 时运行一次。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;rtthread.h&gt;</span></span><br><br><span class="hljs-comment">/* 定时器的控制块 */</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_timer</span> <span class="hljs-title">timer1</span>;</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_timer</span> <span class="hljs-title">timer2</span>;</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/* 定时器 1 超时函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">timeout1</span><span class="hljs-params">(<span class="hljs-type">void</span>* parameter)</span><br>&#123;<br>    rt_kprintf(<span class="hljs-string">&quot;periodic timer is timeout\n&quot;</span>);<br>    <span class="hljs-comment">/* 运行 10 次 */</span><br>    <span class="hljs-keyword">if</span> (cnt++&gt;= <span class="hljs-number">9</span>)<br>    &#123;<br>        rt_timer_stop(&amp;timer1);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* 定时器 2 超时函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">timeout2</span><span class="hljs-params">(<span class="hljs-type">void</span>* parameter)</span><br>&#123;<br>    rt_kprintf(<span class="hljs-string">&quot;one shot timer is timeout\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">timer_static_sample</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/* 初始化定时器 */</span><br>    rt_timer_init(&amp;timer1, <span class="hljs-string">&quot;timer1&quot;</span>,  <span class="hljs-comment">/* 定时器名字是 timer1 */</span><br>                    timeout1, <span class="hljs-comment">/* 超时时回调的处理函数 */</span><br>                    RT_NULL, <span class="hljs-comment">/* 超时函数的入口参数 */</span><br>                    <span class="hljs-number">10</span>, <span class="hljs-comment">/* 定时长度，以 OS Tick 为单位，即 10 个 OS Tick */</span><br>                    RT_TIMER_FLAG_PERIODIC); <span class="hljs-comment">/* 周期性定时器 */</span><br>    rt_timer_init(&amp;timer2, <span class="hljs-string">&quot;timer2&quot;</span>,   <span class="hljs-comment">/* 定时器名字是 timer2 */</span><br>                    timeout2, <span class="hljs-comment">/* 超时时回调的处理函数 */</span><br>                      RT_NULL, <span class="hljs-comment">/* 超时函数的入口参数 */</span><br>                      <span class="hljs-number">30</span>, <span class="hljs-comment">/* 定时长度为 30 个 OS Tick */</span><br>                    RT_TIMER_FLAG_ONE_SHOT); <span class="hljs-comment">/* 单次定时器 */</span><br><br>    <span class="hljs-comment">/* 启动定时器 */</span><br>    rt_timer_start(&amp;timer1);<br>    rt_timer_start(&amp;timer2);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/* 导出到 msh 命令列表中 */</span><br>MSH_CMD_EXPORT(timer_static_sample, timer_static sample);<br></code></pre></td></tr></table></figure><p>仿真运行结果如下：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs applescript">\ | /<br>- RT -     Thread Operating System<br> / | \     <span class="hljs-number">3.1</span><span class="hljs-number">.0</span> build Aug <span class="hljs-number">24</span> <span class="hljs-number">2018</span><br> <span class="hljs-number">2006</span> - <span class="hljs-number">2018</span> Copyright <span class="hljs-keyword">by</span> rt-thread team<br>msh &gt;timer_static_sample<br>msh &gt;periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span><br>periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span><br>one shot timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span><br>periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span><br>periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span><br>periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span><br>periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span><br>periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span><br>periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span><br>periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span><br>periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span><br></code></pre></td></tr></table></figure><h2 id="低于一个Tick的延时"><a href="#低于一个Tick的延时" class="headerlink" title="低于一个Tick的延时"></a>低于一个Tick的延时</h2><p>入口参数 us 指示出需要延时的微秒数目，这个函数只能支持低于 1 OS Tick 的延时，否则 SysTick 会出现溢出而不能够获得指定的延时时间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;board.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">rt_hw_us_delay</span><span class="hljs-params">(<span class="hljs-type">rt_uint32_t</span> us)</span><br>&#123;<br>    <span class="hljs-type">rt_uint32_t</span> delta;<br>    <span class="hljs-comment">/* 获得延时经过的 tick 数 */</span><br>    us = us * (SysTick-&gt;LOAD/(<span class="hljs-number">1000000</span>/RT_TICK_PER_SECOND));<br>    <span class="hljs-comment">/* 获得当前时间 */</span><br>    delta = SysTick-&gt;VAL;<br>    <span class="hljs-comment">/* 循环获得当前时间，直到达到指定的时间后退出循环 */</span><br>    <span class="hljs-keyword">while</span> (delta - SysTick-&gt;VAL&lt; us);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="笔记-1"><a href="#笔记-1" class="headerlink" title="笔记"></a>笔记</h2><ul><li>时钟节拍是特定的周期性中断，这个中断可以看做是系统心跳，中断之间的时间间隔取决于不同的应用，一般是 1ms–100ms，时钟节拍率越快，系统的额外开销就越大，从系统启动开始计数的时钟节拍数称为系统时间。</li><li></li></ul><h1 id="线程间同步"><a href="#线程间同步" class="headerlink" title="线程间同步"></a>线程间同步</h1><p>线程的同步方式有很多种，其核心思想都是：<strong>在访问临界区的时候只允许一个 (或一类) 线程运行。</strong>进入 &#x2F; 退出临界区的方式有很多种：</p><p>1）调用 rt_hw_interrupt_disable() 进入临界区，调用 rt_hw_interrupt_enable() 退出临界区；详见《中断管理》的全局中断开关内容。</p><p>2）调用 rt_enter_critical() 进入临界区，调用 rt_exit_critical() 退出临界区。</p><h2 id="信号量Semaphore"><a href="#信号量Semaphore" class="headerlink" title="信号量Semaphore"></a>信号量Semaphore</h2><p>信号量的值对应了信号量对象的实例数目、资源数目，假如信号量值为 5，则表示共有 5 个信号量实例（资源）可以被使用，当信号量实例数目为零时，再申请该信号量的线程就会被挂起在该信号量的等待队列上，等待可用的信号量实例（资源）。</p><p>可以形成<strong>锁</strong>、<strong>同步</strong>、<strong>资源计数</strong>等关系，也能方便的用于<strong>线程与线程</strong>、<strong>中断与线程</strong>间的同步中。</p><p><img src="/2021/42e53028/06sem_work.png" alt="信号量工作示意图"></p><h3 id="Semaphore-API"><a href="#Semaphore-API" class="headerlink" title="Semaphore API"></a>Semaphore API</h3><p><img src="/2021/42e53028/06sem_ops.png" alt="信号量相关接口"></p><h3 id="创建和删除信号量-create"><a href="#创建和删除信号量-create" class="headerlink" title="创建和删除信号量-create"></a>创建和删除信号量-create</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_sem_t</span> <span class="hljs-title function_">rt_sem_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name,</span><br><span class="hljs-params">                       <span class="hljs-type">rt_uint32_t</span> value,</span><br><span class="hljs-params">                       <span class="hljs-type">rt_uint8_t</span> flag)</span>;<br></code></pre></td></tr></table></figure><p>当选择 RT_IPC_FLAG_FIFO（先进先出）方式时，那么等待线程队列将按照先进先出的方式排队，先进入的线程将先获得等待的信号量；</p><p>当选择 RT_IPC_FLAG_PRIO（优先级等待）方式时，等待线程队列将按照优先级进行排队，优先级高的等待线程将先获得等待的信号量。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>name</td><td>信号量名称</td></tr><tr><td>value</td><td>信号量初始值</td></tr><tr><td>flag</td><td>信号量标志，它可以取如下数值： RT_IPC_FLAG_FIFO 或 RT_IPC_FLAG_PRIO</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_NULL</td><td>创建失败</td></tr><tr><td>信号量的控制块指针</td><td>创建成功</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_sem_delete</span><span class="hljs-params">(<span class="hljs-type">rt_sem_t</span> sem)</span>;<br></code></pre></td></tr></table></figure><p>如果删除该信号量时，有线程正在等待该信号量，那么删除操作会先唤醒等待在该信号量上的线程（等待线程的返回值是 - RT_ERROR），然后再释放信号量的内存资源。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>sem</td><td>rt_sem_create() 创建的信号量对象</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>删除成功</td></tr></tbody></table><h3 id="初始化和脱离信号量-init"><a href="#初始化和脱离信号量-init" class="headerlink" title="初始化和脱离信号量-init"></a>初始化和脱离信号量-init</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_sem_init</span><span class="hljs-params">(<span class="hljs-type">rt_sem_t</span>       sem,</span><br><span class="hljs-params">                    <span class="hljs-type">const</span> <span class="hljs-type">char</span>     *name,</span><br><span class="hljs-params">                    <span class="hljs-type">rt_uint32_t</span>    value,</span><br><span class="hljs-params">                    <span class="hljs-type">rt_uint8_t</span>     flag)</span><br></code></pre></td></tr></table></figure><p>flag见上↑</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>sem</td><td>信号量对象的句柄</td></tr><tr><td>name</td><td>信号量名称</td></tr><tr><td>value</td><td>信号量初始值</td></tr><tr><td>flag</td><td>信号量标志，它可以取如下数值： RT_IPC_FLAG_FIFO 或 RT_IPC_FLAG_PRIO</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>初始化成功</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_sem_detach</span><span class="hljs-params">(<span class="hljs-type">rt_sem_t</span> sem)</span>;<br></code></pre></td></tr></table></figure><p>使用该函数后，内核先唤醒所有挂在该信号量等待队列上的线程，然后将该信号量从内核对象管理器中脱离。原来挂起在信号量上的等待线程将获得 - RT_ERROR 的返回值。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>sem</td><td>信号量对象的句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>脱离成功</td></tr></tbody></table><h3 id="获取信号量-take"><a href="#获取信号量-take" class="headerlink" title="获取信号量-take"></a>获取信号量-take</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_sem_take</span> <span class="hljs-params">(<span class="hljs-type">rt_sem_t</span> sem, <span class="hljs-type">rt_int32_t</span> time)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>sem</td><td>信号量对象的句柄</td></tr><tr><td>time</td><td>指定的等待时间，单位是操作系统时钟节拍（OS Tick），或者RT_WAITING_FOREVER永远等待</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功获得信号量</td></tr><tr><td>-RT_ETIMEOUT</td><td>超时依然未获得信号量</td></tr><tr><td>-RT_ERROR</td><td>其他错误</td></tr></tbody></table><h3 id="无等待获取信号量-trytake"><a href="#无等待获取信号量-trytake" class="headerlink" title="无等待获取信号量-trytake"></a>无等待获取信号量-trytake</h3><p>当用户不想在申请的信号量上挂起线程进行等待时，可以使用无等待方式获取信号量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_sem_trytake</span><span class="hljs-params">(<span class="hljs-type">rt_sem_t</span> sem)</span>;<br></code></pre></td></tr></table></figure><p>这个函数与 rt_sem_take(sem, 0) 的作用相同，即当线程申请的信号量资源实例不可用的时候，它不会等待在该信号量上，而是直接返回 - RT_ETIMEOUT。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>sem</td><td>信号量对象的句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功获得信号量</td></tr><tr><td>-RT_ETIMEOUT</td><td>获取失败</td></tr></tbody></table><h3 id="释放信号量-release"><a href="#释放信号量-release" class="headerlink" title="释放信号量-release"></a>释放信号量-release</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_sem_release</span><span class="hljs-params">(<span class="hljs-type">rt_sem_t</span> sem)</span>;<br></code></pre></td></tr></table></figure><p>例如当信号量的值等于零时，并且有线程等待这个信号量时，释放信号量将唤醒等待在该信号量线程队列中的第一个线程，由它获取信号量；否则将把信号量的值加 1。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>sem</td><td>信号量对象的句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功释放信号量</td></tr></tbody></table><h2 id="信号量应用示例"><a href="#信号量应用示例" class="headerlink" title="信号量应用示例"></a>信号量应用示例</h2><p><strong>动态信号量的使用</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;rtthread.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_PRIORITY         25</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_TIMESLICE        5</span><br><br><span class="hljs-comment">/* 指向信号量的指针 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">rt_sem_t</span> dynamic_sem = RT_NULL;<br><br>ALIGN(RT_ALIGN_SIZE)<br><span class="hljs-type">static</span> <span class="hljs-type">char</span> thread1_stack[<span class="hljs-number">1024</span>];<br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_thread</span> <span class="hljs-title">thread1</span>;</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">rt_thread1_entry</span><span class="hljs-params">(<span class="hljs-type">void</span> *parameter)</span><br>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">rt_uint8_t</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(count &lt;= <span class="hljs-number">100</span>)<br>        &#123;<br>            count++;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-comment">/* count 每计数 10 次，就释放一次信号量 */</span><br>         <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> == (count % <span class="hljs-number">10</span>))<br>        &#123;<br>            rt_kprintf(<span class="hljs-string">&quot;t1 release a dynamic semaphore.\n&quot;</span>);<br>            rt_sem_release(dynamic_sem);<br>        &#125;<br>    &#125;<br>&#125;<br><br>ALIGN(RT_ALIGN_SIZE)<br><span class="hljs-type">static</span> <span class="hljs-type">char</span> thread2_stack[<span class="hljs-number">1024</span>];<br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_thread</span> <span class="hljs-title">thread2</span>;</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">rt_thread2_entry</span><span class="hljs-params">(<span class="hljs-type">void</span> *parameter)</span><br>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">rt_err_t</span> result;<br>    <span class="hljs-type">static</span> <span class="hljs-type">rt_uint8_t</span> number = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">/* 永久方式等待信号量，获取到信号量，则执行 number 自加的操作 */</span><br>        result = rt_sem_take(dynamic_sem, RT_WAITING_FOREVER);<br>        <span class="hljs-keyword">if</span> (result != RT_EOK)<br>        &#123;<br>            rt_kprintf(<span class="hljs-string">&quot;t2 take a dynamic semaphore, failed.\n&quot;</span>);<br>            rt_sem_delete(dynamic_sem);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            number++;<br>            rt_kprintf(<span class="hljs-string">&quot;t2 take a dynamic semaphore. number = %d\n&quot;</span> ,number);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* 信号量示例的初始化 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">semaphore_sample</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/* 创建一个动态信号量，初始值是 0 */</span><br>    dynamic_sem = rt_sem_create(<span class="hljs-string">&quot;dsem&quot;</span>, <span class="hljs-number">0</span>, RT_IPC_FLAG_FIFO);<br>    <span class="hljs-keyword">if</span> (dynamic_sem == RT_NULL)<br>    &#123;<br>        rt_kprintf(<span class="hljs-string">&quot;create dynamic semaphore failed.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        rt_kprintf(<span class="hljs-string">&quot;create done. dynamic semaphore value = 0.\n&quot;</span>);<br>    &#125;<br><br>    rt_thread_init(&amp;thread1,<br>                   <span class="hljs-string">&quot;thread1&quot;</span>,<br>                   rt_thread1_entry,<br>                   RT_NULL,<br>                   &amp;thread1_stack[<span class="hljs-number">0</span>],<br>                   <span class="hljs-keyword">sizeof</span>(thread1_stack),<br>                   THREAD_PRIORITY, THREAD_TIMESLICE);<br>    rt_thread_startup(&amp;thread1);<br><br>    rt_thread_init(&amp;thread2,<br>                   <span class="hljs-string">&quot;thread2&quot;</span>,<br>                   rt_thread2_entry,<br>                   RT_NULL,<br>                   &amp;thread2_stack[<span class="hljs-number">0</span>],<br>                   <span class="hljs-keyword">sizeof</span>(thread2_stack),<br>                   THREAD_PRIORITY<span class="hljs-number">-1</span>, THREAD_TIMESLICE);<br>    rt_thread_startup(&amp;thread2);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/* 导出到 msh 命令列表中 */</span><br>MSH_CMD_EXPORT(semaphore_sample, semaphore sample);<br></code></pre></td></tr></table></figure><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"> \ | /<br>- RT -     Thread Operating System<br> / | \     <span class="hljs-number">3.1</span><span class="hljs-number">.0</span> build Aug <span class="hljs-number">27</span> <span class="hljs-number">2018</span><br> <span class="hljs-number">2006</span> - <span class="hljs-number">2018</span> Copyright <span class="hljs-keyword">by</span> rt-thread team<br>msh &gt;semaphore_sample<br><span class="hljs-built_in">create</span> done. dynamic semaphore <span class="hljs-built_in">value</span> = <span class="hljs-number">0.</span><br>msh &gt;t1 release <span class="hljs-keyword">a</span> dynamic semaphore.<br>t2 take <span class="hljs-keyword">a</span> dynamic semaphore. <span class="hljs-built_in">number</span> = <span class="hljs-number">1</span><br>t1 release <span class="hljs-keyword">a</span> dynamic semaphore.<br>t2 take <span class="hljs-keyword">a</span> dynamic semaphore. <span class="hljs-built_in">number</span> = <span class="hljs-number">2</span><br>t1 release <span class="hljs-keyword">a</span> dynamic semaphore.<br>t2 take <span class="hljs-keyword">a</span> dynamic semaphore. <span class="hljs-built_in">number</span> = <span class="hljs-number">3</span><br>t1 release <span class="hljs-keyword">a</span> dynamic semaphore.<br>t2 take <span class="hljs-keyword">a</span> dynamic semaphore. <span class="hljs-built_in">number</span> = <span class="hljs-number">4</span><br>t1 release <span class="hljs-keyword">a</span> dynamic semaphore.<br>t2 take <span class="hljs-keyword">a</span> dynamic semaphore. <span class="hljs-built_in">number</span> = <span class="hljs-number">5</span><br>t1 release <span class="hljs-keyword">a</span> dynamic semaphore.<br>t2 take <span class="hljs-keyword">a</span> dynamic semaphore. <span class="hljs-built_in">number</span> = <span class="hljs-number">6</span><br>t1 release <span class="hljs-keyword">a</span> dynamic semaphore.<br>t2 take <span class="hljs-keyword">a</span> dynamic semaphore. <span class="hljs-built_in">number</span> = <span class="hljs-number">7</span><br>t1 release <span class="hljs-keyword">a</span> dynamic semaphore.<br>t2 take <span class="hljs-keyword">a</span> dynamic semaphore. <span class="hljs-built_in">number</span> = <span class="hljs-number">8</span><br>t1 release <span class="hljs-keyword">a</span> dynamic semaphore.<br>t2 take <span class="hljs-keyword">a</span> dynamic semaphore. <span class="hljs-built_in">number</span> = <span class="hljs-number">9</span><br>t1 release <span class="hljs-keyword">a</span> dynamic semaphore.<br>t2 take <span class="hljs-keyword">a</span> dynamic semaphore. <span class="hljs-built_in">number</span> = <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p><strong>信号量锁的作用，生产者消费者例程</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;rtthread.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_PRIORITY       6</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_STACK_SIZE     512</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_TIMESLICE      5</span><br><br><span class="hljs-comment">/* 定义最大 5 个元素能够被产生 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSEM 5</span><br><br><span class="hljs-comment">/* 用于放置生产的整数数组 */</span><br><span class="hljs-type">rt_uint32_t</span> <span class="hljs-built_in">array</span>[MAXSEM];<br><br><span class="hljs-comment">/* 指向生产者、消费者在 array 数组中的读写位置 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">rt_uint32_t</span> <span class="hljs-built_in">set</span>, get;<br><br><span class="hljs-comment">/* 指向线程控制块的指针 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">rt_thread_t</span> producer_tid = RT_NULL;<br><span class="hljs-type">static</span> <span class="hljs-type">rt_thread_t</span> consumer_tid = RT_NULL;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_semaphore</span> <span class="hljs-title">sem_lock</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_semaphore</span> <span class="hljs-title">sem_empty</span>, <span class="hljs-title">sem_full</span>;</span><br><br><span class="hljs-comment">/* 生产者线程入口 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">producer_thread_entry</span><span class="hljs-params">(<span class="hljs-type">void</span> *parameter)</span><br>&#123;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* 运行 10 次 */</span><br>    <span class="hljs-keyword">while</span> (cnt &lt; <span class="hljs-number">10</span>)<br>    &#123;<br>        <span class="hljs-comment">/* 获取一个空位 */</span><br>        rt_sem_take(&amp;sem_empty, RT_WAITING_FOREVER);<br><br>        <span class="hljs-comment">/* 修改 array 内容，上锁 */</span><br>        rt_sem_take(&amp;sem_lock, RT_WAITING_FOREVER);<br>        <span class="hljs-built_in">array</span>[<span class="hljs-built_in">set</span> % MAXSEM] = cnt + <span class="hljs-number">1</span>;<br>        rt_kprintf(<span class="hljs-string">&quot;the producer generates a number: %d\n&quot;</span>, <span class="hljs-built_in">array</span>[<span class="hljs-built_in">set</span> % MAXSEM]);<br>        <span class="hljs-built_in">set</span>++;<br>        rt_sem_release(&amp;sem_lock);<br><br>        <span class="hljs-comment">/* 发布一个满位 */</span><br>        rt_sem_release(&amp;sem_full);<br>        cnt++;<br><br>        <span class="hljs-comment">/* 暂停一段时间 */</span><br>        rt_thread_mdelay(<span class="hljs-number">20</span>);<br>    &#125;<br><br>    rt_kprintf(<span class="hljs-string">&quot;the producer exit!\n&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">/* 消费者线程入口 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">consumer_thread_entry</span><span class="hljs-params">(<span class="hljs-type">void</span> *parameter)</span><br>&#123;<br>    <span class="hljs-type">rt_uint32_t</span> sum = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">/* 获取一个满位 */</span><br>        rt_sem_take(&amp;sem_full, RT_WAITING_FOREVER);<br><br>        <span class="hljs-comment">/* 临界区，上锁进行操作 */</span><br>        rt_sem_take(&amp;sem_lock, RT_WAITING_FOREVER);<br>        sum += <span class="hljs-built_in">array</span>[get % MAXSEM];<br>        rt_kprintf(<span class="hljs-string">&quot;the consumer[%d] get a number: %d\n&quot;</span>, (get % MAXSEM), <span class="hljs-built_in">array</span>[get % MAXSEM]);<br>        get++;<br>        rt_sem_release(&amp;sem_lock);<br><br>        <span class="hljs-comment">/* 释放一个空位 */</span><br>        rt_sem_release(&amp;sem_empty);<br><br>        <span class="hljs-comment">/* 生产者生产到 10 个数目，停止，消费者线程相应停止 */</span><br>        <span class="hljs-keyword">if</span> (get == <span class="hljs-number">10</span>) <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-comment">/* 暂停一小会时间 */</span><br>        rt_thread_mdelay(<span class="hljs-number">50</span>);<br>    &#125;<br><br>    rt_kprintf(<span class="hljs-string">&quot;the consumer sum is: %d\n&quot;</span>, sum);<br>    rt_kprintf(<span class="hljs-string">&quot;the consumer exit!\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">producer_consumer</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-built_in">set</span> = <span class="hljs-number">0</span>;<br>    get = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* 初始化 3 个信号量 */</span><br>    rt_sem_init(&amp;sem_lock, <span class="hljs-string">&quot;lock&quot;</span>,     <span class="hljs-number">1</span>,      RT_IPC_FLAG_FIFO);<br>    rt_sem_init(&amp;sem_empty, <span class="hljs-string">&quot;empty&quot;</span>,   MAXSEM, RT_IPC_FLAG_FIFO);<br>    rt_sem_init(&amp;sem_full, <span class="hljs-string">&quot;full&quot;</span>,     <span class="hljs-number">0</span>,      RT_IPC_FLAG_FIFO);<br><br>    <span class="hljs-comment">/* 创建生产者线程 */</span><br>    producer_tid = rt_thread_create(<span class="hljs-string">&quot;producer&quot;</span>,<br>                                    producer_thread_entry, RT_NULL,<br>                                    THREAD_STACK_SIZE,<br>                                    THREAD_PRIORITY - <span class="hljs-number">1</span>,<br>                                    THREAD_TIMESLICE);<br>    <span class="hljs-keyword">if</span> (producer_tid != RT_NULL)<br>    &#123;<br>        rt_thread_startup(producer_tid);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        rt_kprintf(<span class="hljs-string">&quot;create thread producer failed&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* 创建消费者线程 */</span><br>    consumer_tid = rt_thread_create(<span class="hljs-string">&quot;consumer&quot;</span>,<br>                                    consumer_thread_entry, RT_NULL,<br>                                    THREAD_STACK_SIZE,<br>                                    THREAD_PRIORITY + <span class="hljs-number">1</span>,<br>                                    THREAD_TIMESLICE);<br>    <span class="hljs-keyword">if</span> (consumer_tid != RT_NULL)<br>    &#123;<br>        rt_thread_startup(consumer_tid);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        rt_kprintf(<span class="hljs-string">&quot;create thread consumer failed&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 导出到 msh 命令列表中 */</span><br>MSH_CMD_EXPORT(producer_consumer, producer_consumer sample);<br></code></pre></td></tr></table></figure><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">\ | /<br>- RT -     Thread Operating System<br> / | \     <span class="hljs-number">3.1</span><span class="hljs-number">.0</span> build Aug <span class="hljs-number">27</span> <span class="hljs-number">2018</span><br> <span class="hljs-number">2006</span> - <span class="hljs-number">2018</span> Copyright <span class="hljs-keyword">by</span> rt-thread team<br>msh &gt;producer_consumer<br><span class="hljs-keyword">the</span> producer generates <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">1</span><br><span class="hljs-keyword">the</span> consumer[<span class="hljs-number">0</span>] <span class="hljs-built_in">get</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">1</span><br>msh &gt;<span class="hljs-keyword">the</span> producer generates <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">2</span><br><span class="hljs-keyword">the</span> producer generates <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">3</span><br><span class="hljs-keyword">the</span> consumer[<span class="hljs-number">1</span>] <span class="hljs-built_in">get</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">2</span><br><span class="hljs-keyword">the</span> producer generates <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">4</span><br><span class="hljs-keyword">the</span> producer generates <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">5</span><br><span class="hljs-keyword">the</span> producer generates <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">6</span><br><span class="hljs-keyword">the</span> consumer[<span class="hljs-number">2</span>] <span class="hljs-built_in">get</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">3</span><br><span class="hljs-keyword">the</span> producer generates <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">7</span><br><span class="hljs-keyword">the</span> producer generates <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">8</span><br><span class="hljs-keyword">the</span> consumer[<span class="hljs-number">3</span>] <span class="hljs-built_in">get</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">4</span><br><span class="hljs-keyword">the</span> producer generates <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">9</span><br><span class="hljs-keyword">the</span> consumer[<span class="hljs-number">4</span>] <span class="hljs-built_in">get</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">5</span><br><span class="hljs-keyword">the</span> producer generates <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">10</span><br><span class="hljs-keyword">the</span> producer exit!<br><span class="hljs-keyword">the</span> consumer[<span class="hljs-number">0</span>] <span class="hljs-built_in">get</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">6</span><br><span class="hljs-keyword">the</span> consumer[<span class="hljs-number">1</span>] <span class="hljs-built_in">get</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">7</span><br><span class="hljs-keyword">the</span> consumer[<span class="hljs-number">2</span>] <span class="hljs-built_in">get</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">8</span><br><span class="hljs-keyword">the</span> consumer[<span class="hljs-number">3</span>] <span class="hljs-built_in">get</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">9</span><br><span class="hljs-keyword">the</span> consumer[<span class="hljs-number">4</span>] <span class="hljs-built_in">get</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">10</span><br><span class="hljs-keyword">the</span> consumer <span class="hljs-built_in">sum</span> is: <span class="hljs-number">55</span><br><span class="hljs-keyword">the</span> consumer exit!<br></code></pre></td></tr></table></figure><h2 id="互斥量-Mutex"><a href="#互斥量-Mutex" class="headerlink" title="互斥量 Mutex"></a>互斥量 Mutex</h2><p>互斥量又叫相互排斥的信号量，是一种特殊的二值信号量。</p><p>互斥量和信号量不同的是：拥有互斥量的线程拥有互斥量的所有权，互斥量支持递归访问且能防止线程优先级翻转；并且互斥量只能由持有线程释放，而信号量则可以由任何线程释放。</p><p><img src="/2021/42e53028/06mutex_work.png" alt="互斥量工作示意图"></p><p>线程优先级翻转如下。</p><p><img src="/2021/42e53028/06priority_inversion.png" alt="优先级反转 (M 为信号量)"></p><p><img src="/2021/42e53028/06priority_inherit.png" alt="优先级继承 (M 为互斥量)"></p><h3 id="互斥量API"><a href="#互斥量API" class="headerlink" title="互斥量API"></a>互斥量API</h3><p><img src="/2021/42e53028/06mutex_ops.png" alt="互斥量相关接口"></p><h3 id="创建和删除互斥量-create"><a href="#创建和删除互斥量-create" class="headerlink" title="创建和删除互斥量-create"></a>创建和删除互斥量-create</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_mutex_t</span> <span class="hljs-title function_">rt_mutex_create</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">rt_uint8_t</span> flag)</span>;<br></code></pre></td></tr></table></figure><p>互斥量的 flag 标志设置为 RT_IPC_FLAG_PRIO，表示在多个线程等待资源时，将由优先级高的线程优先获得资源。flag 设置为 RT_IPC_FLAG_FIFO，表示在多个线程等待资源时，将按照先来先得的顺序获得资源。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>name</td><td>互斥量的名称</td></tr><tr><td>flag</td><td>互斥量标志，它可以取如下数值： RT_IPC_FLAG_FIFO 或 RT_IPC_FLAG_PRIO</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>互斥量句柄</td><td>创建成功</td></tr><tr><td>RT_NULL</td><td>创建失败</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mutex_delete</span> <span class="hljs-params">(<span class="hljs-type">rt_mutex_t</span> mutex)</span>;<br></code></pre></td></tr></table></figure><p>当删除一个互斥量时，所有等待此互斥量的线程都将被唤醒，等待线程获得的返回值是 - RT_ERROR。然后系统将该互斥量从内核对象管理器链表中删除并释放互斥量占用的内存空间。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mutex</td><td>互斥量对象的句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>删除成功</td></tr></tbody></table><h3 id="初始化和脱离互斥量-init"><a href="#初始化和脱离互斥量-init" class="headerlink" title="初始化和脱离互斥量-init"></a>初始化和脱离互斥量-init</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mutex_init</span> <span class="hljs-params">(<span class="hljs-type">rt_mutex_t</span> mutex, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">rt_uint8_t</span> flag)</span>;<br></code></pre></td></tr></table></figure><p>flag见上</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mutex</td><td>互斥量对象的句柄，它由用户提供，并指向互斥量对象的内存块</td></tr><tr><td>name</td><td>互斥量的名称</td></tr><tr><td>flag</td><td>互斥量标志，它可以取如下数值： RT_IPC_FLAG_FIFO 或 RT_IPC_FLAG_PRIO</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>初始化成功</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mutex_detach</span> <span class="hljs-params">(<span class="hljs-type">rt_mutex_t</span> mutex)</span>;<br></code></pre></td></tr></table></figure><p>使用该函数接口后，内核先唤醒所有挂在该互斥量上的线程（线程的返回值是 -RT_ERROR），然后系统将该互斥量从内核对象管理器中脱离。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mutex</td><td>互斥量对象的句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr></tbody></table><h3 id="获取互斥量-take"><a href="#获取互斥量-take" class="headerlink" title="获取互斥量-take"></a>获取互斥量-take</h3><p>线程获取了互斥量，那么线程就有了对该互斥量的所有权，即某一个时刻一个互斥量只能被一个线程持有。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mutex_take</span> <span class="hljs-params">(<span class="hljs-type">rt_mutex_t</span> mutex, <span class="hljs-type">rt_int32_t</span> time)</span>;<br></code></pre></td></tr></table></figure><ul><li><p>如果互斥量没有被其他线程控制，那么申请该互斥量的线程将成功获得该互斥量。</p></li><li><p>如果互斥量已经被当前线程线程控制，则该互斥量的持有计数加 1，当前线程也不会挂起等待。</p></li><li><p>如果互斥量已经被其他线程占有，则当前线程在该互斥量上挂起等待，直到其他线程释放它或者等待时间超过指定的超时时间。</p></li></ul><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mutex</td><td>互斥量对象的句柄</td></tr><tr><td>time</td><td>指定等待的时间</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功获得互斥量</td></tr><tr><td>-RT_ETIMEOUT</td><td>超时</td></tr><tr><td>-RT_ERROR</td><td>获取失败</td></tr></tbody></table><h3 id="释放互斥量-release"><a href="#释放互斥量-release" class="headerlink" title="释放互斥量-release"></a>释放互斥量-release</h3><p>当线程完成互斥资源的访问后，应尽快释放它占据的互斥量，使得其他线程能及时获取该互斥量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mutex_release</span><span class="hljs-params">(<span class="hljs-type">rt_mutex_t</span> mutex)</span>;<br></code></pre></td></tr></table></figure><ul><li>只有已经拥有互斥量控制权的线程才能释放它，每释放一次该互斥量，它的持有计数就减 1。</li><li>当该互斥量的持有计数为零时（即持有线程已经释放所有的持有操作），它变为可用，等待在该信号量上的线程将被唤醒。</li></ul><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mutex</td><td>互斥量对象的句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr></tbody></table><h2 id="互斥量应用示例"><a href="#互斥量应用示例" class="headerlink" title="互斥量应用示例"></a>互斥量应用示例</h2><p>这是一个互斥量的应用例程，互斥锁是一种保护共享资源的方法。当一个线程拥有互斥锁的时候，可以保护共享资源不被其他线程破坏。下面用一个例子来说明，有两个线程：线程 1 和线程 2，线程 1 对 2 个 number 分别进行加 1 操作；线程 2 也对 2 个 number 分别进行加 1 操作，使用互斥量保证线程改变 2 个 number 值的操作不被打断。如下代码所示：</p><p><strong>互斥量例程</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;rtthread.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_PRIORITY         8</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_TIMESLICE        5</span><br><br><span class="hljs-comment">/* 指向互斥量的指针 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">rt_mutex_t</span> dynamic_mutex = RT_NULL;<br><span class="hljs-type">static</span> <span class="hljs-type">rt_uint8_t</span> number1,number2 = <span class="hljs-number">0</span>;<br><br>ALIGN(RT_ALIGN_SIZE)<br><span class="hljs-type">static</span> <span class="hljs-type">char</span> thread1_stack[<span class="hljs-number">1024</span>];<br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_thread</span> <span class="hljs-title">thread1</span>;</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">rt_thread_entry1</span><span class="hljs-params">(<span class="hljs-type">void</span> *parameter)</span><br>&#123;<br>      <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>      &#123;<br>          <span class="hljs-comment">/* 线程 1 获取到互斥量后，先后对 number1、number2 进行加 1 操作，然后释放互斥量 */</span><br>          rt_mutex_take(dynamic_mutex, RT_WAITING_FOREVER);<br>          number1++;<br>          rt_thread_mdelay(<span class="hljs-number">10</span>);<br>          number2++;<br>          rt_mutex_release(dynamic_mutex);<br>       &#125;<br>&#125;<br><br>ALIGN(RT_ALIGN_SIZE)<br><span class="hljs-type">static</span> <span class="hljs-type">char</span> thread2_stack[<span class="hljs-number">1024</span>];<br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_thread</span> <span class="hljs-title">thread2</span>;</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">rt_thread_entry2</span><span class="hljs-params">(<span class="hljs-type">void</span> *parameter)</span><br>&#123;<br>      <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>      &#123;<br>          <span class="hljs-comment">/* 线程 2 获取到互斥量后，检查 number1、number2 的值是否相同，相同则表示 mutex 起到了锁的作用 */</span><br>          rt_mutex_take(dynamic_mutex, RT_WAITING_FOREVER);<br>          <span class="hljs-keyword">if</span>(number1 != number2)<br>          &#123;<br>            rt_kprintf(<span class="hljs-string">&quot;not protect.number1 = %d, mumber2 = %d \n&quot;</span>,number1 ,number2);<br>          &#125;<br>          <span class="hljs-keyword">else</span><br>          &#123;<br>            rt_kprintf(<span class="hljs-string">&quot;mutex protect ,number1 = mumber2 is %d\n&quot;</span>,number1);<br>          &#125;<br><br>           number1++;<br>           number2++;<br>           rt_mutex_release(dynamic_mutex);<br><br>          <span class="hljs-keyword">if</span>(number1&gt;=<span class="hljs-number">50</span>)<br>              <span class="hljs-keyword">return</span>;<br>      &#125;<br>&#125;<br><br><span class="hljs-comment">/* 互斥量示例的初始化 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">mutex_sample</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/* 创建一个动态互斥量 */</span><br>    dynamic_mutex = rt_mutex_create(<span class="hljs-string">&quot;dmutex&quot;</span>, RT_IPC_FLAG_FIFO);<br>    <span class="hljs-keyword">if</span> (dynamic_mutex == RT_NULL)<br>    &#123;<br>        rt_kprintf(<span class="hljs-string">&quot;create dynamic mutex failed.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    rt_thread_init(&amp;thread1,<br>                   <span class="hljs-string">&quot;thread1&quot;</span>,<br>                   rt_thread_entry1,<br>                   RT_NULL,<br>                   &amp;thread1_stack[<span class="hljs-number">0</span>],<br>                   <span class="hljs-keyword">sizeof</span>(thread1_stack),<br>                   THREAD_PRIORITY, THREAD_TIMESLICE);<br>    rt_thread_startup(&amp;thread1);<br><br>    rt_thread_init(&amp;thread2,<br>                   <span class="hljs-string">&quot;thread2&quot;</span>,<br>                   rt_thread_entry2,<br>                   RT_NULL,<br>                   &amp;thread2_stack[<span class="hljs-number">0</span>],<br>                   <span class="hljs-keyword">sizeof</span>(thread2_stack),<br>                   THREAD_PRIORITY<span class="hljs-number">-1</span>, THREAD_TIMESLICE);<br>    rt_thread_startup(&amp;thread2);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 导出到 MSH 命令列表中 */</span><br>MSH_CMD_EXPORT(mutex_sample, mutex sample);<br></code></pre></td></tr></table></figure><p>线程 1 与线程 2 中均使用互斥量保护对 2 个 number 的操作（倘若将线程 1 中的获取、释放互斥量语句注释掉，线程 1 将对 number 不再做保护），仿真运行结果如下：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\</span> | /<br>- RT -     Thread Operating System<br> / | <span class="hljs-string">\</span>     <span class="hljs-number">3.1</span>.<span class="hljs-number">0</span> build Aug <span class="hljs-number">24</span> <span class="hljs-number">2018</span><br> <span class="hljs-number">2006</span> - <span class="hljs-number">2018</span> Copyright <span class="hljs-keyword">by</span> rt-thread team<br>msh &gt;mutex_sample<br>msh &gt;mutex protect ,number1 = mumber2 <span class="hljs-keyword">is</span> <span class="hljs-number">1</span><br>mutex protect ,number1 = mumber2 <span class="hljs-keyword">is</span> <span class="hljs-number">2</span><br>mutex protect ,number1 = mumber2 <span class="hljs-keyword">is</span> <span class="hljs-number">3</span><br>mutex protect ,number1 = mumber2 <span class="hljs-keyword">is</span> <span class="hljs-number">4</span><br>…<br>mutex protect ,number1 = mumber2 <span class="hljs-keyword">is</span> <span class="hljs-number">48</span><br>mutex protect ,number1 = mumber2 <span class="hljs-keyword">is</span> <span class="hljs-number">49</span><br></code></pre></td></tr></table></figure><p>线程使用互斥量保护对两个 number 的操作，使 number 值保持一致。</p><p>互斥量的另一个例子见下面的代码，这个例子将创建 3 个动态线程以检查持有互斥量时，持有的线程优先级是否被调整到等待线程优先级中的最高优先级。</p><p><strong>防止优先级翻转特性例程</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;rtthread.h&gt;</span></span><br><br><span class="hljs-comment">/* 指向线程控制块的指针 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">rt_thread_t</span> tid1 = RT_NULL;<br><span class="hljs-type">static</span> <span class="hljs-type">rt_thread_t</span> tid2 = RT_NULL;<br><span class="hljs-type">static</span> <span class="hljs-type">rt_thread_t</span> tid3 = RT_NULL;<br><span class="hljs-type">static</span> <span class="hljs-type">rt_mutex_t</span> mutex = RT_NULL;<br><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_PRIORITY       10</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_STACK_SIZE     512</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_TIMESLICE    5</span><br><br><span class="hljs-comment">/* 线程 1 入口 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">thread1_entry</span><span class="hljs-params">(<span class="hljs-type">void</span> *parameter)</span><br>&#123;<br>    <span class="hljs-comment">/* 先让低优先级线程运行 */</span><br>    rt_thread_mdelay(<span class="hljs-number">100</span>);<br><br>    <span class="hljs-comment">/* 此时 thread3 持有 mutex，并且 thread2 等待持有 mutex */</span><br><br>    <span class="hljs-comment">/* 检查 thread2 与 thread3 的优先级情况 */</span><br>    <span class="hljs-keyword">if</span> (tid2-&gt;current_priority != tid3-&gt;current_priority)<br>    &#123;<br>        <span class="hljs-comment">/* 优先级不相同，测试失败 */</span><br>        rt_kprintf(<span class="hljs-string">&quot;the priority of thread2 is: %d\n&quot;</span>, tid2-&gt;current_priority);<br>        rt_kprintf(<span class="hljs-string">&quot;the priority of thread3 is: %d\n&quot;</span>, tid3-&gt;current_priority);<br>        rt_kprintf(<span class="hljs-string">&quot;test failed.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        rt_kprintf(<span class="hljs-string">&quot;the priority of thread2 is: %d\n&quot;</span>, tid2-&gt;current_priority);<br>        rt_kprintf(<span class="hljs-string">&quot;the priority of thread3 is: %d\n&quot;</span>, tid3-&gt;current_priority);<br>        rt_kprintf(<span class="hljs-string">&quot;test OK.\n&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* 线程 2 入口 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">thread2_entry</span><span class="hljs-params">(<span class="hljs-type">void</span> *parameter)</span><br>&#123;<br>    <span class="hljs-type">rt_err_t</span> result;<br><br>    rt_kprintf(<span class="hljs-string">&quot;the priority of thread2 is: %d\n&quot;</span>, tid2-&gt;current_priority);<br><br>    <span class="hljs-comment">/* 先让低优先级线程运行 */</span><br>    rt_thread_mdelay(<span class="hljs-number">50</span>);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 试图持有互斥锁，此时 thread3 持有，应把 thread3 的优先级提升</span><br><span class="hljs-comment">     * 到 thread2 相同的优先级</span><br><span class="hljs-comment">     */</span><br>    result = rt_mutex_take(mutex, RT_WAITING_FOREVER);<br><br>    <span class="hljs-keyword">if</span> (result == RT_EOK)<br>    &#123;<br>        <span class="hljs-comment">/* 释放互斥锁 */</span><br>        rt_mutex_release(mutex);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* 线程 3 入口 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">thread3_entry</span><span class="hljs-params">(<span class="hljs-type">void</span> *parameter)</span><br>&#123;<br>    <span class="hljs-type">rt_tick_t</span> tick;<br>    <span class="hljs-type">rt_err_t</span> result;<br><br>    rt_kprintf(<span class="hljs-string">&quot;the priority of thread3 is: %d\n&quot;</span>, tid3-&gt;current_priority);<br><br>    result = rt_mutex_take(mutex, RT_WAITING_FOREVER);<br>    <span class="hljs-keyword">if</span> (result != RT_EOK)<br>    &#123;<br>        rt_kprintf(<span class="hljs-string">&quot;thread3 take a mutex, failed.\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* 做一个长时间的循环，500ms */</span><br>    tick = rt_tick_get();<br>    <span class="hljs-keyword">while</span> (rt_tick_get() - tick &lt; (RT_TICK_PER_SECOND / <span class="hljs-number">2</span>)) ;<br><br>    rt_mutex_release(mutex);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">pri_inversion</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/* 创建互斥锁 */</span><br>    mutex = rt_mutex_create(<span class="hljs-string">&quot;mutex&quot;</span>, RT_IPC_FLAG_FIFO);<br>    <span class="hljs-keyword">if</span> (mutex == RT_NULL)<br>    &#123;<br>        rt_kprintf(<span class="hljs-string">&quot;create dynamic mutex failed.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* 创建线程 1 */</span><br>    tid1 = rt_thread_create(<span class="hljs-string">&quot;thread1&quot;</span>,<br>                            thread1_entry,<br>                            RT_NULL,<br>                            THREAD_STACK_SIZE,<br>                            THREAD_PRIORITY - <span class="hljs-number">1</span>, THREAD_TIMESLICE);<br>    <span class="hljs-keyword">if</span> (tid1 != RT_NULL)<br>         rt_thread_startup(tid1);<br><br>    <span class="hljs-comment">/* 创建线程 2 */</span><br>    tid2 = rt_thread_create(<span class="hljs-string">&quot;thread2&quot;</span>,<br>                            thread2_entry,<br>                            RT_NULL,<br>                            THREAD_STACK_SIZE,<br>                            THREAD_PRIORITY, THREAD_TIMESLICE);<br>    <span class="hljs-keyword">if</span> (tid2 != RT_NULL)<br>        rt_thread_startup(tid2);<br><br>    <span class="hljs-comment">/* 创建线程 3 */</span><br>    tid3 = rt_thread_create(<span class="hljs-string">&quot;thread3&quot;</span>,<br>                            thread3_entry,<br>                            RT_NULL,<br>                            THREAD_STACK_SIZE,<br>                            THREAD_PRIORITY + <span class="hljs-number">1</span>, THREAD_TIMESLICE);<br>    <span class="hljs-keyword">if</span> (tid3 != RT_NULL)<br>        rt_thread_startup(tid3);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 导出到 msh 命令列表中 */</span><br>MSH_CMD_EXPORT(pri_inversion, prio_inversion sample);<br></code></pre></td></tr></table></figure><p>仿真运行结果如下：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs subunit">\ | /<br>- RT -     Thread Operating System<br> / | \     3.1.0 build Aug 27 2018<br> 2006 - 2018 Copyright by rt-thread team<br>msh &gt;pri_inversion<br>the priority of thread2 is: 10<br>the priority of thread3 is: 11<br>the priority of thread2 is: 10<br>the priority of thread3 is: 10<br><span class="hljs-keyword">test </span>OK.<br></code></pre></td></tr></table></figure><h2 id="事件集Event"><a href="#事件集Event" class="headerlink" title="事件集Event"></a>事件集Event</h2><p>一个事件集可以包含多个事件，利用事件集可以完成<strong>一对多</strong>，<strong>多对多</strong>，<strong>多对一</strong>的线程间同步。</p><p>这种多个事件的集合可以用一个 32 位无符号整型变量来表示，变量的每一位代表一个事件，线程通过 “逻辑与” 或“逻辑或”将一个或多个事件关联起来，形成事件组合。</p><ul><li>事件的 “逻辑或” 也称为是独立型同步，指的是线程与任何事件之一发生同步；</li><li>事件 “逻辑与” 也称为是关联型同步，指的是线程与若干事件都发生同步。</li><li>事件只与线程相关，事件间相互独立：每个线程可拥有 32 个事件标志，采用一个 32 bit 无符号整型数进行记录，每一个 bit 代表一个事件；</li><li>事件仅用于同步，不提供数据传输功能；</li><li>事件无排队性，即多次向线程发送同一事件 (如果线程还未来得及读走)，其效果等同于只发送一次。</li></ul><p><img src="/2021/42e53028/06event_work.png" alt="事件集工作示意图"></p><p>线程 #1 的事件标志中第 1 位和第 30 位被置位，如果事件信息标记位设为逻辑与，则表示线程 #1 只有在事件 1 和事件 30 都发生以后才会被触发唤醒，如果事件信息标记位设为逻辑或，则事件 1 或事件 30 中的任意一个发生都会触发唤醒线程 #1。如果信息标记同时设置了清除标记位，则当线程 #1 唤醒后将主动把事件 1 和事件 30 清为零，否则事件标志将依然存在（即置 1）。</p><h3 id="事件集API"><a href="#事件集API" class="headerlink" title="事件集API"></a>事件集API</h3><p><img src="/2021/42e53028/06event_ops.png" alt="事件相关接口"></p><h3 id="创建和删除事件集-create"><a href="#创建和删除事件集-create" class="headerlink" title="创建和删除事件集-create"></a>创建和删除事件集-create</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_event_t</span> <span class="hljs-title function_">rt_event_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">rt_uint8_t</span> flag)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>name</td><td>事件集的名称</td></tr><tr><td>flag</td><td>事件集的标志，它可以取如下数值： RT_IPC_FLAG_FIFO 或 RT_IPC_FLAG_PRIO</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_NULL</td><td>创建失败</td></tr><tr><td>事件对象的句柄</td><td>创建成功</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_event_delete</span><span class="hljs-params">(<span class="hljs-type">rt_event_t</span> event)</span>;<br></code></pre></td></tr></table></figure><p>在删除前会唤醒所有挂起在该事件集上的线程（线程的返回值是 - RT_ERROR），然后释放事件集对象占用的内存块。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>event</td><td>事件集对象的句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr></tbody></table><h3 id="初始化和脱离事件集-init"><a href="#初始化和脱离事件集-init" class="headerlink" title="初始化和脱离事件集-init"></a>初始化和脱离事件集-init</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_event_init</span><span class="hljs-params">(<span class="hljs-type">rt_event_t</span> event, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">rt_uint8_t</span> flag)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>event</td><td>事件集对象的句柄</td></tr><tr><td>name</td><td>事件集的名称</td></tr><tr><td>flag</td><td>事件集的标志，它可以取如下数值： RT_IPC_FLAG_FIFO 或 RT_IPC_FLAG_PRIO</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_event_detach</span><span class="hljs-params">(<span class="hljs-type">rt_event_t</span> event)</span>;<br></code></pre></td></tr></table></figure><p>用户调用这个函数时，系统首先唤醒所有挂在该事件集等待队列上的线程（线程的返回值是 - RT_ERROR），然后将该事件集从内核对象管理器中脱离。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>event</td><td>事件集对象的句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr></tbody></table><h3 id="发送事件-send"><a href="#发送事件-send" class="headerlink" title="发送事件-send"></a>发送事件-send</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_event_send</span><span class="hljs-params">(<span class="hljs-type">rt_event_t</span> event, <span class="hljs-type">rt_uint32_t</span> <span class="hljs-built_in">set</span>)</span>;<br></code></pre></td></tr></table></figure><p>使用该函数接口时，通过参数 set 指定的事件标志来设定 event 事件集对象的事件标志值，然后遍历等待在 event 事件集对象上的等待线程链表，判断是否有线程的事件激活要求与当前 event 对象事件标志值匹配，如果有，则唤醒该线程。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>event</td><td>事件集对象的句柄</td></tr><tr><td>set</td><td>发送的一个或多个事件的标志值,它可以取如下数值： RT_IPC_FLAG_FIFO 或 RT_IPC_FLAG_PRIO</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr></tbody></table><h3 id="接收事件-recv"><a href="#接收事件-recv" class="headerlink" title="接收事件-recv"></a>接收事件-recv</h3><p>内核使用 32 位的无符号整数来标识事件集，它的每一位代表一个事件，因此一个事件集对象可同时等待接收 32 个事件.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_event_recv</span><span class="hljs-params">(<span class="hljs-type">rt_event_t</span> event,</span><br><span class="hljs-params">                           <span class="hljs-type">rt_uint32_t</span> <span class="hljs-built_in">set</span>,</span><br><span class="hljs-params">                           <span class="hljs-type">rt_uint8_t</span> option,</span><br><span class="hljs-params">                           <span class="hljs-type">rt_int32_t</span> timeout,</span><br><span class="hljs-params">                           <span class="hljs-type">rt_uint32_t</span>* recved)</span>;<br></code></pre></td></tr></table></figure><p>当用户调用这个接口时，系统首先根据 set 参数和接收选项 option 来判断它要接收的事件是否发生，如果已经发生，则根据参数 option 上是否设置有 RT_EVENT_FLAG_CLEAR 来决定是否重置事件的相应标志位，然后返回（其中 recved 参数返回接收到的事件）；如果没有发生，则把等待的 set 和 option 参数填入线程本身的结构中，然后把线程挂起在此事件上，直到其等待的事件满足条件或等待时间超过指定的超时时间。如果超时时间设置为零，则表示当线程要接受的事件没有满足其要求时就不等待，而直接返回 - RT_ETIMEOUT。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>event</td><td>事件集对象的句柄</td></tr><tr><td>set</td><td>接收线程感兴趣的事件</td></tr><tr><td>option</td><td>接收选项 <strong>可取值见下</strong></td></tr><tr><td>timeout</td><td>指定超时时间</td></tr><tr><td>recved</td><td>指向接收到的事件</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr><tr><td>-RT_ETIMEOUT</td><td>超时</td></tr><tr><td>-RT_ERROR</td><td>错误</td></tr></tbody></table><p>option 的值可取：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 选择 逻辑与 或 逻辑或 的方式接收事件 */</span><br>RT_EVENT_FLAG_OR<br>RT_EVENT_FLAG_AND<br><br><span class="hljs-comment">/* 选择清除重置事件标志位 */</span><br>RT_EVENT_FLAG_CLEAR<br></code></pre></td></tr></table></figure><h2 id="事件集应用示例"><a href="#事件集应用示例" class="headerlink" title="事件集应用示例"></a>事件集应用示例</h2><p>这是事件集的应用例程，例子中初始化了一个事件集，两个线程。一个线程等待自己关心的事件发生，另外一个线程发送事件，如代码清单 6-5 例所示：</p><p>事件集的使用例程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;rtthread.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_PRIORITY      9</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_TIMESLICE     5</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EVENT_FLAG3 (1 &lt;&lt; 3)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EVENT_FLAG5 (1 &lt;&lt; 5)</span><br><br><span class="hljs-comment">/* 事件控制块 */</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_event</span> <span class="hljs-title">event</span>;</span><br><br>ALIGN(RT_ALIGN_SIZE)<br><span class="hljs-type">static</span> <span class="hljs-type">char</span> thread1_stack[<span class="hljs-number">1024</span>];<br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_thread</span> <span class="hljs-title">thread1</span>;</span><br><br><span class="hljs-comment">/* 线程 1 入口函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">thread1_recv_event</span><span class="hljs-params">(<span class="hljs-type">void</span> *param)</span><br>&#123;<br>    <span class="hljs-type">rt_uint32_t</span> e;<br><br>    <span class="hljs-comment">/* 第一次接收事件，事件 3 或事件 5 任意一个可以触发线程 1，接收完后清除事件标志 */</span><br>    <span class="hljs-keyword">if</span> (rt_event_recv(&amp;event, (EVENT_FLAG3 | EVENT_FLAG5),<br>                      RT_EVENT_FLAG_OR | RT_EVENT_FLAG_CLEAR,<br>                      RT_WAITING_FOREVER, &amp;e) == RT_EOK)<br>    &#123;<br>        rt_kprintf(<span class="hljs-string">&quot;thread1: OR recv event 0x%x\n&quot;</span>, e);<br>    &#125;<br><br>    rt_kprintf(<span class="hljs-string">&quot;thread1: delay 1s to prepare the second event\n&quot;</span>);<br>    rt_thread_mdelay(<span class="hljs-number">1000</span>);<br><br>    <span class="hljs-comment">/* 第二次接收事件，事件 3 和事件 5 均发生时才可以触发线程 1，接收完后清除事件标志 */</span><br>    <span class="hljs-keyword">if</span> (rt_event_recv(&amp;event, (EVENT_FLAG3 | EVENT_FLAG5),<br>                      RT_EVENT_FLAG_AND | RT_EVENT_FLAG_CLEAR,<br>                      RT_WAITING_FOREVER, &amp;e) == RT_EOK)<br>    &#123;<br>        rt_kprintf(<span class="hljs-string">&quot;thread1: AND recv event 0x%x\n&quot;</span>, e);<br>    &#125;<br>    rt_kprintf(<span class="hljs-string">&quot;thread1 leave.\n&quot;</span>);<br>&#125;<br><br><br>ALIGN(RT_ALIGN_SIZE)<br><span class="hljs-type">static</span> <span class="hljs-type">char</span> thread2_stack[<span class="hljs-number">1024</span>];<br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_thread</span> <span class="hljs-title">thread2</span>;</span><br><br><span class="hljs-comment">/* 线程 2 入口 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">thread2_send_event</span><span class="hljs-params">(<span class="hljs-type">void</span> *param)</span><br>&#123;<br>    rt_kprintf(<span class="hljs-string">&quot;thread2: send event3\n&quot;</span>);<br>    rt_event_send(&amp;event, EVENT_FLAG3);<br>    rt_thread_mdelay(<span class="hljs-number">200</span>);<br><br>    rt_kprintf(<span class="hljs-string">&quot;thread2: send event5\n&quot;</span>);<br>    rt_event_send(&amp;event, EVENT_FLAG5);<br>    rt_thread_mdelay(<span class="hljs-number">200</span>);<br><br>    rt_kprintf(<span class="hljs-string">&quot;thread2: send event3\n&quot;</span>);<br>    rt_event_send(&amp;event, EVENT_FLAG3);<br>    rt_kprintf(<span class="hljs-string">&quot;thread2 leave.\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">event_sample</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">rt_err_t</span> result;<br><br>    <span class="hljs-comment">/* 初始化事件对象 */</span><br>    result = rt_event_init(&amp;event, <span class="hljs-string">&quot;event&quot;</span>, RT_IPC_FLAG_FIFO);<br>    <span class="hljs-keyword">if</span> (result != RT_EOK)<br>    &#123;<br>        rt_kprintf(<span class="hljs-string">&quot;init event failed.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    rt_thread_init(&amp;thread1,<br>                   <span class="hljs-string">&quot;thread1&quot;</span>,<br>                   thread1_recv_event,<br>                   RT_NULL,<br>                   &amp;thread1_stack[<span class="hljs-number">0</span>],<br>                   <span class="hljs-keyword">sizeof</span>(thread1_stack),<br>                   THREAD_PRIORITY - <span class="hljs-number">1</span>, THREAD_TIMESLICE);<br>    rt_thread_startup(&amp;thread1);<br><br>    rt_thread_init(&amp;thread2,<br>                   <span class="hljs-string">&quot;thread2&quot;</span>,<br>                   thread2_send_event,<br>                   RT_NULL,<br>                   &amp;thread2_stack[<span class="hljs-number">0</span>],<br>                   <span class="hljs-keyword">sizeof</span>(thread2_stack),<br>                   THREAD_PRIORITY, THREAD_TIMESLICE);<br>    rt_thread_startup(&amp;thread2);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 导出到 msh 命令列表中 */</span><br>MSH_CMD_EXPORT(event_sample, event sample);<br></code></pre></td></tr></table></figure><p>仿真运行结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"> \ | /<br>- RT -     Thread Operating System<br> / | \     <span class="hljs-number">3.1</span><span class="hljs-number">.0</span> build Aug <span class="hljs-number">24</span> <span class="hljs-number">2018</span><br> <span class="hljs-number">2006</span> - <span class="hljs-number">2018</span> Copyright by rt-thread team<br>msh &gt;event_sample<br>thread2: send event3<br>thread1: OR recv event <span class="hljs-number">0x8</span><br>thread1: delay <span class="hljs-number">1</span>s to prepare the second event<br>msh &gt;thread2: send event5<br>thread2: send event3<br>thread2 leave.<br>thread1: AND recv event <span class="hljs-number">0x28</span><br>thread1 leave.<br></code></pre></td></tr></table></figure><h2 id="笔记-2"><a href="#笔记-2" class="headerlink" title="笔记"></a>笔记</h2><p>Semaphore:值、数值</p><p>Mutex:二值性、只能持有进程释放</p><p>Event:32Bit、进行’’或’’和’’与’’操作</p><ul><li>在获得互斥量后，请尽快释放互斥量，并且在持有互斥量的过程中，不得再行更改持有互斥量线程的优先级。</li><li>互斥量不能在中断服务例程中使用。</li></ul><h1 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h1><h2 id="邮箱Mailbox"><a href="#邮箱Mailbox" class="headerlink" title="邮箱Mailbox"></a>邮箱Mailbox</h2><p>邮箱用于线程间通信，特点是开销比较低，效率较高。邮箱中的每一封邮件只能容纳固定的 4 字节内容（针对 32 位处理系统，指针的大小即为 4 个字节，所以一封邮件恰好能够容纳一个指针）。</p><p>如下图所示，线程或中断服务例程把一封 4 字节长度的邮件发送到邮箱中，而一个或多个线程可以从邮箱中接收这些邮件并进行处理。</p><p><img src="/2021/42e53028/07mb_work.png" alt="邮箱工作示意图"></p><h3 id="邮箱API"><a href="#邮箱API" class="headerlink" title="邮箱API"></a>邮箱API</h3><p><img src="/2021/42e53028/07mb_ops.png" alt="邮箱相关接口"></p><h3 id="创建和删除邮箱-create"><a href="#创建和删除邮箱-create" class="headerlink" title="创建和删除邮箱-create"></a>创建和删除邮箱-create</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_mailbox_t</span> <span class="hljs-title function_">rt_mb_create</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">rt_size_t</span> size, <span class="hljs-type">rt_uint8_t</span> flag)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>name</td><td>邮箱名称</td></tr><tr><td>size</td><td>邮箱容量</td></tr><tr><td>flag</td><td>邮箱标志，它可以取如下数值： RT_IPC_FLAG_FIFO 或 RT_IPC_FLAG_PRIO</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_NULL</td><td>创建失败</td></tr><tr><td>邮箱对象的句柄</td><td>创建成功</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mb_delete</span> <span class="hljs-params">(<span class="hljs-type">rt_mailbox_t</span> mb)</span>;<br></code></pre></td></tr></table></figure><p>删除邮箱时，如果有线程被挂起在该邮箱对象上，内核先唤醒挂起在该邮箱上的所有线程（线程返回值是 - RT_ERROR），然后再释放邮箱使用的内存，最后删除邮箱对象。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mb</td><td>邮箱对象的句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr></tbody></table><h3 id="初始化和脱离邮箱-init"><a href="#初始化和脱离邮箱-init" class="headerlink" title="初始化和脱离邮箱-init"></a>初始化和脱离邮箱-init</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mb_init</span><span class="hljs-params">(<span class="hljs-type">rt_mailbox_t</span> mb,</span><br><span class="hljs-params">                  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name,</span><br><span class="hljs-params">                  <span class="hljs-type">void</span>* msgpool,</span><br><span class="hljs-params">                  <span class="hljs-type">rt_size_t</span> size,</span><br><span class="hljs-params">                  <span class="hljs-type">rt_uint8_t</span> flag)</span><br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mb</td><td>邮箱对象的句柄</td></tr><tr><td>name</td><td>邮箱名称</td></tr><tr><td>msgpool</td><td>缓冲区指针</td></tr><tr><td>size</td><td>邮箱容量</td></tr><tr><td>flag</td><td>邮箱标志，它可以取如下数值： RT_IPC_FLAG_FIFO 或 RT_IPC_FLAG_PRIO</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr></tbody></table><p>即如果 msgpool 指向的缓冲区的字节数是 N，那么邮箱容量应该是 N&#x2F;4。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mb_detach</span><span class="hljs-params">(<span class="hljs-type">rt_mailbox_t</span> mb)</span>;<br></code></pre></td></tr></table></figure><p>使用该函数接口后，内核先唤醒所有挂在该邮箱上的线程（线程获得返回值是 - RT_ERROR），然后将该邮箱对象从内核对象管理器中脱离。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mb</td><td>邮箱对象的句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr></tbody></table><h3 id="发送邮件-send"><a href="#发送邮件-send" class="headerlink" title="发送邮件-send"></a>发送邮件-send</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mb_send</span> <span class="hljs-params">(<span class="hljs-type">rt_mailbox_t</span> mb, <span class="hljs-type">rt_uint32_t</span> value)</span>;<br></code></pre></td></tr></table></figure><p>发送的邮件可以是 32 位任意格式的数据，一个整型值或者一个指向缓冲区的指针。当邮箱中的邮件已经满时，发送邮件的线程或者中断程序会收到 -RT_EFULL 的返回值。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mb</td><td>邮箱对象的句柄</td></tr><tr><td>value</td><td>邮件内容</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>发送成功</td></tr><tr><td>-RT_EFULL</td><td>邮箱已经满了</td></tr></tbody></table><h3 id="等待方式发送邮件-wait-send"><a href="#等待方式发送邮件-wait-send" class="headerlink" title="等待方式发送邮件-wait send"></a>等待方式发送邮件-wait send</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mb_send_wait</span> <span class="hljs-params">(<span class="hljs-type">rt_mailbox_t</span> mb,</span><br><span class="hljs-params">                      <span class="hljs-type">rt_uint32_t</span> value,</span><br><span class="hljs-params">                      <span class="hljs-type">rt_int32_t</span> timeout)</span>;<br></code></pre></td></tr></table></figure><p>rt_mb_send_wait() 与 rt_mb_send() 的区别在于有等待时间，如果邮箱已经满了，那么发送线程将根据设定的 timeout 参数等待邮箱中因为收取邮件而空出空间。如果设置的超时时间到达依然没有空出空间，这时发送线程将被唤醒并返回错误码。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mb</td><td>邮箱对象的句柄</td></tr><tr><td>value</td><td>邮件内容</td></tr><tr><td>timeout</td><td>超时时间</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>发送成功</td></tr><tr><td>-RT_ETIMEOUT</td><td>超时</td></tr><tr><td>-RT_ERROR</td><td>失败，返回错误</td></tr></tbody></table><h3 id="接收邮件-recv"><a href="#接收邮件-recv" class="headerlink" title="接收邮件-recv"></a>接收邮件-recv</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mb_recv</span> <span class="hljs-params">(<span class="hljs-type">rt_mailbox_t</span> mb, <span class="hljs-type">rt_uint32_t</span>* value, <span class="hljs-type">rt_int32_t</span> timeout)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mb</td><td>邮箱对象的句柄</td></tr><tr><td>value</td><td>邮件内容</td></tr><tr><td>timeout</td><td>超时时间</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>发送成功</td></tr><tr><td>-RT_ETIMEOUT</td><td>超时</td></tr><tr><td>-RT_ERROR</td><td>失败，返回错误</td></tr></tbody></table><h2 id="邮箱应用示例"><a href="#邮箱应用示例" class="headerlink" title="邮箱应用示例"></a>邮箱应用示例</h2><p>这是一个邮箱的应用例程，初始化 2 个静态线程，一个静态的邮箱对象，其中一个线程往邮箱中发送邮件，一个线程往邮箱中收取邮件。如下代码所示：</p><p>邮箱的使用例程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;rtthread.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_PRIORITY      10</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_TIMESLICE     5</span><br><br><span class="hljs-comment">/* 邮箱控制块 */</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_mailbox</span> <span class="hljs-title">mb</span>;</span><br><span class="hljs-comment">/* 用于放邮件的内存池 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">char</span> mb_pool[<span class="hljs-number">128</span>];<br><br><span class="hljs-type">static</span> <span class="hljs-type">char</span> mb_str1[] = <span class="hljs-string">&quot;I&#x27;m a mail!&quot;</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">char</span> mb_str2[] = <span class="hljs-string">&quot;this is another mail!&quot;</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">char</span> mb_str3[] = <span class="hljs-string">&quot;over&quot;</span>;<br><br>ALIGN(RT_ALIGN_SIZE)<br><span class="hljs-type">static</span> <span class="hljs-type">char</span> thread1_stack[<span class="hljs-number">1024</span>];<br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_thread</span> <span class="hljs-title">thread1</span>;</span><br><br><span class="hljs-comment">/* 线程 1 入口 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">thread1_entry</span><span class="hljs-params">(<span class="hljs-type">void</span> *parameter)</span><br>&#123;<br>    <span class="hljs-type">char</span> *str;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        rt_kprintf(<span class="hljs-string">&quot;thread1: try to recv a mail\n&quot;</span>);<br><br>        <span class="hljs-comment">/* 从邮箱中收取邮件 */</span><br>        <span class="hljs-keyword">if</span> (rt_mb_recv(&amp;mb, (<span class="hljs-type">rt_uint32_t</span> *)&amp;str, RT_WAITING_FOREVER) == RT_EOK)<br>        &#123;<br>            rt_kprintf(<span class="hljs-string">&quot;thread1: get a mail from mailbox, the content:%s\n&quot;</span>, str);<br>            <span class="hljs-keyword">if</span> (str == mb_str3)<br>                <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-comment">/* 延时 100ms */</span><br>            rt_thread_mdelay(<span class="hljs-number">100</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/* 执行邮箱对象脱离 */</span><br>    rt_mb_detach(&amp;mb);<br>&#125;<br><br>ALIGN(RT_ALIGN_SIZE)<br><span class="hljs-type">static</span> <span class="hljs-type">char</span> thread2_stack[<span class="hljs-number">1024</span>];<br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_thread</span> <span class="hljs-title">thread2</span>;</span><br><br><span class="hljs-comment">/* 线程 2 入口 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">thread2_entry</span><span class="hljs-params">(<span class="hljs-type">void</span> *parameter)</span><br>&#123;<br>    <span class="hljs-type">rt_uint8_t</span> count;<br><br>    count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (count &lt; <span class="hljs-number">10</span>)<br>    &#123;<br>        count ++;<br>        <span class="hljs-keyword">if</span> (count &amp; <span class="hljs-number">0x1</span>)<br>        &#123;<br>            <span class="hljs-comment">/* 发送 mb_str1 地址到邮箱中 */</span><br>            rt_mb_send(&amp;mb, (<span class="hljs-type">rt_uint32_t</span>)&amp;mb_str1);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">/* 发送 mb_str2 地址到邮箱中 */</span><br>            rt_mb_send(&amp;mb, (<span class="hljs-type">rt_uint32_t</span>)&amp;mb_str2);<br>        &#125;<br><br>        <span class="hljs-comment">/* 延时 200ms */</span><br>        rt_thread_mdelay(<span class="hljs-number">200</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* 发送邮件告诉线程 1，线程 2 已经运行结束 */</span><br>    rt_mb_send(&amp;mb, (<span class="hljs-type">rt_uint32_t</span>)&amp;mb_str3);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">mailbox_sample</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">rt_err_t</span> result;<br><br>    <span class="hljs-comment">/* 初始化一个 mailbox */</span><br>    result = rt_mb_init(&amp;mb,<br>                        <span class="hljs-string">&quot;mbt&quot;</span>,                      <span class="hljs-comment">/* 名称是 mbt */</span><br>                        &amp;mb_pool[<span class="hljs-number">0</span>],                <span class="hljs-comment">/* 邮箱用到的内存池是 mb_pool */</span><br>                        <span class="hljs-keyword">sizeof</span>(mb_pool) / <span class="hljs-number">4</span>,        <span class="hljs-comment">/* 邮箱中的邮件数目，因为一封邮件占 4 字节 */</span><br>                        RT_IPC_FLAG_FIFO);          <span class="hljs-comment">/* 采用 FIFO 方式进行线程等待 */</span><br>    <span class="hljs-keyword">if</span> (result != RT_EOK)<br>    &#123;<br>        rt_kprintf(<span class="hljs-string">&quot;init mailbox failed.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    rt_thread_init(&amp;thread1,<br>                   <span class="hljs-string">&quot;thread1&quot;</span>,<br>                   thread1_entry,<br>                   RT_NULL,<br>                   &amp;thread1_stack[<span class="hljs-number">0</span>],<br>                   <span class="hljs-keyword">sizeof</span>(thread1_stack),<br>                   THREAD_PRIORITY, THREAD_TIMESLICE);<br>    rt_thread_startup(&amp;thread1);<br><br>    rt_thread_init(&amp;thread2,<br>                   <span class="hljs-string">&quot;thread2&quot;</span>,<br>                   thread2_entry,<br>                   RT_NULL,<br>                   &amp;thread2_stack[<span class="hljs-number">0</span>],<br>                   <span class="hljs-keyword">sizeof</span>(thread2_stack),<br>                   THREAD_PRIORITY, THREAD_TIMESLICE);<br>    rt_thread_startup(&amp;thread2);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 导出到 msh 命令列表中 */</span><br>MSH_CMD_EXPORT(mailbox_sample, mailbox sample);<br></code></pre></td></tr></table></figure><p>仿真运行结果如下：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"> \ | /<br>- RT -     Thread Operating System<br> / | \     <span class="hljs-number">3.1</span>.<span class="hljs-number">0</span> build Aug <span class="hljs-number">27</span> <span class="hljs-number">2018</span><br> <span class="hljs-number">2006</span> - <span class="hljs-number">2018</span> Copyright <span class="hljs-keyword">by</span> rt-thread team<br>msh &gt;mailbox_sample<br><span class="hljs-symbol">thread1:</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">to</span> recv a mail<br><span class="hljs-symbol">thread1:</span> <span class="hljs-keyword">get</span> a mail <span class="hljs-keyword">from</span> mailbox, the content:I<span class="hljs-comment">&#x27;m a mail!</span><br>msh &gt;thread1: <span class="hljs-keyword">try</span> <span class="hljs-keyword">to</span> recv a mail<br><span class="hljs-symbol">thread1:</span> <span class="hljs-keyword">get</span> a mail <span class="hljs-keyword">from</span> mailbox, the content:this <span class="hljs-built_in">is</span> another mail!<br>…<br><span class="hljs-symbol">thread1:</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">to</span> recv a mail<br><span class="hljs-symbol">thread1:</span> <span class="hljs-keyword">get</span> a mail <span class="hljs-keyword">from</span> mailbox, the content:this <span class="hljs-built_in">is</span> another mail!<br><span class="hljs-symbol">thread1:</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">to</span> recv a mail<br><span class="hljs-symbol">thread1:</span> <span class="hljs-keyword">get</span> a mail <span class="hljs-keyword">from</span> mailbox, the content:over<br></code></pre></td></tr></table></figure><h2 id="消息队列Messagequeue"><a href="#消息队列Messagequeue" class="headerlink" title="消息队列Messagequeue"></a>消息队列Messagequeue</h2><p>消息队列是另一种常用的线程间通讯方式，是邮箱的扩展(消息队列：不固定长度的消息)。可以应用在多种场合：线程间的消息交换、使用串口接收不定长数据等。</p><p>线程或中断服务例程可以将一条或多条消息放入消息队列中。同样，一个或多个线程也可以从消息队列中获得消息。当有多个消息发送到消息队列时，通常将先进入消息队列的消息先传给线程，也就是说，线程先得到的是最先进入消息队列的消息，即先进先出原则 (FIFO)。</p><ul><li>消息框含有消息头（用于链表连接）</li></ul><p><img src="/2021/42e53028/07msg_work.png" alt="消息队列工作示意图"></p><p>消息队列和邮箱的明显不同是消息的长度并不限定在 4 个字节以内；另外，消息队列也包括了一个发送紧急消息的函数接口。但是当创建的是一个所有消息的最大长度是 4 字节的消息队列时，消息队列对象将蜕化成邮箱。</p><h3 id="消息队列API"><a href="#消息队列API" class="headerlink" title="消息队列API"></a>消息队列API</h3><p><img src="/2021/42e53028/07msg_ops.png" alt="消息队列相关接口"></p><h3 id="创建和删除消息队列-create"><a href="#创建和删除消息队列-create" class="headerlink" title="创建和删除消息队列-create"></a>创建和删除消息队列-create</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_mq_t</span> <span class="hljs-title function_">rt_mq_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">rt_size_t</span> msg_size,</span><br><span class="hljs-params">            <span class="hljs-type">rt_size_t</span> max_msgs, <span class="hljs-type">rt_uint8_t</span> flag)</span>;<br></code></pre></td></tr></table></figure><p>消息队列内存的大小 &#x3D;[消息大小+消息头（用于链表连接）的大小]X消息队列最大个数</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>name</td><td>消息队列的名称</td></tr><tr><td>msg_size</td><td>消息队列中一条消息的最大长度，单位字节</td></tr><tr><td>max_msgs</td><td>消息队列的最大个数</td></tr><tr><td>flag</td><td>消息队列采用的等待方式，它可以取如下数值： RT_IPC_FLAG_FIFO 或 RT_IPC_FLAG_PRIO</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>发送成功</td></tr><tr><td>消息队列对象的句柄</td><td>成功</td></tr><tr><td>RT_NULL</td><td>失败</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mq_delete</span><span class="hljs-params">(<span class="hljs-type">rt_mq_t</span> mq)</span>;<br></code></pre></td></tr></table></figure><p>删除消息队列时，如果有线程被挂起在该消息队列等待队列上，则内核先唤醒挂起在该消息等待队列上的所有线程（线程返回值是 - RT_ERROR），然后再释放消息队列使用的内存，最后删除消息队列对象。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mq</td><td>消息队列对象的句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr></tbody></table><h3 id="初始化和脱离消息队列-init"><a href="#初始化和脱离消息队列-init" class="headerlink" title="初始化和脱离消息队列-init"></a>初始化和脱离消息队列-init</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mq_init</span><span class="hljs-params">(<span class="hljs-type">rt_mq_t</span> mq, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name,</span><br><span class="hljs-params">                        <span class="hljs-type">void</span> *msgpool, <span class="hljs-type">rt_size_t</span> msg_size,</span><br><span class="hljs-params">                        <span class="hljs-type">rt_size_t</span> pool_size, <span class="hljs-type">rt_uint8_t</span> flag)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mq</td><td>消息队列对象的句柄</td></tr><tr><td>name</td><td>消息队列的名称</td></tr><tr><td>msgpool</td><td>指向存放消息的缓冲区的指针</td></tr><tr><td>msg_size</td><td>消息队列中一条消息的最大长度，单位字节</td></tr><tr><td>pool_size</td><td>存放消息的缓冲区大小</td></tr><tr><td>flag</td><td>消息队列采用的等待方式，它可以取如下数值： RT_IPC_FLAG_FIFO 或 RT_IPC_FLAG_PRIO</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mq_detach</span><span class="hljs-params">(<span class="hljs-type">rt_mq_t</span> mq)</span>;<br></code></pre></td></tr></table></figure><p>使用该函数接口后，内核先唤醒所有挂在该消息等待队列对象上的线程（线程返回值是 -RT_ERROR），然后将该消息队列对象从内核对象管理器中脱离。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mq</td><td>消息队列对象的句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr></tbody></table><h3 id="发送消息-send"><a href="#发送消息-send" class="headerlink" title="发送消息-send"></a>发送消息-send</h3><p><strong>线程</strong>或者<strong>中断服务程序</strong>都可以给消息队列发送消息。当发送消息时，消息队列对象先从空闲消息链表上取下一个空闲消息块，把线程或者中断服务程序发送的消息内容复制到消息块上，然后把该消息块挂到消息队列的尾部。当且仅当空闲消息链表上有可用的空闲消息块时，发送者才能成功发送消息；当空闲消息链表上无可用消息块，说明消息队列已满，此时，发送消息的的线程或者中断程序会收到一个错误码（-RT_EFULL）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mq_send</span> <span class="hljs-params">(<span class="hljs-type">rt_mq_t</span> mq, <span class="hljs-type">void</span>* buffer, <span class="hljs-type">rt_size_t</span> size)</span>;<br></code></pre></td></tr></table></figure><p>发送消息时，发送者需指定发送的消息队列的对象句柄（即指向消息队列控制块的指针），并且指定发送的消息内容以及消息大小。如下图所示，在发送一个普通消息之后，空闲消息链表上的队首消息被转移到了消息队列尾。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mq</td><td>消息队列对象的句柄</td></tr><tr><td>buffer</td><td>消息内容</td></tr><tr><td>size</td><td>消息大小</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr><tr><td>-RT_EFULL</td><td>消息队列已满</td></tr><tr><td>-RT_ERROR</td><td>失败，表示发送的消息长度大于消息队列中消息的最大长度</td></tr></tbody></table><h3 id="等待方式发送消息-wait"><a href="#等待方式发送消息-wait" class="headerlink" title="等待方式发送消息-wait"></a>等待方式发送消息-wait</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mq_send_wait</span><span class="hljs-params">(<span class="hljs-type">rt_mq_t</span>     mq,</span><br><span class="hljs-params">                         <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buffer,</span><br><span class="hljs-params">                         <span class="hljs-type">rt_size_t</span>   size,</span><br><span class="hljs-params">                         <span class="hljs-type">rt_int32_t</span>  timeout)</span>;<br></code></pre></td></tr></table></figure><p>rt_mq_send_wait() 与 rt_mq_send() 的区别在于有等待时间，如果消息队列已经满了，那么发送线程将根据设定的 timeout 参数进行等待。如果设置的超时时间到达依然没有空出空间，这时发送线程将被唤醒并返回错误码。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mq</td><td>消息队列对象的句柄</td></tr><tr><td>buffer</td><td>消息内容</td></tr><tr><td>size</td><td>消息大小</td></tr><tr><td>timeout</td><td>超时时间</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr><tr><td>-RT_EFULL</td><td>消息队列已满</td></tr><tr><td>-RT_ERROR</td><td>失败，表示发送的消息长度大于消息队列中消息的最大长度</td></tr></tbody></table><h3 id="发送紧急消息-urgent"><a href="#发送紧急消息-urgent" class="headerlink" title="发送紧急消息-urgent"></a>发送紧急消息-urgent</h3><p>发送紧急消息的过程与发送消息几乎一样，唯一的不同是，当发送紧急消息时，从空闲消息链表上取下来的消息块不是挂到消息队列的队尾，而是挂到队首，这样，接收者就能够优先接收到紧急消息，从而及时进行消息处理。发送紧急消息的函数接口如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mq_urgent</span><span class="hljs-params">(<span class="hljs-type">rt_mq_t</span> mq, <span class="hljs-type">void</span>* buffer, <span class="hljs-type">rt_size_t</span> size)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mq</td><td>消息队列对象的句柄</td></tr><tr><td>buffer</td><td>消息内容</td></tr><tr><td>size</td><td>消息大小</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr><tr><td>-RT_EFULL</td><td>消息队列已满</td></tr><tr><td>-RT_ERROR</td><td>失败</td></tr></tbody></table><h3 id="接收消息-recv"><a href="#接收消息-recv" class="headerlink" title="接收消息-recv"></a>接收消息-recv</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mq_recv</span> <span class="hljs-params">(<span class="hljs-type">rt_mq_t</span> mq, <span class="hljs-type">void</span>* buffer,</span><br><span class="hljs-params">                    <span class="hljs-type">rt_size_t</span> size, <span class="hljs-type">rt_int32_t</span> timeout)</span>;<br></code></pre></td></tr></table></figure><p>接收消息时，接收者需指定存储消息的消息队列对象句柄，并且指定一个内存缓冲区，接收到的消息内容将被复制到该缓冲区里。此外，还需指定未能及时取到消息时的超时时间。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mq</td><td>消息队列对象的句柄</td></tr><tr><td>buffer</td><td>消息内容</td></tr><tr><td>size</td><td>消息大小</td></tr><tr><td>timeout</td><td>指定的超时时间</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功收到</td></tr><tr><td>-RT_ETIMEOUT</td><td>超时</td></tr><tr><td>-RT_ERROR</td><td>失败，返回错误</td></tr></tbody></table><h2 id="消息队列应用示例"><a href="#消息队列应用示例" class="headerlink" title="消息队列应用示例"></a>消息队列应用示例</h2><p>这是一个消息队列的应用例程，例程中初始化了 2 个静态线程，一个线程会从消息队列中收取消息；另一个线程会定时给消息队列发送普通消息和紧急消息，如下代码所示：</p><p>消息队列的使用例程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;rtthread.h&gt;</span></span><br><br><span class="hljs-comment">/* 消息队列控制块 */</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_messagequeue</span> <span class="hljs-title">mq</span>;</span><br><span class="hljs-comment">/* 消息队列中用到的放置消息的内存池 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">rt_uint8_t</span> msg_pool[<span class="hljs-number">2048</span>];<br><br>ALIGN(RT_ALIGN_SIZE)<br><span class="hljs-type">static</span> <span class="hljs-type">char</span> thread1_stack[<span class="hljs-number">1024</span>];<br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_thread</span> <span class="hljs-title">thread1</span>;</span><br><span class="hljs-comment">/* 线程 1 入口函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">thread1_entry</span><span class="hljs-params">(<span class="hljs-type">void</span> *parameter)</span><br>&#123;<br>    <span class="hljs-type">char</span> buf = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">rt_uint8_t</span> cnt = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">/* 从消息队列中接收消息 */</span><br>        <span class="hljs-keyword">if</span> (rt_mq_recv(&amp;mq, &amp;buf, <span class="hljs-keyword">sizeof</span>(buf), RT_WAITING_FOREVER) == RT_EOK)<br>        &#123;<br>            rt_kprintf(<span class="hljs-string">&quot;thread1: recv msg from msg queue, the content:%c\n&quot;</span>, buf);<br>            <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">19</span>)<br>            &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">/* 延时 50ms */</span><br>        cnt++;<br>        rt_thread_mdelay(<span class="hljs-number">50</span>);<br>    &#125;<br>    rt_kprintf(<span class="hljs-string">&quot;thread1: detach mq \n&quot;</span>);<br>    rt_mq_detach(&amp;mq);<br>&#125;<br><br>ALIGN(RT_ALIGN_SIZE)<br><span class="hljs-type">static</span> <span class="hljs-type">char</span> thread2_stack[<span class="hljs-number">1024</span>];<br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_thread</span> <span class="hljs-title">thread2</span>;</span><br><span class="hljs-comment">/* 线程 2 入口 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">thread2_entry</span><span class="hljs-params">(<span class="hljs-type">void</span> *parameter)</span><br>&#123;<br>    <span class="hljs-type">int</span> result;<br>    <span class="hljs-type">char</span> buf = <span class="hljs-string">&#x27;A&#x27;</span>;<br>    <span class="hljs-type">rt_uint8_t</span> cnt = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">8</span>)<br>        &#123;<br>            <span class="hljs-comment">/* 发送紧急消息到消息队列中 */</span><br>            result = rt_mq_urgent(&amp;mq, &amp;buf, <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (result != RT_EOK)<br>            &#123;<br>                rt_kprintf(<span class="hljs-string">&quot;rt_mq_urgent ERR\n&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                rt_kprintf(<span class="hljs-string">&quot;thread2: send urgent message - %c\n&quot;</span>, buf);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cnt&gt;= <span class="hljs-number">20</span>)<span class="hljs-comment">/* 发送 20 次消息之后退出 */</span><br>        &#123;<br>            rt_kprintf(<span class="hljs-string">&quot;message queue stop send, thread2 quit\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">/* 发送消息到消息队列中 */</span><br>            result = rt_mq_send(&amp;mq, &amp;buf, <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (result != RT_EOK)<br>            &#123;<br>                rt_kprintf(<span class="hljs-string">&quot;rt_mq_send ERR\n&quot;</span>);<br>            &#125;<br><br>            rt_kprintf(<span class="hljs-string">&quot;thread2: send message - %c\n&quot;</span>, buf);<br>        &#125;<br>        buf++;<br>        cnt++;<br>        <span class="hljs-comment">/* 延时 5ms */</span><br>        rt_thread_mdelay(<span class="hljs-number">5</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* 消息队列示例的初始化 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">msgq_sample</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">rt_err_t</span> result;<br><br>    <span class="hljs-comment">/* 初始化消息队列 */</span><br>    result = rt_mq_init(&amp;mq,<br>                        <span class="hljs-string">&quot;mqt&quot;</span>,<br>                        &amp;msg_pool[<span class="hljs-number">0</span>],             <span class="hljs-comment">/* 内存池指向 msg_pool */</span><br>                        <span class="hljs-number">1</span>,                          <span class="hljs-comment">/* 每个消息的大小是 1 字节 */</span><br>                        <span class="hljs-keyword">sizeof</span>(msg_pool),        <span class="hljs-comment">/* 内存池的大小是 msg_pool 的大小 */</span><br>                        RT_IPC_FLAG_FIFO);       <span class="hljs-comment">/* 如果有多个线程等待，按照先来先得到的方法分配消息 */</span><br><br>    <span class="hljs-keyword">if</span> (result != RT_EOK)<br>    &#123;<br>        rt_kprintf(<span class="hljs-string">&quot;init message queue failed.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    rt_thread_init(&amp;thread1,<br>                   <span class="hljs-string">&quot;thread1&quot;</span>,<br>                   thread1_entry,<br>                   RT_NULL,<br>                   &amp;thread1_stack[<span class="hljs-number">0</span>],<br>                   <span class="hljs-keyword">sizeof</span>(thread1_stack), <span class="hljs-number">25</span>, <span class="hljs-number">5</span>);<br>    rt_thread_startup(&amp;thread1);<br><br>    rt_thread_init(&amp;thread2,<br>                   <span class="hljs-string">&quot;thread2&quot;</span>,<br>                   thread2_entry,<br>                   RT_NULL,<br>                   &amp;thread2_stack[<span class="hljs-number">0</span>],<br>                   <span class="hljs-keyword">sizeof</span>(thread2_stack), <span class="hljs-number">25</span>, <span class="hljs-number">5</span>);<br>    rt_thread_startup(&amp;thread2);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 导出到 msh 命令列表中 */</span><br>MSH_CMD_EXPORT(msgq_sample, msgq sample);<br></code></pre></td></tr></table></figure><p>仿真运行结果如下：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">\ | /<br>- RT -     Thread Operating System<br> / | \     <span class="hljs-number">3.1</span>.<span class="hljs-number">0</span> build Aug <span class="hljs-number">24</span> <span class="hljs-number">2018</span><br> <span class="hljs-number">2006</span> - <span class="hljs-number">2018</span> Copyright <span class="hljs-keyword">by</span> rt-thread team<br>msh &gt; msgq_sample<br>msh &gt;thread2: send message - A<br><span class="hljs-symbol">thread1:</span> recv msg <span class="hljs-keyword">from</span> msg queue, the content:A<br><span class="hljs-symbol">thread2:</span> send message - B<br><span class="hljs-symbol">thread2:</span> send message - C<br><span class="hljs-symbol">thread2:</span> send message - D<br><span class="hljs-symbol">thread2:</span> send message - E<br><span class="hljs-symbol">thread1:</span> recv msg <span class="hljs-keyword">from</span> msg queue, the content:B<br><span class="hljs-symbol">thread2:</span> send message - F<br><span class="hljs-symbol">thread2:</span> send message - G<br><span class="hljs-symbol">thread2:</span> send message - H<br><span class="hljs-symbol">thread2:</span> send urgent message - I<br><span class="hljs-symbol">thread2:</span> send message - J<br><span class="hljs-symbol">thread1:</span> recv msg <span class="hljs-keyword">from</span> msg queue, the content:I<br><span class="hljs-symbol">thread2:</span> send message - K<br><span class="hljs-symbol">thread2:</span> send message - L<br><span class="hljs-symbol">thread2:</span> send message - M<br><span class="hljs-symbol">thread2:</span> send message - N<br><span class="hljs-symbol">thread2:</span> send message - O<br><span class="hljs-symbol">thread1:</span> recv msg <span class="hljs-keyword">from</span> msg queue, the content:C<br><span class="hljs-symbol">thread2:</span> send message - P<br><span class="hljs-symbol">thread2:</span> send message - Q<br><span class="hljs-symbol">thread2:</span> send message - R<br><span class="hljs-symbol">thread2:</span> send message - S<br><span class="hljs-symbol">thread2:</span> send message - T<br><span class="hljs-symbol">thread1:</span> recv msg <span class="hljs-keyword">from</span> msg queue, the content:D<br>message queue <span class="hljs-keyword">stop</span> send, thread2 quit<br><span class="hljs-symbol">thread1:</span> recv msg <span class="hljs-keyword">from</span> msg queue, the content:E<br><span class="hljs-symbol">thread1:</span> recv msg <span class="hljs-keyword">from</span> msg queue, the content:F<br><span class="hljs-symbol">thread1:</span> recv msg <span class="hljs-keyword">from</span> msg queue, the content:G<br>…<br><span class="hljs-symbol">thread1:</span> recv msg <span class="hljs-keyword">from</span> msg queue, the content:T<br><span class="hljs-symbol">thread1:</span> detach mq<br></code></pre></td></tr></table></figure><h2 id="信号Sigset"><a href="#信号Sigset" class="headerlink" title="信号Sigset"></a>信号Sigset</h2><p>信号（又称为软中断信号），在软件层次上是对中断机制的一种模拟，在原理上，一个线程收到一个信号与处理器收到一个中断请求可以说是类似的。</p><p>应用程序(用户)能够使用的信号为 SIGUSR1（10）和 SIGUSR2（12）。</p><p>信号本质是<strong>软中断</strong>，用来通知线程发生了异步事件，用做线程之间的异常通知、应急处理。一个线程不必通过任何操作来等待信号的到达，事实上，线程也不知道信号到底什么时候到达，线程之间可以互相通过调用 rt_thread_kill() 发送软中断信号。</p><p>收到信号的线程对各种信号有不同的处理方法，在信号安装时设定 handler 参数，处理方法可以分为三类：</p><ul><li><p>第一种是类似中断的处理程序，对于需要处理的信号，线程可以指定处理函数，由该函数来处理。</p></li><li><p>第二种方法是，参数设为 SIG_IGN，忽略某个信号，对该信号不做任何处理，就像未发生过一样。 </p></li><li><p>第三种方法是，参数设为 SIG_DFL，系统会调用默认的处理函数_signal_default_handler()。</p></li></ul><p>如下图所示，假设线程 1 需要对信号进行处理，首先线程 1 安装一个信号并解除阻塞，并在安装的同时设定了对信号的异常处理方式；然后其他线程可以给线程 1 发送信号，触发线程 1 对该信号的处理。</p><p>当信号被传递给线程 1 时，如果它正处于挂起状态，那会把状态改为就绪状态去处理对应的信号。如果它正处于运行状态，那么会在它当前的线程栈基础上建立新栈帧空间去处理对应的信号，需要注意的是使用的线程栈大小也会相应增加。</p><p><img src="/2021/42e53028/07signal_work.png" alt="信号工作机制"></p><h3 id="信号API"><a href="#信号API" class="headerlink" title="信号API"></a>信号API</h3><p><img src="/2021/42e53028/07signal_ops.png" alt="信号相关接口"></p><h3 id="安装信号-install"><a href="#安装信号-install" class="headerlink" title="安装信号-install"></a>安装信号-install</h3><p>如果线程要处理某一信号，那么就要在线程中安装该信号。安装信号主要用来确定信号值及线程针对该信号值的动作之间的映射关系，即线程将要处理哪个信号，该信号被传递给线程时，将执行何种操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_sighandler_t</span> <span class="hljs-title function_">rt_signal_install</span><span class="hljs-params">(<span class="hljs-type">int</span> signo, <span class="hljs-type">rt_sighandler_t</span>[] handler)</span>;<br></code></pre></td></tr></table></figure><p>其中 rt_sighandler_t 是定义信号处理函数的函数指针类型。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>signo</td><td>信号值（只有 SIGUSR1 和 SIGUSR2 是开放给用户使用的，下同）</td></tr><tr><td>handler</td><td>设置对信号值的处理方式 （函数指针）</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>SIG_ERR</td><td>错误的信号</td></tr><tr><td>安装信号前的 handler 值</td><td>成功</td></tr></tbody></table><h3 id="屏蔽信号-mask"><a href="#屏蔽信号-mask" class="headerlink" title="屏蔽信号-mask"></a>屏蔽信号-mask</h3><p>信号阻塞，也可以理解为屏蔽信号。如果该信号被阻塞，则该信号将不会递达给安装此信号的线程，也不会引发软中断处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">rt_signal_mask</span><span class="hljs-params">(<span class="hljs-type">int</span> signo)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>signo</td><td>信号值</td></tr></tbody></table><h3 id="解除信号屏蔽-unmask"><a href="#解除信号屏蔽-unmask" class="headerlink" title="解除信号屏蔽-unmask"></a>解除信号屏蔽-unmask</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">rt_signal_unmask</span><span class="hljs-params">(<span class="hljs-type">int</span> signo)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>signo</td><td>信号值</td></tr></tbody></table><h3 id="发送信号-kill"><a href="#发送信号-kill" class="headerlink" title="发送信号-kill"></a>发送信号-kill</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">rt_thread_kill</span><span class="hljs-params">(<span class="hljs-type">rt_thread_t</span> tid, <span class="hljs-type">int</span> sig)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>tid</td><td>接收信号的线程</td></tr><tr><td>sig</td><td>信号值</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>发送成功</td></tr><tr><td>-RT_EINVAL</td><td>参数错误</td></tr></tbody></table><h3 id="等待信号-wait"><a href="#等待信号-wait" class="headerlink" title="等待信号-wait"></a>等待信号-wait</h3><p>等待 set 信号的到来，如果没有等到这个信号，则将线程挂起，直到等到这个信号或者等待时间超过指定的超时时间 timeout。如果等到了该信号，则将指向该信号体的指针存入 si，如下是等待信号的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">rt_signal_wait</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">rt_sigset_t</span> *<span class="hljs-built_in">set</span>,</span><br><span class="hljs-params">                        <span class="hljs-type">rt_siginfo_t</span>[] *si, <span class="hljs-type">rt_int32_t</span> timeout)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>set</td><td>指定等待的信号</td></tr><tr><td>si</td><td>指向存储等到信号信息的指针</td></tr><tr><td>timeout</td><td>指定的等待时间</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>等到信号</td></tr><tr><td>-RT_ETIMEOUT</td><td>超时</td></tr><tr><td>-RT_EINVAL</td><td>参数错误</td></tr></tbody></table><h2 id="信号应用示例"><a href="#信号应用示例" class="headerlink" title="信号应用示例"></a>信号应用示例</h2><p>这是一个信号的应用例程，如下代码所示。此例程创建了 1 个线程，在安装信号时，信号处理方式设为自定义处理，定义的信号的处理函数为 thread1_signal_handler()。待此线程运行起来安装好信号之后，给此线程发送信号。此线程将接收到信号，并打印信息。</p><p>信号使用例程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;rtthread.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_PRIORITY         25</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_STACK_SIZE       512</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_TIMESLICE        5</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">rt_thread_t</span> tid1 = RT_NULL;<br><br><span class="hljs-comment">/* 线程 1 的信号处理函数 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">thread1_signal_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span><br>&#123;<br>    rt_kprintf(<span class="hljs-string">&quot;thread1 received signal %d\n&quot;</span>, sig);<br>&#125;<br><br><span class="hljs-comment">/* 线程 1 的入口函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">thread1_entry</span><span class="hljs-params">(<span class="hljs-type">void</span> *parameter)</span><br>&#123;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* 安装信号 */</span><br>    rt_signal_install(SIGUSR1, thread1_signal_handler);<br>    rt_signal_unmask(SIGUSR1);<br><br>    <span class="hljs-comment">/* 运行 10 次 */</span><br>    <span class="hljs-keyword">while</span> (cnt &lt; <span class="hljs-number">10</span>)<br>    &#123;<br>        <span class="hljs-comment">/* 线程 1 采用低优先级运行，一直打印计数值 */</span><br>        rt_kprintf(<span class="hljs-string">&quot;thread1 count : %d\n&quot;</span>, cnt);<br><br>        cnt++;<br>        rt_thread_mdelay(<span class="hljs-number">100</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* 信号示例的初始化 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">signal_sample</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/* 创建线程 1 */</span><br>    tid1 = rt_thread_create(<span class="hljs-string">&quot;thread1&quot;</span>,<br>                            thread1_entry, RT_NULL,<br>                            THREAD_STACK_SIZE,<br>                            THREAD_PRIORITY, THREAD_TIMESLICE);<br><br>    <span class="hljs-keyword">if</span> (tid1 != RT_NULL)<br>        rt_thread_startup(tid1);<br><br>    rt_thread_mdelay(<span class="hljs-number">300</span>);<br><br>    <span class="hljs-comment">/* 发送信号 SIGUSR1 给线程 1 */</span><br>    rt_thread_kill(tid1, SIGUSR1);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 导出到 msh 命令列表中 */</span><br>MSH_CMD_EXPORT(signal_sample, signal sample);<br></code></pre></td></tr></table></figure><p>仿真运行结果如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"> <span class="hljs-string">\</span> <span class="hljs-string">|</span> <span class="hljs-string">/</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">RT</span> <span class="hljs-bullet">-</span>     <span class="hljs-string">Thread</span> <span class="hljs-string">Operating</span> <span class="hljs-string">System</span><br> <span class="hljs-string">/</span> <span class="hljs-string">|</span> <span class="hljs-string">\</span>     <span class="hljs-number">3.1</span><span class="hljs-number">.0</span> <span class="hljs-string">build</span> <span class="hljs-string">Aug</span> <span class="hljs-number">24</span> <span class="hljs-number">2018</span><br> <span class="hljs-number">2006</span> <span class="hljs-bullet">-</span> <span class="hljs-number">2018 </span><span class="hljs-string">Copyright</span> <span class="hljs-string">by</span> <span class="hljs-string">rt-thread</span> <span class="hljs-string">team</span><br><span class="hljs-string">msh</span> <span class="hljs-string">&gt;signal_sample</span><br><span class="hljs-attr">thread1 count :</span> <span class="hljs-number">0</span><br><span class="hljs-attr">thread1 count :</span> <span class="hljs-number">1</span><br><span class="hljs-attr">thread1 count :</span> <span class="hljs-number">2</span><br><span class="hljs-string">msh</span> <span class="hljs-string">&gt;thread1</span> <span class="hljs-string">received</span> <span class="hljs-string">signal</span> <span class="hljs-number">10</span><br><span class="hljs-attr">thread1 count :</span> <span class="hljs-number">3</span><br><span class="hljs-attr">thread1 count :</span> <span class="hljs-number">4</span><br><span class="hljs-attr">thread1 count :</span> <span class="hljs-number">5</span><br><span class="hljs-attr">thread1 count :</span> <span class="hljs-number">6</span><br><span class="hljs-attr">thread1 count :</span> <span class="hljs-number">7</span><br><span class="hljs-attr">thread1 count :</span> <span class="hljs-number">8</span><br><span class="hljs-attr">thread1 count :</span> <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><h2 id="笔记-3"><a href="#笔记-3" class="headerlink" title="笔记"></a>笔记</h2><p>Mailbox:开销较小，4字节内容，</p><p>Message Queue:长度不固定、需要进行内存分配、</p><p>Signal:软件中断</p><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>RT-Thread 操作系统在内存管理上，根据上层应用及系统资源的不同，有针对性地提供了不同的内存分配管理算法。总体上可分为两类：内存堆管理与内存池管理，而内存堆管理又根据具体内存设备划分为三种情况：</p><ul><li><p>第一种是针对小内存块的分配管理（小内存管理算法）；</p></li><li><p>第二种是针对大内存块的分配管理（slab 管理算法）；</p></li><li><p>第三种是针对多内存堆的分配情况（memheap 管理算法）</p></li></ul><h2 id="内存堆Heap"><a href="#内存堆Heap" class="headerlink" title="内存堆Heap"></a>内存堆Heap</h2><p>RT-Thread 将 “ZI 段结尾处” 到内存尾部的空间用作内存堆。</p><p><img src="/2021/42e53028/08Memory_distribution.png" alt="RT-Thread 内存分布"></p><p>内存堆可以在当前资源满足的情况下，根据用户的需求分配任意大小的内存块。而当用户不需要再使用这些内存块时，又可以释放回堆中供其他应用分配使用。RT-Thread 系统为了满足不同的需求，提供了不同的内存管理算法，分别是<strong>小内存管理算法</strong>、<strong>Slab</strong> 管理算法和 <strong>memheap 管理算法</strong>。</p><p><strong>小内存管理算法</strong>主要针对系统资源比较少，一般用于小于 2MB 内存空间的系统；</p><p><strong>slab 内存管理算法</strong>则主要是在系统资源比较丰富时，提供了一种近似多内存池管理算法的快速算法。</p><p> <strong>memheap 管理算法</strong>。memheap 方法适用于系统存在多个内存堆的情况，它可以将多个内存 “粘贴” 在一起，形成一个大的内存堆，用户使用起来会非常方便。</p><h3 id="小内存管理算法"><a href="#小内存管理算法" class="headerlink" title="小内存管理算法"></a>小内存管理算法</h3><p><img src="/2021/42e53028/08smem_work.png" alt="小内存管理工作机制图"></p><p>每个内存块（不管是已分配的内存块还是空闲的内存块）都包含一个数据头，其中包括：</p><p><strong>1）magic</strong>：变数（或称为幻数），它会被初始化成 0x1ea0（即英文单词 heap），用于标记这个内存块是一个内存管理用的内存数据块；变数不仅仅用于标识这个数据块是一个内存管理用的内存数据块，实质也是一个内存保护字：如果这个区域被改写，那么也就意味着这块内存块被非法改写（正常情况下只有内存管理器才会去碰这块内存）。</p><p><strong>2）used</strong>：指示出当前内存块是否已经分配。</p><p><strong>内存管理的表现主要体现在内存的分配与释放上，小型内存管理算法可以用以下例子体现出来。</strong></p><p><strong>如下图所示的内存分配情况，空闲链表指针 lfree 初始指向 32 字节的内存块。当用户线程要再分配一个 64 字节的内存块时，但此 lfree 指针指向的内存块只有 32 字节并不能满足要求，内存管理器会继续寻找下一内存块，当找到再下一块内存块，128 字节时，它满足分配的要求。因为这个内存块比较大，分配器将把此内存块进行拆分，余下的内存块（52 字节）继续留在 lfree 链表中，如下图分配 64 字节后的链表结构所示。</strong></p><p><img src="/2021/42e53028/08smem_work3.png" alt="小内存管理算法链表结构示意图 2"></p><p>另外，在每次分配内存块前，都会留出 12 字节数据头用于 magic、used 信息及链表节点使用。返回给应用的地址实际上是这块内存块 12 字节以后的地址，前面的 12 字节数据头是用户永远不应该碰的部分（注：12 字节数据头长度会与系统对齐差异而有所不同）。</p><p>释放时则是相反的过程，但分配器会查看前后相邻的内存块是否空闲，如果空闲则合并成一个大的空闲内存块。</p><h3 id="Slab管理算法"><a href="#Slab管理算法" class="headerlink" title="Slab管理算法"></a>Slab管理算法</h3><p>slab 分配器会根据对象的大小分成多个区（zone），也可以看成每类对象有一个内存池，如下图所示：</p><p><img src="/2021/42e53028/08slab.png" alt="slab 内存分配结构图"></p><p>一个 zone 的大小在 32K 到 128K 字节之间，分配器会在堆初始化时根据堆的大小自动调整。系统中的 zone 最多包括 72 种对象，一次最大能够分配 16K 的内存空间，如果超出了 16K 那么直接从页分配器中分配。每个 zone 上分配的内存块大小是固定的，能够分配相同大小内存块的 zone 会链接在一个链表中，而 72 种对象的 zone 链表则放在一个数组（zone_array[]）中统一管理。</p><p><strong>（1）内存分配</strong></p><p>假设分配一个 32 字节的内存，slab 内存分配器会先按照 32 字节的值，从 zone array 链表表头数组中找到相应的 zone 链表。如果这个链表是空的，则向页分配器分配一个新的 zone，然后从 zone 中返回第一个空闲内存块。如果链表非空，则这个 zone 链表中的第一个 zone 节点必然有空闲块存在（否则它就不应该放在这个链表中），那么就取相应的空闲块。如果分配完成后，zone 中所有空闲内存块都使用完毕，那么分配器需要把这个 zone 节点从链表中删除。</p><p><strong>（2）内存释放</strong></p><p>分配器需要找到内存块所在的 zone 节点，然后把内存块链接到 zone 的空闲内存块链表中。如果此时 zone 的空闲链表指示出 zone 的所有内存块都已经释放，即 zone 是完全空闲的，那么当 zone 链表中全空闲 zone 达到一定数目后，系统就会把这个全空闲的 zone 释放到页面分配器中去。</p><h3 id="Memheap管理算法"><a href="#Memheap管理算法" class="headerlink" title="Memheap管理算法"></a>Memheap管理算法</h3><p> memheap 功能就可以很方便地把多个 memheap（地址可不连续）粘合起来用于系统的 heap 分配。</p><p>memheap 工作机制如下图所示，首先将多块内存加入 memheap_item 链表进行粘合。当分配内存块时，会先从默认内存堆去分配内存，当分配不到时会查找 memheap_item 链表，尝试从其他的内存堆上分配内存块。应用程序不用关心当前分配的内存块位于哪个内存堆上，就像是在操作一个内存堆。</p><p><img src="/2021/42e53028/08memheap.png" alt="memheap 处理多内存堆"></p><h2 id="内存池Pool"><a href="#内存池Pool" class="headerlink" title="内存池Pool"></a>内存池Pool</h2><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>创建&#x2F;初始化</td><td>rt_mp_create()&#x2F;rt_mp_init()</td></tr><tr><td>分配内存块</td><td>rt_mp_alloc()</td></tr><tr><td>释放内存块</td><td>rt_mp_free()</td></tr><tr><td>删除&#x2F;脱离</td><td>rt_mp_delete()&#x2F;rt_mp_detach()</td></tr></tbody></table><h3 id="创建-x2F-删除-create"><a href="#创建-x2F-删除-create" class="headerlink" title="创建&#x2F;删除-create"></a>创建&#x2F;删除-create</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_mp_t</span> <span class="hljs-title function_">rt_mp_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name,</span><br><span class="hljs-params">                         <span class="hljs-type">rt_size_t</span> block_count,</span><br><span class="hljs-params">                         <span class="hljs-type">rt_size_t</span> block_size)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>name</td><td>内存池名</td></tr><tr><td>block_count</td><td>内存块数量</td></tr><tr><td>block_size</td><td>内存块容量</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>内存池的句柄</td><td>创建内存池对象成功</td></tr><tr><td>RT_NULL</td><td>创建失败</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mp_delete</span><span class="hljs-params">(<span class="hljs-type">rt_mp_t</span> mp)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mp</td><td>rt_mp_create 返回的内存池对象句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>删除成功</td></tr></tbody></table><h3 id="初始化-x2F-剥离-init"><a href="#初始化-x2F-剥离-init" class="headerlink" title="初始化&#x2F;剥离-init"></a>初始化&#x2F;剥离-init</h3><p>内存池块个数 &#x3D; size &#x2F; (block_size + 4 链表指针大小)，计算结果取整数。</p><p>例如：内存池数据区总大小 size 设为 4096 字节，内存块大小 block_size 设为 80 字节；则申请的内存块个数为 4096&#x2F; (80+4)&#x3D; 48 个。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mp_init</span><span class="hljs-params">(<span class="hljs-type">rt_mp_t</span> mp,</span><br><span class="hljs-params">                        <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name,</span><br><span class="hljs-params">                        <span class="hljs-type">void</span> *start, <span class="hljs-type">rt_size_t</span> size,</span><br><span class="hljs-params">                        <span class="hljs-type">rt_size_t</span> block size)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mp</td><td>内存池对象</td></tr><tr><td>name</td><td>内存池名</td></tr><tr><td>start</td><td>内存池的起始位置</td></tr><tr><td>size</td><td>内存池数据区域大小</td></tr><tr><td>block_size</td><td>内存块容量</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>初始化成功</td></tr><tr><td>- RT_ERROR</td><td>失败</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mp_detach</span><span class="hljs-params">(<span class="hljs-type">rt_mp_t</span> mp)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mp</td><td>内存池对象</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr></tbody></table><h3 id="分配-alloc"><a href="#分配-alloc" class="headerlink" title="分配-alloc"></a>分配-alloc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">rt_mp_alloc</span> <span class="hljs-params">(<span class="hljs-type">rt_mp_t</span> mp, <span class="hljs-type">rt_int32_t</span> time)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mp</td><td>内存池对象</td></tr><tr><td>time</td><td>超时时间</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>分配的内存块地址</td><td>成功</td></tr><tr><td>RT_NULL</td><td>失败</td></tr></tbody></table><h3 id="释放-free"><a href="#释放-free" class="headerlink" title="释放-free"></a>释放-free</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">rt_mp_free</span> <span class="hljs-params">(<span class="hljs-type">void</span> *block)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>block</td><td>内存块指针</td></tr></tbody></table><h2 id="笔记-4"><a href="#笔记-4" class="headerlink" title="笔记"></a>笔记</h2><ul><li>因为内存堆管理器要满足多线程情况下的安全分配，会考虑多线程间的互斥问题，所以请不要在中断服务例程中分配或释放动态内存块。因为它可能会引起当前上下文被挂起等待。</li></ul><h1 id="RT-Thread的中断管理"><a href="#RT-Thread的中断管理" class="headerlink" title="RT-Thread的中断管理"></a>RT-Thread的中断管理</h1><h2 id="中断工作机制"><a href="#中断工作机制" class="headerlink" title="中断工作机制"></a>中断工作机制</h2><h3 id="中断处理过程"><a href="#中断处理过程" class="headerlink" title="中断处理过程"></a>中断处理过程</h3><p>RT-Thread 中断管理中，将中断处理程序分为中断前导程序、用户中断服务程序、中断后续程序三部分<br><img src="/2021/42e53028/09interrupt_work_process.png" alt="中断处理程序的 3 部分"></p><h4 id="中断前导"><a href="#中断前导" class="headerlink" title="中断前导"></a>中断前导</h4><ol><li><p>保存 CPU 中断现场，这部分跟 CPU 架构相关，不同 CPU 架构的实现方式有差异。</p><p>对于 Cortex-M 来说，该工作由硬件自动完成。当一个中断触发并且系统进行响应时，处理器硬件会将当前运行部分的上下文寄存器自动压入中断栈中，这部分的寄存器包括 PSR、PC、LR、R12、R3-R0 寄存器。</p></li><li><p>通知内核进入中断状态，调用 rt_interrupt_enter() 函数，作用是把全局变量 rt_interrupt_nest 加 1，用它来记录中断嵌套的层数，代码如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">rt_interrupt_enter</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">rt_base_t</span> level;<br><br>    level = rt_hw_interrupt_disable();<br>    rt_interrupt_nest ++;<br>    rt_hw_interrupt_enable(level);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h4><ol><li><p>中断完后<strong>不进行</strong>线程切换，这种情况下用户中断服务程序和中断后续程序运行完毕后退出中断模式，返回被中断的线程。</p></li><li><p>中断完后<strong>进行</strong>线程切换，这种情况会调用 rt_hw_context_switch_interrupt() 函数进行上下文切换，该函数跟 CPU 架构相关，不同 CPU 架构的实现方式有差异。</p><p>rt_hw_context_switch_interrupt() 函数会触发PendSV异常，PendSV 异常被触发后，不会立即进行 PendSV 异常中断处理程序，因为此时还在中断处理中，只有当中断后续程序运行完毕，真正退出中断处理后，才进入 PendSV 异常中断处理程序。</p></li></ol><h4 id="中断后续"><a href="#中断后续" class="headerlink" title="中断后续"></a>中断后续</h4><ol><li><p>通知内核离开中断状态，通过调用 rt_interrupt_leave() 函数，将全局变量 rt_interrupt_nest 减 1，代码如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">rt_interrupt_leave</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">rt_base_t</span> level;<br><br>    level = rt_hw_interrupt_disable();<br>    rt_interrupt_nest --;<br>    rt_hw_interrupt_enable(level);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>恢复中断前的 CPU 上下文，中断过程<strong>发生了线程切换</strong>和<strong>没发生线程切换</strong>的CPU上下文是不一样的。</p></li></ol><h3 id="中断嵌套"><a href="#中断嵌套" class="headerlink" title="中断嵌套"></a>中断嵌套</h3><p>如果需要进行线程调度，线程的上下文切换将在所有中断处理程序都运行结束时才发生，如下图所示。</p><p><img src="/2021/42e53028/09ths_switch.png" alt="中断中的线程切换"></p><h3 id="中断栈"><a href="#中断栈" class="headerlink" title="中断栈"></a>中断栈</h3><ol><li>中断栈可以保存在打断线程的栈中，当从中断中退出时，返回相应的线程继续执行。</li><li>中断栈也可以与线程栈完全分离开来，即每次进入中断时，在保存完打断线程上下文后，切换到新的中断栈中独立运行。在中断退出时，再做相应的上下文恢复。</li></ol><p>使用独立中断栈相对来说更容易实现，并且对于线程栈使用情况也比较容易了解和掌握（否则必须要为中断栈预留空间，如果系统支持中断嵌套，还需要考虑应该为嵌套中断预留多大的空间）。</p><h3 id="中断的底半处理"><a href="#中断的底半处理" class="headerlink" title="中断的底半处理"></a>中断的底半处理</h3><p>发生中断后，中断一般读取硬件状态或者数据，然后发送一个通知（信号量、事件、邮箱、消息队列等），接下来的相关线程收到通知对着数据进行进一步处理，这个处理的过程就叫<strong>底半处理</strong>。</p><blockquote><p>当一个中断发生时，中断服务程序需要取得相应的硬件状态或者数据。如果中断服务程序接下来要对状态或者数据进行简单处理，比如 CPU 时钟中断，中断服务程序只需对一个系统时钟变量进行加一操作，然后就结束中断服务程序。这类中断需要的运行时间往往都比较短。但对于另外一些中断，中断服务程序在取得硬件状态或数据以后，还需要进行一系列更耗时的处理过程，通常需要将该中断分割为两部分，即<strong>上半部分</strong>（Top Half）和<strong>底半部分</strong>（Bottom Half）。在上半部分中，取得硬件状态和数据后，打开被屏蔽的中断，给相关线程发送一条通知（可以是 RT-Thread 所提供的信号量、事件、邮箱或消息队列等方式），然后结束中断服务程序；而接下来，相关的线程在接收到通知后，接着对状态或数据进行进一步的处理，这一过程称之为<strong>底半处理</strong>。</p></blockquote><h2 id="中断管理API"><a href="#中断管理API" class="headerlink" title="中断管理API"></a>中断管理API</h2><p><img src="/2021/42e53028/09interrupt_ops.png" alt="中断相关接口"></p><p><strong>请注意！！！装载中断服务例程、中断源管理——的API 并不会出现在每一个移植分支中，例如通常 Cortex-M0&#x2F;M3&#x2F;M4 的移植分支中就没有这些 API。</strong></p><h3 id="装载中断服务例程"><a href="#装载中断服务例程" class="headerlink" title="装载中断服务例程"></a>装载中断服务例程</h3><p>系统把用户的中断服务程序 (handler) 和指定的中断号关联起来，可调用如下的接口挂载一个新的中断服务程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_isr_handler_t</span> <span class="hljs-title function_">rt_hw_interrupt_install</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-built_in">vector</span>,</span><br><span class="hljs-params">                                        <span class="hljs-type">rt_isr_handler_t</span>  handler,</span><br><span class="hljs-params">                                        <span class="hljs-type">void</span> *param,</span><br><span class="hljs-params">                                        <span class="hljs-type">char</span> *name)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>vector</td><td>vector 是挂载的中断号</td></tr><tr><td>handler</td><td>新挂载的中断服务程序</td></tr><tr><td>param</td><td>param 会作为参数传递给中断服务程序</td></tr><tr><td>name</td><td>中断的名称</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>return</td><td>挂载这个中断服务程序之前挂载的中断服务程序的句柄</td></tr></tbody></table><h3 id="中断源管理"><a href="#中断源管理" class="headerlink" title="中断源管理"></a>中断源管理</h3><ol><li>屏蔽中断源</li></ol><p>通常在 ISR 准备处理某个中断信号之前，我们需要先屏蔽该中断源，在 ISR 处理完状态或数据以后，及时的打开之前被屏蔽的中断源。</p><p>屏蔽中断源可以保证在接下来的处理过程中硬件状态或者数据不会受到干扰，可调用下面这个函数接口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">rt_hw_interrupt_mask</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-built_in">vector</span>)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>vector</td><td>要屏蔽的中断号</td></tr></tbody></table><ol start="2"><li>打开被屏蔽的中断源</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">rt_hw_interrupt_umask</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-built_in">vector</span>)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>vector</td><td>要打开屏蔽的中断号</td></tr></tbody></table><h3 id="全局中断开关"><a href="#全局中断开关" class="headerlink" title="全局中断开关"></a>全局中断开关</h3><p><strong>全局中断开关也称为</strong>中断锁，是禁止多线程访问临界区最简单的一种方式，即通过关闭中断的方式，来保证当前线程不会被其他事件打断（因为整个系统已经不再响应那些可以触发线程重新调度的外部事件），也就是当前线程不会被抢占，除非这个线程主动放弃了处理器控制权。</p><ol><li>失能全局中断</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_base_t</span> <span class="hljs-title function_">rt_hw_interrupt_disable</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>返回</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>中断状态</td><td>rt_hw_interrupt_disable 函数运行前的中断状态</td></tr><tr><td>2. 使能全局中断</td><td></td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">rt_hw_interrupt_enable</span><span class="hljs-params">(<span class="hljs-type">rt_base_t</span> level)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>level</td><td>前一次 rt_hw_interrupt_disable 返回的中断状态</td></tr></tbody></table><h3 id="中断通知"><a href="#中断通知" class="headerlink" title="中断通知"></a>中断通知</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">rt_interrupt_enter</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">rt_interrupt_leave</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><p>这两个接口分别用在中断前导程序和中断后续程序中，均会对 rt_interrupt_nest（中断嵌套深度）的值进行修改。</p><p>使用 rt_interrupt_enter&#x2F;leave() 的作用是，在中断中释放了一个信号量，唤醒了某线程，但通过判断发现当前系统处于中断上下文环境中，那么在进行线程切换时应该采取中断中线程切换的策略（等中断结束再切换），而不是立即进行切换（正常情况下立即进行切换）。</p><p><del>（不建议）但如果中断服务程序不会调用内核相关的函数（释放信号量等操作），这个时候，也可以不调用 rt_interrupt_enter&#x2F;leave() 函数。</del></p><p>在上层应用中，在内核需要知道当前已经进入到中断状态或当前<strong>嵌套的中断深度</strong>时，可调用 rt_interrupt_get_nest() 接口，它会返回 rt_interrupt_nest。如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_uint8_t</span> <span class="hljs-title function_">rt_interrupt_get_nest</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>返回</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>0</td><td>当前系统不处于中断上下文环境中</td></tr><tr><td>1</td><td>当前系统处于中断上下文环境中</td></tr><tr><td>大于 1</td><td>当前中断嵌套层次</td></tr></tbody></table><h2 id="中断与轮询"><a href="#中断与轮询" class="headerlink" title="中断与轮询"></a>中断与轮询</h2><p>当驱动外设工作时，其编程模式到底采用中断模式触发还是轮询模式触发往往是驱动开发人员首先要考虑的问题，并且这个问题在实时操作系统与分时操作系统中差异还非常大。</p><p>在实时系统中轮询模式可能会出现非常大问题，因为在实时操作系统中，当一个程序持续地执行时（轮询时），它所在的线程会一直运行，比它优先级低的线程都不会得到运行。而分时系统中，这点恰恰相反，几乎没有优先级之分，可以在一个时间片运行这个程序，然后在另外一段时间片上运行另外一段程序。</p><p>所以通常情况下，实时系统中更多采用的是中断模式来驱动外设。当数据达到时，由中断唤醒相关的处理线程，再继续进行后续的动作。例如一些携带 FIFO（包含一定数据量的先进先出队列）的串口外设，其写入过程可以是这样的，如下图所示：</p><p><img src="/2021/42e53028/09interrupt_reque.png" alt="中断模式驱动外设"></p><p><strong>对于低速设备来说，运用这种模式非常好，而对于高速设备，数据量又小的情况下，线程的切换时间（几个us）会很明显的影响数据吞吐量和带宽利用率。</strong></p><blockquote><p>发送数据量越小，发送速度越快，对于数据吞吐量的影响也将越大。归根结底，取决于系统中产生中断的频度如何。当一个实时系统想要提升数据吞吐量时，可以考虑的几种方式：</p><p>1）增加每次数据量发送的长度，每次尽量让外设尽量多地发送数据；</p><p>2）必要情况下更改中断模式为轮询模式。同时为了解决轮询方式一直抢占处理机，其他低优先级线程得不到运行的情况，可以把轮询线程的优先级适当降低。</p></blockquote><h1 id="内核移植"><a href="#内核移植" class="headerlink" title="内核移植"></a>内核移植</h1><p>参考官方文档</p><h2 id="CPU架构移植"><a href="#CPU架构移植" class="headerlink" title="CPU架构移植"></a>CPU架构移植</h2><h2 id="BSP移植"><a href="#BSP移植" class="headerlink" title="BSP移植"></a>BSP移植</h2>]]></content>
    
    
    <categories>
      
      <category>RTOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RTOS</tag>
      
      <tag>RT-Thread</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LinuxAlphaMini</title>
    <link href="/2021/9b4105ad/"/>
    <url>/2021/9b4105ad/</url>
    
    <content type="html"><![CDATA[<h1 id="汇编基础"><a href="#汇编基础" class="headerlink" title="汇编基础"></a>汇编基础</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">label</span>： instruction @ comment <br></code></pre></td></tr></table></figure><p><strong>label 即标号</strong>，表示地址位置，有些指令前面可能会有标号，这样就可以通过这个标号得到指令的地址，标号也可以用来表示数据地址。注意 label 后面的“：”，任何以“：”结尾的标识符都会被识别为一个标号。<br><strong>instruction 即指令</strong>，也就是汇编指令或伪指令。<br><strong>@符号</strong>，表示后面的是注释<br><strong>comment</strong> 就是注释内容。</p><p>例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">add:<br>MOVS R0, #0X12 @设置 R0=0X12<br></code></pre></td></tr></table></figure><p><strong>注意！ ARM 中的指令、伪指令、伪操作、寄存器名等可以全部使用大写，也可以全部使用小写，但是不能大小写混用。</strong>  </p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">.section</span> <span class="hljs-string">.testsection</span> @定义一个 testsetcion 段 <br></code></pre></td></tr></table></figure><ul><li>.text 表示代码段。  </li><li>.data 初始化的数据段。</li><li>.bss 未初始化的数据段。</li><li>.rodata 只读数据段。</li></ul><p><strong>伪操作:</strong></p><ul><li>.byte 定义单字节数据，比如.byte 0x12。</li><li>.short 定义双字节数据，比如.short 0x1234。</li><li>.long 定义一个 4 字节数据，比如.long 0x12345678。</li><li>.equ 赋值语句，格式为： .equ 变量名，表达式，比如.equ num, 0x12，表示 num&#x3D;0x12。</li><li>.align 数据字节对齐，比如： .align 4 表示 4 字节对齐。</li><li>.end 表示源文件结束。</li><li>.global 定义一个全局符号，格式为： .global symbol，比如： .global _start(汇编程序的默认入口标号是_start  )。</li></ul><p><strong>函数:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">函数名:</span><br>函数体<br>返回语句<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">/* SVC 中断 */<br>SVC_Handler:<br>    ldr r0, =SVC_Handler<br>    bx r0@跳转<br></code></pre></td></tr></table></figure><h2 id="常用汇编指令"><a href="#常用汇编指令" class="headerlink" title="常用汇编指令"></a>常用汇编指令</h2><h3 id="处理器内部数据传输指令-mov-mrs-msr"><a href="#处理器内部数据传输指令-mov-mrs-msr" class="headerlink" title="处理器内部数据传输指令 mov mrs msr"></a>处理器内部数据传输指令 mov mrs msr</h3><table><thead><tr><th>指令</th><th>目的</th><th>源</th><th></th></tr></thead><tbody><tr><td>MOV</td><td>R0</td><td>R1</td><td>将 R1 里面的数据复制到 R0 中。</td></tr><tr><td>MRS</td><td>R0</td><td>CPSR</td><td>将特殊寄存器 CPSR 里面的数据复制到 R0 中。<br/><strong>(特殊寄存器只能由这个指令 读 )</strong></td></tr><tr><td>MSR</td><td>CPSR</td><td>R1</td><td>将 R1 里面的数据复制到特殊寄存器 CPSR 里中。<br/><strong>(特殊寄存器只能由这个指令 写 )</strong></td></tr></tbody></table><h3 id="存储器访问指令-ldr-str"><a href="#存储器访问指令-ldr-str" class="headerlink" title="存储器访问指令 ldr str"></a>存储器访问指令 ldr str</h3><p>I.MX6UL中的RAM,寄存器都需要这个指令访问。</p><p>LDR和STR是按照字进行读取和写入的，LDRB和STRB是按字节，LDRH和STRH是按半字操作。</p><table><thead><tr><th>指令</th><th></th></tr></thead><tbody><tr><td>LDR Rd, [Rn , #offset]</td><td>从存储器 Rn+offset 的位置读取数据存放到 Rd 中。</td></tr><tr><td>STR Rd, [Rn, #offset]</td><td>将 Rd 中的数据写入到存储器中的 Rn+offset 位置。</td></tr></tbody></table><h4 id="LDR"><a href="#LDR" class="headerlink" title="LDR"></a>LDR</h4><ul><li><p>读取寄存器值</p></li><li><p>加载立即数到寄存器</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">@加载立即数<br>LDR R0, =0X0209C004 @将寄存器地址 0X0209C004 加载到 R0 中，即 R0=0X0209C004<br>@读取寄存器值<br>LDR R1, [R0] @读取地址 0X0209C004 中的数据到 R1 寄存器中<br></code></pre></td></tr></table></figure><h4 id="STR"><a href="#STR" class="headerlink" title="STR"></a>STR</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">LDR R0, =0X0209C004 @将寄存器地址 0X0209C004 加载到 R0 中，即 R0=0X0209C004<br>LDR R1, =0X12345678 @R1 保存要写入到寄存器的值，即 R1=0X12345678<br>STR R1, [R0] @将 R1 中的值写入到 R0 中的地址上<br></code></pre></td></tr></table></figure><h3 id="压栈出栈指令-push-pop"><a href="#压栈出栈指令-push-pop" class="headerlink" title="压栈出栈指令 push pop"></a>压栈出栈指令 push pop</h3><table><thead><tr><th>指令</th><th></th></tr></thead><tbody><tr><td>PUSH &lt;reg list&gt;</td><td>将寄存器列表存入栈中。</td></tr><tr><td>POP &lt;reg list&gt;</td><td>从栈中恢复寄存器列表。</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asm">@处理器的堆栈是向下增长的 见下图<br>PUSH &#123;R0~R3, R12&#125; @将 R0~R3 和 R12 压栈<br>PUSH &#123;LR&#125; @将 LR 进行压栈<br><br>POP &#123;LR&#125; @先恢复 LR<br>POP &#123;R0~R3,R12&#125; @在恢复 R0~R3,R12<br></code></pre></td></tr></table></figure><p><img src="/2021/9b4105ad/image-20210707144653945.png" alt="image-20210707144653945"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs asm">@这个和上面的是等同的<br>STMFD SP!,&#123;R0~R3, R12&#125; @R0~R3,R12 入栈<br>STMFD SP!,&#123;LR&#125; @LR 入栈<br><br>LDMFD SP!, &#123;LR&#125; @先恢复 LR<br>LDMFD SP!, &#123;R0~R3, R12&#125; @再恢复 R0~R3, R12<br><br><br>LDMFD = LDM + FD<br>STMFD = STM + FD<br>LDM(多个) -&gt; LDR(单个)<br>STM(多个) -&gt; STR(单个)<br>FD = Full Descending 即满递减的意思(根据 ATPCS 规则,ARM 使用的 FD 类型的堆栈， SP 指向最后一个入栈的数值，堆栈是由高地址向下增长的，也就是前面说的向下增长的堆栈，)<br></code></pre></td></tr></table></figure><h3 id="跳转指令-b-bx-bl-blx"><a href="#跳转指令-b-bx-bl-blx" class="headerlink" title="跳转指令 b bx bl blx"></a>跳转指令 b bx bl blx</h3><p>跳转操作的方法  </p><ol><li>直接使用跳转指令 B、 BL、 BX 等</li><li>直接向 PC 寄存器里面写入数据。</li></ol><table><thead><tr><th>指令</th><th></th></tr></thead><tbody><tr><td>B &lt;label&gt;</td><td>跳转到 label，如果跳转范围超过了+&#x2F;-2KB，<br/>可以指定 B.W &lt;label&gt;使用 32 位版本的跳转指令， 这样可以得到较大范围的 跳转</td></tr><tr><td>BX &lt;Rm&gt;</td><td>间接跳转，跳转到存放于 Rm 中的地址处，并且切换指令集</td></tr><tr><td>BL &lt;label&gt;</td><td>跳转到标号地址，并将返回地址保存在 LR 中。</td></tr><tr><td>BLX &lt;Rm&gt;</td><td>结合 BX 和 BL 的特点，跳转到 Rm 指定的地址，并将返回地 址保存在 LR 中，切换指令集。</td></tr></tbody></table><h4 id="B指令"><a href="#B指令" class="headerlink" title="B指令"></a>B指令</h4><p>这是最简单的跳转指令， B 指令会将 PC 寄存器的值设置为跳转目标地址， 一旦执行 B 指令， ARM 处理器就会立即跳转到指定的目标地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">_start:<br>    ldr sp,=0X80200000 @设置栈指针<br>    b main @跳转到 main 函数<br></code></pre></td></tr></table></figure><p>上述代码就是典型的在汇编中初始化 C 运行环境，然后跳转到 C 文件的 main 函数中运行 ，上述代码只是初始化了 SP 指针，有些处理器还需要做其他的初始化，比如初始化 DDR 等等。因为跳转到 C 文件以后再也不会回到汇编了，所以在第 4 行使用了 B 指令来完成跳转  。</p><h4 id="BL指令"><a href="#BL指令" class="headerlink" title="BL指令"></a>BL指令</h4><p>BL 指令相比 B 指令，在跳转之前会在寄存器 LR(R14)中保存当前 PC 寄存器值，所以可以通过将 LR 寄存器中的值重新加载到 PC 中来继续从跳转之前的代码处运行，这是子程序调用一个基本但常用的手段。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asm">push &#123;r0, r1&#125; @保存 r0,r1<br>cps #0x13 @进入 SVC 模式，允许其他中断再次进去<br><br>bl system_irqhandler@加载 C 语言中断处理函数到 r2 寄存器中<br><br>cps #0x12 @进入 IRQ 模式<br>pop &#123;r0, r1&#125;<br>str r0, [r1, #0X10] @中断执行完成，写 EOIR<br></code></pre></td></tr></table></figure><p>上述代码中第 5 行就是执行 C 语言版的中断处理函数，当处理完成以后是需要返回来继续执行下面的程序，所以使用了 BL 指令。  </p><h3 id="算术运算指令"><a href="#算术运算指令" class="headerlink" title="算术运算指令"></a>算术运算指令</h3><p>汇编中也可以进行算术运算， 比如加减乘除，常用的运算指令用法如表 7.2.5.1 所示：</p><table><thead><tr><th>指令</th><th>计算公式</th><th></th></tr></thead><tbody><tr><td>ADD Rd, Rn, Rm</td><td>Rd &#x3D; Rn + Rm</td><td>加法运算，指令为 ADD</td></tr><tr><td>ADD Rd, Rn, #immed</td><td>Rd &#x3D; Rn + #immed</td><td>加法运算，指令为 ADD</td></tr><tr><td>ADC Rd, Rn, Rm</td><td>Rd &#x3D; Rn + Rm + 进位</td><td>带进位的加法运算，指令为 ADC</td></tr><tr><td>ADC Rd, Rn, #immed</td><td>Rd &#x3D; Rn + #immed +进位</td><td>带进位的加法运算，指令为 ADC</td></tr><tr><td>SUB Rd, Rn, Rm</td><td>Rd &#x3D; Rn – Rm</td><td>减法</td></tr><tr><td>SUB Rd, #immed</td><td>Rd &#x3D; Rd - #immed</td><td>减法</td></tr><tr><td>SUB Rd, Rn, #immed</td><td>Rd &#x3D; Rn - #immed</td><td>减法</td></tr><tr><td>SBC Rd, Rn, #immed</td><td>Rd &#x3D; Rn - #immed – 借位</td><td>带借位的减法</td></tr><tr><td>SBC Rd, Rn ,Rm</td><td>Rd &#x3D; Rn – Rm – 借位</td><td>带借位的减法</td></tr><tr><td>MUL Rd, Rn, Rm</td><td>Rd &#x3D; Rn * Rm</td><td>乘法(32 位)</td></tr><tr><td>UDIV Rd, Rn, Rm</td><td>Rd &#x3D; Rn &#x2F; Rm</td><td>无符号除法</td></tr><tr><td>SDIV Rd, Rn, Rm</td><td>Rd &#x3D; Rn &#x2F; Rm</td><td>有符号除法</td></tr></tbody></table><h3 id="逻辑运算指令"><a href="#逻辑运算指令" class="headerlink" title="逻辑运算指令"></a>逻辑运算指令</h3><table><thead><tr><th>指令</th><th>计算公式</th><th></th></tr></thead><tbody><tr><td>AND Rd, Rn</td><td>Rd &#x3D; Rd &amp;Rn</td><td>按位与</td></tr><tr><td>AND Rd, Rn, #immed</td><td>Rd &#x3D; Rn &amp;#immed</td><td>按位与</td></tr><tr><td>AND Rd, Rn, Rm</td><td>Rd &#x3D; Rn &amp; Rm</td><td>按位与</td></tr><tr><td>ORR Rd, Rn</td><td>Rd &#x3D; Rd | Rn</td><td>按位或</td></tr><tr><td>ORR Rd, Rn, #immed</td><td>Rd &#x3D; Rn | #immed</td><td>按位或</td></tr><tr><td>ORR Rd, Rn, Rm</td><td>Rd &#x3D; Rn | Rm</td><td>按位或</td></tr><tr><td>BIC Rd, Rn</td><td>Rd &#x3D; Rd &amp; (~Rn)</td><td>位清除</td></tr><tr><td>BIC Rd, Rn, #immed</td><td>Rd &#x3D; Rn &amp; (~#immed)</td><td>位清除</td></tr><tr><td>BIC Rd, Rn , Rm</td><td>Rd &#x3D; Rn &amp; (~Rm)</td><td>位清除</td></tr><tr><td>ORN Rd, Rn, #immed</td><td>Rd &#x3D; Rn | (#immed)</td><td>按位或非</td></tr><tr><td>ORN Rd, Rn, Rm</td><td>Rd &#x3D; Rn | (Rm)</td><td>按位或非</td></tr><tr><td>EOR Rd, Rn</td><td>Rd &#x3D; Rd ^ Rn</td><td>按位异或</td></tr><tr><td>EOR Rd, Rn, #immed</td><td>Rd &#x3D; Rn ^ #immed</td><td>按位异或</td></tr><tr><td>EOR Rd, Rn, Rm</td><td>Rd &#x3D; Rn ^ Rm</td><td>按位异或</td></tr></tbody></table><h1 id="启动方式"><a href="#启动方式" class="headerlink" title="启动方式"></a>启动方式</h1><h2 id="BOOT"><a href="#BOOT" class="headerlink" title="BOOT"></a>BOOT</h2><p>OOT_MODE[1:0]的值是可以改变的，有两种方式，一种是改写 eFUSE(熔丝)，一种是修改相应的 GPIO 高低电平。  </p><ul><li>BOOT_MODE1 和 BOOT_MODE0 在芯片内部是有 100KΩ下拉电阻的 ，所以默认是0。</li></ul><table><thead><tr><th>BOOT_MODE[1:0]</th><th>BOOT 类型</th></tr></thead><tbody><tr><td>00</td><td>从 FUSE 启动</td></tr><tr><td>01</td><td>串行下载</td></tr><tr><td>10</td><td>内部 BOOT 模式</td></tr><tr><td>11</td><td>保留</td></tr></tbody></table><h3 id="串行下载"><a href="#串行下载" class="headerlink" title="串行下载"></a>串行下载</h3><p>串行下载的意思就是可以通过 USB 或者 UART 将代码下载到板子上的外置存储设备中，我们可以使用 OTG1 这个 USB口向开发板上的 SD&#x2F;EMMC、 NAND 等存储设备下载代码。  </p><h3 id="内部-BOOT-模式"><a href="#内部-BOOT-模式" class="headerlink" title="内部 BOOT 模式"></a>内部 BOOT 模式</h3><p>芯片会执行内部的 boot ROM 代码，代码会进行硬件初始化(一部分外设)，然后从 boot 设备(就是存放代码的设备、比如 SD&#x2F;EMMC、 NAND)中<strong>将代码拷贝出来复制到指定的 RAM 中，一般是 DDR。</strong>  </p><h2 id="BOOT模式-启动设备"><a href="#BOOT模式-启动设备" class="headerlink" title="BOOT模式 启动设备"></a>BOOT模式 启动设备</h2><p>当 BOOT_MODE 设置为内部 BOOT 模式以后，可以从以下设备中启动：<br>①、接到 EIM 接口的 CS0 上的 16 位 NOR Flash。<br>②、接到 EIM 接口的 CS0 上的 OneNAND Flash。<br>③、接到 GPMI 接口上的 MLC&#x2F;SLC NAND Flash， NAND Flash 页大小支持 2KByte、 4KByte和 8KByte， 8 位宽。<br>④、 Quad SPI Flash。<br>⑤、接到 USDHC 接口上的 SD&#x2F;MMC&#x2F;eSD&#x2F;SDXC&#x2F;eMMC 等设备。<br>⑥、 SPI 接口的 EEPROM。  </p><p>启动设备是通过  BOOT_CFG1[7:0]、 BOOT_CFG2[7:0]和 BOOT_CFG4[7:0]这 24 个配置 IO配置，这 24 个配置 IO 刚好对应着 LCD 的 24 根数据线 LCD_DATA0~LCDDATA23，<strong>当启动完成以后这 24 个 IO 就可以作为 LCD 的数据线使用。</strong>  </p><table><thead><tr><th>boot1</th><th>boot0</th><th></th><th></th><th></th><th></th><th></th><th></th><th>启动设备</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>x</td><td>x</td><td>x</td><td>x</td><td>x</td><td>x</td><td>串行下载，可以通过 USB 烧写镜像文件。</td></tr><tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>SD 卡启动。</td></tr><tr><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>EMMC 启动。</td></tr><tr><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>NAND FLASH 启动。</td></tr></tbody></table><h2 id="烧写镜像"><a href="#烧写镜像" class="headerlink" title="烧写镜像"></a>烧写镜像</h2><p><strong>imxdownload 会在 led.bin前面添加一些头信息，重新生成一个叫做 load.imx 的文件，头部信息包含以下</strong>  </p><ul><li><p>Image vector table，简称 IVT， IVT 里面包含了一系列的地址信息，这些地址信息在ROM 中按照固定的地址存放着。 </p></li><li><p>Boot data，启动数据，包含了镜像要拷贝到哪个地址，拷贝的大小是多少等等。</p></li><li><p>Device configuration data，简称 DCD，设备配置信息，重点是 DDR3 的初始化配置。</p></li><li><p>用户代码可执行文件，比如 led.bin。</p></li></ul><p>最终烧写到 I.MX6U 中的程序其组成为： IVT+Boot data+DCD+.bin 。(3KByte 的 IVT+Boot Data+DCD)</p><p>.bin是从0x87800000这个地方开始，往前推load.imx就是从0x877FF400开始的。</p><h1 id="点灯"><a href="#点灯" class="headerlink" title="点灯"></a>点灯</h1><p><strong>Makefile</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 定义了一个变量 objs， objs 包含着要生成 ledc.bin 所需的材料： start.o 和 main.o</span><br><span class="hljs-comment"># 这里要注意 start.o 一定要放到最前面！因为在后面链接的时候 start.o 要在最前面，因为 start.o 是最先要执行的文件！</span><br>objs := start.o main.o<br><br><span class="hljs-comment"># 使用依赖文件(objs:=start.o main.o),生成目标可执行文件ledc.bin</span><br><span class="hljs-section">ledc.bin:<span class="hljs-variable">$(objs)</span></span><br><span class="hljs-comment"># 使用编译器 arm-linux-gnueabihf-ld 进行连接,-Ttext指定起始地址是0X87800000</span><br><span class="hljs-comment"># $^ 是所有依赖文件的集合,也就是变量objs的值(start.o main.o)</span><br><span class="hljs-comment"># 展开等价 arm-linux-gnueabihf-ld -Ttext 0X87800000 -o ledc.elf start.o main.o</span><br>arm-linux-gnueabihf-ld -Ttext 0X87800000 -o ledc.elf <span class="hljs-variable">$^</span><br><span class="hljs-comment"># 将ledc.elf转换成ledc.bin文件</span><br><span class="hljs-comment"># $@ 的意思是目标集合，在这里就是 ledc.bin</span><br><span class="hljs-comment"># 展开等价 arm-linux-gnueabihf-objcopy -O binary -S ledc.elf ledc.bin</span><br>arm-linux-gnueabihf-objcopy -O binary -S ledc.elf <span class="hljs-variable">$@</span><br><span class="hljs-comment"># 反汇编，生成 ledc.dis 文件</span><br>arm-linux-gnueabihf-objdump -D -m arm ledc.elf &gt; ledc.dis<br><br><span class="hljs-comment"># 下面规则展开等价 </span><br><span class="hljs-comment"># start.o:start.s</span><br><span class="hljs-comment">#arm-linux-gnueabihf-gcc -Wall -nostdlib -c -O2 -o start.o start.s</span><br><span class="hljs-comment"># %匹配任意字符</span><br><span class="hljs-section">%.o:%.s</span><br><span class="hljs-comment"># $@ 的意思是目标集合，在这里就是 %.o</span><br><span class="hljs-comment"># $&lt; 所有依赖文件的集合，在这就是 %.s</span><br>arm-linux-gnueabihf-gcc -Wall -nostdlib -c -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br><span class="hljs-section">%.o:%.S</span><br>arm-linux-gnueabihf-gcc -Wall -nostdlib -c -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br><span class="hljs-section">%.o:%.c</span><br>arm-linux-gnueabihf-gcc -Wall -nostdlib -c -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br><br><span class="hljs-section">clean:</span><br>rm -rf *.o ledc.bin ledc.elf ledc.dis<br></code></pre></td></tr></table></figure><p><strong>Makefile</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 类似于上面的只是用到了变量</span><br>CROSS_COMPILE?= arm-linux-gnueabihf-<br>NAME ?= ledc<br><br>CC := <span class="hljs-variable">$(CROSS_COMPILE)</span>gcc<br>LD := <span class="hljs-variable">$(CROSS_COMPILE)</span>ld<br>OBJCOPY := <span class="hljs-variable">$(CROSS_COMPILE)</span>objcopy<br>OBJDUMP := <span class="hljs-variable">$(CROSS_COMPILE)</span>objdump<br>OBJS := start.o main.o<br><br><span class="hljs-variable">$(NAME)</span>.bin:<span class="hljs-variable">$(OBJS)</span><br><span class="hljs-variable">$(LD)</span> -Timx6ul.lds -o <span class="hljs-variable">$(NAME)</span>.elf <span class="hljs-variable">$^</span><br><span class="hljs-variable">$(OBJCOPY)</span> -O binary -S <span class="hljs-variable">$(NAME)</span>.elf <span class="hljs-variable">$@</span><br><span class="hljs-variable">$(OBJDUMP)</span> -D -m arm <span class="hljs-variable">$(NAME)</span>.elf &gt; <span class="hljs-variable">$(NAME)</span>.dis<br>    <br><span class="hljs-section">%.o:%.s</span><br><span class="hljs-variable">$(CC)</span> -Wall -nostdlib -c -O2 -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br><span class="hljs-section">%.o:%.S</span><br><span class="hljs-variable">$(CC)</span> -Wall -nostdlib -c -O2 -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br><span class="hljs-section">%.o:%.c</span><br><span class="hljs-variable">$(CC)</span> -Wall -nostdlib -c -O2 -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br><br><span class="hljs-section">clean:</span><br>rm -rf *.o <span class="hljs-variable">$(NAME)</span>.bin <span class="hljs-variable">$(NAME)</span>.elf <span class="hljs-variable">$(NAME)</span>.dis<br></code></pre></td></tr></table></figure><p><strong>Makefile</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs makefile">CROSS_COMPILE?= arm-linux-gnueabihf-<br><span class="hljs-comment"># 编译后 目标名</span><br>TARGET?= bsp<br><br><span class="hljs-comment"># 编译器相关</span><br>CC:= <span class="hljs-variable">$(CROSS_COMPILE)</span>gcc<br>LD:= <span class="hljs-variable">$(CROSS_COMPILE)</span>ld<br>OBJCOPY:= <span class="hljs-variable">$(CROSS_COMPILE)</span>objcopy<br>OBJDUMP:= <span class="hljs-variable">$(CROSS_COMPILE)</span>objdump<br><br><span class="hljs-comment"># include dir</span><br>INCDIRS:=  imx6ul  \<br>bsp/clk \<br>bsp/led \<br>bsp/delay<br><br><span class="hljs-comment"># sourc dir</span><br>SRCDIRS :=  project \<br>bsp/clk \<br>bsp/led \<br>bsp/delay<br><br><span class="hljs-comment"># 这里用到了 patsubst 函数 通过这个函数给 INCDIRS 前面加了一个 -I</span><br><span class="hljs-comment"># 展开 INCLUDE := -I imx6ul -I bsp/clk -I bsp/led -I bsp/delay</span><br>INCLUDE := <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %, -I %, <span class="hljs-variable">$(INCDIRS)</span>)</span><br><br><span class="hljs-comment"># 这里用到了 foreach 和 wildcard 函数</span><br><span class="hljs-comment"># 展开 SFILES := project/start.S</span><br><span class="hljs-comment"># 展开 CFILES := project/main.c bsp/clk/bsp_clk.c bsp/led/bsp_led.c bsp/delay/bsp_delay.c</span><br>SFILES := <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> <span class="hljs-built_in">dir</span>, <span class="hljs-variable">$(SRCDIRS)</span>, $(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(dir)</span>/*.S)</span>)<br>CFILES := <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> <span class="hljs-built_in">dir</span>, <span class="hljs-variable">$(SRCDIRS)</span>, $(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(dir)</span>/*.c)</span>)<br><br><span class="hljs-comment"># 这里用到了 notdir 函数 除去路径函数</span><br><span class="hljs-comment"># 展开 SFILENDIR := start.S</span><br><span class="hljs-comment"># 展开 CFILENDIR := main.c bsp_clk.c bsp_led.c bsp_delay.c</span><br>SFILENDIR := <span class="hljs-variable">$(<span class="hljs-built_in">notdir</span> <span class="hljs-variable">$(SFILES)</span>)</span><br>CFILENDIR := <span class="hljs-variable">$(<span class="hljs-built_in">notdir</span> <span class="hljs-variable">$(CFILES)</span>)</span><br><br><span class="hljs-comment"># 展开 SOBJS := obj/start.o</span><br><span class="hljs-comment"># 展开 COBJS := obj/main.o obj/bsp_clk.o obj/bsp_led.o obj/bsp_delay.o</span><br><span class="hljs-comment"># 展开 OBJS  := obj/start.o obj/main.o obj/bsp_clk.o obj/bsp_led.o obj/bsp_delay.o</span><br>SOBJS := <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %, obj/%, $(SFILENDIR:.S=.o)</span>)<br>COBJS := <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %, obj/%, $(CFILENDIR:.c=.o)</span>)<br>OBJS := <span class="hljs-variable">$(SOBJS)</span> <span class="hljs-variable">$(COBJS)</span><br><br>VPATH := <span class="hljs-variable">$(SRCDIRS)</span><br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: clean</span><br><br><span class="hljs-variable">$(TARGET)</span>.bin : <span class="hljs-variable">$(OBJS)</span><br><span class="hljs-variable">$(LD)</span> -Timx6ul.lds -o <span class="hljs-variable">$(TARGET)</span>.elf <span class="hljs-variable">$^</span><br><span class="hljs-variable">$(OBJCOPY)</span> -O binary -S <span class="hljs-variable">$(TARGET)</span>.elf <span class="hljs-variable">$@</span><br><span class="hljs-variable">$(OBJDUMP)</span> -D -m arm <span class="hljs-variable">$(TARGET)</span>.elf &gt; <span class="hljs-variable">$(TARGET)</span>.dis<br><br><span class="hljs-variable">$(SOBJS)</span> : obj/%.o : %.S<br><span class="hljs-variable">$(CC)</span> -Wall -nostdlib -c -O2 <span class="hljs-variable">$(INCLUDE)</span> -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br><span class="hljs-variable">$(COBJS)</span> : obj/%.o : %.c<br><span class="hljs-variable">$(CC)</span> -Wall -nostdlib -c -O2 <span class="hljs-variable">$(INCLUDE)</span> -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br><br><span class="hljs-section">clean:</span><br>rm -rf <span class="hljs-variable">$(TARGET)</span>.elf <span class="hljs-variable">$(TARGET)</span>.dis <span class="hljs-variable">$(TARGET)</span>.bin <span class="hljs-variable">$(COBJS)</span> <span class="hljs-variable">$(SOBJS)</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>AlphaMini</tag>
      
      <tag>正点原子</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cortex-A7 基础</title>
    <link href="/2021/da01e608/"/>
    <url>/2021/da01e608/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Cortex-A7 MPCore </p><ul><li><p>1-4core</p></li><li><p>Cortex-A15(big)+Cortex-A7(LITTLE)</p></li><li><p>L1 Cache 8,16,32,64KB</p></li><li><p>L2 Choice</p></li></ul><p>Cortex-A7 MPCore 基于 ARMv7-A</p><ul><li>SIMDv2 扩展整形和浮点向量</li><li>VFPv4 高性能单双精度浮点指令</li><li>LPAE 40bit寻址 最大1TB内存</li><li>硬件虚拟化</li><li>NEON 多媒体、信号处理加速</li></ul><h1 id="运行模式"><a href="#运行模式" class="headerlink" title="运行模式"></a>运行模式</h1><p>Cortex-A7处理器有 9种处理模式，除了 User(USR)用户模式以外，其它 8 种运行模式都是特权模式。  </p><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>User(USR)</td><td>用户模式，非特权大部分程序运行的时候就处于此。</td></tr><tr><td>FIQ</td><td>快速中断模式，进入 FIQ 中断异常</td></tr><tr><td>IRQ</td><td>一般中断模式。</td></tr><tr><td>Supervisor(SVC)</td><td>超级管理员模式，特权模式，供操作系统使用。</td></tr><tr><td>Monitor(MON)</td><td>这个模式用于安全扩展模式。</td></tr><tr><td>Abort(ABT)</td><td>数据访问终止模式，用于虚拟存储以及存储保护。</td></tr><tr><td>Hyp(HYP)</td><td>用于虚拟化扩展。</td></tr><tr><td>Undef(UND)</td><td>未定义指令终止模式。</td></tr><tr><td>System(SYS)</td><td>系统模式，用于运行特权级的操作系统任务</td></tr></tbody></table><h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><p><img src="/2021/da01e608/image-20210702163336723.png" alt="image-20210702163336723"></p><ul><li>暗色代表没有物理寄存器</li></ul><p><img src="/2021/da01e608/image-20210702163355713.png" alt="image-20210702163355713"></p><h2 id="CPSR"><a href="#CPSR" class="headerlink" title="CPSR"></a>CPSR</h2><p>CPSR 是当前程序状态寄存器，该寄存器包含了条件标志位、中断禁止位、当前处理器模式标志<br>等一些状态位以及一些控制位。  </p><p>SPSR(备份程序状态寄存器)  备份CPSR的</p><p><img src="/2021/da01e608/image-20210702164501790.png" alt="image-20210702164501790"></p><ul><li><p>N(bit31)：当两个补码表示的 有符号整数运算的时候， N&#x3D;1 表示运算对的结果为负数， N&#x3D;0表示结果为正数。</p></li><li><p>Z(bit30)： Z&#x3D;1 表示运算结果为零， Z&#x3D;0 表示运算结果不为零，对于 CMP 指令， Z&#x3D;1 表示进行比较的两个数大小相等。</p></li><li><p>C(bit29)：在加法指令中，当结果产生了进位，则 C&#x3D;1，表示无符号数运算发生上溢，其它情况下 C&#x3D;0。在减法指令中，当运算中发生借位，则 C&#x3D;0，表示无符号数运算发生下溢，其它情况下 C&#x3D;1。对于包含移位操作的非加&#x2F;减法运算指令， C 中包含最后一次溢出的位的数值，对于其它非加&#x2F;减运算指令， C 位的值通常不受影响。</p></li><li><p>V(bit28)： 对于加&#x2F;减法运算指令，当操作数和运算结果表示为二进制的补码表示的带符号数时， V&#x3D;1 表示符号位溢出，通常其他位不影响 V 位。</p></li><li><p>Q(bit27)： 仅 ARM v5TE_J 架构支持，表示饱和状态， Q&#x3D;1 表示累积饱和， Q&#x3D;0 表示累积不饱和。</p></li><li><p>IT[1:0].(bit26:25)： 和 IT[7:2].(bit15:bit10)一起组成 IT[7:0]，作为 IF-THEN 指令执行状态。</p></li><li><p>J(bit24)： 仅 ARM_v5TE-J 架构支持， J&#x3D;1 表示处于 Jazelle 状态，此位通常和 T(bit5)位一起表示当前所使用的指令集：</p></li></ul><table><thead><tr><th>J</th><th>T</th><th>bref</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>ARM</td></tr><tr><td>0</td><td>1</td><td>Thumb</td></tr><tr><td>1</td><td>1</td><td>ThumbEE</td></tr><tr><td>1</td><td>0</td><td>Jazelle</td></tr></tbody></table><ul><li><p>GE[3:0].(bit19:16)： SIMD 指令有效，大于或等于。</p></li><li><p>IT[7:2].(bit15:10)： 参考 IT[1:0]。</p></li><li><p>E(bit9)： 大小端控制位， E&#x3D;1 表示大端模式， E&#x3D;0 表示小端模式。</p></li><li><p>A(bit8)： 禁止异步中断位， A&#x3D;1 表示禁止异步中断。</p></li><li><p>I(bit7)： I&#x3D;1 禁止 IRQ， I&#x3D;0 使能 IRQ。</p></li><li><p>F(bit6)： F&#x3D;1 禁止 FIQ， F&#x3D;0 使能 FIQ。</p></li><li><p>T(bit5)： 控制指令执行状态，表明本指令是 ARM 指令还是 Thumb 指令，通常和 J(bit24)一起表明指令类型，参考 J(bit24)位。</p></li><li><p>M[4:0]： 处理器模式控制位：</p><table><thead><tr><th>M[4:0]</th><th>CPU Mode</th></tr></thead><tbody><tr><td>10000</td><td>User 模式</td></tr><tr><td>10001</td><td>FIQ 模式</td></tr><tr><td>10010</td><td>IRQ 模式</td></tr><tr><td>10011</td><td>Supervisor(SVC)模式</td></tr><tr><td>10110</td><td>Monitor(MON)模式</td></tr><tr><td>10111</td><td>Abort(ABT)模式</td></tr><tr><td>11010</td><td>Hyp(HYP)模式</td></tr><tr><td>11011</td><td>Undef(UND)模式</td></tr><tr><td>11111</td><td>System(SYS)模式</td></tr></tbody></table></li></ul><p>​    </p>]]></content>
    
    
    <categories>
      
      <category>CortexCore</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cortex-A7</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cortex-M3基础</title>
    <link href="/2020/2651f4ca/"/>
    <url>/2020/2651f4ca/</url>
    
    <content type="html"><![CDATA[<h1 id="Cortex-M3基础"><a href="#Cortex-M3基础" class="headerlink" title="Cortex-M3基础"></a>Cortex-M3基础</h1><h2 id="寄存器组"><a href="#寄存器组" class="headerlink" title="寄存器组"></a>寄存器组</h2><p><img src="/2020/2651f4ca/image-20201030190843098.png" alt="image-20201030190843098"></p><h3 id="堆栈指针"><a href="#堆栈指针" class="headerlink" title="堆栈指针"></a>堆栈指针</h3><ul><li><p>R13在同一时间只有一个可见，这就是所谓的“banked”寄存器。R13 作为堆栈指针寄存器 (Stack Pointer，SP)。</p></li><li><p>主堆栈指针（MSP）：复位后缺省使用的堆栈指针，用于操作系统内核以及异常处理例程（包<br>括中断服务例程）</p></li><li><p>进程堆栈指针（PSP）：由用户的应用程序代码使用。</p></li></ul><h3 id="连接寄存器"><a href="#连接寄存器" class="headerlink" title="连接寄存器"></a>连接寄存器</h3><p>R14 作为连接寄存器 (Link Register，LR)，当呼叫(调用)一个子程序时，由R14 存储返回地址。</p><h3 id="程序计数寄存器"><a href="#程序计数寄存器" class="headerlink" title="程序计数寄存器"></a>程序计数寄存器</h3><p>R15 作为程序计数器 (Program Counter，PC)，指向当前的程序地址。如果修改它的值，就能改变程序的执行流。</p><h2 id="特殊功能寄存器"><a href="#特殊功能寄存器" class="headerlink" title="特殊功能寄存器"></a>特殊功能寄存器</h2><p><img src="/2020/2651f4ca/image-20201030192111032.png" alt="image-20201030192111032"></p><table><thead><tr><th>寄存器</th><th>功能</th></tr></thead><tbody><tr><td>xPSR</td><td>记录ALU 标志（0 标志，进位标志，负数标志，溢出标志），执行状态，<strong>以及当前正服务的中断号</strong>。(保存算术与逻辑标志，例如负数标志，零结果标志，溢出标志等等)</td></tr><tr><td>PRIMASK</td><td>除能所有的中断，不可屏蔽中断（NMI）不受影响。</td></tr><tr><td>FAULTMASK</td><td>除能所有的fault——NMI 依然不受影响，而且被除能的faults 会“上访”，见后续章节的叙述。</td></tr><tr><td>BASEPRI</td><td>除能所有优先级不高于某个具体数值的中断。</td></tr><tr><td>CONTROL</td><td>定义特权状态（见后续章节对特权的叙述），并且决定使用哪一个堆栈指针。(如果是具有浮点单元的 Cortex-M4 或者 Cortex-M7，控制寄存器也用来指示浮点单元当前是否在使用)</td></tr></tbody></table><h3 id="xPSR"><a href="#xPSR" class="headerlink" title="xPSR"></a>xPSR</h3><p>程序状态寄存器在其内部又被分为三个子状态寄存器：</p><ul><li>应用程序 PSR（APSR）</li><li>中断号 PSR（IPSR）</li><li>执行 PSR（EPSR）<br><img src="/2020/2651f4ca/image-20201217154557648.png" alt="image-20201217154557648"></li></ul><h3 id="PRIMASK，FAULTMASK-，BASEPRI"><a href="#PRIMASK，FAULTMASK-，BASEPRI" class="headerlink" title="PRIMASK，FAULTMASK ，BASEPRI"></a>PRIMASK，FAULTMASK ，BASEPRI</h3><p>CM3 page.41</p><h3 id="CONTROL-控制寄存器"><a href="#CONTROL-控制寄存器" class="headerlink" title="CONTROL 控制寄存器"></a>CONTROL 控制寄存器</h3><table><thead><tr><th>位</th><th>功能</th></tr></thead><tbody><tr><td>CONTROL[1]</td><td>堆栈指针选择<br/>0&#x3D;选择主堆栈指针MSP（复位后缺省值）<br/>1&#x3D;选择进程堆栈指针PSP<br/>在线程或基础级（没有在响应异常——译注），可以使用PSP。在handler 模式下，<br/>只允许使用MSP，所以此时不得往该位写1。</td></tr><tr><td>CONTROL[0]</td><td>0&#x3D;特权级的线程模式<br/>1&#x3D;用户级的线程模式<br/>Handler 模式永远都是特权级的。</td></tr></tbody></table><h2 id="操作模式和特权模式"><a href="#操作模式和特权模式" class="headerlink" title="操作模式和特权模式"></a>操作模式和特权模式</h2><p>Cortex-M 引入了操作模式(handler mode、thread mode)和特权级别(特权级和用户级)的概念，如果进入异常或中断处理则进入handler mode，其他情况则为thread mode。</p><p><img src="/2020/2651f4ca/image-20201030193232853.png" alt="image-20201030193232853"></p><p><strong>handler mode总是使用 MSP 作为堆栈</strong>，<strong>thread mode可以选择使用 MSP 或 PSP 作为堆栈</strong>，同样通过CONTROL 特殊寄存器控制。复位后，Cortex-M 默认进入线程模式、特权级、使用 MSP 堆栈。</p><p><img src="/2020/2651f4ca/image-20201030193654568.png" alt="image-20201030193654568"></p><p>这可以提供一种存储器访问的保护机制，使得普通的用户程序代码不能意外地，甚至是恶意地执行涉及到要害的操作。处理器支持两种特权级，这也是一个基本的安全模型。</p><p>举例来说，操作系统的内核通常都在特权级下执行，所有没有被MPU 禁掉的存储器都可以访问。在操作系统开启了一个用户程序后，通常都会让它在用户级下执行，从而使系统不会因某个程序的崩溃或恶意破坏而受损。</p><h2 id="内建的嵌套向量中断控制器-NVIC"><a href="#内建的嵌套向量中断控制器-NVIC" class="headerlink" title="内建的嵌套向量中断控制器(NVIC)"></a>内建的嵌套向量中断控制器(NVIC)</h2><h2 id="SVC和PendSV"><a href="#SVC和PendSV" class="headerlink" title="SVC和PendSV"></a>SVC和PendSV</h2><h3 id="SVC（系统服务调用，系统调用）"><a href="#SVC（系统服务调用，系统调用）" class="headerlink" title="SVC（系统服务调用，系统调用）"></a>SVC（系统服务调用，系统调用）</h3><p>例如，操作系统不让用户程序直接访问硬件，而是通过提供一些系统服务函数，用户程序使用SVC 发出对系统服务函数的呼叫请求，以这种方法调用它们来间接访问硬件。因此，当用户程序想要控制特定的硬件时，它就会产生一个SVC 异常，然后操作系统提供的SVC 异常服务例程得到执行，它再调用相关的操作系统函数，后者完成用户程序请求的服务。</p><p>优势：</p><ul><li>第一，它使用户程序从控制硬件的繁文缛节中解脱出来，而是由OS 负责控制具体的硬件。</li><li>第二，OS 的代码可以经过充分的测试，从而能使系统更加健壮和可靠。</li><li>第三，它使用户程序无需在特权级下执行，用户程序无需承担因误操作而瘫痪整个系统的风险。</li><li>第四，通过SVC 的机制，还让用户程序变得与硬件无关，因此在开发应用程序时无需了解硬件的操作细节，从而简化了开发的难度和繁琐度，并且使应用程序跨硬件平台移植成为可能。</li></ul><h3 id="PendSV（可悬起系统调用）"><a href="#PendSV（可悬起系统调用）" class="headerlink" title="PendSV（可悬起系统调用）"></a>PendSV（可悬起系统调用）</h3><p>PendSV ，它是可以像普通的中断一样被悬起的（不像SVC 那样会上访）。OS 可以利用它“缓期执行”一个异常——直到其它重要的任务完成后才执行动作。悬起PendSV 的方法是：手工往NVIC 的PendSV 悬起寄存器中写1。悬起后，如果优先级不够高，则将缓期等待执行。</p><p>PendSV 的典型使用场合是在上下文切换时（在不同任务之间切换）。例如发生中断时产生线程唤醒，中断会引发一个PendSV，在中断运行结束后，会进入PendSV在里面进行线程唤醒（线程切换）。</p><h1 id="一些总结和个人笔记"><a href="#一些总结和个人笔记" class="headerlink" title="一些总结和个人笔记"></a>一些总结和个人笔记</h1><h2 id="中断的入栈出栈"><a href="#中断的入栈出栈" class="headerlink" title="中断的入栈出栈"></a>中断的入栈出栈</h2><ol><li>进入异常服务例程时，自动压栈R0‐R3, R12, LR, PSR 和PC。</li><li>进入异常服务程序后，LR的值被自动更新为特殊的EXC_RETURN。</li></ol><table><thead><tr><th>数值</th><th>功能</th></tr></thead><tbody><tr><td>0xFFFF_FFF1</td><td>返回handler模式</td></tr><tr><td>0xFFFF_FFF9</td><td>返回线程模式，并使用主堆栈(SP&#x3D;MSP)</td></tr><tr><td>0xFFFF_FFFD</td><td>返回线程模式，并使用线程堆栈(SP&#x3D;PSP)</td></tr></tbody></table><ul><li><p>如果主程序在线程模式下运行， 并且在使用MSP 时被中断， 则在服务例程中LR&#x3D;0xFFFF_FFF9（主程序被打断前的LR已被自动入栈）。</p></li><li><p>如果主程序在线程模式下运行， 并且在使用PSP 时被中断， 则在服务例程中LR&#x3D;0xFFFF_FFFD（主程序被打断前的LR已被自动入栈）。</p></li></ul><ol start="3"><li>进入函数调用时也会压栈Rxxx寄存器作为传入参数。</li><li>R0作为函数的返回值。</li></ol>]]></content>
    
    
    <categories>
      
      <category>CortexCore</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cortex-M3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RTX</title>
    <link href="/2020/2b1e625a/"/>
    <url>/2020/2b1e625a/</url>
    
    <content type="html"><![CDATA[<h1 id="创建一个RTX项目"><a href="#创建一个RTX项目" class="headerlink" title="创建一个RTX项目"></a>创建一个RTX项目</h1><p><strong>Create an RTX5 Project</strong></p><ol><li><p>创建一个新的项目,并选择单片机设备。</p><p>Create a new project and select a microcontroller device.</p></li><li><p>设置 <strong>CMSIS::CORE</strong> 和 <strong>CMSIS::RTOS2 (API)::Keil RTX5</strong>，在下拉框中你可以选择添加RTX库或者添加完整源代码。</p><p>In the Manage Run-Time Environment window, select <strong>CMSIS::CORE</strong> and <strong>CMSIS::RTOS2 (API)::Keil RTX5</strong>. You can choose to either add RTX as a library (Variant: <strong>Library</strong>) or to add the full source code (Variant: <strong>Source</strong> - required if using the <a href="http://www.keil.com/pack/doc/compiler/EventRecorder/html/index.html"><strong>Event Recorder</strong></a>):</p></li><li><p>添加启动文件 <strong>Device::Startup</strong></p></li><li><p>一个示例代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">osKernelInitialize();/ /初始化RTX<br><span class="hljs-title function_">NVIC_SetPriorityGrouping</span> <span class="hljs-params">(<span class="hljs-number">3</span>)</span>;/ /设置优先级分组<br>tread_id =osThreadNew(tread_func,空,空);/ /创建一些线程<br>osKernelStart();/ /开始RTX内核<br></code></pre></td></tr></table></figure><p>注：</p><ol><li><p>添加RTX特定功能的支持</p><p>如果你需要一些的<a href="group__rtx5__specific.html">RTX特定功能</a>在您的应用程序代码中,# include<a href="theory_of_operation.html#rtx_os_h">头文件rtx_os.h</a>。 如使能<a href="theory_of_operation.html#lowPower">低功耗</a>和<a href="theory_of_operation.html#TickLess">tick-less</a>操作模式。</p></li><li><p>添加事件记录器</p><ul><li><p>打开MRTE(Manage Run-Time Environment)窗口</p></li><li><p>确保RTX5使用的是源代码(Source)模式</p></li><li><p>打开 <strong>Compiler::Event Recorder</strong></p></li></ul></li></ol></li></ol><h1 id="中断-Cortex-M"><a href="#中断-Cortex-M" class="headerlink" title="中断 (Cortex-M)"></a>中断 (Cortex-M)</h1><p>Cortex-M处理器,RTX5内核使用以下异常中断。 下面的表格还列出了必须分配给这些中断的优先级。</p><table><thead><tr><th>处理程序</th><th>优先级</th><th>中断&#x2F;异常</th></tr></thead><tbody><tr><td>SysTick</td><td>最低</td><td>内核系统定时器中断产生周期性的计时器滴答声</td></tr><tr><td>PendSV</td><td>最低</td><td>PendSV(系统级服务请求)当调用某些RTX功能<strong>处理程序</strong>模式</td></tr><tr><td>SVC</td><td>最低+ 1</td><td>主管叫用来输入RTOS内核<strong>线程</strong>模式</td></tr></tbody></table><p>可以使用其他设备中断没有限制。 ARM Cortex-M3 &#x2F; M4 &#x2F; M7 &#x2F; M23 &#x2F; M33 &#x2F; M35P处理器,从未被RTX禁用中断内核。</p><p><strong>使用中断的优先级分组</strong></p><ul><li>在调用函数<a href="group__CMSIS__RTOS__KernelCtrl.html#ga9ae2cc00f0d89d7b6a307bba942b5221">osKernelStart（）</a>之前，应使用CMSIS-Core函数NVIC_SetPriorityGrouping配置中断优先级分组。RTX内核使用优先级组值来设置SysTick和PendSV中断的优先级。</li><li>RTX内核为上表中列出的中断&#x2F;异常设置优先级，并使用最低的两个优先级。</li><li>不要更改RTX内核使用的优先级。如果无法避免，请确保SysTick &#x2F; PendSV的抢占优先级低于SVC。</li><li>允许的优先级组值为0到6.优先级组值7将导致RTX失败，因为只有一个可用优先级。</li><li>的<strong>main函数堆叠</strong>被用于运行RTX功能。因此，需要为RTX内核执行配置足够的堆栈。</li></ul>]]></content>
    
    
    <categories>
      
      <category>RTOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RTX</tag>
      
      <tag>RTOS</tag>
      
      <tag>Keil</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UCOS</title>
    <link href="/2020/2ac84091/"/>
    <url>/2020/2ac84091/</url>
    
    <content type="html"><![CDATA[<h2 id="序章"><a href="#序章" class="headerlink" title="序章"></a>序章</h2><h3 id="延时函数"><a href="#延时函数" class="headerlink" title="延时函数"></a>延时函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>  <span class="hljs-title function_">OSTimeDlyHMSM</span> <span class="hljs-params">(CPU_INT16U   hours,</span><br><span class="hljs-params">                     CPU_INT16U   minutes,</span><br><span class="hljs-params">                     CPU_INT16U   seconds,</span><br><span class="hljs-params">                     CPU_INT32U   milli,</span><br><span class="hljs-params">                     OS_OPT       opt,</span><br><span class="hljs-params">                     OS_ERR      *p_err)</span><br><br><span class="hljs-title function_">OSTimeDlyHMSM</span><span class="hljs-params">(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,OS_OPT_TIME_HMSM_STRICT,&amp;err)</span>; <span class="hljs-comment">//延时1s</span><br><span class="hljs-comment">//strick   adj. 严格的；绝对的；精确的；详细的</span><br></code></pre></td></tr></table></figure><h2 id="任务管理"><a href="#任务管理" class="headerlink" title="任务管理"></a>任务管理</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//创建开始任务</span><br>OSTaskCreate((OS_TCB * )&amp;StartTaskTCB,<span class="hljs-comment">//任务控制块</span><br> (CPU_CHAR* )<span class="hljs-string">&quot;start task&quot;</span>, <span class="hljs-comment">//任务名字</span><br>                 (OS_TASK_PTR )start_task, <span class="hljs-comment">//任务函数</span><br>                 (<span class="hljs-type">void</span>* )<span class="hljs-number">0</span>,<span class="hljs-comment">//传递给任务函数的参数</span><br>                 (OS_PRIO  )START_TASK_PRIO,     <span class="hljs-comment">//任务优先级</span><br>                 (CPU_STK   * )&amp;START_TASK_STK[<span class="hljs-number">0</span>],<span class="hljs-comment">//任务堆栈基地址</span><br>                 (CPU_STK_SIZE)START_STK_SIZE/<span class="hljs-number">10</span>,<span class="hljs-comment">//任务堆栈深度限位</span><br>                 (CPU_STK_SIZE)START_STK_SIZE,<span class="hljs-comment">//任务堆栈大小</span><br>                 (OS_MSG_QTY  )<span class="hljs-number">0</span>,<span class="hljs-comment">//任务内部消息队列能够接收的最大消息数目,为0时禁止接收消息</span><br>                 (OS_TICK  )<span class="hljs-number">0</span>,<span class="hljs-comment">//当使能时间片轮转时的时间片长度，为0时为默认长度，</span><br>                 (<span class="hljs-type">void</span>   * )<span class="hljs-number">0</span>,<span class="hljs-comment">//用户补充的存储区</span><br>                 (OS_OPT      )OS_OPT_TASK_STK_CHK|OS_OPT_TASK_STK_CLR, <span class="hljs-comment">//任务选项</span><br>                 (OS_ERR * )&amp;err);<span class="hljs-comment">//存放该函数错误时的返回值</span><br><br><br></code></pre></td></tr></table></figure><ol><li><p><code>(CPU_STK_SIZE)START_STK_SIZE/10,//任务堆栈深度限位</code>    一般设定小于10%即可</p></li><li><p><code>(OS_TCB * )&amp;StartTaskTCB,//任务控制块</code>   <strong>不要访问和更改其中的成员变量</strong></p></li></ol><h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><ul><li><p>数值越小优先级越高</p></li><li><p>os_cfg.h line48   <strong>OS_CFG_PRIO_MAX</strong>  最大优先级数</p></li></ul><h4 id="就绪表"><a href="#就绪表" class="headerlink" title="就绪表"></a>就绪表</h4><ul><li>优先级位映射表**OSPrioTbl[]**：用来记录哪个优先级下有任务就绪</li><li>就绪任务列表**OSRdyList[]**：用来记录每一个优先级下所有就绪的任务</li></ul><h4 id="前导零"><a href="#前导零" class="headerlink" title="前导零"></a>前导零</h4><ul><li>硬件计算  能计算一个值前面有多少零</li></ul><h2 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h2><h4 id="任务调度-1"><a href="#任务调度-1" class="headerlink" title="任务调度"></a>任务调度</h4><ul><li>任务调度器 进入中断   OSIntEnter();  </li><li>任务调度器 退出中断   OSIntExit();</li></ul><h4 id="发生任务调度的调度点"><a href="#发生任务调度的调度点" class="headerlink" title="发生任务调度的调度点"></a>发生任务调度的调度点</h4><ul><li>延时函数OSTimeDly()（按时间延时）或者OSTimeDlyHMSM()（按节拍延时）</li><li>创建、删除任务</li><li>改变优先级</li><li>通过调用OSTaskSuspend()将自身挂起、或解除某个挂起的任务</li><li>OSSched() 用户自行请求调度</li></ul><h4 id="调度器上锁解锁"><a href="#调度器上锁解锁" class="headerlink" title="调度器上锁解锁"></a>调度器上锁解锁</h4><ul><li>OSSchedLock()加锁</li><li>OSSchedUnlock()解锁</li></ul><h4 id="时间片轮转调度"><a href="#时间片轮转调度" class="headerlink" title="时间片轮转调度"></a>时间片轮转调度</h4><ul><li>待补充</li></ul><h2 id="UCOS系统初始化"><a href="#UCOS系统初始化" class="headerlink" title="UCOS系统初始化"></a>UCOS系统初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>   OS_ERR err;<br>   ……<br>   <span class="hljs-comment">//其他函数，一般为外设初始化函数</span><br>   ……<br>   OSInit(&amp;err);<br>   ……<br>   <span class="hljs-comment">//其他函数，一般为创建任务函数</span><br>   ……<br>   OSStart(&amp;err);<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>OSInit()必须先于其他的UCOS函数调用包括OSStart()</li></ul><h2 id="任务创建与管理"><a href="#任务创建与管理" class="headerlink" title="任务创建与管理"></a>任务创建与管理</h2><h4 id="任务的创建"><a href="#任务的创建" class="headerlink" title="任务的创建"></a>任务的创建</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">OSTaskCreate((OS_TCB * )&amp;StartTaskTCB,<span class="hljs-comment">//任务控制块</span><br>             (CPU_CHAR* )<span class="hljs-string">&quot;start task&quot;</span>, <span class="hljs-comment">//任务名字</span><br>             (OS_TASK_PTR )start_task, <span class="hljs-comment">//任务函数</span><br>             (<span class="hljs-type">void</span>* )<span class="hljs-number">0</span>,<span class="hljs-comment">//传递给任务函数的参数</span><br>             (OS_PRIO  )START_TASK_PRIO,     <span class="hljs-comment">//任务优先级</span><br>             (CPU_STK   * )&amp;START_TASK_STK[<span class="hljs-number">0</span>],<span class="hljs-comment">//任务堆栈基地址</span><br>             (CPU_STK_SIZE)START_STK_SIZE/<span class="hljs-number">10</span>,<span class="hljs-comment">//任务堆栈深度限位</span><br>             (CPU_STK_SIZE)START_STK_SIZE,<span class="hljs-comment">//任务堆栈大小</span><br>             (OS_MSG_QTY  )<span class="hljs-number">0</span>,<span class="hljs-comment">//任务内部消息队列能够接收的最大消息数目,为0时禁止接收消息</span><br>             (OS_TICK  )<span class="hljs-number">0</span>,<span class="hljs-comment">//当使能时间片轮转时的时间片长度，为0时为默认长度，</span><br>             (<span class="hljs-type">void</span>   * )<span class="hljs-number">0</span>,<span class="hljs-comment">//用户补充的存储区</span><br>             (OS_OPT      )OS_OPT_TASK_STK_CHK|OS_OPT_TASK_STK_CLR, <span class="hljs-comment">//任务选项</span><br>             (OS_ERR * )&amp;err);<span class="hljs-comment">//存放该函数错误时的返回值</span><br></code></pre></td></tr></table></figure><p>OS_ERR 错误代码</p><h4 id="任务的删除"><a href="#任务的删除" class="headerlink" title="任务的删除"></a>任务的删除</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>  <span class="hljs-title function_">OSTaskDel</span> <span class="hljs-params">(OS_TCB  *p_tcb,</span><br><span class="hljs-params">                 OS_ERR  *p_err)</span>;<br>    <br>OSTaskDel((OS_TCB*)&amp;Task2_TaskTCB,&amp;err);<br></code></pre></td></tr></table></figure><p>不建议在系统运行时删除任务</p><blockquote><p>尽管UCOSIII允许在系统运行中删除任务，但是应该尽量避免这种操作，如果这个任务可能占有与其他任务共享的资源，在删除此任务之前这个被占有的资源没有被释放就有可能导致奇怪的结果。</p></blockquote><h2 id="任务的挂起与恢复"><a href="#任务的挂起与恢复" class="headerlink" title="任务的挂起与恢复"></a>任务的挂起与恢复</h2><h3 id="挂起"><a href="#挂起" class="headerlink" title="挂起"></a>挂起</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>   <span class="hljs-title function_">OSTaskSuspend</span> <span class="hljs-params">(OS_TCB  *p_tcb,</span><br><span class="hljs-params">                      OS_ERR  *p_err)</span>;<br><br>OSTaskSuspend((OS_TCB*)&amp;Task2_TaskTCB,&amp;err);<span class="hljs-comment">//挂起任务2</span><br></code></pre></td></tr></table></figure><p>挂起错误</p><ul><li>任务被加锁</li><li>任务空闲</li></ul><h3 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>  <span class="hljs-title function_">OSTaskResume</span> <span class="hljs-params">(OS_TCB  *p_tcb,</span><br><span class="hljs-params">                    OS_ERR  *p_err)</span><br><br><span class="hljs-title function_">OSTaskResume</span><span class="hljs-params">((OS_TCB*)&amp;Task2_TaskTCB,&amp;err)</span>;<span class="hljs-comment">//恢复任务2</span><br></code></pre></td></tr></table></figure><p>恢复错误</p><ul><li>任务状态无效（错误的状态）、任务不是已经挂起的</li><li>不能恢复自己</li></ul><h2 id="时间片轮转调度-1"><a href="#时间片轮转调度-1" class="headerlink" title="时间片轮转调度"></a>时间片轮转调度</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>  <span class="hljs-title function_">OSSchedRoundRobinCfg</span> <span class="hljs-params">(CPU_BOOLEAN   en,</span><br><span class="hljs-params">                            OS_TICK       dflt_time_quanta,</span><br><span class="hljs-params">                            OS_ERR       *p_err)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span>OS_CFG_SCHED_ROUND_ROBIN_EN  <span class="hljs-comment">//当使用时间片轮转的时候</span></span><br> <span class="hljs-comment">//使能时间片轮转调度功能,时间片长度为1个系统时钟节拍，既1*5=5ms</span><br><span class="hljs-title function_">OSSchedRoundRobinCfg</span><span class="hljs-params">(DEF_ENABLED,<span class="hljs-number">1</span>,&amp;err)</span>;  <br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul><li>设置宏  <strong>OS_CFG_SCHED_ROUND_ROBIN_EN</strong>  为1</li><li>调用函数  <strong>OSSchedRoundRobinCfg()</strong>  开启时间片轮转调度功能</li></ul><h3 id="时间片的放弃"><a href="#时间片的放弃" class="headerlink" title="时间片的放弃"></a>时间片的放弃</h3><p><code>OSSchedRoundRobinYield(&amp;err);</code></p><h3 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h3><p>时间片如果不够执行可能会产生奇怪的效果请注意</p><h2 id="系统内部任务"><a href="#系统内部任务" class="headerlink" title="系统内部任务"></a>系统内部任务</h2><ol><li><p>中断服务管理任务</p></li><li><p>时钟节拍任务</p></li><li><p>定时任务（可选）</p></li><li><p>统计任务（可选）</p></li><li><p>空闲任务</p></li></ol><h3 id="中断服务管理任务"><a href="#中断服务管理任务" class="headerlink" title="中断服务管理任务"></a>中断服务管理任务</h3><ul><li>默认优先级最高，第一，不可更改。</li></ul><h3 id="时钟节拍任务"><a href="#时钟节拍任务" class="headerlink" title="时钟节拍任务"></a>时钟节拍任务</h3><ul><li>优先级较高，第二。</li></ul><h3 id="定时任务（可选）"><a href="#定时任务（可选）" class="headerlink" title="定时任务（可选）"></a>定时任务（可选）</h3><ul><li><p>默认优先级，第三。</p></li><li><p>提供软件定时功能</p></li><li><p>将宏OS_CFG_TMR_EN设置为1就会使能定时任务，在OSInit()中将会调用函数OS_TmrInit()来创建定时任务。</p></li></ul><h3 id="统计任务（可选）"><a href="#统计任务（可选）" class="headerlink" title="统计任务（可选）"></a>统计任务（可选）</h3><ul><li>一般优先级，倒数第二。</li><li>统计CPU使用率，堆栈使用率</li><li>可选创建（将宏<strong>OS_CFG_STAT_TASK_EN</strong>置1）</li><li>必须在main函数创建的以一个任务也是唯一的一个应用任务里面调用函数**OSStatTaskCPUUsageInit()**查询使用情况</li></ul><h3 id="空闲任务"><a href="#空闲任务" class="headerlink" title="空闲任务"></a>空闲任务</h3><ul><li>优先级最低，倒数第一。</li><li>不能调用会使空闲任务进入等待态的函数。</li><li><span style="color:red">可统计CPU使用率</span>（用处）</li></ul><h2 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h2><p>共有8个</p><ol><li>OSIdleTaskHook()，<strong>空闲任务</strong>调用这个函数，可以用来让CPU进入低功耗模式</li><li>OSInitHook()，<strong>系统初始化</strong>函数OSInit()调用此函数</li><li>OSStatTaskHook(), <strong>统计任务每秒</strong>中都会调用这个函数，此函数允许你向统计任务中添加自己的应用函数。</li><li>OSTaskCreateHook(),<strong>任务创建</strong>的钩子函数。</li><li>OSTaskDelHook(),<strong>任务删除</strong>的钩子函数。</li><li>OSTaskReturnHook(),<strong>任务意外返回</strong>时调用的钩子函数，比如删除某个任务</li><li>OSTaskSwHook(),<strong>任务切换</strong>时候调用的钩子函数。</li><li>OSTimeTickHook()，<strong>滴答定时器</strong>调用的钩子函数。</li></ol><h2 id="中断时间管理"><a href="#中断时间管理" class="headerlink" title="中断时间管理"></a>中断时间管理</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">USART1_IRQHandler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>       OSIntEnter();<br>      <span class="hljs-comment">//中断服务程序</span><br>      OSIntExit();<br>&#125;  <br><br><br><br></code></pre></td></tr></table></figure><ul><li>最大250级中断嵌套</li></ul><h2 id="临界区代码保护"><a href="#临界区代码保护" class="headerlink" title="临界区代码保护"></a>临界区代码保护</h2><blockquote><p>临界区：不可被打断的代码段</p></blockquote><p>OS_CFG_ISR_POST_DEFERRED_EN   的值与临界段代码保护方式</p><table><thead><tr><th>0</th><th>关中断</th></tr></thead><tbody><tr><td>1</td><td>调度器上锁（可能会被其它中断打断）</td></tr></tbody></table><ol><li><p>进入临界段</p><ul><li>一个进入函数</li></ul></li><li><p>退出临界段</p><ul><li><p>退出后产生调度——-OS_CRITICAL_EXIT()</p></li><li><p>退出后不产生调度—-OS_CRITICAL_EXIT_NO_SCHED()</p></li><li></li></ul></li></ol><h3 id="CPU-SR-ALLOC"><a href="#CPU-SR-ALLOC" class="headerlink" title="CPU_SR_ALLOC()"></a>CPU_SR_ALLOC()</h3><ol><li>函数CPU_SR_ALLOC()是为CPU_CRITICAL_ENTER()和CPU_CRITICAL_EXIT()申请一个变量：</li></ol><p><code>#define  CPU_SR_ALLOC()           CPU_SR  cpu_sr = (CPU_SR)0</code></p><p>这个是临界代码段，在下面一个小节有详细讲解。</p><ol start="2"><li>这样做是为了防止编译器警告。</li></ol><h2 id="任务延时"><a href="#任务延时" class="headerlink" title="任务延时"></a>任务延时</h2><ul><li>开始延时</li></ul><table><thead><tr><th>OSTimeDly()</th><th>相对延时</th><th>基于时钟节拍</th></tr></thead><tbody><tr><td></td><td>绝对延时</td><td></td></tr><tr><td></td><td>周期延时</td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td>OSTimeDlyHMSM()</td><td>相对延时</td><td>基于时间</td></tr></tbody></table><ul><li><p>取消延时</p><p>延时任务任务可通过在其他任务中调用函数OSTimeDlyResume()取消延时而进入就绪状态，此函数最后会引发一次任务调度。</p></li></ul><h2 id="获取系统时间"><a href="#获取系统时间" class="headerlink" title="获取系统时间"></a>获取系统时间</h2><p>​UCOSIII定义了一个 CPU_INT32U 类型的全局变量 OSTickCtr 来记录系统时钟节拍数，在调用 <strong>OSInit()</strong> 时被初始化为 0，以后每发生1个时钟节拍，OSTickCtr加1。</p><ul><li>OSTimeSet()允许用户改变当前时钟节拍计数器的值</li><li>OSTimeGet()用来获取动迁时钟节拍计数器的值</li></ul><h2 id="软件定时器"><a href="#软件定时器" class="headerlink" title="软件定时器"></a>软件定时器</h2><p>​定时器本质是递减计数器，当计数器减到零时可以执行回调函数。应用程序可以有任意数量的定时器，UCOSIII中定时器的时间分辨率由一个宏 <strong>OS_CFG_TMR_TASK_RATE_HZ</strong> 确定，单位为HZ，默认为100Hz。</p><ul><li>避免在回调函数使用   <strong>阻塞</strong>，<strong>删除</strong>   定时器任务的函数。</li></ul><h3 id="软件定时器的API"><a href="#软件定时器的API" class="headerlink" title="软件定时器的API"></a>软件定时器的API</h3><table><thead><tr><th><strong>OSTmrCreate()</strong></th><th><strong>创建定时器并制定运行模式</strong></th></tr></thead><tbody><tr><td>OSTmrDel()</td><td>删除定时器</td></tr><tr><td>OSTmrRemainGet()</td><td>获取定时器的剩余时间</td></tr><tr><td><strong>OSTmrStart()</strong></td><td><strong>启动定时器计数</strong></td></tr><tr><td>OSTmrStateGet()</td><td>获取当前定时器状态</td></tr><tr><td><strong>OSTmrStop()</strong></td><td><strong>停止计数器倒计时</strong></td></tr></tbody></table><p><strong>OSTmrCreate()有三种模式</strong></p><ul><li>单次模式（通过OSTmrStart()触发）</li><li>周期无延迟模式</li><li>周期有延迟模式</li></ul><h2 id="信号量、互斥信号量、内嵌信号量"><a href="#信号量、互斥信号量、内嵌信号量" class="headerlink" title="信号量、互斥信号量、内嵌信号量"></a>信号量、互斥信号量、内嵌信号量</h2><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量像是一种上锁机制，代码必须获得对应的钥匙才能继续执行，一旦获得了钥匙，也就意味着该任务具有进入被锁部分代码的权限。一旦执行至被锁代码段，则任务一直等待，直到对应被锁部分代码的钥匙被再次释放才能继续执行。</p><ul><li>信号量用于控制对共享资源的保护，但是现在基本用来做任务同步用。</li></ul><h4 id="信号量API"><a href="#信号量API" class="headerlink" title="信号量API"></a>信号量API</h4><table><thead><tr><th>OSSemCreate()</th><th>建立一个信号量</th></tr></thead><tbody><tr><td>OSSemDel()</td><td>删除一个信号量</td></tr><tr><td><strong>OSSemPend()</strong></td><td><strong>等待一个信号量</strong></td></tr><tr><td>OSSemPendAbrot()</td><td>取消等待</td></tr><tr><td><strong>OSSemPost()</strong></td><td><strong>释放或者发出一个信号量</strong></td></tr><tr><td>OSSemSet()</td><td>强制设置一个信号量的值</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>  <span class="hljs-title function_">OSSemCreate</span> <span class="hljs-params">(OS_SEM      *p_sem,<span class="hljs-comment">//OS_SEMMY_SEM;定义一个信号量，用于访问共享资源</span></span><br><span class="hljs-params">                   CPU_CHAR    *p_name,<span class="hljs-comment">//&quot;MY_SEM&quot;名称</span></span><br><span class="hljs-params">                   OS_SEM_CTR   cnt,<span class="hljs-comment">//如果设置成计数型信号量 此处设置成对应数字即可   如果设置成二进制信号量   此处设置成0即可</span></span><br><span class="hljs-params">                   OS_ERR      *p_err)</span><span class="hljs-comment">//</span><br>    <br><span class="hljs-title function_">OSSemCreate</span> <span class="hljs-params">((OS_SEM*)&amp;MY_SEM,</span><br><span class="hljs-params">             (CPU_CHAR*)<span class="hljs-string">&quot;MY_SEM&quot;</span>,</span><br><span class="hljs-params">             (OS_SEM_CTR)<span class="hljs-number">1</span>,</span><br><span class="hljs-params">             (OS_ERR*)&amp;err)</span>;<br></code></pre></td></tr></table></figure><ul><li>OS_SEM_CTR   cnt,<ul><li>如果设置成计数型信号量   此处设置成对应数字即可   </li><li>如果设置成二进制信号量   此处设置成0，指示事件的发生（同步）</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">OS_SEM_CTR  <span class="hljs-title function_">OSSemPend</span> <span class="hljs-params">(OS_SEM   *p_sem,</span><br><span class="hljs-params">                       OS_TICK   timeout,</span><br><span class="hljs-params">                       OS_OPT    opt,</span><br><span class="hljs-params">                       CPU_TS   *p_ts,</span><br><span class="hljs-params">                       OS_ERR   *p_err)</span><br><br><span class="hljs-title function_">OSSemPend</span><span class="hljs-params">(&amp;MY_SEM,<span class="hljs-number">0</span>,OS_OPT_PEND_BLOCKING,<span class="hljs-number">0</span>,&amp;err)</span>; <span class="hljs-comment">//请求信号量</span><br></code></pre></td></tr></table></figure><ul><li>OS_OPT    opt,<ul><li>OS_OPT_PEND_BLOCKING —————-&gt;  阻塞式</li><li>OS_OPT_PEND_NON_BLOCKING ——-&gt; 非阻塞式</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">OS_SEM_CTR  <span class="hljs-title function_">OSSemPost</span> <span class="hljs-params">(OS_SEM  *p_sem,</span><br><span class="hljs-params">                       OS_OPT   opt,</span><br><span class="hljs-params">                       OS_ERR  *p_err)</span><br>    <br><span class="hljs-title function_">OSSemPost</span> <span class="hljs-params">(&amp;MY_SEM,OS_OPT_POST_1,&amp;err)</span>;<span class="hljs-comment">//发送 释放 信号量</span><br></code></pre></td></tr></table></figure><ul><li>OS_OPT    opt，<ul><li>OS_OPT_POST_1 —–&gt;只使能等待信号量的最高优先级任务   (如果任务正在等待)。</li><li>OS_OPT_POST_ALL  ——&gt;发送到所有等待信号量的任务</li><li>OS_OPT_POST_NO_SCHED  ———&gt;不调用调度程序  可以与其他选项之一一起添加。</li></ul></li></ul><h3 id="互斥信号量"><a href="#互斥信号量" class="headerlink" title="互斥信号量"></a>互斥信号量</h3><h4 id="互斥信号量API"><a href="#互斥信号量API" class="headerlink" title="互斥信号量API"></a>互斥信号量API</h4><table><thead><tr><th>OSMutexCreate()</th><th>建立一个互斥信号量</th></tr></thead><tbody><tr><td>OSMutexDel()</td><td>删除一个互斥信号量</td></tr><tr><td><strong>OSMutexPend()</strong></td><td><strong>等待一个互斥信号量</strong></td></tr><tr><td>OSMutexPendAbrot()</td><td>取消等待</td></tr><tr><td><strong>OSMutexPost()</strong></td><td><strong>释放或者发布一个互斥信号量</strong></td></tr></tbody></table><h3 id="内嵌信号量"><a href="#内嵌信号量" class="headerlink" title="内嵌信号量"></a>内嵌信号量</h3><table><thead><tr><th>OSTaskSemPend()</th><th>等待一个任务信号量</th></tr></thead><tbody><tr><td>OSTaskSemPendAbort()</td><td>取消等待任务信号量</td></tr><tr><td><strong>OSTaskSemPost()</strong></td><td><strong>发布任务信号量</strong></td></tr><tr><td>OSTaskSemSet()</td><td>强行设置任务信号量计数</td></tr></tbody></table><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><h3 id="消息队列-1"><a href="#消息队列-1" class="headerlink" title="消息队列"></a>消息队列</h3><table><thead><tr><th><strong>函数名</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><strong>OSQCreate()</strong></td><td><strong>创建一个消息   队列</strong></td></tr><tr><td>OSQDel()</td><td>删除一个消息队列</td></tr><tr><td>OSQFlush()</td><td>清空消息队列</td></tr><tr><td><strong>OSQPend()</strong></td><td><strong>等待消息</strong></td></tr><tr><td>OSQPendAbort()</td><td>取消等待消息</td></tr><tr><td><strong>OSQPost()</strong></td><td><strong>向消息队列发布一则消息</strong></td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>  <span class="hljs-title function_">OSQCreate</span> <span class="hljs-params">(OS_Q        *p_q,</span><br><span class="hljs-params">                 CPU_CHAR    *p_name,</span><br><span class="hljs-params">                 OS_MSG_QTY   max_qty,</span><br><span class="hljs-params">                 OS_ERR      *p_err)</span><br>    <br><span class="hljs-title function_">OSQCreate</span> <span class="hljs-params">((OS_Q*)&amp;KEY_Msg,<span class="hljs-comment">//消息队列</span></span><br><span class="hljs-params">           (CPU_CHAR*)<span class="hljs-string">&quot;KEY Msg&quot;</span>,<span class="hljs-comment">//消息队列名称</span></span><br><span class="hljs-params">           (OS_MSG_QTY)KEYMSG_Q_NUM,<span class="hljs-comment">//消息队列长度，这里设置为1</span></span><br><span class="hljs-params">           (OS_ERR*)&amp;err)</span>;<span class="hljs-comment">//错误码</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//发送消息</span><br>OSQPost((OS_Q*)&amp;DATA_Msg,<br>        (<span class="hljs-type">void</span>*)pbuf,<br>        (OS_MSG_SIZE)<span class="hljs-number">10</span>,<br>        (OS_OPT)OS_OPT_POST_FIFO,<br>        (OS_ERR*)&amp;err);<br><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//请求消息</span><br>p=OSQPend((OS_Q*)&amp;DATA_Msg,   <br>          (OS_TICK)<span class="hljs-number">0</span>,<br>          (OS_OPT)OS_OPT_PEND_BLOCKING,<br>          (OS_MSG_SIZE*)&amp;size,<br>          (CPU_TS*)<span class="hljs-number">0</span>,<br>          (OS_ERR*)&amp;err);<br></code></pre></td></tr></table></figure><h3 id="任务内建消息队列"><a href="#任务内建消息队列" class="headerlink" title="任务内建消息队列"></a>任务内建消息队列</h3><table><thead><tr><th><strong>函数名</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><strong>OSTaskQPend()</strong></td><td><strong>等待消息</strong></td></tr><tr><td>OSTaskQPendAbort()</td><td>取消等待消息</td></tr><tr><td><strong>OSTaskQPost()</strong></td><td><strong>向任务发布一则消息</strong></td></tr><tr><td>OSTaskQFlush()</td><td>清空任务的消息队列</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//创建MSGDIS任务</span><br>OSTaskCreate((OS_TCB * )&amp;Msgdis_TaskTCB,<br>             (CPU_CHAR* )<span class="hljs-string">&quot;Msgdis task&quot;</span>, <br>             (OS_TASK_PTR )msgdis_task, <br>             (<span class="hljs-type">void</span>* )<span class="hljs-number">0</span>,<br>             (OS_PRIO  )MSGDIS_TASK_PRIO,     <br>             (CPU_STK   * )&amp;MSGDIS_TASK_STK[<span class="hljs-number">0</span>],<br>             (CPU_STK_SIZE)MSGDIS_STK_SIZE/<span class="hljs-number">10</span>,<br>             (CPU_STK_SIZE)MSGDIS_STK_SIZE,<br>             (OS_MSG_QTY  )TASK_Q_NUM,<span class="hljs-comment">//任务Msgdis_task需要使用内建消息队列，消息队列长度为4</span><br>             (OS_TICK  )<span class="hljs-number">0</span>,  <br>             (<span class="hljs-type">void</span>   * )<span class="hljs-number">0</span>,<br>             (OS_OPT      )OS_OPT_TASK_STK_CHK|OS_OPT_TASK_STK_CLR,<br>             (OS_ERR * )&amp;err);<br><br></code></pre></td></tr></table></figure><ul><li>注意看 OS_MSG_QTY 正常时其设置为0  使用内建消息队列将之设置成对应的数量即可</li></ul><h2 id="事件标志组"><a href="#事件标志组" class="headerlink" title="事件标志组"></a>事件标志组</h2><p>​       在UCOSIII中事件标志组为OS_FLAG_GRP，如果需要使用事件标志组的时候需要将宏OS_CFG_FLAG_EN置1，</p><table><thead><tr><th><strong>函数名</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><strong>OSFlagCreate()</strong></td><td><strong>创建事件标志组</strong></td></tr><tr><td>OSFlagDel()</td><td>删除事件标志组</td></tr><tr><td><strong>OSFlagPend()</strong></td><td><strong>等待事件标志组</strong></td></tr><tr><td>OSFlagPendAbort()</td><td>取消等待事件标志</td></tr><tr><td>OSFlagPendGetFlagsRdy()</td><td>获取使任务就绪的事件标志</td></tr><tr><td><strong>OSFlagPost()</strong></td><td><strong>向事件标志组发布标志</strong></td></tr></tbody></table><h2 id="同时等待多个内核对象"><a href="#同时等待多个内核对象" class="headerlink" title="同时等待多个内核对象"></a>同时等待多个内核对象</h2><p>​在UCOSIII中允许任务同时等待多个<strong>信号量</strong>和多个<strong>消息队列</strong>，也就是说，UCOSIII不支持同时等待多个事件标志组或互斥信号量。</p><p>​    一个任务可以等待任意数量的信号量和消息队列，第一个信号量或消息队列的发布会导致该任务进入就绪态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">OS_OBJ_QTY  <span class="hljs-title function_">OSPendMulti</span> <span class="hljs-params">(OS_PEND_DATA  *p_pend_data_tbl,</span><br><span class="hljs-params">                         OS_OBJ_QTY     tbl_size,</span><br><span class="hljs-params">                         OS_TICK        timeout,</span><br><span class="hljs-params">                         OS_OPT         opt,</span><br><span class="hljs-params">                         OS_ERR        *p_err)</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">OS_SEMTest_Sem1;<span class="hljs-comment">//信号量1</span><br>OS_SEMTest_Sem2;<span class="hljs-comment">//信号量2</span><br>OS_QTest_Q;<span class="hljs-comment">//消息队列</span><br><br>OS_PEND_DATA pend_multi_tbl[CORE_OBJ_NUM];<br><br>pend_multi_tbl[<span class="hljs-number">0</span>].PendObjPtr=(OS_PEND_OBJ*)&amp;Test_Sem1;<br>pend_multi_tbl[<span class="hljs-number">1</span>].PendObjPtr=(OS_PEND_OBJ*)&amp;Test_Sem2;<br>pend_multi_tbl[<span class="hljs-number">2</span>].PendObjPtr=(OS_PEND_OBJ*)&amp;Test_Q;<br></code></pre></td></tr></table></figure><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2>]]></content>
    
    
    <categories>
      
      <category>RTOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RTOS</tag>
      
      <tag>UCOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Modbus</title>
    <link href="/2020/7d358aa2/"/>
    <url>/2020/7d358aa2/</url>
    
    <content type="html"><![CDATA[<h1 id="Modbus"><a href="#Modbus" class="headerlink" title="Modbus"></a>Modbus</h1><p><a href="https://wenku.baidu.com/view/ef2f8bfe81eb6294dd88d0d233d4b14e85243e3a.html">百度文库 MODBUS协议最简单又是最直白的解释</a></p><ul><li><p>分为RTU（发Hex）模式和ASCII（发字符）模式</p></li><li><p>从机地址 0-247 （其中0为广播地址）</p></li><li><p>通信格式</p></li><li><p><strong>ASCII</strong></p><p>起始符+<strong>设备地址(1Byte)+功能码(1Byte)+数据(nByte n&lt;253)+校验(2Byte LRC)</strong>+结束符</p><ul><li>起始符——ASCII的起始符为‘:’一个冒号</li><li>设备地址——0-247</li><li>功能码——见下文</li><li>数据——略</li><li>校验——<strong>起始符 和 校验符</strong>  之间的所有数据        一般用LRC校验</li><li>结束符——Chr$（13）+Chr（10）</li><li>例—— : (起)    02(地址) 03(功能) 0a00(数据) 0004(校验)    Chr$(13)Chr(10)(终)</li><li>设备地址、功能码、数据、校验 都是用的十六进制的字符形式 例如发送0x16就发送“16”</li></ul></li><li><p><strong>RTU</strong></p><p>起始符+<strong>设备地址(1Byte)+功能码(1Byte)+数据(nByte n&lt;253)+校验(2Byte CRC16)</strong>+结束符</p><ul><li>起始符——3.5个字符的时间间隔</li><li>设备地址——0-247</li><li>功能码——见下文</li><li>数据——略</li><li>校验——<strong>起始符 和 校验符</strong>  之间的所有数据        一般用CRC16校验</li><li>结束符——3.5个字符的时间间隔</li></ul></li></ul><h1 id="功能表"><a href="#功能表" class="headerlink" title="功能表"></a>功能表</h1><table><thead><tr><th align="center">功能码</th><th>名称</th><th>作用</th></tr></thead><tbody><tr><td align="center">1</td><td>读取线圈状态</td><td>取得一组逻辑线圈的当前状态（ON&#x2F;OFF)</td></tr><tr><td align="center">2</td><td>读取输入状态</td><td>取得一组开关输入的当前状态（ON&#x2F;OFF)</td></tr><tr><td align="center">3</td><td>读取保持寄存器</td><td>在一个或多个保持寄存器中取得当前的二进制值</td></tr><tr><td align="center">4</td><td>读取输入寄存器</td><td>在一个或多个输入寄存器中取得当前的二进制值</td></tr><tr><td align="center">5</td><td>强置单线圈</td><td>强置一个逻辑线圈的通断状态</td></tr><tr><td align="center">6</td><td>预置单寄存器</td><td>把具体二进值装入一个保持寄存器</td></tr><tr><td align="center">7</td><td>读取异常状态</td><td>取得8个内部线圈的通断状态，这8个线圈的地址由控制器决定</td></tr><tr><td align="center">8</td><td>回送诊断校验</td><td>把诊断校验报文送从机，以对通信处理进行评鉴</td></tr><tr><td align="center">9</td><td>编程（只用于484）</td><td>使主机模拟编程器作用，修改PC从机逻辑</td></tr><tr><td align="center">10</td><td>控询（只用于484）</td><td>可使主机与一台正在执行长程序任务从机通信，探询该从机是否已完成其操作任务，仅在含有功能码9的报文发送后，本功能码才发送</td></tr><tr><td align="center">11</td><td>读取事件计数</td><td>可使主机发出单询问，并随即判定操作是否成功，尤其是该命令或其他应答产生通信错误时</td></tr><tr><td align="center">12</td><td>读取通信事件记录</td><td>可是主机检索每台从机的ModBus事务处理通信事件记录。如果某项事务处理完成，记录会给出有关错误</td></tr><tr><td align="center">13</td><td>编程（184&#x2F;384 484 584）</td><td>可使主机模拟编程器功能修改PC从机逻辑</td></tr><tr><td align="center">14</td><td>探询（184&#x2F;384 484 584）</td><td>可使主机与正在执行任务的从机通信，定期控询该从机是否已完成其程序操作，仅在含有功能13的报文发送后，本功能码才得发送</td></tr><tr><td align="center">15</td><td>强置多线圈</td><td>强置一串连续逻辑线圈的通断</td></tr><tr><td align="center">16</td><td>预置多寄存器</td><td>把具体的二进制值装入一串连续的保持寄存器</td></tr><tr><td align="center">17</td><td>报告从机标识</td><td>可使主机判断编址从机的类型及该从机运行指示灯的状态</td></tr><tr><td align="center">18</td><td>（884和MICRO 84）</td><td>可使主机模拟编程功能，修改PC状态逻辑</td></tr><tr><td align="center">19</td><td>重置通信链路</td><td>发生非可修改错误后，是从机复位于已知状态，可重置顺序字节</td></tr><tr><td align="center">20</td><td>读取通用参数（584L）</td><td>显示扩展存储器文件中的数据信息</td></tr><tr><td align="center">21</td><td>写入通用参数（584L）</td><td>把通用参数写入扩展存储文件，或修改之</td></tr><tr><td align="center">22～64</td><td>保留作扩展功能备用</td><td></td></tr><tr><td align="center">65～72</td><td>保留以备用户功能所用</td><td>留作用户功能的扩展编码</td></tr><tr><td align="center">73～119</td><td>非法功能</td><td></td></tr><tr><td align="center">120～127</td><td>保留</td><td>留作内部作用</td></tr><tr><td align="center">128～255</td><td>保留</td><td>用于异常应答</td></tr></tbody></table><h2 id="0x01-读取线圈状态（数字量）"><a href="#0x01-读取线圈状态（数字量）" class="headerlink" title="0x01 读取线圈状态（数字量）"></a>0x01 读取线圈状态（数字量）</h2><p><strong>0x01号命令，读取一个或多个    可读写数字量寄存器    （读取线圈状态）：</strong></p><table><thead><tr><th>设备地址+功能码</th><th>起始地址高八位+低八位</th><th>读取寄存器数量高八位+低八位</th><th>CRC16</th></tr></thead><tbody><tr><td>0x11+0x01</td><td>0x00+0x13</td><td>0x00+0x25</td><td>高8+低8</td></tr></tbody></table><p><strong>意义如下：</strong></p><ol><li>设备地址与功能码：在一个485总线上可以挂接多个设备，此处的设备地址表示想和哪一个设备通讯。例子中为想和0x11通讯。读取数字量的命令号固定为0x01。</li><li>起始地址高8位、低8位：表示想读取的开关量的起始地址(起始地址为0)。比如例子中的起始地址为0x0013。</li><li>寄存器数高8位、低8位：表示从起始地址开始读多少个开关量。例子中为37(0x0025)个开关量。</li><li>CRC校验：是从开头一直校验到此之前。</li></ol><p><strong>设备响应</strong>：</p><table><thead><tr><th>设备地址+功能码</th><th>返回的字节个数</th><th>返回的数据1+数据2+….+数据n</th><th>CRC16</th></tr></thead><tbody><tr><td>0x11+0x01</td><td>0x05</td><td>0xcd+0x6b+0xb2+0x0e+0x1b</td><td>高8+低8</td></tr></tbody></table><p><strong>意义如下：</strong></p><ol><li><p>设备地址与功能码：上同，0x01。</p></li><li><p>返回的字节个数：表示数据的字节个数，也就是数据的n的值。</p></li><li><p>数据1…n：由于每一个数据是一个8位的数，所以每一个数据表示8个开关量的值，每一位为0表示对应的开关断开，为1表示闭合。</p><p><strong>如果询问的开关量不是8的整倍数，那么最后一个字节的高位部分无意义，置为0。</strong></p></li><li><p>CRC校验同上。</p></li></ol><h2 id="0x05强制单线圈（写一个开关数字量）"><a href="#0x05强制单线圈（写一个开关数字量）" class="headerlink" title="0x05强制单线圈（写一个开关数字量）"></a>0x05强制单线圈（写一个开关数字量）</h2><p><strong>0x05号命令，写一个数字量（强制单线圈） 可广播：</strong></p><table><thead><tr><th>设备地址+功能码</th><th>需操作的寄存器地址高8位+低8位</th><th>需操作的寄存器数据高8位+低8位</th><th>CRC16</th></tr></thead><tbody><tr><td>0x11+0x05</td><td>0x00+0xac</td><td>0xff+0x00</td><td>高8+低8</td></tr></tbody></table><p><strong>意义如下：</strong></p><ol><li><p>设备地址与功能码：上同，0x05。</p></li><li><p>需下置的寄存器地址高8位，低8位：表明了需要置位（操作）的开关的地址。</p></li><li><p>置位（操作）的数据高8位，低8位：表明需要置位的开关量的状态。例子中为把该开关闭合。</p><p><strong>注意，此处只可以是[FF][00]表示ON状态 闭合      [00][00]表示OFF状态 断开，其他数值非法。</strong></p></li><li><p>注意此命令一条只能下置一个开关量的状态。</p></li></ol><p><strong>设备响应：</strong></p><ol><li>如果成功把计算机发送的命令原样返回，否则不响应。</li></ol><h2 id="0x03读取保持寄存器（模拟量）"><a href="#0x03读取保持寄存器（模拟量）" class="headerlink" title="0x03读取保持寄存器（模拟量）"></a>0x03读取保持寄存器（模拟量）</h2><p><strong>0x03号命令，读可读写模拟量寄存器（保持寄存器）：</strong></p><table><thead><tr><th>设备地址+功能码</th><th>起始寄存器地址高8位+低8位</th><th>读取的寄存器数量高8位+低8位</th><th>CRC16</th></tr></thead><tbody><tr><td>0x11+0x03</td><td>0x00+0x6b</td><td>0x00+0x03</td><td>高8+低8</td></tr></tbody></table><p><strong>意义如下：</strong></p><ol><li>设备地址与功能码：上同，0x03。</li><li>起始地址高8位、低8位：表示想读取的模拟量的起始地址(起始地址为0)。比如例子中的起始地址为0x006b。</li><li>寄存器数高8位、低8位：表示从起始地址开始读多少个模拟量。例子中为3个模拟量。注意，在返回的信息中一个模拟量需要返回两个字节。</li></ol><p><strong>设备响应：</strong></p><table><thead><tr><th>设备地址+功能码</th><th>返回的字节个数</th><th>返回的数据1+数据2+….+数据n</th><th>CRC16</th></tr></thead><tbody><tr><td>0x11+0x03</td><td>0x06</td><td>0x02+0x2b+0x00+0x00+0x00+0x64</td><td>高8+低8</td></tr></tbody></table><p><strong>意义如下：</strong></p><ol><li>设备地址与功能码：上同，0x03。</li><li>返回的字节个数：表示数据的字节个数，也就是数据1，2…n中的n的值。例子中返回了3个模拟量的数据，因为一个模拟量需要2个字节所以共6个字节。</li><li>数据1…n：[数据1][数据2]分别是第1个模拟量的高8位和低8位，[数据3][数据4]是第2个模拟量的高8位和低8位，以此类推。例子中返回的值分别是555，0，100。</li></ol><h2 id="0x06预置单寄存器（写一个模拟量）"><a href="#0x06预置单寄存器（写一个模拟量）" class="headerlink" title="0x06预置单寄存器（写一个模拟量）"></a>0x06预置单寄存器（写一个模拟量）</h2><p><strong>0x06号命令，写单个模拟量寄存器（保持寄存器）：</strong></p><table><thead><tr><th>设备地址+功能码</th><th>需操作的寄存器地址高8位+低8位</th><th>需操作的寄存器数据高8位+低8位</th><th>CRC16</th></tr></thead><tbody><tr><td>0x11+0x06</td><td>0x00+0x01</td><td>0x00+0x03</td><td>高8+低8</td></tr></tbody></table><p><strong>意义如下：</strong></p><ol><li>设备地址与功能码：上同，0x06。</li><li>需下置的寄存器地址高8位，低8位：表明了需要下置的模拟量寄存器的地址。</li><li>下置的数据高8位，低8位：表明需要下置的模拟量数据。比如例子中就把1号寄存器的值设为3。</li><li>注意此命令一条只能下置一个模拟量的状态。</li></ol><p><strong>设备响应：</strong></p><p>如果成功把计算机发送的命令原样返回，否则不响应。</p><h2 id="0x16-预置多寄存器（写多个模拟量）"><a href="#0x16-预置多寄存器（写多个模拟量）" class="headerlink" title="0x16 预置多寄存器（写多个模拟量）"></a>0x16 预置多寄存器（写多个模拟量）</h2><p><strong>0x16号命令，写多个模拟量寄存器（保持寄存器）：</strong></p><table><thead><tr><th>设备地址+功能码</th><th>需操作的地址高8位+低8位</th><th>需操作数据的数量高8位+低8位</th><th>操作的数据1 高8位+低8位</th></tr></thead><tbody><tr><td>0x11+0x16</td><td>0x00+0x01</td><td>0x00+0x01</td><td>0x00+0x05</td></tr><tr><td>操作的数据2 高8位+低8位</td><td>………</td><td>操作的数据n 高8位+低8位</td><td>CRC16</td></tr><tr><td></td><td></td><td></td><td>高8+低8</td></tr></tbody></table><p><strong>意义如下：</strong></p><ol><li>设备地址与功能码：上同，0x16。</li><li>需下置的寄存器地址高8位，低8位：表明了需要下置的模拟量寄存器的地址。</li><li>需下置的数据数量高8位，低8位：表明了需要下置的数据数量，这里为1。</li><li>下置的数据高8位，低8位：表明需要下置的模拟量数据。比如例子中就把1号寄存器的值设为5。</li></ol><p><strong>设备响应：</strong></p><p>如果成功把计算机返回的如下命令，否则不响应。</p><table><thead><tr><th>设备地址+功能码</th><th>需操作的寄存器地址高8位+低8位</th><th>需操作的寄存器数量高8位+低8位</th><th>CRC16</th></tr></thead><tbody><tr><td>0x11+0x16</td><td>0x00+0x01</td><td>0x00+0x01</td><td>高8+低8</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Communication</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
      <tag>Modbus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PID算法</title>
    <link href="/2019/14ee3806/"/>
    <url>/2019/14ee3806/</url>
    
    <content type="html"><![CDATA[<h2 id="PID算法笔记"><a href="#PID算法笔记" class="headerlink" title="PID算法笔记"></a>PID算法笔记</h2><p>位式控制算法，只考虑当前值，控制量有惯性，比较僵硬</p><h3 id="P–比例算法"><a href="#P–比例算法" class="headerlink" title="P–比例算法"></a>P–比例算法</h3><ul><li>只考虑现在的误差</li></ul><p>E<sub>k</sub> &#x3D; S<sub>V</sub> - X<sub>k</sub>(E<sub>k</sub>差值  S<sub>v</sub>期望值  X<sub>k</sub>当前值)</p><p>单纯的P控制算法：P<sub>out</sub>&#x3D;K<sub>p</sub> * E<sub>k</sub> ( P<sub>out</sub>输出的控制量  K<sub>p</sub>控制量  E<sub>k</sub>差值)</p><p><strong>单纯的P控制算法当前误差等于零后不控制</strong></p><p>P<sub>out</sub>&#x3D;K<sub>p</sub> * E<sub>k</sub>+OUT<sub>0</sub>(OUT<sub>0</sub>是一个常数维持静态误差)</p><hr><h3 id="I–积分算法"><a href="#I–积分算法" class="headerlink" title="I–积分算法"></a>I–积分算法</h3><ul><li>根据历史误差控制</li></ul><p>E<sub>1</sub>, E<sub>2</sub>, E<sub>3</sub>, E<sub>4</sub>, E<sub>5</sub>, ……….. E<sub>k</sub>  (E<sub>k</sub>差值)</p><p>S<sub>k</sub>&#x3D;E<sub>1</sub>+ E<sub>2</sub>+ E<sub>3</sub>+ E<sub>4</sub>+ E<sub>5</sub>+ ……….. +E<sub>k</sub>    (S<sub>k</sub> 误差和即积分)</p><p>I<sub>out</sub>&#x3D;K<sub>p</sub> * S<sub>k</sub> (I<sub>out</sub>输出的控制量  K<sub>p</sub>控制量)</p><p><strong>单纯的I控制算法历史误差等于零后不控制（当前误差可能很大）</strong></p><p>I<sub>out</sub>&#x3D;K<sub>p</sub> * S<sub>k</sub> +OUT<sub>0</sub>(OUT<sub>0</sub>是一个常数维持静态误差)</p><hr><h3 id="D–微分算法"><a href="#D–微分算法" class="headerlink" title="D–微分算法"></a>D–微分算法</h3><ul><li>考察最近变化趋势进行控制</li></ul><p>D<sub>k</sub>&#x3D;E<sub>k</sub> - E<sub>k-1</sub></p><p>D<sub>out</sub>&#x3D;K<sub>p</sub> * D<sub>k</sub> </p><hr><hr><hr><h2 id="Proportion-比例"><a href="#Proportion-比例" class="headerlink" title="Proportion (比例)"></a>Proportion (比例)</h2><p>误差越大，反馈越大</p><p>过小时系统反应很慢，过大时会产生振荡</p><ul><li>开环增益越大，稳态误差减小（无法消除，属于有差调节）</li><li>过渡时间缩短</li><li>稳定程度变差</li></ul><h2 id="Integral（积分）"><a href="#Integral（积分）" class="headerlink" title="Integral（积分）"></a>Integral（积分）</h2><p>误差持续越久，反馈越大</p><p>第一次到达目标会产生过冲，超调</p><p>积分求位置误差</p><ul><li>消除系统稳态误差（能够消除静态误差，属于无差调节）</li><li>稳定程度变差</li></ul><h2 id="Differential（微分）"><a href="#Differential（微分）" class="headerlink" title="Differential（微分）"></a>Differential（微分）</h2><p>误差变化率越大，反馈越大</p><p>根据以前的变化率预测未来的变化率</p><p>过大时会拖慢系统响应速度</p><p>提高响应速度，减少震荡</p><ul><li>减小超调量</li><li>减小调节时间（与P控制相比较而言）</li><li>增强系统稳定性</li><li>增加系统阻尼程度</li></ul><h2 id="PID总结"><a href="#PID总结" class="headerlink" title="PID总结"></a>PID总结</h2><ul><li><strong>稳定性</strong>（P和I降低系统稳定性，D提高系统稳定性）：在平衡状态下，系统受到某个干扰后，经过一段时间其被控量可以达到某一稳定状态；</li><li><strong>准确性</strong>（P和I提高稳态精度，D无作用）：系统处于稳态时，其稳态误差；</li><li><strong>快速性</strong>（P和D提高响应速度，I降低响应速度）：系统对动态响应的要求。一般由过渡时间的长短来衡量。</li></ul>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PID</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构</title>
    <link href="/2019/79666db/"/>
    <url>/2019/79666db/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="C语言打印运行时间"><a href="#C语言打印运行时间" class="headerlink" title="C语言打印运行时间"></a>C语言打印运行时间</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;time.h&gt;</span></span><br><span class="hljs-type">time_t</span> start, stop;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    start = clock();<span class="hljs-comment">//滴答时钟</span><br>    <span class="hljs-comment">//运行的函数</span><br>    stop = clock();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf----%lf\r\n&quot;</span>, (<span class="hljs-type">double</span>)(stop-start),(<span class="hljs-type">double</span>)(stop-start)/CLK_TCK);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="尾递归可以优化成For"><a href="#尾递归可以优化成For" class="headerlink" title="尾递归可以优化成For"></a>尾递归可以优化成For</h2><p>尾递归：程序返回时才发生递归。</p><h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h2 id="1-3-应用实例：最大子列和问题"><a href="#1-3-应用实例：最大子列和问题" class="headerlink" title="1.3 应用实例：最大子列和问题"></a>1.3 应用实例：最大子列和问题</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">Max3</span><span class="hljs-params">( <span class="hljs-type">int</span> A, <span class="hljs-type">int</span> B, <span class="hljs-type">int</span> C )</span><br>&#123; <span class="hljs-comment">/* 返回3个整数中的最大值 */</span><br>    <span class="hljs-keyword">return</span> A &gt; B ? A &gt; C ? A : C : B &gt; C ? B : C;<br>&#125;<br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">DivideAndConquer</span><span class="hljs-params">( <span class="hljs-type">int</span> List[], <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right )</span><br>&#123; <span class="hljs-comment">/* 分治法求List[left]到List[right]的最大子列和 */</span><br>    <span class="hljs-type">int</span> MaxLeftSum, MaxRightSum; <span class="hljs-comment">/* 存放左右子问题的解 */</span><br>    <span class="hljs-type">int</span> MaxLeftBorderSum, MaxRightBorderSum; <span class="hljs-comment">/*存放跨分界线的结果*/</span><br> <br>    <span class="hljs-type">int</span> LeftBorderSum, RightBorderSum;<br>    <span class="hljs-type">int</span> center, i;<br> <br>    <span class="hljs-keyword">if</span>( left == right )  &#123; <span class="hljs-comment">/* 递归的终止条件，子列只有1个数字 */</span><br>        <span class="hljs-keyword">if</span>( List[left] &gt; <span class="hljs-number">0</span> )  <span class="hljs-keyword">return</span> List[left];<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br> <br>    <span class="hljs-comment">/* 下面是&quot;分&quot;的过程 */</span><br>    center = ( left + right ) / <span class="hljs-number">2</span>; <span class="hljs-comment">/* 找到中分点 */</span><br>    <span class="hljs-comment">/* 递归求得两边子列的最大和 */</span><br>    MaxLeftSum = DivideAndConquer( List, left, center );<br>    MaxRightSum = DivideAndConquer( List, center+<span class="hljs-number">1</span>, right );<br> <br>    <span class="hljs-comment">/* 下面求跨分界线的最大子列和 */</span><br>    MaxLeftBorderSum = <span class="hljs-number">0</span>; LeftBorderSum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>( i=center; i&gt;=left; i-- ) &#123; <span class="hljs-comment">/* 从中线向左扫描 */</span><br>        LeftBorderSum += List[i];<br>        <span class="hljs-keyword">if</span>( LeftBorderSum &gt; MaxLeftBorderSum )<br>            MaxLeftBorderSum = LeftBorderSum;<br>    &#125; <span class="hljs-comment">/* 左边扫描结束 */</span><br> <br>    MaxRightBorderSum = <span class="hljs-number">0</span>; RightBorderSum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>( i=center+<span class="hljs-number">1</span>; i&lt;=right; i++ ) &#123; <span class="hljs-comment">/* 从中线向右扫描 */</span><br>        RightBorderSum += List[i];<br>        <span class="hljs-keyword">if</span>( RightBorderSum &gt; MaxRightBorderSum )<br>            MaxRightBorderSum = RightBorderSum;<br>    &#125; <span class="hljs-comment">/* 右边扫描结束 */</span><br> <br>    <span class="hljs-comment">/* 下面返回&quot;治&quot;的结果 */</span><br>    <span class="hljs-keyword">return</span> Max3( MaxLeftSum, MaxRightSum, MaxLeftBorderSum + MaxRightBorderSum );<br>&#125;<br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">MaxSubseqSum3</span><span class="hljs-params">( <span class="hljs-type">int</span> List[], <span class="hljs-type">int</span> N )</span><br>&#123; <span class="hljs-comment">/* 保持与前2种算法相同的函数接口 */</span><br>    <span class="hljs-keyword">return</span> DivideAndConquer( List, <span class="hljs-number">0</span>, N<span class="hljs-number">-1</span> );<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第二章-线性结构"><a href="#第二章-线性结构" class="headerlink" title="第二章 线性结构"></a>第二章 线性结构</h1><h2 id="2-1-线性表及其实现"><a href="#2-1-线性表及其实现" class="headerlink" title="2.1 线性表及其实现"></a>2.1 线性表及其实现</h2><h3 id="数组实现"><a href="#数组实现" class="headerlink" title="数组实现"></a>数组实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Position;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">List</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> &#123;</span><br>    ElementType Data[MAXSIZE];<br>    Position Last;<br>&#125;;<br> <br><span class="hljs-comment">/* 初始化 */</span><br>List <span class="hljs-title function_">MakeEmpty</span><span class="hljs-params">()</span><br>&#123;<br>    List L;<br> <br>    L = (List)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> LNode));<br>    L-&gt;Last = <span class="hljs-number">-1</span>;<br> <br>    <span class="hljs-keyword">return</span> L;<br>&#125;<br> <br><span class="hljs-comment">/* 查找 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR -1</span><br> <br>Position <span class="hljs-title function_">Find</span><span class="hljs-params">( List L, ElementType X )</span><br>&#123;<br>    Position i = <span class="hljs-number">0</span>;<br> <br>    <span class="hljs-keyword">while</span>( i &lt;= L-&gt;Last &amp;&amp; L-&gt;Data[i]!= X )<br>        i++;<br>    <span class="hljs-keyword">if</span> ( i &gt; L-&gt;Last )  <span class="hljs-keyword">return</span> ERROR; <span class="hljs-comment">/* 如果没找到，返回错误信息 */</span><br>    <span class="hljs-keyword">else</span>  <span class="hljs-keyword">return</span> i;  <span class="hljs-comment">/* 找到后返回的是存储位置 */</span><br>&#125;<br> <br><span class="hljs-comment">/* 插入 */</span><br><span class="hljs-comment">/*注意:在插入位置参数P上与课程视频有所不同，课程视频中i是序列位序（从1开始），这里P是存储下标位置（从0开始），两者差1*/</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">Insert</span><span class="hljs-params">( List L, ElementType X, Position P )</span> <br>&#123; <span class="hljs-comment">/* 在L的指定位置P前插入一个新元素X */</span><br>    Position i;<br> <br>    <span class="hljs-keyword">if</span> ( L-&gt;Last == MAXSIZE<span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-comment">/* 表空间已满，不能插入 */</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;表满&quot;</span>); <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>    &#125;  <br>    <span class="hljs-keyword">if</span> ( P&lt;<span class="hljs-number">0</span> || P&gt;L-&gt;Last+<span class="hljs-number">1</span> ) &#123; <span class="hljs-comment">/* 检查插入位置的合法性 */</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;位置不合法&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>    &#125; <br>    <span class="hljs-keyword">for</span>( i=L-&gt;Last; i&gt;=P; i-- )<br>        L-&gt;Data[i+<span class="hljs-number">1</span>] = L-&gt;Data[i]; <span class="hljs-comment">/* 将位置P及以后的元素顺序向后移动 */</span><br>    L-&gt;Data[P] = X;  <span class="hljs-comment">/* 新元素插入 */</span><br>    L-&gt;Last++;       <span class="hljs-comment">/* Last仍指向最后元素 */</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <br>&#125; <br> <br><span class="hljs-comment">/* 删除 */</span><br><span class="hljs-comment">/*注意:在删除位置参数P上与课程视频有所不同，课程视频中i是序列位序（从1开始），这里P是存储下标位置（从0开始），两者差1*/</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">Delete</span><span class="hljs-params">( List L, Position P )</span><br>&#123; <span class="hljs-comment">/* 从L中删除指定位置P的元素 */</span><br>    Position i;<br> <br>    <span class="hljs-keyword">if</span>( P&lt;<span class="hljs-number">0</span> || P&gt;L-&gt;Last ) &#123; <span class="hljs-comment">/* 检查空表及删除位置的合法性 */</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;位置%d不存在元素&quot;</span>, P ); <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>    &#125;<br>    <span class="hljs-keyword">for</span>( i=P+<span class="hljs-number">1</span>; i&lt;=L-&gt;Last; i++ )<br>        L-&gt;Data[i<span class="hljs-number">-1</span>] = L-&gt;Data[i]; <span class="hljs-comment">/* 将位置P+1及以后的元素顺序向前移动 */</span><br>    L-&gt;Last--; <span class="hljs-comment">/* Last仍指向最后元素 */</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;   <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">PtrToLNode</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> &#123;</span><br>    ElementType Data;<br>    PtrToLNode Next;<br>&#125;;<br><span class="hljs-keyword">typedef</span> PtrToLNode Position;<br><span class="hljs-keyword">typedef</span> PtrToLNode List;<br> <br><span class="hljs-comment">/* 查找 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR NULL</span><br> <br>Position <span class="hljs-title function_">Find</span><span class="hljs-params">( List L, ElementType X )</span><br>&#123;<br>    Position p = L; <span class="hljs-comment">/* p指向L的第1个结点 */</span><br> <br>    <span class="hljs-keyword">while</span> ( p &amp;&amp; p-&gt;Data!=X )<br>        p = p-&gt;Next;<br> <br>    <span class="hljs-comment">/* 下列语句可以用 return p; 替换 */</span><br>    <span class="hljs-keyword">if</span> ( p )<br>        <span class="hljs-keyword">return</span> p;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> ERROR;<br>&#125;<br> <br><span class="hljs-comment">/* 带头结点的插入 */</span><br><span class="hljs-comment">/*注意:在插入位置参数P上与课程视频有所不同，课程视频中i是序列位序（从1开始），这里P是链表结点指针，在P之前插入新结点 */</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">Insert</span><span class="hljs-params">( List L, ElementType X, Position P )</span><br>&#123; <span class="hljs-comment">/* 这里默认L有头结点 */</span><br>    Position tmp, pre;<br> <br>    <span class="hljs-comment">/* 查找P的前一个结点 */</span>        <br>    <span class="hljs-keyword">for</span> ( pre=L; pre&amp;&amp;pre-&gt;Next!=P; pre=pre-&gt;Next ) ;            <br>    <span class="hljs-keyword">if</span> ( pre==<span class="hljs-literal">NULL</span> ) &#123; <span class="hljs-comment">/* P所指的结点不在L中 */</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;插入位置参数错误\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* 找到了P的前一个结点pre */</span><br>        <span class="hljs-comment">/* 在P前插入新结点 */</span><br>        tmp = (Position)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> LNode)); <span class="hljs-comment">/* 申请、填装结点 */</span><br>        tmp-&gt;Data = X; <br>        tmp-&gt;Next = P;<br>        pre-&gt;Next = tmp;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br> <br><span class="hljs-comment">/* 带头结点的删除 */</span><br><span class="hljs-comment">/*注意:在删除位置参数P上与课程视频有所不同，课程视频中i是序列位序（从1开始），这里P是拟删除结点指针 */</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">Delete</span><span class="hljs-params">( List L, Position P )</span><br>&#123; <span class="hljs-comment">/* 这里默认L有头结点 */</span><br>    Position tmp, pre;<br> <br>    <span class="hljs-comment">/* 查找P的前一个结点 */</span>        <br>    <span class="hljs-keyword">for</span> ( pre=L; pre&amp;&amp;pre-&gt;Next!=P; pre=pre-&gt;Next ) ;            <br>    <span class="hljs-keyword">if</span> ( pre==<span class="hljs-literal">NULL</span> || P==<span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">/* P所指的结点不在L中 */</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;删除位置参数错误\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* 找到了P的前一个结点pre */</span><br>        <span class="hljs-comment">/* 将P位置的结点删除 */</span><br>        pre-&gt;Next = P-&gt;Next;<br>        <span class="hljs-built_in">free</span>(P);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-2-堆栈"><a href="#2-2-堆栈" class="headerlink" title="2.2 堆栈"></a>2.2 堆栈</h2><h3 id="数组实现-1"><a href="#数组实现-1" class="headerlink" title="数组实现"></a>数组实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Position;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SNode</span> &#123;</span><br>    ElementType *Data; <span class="hljs-comment">/* 存储元素的数组 */</span><br>    Position Top;      <span class="hljs-comment">/* 栈顶指针 */</span><br>    <span class="hljs-type">int</span> MaxSize;       <span class="hljs-comment">/* 堆栈最大容量 */</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SNode</span> *<span class="hljs-title">Stack</span>;</span><br> <br>Stack <span class="hljs-title function_">CreateStack</span><span class="hljs-params">( <span class="hljs-type">int</span> MaxSize )</span><br>&#123;<br>    Stack S = (Stack)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> SNode));<br>    S-&gt;Data = (ElementType *)<span class="hljs-built_in">malloc</span>(MaxSize * <span class="hljs-keyword">sizeof</span>(ElementType));<br>    S-&gt;Top = <span class="hljs-number">-1</span>;<br>    S-&gt;MaxSize = MaxSize;<br>    <span class="hljs-keyword">return</span> S;<br>&#125;<br> <br><span class="hljs-type">bool</span> <span class="hljs-title function_">IsFull</span><span class="hljs-params">( Stack S )</span><br>&#123;<br>    <span class="hljs-keyword">return</span> (S-&gt;Top == S-&gt;MaxSize<span class="hljs-number">-1</span>);<br>&#125;<br> <br><span class="hljs-type">bool</span> <span class="hljs-title function_">Push</span><span class="hljs-params">( Stack S, ElementType X )</span><br>&#123;<br>    <span class="hljs-keyword">if</span> ( IsFull(S) ) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;堆栈满&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        S-&gt;Data[++(S-&gt;Top)] = X;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br> <br><span class="hljs-type">bool</span> <span class="hljs-title function_">IsEmpty</span><span class="hljs-params">( Stack S )</span><br>&#123;<br>    <span class="hljs-keyword">return</span> (S-&gt;Top == <span class="hljs-number">-1</span>);<br>&#125;<br> <br>ElementType <span class="hljs-title function_">Pop</span><span class="hljs-params">( Stack S )</span><br>&#123;<br>    <span class="hljs-keyword">if</span> ( IsEmpty(S) ) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;堆栈空&quot;</span>);<br>        <span class="hljs-keyword">return</span> ERROR; <span class="hljs-comment">/* ERROR是ElementType的特殊值，标志错误 */</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <br>        <span class="hljs-keyword">return</span> ( S-&gt;Data[(S-&gt;Top)--] );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="链表实现-1"><a href="#链表实现-1" class="headerlink" title="链表实现"></a>链表实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SNode</span> *<span class="hljs-title">PtrToSNode</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SNode</span> &#123;</span><br>    ElementType Data;<br>    PtrToSNode Next;<br>&#125;;<br><span class="hljs-keyword">typedef</span> PtrToSNode Stack;<br> <br>Stack <span class="hljs-title function_">CreateStack</span><span class="hljs-params">( )</span> <br>&#123; <span class="hljs-comment">/* 构建一个堆栈的头结点，返回该结点指针 */</span><br>    Stack S;<br> <br>    S = (Stack)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> SNode));<br>    S-&gt;Next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> S;<br>&#125;<br> <br><span class="hljs-type">bool</span> <span class="hljs-title function_">IsEmpty</span> <span class="hljs-params">( Stack S )</span><br>&#123; <span class="hljs-comment">/* 判断堆栈S是否为空，若是返回true；否则返回false */</span><br>    <span class="hljs-keyword">return</span> ( S-&gt;Next == <span class="hljs-literal">NULL</span> );<br>&#125;<br> <br><span class="hljs-type">bool</span> <span class="hljs-title function_">Push</span><span class="hljs-params">( Stack S, ElementType X )</span><br>&#123; <span class="hljs-comment">/* 将元素X压入堆栈S */</span><br>    PtrToSNode TmpCell;<br> <br>    TmpCell = (PtrToSNode)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> SNode));<br>    TmpCell-&gt;Data = X;<br>    TmpCell-&gt;Next = S-&gt;Next;<br>    S-&gt;Next = TmpCell;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br> <br>ElementType <span class="hljs-title function_">Pop</span><span class="hljs-params">( Stack S )</span>  <br>&#123; <span class="hljs-comment">/* 删除并返回堆栈S的栈顶元素 */</span><br>    PtrToSNode FirstCell;<br>    ElementType TopElem;<br> <br>    <span class="hljs-keyword">if</span>( IsEmpty(S) ) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;堆栈空&quot;</span>); <br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        FirstCell = S-&gt;Next; <br>        TopElem = FirstCell-&gt;Data;<br>        S-&gt;Next = FirstCell-&gt;Next;<br>        <span class="hljs-built_in">free</span>(FirstCell);<br>        <span class="hljs-keyword">return</span> TopElem;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-3-队列"><a href="#2-3-队列" class="headerlink" title="2.3 队列"></a>2.3 队列</h2><h3 id="数组实现-2"><a href="#数组实现-2" class="headerlink" title="数组实现"></a>数组实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Position;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> &#123;</span><br>    ElementType *Data;     <span class="hljs-comment">/* 存储元素的数组 */</span><br>    Position Front, Rear;  <span class="hljs-comment">/* 队列的头、尾指针 */</span><br>    <span class="hljs-type">int</span> MaxSize;           <span class="hljs-comment">/* 队列最大容量 */</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> *<span class="hljs-title">Queue</span>;</span><br> <br>Queue <span class="hljs-title function_">CreateQueue</span><span class="hljs-params">( <span class="hljs-type">int</span> MaxSize )</span><br>&#123;<br>    Queue Q = (Queue)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> QNode));<br>    Q-&gt;Data = (ElementType *)<span class="hljs-built_in">malloc</span>(MaxSize * <span class="hljs-keyword">sizeof</span>(ElementType));<br>    Q-&gt;Front = Q-&gt;Rear = <span class="hljs-number">0</span>;<br>    Q-&gt;MaxSize = MaxSize;<br>    <span class="hljs-keyword">return</span> Q;<br>&#125;<br> <br><span class="hljs-type">bool</span> <span class="hljs-title function_">IsFull</span><span class="hljs-params">( Queue Q )</span><br>&#123;<br>    <span class="hljs-keyword">return</span> ((Q-&gt;Rear+<span class="hljs-number">1</span>)%Q-&gt;MaxSize == Q-&gt;Front);<br>&#125;<br> <br><span class="hljs-type">bool</span> <span class="hljs-title function_">AddQ</span><span class="hljs-params">( Queue Q, ElementType X )</span><br>&#123;<br>    <span class="hljs-keyword">if</span> ( IsFull(Q) ) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;队列满&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        Q-&gt;Rear = (Q-&gt;Rear+<span class="hljs-number">1</span>)%Q-&gt;MaxSize;<br>        Q-&gt;Data[Q-&gt;Rear] = X;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br> <br><span class="hljs-type">bool</span> <span class="hljs-title function_">IsEmpty</span><span class="hljs-params">( Queue Q )</span><br>&#123;<br>    <span class="hljs-keyword">return</span> (Q-&gt;Front == Q-&gt;Rear);<br>&#125;<br> <br>ElementType <span class="hljs-title function_">DeleteQ</span><span class="hljs-params">( Queue Q )</span><br>&#123;<br>    <span class="hljs-keyword">if</span> ( IsEmpty(Q) ) &#123; <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;队列空&quot;</span>);<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-keyword">else</span>  &#123;<br>        Q-&gt;Front =(Q-&gt;Front+<span class="hljs-number">1</span>)%Q-&gt;MaxSize;<br>        <span class="hljs-keyword">return</span>  Q-&gt;Data[Q-&gt;Front];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="链表实现-2"><a href="#链表实现-2" class="headerlink" title="链表实现"></a>链表实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">PtrToNode</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span> <span class="hljs-comment">/* 队列中的结点 */</span><br>    ElementType Data;<br>    PtrToNode Next;<br>&#125;;<br><span class="hljs-keyword">typedef</span> PtrToNode Position;<br> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> &#123;</span><br>    Position Front, Rear;  <span class="hljs-comment">/* 队列的头、尾指针 */</span><br>    <span class="hljs-type">int</span> MaxSize;           <span class="hljs-comment">/* 队列最大容量 */</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> *<span class="hljs-title">Queue</span>;</span><br> <br><span class="hljs-type">bool</span> <span class="hljs-title function_">IsEmpty</span><span class="hljs-params">( Queue Q )</span><br>&#123;<br>    <span class="hljs-keyword">return</span> ( Q-&gt;Front == <span class="hljs-literal">NULL</span>);<br>&#125;<br> <br>ElementType <span class="hljs-title function_">DeleteQ</span><span class="hljs-params">( Queue Q )</span><br>&#123;<br>    Position FrontCell; <br>    ElementType FrontElem;<br>     <br>    <span class="hljs-keyword">if</span>  ( IsEmpty(Q) ) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;队列空&quot;</span>);<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        FrontCell = Q-&gt;Front;<br>        <span class="hljs-keyword">if</span> ( Q-&gt;Front == Q-&gt;Rear ) <span class="hljs-comment">/* 若队列只有一个元素 */</span><br>            Q-&gt;Front = Q-&gt;Rear = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">/* 删除后队列置为空 */</span><br>        <span class="hljs-keyword">else</span>                     <br>            Q-&gt;Front = Q-&gt;Front-&gt;Next;<br>        FrontElem = FrontCell-&gt;Data;<br> <br>        <span class="hljs-built_in">free</span>( FrontCell );  <span class="hljs-comment">/* 释放被删除结点空间  */</span><br>        <span class="hljs-keyword">return</span>  FrontElem;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第三章-树"><a href="#第三章-树" class="headerlink" title="第三章 树"></a>第三章 树</h1><h2 id="3-3-二叉树的遍历"><a href="#3-3-二叉树的遍历" class="headerlink" title="3.3 二叉树的遍历"></a>3.3 二叉树的遍历</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">InorderTraversal</span><span class="hljs-params">( BinTree BT )</span><br>&#123;<br>    <span class="hljs-keyword">if</span>( BT ) &#123;<br>        InorderTraversal( BT-&gt;Left );<br>        <span class="hljs-comment">/* 此处假设对BT结点的访问就是打印数据 */</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, BT-&gt;Data); <span class="hljs-comment">/* 假设数据为整型 */</span><br>        InorderTraversal( BT-&gt;Right );<br>    &#125;<br>&#125;<br> <br><span class="hljs-type">void</span> <span class="hljs-title function_">PreorderTraversal</span><span class="hljs-params">( BinTree BT )</span><br>&#123;<br>    <span class="hljs-keyword">if</span>( BT ) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, BT-&gt;Data );<br>        PreorderTraversal( BT-&gt;Left );<br>        PreorderTraversal( BT-&gt;Right );<br>    &#125;<br>&#125;<br> <br><span class="hljs-type">void</span> <span class="hljs-title function_">PostorderTraversal</span><span class="hljs-params">( BinTree BT )</span><br>&#123;<br>    <span class="hljs-keyword">if</span>( BT ) &#123;<br>        PostorderTraversal( BT-&gt;Left );<br>        PostorderTraversal( BT-&gt;Right );<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, BT-&gt;Data);<br>    &#125;<br>&#125;<br> <br><span class="hljs-type">void</span> <span class="hljs-title function_">LevelorderTraversal</span> <span class="hljs-params">( BinTree BT )</span><br>&#123; <br>    Queue Q; <br>    BinTree T;<br> <br>    <span class="hljs-keyword">if</span> ( !BT ) <span class="hljs-keyword">return</span>; <span class="hljs-comment">/* 若是空树则直接返回 */</span><br>     <br>    Q = CreatQueue(); <span class="hljs-comment">/* 创建空队列Q */</span><br>    AddQ( Q, BT );<br>    <span class="hljs-keyword">while</span> ( !IsEmpty(Q) ) &#123;<br>        T = DeleteQ( Q );<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, T-&gt;Data); <span class="hljs-comment">/* 访问取出队列的结点 */</span><br>        <span class="hljs-keyword">if</span> ( T-&gt;Left )   AddQ( Q, T-&gt;Left );<br>        <span class="hljs-keyword">if</span> ( T-&gt;Right )  AddQ( Q, T-&gt;Right );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>堆栈</tag>
      
      <tag>队列</tag>
      
      <tag>链表</tag>
      
      <tag>树</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

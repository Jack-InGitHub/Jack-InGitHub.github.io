<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>一些优秀的开源项目</title>
    <link href="/2024/9bf1668d/"/>
    <url>/2024/9bf1668d/</url>
    
    <content type="html"><![CDATA[<h1 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h1><h1 id="Net"><a href="#Net" class="headerlink" title="Net"></a>Net</h1><h3 id="Tinyhttpd（示例代码）"><a href="#Tinyhttpd（示例代码）" class="headerlink" title="Tinyhttpd（示例代码）"></a>Tinyhttpd（示例代码）</h3><p><strong>tinyhttpd</strong>是一个超轻量型Http Server，使用C语言开发，全部代码只有 502 行（包括注释），附带一个简单的 Client 可以通过阅读这段代码理解一个 Http Server 的本质。</p><blockquote><p>tinyhttpd 是我为学校项目编写的一个相对简单的网络服务器。虽然非常简单，但 tinyhttpd 是线程化的，可以处理基本的 CGI 脚本！这是一个用于演示 http 背后概念的教育工具。</p></blockquote><p><strong>项目地址</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">http://sourceforge.net/projects/tinyhttpd/<br></code></pre></td></tr></table></figure><h1 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h1><h2 id="CRC"><a href="#CRC" class="headerlink" title="CRC"></a>CRC</h2><h3 id="libcrc"><a href="#libcrc" class="headerlink" title="libcrc"></a>libcrc</h3><p>Libcrc - C 语言多平台 MIT 许可 CRC 库<br><a href="https://github.com/lammertb/libcrc">https://github.com/lammertb/libcrc</a></p><h2 id="cJSON"><a href="#cJSON" class="headerlink" title="cJSON"></a>cJSON</h2><p>Ultralightweight JSON parser in ANSI C.</p><p><a href="https://github.com/DaveGamble/cJSON">https://github.com/DaveGamble/cJSON</a></p><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><h3 id="Cmockery-单元测试框架"><a href="#Cmockery-单元测试框架" class="headerlink" title="Cmockery 单元测试框架"></a>Cmockery 单元测试框架</h3><p>Cmockery 是一个轻量级库，用于编写 C 单元测试。google 开发。</p><p><a href="https://github.com/google/cmockery">https://github.com/google/cmockery</a></p><h3 id="libev"><a href="#libev" class="headerlink" title="libev"></a>libev</h3><p>libev是一个全功能和高性能的事件循环库，libev 参考并模仿了libevent和perl模块Event。它用于GNU虚拟专用以太网、rxvt-unicode、auditd、Deliantra MORPG服务器和客户端以及许多其他程序。node.js曾经嵌入了libev，现在更换为了libuv。</p><p>其以高效出名，它可以将 IO 事件、定时器、和信号统一起来，统一放在事件处理这一套框架下处理。</p><p>基于 Reactor 模式，效率较高，并且代码精简（4.15 版本 8000 多行），是学习事件驱动编程的很好的资源。</p><p><a href="http://libev.schmorp.de/">http://libev.schmorp.de/</a><br><a href="https://github.com/enki/libev">https://github.com/enki/libev</a></p>]]></content>
    
    
    <categories>
      
      <category>embedded</category>
      
    </categories>
    
    
    <tags>
      
      <tag>embedded</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>音视频编解码</title>
    <link href="/2024/2f262a28/"/>
    <url>/2024/2f262a28/</url>
    
    <content type="html"><![CDATA[<h1 id="视频显示原理"><a href="#视频显示原理" class="headerlink" title="视频显示原理"></a>视频显示原理</h1><p>视频是利用人眼视觉暂留的原理，通过播放一系列的图片，使人眼产生运动的感觉。单纯传输视频画面，视频量非常大，对现有的网络和存储来说是不可接受的。为了能够使视频便于传输和存储，人们发现视频有大量重复的信息，如果将重复信息在发送端去掉，在接收端恢复出来，这样就大大减少了视频数据的文件，因此有了各种视频压缩标准。</p><h1 id="视频编码"><a href="#视频编码" class="headerlink" title="视频编码"></a>视频编码</h1><p><a href="https://www.cnblogs.com/yongdaimi/p/10676309.html">参考 I帧、P帧、B帧、GOP、IDR 和PTS, DTS之间的关系</a><br><a href="https://blog.csdn.net/BigDream123/article/details/120329879">视频编码基础：I帧、P帧 和 B 帧</a></p><blockquote><p>拓展知识：视频编码方式<br>H.26x（由ITU[国际电传视讯联盟]主导）<br>MPEG-x （由ISO[国际标准组织机构]下属的MPEG[运动图象专家组]开发）<br>VP-x （Google开发的开源视频编码格式）<br>AV1 （由Alliance for Open Media 开放媒体联盟，开发的一种开源视频编码格式）</p><ul><li><strong>MPEG-4</strong> 与H.264诞生了H.264&#x2F;AVC标准</li><li><strong>H.264&#x2F;AVC</strong> H.264&#x2F;MPEG-4第十部分，或称AVC（Advanced Video Coding，高级视频编码）</li><li><strong>H.265&#x2F;HEVC</strong> （High Efficiency Video Coding，简称HEVC）H.264的继任者，最高分辨率可达到8192×4320，HEVC被认为不仅提升图像质量，同时也能达到<strong>H.264&#x2F;MPEG-4</strong> AVC两倍之压缩率。唯一的潜在缺点是许可系统有点复杂。</li><li><strong>H.266&#x2F;VVC</strong>  Versatile Video Coding H.266 的开发目的是超越 H.265。但仍然存在一些与前身类似的许可和版税问题需要解决。与 H.265 相比，在相同的感知质量下，H.266 能够将比特率降低 30% 至 50%。</li><li><strong>VP9</strong> VP9 作为 VP8 的后继产品，主要竞争对手是 MPEG 的高效视频编码标准 HEVC。</li><li><strong>AV1</strong> 旨在提供更高效的压缩和更好的视频质量。它免版税且开源，效率比 VP9 高 30%。</li></ul><p>对比：</p><ol><li>压缩效率：H.265和AV1相对于H.264、MPEG-2、MPEG-4和VP9具有更高的压缩效率，可以在相同的视频质量下减少更多的码率，从而减少带宽和存储需求。</li><li>支持的分辨率和帧率：H.264、MPEG-2、MPEG-4和VP9支持较低的分辨率和帧率，而H.265和AV1支持更高的分辨率和帧率，例如4K和8K视频。</li><li>编码延迟：H.265和AV1相对于H.264、MPEG-2、MPEG-4和VP9具有更高的编码延迟，这意味着它们需要更长的时间来编码视频，这可能会影响实时视频流应用。</li><li><strong>编码复杂度</strong>：H.265和AV1相对于H.264、MPEG-2、MPEG-4和VP9具有更高的编码复杂度，这意味着需要更强的计算能力来进行编码。</li><li>开放性：AV1是一种开放标准，由多个公司和组织共同开发，可以免费使用，而H.264、H.265、MPEG-2、MPEG-4和VP9则有专利和版权限制。<br>AV1和H.265的压缩比较高，所以编码较为复杂，延迟较高，计算量更高。</li></ol><p><strong>需要注意的是 MKV MP4 AVI 等等这些是音视频容器，和视频编码不是一个概念，视频容器是用来盛放各种视频流、音频流、字幕等等数据的“容器”。不同的容器里面可能包含着相同的视频流。</strong></p></blockquote><p>编码器将多张图像进行编码后生产成一段一段的 GOP ( Group of Pictures ) ， 解码器在播放时则是读取一段一段的 GOP 进行解码后读取画面再渲染显示。<br>GOP ( Group of Pictures) 是一组连续的画面，由一张 I 帧和数张 B &#x2F; P 帧组成，是视频图像编码器和解码器存取的基本单位，它的排列顺序将会一直重复到影像结束。</p><ul><li><strong>I 帧</strong>是内部编码帧（也称为关键帧）是一个完整的图像帧，它独立于其他帧存在。I帧不依赖于其他帧的信息即可独立解码，类似于静态图像，可以视为视频序列中的一个参考点。由于I帧包含了完整的图像信息，其压缩率相对较低，但在解码时最为简单，因为它不涉及对其他帧的依赖。</li><li><strong>P 帧</strong>是前向预测帧（前向参考帧）依赖于前面的I帧或P帧来生成。P帧存储的是与前一帧相比图像的变化量，因此它的压缩效果通常比I帧更好。在解码P帧时，需要先解码它所依赖的I帧或P帧，然后根据这些信息来重建当前帧的画面。P帧的引入有效减少了时间维度上的冗余，提高了视频的压缩效率。</li><li><strong>B 帧</strong>是双向内插帧（双向参考帧）需要参考前后的I帧或P帧来生成。B帧利用前后帧的信息来预测当前帧的内容，从而实现更高的压缩比。由于B帧的解码需要前后帧的信息，它不能独立解码，必须在解码序列中结合I帧和P帧来完成。<br>简单地讲，I 帧是一个完整的画面，而 P 帧和 B 帧记录的是相对于 I 帧的变化。如果没有 I 帧，P 帧和 B 帧就无法解码。</li></ul><p>在H.264压缩标准中I帧、P帧、B帧用于表示传输的视频画面。<br><img src="/2024/2f262a28/image-20240721152541316.png"></p><h2 id="GOP-和-IDR"><a href="#GOP-和-IDR" class="headerlink" title="GOP 和 IDR"></a>GOP 和 IDR</h2><p>在H264中图像以<strong>序列</strong>为单位进行组织，一个序列是一段图像编码后的数据流。<br>一个序列的第一个图像叫做 <strong>IDR 图像</strong>（<strong>立即刷新图像</strong>），IDR 图像都是 I 帧图像。H.264 引入 IDR 图像是为了解码的重同步，当解码器解码到 IDR 图像时，立即将参考帧队列清空，将已解码的数据全部输出或抛弃，重新查找参数集，开始一个新的序列。这样，如果前一个序列出现重大错误，在这里可以获得重新同步的机会。IDR图像之后的图像永远不会使用IDR之前的图像的数据来解码。<br>一个序列就是一段内容差异不太大的图像编码后生成的一串数据流。当运动变化比较少时，一个序列可以很长，因为运动变化少就代表图像画面的内容变动很小，所以就可以编一个I帧，然后一直P帧、B帧了。当运动变化多时，可能一个序列就比较短了，比如就包含一个I帧和3、4个P帧。<br>在视频编码序列中，GOP即Group of picture（<strong>图像组</strong>），指两个I帧之间的距离，Reference（<strong>参考周期</strong>）指两个P帧之间的距离。两个I帧之间形成一组图片，就是GOP（Group Of Picture）。</p><p>【GOP示意图】<br><img src="/2024/2f262a28/image-20240721161215632.png" alt="alt"></p><h2 id="I帧"><a href="#I帧" class="headerlink" title="I帧"></a>I帧</h2><p>I帧:即Intra-coded picture（<strong>帧内编码图像帧</strong>），I帧表示关键帧，你可以理解为这一帧画面的完整保留；解码时只需要本帧数据就可以完成（因为包含完整画面）。又称为内部画面 (intra picture)，I 帧通常是每个 GOP（MPEG 所使用的一种视频压缩技术）的第一个帧，经过适度地压缩，做为随机访问的参考点，可以当成图象。在MPEG编码的过程中，部分视频帧序列压缩成为I帧；部分压缩成P帧；还有部分压缩成B帧。I帧法是帧内压缩法，也称为“关键帧”压缩法。I帧法是基于离散余弦变换DCT（Discrete Cosine Transform）的压缩技术，这种算法与JPEG压缩算法类似。采用I帧压缩可达到1&#x2F;6的压缩比而无明显的压缩痕迹。</p><p>【<strong>I帧特点</strong>】<br>　　1.它是一个全帧压缩编码帧。它将全帧图像信息进行JPEG压缩编码及传输;<br>　　2.解码时仅用I帧的数据就可重构完整图像;<br>　　3.I帧描述了图像背景和运动主体的详情;<br>　　4.I帧不需要参考其他画面而生成;<br>　　5.I帧是P帧和B帧的参考帧(其质量直接影响到同组中以后各帧的质量);<br>　　6.I帧是帧组GOP的基础帧(第一帧),在一组中只有一个I帧;<br>　　7.I帧不需要考虑运动矢量;<br>　　8.I帧所占数据的信息量比较大。</p><p>【<strong>I帧编码流程</strong>】<br>　　(1)进行帧内预测，决定所采用的帧内预测模式。<br>　　(2)像素值减去预测值，得到残差。<br>　　(3)对残差进行变换和量化。<br>　　(4)变长编码和算术编码。<br>　　(5)重构图像并滤波，得到的图像作为其它帧的参考帧。</p><p>例如：在视频会议系统中，终端发送给MCU（或者MCU发送给终端）的图像，并不是每次都把完整的一幅幅图片发送到远端，而只是发送后一幅画面在前一幅画面基础上发生变化的部分。如果在网络状况不好的情况下，终端的接收远端或者发送给远程的画面就会有丢包而出现图像花屏、图像卡顿的现象，在这种情况下如果没有I帧机制来让远端重新发一幅新的完整的图像到本地（或者本地重新发一幅新的完整的图像给远端），终端的输出图像的花屏、卡顿现象会越来越严重，从而造成会议无法正常进行。<br>在视频画面播放过程中，若I帧丢失了，则后面的P帧也就随着解不出来，就会出现视频画面黑屏的现象；若P帧丢失了，则视频画面会出现花屏、马赛克等现象。<br>在视频会议系统中I帧只会在会议限定的带宽内发生，不会超越会议带宽而生效。I帧机制不仅存在于MCU中，电视墙服务器、录播服务器中也存在。就是为了解决在网络状况不好的情况下，出现的丢包而造成的如图像花屏、卡顿，而影响会议会正常进行。</p><h2 id="P-帧"><a href="#P-帧" class="headerlink" title="P 帧"></a>P 帧</h2><p>P帧:即Predictive-coded Picture（<strong>前向预测编码图像帧</strong>）。P帧表示的是这一帧跟之前的一个关键帧（或P帧）的差别，解码时需要用之前缓存的画面叠加上本帧定义的差别，生成最终画面。（也就是差别帧，P帧没有完整画面数据，只有与前一帧的画面差别的数据）</p><p><img src="/2024/2f262a28/image-20240721162346288.png"></p><p>【<strong>P帧的预测与重构</strong>】<br>　　P帧是以I帧为参考帧,在I帧中找出P帧“某点”的预测值和运动矢量,取预测差值和运动矢量一起传送。在接收端根据运动矢量从I帧中找出P帧“某点”的预测值并与差值相加以得到P帧“某点”样值,从而可得到完整的P帧。</p><p>【<strong>P帧特点</strong>】<br>　　1.P帧是I帧后面相隔1~2帧的编码帧;<br>　　2.P帧采用运动补偿的方法传送它与前面的I或P帧的差值及运动矢量(预测误差);<br>　　3.解码时必须将I帧中的预测值与预测误差求和后才能重构完整的P帧图像;<br>　　4.P帧属于前向预测的帧间编码。它只参考前面最靠近它的I帧或P帧;<br>　　5.P帧可以是其后面P帧的参考帧,也可以是其前后的B帧的参考帧;<br>　　6.由于P帧是参考帧,它可能造成解码错误的扩散;<br>　　7.由于是差值传送,P帧的压缩比较高。</p><h2 id="B帧"><a href="#B帧" class="headerlink" title="B帧"></a>B帧</h2><p>B帧:即Bidirectionally predicted picture（<strong>双向预测编码图像帧</strong>)。B帧是双向差别帧，也就是B帧记录的是本帧与前后帧的差别，换言之，<strong>要解码B帧，不仅要取得之前的缓存画面，还要解码之后的画面</strong>，通过前后画面的与本帧数据的叠加取得最终的画面。B帧压缩率高，但是解码时CPU会比较累。<strong>无论是从编码侧还是解码侧看，B帧都是资源密集型</strong></p><p><img src="/2024/2f262a28/image-20240721162537729.png"></p><p>【<strong>B帧的预测与重构</strong>】<br><strong>B帧以前面的I或P帧和后面的P帧为参考帧</strong>,“找出”B帧“某点”的预测值和两个运动矢量,并取预测差值和运动矢量传送。接收端根据运动矢量在两个参考帧中“找出(算出)”预测值并与差值求和,得到B帧“某点”样值,从而可得到完整的B帧。采用运动预测的方式进行帧间双向预测编码</p><p>【<strong>B帧特点</strong>】<br>　　1.B帧是由前面的I或P帧和后面的P帧来进行预测的;<br>　　2.B帧传送的是<strong>它与前面的I帧或P帧和后面的P帧之间的预测误差及运动矢量</strong>;<br>　　3.B帧是双向预测编码帧;<br>　　4.B帧压缩比最高,因为它只反映丙参考帧间运动主体的变化情况,预测比较准确;<br>　　5.B帧不是参考帧,不会造成解码错误的扩散</p><p>【<strong>为什么需要B帧</strong>】</p><p> 从上面的看，我们知道I和P的解码算法比较简单，资源占用也比较少，I只要自己完成就行了，P呢，也只需要解码器把前一个画面缓存一下，遇到P时就使用之前缓存的画面就好了，如果视频流只有I和P，解码器可以不管后面的数据，边读边解码，线性前进，大家很舒服。那么为什么还要引入B帧？</p><p>网络上的电影很多都采用了B帧，因为B帧记录的是前后帧的差别，<strong>比P帧能节约更多的空间</strong>，但这样一来，文件小了，解码器就麻烦了，因为在解码时，不仅要用之前缓存的画面，还要知道下一个I或者P的画面（也就是说要预读预解码），而且，B帧不能简单地丢掉，因为B帧其实也包含了画面信息，如果简单丢掉，并用之前的画面简单重复，就会造成画面卡（其实就是丢帧了），并且由于网络上的电影为了节约空间，往往使用相当多的B帧，B帧用的多，对不支持B帧的播放器就造成更大的困扰，画面也就越卡。</p><p>【<strong>显示和解码顺序示意图</strong>】<br><img src="/2024/2f262a28/image-20240721162803162.png"></p><h2 id="PTS-DTS"><a href="#PTS-DTS" class="headerlink" title="PTS DTS"></a>PTS DTS</h2><p>【<strong>为什么会有PTS和DTS的概念</strong>】</p><p>通过上面的描述可以看出：P帧需要参考前面的I帧或P帧才可以生成一张完整的图片，而B帧则需要参考前面I帧或P帧及其后面的一个P帧才可以生成一张完整的图片。这样就带来了一个问题：在视频流中，先到来的 B 帧无法立即解码，需要等待它依赖的后面的 I、P 帧先解码完成，这样一来播放时间与解码时间不一致了，顺序打乱了，那这些帧该如何播放呢？这时就引入了另外两个概念：DTS 和 PTS。</p><p>【<strong>PTS和DTS</strong>】</p><p>先来了解一下PTS和DTS的基本概念：</p><p><strong>DTS（Decoding Time Stamp）</strong>：即<strong>解码时间戳</strong>，这个时间戳的意义在于告诉播放器该在什么时候解码这一帧的数据。<br><strong>PTS（Presentation Time Stamp）</strong>：即<strong>显示时间戳</strong>，这个时间戳用来告诉播放器该在什么时候显示这一帧的数据。</p><p>虽然 DTS、PTS 是用于指导播放端的行为，但它们是在编码的时候由编码器生成的。</p><p>在视频采集的时候是录制一帧就编码一帧发送一帧的，在编码的时候会生成 PTS，这里需要特别注意的是 frame（帧）的编码方式，在通常的场景中，编解码器编码一个 I 帧，然后向后跳过几个帧，用编码 I 帧作为基准帧对一个未来 P 帧进行编码，然后跳回到 I 帧之后的下一个帧。编码的 I 帧和 P 帧之间的帧被编码为 B 帧。之后，编码器会再次跳过几个帧，使用第一个 P 帧作为基准帧编码另外一个 P 帧，然后再次跳回，用 B 帧填充显示序列中的空隙。这个过程不断继续，每 12 到 15 个 P 帧和 B 帧内插入一个新的 I 帧。P 帧由前一个 I 帧或 P 帧图像来预测，而 B 帧由前后的两个 P 帧或一个 I 帧和一个 P 帧来预测，因而编解码和帧的显示顺序有所不同，如下所示：</p><p><img src="/2024/2f262a28/image-20240721163414484.png"></p><p>假设编码器采集到的帧是这个样子的：<br><code> I B B P B B P </code></p><p>那么它的显示顺序，也就是PTS应该是这样：<br><code> 1 2 3 4 5 6 7  </code></p><p>编码器的编码顺序是：<br><code> 1 4 2 3 7 5 6 </code></p><p>推流顺序也是按照编码顺序去推的，即<br><code> I P B B P B B </code></p><p>那么接收断收到的视频流也就是<br><code> I P B B P B B </code></p><p>这时候去解码，也是按照收到的视频流一帧一帧去解的了，接收一帧解码一帧，因为在编码的时候已经按照 I、B、P 的依赖关系编好了，接收到数据直接解码就好了。那么解码顺序是：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">     I P B B P B B<br>DTS：1 2 3 4 5 6 7<br>PTS：1 4 2 3 7 5 6<br></code></pre></td></tr></table></figure><p>可以看到解码出来对应的 PTS 不是顺序的，为了正确显示视频流，这时候我们就必须按照 PTS 重新调整解码后的 frame(帧)，即</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">     I B B P B B P<br>DTS：1 3 4 2 6 7 5<br>PTS：1 2 3 4 5 6 7<br></code></pre></td></tr></table></figure><p>另外，并不是一定要使用B帧。<strong>在实时互动直播系统中，很少使用B帧</strong>。主要的原因是压缩和解码B帧时，由于要双向参考，所以它需要缓冲更多的数据，且使用的CPU也会更高。由于实时性的要求，所以一般不使用它。不过对于播放器来说，遇到带有B帧的H264数据是常有的事儿。在没有B帧的情况下，存放帧的顺序和显示帧的顺序就是一样的，PTS和DTS的值也是一样的。</p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>audio</tag>
      
      <tag>video</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flash磨损均衡</title>
    <link href="/2024/4ce716c0/"/>
    <url>/2024/4ce716c0/</url>
    
    <content type="html"><![CDATA[<h1 id="Flash磨损均衡"><a href="#Flash磨损均衡" class="headerlink" title="Flash磨损均衡"></a>Flash磨损均衡</h1><h1 id="flash-原理和部分名称"><a href="#flash-原理和部分名称" class="headerlink" title="flash 原理和部分名称"></a>flash 原理和部分名称</h1><p><img src="/2024/4ce716c0/image-20240604163634862.png"></p><ul><li><strong>package</strong> 是存储芯片，即带有电连接器的小黑色矩形。</li><li><strong>dies</strong> 每个<code>package</code>包含一个或多个<code>die</code>（例如一个、两个或四个）。<code>die</code> 是可以独立执行命令或报告状态的最小单元。</li><li><strong>planes</strong>每个芯片包含一个或多个<code>planes</code> （通常为一或两个）。每个<code>planes</code>上都可以进行相同的并发操作，但有一些限制。</li><li><strong>blocks</strong> 每个<code>planes</code>包含若干个<code>block</code> ，<code>block</code><strong>是可以擦除的最小单位</strong>。</li><li><strong>pages</strong>每个<code>block</code>包含若干个 <code>page</code>，<code>page</code>是可进行编程（即写入）的最小单位。</li></ul><p><strong>磨损均衡 可实现的 底层原理是（同一个块）一次擦除，多次写入。</strong></p><p>擦除是将任意内容改成0xff，即全1状态。<br>你可以对一个page执行多次写入，但是需要注意的是写入仅能将1改成0，<strong>无法将0改成1</strong>。</p><blockquote><p>EEPROM可以单字节（或者四字节）写，而FLASH只能按整个blocks擦除，另外EEPROM一般有100万次的读写寿命，而FLASH只有10万次；</p></blockquote><h1 id="一些简单实现的Demo"><a href="#一些简单实现的Demo" class="headerlink" title="一些简单实现的Demo"></a>一些简单实现的Demo</h1><p>这些demo只是头脑风暴的一些实现，仅仅是一个思路，具体实现还需要完善很多的细节。</p><p><a href="Flash%E7%A3%A8%E6%8D%9F%E5%9D%87%E8%A1%A1.assets/flash%E7%9A%84%E7%A3%A8%E6%8D%9F%E5%9D%87%E8%A1%A1.drawio">draw.io 源文件</a></p><h2 id="数据长度固定"><a href="#数据长度固定" class="headerlink" title="数据长度固定"></a>数据长度固定</h2><p>数据长度固定，使用bitmap记录数据状态。</p><p><img src="/2024/4ce716c0/image-20240604162704326.png"></p><p><img src="/2024/4ce716c0/image-20240604175346112.png"><br><img src="/2024/4ce716c0/image-20240604175403042.png"></p><h2 id="数据长度可变"><a href="#数据长度可变" class="headerlink" title="数据长度可变"></a>数据长度可变</h2><p><img src="/2024/4ce716c0/image-20240604181628435.png"></p><h1 id="一些高性能的磨损均衡算法-SSD-Wear-Leveling"><a href="#一些高性能的磨损均衡算法-SSD-Wear-Leveling" class="headerlink" title="一些高性能的磨损均衡算法 SSD Wear Leveling"></a>一些高性能的磨损均衡算法 SSD Wear Leveling</h1><p>Flash采取<strong>异地更新</strong>的策略 ,更新的数据会被放到别的物理页上,而不是覆盖原来的数据。包含新版本数据的页被称为<strong>有效页</strong>,新版本数据被称为<strong>有效数据</strong>。包含旧版本数据的页被称为<strong>无效页</strong>，或称为脏页，脏页经过擦除操作后成为空闲页，才可以重新写入数据。因为Flash是<strong>以块为单位执行擦除</strong>的，因此需要将脏页所在块上的所有物理页都擦除，在擦除之前需要检查此块上是否存在有效页，如果存在就必须先转移到其他块上。因为每个Flash块的擦除次数有限，一般是在10 万次到100万次之间，只要有块的擦除次数达到了上限，Flash数据存储的性能将下降。所以必须想办法，使<strong>擦除操作平均作用在每个Flash块上</strong>，这种方法就是磨损均衡(wear-leveling)算法。</p><p>我们在应用Flash时，实际上访问的是Flash的逻辑地址，在逻辑地址和物理地址之间，存在着映射关系。数据更新后只需改变映射表中物理页的地址，并将原版本数据所在的物理页标为无效。对于经常被更新的数据块，我们称之为<strong>“热”数据块</strong>，对长期得不到更新的数据块，称之为<strong>“冷”数据块</strong>。数据块经常更新的话，就会经常被擦除，而长期不更行的数据块，不会出现脏页而被擦除，其擦除次数会明显少于存放着经常被更新数据的块。如何实现“冷热”数据存放位置的交换是磨损均衡处理中需要考虑的问题。</p><p>目前常用的磨损均衡算法大致分为两类，一类是随机性算法，一类是确定性算法。</p><ul><li>对于随机性算法，其原理为：在每次写或擦除操作后，按照某一概率来触发磨损均衡处理。按照均匀分布的概率，<strong>随机选择某个块执行擦除操作</strong>。不论块上放的是“冷”数据还是“热”数据,让每个块得到相等的擦除机会。最后将选中块上的有效数据复制到空块后擦除此块。将数据移动到哪个空闲块上,也是随机选择,因为没有记录块的擦除情况,存在将“冷”数据又移动到一个“冷”块上的情况,结果此块并没有增加擦除次数, 这种情况尤其会发生在有大量“冷”数据的系统里。</li><li>对于确定性算法，又分为周期性和全局性两种，其中<strong>周期性算法</strong>的原理为：将Flash的寿命看做是一个接一个的磨损均衡周期组成的。在一个处理周期中，达到规定的擦除次数的块在这一轮周期中将不会被选中，这样可使各个块都达到相同的擦除次数，再开始下一个擦除周期。通过调整Flash块的规定擦除次数，可以使整个Flash能够达到理想的磨损均衡。<strong>全局性算法</strong>的原理为：不划分处理周期，在一个全局范围内控制块的磨损均衡。当任何两个块的擦除次数之差超过一个给定的阈值时，或者当某块的擦除次数超过了所有块的平均擦除次数时，启动磨损均衡处理，将擦除次数少的块上的数据和擦除次数多的块上的数据进行交换。如果块上存放的是“冷”数据，即数据很少被更新，则该块上的数据不易变脏，很少得到擦除的机会。相反，如果该块上存放的是“热”数据，则该块上的数据经常被更新，经常得到擦除脏数据的机会。根据这个原理来交换“冷热”数据，从而实现磨损均衡。</li></ul><p>对比两类磨损均衡算法，可以看出：随机性算法的效果受随机因素影响较大，在擦除前，并不知道各个块被擦除的情况，同时对逻辑页的随机性请求并不能做到完全等概率，所以虽然随机性算法是等概率地选择处理页，但每个块的擦除次数并不能达到等概率分布，不能达到很好的磨损均衡效果。确定性算法因记录了物理块的擦除次数，故在处理中可根据这些信息来作出调整决策，各块基本达到了相近的擦除次数，磨损均衡的效果明显好于随机性算法。但这是在消耗大量内存开销的基础上实现的。</p><p>根据以上讨论的情况，可以看出，必须结合两类算法的优势，来实现效果较好的磨损均衡处理，才能既保证Flash的读写速度，又能保证Flash的使用寿命，这将是决定固态存储能否全面战胜机械硬盘的关键之战。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>Understanding Flash: Blocks, Pages and Program &#x2F; Erases<br><a href="https://flashdba.com/2014/06/20/understanding-flash-blocks-pages-and-program-erases/">https://flashdba.com/2014/06/20/understanding-flash-blocks-pages-and-program-erases/</a><br>Flash存储器磨损均衡原理及实现<br><a href="https://blog.csdn.net/csdliqi/article/details/80361163">https://blog.csdn.net/csdliqi/article/details/80361163</a><br>深入解析SSD Wear Leveling磨损均衡技术：如何让你的硬盘更长寿？<br><a href="https://blog.csdn.net/zhuzongpeng/article/details/134520307">https://blog.csdn.net/zhuzongpeng/article/details/134520307</a></p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>flash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RT-Thread 宝藏之Ringblk组件</title>
    <link href="/2024/5b8b4de/"/>
    <url>/2024/5b8b4de/</url>
    
    <content type="html"><![CDATA[<h1 id="RT-Thread-宝藏之ringblk组件"><a href="#RT-Thread-宝藏之ringblk组件" class="headerlink" title="RT-Thread 宝藏之ringblk组件"></a>RT-Thread 宝藏之ringblk组件</h1><h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>ringblk是什么？<br>ringblk &#x3D; ring block(环形块缓冲区)，它的缓冲区的单位是一个 <code>block</code> , 每次对数据的操作都是以 <code>block</code> 为单位。</p><blockquote><p>还有一个更加常见的 <code>ringbuf</code>(环形缓冲区，一种数据结构)。<code>ringbuf</code>就是比较常见的先入先出（FIFO，First-In-First-Out）的环形缓冲区。</p><p>下面是两者的一些对比：</p><ol><li><strong>数据存储方式</strong>：<ul><li><code>ringbuf</code>：传统的环形缓冲区，通常由固定大小的单字节组成，数据以连续的方式存储。</li><li><code>ringblk</code>：环形块缓冲区，由多个大小不一的数据块组成，每个块可以包含多个字节。</li></ul></li><li><strong>内存效率</strong>：<ul><li><code>ringbuf</code>：可能需要更多的内存拷贝操作，因为它通常以单字节为单位操作数据。</li><li><code>ringblk</code>：设计用于减少内存拷贝，通过块操作可以提高内存使用效率。</li></ul></li><li><strong>适用场景</strong>：</li></ol><ul><li><code>ringbuf</code>：适用于简单的数据流处理，如字符设备驱动程序。</li><li><code>ringblk</code>：适用于需要高效处理大块数据的场景，如DMA传输、通信帧的接收与发送、网络通信等。</li></ul><ol start="4"><li><strong>性能</strong>：  <ul><li><code>ringbuf</code>：在处理小数据或字符流时可能表现良好。</li><li><code>ringblk</code>：由于减少了内存拷贝（零字节拷贝zero-copy），可能在处理大块数据时提供更好的性能。</li></ul></li></ol><p><code>ringblk</code>提供了更高级的特性，特别是在处理大块数据和需要高效率数据传输的场景中。<br>而<code>ringbuf</code>则适用于对简单连续数据流的处理。</p></blockquote><p><a href="https://www.rt-thread.org/document/api/group__ring__block__buffer.html">RT-Thread 环形块状缓冲区 参考资料</a></p>]]></content>
    
    
    <categories>
      
      <category>RTOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rtos</tag>
      
      <tag>rt-thread</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AES</title>
    <link href="/2024/f17585eb/"/>
    <url>/2024/f17585eb/</url>
    
    <content type="html"><![CDATA[<h1 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h1><p>高级加密标准( AES  <strong>Advanced Encryption Standard</strong>)，原名Rijndael，是美国国家标准与技术研究所(NIST) 在 2017 年制定的电子数据加密规范。</p><p>AES已被美国政府采用。它取代了1977 年发布的数据加密标准(DES) 。<br>AES 描述的算法是对称密钥算法，这意味着相同的密钥用于加密和解密数据。</p><p>一些特性</p><ul><li>对称加密，加密解密使用同样的密钥</li><li>分组加密，将明文分块成若干个数据块，分块加密（块大小固定为128位 16Byte）</li><li>密钥长度可选128位、192位、256位，分别对应于10轮循环、12轮循环、14轮循环</li></ul><h1 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h1><p><img src="/2024/f17585eb/image-20240323184445497.png"></p><ul><li>最终轮运算有些不同的是它只执行 1、2、4，不执行3。</li></ul><p><img src="/2024/f17585eb/image-20240323201021478.png"></p><h1 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h1><p>解密为加密的完全逆过程</p><blockquote><p>这个图从下往上看</p></blockquote><p><img src="/2024/f17585eb/image-20240323203852410.png"></p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>aes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Obsidian</title>
    <link href="/2024/b58cbef5/"/>
    <url>/2024/b58cbef5/</url>
    
    <content type="html"><![CDATA[<h1 id="一些格式问题"><a href="#一些格式问题" class="headerlink" title="一些格式问题"></a>一些格式问题</h1><h2 id=""><a href="#" class="headerlink" title="%%"></a>%%</h2><p>两个百分号在html中是“一个模板引擎系统，其语法基于jinja。”</p><ul><li>Obsidian 会默认把CRLF的换行符自动转换成LF的<br>   我们需要将单独这个仓库的git配置成<code>autocrlf = false</code>以保证换行符的统一。</li></ul>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>markdown</tag>
      
      <tag>obsidian</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS</title>
    <link href="/2024/ee69e452/"/>
    <url>/2024/ee69e452/</url>
    
    <content type="html"><![CDATA[<h1 id="JS-JavaScript"><a href="#JS-JavaScript" class="headerlink" title="JS (JavaScript)"></a>JS (JavaScript)</h1><h1 id="JS-简介"><a href="#JS-简介" class="headerlink" title="JS 简介"></a>JS 简介</h1><p>JavaScript 是 web 开发人员必须学习的 3 门语言中的一门：</p><ol><li><strong>HTML</strong> 定义了网页的内容</li><li><strong>CSS</strong> 描述了网页的布局</li><li><strong>JavaScript</strong> 控制了网页的行为</li></ol><h2 id="JS-特性"><a href="#JS-特性" class="headerlink" title="JS 特性"></a>JS 特性</h2><ul><li>JavaScript 是脚本语言</li><li>JavaScript 是互联网上最流行的脚本语言，这门语言可用于 HTML 和 web，更可广泛用于服务器、PC、笔记本电脑、平板电脑和智能手机等设备。</li><li>JavaScript 是一种轻量级的编程语言。</li><li>JavaScript 是可插入 HTML 页面的编程代码。</li><li>JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行。</li><li>JavaScript 很容易学习。</li></ul>]]></content>
    
    
    <categories>
      
      <category>language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>html</tag>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS</title>
    <link href="/2024/ee69e452/"/>
    <url>/2024/ee69e452/</url>
    
    <content type="html"><![CDATA[<h1 id="CSS-Cascading-Style-Sheets"><a href="#CSS-Cascading-Style-Sheets" class="headerlink" title="CSS (Cascading Style Sheets)"></a>CSS (Cascading Style Sheets)</h1>]]></content>
    
    
    <categories>
      
      <category>language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>css</tag>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML</title>
    <link href="/2024/2eec1551/"/>
    <url>/2024/2eec1551/</url>
    
    <content type="html"><![CDATA[<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h1 id="HTML-概述"><a href="#HTML-概述" class="headerlink" title="HTML 概述"></a>HTML 概述</h1><h2 id="HTML-是什么"><a href="#HTML-是什么" class="headerlink" title="HTML 是什么"></a>HTML 是什么</h2><p>HTML 是用来描述网页的一种语言。</p><ul><li>HTML 指的是超文本标记语言: <strong>H</strong>yper<strong>T</strong>ext <strong>M</strong>arkup <strong>L</strong>anguage</li><li>HTML 不是一种编程语言，而是一种<strong>标记</strong>语言</li><li>标记语言是一套<strong>标记标签</strong> (markup tag)</li><li>HTML 使用标记标签来<strong>描述</strong>网页</li><li>HTML 文档包含了HTML <strong>标签</strong>及<strong>文本</strong>内容</li><li>HTML文档也叫做 <strong>web 页面</strong></li></ul><h2 id="HTML-标签"><a href="#HTML-标签" class="headerlink" title="HTML 标签"></a>HTML 标签</h2><p>HTML 标记标签通常被称为 HTML 标签 (HTML tag)。</p><ul><li>HTML 标签是由 <em>尖括号</em> 包围的关键词，比如 <code>&lt;html&gt;</code></li><li>HTML 标签通常是 <em>成对出现</em> 的，比如<code> &lt;b&gt; </code>和 <code>&lt;/b&gt;</code></li><li>标签对中的第一个标签是 <em>开始标签</em> ，第二个标签是 <em>结束标签</em></li><li>开始和结束标签也被称为 <em>开放标签</em> 和 <em>闭合标签</em></li></ul><h2 id="HTML-页面结构"><a href="#HTML-页面结构" class="headerlink" title="HTML 页面结构"></a>HTML 页面结构</h2><p><img src="/2024/2eec1551/02A7DD95-22B4-4FB9-B994-DDB5393F7F03.jpg" alt="img"></p><blockquote><p>  只有 <code>&lt;body&gt;</code> 区域 才会在浏览器中显示。</p></blockquote><h3 id="声明"><a href="#声明" class="headerlink" title="&lt;!DOCTYPE&gt; 声明"></a>&lt;!DOCTYPE&gt; 声明</h3><p><code>&lt;!DOCTYPE&gt;</code>声明用于标识网页文件，<code>&lt;!DOCTYPE&gt;</code> 是文档类型声明（Document Type Declaration）的缩写。</p><p>网络上有很多不同的文件，如果能够正确声明HTML的版本，浏览器就能正确显示网页内容。</p><p>doctype 声明是不区分大小写的。</p><p><strong>HTML5</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>HTML 4.01</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">HTML</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span></span><br><span class="hljs-meta"><span class="hljs-string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>XHTML 1.0</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</span></span><br><span class="hljs-meta"><span class="hljs-string">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="charset-编码格式"><a href="#charset-编码格式" class="headerlink" title="charset 编码格式"></a>charset 编码格式</h3><p>指定html文件的编码格式 UTF-8 或 GBK …</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="HTML-元素"><a href="#HTML-元素" class="headerlink" title="HTML 元素"></a>HTML 元素</h1><h2 id="HTML元素的语法"><a href="#HTML元素的语法" class="headerlink" title="HTML元素的语法"></a>HTML元素的语法</h2><table><thead><tr><th align="left">开始标签 *</th><th align="left">元素内容</th><th align="left">结束标签 *</th></tr></thead><tbody><tr><td align="left"><code>&lt;p&gt;</code></td><td align="left">这是一个段落</td><td align="left"><code>&lt;/p&gt;</code></td></tr><tr><td align="left"><code>&lt;a href=&quot;default.htm&quot;&gt;</code></td><td align="left">这是一个链接</td><td align="left"><code>&lt;/a&gt;</code></td></tr><tr><td align="left"><code>&lt;br&gt;</code></td><td align="left">换行</td><td align="left"></td></tr></tbody></table><p>**<em><strong>开始标签常被称为</strong>起始标签（opening tag）</em>*</p><p>**<em><strong>结束标签常称为</strong>闭合标签（closing tag）</em>*</p><h2 id="HTML元素的特性"><a href="#HTML元素的特性" class="headerlink" title="HTML元素的特性"></a>HTML元素的特性</h2><ul><li>HTML 元素以<strong>开始标签</strong>起始</li><li>HTML 元素以<strong>结束标签</strong>终止</li><li><strong>元素的内容</strong>是开始标签与结束标签之间的内容</li><li>某些 HTML 元素具有<strong>空内容（empty content）</strong></li><li>空元素<strong>在开始标签中进行关闭</strong>（以开始标签的结束而结束）</li><li>大多数 HTML 元素可拥有<strong>属性</strong></li><li>不要忘记结束标签！</li><li>在 XHTML、XML 以及未来版本的 HTML 中，所有元素都必须被关闭。</li><li>HTML 标签对大小写不敏感：<code>&lt;P&gt;</code> 等同于 <code>&lt;p&gt;</code>。万维网联盟（W3C）在 HTML 4 中<strong>推荐使用小写</strong>，而在未来 HTML 版本中会强制使用小写。</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>标题</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>这是一个标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="HTML-标签-1"><a href="#HTML-标签-1" class="headerlink" title="HTML 标签"></a>HTML 标签</h1><p>每个元素都有一个标签</p><p><strong>标题</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>这是一个标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>段落</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是一个段落。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>链接</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.oikiou.net&quot;</span>&gt;</span>这是一个链接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>图像</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/images/logo.png&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;258&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;39&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p><strong>注释</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 这是一个注释 --&gt;</span><br></code></pre></td></tr></table></figure><h2 id="标签-List"><a href="#标签-List" class="headerlink" title="标签 List"></a>标签 List</h2><table><thead><tr><th></th><th align="left">标签</th><th align="left">描述</th></tr></thead><tbody><tr><td></td><td align="left"><strong>基础</strong></td><td align="left"></td></tr><tr><td>☆</td><td align="left"><code>&lt;!DOCTYPE&gt;</code></td><td align="left">定义文档类型。</td></tr><tr><td>☆</td><td align="left"><code>&lt;html&gt;</code></td><td align="left">定义一个 HTML 文档</td></tr><tr><td>☆</td><td align="left"><code>&lt;title&gt;</code></td><td align="left">为文档定义一个标题</td></tr><tr><td>☆</td><td align="left"><code>&lt;body&gt;</code></td><td align="left">定义文档的主体</td></tr><tr><td>☆</td><td align="left"><code>&lt;h1&gt; to &lt;h6&gt;</code></td><td align="left">定义 HTML 标题</td></tr><tr><td>☆</td><td align="left"><code>&lt;p&gt;</code></td><td align="left">定义一个段落</td></tr><tr><td>☆</td><td align="left"><code>&lt;br&gt;</code></td><td align="left">定义简单的折行。</td></tr><tr><td>☆</td><td align="left"><code>&lt;hr&gt;</code></td><td align="left">定义水平线。</td></tr><tr><td>☆</td><td align="left"><code>&lt;!--...--&gt;</code></td><td align="left">定义一个注释</td></tr><tr><td></td><td align="left"><strong>格式</strong></td><td align="left"></td></tr><tr><td></td><td align="left"><code>&lt;acronym&gt;</code></td><td align="left">HTML5不再支持。 定义只取首字母的缩写。</td></tr><tr><td></td><td align="left"><code>&lt;abbr&gt;</code></td><td align="left">定义一个缩写。</td></tr><tr><td>☆</td><td align="left"><code>&lt;address&gt;</code></td><td align="left">定义文档作者或拥有者的联系信息。</td></tr><tr><td>☆</td><td align="left"><code>&lt;b&gt;</code></td><td align="left">定义粗体文本。</td></tr><tr><td></td><td align="left"><code>&lt;bdi&gt;</code></td><td align="left">允许您设置一段文本，使其脱离其父元素的文本方向设置。</td></tr><tr><td></td><td align="left"><code>&lt;bdo&gt;</code></td><td align="left">定义文本的方向。</td></tr><tr><td></td><td align="left"><code>&lt;big&gt;</code></td><td align="left">HTML5不再支持。 定义大号文本。</td></tr><tr><td>☆</td><td align="left"><code>&lt;blockquote&gt;</code></td><td align="left">定义块引用。</td></tr><tr><td></td><td align="left"><code>&lt;center&gt;</code></td><td align="left">HTML5不再支持。 HTML 4.01 已废弃。定义居中文本。</td></tr><tr><td></td><td align="left"><code>&lt;cite&gt;</code></td><td align="left">定义引用(citation)。</td></tr><tr><td>☆</td><td align="left"><code>&lt;code&gt;</code></td><td align="left">定义计算机代码文本。</td></tr><tr><td></td><td align="left"><code>&lt;del&gt;</code></td><td align="left">定义被删除文本。</td></tr><tr><td></td><td align="left"><code>&lt;dfn&gt;</code></td><td align="left">定义定义项目。</td></tr><tr><td>☆</td><td align="left"><code>&lt;em&gt;</code></td><td align="left">定义强调文本。</td></tr><tr><td></td><td align="left"><code>&lt;font&gt;</code></td><td align="left">HTML5不再支持。 HTML 4.01 已废弃。 定义文本的字体、尺寸和颜色</td></tr><tr><td>☆</td><td align="left"><code>&lt;i&gt;</code></td><td align="left">定义斜体文本。</td></tr><tr><td></td><td align="left"><code>&lt;ins&gt;</code></td><td align="left">定义被插入文本。</td></tr><tr><td></td><td align="left"><code>&lt;kbd&gt;</code></td><td align="left">定义键盘文本。</td></tr><tr><td></td><td align="left"><code>&lt;mark&gt;</code></td><td align="left">定义带有记号的文本。</td></tr><tr><td></td><td align="left"><code>&lt;meter&gt;</code></td><td align="left">定义度量衡。仅用于已知最大和最小值的度量。</td></tr><tr><td></td><td align="left"><code>&lt;pre&gt;</code></td><td align="left">定义预格式文本</td></tr><tr><td></td><td align="left"><code>&lt;progress&gt;</code></td><td align="left">定义运行中的任务进度（进程）。</td></tr><tr><td></td><td align="left"><code>&lt;q&gt;</code></td><td align="left">定义短的引用。</td></tr><tr><td></td><td align="left"><code>&lt;rp&gt;</code></td><td align="left">定义不支持 ruby 元素的浏览器所显示的内容。</td></tr><tr><td></td><td align="left"><code>&lt;rt&gt;</code></td><td align="left">定义字符（中文注音或字符）的解释或发音。</td></tr><tr><td></td><td align="left"><code>&lt;ruby&gt;</code></td><td align="left">定义 ruby 注释（中文注音或字符）。</td></tr><tr><td>☆</td><td align="left"><code>&lt;s&gt;</code></td><td align="left">定义加删除线的文本。</td></tr><tr><td></td><td align="left"><code>&lt;samp&gt;</code></td><td align="left">定义计算机代码样本。</td></tr><tr><td></td><td align="left"><code>&lt;small&gt;</code></td><td align="left">定义小号文本。</td></tr><tr><td></td><td align="left"><code>&lt;strike&gt;</code></td><td align="left">HTML5不再支持。 HTML 4.01 已废弃。 定义加删除线的文本。</td></tr><tr><td>☆</td><td align="left"><code>&lt;strong&gt;</code></td><td align="left">定义语气更为强烈的强调文本。</td></tr><tr><td>☆</td><td align="left"><code>&lt;sub&gt;</code></td><td align="left">定义下标文本。</td></tr><tr><td>☆</td><td align="left"><code>&lt;sup&gt;</code></td><td align="left">定义上标文本。</td></tr><tr><td>☆</td><td align="left"><code>&lt;time&gt;</code></td><td align="left">定义一个日期&#x2F;时间</td></tr><tr><td></td><td align="left"><code>&lt;tt&gt;</code></td><td align="left">HTML5不再支持。 定义打字机文本。</td></tr><tr><td>☆</td><td align="left"><code>&lt;u&gt;</code></td><td align="left">定义下划线文本。</td></tr><tr><td>☆</td><td align="left"><code>&lt;var&gt;</code></td><td align="left">定义文本的变量部分。</td></tr><tr><td></td><td align="left"><code>&lt;wbr&gt;</code></td><td align="left">规定在文本中的何处适合添加换行符。</td></tr><tr><td></td><td align="left"><strong>表单</strong></td><td align="left"></td></tr><tr><td></td><td align="left"><code>&lt;form&gt;</code></td><td align="left">定义一个 HTML 表单，用于用户输入。</td></tr><tr><td></td><td align="left"><code>&lt;input&gt;</code></td><td align="left">定义一个输入控件</td></tr><tr><td></td><td align="left"><code>&lt;textarea&gt;</code></td><td align="left">定义多行的文本输入控件。</td></tr><tr><td></td><td align="left"><code>&lt;button&gt;</code></td><td align="left">定义按钮。</td></tr><tr><td></td><td align="left"><code>&lt;select&gt;</code></td><td align="left">定义选择列表（下拉列表）。</td></tr><tr><td></td><td align="left"><code>&lt;optgroup&gt;</code></td><td align="left">定义选择列表中相关选项的组合。</td></tr><tr><td></td><td align="left"><code>&lt;option&gt;</code></td><td align="left">定义选择列表中的选项。</td></tr><tr><td></td><td align="left"><code>&lt;label&gt;</code></td><td align="left">定义 input 元素的标注。</td></tr><tr><td></td><td align="left"><code>&lt;fieldset&gt;</code></td><td align="left">定义围绕表单中元素的边框。</td></tr><tr><td></td><td align="left"><code>&lt;legend&gt;</code></td><td align="left">定义 fieldset 元素的标题。</td></tr><tr><td></td><td align="left"><code>&lt;datalist&gt;</code></td><td align="left">规定了 input 元素可能的选项列表。</td></tr><tr><td></td><td align="left"><code>&lt;keygen&gt;</code></td><td align="left">规定用于表单的密钥对生成器字段。</td></tr><tr><td></td><td align="left"><code>&lt;output&gt;</code></td><td align="left">定义一个计算的结果</td></tr><tr><td></td><td align="left"><strong>框架</strong></td><td align="left"></td></tr><tr><td></td><td align="left"><code>&lt;frame&gt;</code></td><td align="left">HTML5不再支持。 定义框架集的窗口或框架。</td></tr><tr><td></td><td align="left"><code>&lt;frameset&gt;</code></td><td align="left">HTML5不再支持。定义框架集。</td></tr><tr><td></td><td align="left"><code>&lt;noframes&gt;</code></td><td align="left">HTML5不再支持。 定义针对不支持框架的用户的替代内容。</td></tr><tr><td></td><td align="left"><code>&lt;iframe&gt;</code></td><td align="left">定义内联框架。</td></tr><tr><td></td><td align="left"><strong>图像</strong></td><td align="left"></td></tr><tr><td></td><td align="left"><code>&lt;img&gt;</code></td><td align="left">定义图像。</td></tr><tr><td></td><td align="left"><code>&lt;map&gt;</code></td><td align="left">定义图像映射。</td></tr><tr><td></td><td align="left"><code>&lt;area&gt;</code></td><td align="left">定义图像地图内部的区域。</td></tr><tr><td></td><td align="left"><code>&lt;canvas&gt;</code></td><td align="left">通过脚本（通常是 JavaScript）来绘制图形（比如图表和其他图像）。</td></tr><tr><td></td><td align="left"><code>&lt;figcaption&gt;</code></td><td align="left">定义一个 caption for a <figure> element</td></tr><tr><td></td><td align="left"><code>&lt;figure&gt;</code></td><td align="left">figure 标签用于对元素进行组合。</td></tr><tr><td></td><td align="left"><strong>Audio&#x2F;Video</strong></td><td align="left"></td></tr><tr><td></td><td align="left"><code>&lt;audio&gt;</code></td><td align="left">定义声音，比如音乐或其他音频流。</td></tr><tr><td></td><td align="left"><code>&lt;source&gt;</code></td><td align="left">定义media元素 (<video> 和 <audio>)的媒体资源。media</td></tr><tr><td></td><td align="left"><code>&lt;track&gt;</code></td><td align="left">为媒体(<video> 和 <audio>)元素定义外部文本轨道。</td></tr><tr><td></td><td align="left"><code>&lt;video&gt;</code></td><td align="left">定义一个音频或者视频</td></tr><tr><td></td><td align="left"><strong>链接</strong></td><td align="left"></td></tr><tr><td></td><td align="left"><code>&lt;a&gt;</code></td><td align="left">定义一个链接</td></tr><tr><td></td><td align="left"><code>&lt;link&gt;</code></td><td align="left">定义文档与外部资源的关系。</td></tr><tr><td></td><td align="left"><code>&lt;main&gt;</code></td><td align="left">定义文档的主体部分。</td></tr><tr><td></td><td align="left"><code>&lt;nav&gt;</code></td><td align="left">定义导航链接</td></tr><tr><td></td><td align="left"><strong>列表</strong></td><td align="left"></td></tr><tr><td></td><td align="left"><code>&lt;ul&gt;</code></td><td align="left">定义一个无序列表</td></tr><tr><td></td><td align="left"><code>&lt;ol&gt;</code></td><td align="left">定义一个有序列表</td></tr><tr><td></td><td align="left"><code>&lt;li&gt;</code></td><td align="left">定义一个列表项</td></tr><tr><td></td><td align="left"><code>&lt;dir&gt;</code></td><td align="left">HTML5不再支持。 HTML 4.01 已废弃。 定义目录列表。</td></tr><tr><td></td><td align="left"><code>&lt;dl&gt;</code></td><td align="left">定义一个定义列表</td></tr><tr><td></td><td align="left"><code>&lt;dt&gt;</code></td><td align="left">定义一个定义定义列表中的项目。</td></tr><tr><td></td><td align="left"><code>&lt;dd&gt;</code></td><td align="left">定义定义列表中项目的描述。</td></tr><tr><td></td><td align="left"><code>&lt;menu&gt;</code></td><td align="left">定义菜单列表。</td></tr><tr><td></td><td align="left"><code>&lt;command&gt;</code></td><td align="left">定义用户可能调用的命令（比如单选按钮、复选框或按钮）。</td></tr><tr><td></td><td align="left"><strong>表格</strong></td><td align="left"></td></tr><tr><td></td><td align="left"><code>&lt;table&gt;</code></td><td align="left">定义一个表格</td></tr><tr><td></td><td align="left"><code>&lt;caption&gt;</code></td><td align="left">定义表格标题。</td></tr><tr><td></td><td align="left"><code>&lt;th&gt;</code></td><td align="left">定义表格中的表头单元格。</td></tr><tr><td></td><td align="left"><code>&lt;tr&gt;</code></td><td align="left">定义表格中的行。</td></tr><tr><td></td><td align="left"><code>&lt;td&gt;</code></td><td align="left">定义表格中的单元。</td></tr><tr><td></td><td align="left"><code>&lt;thead&gt;</code></td><td align="left">定义表格中的表头内容。</td></tr><tr><td></td><td align="left"><code>&lt;tbody&gt;</code></td><td align="left">定义表格中的主体内容。</td></tr><tr><td></td><td align="left"><code>&lt;tfoot&gt;</code></td><td align="left">定义表格中的表注内容（脚注）。</td></tr><tr><td></td><td align="left"><code>&lt;col&gt;</code></td><td align="left">定义表格中一个或多个列的属性值。</td></tr><tr><td></td><td align="left"><code>&lt;colgroup&gt;</code></td><td align="left">定义表格中供格式化的列组。</td></tr><tr><td></td><td align="left"><strong>样式&#x2F;节</strong></td><td align="left"></td></tr><tr><td></td><td align="left"><code>&lt;style&gt;</code></td><td align="left">定义文档的样式信息。</td></tr><tr><td></td><td align="left"><code>&lt;div&gt;</code></td><td align="left">定义文档中的节。</td></tr><tr><td></td><td align="left"><code>&lt;span&gt;</code></td><td align="left">定义文档中的节。</td></tr><tr><td></td><td align="left"><code>&lt;header&gt;</code></td><td align="left">定义一个文档头部部分</td></tr><tr><td></td><td align="left"><code>&lt;footer&gt;</code></td><td align="left">定义一个文档底部</td></tr><tr><td></td><td align="left"><code>&lt;section&gt;</code></td><td align="left">定义了文档的某个区域</td></tr><tr><td></td><td align="left"><code>&lt;article&gt;</code></td><td align="left">定义一个文章内容</td></tr><tr><td></td><td align="left"><code>&lt;aside&gt;</code></td><td align="left">定义其所处内容之外的内容。</td></tr><tr><td></td><td align="left"><code>&lt;details&gt;</code></td><td align="left">定义了用户可见的或者隐藏的需求的补充细节。</td></tr><tr><td></td><td align="left"><code>&lt;dialog&gt;</code></td><td align="left">定义一个对话框或者窗口</td></tr><tr><td></td><td align="left"><code>&lt;summary&gt;</code></td><td align="left">定义一个可见的标题。 当用户点击标题时会显示出详细信息。</td></tr><tr><td></td><td align="left"><strong>元信息</strong></td><td align="left"></td></tr><tr><td></td><td align="left"><code>&lt;head&gt;</code></td><td align="left">定义关于文档的信息</td></tr><tr><td></td><td align="left"><code>&lt;meta&gt;</code></td><td align="left">定义关于 HTML 文档的元信息。</td></tr><tr><td></td><td align="left"><code>&lt;base&gt;</code></td><td align="left">定义页面中所有链接的默认地址或默认目标。</td></tr><tr><td></td><td align="left"><code>&lt;basefont&gt;</code></td><td align="left">HTML5不再支持。 HTML 4.01 已废弃。 定义页面中文本的默认字体、颜色或尺寸。</td></tr><tr><td></td><td align="left"><strong>程序</strong></td><td align="left"></td></tr><tr><td></td><td align="left"><code>&lt;script&gt;</code></td><td align="left">定义客户端脚本。</td></tr><tr><td></td><td align="left"><code>&lt;noscript&gt;</code></td><td align="left">定义针对不支持客户端脚本的用户的替代内容。</td></tr><tr><td></td><td align="left"><code>&lt;applet&gt;</code></td><td align="left">HTML5不再支持。 HTML 4.01 已废弃。 定义嵌入的 applet。</td></tr><tr><td></td><td align="left"><code>&lt;embed&gt;</code></td><td align="left">定义了一个容器，用来嵌入外部应用或者互动程序（插件）。</td></tr><tr><td></td><td align="left"><code>&lt;object&gt;</code></td><td align="left">定义嵌入的对象。</td></tr><tr><td></td><td align="left"><code>&lt;param&gt;</code></td><td align="left">定义对象的参数。</td></tr></tbody></table><h1 id="HTML-属性"><a href="#HTML-属性" class="headerlink" title="HTML 属性"></a>HTML 属性</h1><h2 id="HTML属性-的特征"><a href="#HTML属性-的特征" class="headerlink" title="HTML属性 的特征"></a>HTML属性 的特征</h2><ul><li>HTML 元素可以设置<strong>属性</strong></li><li>属性可以在元素中添加<strong>附加信息</strong></li><li>属性一般描述于<strong>开始标签</strong></li><li>属性总是以名称&#x2F;值对的形式出现，**比如：name&#x3D;”value”**。</li><li>属性值应该始终被包括在<strong>引号内</strong>。<ul><li>双引号是最常用的，在某些个别的情况下，比如属性值本身就含有双引号，那么您必须使用单引号。</li></ul></li></ul><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- href=&quot;http://www.baidu.com&quot; 就是 HTML属性 --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://www.baidu.com&quot;</span>&gt;</span> Baidu <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="参考List"><a href="#参考List" class="headerlink" title="参考List"></a>参考List</h2><h3 id="HTML-全局属性"><a href="#HTML-全局属性" class="headerlink" title="HTML 全局属性"></a>HTML 全局属性</h3><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>accesskey</code></td><td align="left">设置访问元素的键盘快捷键。</td></tr><tr><td align="left"><code>class</code></td><td align="left">规定元素的类名（classname）</td></tr><tr><td align="left"><code>contenteditable</code></td><td align="left">规定是否可编辑元素的内容。</td></tr><tr><td align="left"><code>contextmenu</code></td><td align="left">指定一个元素的上下文菜单。当用户右击该元素，出现上下文菜单</td></tr><tr><td align="left"><code>data-*</code></td><td align="left">用于存储页面的自定义数据</td></tr><tr><td align="left"><code>dir</code></td><td align="left">设置元素中内容的文本方向。</td></tr><tr><td align="left"><code>draggable</code></td><td align="left">指定某个元素是否可以拖动</td></tr><tr><td align="left"><code>dropzone</code></td><td align="left">指定是否将数据复制，移动，或链接，或删除</td></tr><tr><td align="left"><code>hidden</code></td><td align="left">hidden 属性规定对元素进行隐藏。</td></tr><tr><td align="left"><code>id</code></td><td align="left">规定元素的唯一 id</td></tr><tr><td align="left"><code>lang</code></td><td align="left">设置元素中内容的语言代码。</td></tr><tr><td align="left"><code>spellcheck</code></td><td align="left">检测元素是否拼写错误</td></tr><tr><td align="left"><code>style</code></td><td align="left">规定元素的行内样式（inline style）</td></tr><tr><td align="left"><code>tabindex</code></td><td align="left">设置元素的 Tab 键控制次序。</td></tr><tr><td align="left"><code>title</code></td><td align="left">规定元素的额外信息（可在工具提示中显示）</td></tr><tr><td align="left"><code>translate</code></td><td align="left">指定是否一个元素的值在页面载入时是否需要翻译</td></tr></tbody></table><h1 id="HTML-示例"><a href="#HTML-示例" class="headerlink" title="HTML 示例"></a>HTML 示例</h1><h2 id="文本格式化"><a href="#文本格式化" class="headerlink" title="文本格式化"></a>文本格式化</h2><p>HTML 使用标签 <code>&lt;b&gt;</code>(“bold”) 与 <code>&lt;i&gt;</code>(“italic”) 对输出的文本进行格式, 如：<b>粗体</b> or <i>斜体</i></p><blockquote><p>  通常标签 <code>&lt;strong&gt;</code> 替换加粗标签 <code>&lt;b&gt;</code> 来使用, <code>&lt;em&gt;</code> 替换 <code>&lt;i&gt;</code>标签使用。</p><p>  然而，这些标签的含义是不同的：</p><p>  <code>&lt;b&gt;</code> 与<code>&lt;i&gt;</code> 定义粗体或斜体文本。</p><p>  <code>&lt;strong&gt;</code> 或者 <code>&lt;em&gt;</code>意味着你要呈现的文本是重要的，所以要突出显示。（重要文本的呈现方式有很多种，不仅仅只有加粗一种）</p></blockquote><h2 id="链接-a"><a href="#链接-a" class="headerlink" title="链接 a"></a>链接 a</h2><p>HTML使用标签 <code>&lt;a&gt;</code> 来设置超文本链接。</p><p>超链接可以是<u>一个字，一个词，或者一组词，也可以是一幅图像</u>，您可以点击这些内容来跳转到新的文档或者当前文档中的某个部分。（<strong>文本链接、图像链接、锚点链接、下载链接</strong>）</p><p>在标签 <code>&lt;a&gt;</code> 中使用了 <strong>href</strong> 属性来描述链接的地址。</p><p>以下是 HTML 中创建链接的基本语法和属性：</p><ul><li><p><code>&lt;a&gt;</code> 元素：创建链接的主要HTML元素是<code>&lt;a&gt;</code>（锚）元素。<code>&lt;a&gt;</code>元素具有以下属性：</p><ul><li><p><code>href</code>：指定链接目标的URL，这是链接的最重要属性。可以是另一个网页的URL、文件的URL或其他资源的URL。</p></li><li><p><code>target</code>（可选）：指定链接如何在浏览器中打开。</p><ul><li><code>_blank</code>（在新标签或窗口中打开链接）</li><li><code>_self</code> 在单击的同一框架中打开链接文档（在当前标签或窗口中打开链接）。</li><li><code>_top</code> 在整个窗口中打开链接文档</li></ul></li><li><p><code>title</code>（可选）：提供链接的额外信息，通常在鼠标悬停在链接上时显示为工具提示。</p></li><li><p><code>rel</code>（可选）：指定与链接目标的关系，如 nofollow、noopener 等。</p></li></ul></li></ul><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><p><strong>文本链接：</strong>最常见的链接类型是文本链接，它使用 <code>&lt;a&gt;</code> 元素将一段文本转化为可点击的链接，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.example.com&quot;</span>&gt;</span>访问示例网站<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>图像链接：</strong>您还可以使用图像作为链接。在这种情况下，<code>&lt;a&gt;</code> 元素包围着 <code>&lt;img&gt;</code> 元素。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.example.com&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;example.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;示例图片&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>锚点链接：</strong>除了链接到其他网页外，您还可以在同一页面内创建内部链接，这称为锚点链接。要创建锚点链接，需要在目标位置使用 <code>&lt;a&gt;</code> 元素定义一个标记，并使用<code>#</code>符号引用该标记。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#section2&quot;</span>&gt;</span>跳转到第二部分<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 在页面中的某个位置 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;section2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#C4&quot;</span>&gt;</span>查看章节 4<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;C4&quot;</span>&gt;</span>章节 4<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这边显示该章节的内容……<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>下载链接：</strong>如果您希望链接用于下载文件而不是导航到另一个网页，可以使用 download 属性。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;document.pdf&quot;</span> <span class="hljs-attr">download</span>&gt;</span>下载文档<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>邮件链接</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;mailto:someone@example.com?cc=someoneelse@example.com&amp;bcc=andsomeoneelse@example.com&amp;subject=Summer%20Party&amp;body=You%20are%20invited%20to%20a%20big%20summer%20party!&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_top&quot;</span>&gt;</span>发送邮件!<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>mailto: 收件人 <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>cc= 抄送 <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>bcc= 密送 <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>subject= 标题 <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>body= 正文 <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>注意:<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span> 单词之间的空格使用 %20 代替，以确保浏览器可以正常显示文本。<br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="头部-head"><a href="#头部-head" class="headerlink" title="头部 head"></a>头部 head</h2><p><code>&lt;head&gt;</code> 元素包含了所有的头部标签元素。在 <code>&lt;head&gt;</code>元素中你可以插入脚本（scripts）, 样式文件（CSS），及各种meta信息。</p><p>可以添加在头部区域的元素标签为: <code>&lt;title&gt;</code>, <code>&lt;style&gt;</code>, <code>&lt;meta&gt;</code>, <code>&lt;link&gt;</code>, <code>&lt;script&gt;</code>, <code>&lt;noscript&gt;</code> 和 <code>&lt;base&gt;</code>。</p><h3 id="元素"><a href="#元素" class="headerlink" title="&lt;title&gt; 元素"></a><code>&lt;title&gt;</code> 元素</h3><p><code>&lt;title&gt;</code> 标签定义了不同文档的标题。</p><p><code>&lt;title&gt;</code> 在 HTML&#x2F;XHTML 文档中是必需的。</p><p><code>&lt;title&gt;</code> 元素:</p><ul><li>定义了浏览器工具栏的标题</li><li>当网页添加到收藏夹时，显示在收藏夹中的标题</li><li>显示在搜索引擎结果页面的标题</li></ul><h3 id="元素-1"><a href="#元素-1" class="headerlink" title="&lt;base&gt; 元素"></a><code>&lt;base&gt;</code> 元素</h3><p><code>&lt;base&gt;</code> 标签描述了基本的链接地址&#x2F;链接目标，该标签作为HTML文档中所有的链接标签的默认链接:</p><h3 id="元素-2"><a href="#元素-2" class="headerlink" title="&lt;link&gt; 元素"></a><code>&lt;link&gt;</code> 元素</h3><p><code>&lt;link&gt;</code> 标签定义了文档与外部资源之间的关系。</p><p><code>&lt;link&gt;</code> 标签通常用于链接到样式表</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 定义head处的图标 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;icon&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;logo.ico&quot;</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 使用外部样式表 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;mystyle.css&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="元素-3"><a href="#元素-3" class="headerlink" title="&lt;style&gt; 元素"></a><code>&lt;style&gt;</code> 元素</h3><p><code>&lt;style&gt;</code> 标签定义了HTML文档的样式文件引用地址.</p><p>在<code>&lt;style&gt;</code> 元素中你也可以直接添加样式来渲染 HTML 文档:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 将背景设置成黄色，段落设置成蓝色 --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-tag">body</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>:yellow;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-tag">p</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">color</span>:blue</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="元素-4"><a href="#元素-4" class="headerlink" title="&lt;meta&gt; 元素"></a><code>&lt;meta&gt;</code> 元素</h3><p>meta标签描述了一些基本的元数据。</p><p><code>&lt;meta&gt;</code> 标签提供了元数据.元数据也不显示在页面上，但会被浏览器解析。</p><p>META 元素通常用于指定网页的描述，关键词，文件的最后修改时间，作者，和其他元数据。</p><p>元数据可以使用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他Web服务。</p><p><code>&lt;meta&gt;</code> 一般放置于 <code>&lt;head&gt;</code> 区域</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;keywords&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;HTML, CSS, XML, XHTML, JavaScript&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;description&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;免费 Web &amp; 编程 教程&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;author&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;Runoob&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;refresh&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;30&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="元素-5"><a href="#元素-5" class="headerlink" title="&lt;script&gt; 元素"></a><code>&lt;script&gt;</code> 元素</h3><p><code>&lt;script&gt;</code>标签用于加载脚本文件，如： JavaScript。</p><h3 id="头部-head-元素"><a href="#头部-head-元素" class="headerlink" title="头部 head 元素"></a>头部 head 元素</h3><table><thead><tr><th align="left">标签</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>head</code></td><td align="left">定义了文档的信息</td></tr><tr><td align="left"><code>title</code></td><td align="left">定义了文档的标题</td></tr><tr><td align="left"><code>base</code></td><td align="left">定义了页面链接标签的默认链接地址</td></tr><tr><td align="left"><code>link</code></td><td align="left">定义了一个文档和外部资源之间的关系</td></tr><tr><td align="left"><code>meta</code></td><td align="left">定义了HTML文档中的元数据</td></tr><tr><td align="left"><code>script</code></td><td align="left">定义了客户端的脚本文件</td></tr><tr><td align="left"><code>style</code></td><td align="left">定义了HTML文档的样式文件</td></tr></tbody></table><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p>…</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">背景色<br>style=&quot;<span class="hljs-attribute">background-color</span>:green;&quot;<br>字体 字体颜色 字体大小<br>style=&quot;<span class="hljs-attribute">font-family</span>:arial;<span class="hljs-attribute">color</span>:red;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">20px</span>;&quot;<br>居中对齐<br>style=&quot;<span class="hljs-attribute">text-align</span>:center;&quot;<br></code></pre></td></tr></table></figure><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Header 1<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Header 2<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>row 1, cell 1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>row 1, cell 2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>row 2, cell 1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>row 2, cell 2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><table border="1">    <tr>        <th>Header 1</th>        <th>Header 2</th>    </tr>    <tr>        <td>row 1, cell 1</td>        <td>row 1, cell 2</td>    </tr>    <tr>        <td>row 2, cell 1</td>        <td>row 2, cell 2</td>    </tr></table><h3 id="表格元素"><a href="#表格元素" class="headerlink" title="表格元素"></a>表格元素</h3><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td><code>&lt;table&gt;</code></td><td>定义表格</td></tr><tr><td><code>&lt;th&gt;</code></td><td>定义表格的表头</td></tr><tr><td><code>&lt;tr&gt;</code></td><td>定义表格的行</td></tr><tr><td><code>&lt;td&gt;</code></td><td>定义表格单元</td></tr><tr><td><code>&lt;caption&gt;</code></td><td>定义表格标题</td></tr><tr><td><code>&lt;colgroup&gt;</code></td><td>定义表格列的组</td></tr><tr><td><code>&lt;col&gt;</code></td><td>定义用于表格列的属性</td></tr><tr><td><code>&lt;thead&gt;</code></td><td>定义表格的页眉</td></tr><tr><td><code>&lt;tbody&gt;</code></td><td>定义表格的主体</td></tr><tr><td><code>&lt;tfoot&gt;</code></td><td>定义表格的页脚</td></tr></tbody></table><h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><h3 id="元素-6"><a href="#元素-6" class="headerlink" title="&lt;div&gt; 元素"></a><code>&lt;div&gt;</code> 元素</h3><p>HTML <code>&lt;div&gt;</code> 元素是块级元素，它可用于组合其他 HTML 元素的容器。</p><p><code>&lt;div&gt;</code> 元素没有特定的含义。除此之外，由于它属于块级元素，浏览器会在其前后显示折行。</p><p>如果与 CSS 一同使用，<code>&lt;div&gt;</code> 元素可用于对大的内容块设置样式属性。</p><p><code>&lt;div&gt;</code> 元素的另一个常见的用途是文档布局。它取代了使用表格定义布局的老式方法。使用 <code>&lt;table&gt;</code> 元素进行文档布局不是表格的正确用法。<code>&lt;table&gt;</code> 元素的作用是显示表格化的数据。</p><h3 id="元素-7"><a href="#元素-7" class="headerlink" title="&lt;span&gt; 元素"></a><code>&lt;span&gt;</code> 元素</h3><p>HTML <code>&lt;span&gt;</code> 元素是内联元素，可用作文本的容器</p><p><code>&lt;span&gt;</code> 元素也没有特定的含义。</p><p>当与 CSS 一同使用时，<code>&lt;span&gt;</code> 元素可用于为部分文本设置样式属性。</p><h3 id="div-与-span-对比"><a href="#div-与-span-对比" class="headerlink" title="div 与 span 对比"></a>div 与 span 对比</h3><p><strong>块级元素 vs. 行内元素：</strong></p><ul><li><code>&lt;div&gt;</code> 是块级元素，它独占一行，可以设置宽度、高度以及边距等样式属性。它适合用于创建页面的大块结构，例如页面的主体区域、容器、布局等。</li><li><code>&lt;span&gt;</code> 是行内元素，它不会独占一行，宽度默认由其内容决定。它适合用于对文本或其他行内元素进行样式化、标记或包裹。</li></ul><p><strong>默认样式和布局：</strong></p><ul><li><code>&lt;div&gt;</code> 元素的默认样式为块级显示，会以块的形式占据可用空间。</li><li><code>&lt;span&gt;</code> 元素的默认样式为行内显示，它不会独占一行，只占据其内容的宽度。</li></ul><p><strong>嵌套关系：</strong></p><ul><li><code>&lt;div&gt;</code> 可以容纳其他块级元素和行内元素，包括其他的 <code>&lt;div&gt;</code> 和 <code>&lt;span&gt;</code> 元素。</li><li><code>&lt;span&gt;</code> 通常被用来包裹文本或其他行内元素，比如用来设置特定文本的样式。</li></ul><p>总之，<code>&lt;div&gt;</code> 用于创建页面结构和布局，而 <code>&lt;span&gt;</code> 用于对文本或行内元素进行样式化或包裹。它们在页面设计和样式设置中有不同的用途和作用。</p><h3 id="区块标签"><a href="#区块标签" class="headerlink" title="区块标签"></a>区块标签</h3><table><thead><tr><th align="left">标签</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>div</code></td><td align="left">定义了文档的区域，块级 (block-level)</td></tr><tr><td align="left"><code>span</code></td><td align="left">用来组合文档中的行内元素， 内联元素(inline)</td></tr></tbody></table><h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><p>HTML 表单用于收集用户的<strong>输入信息</strong>。</p><p>HTML 表单表示文档中的一个区域，此区域包含交互控件，将用户收集到的信息发送到 Web 服务器。</p><p>HTML 表单通常包含各种<u>输入字段、复选框、单选按钮、下拉列表等元素</u>。</p><ul><li><code>&lt;form&gt;</code> 元素用于创建表单，<code>action</code> 属性定义了表单数据提交的目标 URL，<code>method</code> 属性定义了提交数据的 HTTP 方法（这里使用的是 “post”）。</li><li><code>&lt;label&gt;</code> 元素用于为表单元素添加标签，提高可访问性。</li><li><code>&lt;input&gt;</code> 元素是最常用的表单元素之一，它可以创建文本输入框、密码框、单选按钮、复选框等。<code>type</code> 属性定义了输入框的类型，<code>id</code> 属性用于关联 <code>&lt;label&gt;</code> 元素，<code>name</code> 属性用于标识表单字段。</li><li><code>&lt;select&gt;</code> 元素用于创建下拉列表，而 <code>&lt;option&gt;</code> 元素用于定义下拉列表中的选项。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 文本输入框 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>用户名:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">required</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 密码输入框 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span>密码:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">required</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 单选按钮 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>性别:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;male&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;male&quot;</span> <span class="hljs-attr">checked</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;male&quot;</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;female&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;female&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;female&quot;</span>&gt;</span>女<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 复选框 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;subscribe&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;subscribe&quot;</span> <span class="hljs-attr">checked</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;subscribe&quot;</span>&gt;</span>订阅推送信息<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 下拉列表 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;country&quot;</span>&gt;</span>国家:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;country&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;country&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;cn&quot;</span>&gt;</span>CN<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;usa&quot;</span>&gt;</span>USA<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;uk&quot;</span>&gt;</span>UK<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 提交按钮 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h3><table><thead><tr><th align="left">标签</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>form</code></td><td align="left">定义供用户输入的表单</td></tr><tr><td align="left"><code>input</code></td><td align="left">定义输入域</td></tr><tr><td align="left"><code>textarea</code></td><td align="left">定义文本域 (一个多行的输入控件)</td></tr><tr><td align="left"><code>label</code></td><td align="left">定义了 <code>&lt;input&gt;</code> 元素的标签，一般为输入标题</td></tr><tr><td align="left"><code>fieldset</code></td><td align="left">定义了一组相关的表单元素，并使用外框包含起来</td></tr><tr><td align="left"><code>legend</code></td><td align="left">定义了 <code>&lt;fieldset&gt;</code> 元素的标题</td></tr><tr><td align="left"><code>select</code></td><td align="left">定义了下拉选项列表</td></tr><tr><td align="left"><code>optgroup</code></td><td align="left">定义选项组</td></tr><tr><td align="left"><code>option</code></td><td align="left">定义下拉列表中的选项</td></tr><tr><td align="left"><code>button</code></td><td align="left">定义一个点击按钮</td></tr><tr><td align="left"><code>datalist</code></td><td align="left">指定一个预先定义的输入控件选项列表</td></tr><tr><td align="left"><code>keygen</code></td><td align="left">定义了表单的密钥对生成器字段</td></tr><tr><td align="left"><code>output</code></td><td align="left">定义一个计算结果</td></tr></tbody></table><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><p>…</p><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><p>…</p><h2 id="字符实体"><a href="#字符实体" class="headerlink" title="字符实体"></a>字符实体</h2><p>在 HTML 中，某些字符是预留的。</p><p>在 HTML 中不能使用小于号（&lt;）和大于号（&gt;），这是因为浏览器会误认为它们是标签。</p><p>如果希望正确地显示预留字符，我们必须在 HTML 源代码中使用字符实体（character entities）。 字符实体类似这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html">&amp;*entity_name*;<br><span class="hljs-comment">&lt;!-- 或 --&gt;</span><br>&amp;#*entity_number*;<br></code></pre></td></tr></table></figure><p>如需显示小于号，我们必须这样写：&lt; 或 &#60; 或 &#060;  (<code>&amp;lt;</code> 或 <code>&amp;#60;</code> 或 <code>&amp;#060;</code>)</p>]]></content>
    
    
    <categories>
      
      <category>language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>语义化版本编号 Major、Minor、Patch</title>
    <link href="/2024/f0099803/"/>
    <url>/2024/f0099803/</url>
    
    <content type="html"><![CDATA[<h2 id="语义化版本（Semantic-Versioning）：Major、Minor-和-Patch-版本号解析"><a href="#语义化版本（Semantic-Versioning）：Major、Minor-和-Patch-版本号解析" class="headerlink" title="语义化版本（Semantic Versioning）：Major、Minor 和 Patch 版本号解析"></a>语义化版本（Semantic Versioning）：Major、Minor 和 Patch 版本号解析</h2><p>语义化版本，通常简称为SemVer，是一种软件版本号的标准化方案，旨在使软件版本号的管理更加透明和可预测。它主要由三个部分组成：Major（主版本号）、Minor（次版本号）和Patch（修订版本号）。在这篇文章中，我们将深入解释这三个部分的含义，并提供详细的示例来说明它们的用途和变更规则。</p><p>在RT-Thread内有如下代码段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* RT-Thread version information */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_VERSION_MAJOR                5               <span class="hljs-comment">/**&lt; Major version number (X.x.x) */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_VERSION_MINOR                1               <span class="hljs-comment">/**&lt; Minor version number (x.X.x) */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_VERSION_PATCH                0               <span class="hljs-comment">/**&lt; Patch version number (x.x.X) */</span></span><br><br><span class="hljs-comment">/* e.g. #if (RTTHREAD_VERSION &gt;= RT_VERSION_CHECK(4, 1, 0) */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_VERSION_CHECK(major, minor, revise)          ((major * 10000) + (minor * 100) + revise)</span><br><br><span class="hljs-comment">/* RT-Thread version */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTTHREAD_VERSION                RT_VERSION_CHECK(RT_VERSION_MAJOR, RT_VERSION_MINOR, RT_VERSION_PATCH)</span><br></code></pre></td></tr></table></figure><h3 id="Major（主版本号）"><a href="#Major（主版本号）" class="headerlink" title="Major（主版本号）"></a>Major（主版本号）</h3><p>Major版本号是语义化版本中的第一个数字，用于表示软件的主要版本变更。当进行大规模的、不兼容的变更时，应该增加Major版本号。主要变更包括：</p><ol><li><strong>不兼容的API更改</strong>：当你修改了软件的API，以至于旧版本的代码无法与新版本一起正常工作时，应该升级Major版本号。这可能包括删除、更改或添加API端点、参数或行为。</li><li><strong>重大功能新增</strong>：如果你引入了重要的新功能，这可能会改变用户的工作流程或提供新的能力，也应该升级Major版本号。</li><li><strong>废弃旧功能</strong>：当你计划废弃或删除旧的功能时，通常需要增加Major版本号，以提醒用户进行迁移。</li></ol><p>示例： 假设有一个虚构的图形处理库，当前版本号为1.0.0。如果开发团队决定删除现有API中的一个核心功能，这将导致现有的用户无法升级到新版本而不修改其代码，那么新版本的版本号应该升级到2.0.0。</p><h3 id="Minor（次版本号）"><a href="#Minor（次版本号）" class="headerlink" title="Minor（次版本号）"></a>Minor（次版本号）</h3><p>Minor版本号是语义化版本中的第二个数字，用于表示向后兼容的新功能添加。Minor版本号的变更包括：</p><ol><li><strong>新增功能</strong>：当你向软件添加新的功能，但这些功能不会破坏现有的API或功能，应该增加Minor版本号。</li><li><strong>改进现有功能</strong>：如果你对现有功能进行了改进，但这些改进不会导致现有用户的代码无法工作，也应该升级Minor版本号。</li><li><strong>向后兼容的API增强</strong>：如果你增加了现有API的参数、选项或能力，而这不会破坏已有的使用方式，也应该升级Minor版本号。</li></ol><p>示例： 继续以图形处理库为例，当前版本号为1.2.0。开发团队决定在库中添加一个全新的图像滤镜功能，但这不会破坏任何现有功能或API。在这种情况下，版本号应升级到1.3.0。</p><h3 id="Patch（修订版本号）"><a href="#Patch（修订版本号）" class="headerlink" title="Patch（修订版本号）"></a>Patch（修订版本号）</h3><p>Patch版本号是语义化版本中的第三个数字，用于表示向后兼容的错误修复或小的改进。Patch版本号的变更包括：</p><ol><li><strong>错误修复</strong>：当你解决现有功能或API中的错误时，应该升级Patch版本号。这些修复不应引入新的功能或改变现有的行为。</li><li><strong>性能优化</strong>：如果你对现有功能进行性能优化，而不会改变其行为，也应该升级Patch版本号。</li><li><strong>小的改进或修改</strong>：如果你进行了一些小的改进，但它们不会破坏向后兼容性，应该升级Patch版本号。</li></ol><p>示例： 继续以图形处理库为例，当前版本号为1.2.3。在测试中发现一个重要的Bug，它导致图像处理不正确。开发团队修复了这个问题，没有引入新的功能或改变现有功能，版本号应该升级到1.2.4。</p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>major</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码、硬件常见的缩写</title>
    <link href="/2024/fd896621/"/>
    <url>/2024/fd896621/</url>
    
    <content type="html"><![CDATA[<h1 id="代码、硬件常见的缩写"><a href="#代码、硬件常见的缩写" class="headerlink" title="代码、硬件常见的缩写"></a>代码、硬件常见的缩写</h1><p><strong>常用单词缩写</strong></p><table><thead><tr><th>全词</th><th>缩词&#x2F;简写</th><th>中译</th><th>全词</th><th>缩词&#x2F;简写</th><th>中译</th></tr></thead><tbody><tr><td>指令内核相关类</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>source</td><td>src</td><td>源头</td><td>default</td><td>def</td><td>默认</td></tr><tr><td>destination</td><td>dst或des</td><td>目的地，目标</td><td>define</td><td>def</td><td>定义</td></tr><tr><td>operator</td><td>optr</td><td>操作符</td><td>macro</td><td>mcr</td><td>宏</td></tr><tr><td>operand</td><td>opnd</td><td>操作数</td><td>return</td><td>ret</td><td>返回</td></tr><tr><td>offset</td><td>ofs</td><td>偏移</td><td>assemble</td><td>asm</td><td>汇编</td></tr><tr><td>clear</td><td>clr</td><td>清除</td><td>interrupt</td><td>intr</td><td>中断</td></tr><tr><td>move</td><td>mov</td><td>移动</td><td>priority</td><td>prio</td><td>优先级</td></tr><tr><td>instruction</td><td>instr</td><td>指令</td><td>vector</td><td>vect</td><td>向量</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>变量内存相关类</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>temperature</td><td>temper</td><td>温度</td><td>address</td><td>addr</td><td>地址</td></tr><tr><td>temporary</td><td>tmp</td><td>临时</td><td>pointer</td><td>ptr</td><td>指针</td></tr><tr><td>counter</td><td>ctr</td><td>计数器</td><td>buffer</td><td>buf</td><td>缓冲区</td></tr><tr><td>count</td><td>cnt</td><td>计数</td><td>stack</td><td>stk</td><td>堆</td></tr><tr><td>flag</td><td>flg</td><td>旗帜、标识</td><td>memory</td><td>mem</td><td>内存</td></tr><tr><td>parameter</td><td>par</td><td>参数</td><td>storage</td><td>stg</td><td>存储器</td></tr><tr><td>argument</td><td>arg</td><td>参数</td><td>block</td><td>blk</td><td>块</td></tr><tr><td>variable</td><td>var</td><td>变量</td><td>allocate</td><td>alloc</td><td>分配</td></tr><tr><td>array</td><td>arr</td><td>数组</td><td>object</td><td>obj</td><td>对象</td></tr><tr><td>string</td><td>str</td><td>字符串</td><td></td><td></td><td></td></tr><tr><td>character</td><td>char</td><td>字符</td><td></td><td></td><td></td></tr><tr><td>数学计算相关类</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>increment</td><td>inc</td><td>增加</td><td>average</td><td>avg</td><td>平均数</td></tr><tr><td>decrease</td><td>dec</td><td>减少</td><td>summation</td><td>sum</td><td>求和;总和</td></tr><tr><td>addition</td><td>add</td><td>增加；加法</td><td>calculate</td><td>calc</td><td>计算</td></tr><tr><td>subtraction</td><td>sub</td><td>减少，减法</td><td>total</td><td>tot</td><td>总计</td></tr><tr><td>multiplication</td><td>mul</td><td>乘法</td><td>magnitude</td><td>mag</td><td>巨大</td></tr><tr><td>division</td><td>div</td><td>除法；除以</td><td>maximum</td><td>max</td><td>最大</td></tr><tr><td>proportion</td><td>kp</td><td>比例</td><td>minimum</td><td>min</td><td>最小</td></tr><tr><td>integral</td><td>ki</td><td>积分</td><td>middle</td><td>mid</td><td>中间</td></tr><tr><td>differential</td><td>kd</td><td>微分</td><td>equivalent</td><td>equiv</td><td>相等的</td></tr><tr><td>absolute</td><td>abs</td><td>绝对值</td><td>greater equal</td><td>ge</td><td>大于等于</td></tr><tr><td>algorithm</td><td>algo</td><td>算法</td><td>greater than</td><td>gt</td><td>大于</td></tr><tr><td>exponent</td><td>expo</td><td>指数</td><td>less equal</td><td>le</td><td>小于等于</td></tr><tr><td>recur</td><td>recu</td><td>递归</td><td>less than</td><td>lt</td><td>小于</td></tr><tr><td>limit</td><td>lim</td><td>限制</td><td>quarter</td><td>quar</td><td>四分之一</td></tr><tr><td>mantissa</td><td>mant</td><td>尾数</td><td>scale</td><td>scal</td><td>比例</td></tr><tr><td>fraction</td><td>fract</td><td>小数</td><td>double</td><td>dbl</td><td>两倍</td></tr><tr><td>digit</td><td>dig</td><td>数字</td><td></td><td></td><td></td></tr><tr><td>number</td><td>num</td><td>数字；数量</td><td></td><td></td><td></td></tr><tr><td>value</td><td>val</td><td>值</td><td></td><td></td><td></td></tr><tr><td>其他计算相关类</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>reference</td><td>ref</td><td>引用，参考</td><td>between</td><td>btw</td><td>之间</td></tr><tr><td>compare</td><td>cmp</td><td>比较</td><td>interval</td><td>intvl</td><td>间隔</td></tr><tr><td>different</td><td>diff</td><td>对比</td><td>different</td><td>diff</td><td>区别</td></tr><tr><td>optimization</td><td>opt</td><td>最优化</td><td>error</td><td>err</td><td>错误</td></tr><tr><td>degree</td><td>deg</td><td>度数，程度</td><td>exception</td><td>exc</td><td>异常</td></tr><tr><td>full</td><td>ful</td><td>全量</td><td></td><td></td><td></td></tr><tr><td>multiplex</td><td>mux</td><td>多路复用</td><td>result</td><td>rslt</td><td>结果</td></tr><tr><td>overflow</td><td>ovf</td><td>溢出</td><td>complete</td><td>comp</td><td>完成</td></tr><tr><td>check</td><td>chk</td><td>检查，核对</td><td>success</td><td>succ</td><td>成功</td></tr><tr><td>test</td><td>tst</td><td>测试</td><td>error</td><td>err</td><td>错误</td></tr><tr><td>detect</td><td></td><td>检测，识别</td><td></td><td></td><td></td></tr><tr><td>measure</td><td>meas</td><td>测量</td><td></td><td></td><td></td></tr><tr><td>sample</td><td>smp</td><td>样本</td><td></td><td></td><td></td></tr><tr><td>make</td><td>mk</td><td>制造</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>时间顺序相关类</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>timer</td><td>tmr或tim</td><td>定时器</td><td>new</td><td></td><td>新的</td></tr><tr><td>time</td><td>tm</td><td>时间</td><td>old</td><td></td><td>老的；旧的</td></tr><tr><td>second</td><td>sec</td><td>秒、第二</td><td>now</td><td></td><td>现在；目前</td></tr><tr><td>minute</td><td>min</td><td>分钟</td><td>current</td><td>cur</td><td>当前</td></tr><tr><td>hour</td><td>hr</td><td>小时</td><td>previous</td><td>prev</td><td>先前的</td></tr><tr><td>day</td><td></td><td>天</td><td>delay</td><td>dly</td><td>延迟</td></tr><tr><td>month</td><td>mth</td><td>月</td><td>expiration</td><td>expi</td><td>过期</td></tr><tr><td>year</td><td></td><td>年</td><td>next</td><td>nex</td><td>下一个</td></tr><tr><td>period</td><td>perd</td><td>时期</td><td></td><td></td><td></td></tr><tr><td>timestamp</td><td>ts</td><td>时间戳</td><td></td><td></td><td></td></tr><tr><td>timeout</td><td>to</td><td>超时</td><td></td><td></td><td></td></tr><tr><td>age</td><td></td><td>年龄</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>结构方向相关类</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>positon</td><td>pos</td><td>位置</td><td>origin</td><td>org</td><td>起源，原点</td></tr><tr><td>coordinates</td><td>coord</td><td>坐标系</td><td>point</td><td>pt</td><td>点</td></tr><tr><td>row</td><td></td><td>行</td><td>rect</td><td>rc</td><td>矩形</td></tr><tr><td>column</td><td>col</td><td>列</td><td>rectangle</td><td>rect</td><td>长方形</td></tr><tr><td>vertical</td><td>vert&#x2F;v</td><td>垂直</td><td>cylinder</td><td>cyl</td><td>圆柱体</td></tr><tr><td>horizontal</td><td>hori&#x2F;h</td><td>水平的</td><td>length</td><td>len</td><td>长度</td></tr><tr><td>dimension</td><td>dim</td><td>维度</td><td>high</td><td>hi</td><td>高度；高的</td></tr><tr><td>permutation</td><td>perm</td><td>排列</td><td>invert</td><td>invt</td><td>颠倒</td></tr><tr><td>信息相关类</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>information</td><td>info</td><td>信息</td><td>command</td><td>cmd</td><td>命令</td></tr><tr><td>communication</td><td>comu</td><td>通信</td><td>config</td><td>conf</td><td>配置</td></tr><tr><td>message</td><td>msg</td><td>消息；信息</td><td>request</td><td>req</td><td>请求</td></tr><tr><td>packet</td><td>pkt</td><td>信息包</td><td>acknowledge</td><td>ack</td><td>承认；应答</td></tr><tr><td>package</td><td>pkg</td><td>包</td><td>answer</td><td>ans</td><td>回答</td></tr><tr><td>protocol</td><td>proto</td><td>协议</td><td>response</td><td>rsp</td><td>响应</td></tr><tr><td>stream</td><td>stm</td><td>流</td><td></td><td></td><td></td></tr><tr><td>header</td><td>hdr</td><td>头</td><td></td><td></td><td></td></tr><tr><td>index</td><td>idx</td><td>索引</td><td>decode</td><td>deco</td><td>解码</td></tr><tr><td>frame</td><td>frm</td><td>帧率；框架</td><td>encode</td><td>enc</td><td>编码</td></tr><tr><td>clock</td><td>clok</td><td>时钟</td><td>coding</td><td></td><td>译码；编码</td></tr><tr><td>receive</td><td>recv</td><td>接收</td><td>authentication</td><td>auth</td><td>校验</td></tr><tr><td>send</td><td>send</td><td>发送</td><td>authentication code</td><td>authcode</td><td>校验码</td></tr><tr><td>context</td><td>ctx</td><td>上下文</td><td>unknown</td><td>unk</td><td>未知</td></tr><tr><td>connect</td><td>con</td><td>连接</td><td>extension</td><td>ext</td><td>扩展</td></tr><tr><td>ethernet</td><td>eth</td><td>以太网</td><td>expand</td><td>expa</td><td>扩展</td></tr><tr><td>mailbox</td><td>mbox</td><td>邮箱</td><td>field</td><td>fld</td><td>字段</td></tr><tr><td>mask</td><td>msk</td><td>掩码</td><td>identifier</td><td>id</td><td>标识符</td></tr><tr><td></td><td></td><td></td><td>decode</td><td>deco</td><td>解码</td></tr><tr><td></td><td></td><td></td><td>encode</td><td>enc</td><td>编码</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>计算机动作操作类</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>construct</td><td>cons</td><td>构建</td><td>select</td><td>sel</td><td>选择</td></tr><tr><td>control</td><td>ctl</td><td>控制</td><td>delete</td><td>del</td><td>删除</td></tr><tr><td>execute</td><td>exec</td><td>执行</td><td>insert</td><td>ins</td><td>插入</td></tr><tr><td>register</td><td>reg</td><td>注册</td><td>copy</td><td>cpy</td><td>复制</td></tr><tr><td>click</td><td>clk</td><td>点击</td><td>paste</td><td></td><td>粘贴</td></tr><tr><td>back</td><td>bk</td><td>后退</td><td>cut</td><td></td><td>剪切</td></tr><tr><td>disable</td><td>dis</td><td>使失效</td><td>print</td><td>Prn&#x2F;prt</td><td>打印</td></tr><tr><td>enable</td><td>en</td><td>使能</td><td>input</td><td>in</td><td>输入</td></tr><tr><td>effective</td><td>eff</td><td>有效的</td><td>output</td><td>out</td><td>输出</td></tr><tr><td>invalid</td><td>inv</td><td>无效的</td><td>lock</td><td>lck</td><td>上锁</td></tr><tr><td>logic</td><td>lgc</td><td>逻辑的</td><td>unlock</td><td>unlk</td><td>解锁</td></tr><tr><td>read</td><td>r</td><td>读</td><td>scan</td><td>sca</td><td>扫描</td></tr><tr><td>write</td><td>w</td><td>写</td><td>search</td><td>srch</td><td>搜索</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>计算机专业名称类</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>iteration</td><td>itr</td><td>迭代；反复；重复</td><td>initialization</td><td>init</td><td>初始化</td></tr><tr><td>version</td><td>ver</td><td>版本</td><td>program</td><td>prg</td><td>程序</td></tr><tr><td>password</td><td>psw</td><td>密码</td><td>system</td><td>sys</td><td>系统</td></tr><tr><td>permission</td><td>perms</td><td>许可</td><td>android</td><td>adr</td><td>安卓操作系统</td></tr><tr><td>device</td><td>dev</td><td>设备</td><td>application</td><td>app</td><td>应用程序</td></tr><tr><td>administrator</td><td>adm</td><td>管理员</td><td>driver</td><td>drv</td><td>驱动</td></tr><tr><td>manager</td><td>mgr</td><td>管理者，管理器</td><td>update</td><td>upd</td><td>更新</td></tr><tr><td>standard</td><td>std</td><td>标准</td><td>upgrade</td><td>upg</td><td>升级</td></tr><tr><td>library</td><td>lib</td><td>静态库</td><td>environment</td><td>env</td><td>运行环境</td></tr><tr><td>database</td><td>db</td><td>数据库</td><td>process</td><td>proc</td><td>进程</td></tr><tr><td>dynamic</td><td>dyna</td><td>动态</td><td>ready</td><td>rdy</td><td>就绪</td></tr><tr><td>synchronization</td><td>sync</td><td>同步</td><td>suspend</td><td>susp</td><td>挂起</td></tr><tr><td>asynchronization</td><td>asyn</td><td>异步</td><td>status</td><td>sts</td><td>状态</td></tr><tr><td>link</td><td>lnk</td><td>链接</td><td>signal</td><td>sig</td><td>信号</td></tr><tr><td>server</td><td>svr</td><td>服务</td><td>semaphore</td><td>sem</td><td>信号量</td></tr><tr><td>executable file</td><td>exe</td><td>可执行文件</td><td>scheduler</td><td>scher</td><td>调度器</td></tr><tr><td>sequence</td><td>seq</td><td>序列</td><td>task</td><td>tsk</td><td>任务</td></tr><tr><td>serialize</td><td>seri</td><td>序列化</td><td>statistic</td><td>stat</td><td>统计</td></tr><tr><td>virus</td><td>vir</td><td>病毒</td><td>process</td><td>proc</td><td>进程</td></tr><tr><td></td><td></td><td></td><td>ready</td><td>rdy</td><td>就绪</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>文档图片类</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>directory</td><td>dir</td><td>目录</td><td><a href="https://so.csdn.net/so/search?q=bitmap&spm=1001.2101.3001.7020">bitmap</a></td><td>bmp</td><td>位图纹理</td></tr><tr><td>list</td><td>lst</td><td>列表</td><td>image</td><td>img</td><td>图像</td></tr><tr><td>log</td><td>log</td><td>日志</td><td>picture</td><td>pic</td><td>图片</td></tr><tr><td>document</td><td>doc</td><td>文档</td><td>color</td><td>clr</td><td>颜色</td></tr><tr><td>text</td><td>txt</td><td>文本</td><td>record</td><td>rcd</td><td>记录</td></tr><tr><td>table</td><td>tab或tbl</td><td>表格</td><td>dictionary</td><td>dict</td><td>词典、字典</td></tr><tr><td>manual</td><td>man</td><td>手册</td><td></td><td></td><td></td></tr><tr><td>specification</td><td>spec</td><td>说明</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>软件界面名称类</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>screen</td><td>scr</td><td>屏幕</td><td>button</td><td>btn</td><td>按钮</td></tr><tr><td>display</td><td>disp</td><td>显示</td><td>component</td><td>com</td><td>组件(多用于ui组件目录命名)</td></tr><tr><td>util</td><td></td><td>工具</td><td>window</td><td>wnd</td><td>窗口</td></tr><tr><td>attribute</td><td>attr</td><td>属性</td><td>dialog</td><td>dlg</td><td>对话框</td></tr><tr><td>feature</td><td>fea</td><td>特征</td><td>cursor</td><td>csr</td><td>光标</td></tr><tr><td>bottom</td><td>btm</td><td>底部</td><td>markdown</td><td>md</td><td>文本标记语言</td></tr><tr><td>descriptor</td><td>desc</td><td>描述符</td><td></td><td></td><td></td></tr><tr><td>visible</td><td>vis</td><td>可见的</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>电气相关类</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>frequency</td><td>freq</td><td>频率</td><td>poweron</td><td>pwron</td><td>上电</td></tr><tr><td>voltage</td><td>vol</td><td>电压</td><td>back electromotive force</td><td>BEF</td><td>反电动势</td></tr><tr><td>current</td><td>cur</td><td>电流</td><td>speed</td><td>spd</td><td>速度</td></tr><tr><td>power</td><td>pwr</td><td>功率&#x2F;电源</td><td>electric</td><td>elec</td><td>电子的</td></tr><tr><td>trigger</td><td>trig</td><td>触发器</td><td></td><td></td><td></td></tr><tr><td>threshold</td><td>thold</td><td>阈值</td><td></td><td></td><td></td></tr><tr><td>switch</td><td>sw</td><td>开关</td><td></td><td></td><td></td></tr><tr><td>toggle</td><td>tgl</td><td>切换</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>其他类</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>resource</td><td>res</td><td>资源</td><td>prefix</td><td>pre</td><td>前缀</td></tr><tr><td>region</td><td>rgn</td><td>区域、领域</td><td>reactive</td><td>react</td><td>有反应的</td></tr><tr><td>group</td><td>grp</td><td>组</td><td>recall</td><td>rcl</td><td>召回</td></tr><tr><td>assemble</td><td>asm</td><td>集合</td><td>release</td><td>rel</td><td>发布</td></tr><tr><td></td><td></td><td></td><td>repeat</td><td>rpt</td><td>重复</td></tr><tr><td>action</td><td>act</td><td>动作</td><td>duplicate</td><td>dup</td><td>重复</td></tr><tr><td>common</td><td>comm</td><td>通用</td><td>repository</td><td>repo</td><td>仓库</td></tr><tr><td>dependency</td><td>dep</td><td>依赖</td><td>reserve</td><td>resv</td><td>保留</td></tr><tr><td>debug</td><td>dbg</td><td>调试</td><td>reset</td><td>rst</td><td>重置</td></tr><tr><td>direct</td><td>dirt</td><td>直接的</td><td>resume</td><td>resu</td><td>重新开始</td></tr><tr><td>engine</td><td>eng</td><td>引擎</td><td>reverse</td><td>revs</td><td>反转</td></tr><tr><td>experiment</td><td>exp</td><td>实验</td><td>schedule</td><td>sch</td><td>计划</td></tr><tr><td>exposure</td><td>expo</td><td>曝光</td><td>section</td><td>sect</td><td>节</td></tr><tr><td>generate</td><td>gen</td><td>产生</td><td>segment</td><td>seg</td><td>段</td></tr><tr><td>handler</td><td></td><td>处理者</td><td>strategy</td><td>stra</td><td>策略</td></tr><tr><td>marshal</td><td>mar</td><td>序列化</td><td>change</td><td>chg</td><td>改变</td></tr><tr><td>unmarshal</td><td>unmar</td><td>反序列化</td><td>convert</td><td>conv</td><td>转换</td></tr><tr><td>deserialize</td><td>dese</td><td>反序列化</td><td>translate</td><td>tran</td><td>翻译，转换</td></tr><tr><td>manufacturer</td><td>mft</td><td>制造商</td><td></td><td></td><td></td></tr><tr><td>positive</td><td>posi</td><td>积极的</td><td></td><td></td><td></td></tr><tr><td>negative</td><td>neg</td><td>消极的</td><td></td><td></td><td></td></tr><tr><td>neutral</td><td>neut</td><td>中立</td><td></td><td></td><td></td></tr><tr><td>quality</td><td>qlty</td><td>质量</td><td></td><td></td><td></td></tr><tr><td>properties</td><td>prop</td><td>性能</td><td></td><td></td><td></td></tr><tr><td>performance</td><td>perf</td><td>性能</td><td></td><td></td><td></td></tr><tr><td>product</td><td>prod</td><td>产品</td><td></td><td></td><td></td></tr><tr><td>profile</td><td>pf</td><td>用户画像</td><td></td><td></td><td></td></tr><tr><td>project</td><td>proj</td><td>项目</td><td></td><td></td><td></td></tr><tr><td>protect</td><td>prot</td><td>保护</td><td></td><td></td><td></td></tr><tr><td>proxy</td><td>prx</td><td>代理</td><td></td><td></td><td></td></tr><tr><td>public</td><td>pub</td><td>公共的</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p><strong>常用反义词组</strong></p><table><thead><tr><th>词</th><th>反义词</th><th>中译</th><th>词</th><th>反义词</th><th>中译</th></tr></thead><tbody><tr><td>add</td><td>remove</td><td>添加&#x2F;移除</td><td>min</td><td>max</td><td>最小&#x2F;最大</td></tr><tr><td>add</td><td>delete</td><td>添加&#x2F;删除</td><td>old</td><td>new</td><td>旧&#x2F;新</td></tr><tr><td>begin</td><td>end</td><td>开始&#x2F;最后</td><td>start</td><td>stop</td><td>开始&#x2F;停止</td></tr><tr><td>create</td><td>destroy</td><td>创建&#x2F;破坏</td><td>next</td><td>previous</td><td>下个&#x2F;以前的</td></tr><tr><td>insert</td><td>delete</td><td>插入&#x2F;删除</td><td>source</td><td>target</td><td>源头&#x2F;目标</td></tr><tr><td>first</td><td>last</td><td>第一&#x2F;最后</td><td>show</td><td>hide</td><td>显示&#x2F;隐藏</td></tr><tr><td>get</td><td>release</td><td>获得&#x2F;释放</td><td>send</td><td>receive</td><td>发送&#x2F;接收</td></tr><tr><td>put</td><td>get</td><td>放下&#x2F;获得</td><td>source</td><td>destination</td><td>源头&#x2F;目的</td></tr><tr><td>increment</td><td>decrement</td><td>增加&#x2F;减少</td><td>cut</td><td>paste</td><td>剪切&#x2F;粘贴</td></tr><tr><td>lock</td><td>unlock</td><td>上锁&#x2F;解锁</td><td>up</td><td>down</td><td>上&#x2F;下</td></tr><tr><td>open</td><td>close</td><td>打开&#x2F;关闭</td><td>top</td><td>btm</td><td>顶部&#x2F;底部</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>words</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RustDesk</title>
    <link href="/2023/c98db97a/"/>
    <url>/2023/c98db97a/</url>
    
    <content type="html"><![CDATA[<h1 id="Server-搭建"><a href="#Server-搭建" class="headerlink" title="Server 搭建"></a>Server 搭建</h1><p>RustDesk Server OSS<strong>功能简单</strong>，<strong>无需许可证</strong>，RustDesk Server Pro<strong>功能更强</strong>，<strong>需要许可证</strong>。</p><p>参考官方<a href="https://rustdesk.com/docs/en/self-host/rustdesk-server-oss/">文档</a>。</p><h2 id="RustDesk-Server-OSS-搭建"><a href="#RustDesk-Server-OSS-搭建" class="headerlink" title="RustDesk Server OSS 搭建"></a>RustDesk Server OSS 搭建</h2><p>RustDesk Server OSS有两个程序<code>hbbs</code>和<code>hbbr</code>。</p><ul><li><code>hbbs</code>- RustDesk ID&#x2F;Rendezvous 服务器</li><li><code>hbbr</code>- RustDesk 中继服务器</li></ul><blockquote><p>  默认情况下，</p><p>  <code>hbbs</code> 侦听 21115 (TCP)、21116 (TCP&#x2F;UDP) 和 21118 (TCP)，</p><p>  <code>hbbr</code> 侦听 21117 (TCP) 、21119（TCP）。</p><p>  请务必在防火墙中打开这些端口。 <strong>请注意，TCP 和 UDP 都应启用 21116。</strong> </p><p>  21115 用于 NAT 类型测试，21116&#x2F;UDP 用于 ID 注册，心跳服务，21116&#x2F;TCP用于TCP打洞和连接服务，21117用于Relay服务，21118和21119用于支持Web客户端。 </p><p>  <em>如果不需要Web客户端（21118、21119）支持，可以禁用相应端口。</em></p></blockquote><ul><li>TCP (<strong>21115、21116、21117、21118、21119</strong>)</li><li>UDP (<strong>21116</strong>)</li></ul><p>关闭防火墙对端口的封锁：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">ufw allow 21115:21119/tcp<br>ufw allow 21116/udp<br>sudo ufw enable<br></code></pre></td></tr></table></figure><h3 id="服务器硬件要求"><a href="#服务器硬件要求" class="headerlink" title="服务器硬件要求"></a>服务器硬件要求</h3><blockquote><h5 id="服务器要求"><a href="#服务器要求" class="headerlink" title="服务器要求"></a>服务器要求</h5><p>  硬件要求很低；基础云服务器最低配置就够了，对CPU和内存的要求也很低。您还可以使用 Raspberry Pi 或类似的东西。从网络规模来看，如果TCP打洞直连失败，会消耗中继流量。中继连接的流量在 30 K&#x2F;s 到 3 M&#x2F;s（1920x1080 屏幕）之间，具体取决于分辨率设置和屏幕更新。如果只是办公需求，流量在100K&#x2F;s左右。</p></blockquote><h3 id="hbbr-的运行"><a href="#hbbr-的运行" class="headerlink" title="hbbr 的运行"></a>hbbr 的运行</h3><blockquote><p>  <code>hbbs</code>第一次运行时，会自动生成一对加密的私钥和<strong>公钥</strong>（分别位于<code>id_ed25519</code>和<code>id_ed25519.pub</code>运行目录下的文件），其主要目的是通信加密。</p><p>  <strong>公钥就是我们需要填入Client端的key</strong></p><p>  如果您想禁止没有密钥的用户建立非加密连接，请在运行时添加<code>-k _</code>参数<code>hbbs</code>和<code>hbbr</code>。</p><p>  <em>注意不要漏写了下划线</em> 例如：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">./hbbs -r &lt;relay-server-ip[:port]&gt; -k _<br>./hbbr -k _<br></code></pre></td></tr></table></figure></blockquote><h3 id="使用Docker搭建"><a href="#使用Docker搭建" class="headerlink" title="使用Docker搭建"></a>使用Docker搭建</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo docker image pull rustdesk/rustdesk-server<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-v 映射文件夹 容器内 /root 目录会存放key文件等</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">hbbs 的 -r 参数是 服务器地址</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">hbbs 和 hbbr 的 -k 参数是 禁止没有密钥的用户建立非加密连接</span><br>sudo docker run --name hbbs -v ./data:/root -td -m 64M --restart=on-failure --net=host rustdesk/rustdesk-server hbbs -r &lt;relay-server-ip[:port]&gt; -k _<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-built_in">sudo</span> docker run --name hbbr -v ./data:/root -td -m 64M --restart=on-failure --net=host rustdesk/rustdesk-server hbbr -k _</span><br><br></code></pre></td></tr></table></figure><h1 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h1><p>在 RustDesk 客户端主主页中，单击 ID 旁边的菜单按钮 [ ⋮ ]，然后单击网络，您现在可以使用提升的权限解锁设置并设置您的 ID、中继、API 和密钥。</p><p><img src="/2023/c98db97a/network-config.png" alt="img"></p><p>在<strong>ID Server</strong>输入框中输入<code>hbbs</code>的域名或IP地址。</p><p>另外两个地址可以留空，RustDesk会自动推导（如果没有专门设置），Relay Server指的是<code>hbbr</code>（端口21117）。</p><p>Key的数值：Docker中可以在<code>data</code>文件夹找到<code>id_ed25519.pub</code>文件，此文件内容即为key。</p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RustDesk</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>USB</title>
    <link href="/2023/9c721b62/"/>
    <url>/2023/9c721b62/</url>
    
    <content type="html"><![CDATA[<h1 id="USB-版本及发展历史"><a href="#USB-版本及发展历史" class="headerlink" title="USB 版本及发展历史"></a>USB 版本及发展历史</h1><p>USB接口自1994年推出以来，经过26年的发展，经过USB1.0&#x2F;1.1、USB2.0、USB3.x，最终发展到了现在的USB4；传输速率也从最开始的1.5Mbps，大幅提高到了最新的40Gbps。<br><img src="/2023/9c721b62/image-20240621114302408.png"></p><h2 id="USB1-0"><a href="#USB1-0" class="headerlink" title="USB1.0"></a>USB1.0</h2><ul><li>1996年1月15日推出USB1.0接口规范</li><li>规定低速传输速率为1.5Mbit&#x2F;s</li><li>对外提供供电电压为5V，最大电流500mA</li><li>一般适用于鼠标、键盘等低速HID设备。</li><li>支持热插拨</li></ul><h2 id="USB1-1"><a href="#USB1-1" class="headerlink" title="USB1.1"></a>USB1.1</h2><ul><li>1998年9月23日对原来的USB1.0进行升级，提出了USB1.1</li><li>USB1.1规定了全速传输速率为12Mbit&#x2F;s,并兼容USB1.0的1.5Mbit&#x2F;s</li><li>传输线缆最大度度3m</li><li>对外提供供电电压为5V，最大电流500mA</li><li>一般适用于鼠标、键盘、U盘，光驱等。</li><li>一个USB接口理论上可以支持127个设备。</li></ul><h2 id="USB2-0"><a href="#USB2-0" class="headerlink" title="USB2.0"></a>USB2.0</h2><ul><li>2000年4月27日由USB-IF组织提出了USB2.0总线协议规范</li><li>具备480Mbit&#x2F;s的高速传输速率，向下兼容低速1.5Mbit&#x2F;s和全速12Mit&#x2F;s</li><li>传输线缆最大度度5m</li><li>对外提供供电电压为5V，最大电流500mA</li><li>通过HUB级联的方式，一个USB接口理论上可以扩展127个USB设备</li><li>支持 4种传输方式：控制传输、中断传输、同步传输和块传输。</li></ul><p><strong>USB3 的名字有些多</strong></p><table><thead><tr><th>版本</th><th>时间</th><th>带宽</th><th>别名，指的是同一种</th></tr></thead><tbody><tr><td>USB3.0</td><td>2008年11月17</td><td>5Gbps</td><td>SuperSpeed USB、USB 3.2 Gen 1、USB 3.1 Gen 1</td></tr><tr><td>USB3.1</td><td>2013年7月</td><td>10Gbps</td><td>SuperSpeed USB 10Gbps、USB 3.2 Gen 2、USB 3.1 Gen 2</td></tr><tr><td>USB3.2</td><td>2017年9月份</td><td>20Gbps</td><td>SuperSpeed USB 20Gbps、USB 3.2 Gen 2x2</td></tr></tbody></table><h2 id="USB3-0-USB-3-2-Gen-1-USB-3-1-Gen-1"><a href="#USB3-0-USB-3-2-Gen-1-USB-3-1-Gen-1" class="headerlink" title="USB3.0 &#x2F; USB 3.2 Gen 1 &#x2F; USB 3.1 Gen 1"></a>USB3.0 &#x2F; USB 3.2 Gen 1 &#x2F; USB 3.1 Gen 1</h2><ul><li>超高速USB3.0规范于2008年11月17日出USB-IF组织推出。</li><li>提供更高的5.0Gbit&#x2F;s的超高速传输速度，并向下兼容低速1.5Mbits&#x2F;s、全速12Mbit&#x2F;s和高速480Mbit&#x2F;s传输速率</li><li>对外提供供电电压为5V，最大电流900mA</li><li>传输线缆最大度度3m</li><li>增加了新的电源管理功能，支持待机、睡眠以及暂定模式，更加省电。</li><li>全双工通讯。</li></ul><h2 id="USB3-1-USB-3-2-Gen-2-USB-3-1-Gen-2"><a href="#USB3-1-USB-3-2-Gen-2-USB-3-1-Gen-2" class="headerlink" title="USB3.1 &#x2F; USB 3.2 Gen 2 &#x2F; USB 3.1 Gen 2"></a>USB3.1 &#x2F; USB 3.2 Gen 2 &#x2F; USB 3.1 Gen 2</h2><p>2013年7月份，USB 3.1发布，速度翻番至10Gbps，同时USB-IF就把USB 3.0改名为USB 3.1 Gen 1，新的USB 3.1则叫做USB 3.1 Gen 2。</p><ul><li>2013年7月份发布</li><li>速度翻番至10Gbps</li><li>新增USB A&#x2F;V影音传输。以更适合作为移动设备的输出接口，尤其是可逆的Type-C。</li><li>将供电的最高允许标准提高到了20V&#x2F;5A，供电100W。</li><li>必须使用USB Type-C接口才能达到10Gbps的速度。</li></ul><h2 id="USB3-2-USB-3-2-Gen-2x2"><a href="#USB3-2-USB-3-2-Gen-2x2" class="headerlink" title="USB3.2 &#x2F; USB 3.2 Gen 2x2"></a>USB3.2 &#x2F; USB 3.2 Gen 2x2</h2><ul><li>2017年9月份，USB 3.2发布。</li><li>据最新公布的规范，USB 3.0、USB 3.1的版本命名都将彻底消失，统一被划入USB 3.2的序列，三者分别再次改名叫做USB 3.2 Gen 1、USB 3.2 Gen 2、USB 3.2 Gen 2x2。</li><li>它们还各自有一个市场推广命名，分别是SuperSpeed USB、SuperSpeed USB 10Gbps、SuperSpeed USB 20Gbps。<br>  之所以想出USB 3.2 Gen2x2这样的名字，大概是因为它使用了USB Type-C接口的上下两端全部针脚，速度得以翻番。</li><li>必须使用USB Type-C接口才能达到20Gbps的速度。</li></ul><h1 id="USB-描述符"><a href="#USB-描述符" class="headerlink" title="USB 描述符"></a>USB 描述符</h1><blockquote><p>  USB是个通用的总线，端口都是统一的。但是USB设备却各种各样，例如USB鼠标，USB键盘，U盘等等，那么USB主机是如何识别出不同的设备的呢？这就要依赖于描述符了。</p><p>  USB的描述符主要有<strong>设备描述符，配置描述符，接口描述符，端点描述符，字符串描述符，HID描述符，报告描述符</strong>等等。</p></blockquote><p><strong>USB各个描述符之间的关系</strong></p><blockquote><p>  一个USB设备有一个<strong>设备描述符</strong>，设备描述符里面决定了该设备有<strong>多少种配置</strong>，每种配置描述符对应着配置描述符；</p><p>  而在<strong>配置描述符</strong>中又定义了该配置里面有<strong>多少个接口</strong>，每个接口有对应的接口描述符；</p><p>  在<strong>接口描述符</strong>里面又定义了该接口有<strong>多少个端点</strong>，每个端点对应一个端点描述符；</p><p>  在<strong>端点描述符</strong>定义了端点的大小，类型等等。</p><blockquote><p>  由此我们可以看出，USB的描述符之间的关系是一层一层的，最上一层是设备描述符，下面是配置描述符，再下面是接口描述符，再下面是端点描述符。</p><p>  在获取描述符时，先获取设备描述符，然后再获取配置描述符，根据配置描述符中的配置集合长度，一次将配置描述符、接口描述符、端点描述符一起一次读回。</p><p>  其中可能还会有获取设备序列号，厂商字符串，产品字符串等。</p></blockquote></blockquote><p><strong>各个描述符的编号</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEVICE_DESCRIPTOR               0x01  <span class="hljs-comment">//设备描述符   </span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIGURATION_DESCRIPTOR        0x02  <span class="hljs-comment">//配置描述符   </span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STRING_DESCRIPTOR               0x03  <span class="hljs-comment">//字符串描述符   </span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INTERFACE_DESCRIPTOR            0x04  <span class="hljs-comment">//接口描述符   </span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ENDPOINT_DESCRIPTOR             0x05  <span class="hljs-comment">//端点描述符  </span></span><br></code></pre></td></tr></table></figure><p><img src="/2023/9c721b62/v2-43379ad330f4acd76ce885f2e1359458_720w.webp" alt="img"></p><p><img src="/2023/9c721b62/usbdes.jpeg" alt="img"></p><p><img src="/2023/9c721b62/image-20240620151939825.png"></p><h2 id="设备描述符-0x01-Device-Descriptor"><a href="#设备描述符-0x01-Device-Descriptor" class="headerlink" title="设备描述符 0x01 Device Descriptor"></a>设备描述符 0x01 Device Descriptor</h2><p><img src="/2023/9c721b62/dev.png" alt="设备描述符"></p><p><strong>代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 定义标准的设备描述符结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">DEVICE_DCESCRIPTOR_STRUCT</span> &#123;</span><br>    BYTE blength;            <span class="hljs-comment">// 设备描述符的字节数大小</span><br>    BYTE bDescriptorType;    <span class="hljs-comment">// 设备描述符类型编号</span><br>    WORD bcdUSB;             <span class="hljs-comment">// USB版本号</span><br>    BYTE bDeviceClass;       <span class="hljs-comment">// USB分配的设备类代码</span><br>    BYTE bDeviceSubClass;    <span class="hljs-comment">// USB分配的子类代码</span><br>    BYTE bDeviceProtocol;    <span class="hljs-comment">// USB分配的设备协议代码</span><br>    BYTE bMaxPacketSize0;    <span class="hljs-comment">// 端点0的最大包大小</span><br>    WORD idVendor;           <span class="hljs-comment">// 厂商编号</span><br>    WORD idProduct;          <span class="hljs-comment">// 产品编号</span><br>    WORD bcdDevice;          <span class="hljs-comment">// 设备出厂编号</span><br>    BYTE iManufacturer;      <span class="hljs-comment">// 设备厂商字符串的索引</span><br>    BYTE iProduct;           <span class="hljs-comment">// 描述产品字符串的索引</span><br>    BYTE iSerialNumber;      <span class="hljs-comment">// 描述设备序列号字符串的索引</span><br>    BYTE bNumConfigurations; <span class="hljs-comment">// 可能的配置数量</span><br>&#125; DEVICE_DESCRIPTOR_STRUCT, *pDEVICE_DESCRIPTOR_STRUCT;<br><br><span class="hljs-comment">// 实际的设备描述符示例</span><br>DEVICE_DESCRIPTOR_STRUCT device_descriptor = &#123;<br>.blength           =<span class="hljs-keyword">sizeof</span>(DEVICE_DESCRIPTOR_STRUCT),<span class="hljs-comment">// 设备描述符的字节数大小，这里是18字节</span><br>.bDescriptorType   =DEVICE_DESCRIPTOR,  <span class="hljs-comment">// 设备描述符类型编号，设备描述符是01</span><br>.bcdUSB            =<span class="hljs-number">0x1001</span>, <span class="hljs-comment">// USB版本号，这里是USB01.10，即USB1.1。由于51是大端模式，所以高低字节交换</span><br>.bDeviceClass      =<span class="hljs-number">0x00</span>,   <span class="hljs-comment">// USB分配的设备类代码，0表示类型在接口描述符中定义</span><br>.bDeviceSubClass   =<span class="hljs-number">0x00</span>,   <span class="hljs-comment">// USB分配的子类代码，上面一项为0时，本项也要设置为0</span><br>.bDeviceProtocol   =<span class="hljs-number">0x00</span>,   <span class="hljs-comment">// USB分配的设备协议代码，上面一项为0时，本项也要设置为0</span><br>.bMaxPacketSize0   =<span class="hljs-number">0x10</span>,   <span class="hljs-comment">// 端点0的最大包大小，这里为16字节</span><br>.idVendor          =<span class="hljs-number">0x7104</span>, <span class="hljs-comment">// 厂商编号，这个是需要跟USB组织申请的ID号，表示厂商代号。</span><br>.idProduct         =<span class="hljs-number">0xf0ff</span>, <span class="hljs-comment">// 该产品的编号，跟厂商编号一起配合使用，让主机注册该设备并加载相应的驱动程序</span><br>.bcdDevice         =<span class="hljs-number">0x0100</span>, <span class="hljs-comment">// 设备出厂编号</span><br>.iManufacturer     =<span class="hljs-number">0x01</span>,   <span class="hljs-comment">// 设备厂商字符串的索引，在获取字符串描述符时，使用该索引号来识别不同的字符串</span><br>.iProduct          =<span class="hljs-number">0x02</span>,   <span class="hljs-comment">// 描述产品字符串的索引，同上</span><br>.iSerialNumber     =<span class="hljs-number">0x03</span>,   <span class="hljs-comment">// 描述设备序列号字符串的索引，同上</span><br>.bNumConfigurations=<span class="hljs-number">0x01</span>    <span class="hljs-comment">// 可能的配置数为1，即该设备只有一个配置</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p><strong>bLength</strong></p><ul><li>是设备描述符的总长度，以字节为单位。</li></ul></li><li><p><strong>bDescriptorType</strong></p><ul><li>代表了本描述符的类型。</li><li>用于描述设备的描述符 是0x01。<ul><li>其他描述符的数值及含义</li><li><img src="/2023/9c721b62/d976ff82852a45ea8fc59183689cbd5b.png" alt="在这里插入图片描述"></li></ul></li></ul></li><li><p><strong>bcdUSB</strong></p><ul><li>显示了设备支持的USB版本，通常是最新版本。</li><li>这是一个<a href="https://so.csdn.net/so/search?q=%E4%BA%8C%E8%BF%9B%E5%88%B6&spm=1001.2101.3001.7020">二进制</a>代码形式的十进制数据，采用0xAABC的形式，其中A是主版本号，B是次版本号，C是子次版本号。</li><li>例如，USB2.0设备拥有0x0200值，USB1.1设备拥有0x0110值。通常，主机将使用bcdUSB以确定需要加载的USB驱动器。</li></ul></li><li><p><strong>bDeviceClass</strong>、<strong>bDeviceSubClass</strong>、<strong>bDeviceProtocol</strong></p><ul><li>分别代表<strong>设备类型</strong>，<strong>子类型</strong>，<strong>设备使用的协议</strong></li><li>USB-IF区分设备类分了三个等级（类-子类-协议码）其中，<ul><li>类包含人机交互类、图像类、无线类、音频类等等，</li><li>子类比如音频类的音频控制、音频流等等，</li><li>协议比如人机接口类中的鼠标、键盘、<a href="https://so.csdn.net/so/search?q=%E8%A7%A6%E6%91%B8%E5%B1%8F&spm=1001.2101.3001.7020">触摸屏</a>等，</li></ul></li><li><blockquote><p>  为何会有这么多USB的Class分类，子分类，设备协议。<br>  我们要知道，USB协议设计的目的，就是为实现通用，用单一的USB接口取代之前种类繁多的各种其他接口。而为了取代其他各种接口，那意味着就要实现各种设备所对应的各种功能。</p></blockquote></li></ul></li><li><p><strong>bMaxPackeSize0</strong></p><ul><li>端点一次最大传多少个字节。</li><li>根据设备，数据包的大小可以为 8 个字节、 16 个字节、 32 个字节和 64 个字节。</li><li>USB协议里有规定，端点0最低8字节，端点的最大传输大小和USB速度等级以及传输类型有关，<strong>控制传输一般使用端点0</strong>，低速最大8字节，全速和高速最大传输64字节：</li></ul></li><li><p><strong>idVendor</strong></p><ul><li>代表着设备的生产商ID,由USB设备生产商向USB-IF官方来统一管理和申请。</li></ul></li><li><p><strong>idProduct</strong></p><ul><li>代表着该生产商生产的产品编号，同一厂商下的不同idProduct代表着该公司不同的产品系列。</li></ul></li><li><p><strong>bcdDevice</strong></p><ul><li>是一个BCD编码格式，代表着设备的出产编号，或者同一产品的版本更新迭代。</li></ul></li><li><p><strong>iManufacturer</strong></p><ul><li>描述厂商的字符串的索引，为0则表示没有。</li></ul></li><li><p><strong>iProduct</strong></p><ul><li>描述产品的字符串的索引，为0则表示没有。</li></ul></li><li><p><strong>iSerialNumber</strong></p><ul><li>产品序列号字符串的索引，为0则表示没有。</li></ul></li><li><p><strong>bNumConfigurations</strong></p><ul><li>指示设备有多少个配置，前面提到过，一个USB可能有多个配置，一般USB产品都是1个配置。</li></ul></li></ul><h2 id="配置描述符-0x02-Configuration-Descriptor"><a href="#配置描述符-0x02-Configuration-Descriptor" class="headerlink" title="配置描述符 0x02 Configuration Descriptor"></a>配置描述符 0x02 Configuration Descriptor</h2><table><thead><tr><th>偏移</th><th>字段</th><th>大小<br>Byte</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>bLength</td><td>1</td><td>该描述符的长度 &#x3D; 9 个字节</td></tr><tr><td>1</td><td>bDescriptorType</td><td>1</td><td>描述符类型 &#x3D; 配置（02h）</td></tr><tr><td>2</td><td>wTotalLength</td><td>2</td><td>总长度包括接口和端点描述符在内</td></tr><tr><td>4</td><td>bNumInterfaces</td><td>1</td><td>本配置中接口的数量</td></tr><tr><td>5</td><td>bConfigurationValue</td><td>1</td><td>SET_CONFIGURATION 请求所使用的配置值，用于选择该配置</td></tr><tr><td>6</td><td>iConfiguration</td><td>1</td><td>描述该配置的字符串索引</td></tr><tr><td>7</td><td>bmAttributes</td><td>1</td><td>位 7：预留（设置为 1） <br>位 6：自供电 <br>位 5：远程唤醒<br>位 4:0：保留</td></tr><tr><td>8</td><td>bMaxPower</td><td>1</td><td>本配置所需的最大功耗（单位为 2 mA）</td></tr></tbody></table><ul><li><p><strong>bLength</strong> 1字节，表示配置描述符的长度，配置描述符的长度是9字节。</p></li><li><p><strong>bDescriptor</strong> 1字节，表示描述符的类型，配置描述符的类型编码为 0x02。</p></li><li><p><strong>wTotalLength</strong> 2字节，是整个配置描述符集合的总长度。包括配置描述符，接口描述符，端点描述符和类特殊描述符（如果有）。</p></li><li><p><strong>bNumInterfaces</strong> 1字节，则定义了在该指定配置中接口总数。最小为 1 个接口，通常功能单一的设备只有一个接口（如鼠标），而复合设备具有多个接口（如音频设备）。</p></li><li><p><strong>bConfigurationValue</strong> 1字节，表示该配置的值，设置配置请求时会发送一个配置值，如果某个配置的bConfigurationValue和它相匹配，就表示该配置被激活。</p></li><li><p><strong>iConfiguration</strong> 1字节，描述该配置的字符串的索引，如果该值为0，表示没有字符串来描述它。</p></li><li><p><strong>bmAttributes</strong> 1字节，定义了 USB 设备的一些特性。 位7保留，必须设置为1，位6表示供电方式，设置为 0表示设备由总线供电，设置为 1 表示设备自供电。位5表示是否支持远程唤醒，设置为 1表示支持远程唤醒，设置为 0 表示不支持远程唤醒。位4~位0设置为0。</p></li><li><p><strong>bMaxPower</strong> 1字节，表示设备需要从总线获取的最大电流量，以 2 mA 为单位。如需要200mA的最大电流，则该字段的值为100。</p></li></ul><h2 id="字符串描述符-0x03"><a href="#字符串描述符-0x03" class="headerlink" title="字符串描述符 0x03"></a>字符串描述符 0x03</h2><table><thead><tr><th>偏移</th><th>字段</th><th>大小（字节）</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>bLength</td><td>1</td><td>该描述符的长度 &#x3D; 7 个字节</td></tr><tr><td>1</td><td>bDescriptorType</td><td>1</td><td>描述符类型 &#x3D; STRING （03h）</td></tr><tr><td>2..n</td><td>bString 或 wLangID</td><td>变化</td><td>Unicode 编码字符串 或 LANGID 代码</td></tr></tbody></table><p>字符串描述符是可选的，字符串描述符用于描述一些方便人们阅读的信息，比如制造商、设备名称啥的。如果一个设备没有字符串描述符，那么其他描述符中和字符串有关的索引值都必须为 0。</p><h2 id="接口描述符-0x04-Interface-Descriptor"><a href="#接口描述符-0x04-Interface-Descriptor" class="headerlink" title="接口描述符 0x04 Interface Descriptor"></a>接口描述符 0x04 Interface Descriptor</h2><table><thead><tr><th>偏移</th><th>字段</th><th>大小（字节）</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>bLength</td><td>1</td><td>该描述符的长度 &#x3D; 9 个字节</td></tr><tr><td>1</td><td>bDescriptorType</td><td>1</td><td>描述符类型 &#x3D; 接口（04h）</td></tr><tr><td>2</td><td>bInterfaceNumber</td><td>1</td><td>该接口基于零的索引</td></tr><tr><td>3</td><td>bAlternateSetting</td><td>1</td><td>备用设置值</td></tr><tr><td>4</td><td>bNumEndpoints</td><td>1</td><td>该接口所使用的端点数量（不包含 EP0）</td></tr><tr><td>5</td><td>bInterfaceClass</td><td>1</td><td>接口类别</td></tr><tr><td>6</td><td>bInterfaceSubclass</td><td>1</td><td>接口子类别</td></tr><tr><td>7</td><td>bInterfaceProtocol</td><td>1</td><td>接口协议</td></tr><tr><td>8</td><td>iInterface</td><td>1</td><td>该接口字符串描述符索引</td></tr></tbody></table><ul><li><strong>bLength</strong> 1字节，表示接口描述符的长度，标准的接口描述符的长度为9字节。</li><li><strong>bDescriptorType</strong> 1字节，表示描述符的类型，接口描述符的类型编码为 0x04。</li><li><strong>bInterfaceNumber</strong> 1字节，表示该接口的编号，如果一个配置具有多个接口，每个接口的编号都不相同，从0开始依次递增对一个配置的接口进行编号。</li><li><strong>bAlternateSetting</strong> 1字节，接口的备用编号，很少用到，设置为0。</li><li><strong>bNumEndpoints</strong> 1字节，表示该接口的端点数（不包括0端点）。</li><li><strong>bInterfaceClass、bInterfaceSubClass、bInterfaceProtocol</strong> 均为1字节，分别表示接口所使用的类，子类以及协议，由USB协会规定。</li><li><strong>iInterface</strong> 1字节，描述该接口的字符串的索引值，如果为0，表示没有字符串。</li></ul><p><strong>bInterfaceClass</strong>、<strong>bDeviceClass</strong>：</p><table><thead><tr><th>Base Class</th><th>Descriptor Usage</th><th>Description</th></tr></thead><tbody><tr><td>00h</td><td>Device</td><td>Use class information in the Interface Descriptors</td></tr><tr><td>01h</td><td>Interface</td><td>Audio USB音频，参见UAC规范</td></tr><tr><td>02h</td><td>Both</td><td>Communications and <a href="https://www.usbzh.com/article/detail-842.html">CDC</a> Control 网卡、调制解调器、串列端口</td></tr><tr><td>03h</td><td>Interface</td><td><a href="https://www.usbzh.com/article/detail-76.html">HID</a> (Human Interface Device)，键盘、鼠标 参见<a href="https://www.usbzh.com/article/detail-76.html">HID</a>规范</td></tr><tr><td>05h</td><td>Interface</td><td>Physical 控制杆</td></tr><tr><td>06h</td><td>Interface</td><td>Image 影像扫描仪、Picture Transfer Protocol</td></tr><tr><td>07h</td><td>Interface</td><td>Printer 打印机</td></tr><tr><td>08h</td><td>Interface</td><td>Mass Storage U盘、移动硬盘、存储卡读卡器、数字相机</td></tr><tr><td>09h</td><td>Device</td><td>Hub <a href="https://www.usbzh.com/article/detail-25.html">集线器</a></td></tr><tr><td>0Ah</td><td>Interface</td><td><a href="https://www.usbzh.com/article/detail-842.html">CDC</a>-Data 调制解调器、网络卡、ISDN、传真</td></tr><tr><td>0Bh</td><td>Interface</td><td>Smart Card 读卡器</td></tr><tr><td>0Dh</td><td>Interface</td><td>Content Security</td></tr><tr><td>0Eh</td><td>Interface</td><td>Video USB视频，<a href="https://www.usbzh.com/article/detail-80.html">UVC</a>摄像头，参见<a href="https://www.usbzh.com/article/detail-80.html">UVC</a>规范</td></tr><tr><td>0Fh</td><td>Interface</td><td>Personal Healthcare</td></tr><tr><td>10h</td><td>Interface</td><td>Audio&#x2F;Video Devices</td></tr><tr><td>11h</td><td>Device</td><td>Billboard Device Class</td></tr><tr><td>12h</td><td>Interface</td><td>USB Type-C Bridge Class</td></tr><tr><td>DCh</td><td>Both</td><td>Diagnostic Device</td></tr><tr><td>E0h</td><td>Interface</td><td>Wireless Controller 蓝牙</td></tr><tr><td>EFh</td><td>Both</td><td>Miscellaneous</td></tr><tr><td>FEh</td><td>Interface</td><td>Application Specific 红外线资料桥接器</td></tr><tr><td>FFh</td><td>Both</td><td>Vendor Specific 自定义USB设备</td></tr><tr><td>更多信息参考 <a href="https://www.usb.org/defined-class-codes">USB.org</a> 的部分章节</td><td></td><td></td></tr></tbody></table><h2 id="端点描述符-0x05-Endpoint-Descriptor"><a href="#端点描述符-0x05-Endpoint-Descriptor" class="headerlink" title="端点描述符 0x05 Endpoint Descriptor"></a>端点描述符 0x05 Endpoint Descriptor</h2><table><thead><tr><th>偏移</th><th>字段</th><th>大小<br>Byte</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>bLength</td><td>1</td><td>该描述符长度 &#x3D; 7 个字节</td></tr><tr><td>1</td><td>bDescriptorType</td><td>1</td><td>描述符类型 &#x3D; 端点（05h）</td></tr><tr><td>2</td><td>bEndpointAddress</td><td>1</td><td><strong>位 3…0</strong>：端点数量 <br/><strong>位 6…4</strong>：预留，复位为零 <br/><strong>位 7</strong>：端点的方向。控制端点可以忽略该位。 <br/>0 &#x3D; OUT 端点 (主机到设备) <br/>1 &#x3D; IN 端点 (设备到主机)</td></tr><tr><td>3</td><td>bmAttributes</td><td>1</td><td><strong>位 1…0</strong>：传输类型 <br/>00 &#x3D; 控制传输 <br/>01 &#x3D; 同步传输 <br/>10 &#x3D; 批量传输 <br/>11 &#x3D; 中断传输 <br/>如果该端点不是同步端点，那么位 5 到位 2 将被预留，必须将这些位设置为零。如果该端点是同步的，这些位将按如下内容定义： <br/><strong>位 3…2</strong>：同步类型 <br/>00 &#x3D; 无同步 <br/>01 &#x3D; 异步 <br/>10 &#x3D; 自适应 <br/>11 &#x3D; 同步 <br/><strong>位 5…4</strong>：用途类型 <br/>00 &#x3D; 数据端点 <br/>01 &#x3D; 反馈端点 <br/>10 &#x3D; 隐式反馈数据端点 <br/>数值 11 表示保留</td></tr><tr><td>4</td><td>wMaxPacketSize</td><td>1</td><td>该端点的数据包最大尺寸</td></tr><tr><td>6</td><td>bInterval</td><td>1</td><td>中断端点的轮询间隔，单位为 ms（对于同步端点，该间隔为 1 ms；控制或批量端点可能忽略该字段）</td></tr></tbody></table><ul><li><strong>bLength</strong> 1字节，表示端点描述符的长度，标准的端点描述符的长度为7字节。</li><li><strong>bDescriptorType</strong> 1字节，表示描述符的类型，端点描述符的类型编码为 0x05。</li><li><strong>bEndpointAddress</strong> 1字节，表示该端点的地址和方向。</li><li><strong>bmAttributes</strong> 1字节，表示该端点的属性，详细看上表。<ul><li><strong>Transfer Type</strong> <ul><li><strong>控制CONTROL</strong> 控制端点被用来控制对 USB 设备的不同部分访问。<em>通常用作配置设备、获取设备信息、发送命令到设备或获取设备状态报告</em>。这些端点通常较小。<em>每个 USB 设备都有一个控制端点称为”端点 0”, 被 USB 核心用来在插入时配置设备</em>。USB协议保证总有足够的带宽留给控制端点传送数据到设备.  </li><li><strong>中断INTERRUPT</strong>每当 USB 主机向设备请求数据时，中断端点以固定的速率传送<em>小量的数据</em>。此为USB 键盘和鼠标的主要的数据传送方法。它还用以传送数据到 USB 设备来控制设备。<em>通常不用来传送大量数据</em>。USB协议保证总有足够的带宽留给中断端点传送数据到设备.</li><li><strong>批量BULK</strong>  批量端点用以传送大量数据。这些端点常比中断端点大得多. 它们普遍用于<em>不能有任何数据丢失的数据</em>。USB 协议<em>不保证传输在特定时间范围内完成</em>。如果总线上没有足够的空间来发送整个BULK包，它被分为多个包进行传输。这些端点普遍用于打印机、USB Mass Storage和USB网络设备上。</li><li><strong>等时ISOCHRONOUS</strong> 等时端点也批量传送大量数据, 但是这个数据<em>不被保证能送达</em>。这些端点用在可以处理数据丢失的设备中，并且更多依赖于保持持续的数据流。如音频和视频设备等等。</li><li>对比总结：<em>控制</em>和<em>批量</em>端点用于异步数据传送，而<em>中断</em>和<em>同步</em>端点是周期性的。这意味着这些端点被设置来在固定的时间连续传送数据，USB 核心为它们保留了相应的带宽。</li></ul></li></ul></li><li><strong>wMaxPacketSize</strong> 2字节，表示该端点的数据包最大长度。</li><li><strong>bInterval</strong> 1字节</li></ul><p>每个端点描述符都规定了该端点所支持的最大数据包长 (wMaxPacketSize)，主机每次发送数据包，都不能超过端点的最大包长，各种端点的最大包长如下表：</p><table><thead><tr><th>端点类型</th><th>最大包长 (低速)</th><th>最大包长 (全速)</th><th>最大包长 (高)</th></tr></thead><tbody><tr><td>控制端点</td><td>8</td><td>8&#x2F;16&#x2F;32&#x2F;64</td><td>64</td></tr><tr><td>实时端点</td><td>不支持</td><td>1023</td><td>1024</td></tr><tr><td>中断端点</td><td>8</td><td>64</td><td>1024</td></tr><tr><td>批量端点</td><td>不支持</td><td>8&#x2F;16&#x2F;32&#x2F;64</td><td>512</td></tr></tbody></table><h1 id="HID"><a href="#HID" class="headerlink" title="HID"></a>HID</h1><h1 id="UVC"><a href="#UVC" class="headerlink" title="UVC"></a>UVC</h1><blockquote><p>UVC，全称为：USB video(device) class,是微软与另外几家设备厂商联合推出的为USB视频捕获设备定义的协议标准，目前已成为USB org标准之一。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>embedded</category>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>embedded</tag>
      
      <tag>usb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OrangePi</title>
    <link href="/2023/6dfa9920/"/>
    <url>/2023/6dfa9920/</url>
    
    <content type="html"><![CDATA[<h1 id="OrangePi-3B-系统安装"><a href="#OrangePi-3B-系统安装" class="headerlink" title="OrangePi 3B 系统安装"></a>OrangePi 3B 系统安装</h1><p>…</p><p>系统镜像：</p><p>EN: <a href="http://www.orangepi.org/html/hardWare/computerAndMicrocontrollers/service-and-support/Orange-Pi-3B.html">http://www.orangepi.org/html/hardWare/computerAndMicrocontrollers/service-and-support/Orange-Pi-3B.html</a></p><p>CN: <a href="http://www.orangepi.cn/html/hardWare/computerAndMicrocontrollers/service-and-support/Orange-Pi-3B.html">http://www.orangepi.cn/html/hardWare/computerAndMicrocontrollers/service-and-support/Orange-Pi-3B.html</a></p><h1 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h1><h2 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h2><table><thead><tr><th>用户名</th><th>密码</th></tr></thead><tbody><tr><td>root</td><td>orangepi</td></tr><tr><td>orangepi</td><td>orangepi</td></tr></tbody></table><h2 id="硬件配置"><a href="#硬件配置" class="headerlink" title="硬件配置"></a>硬件配置</h2><blockquote><p>  <strong>选择 System -&gt; Hardware</strong></p><p>  请注意，uart2_m0 默认是作为系统的调试串口，如果打开了 uart2 的配置，调试串口的功能会无法使用</p><p>  i2c3_m0 和 uart3_m0 是引脚复用的，两者不能同时打开</p><p>  <strong>配置完成需要重启生效</strong></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo orangepi-config<br><br>reboot<br></code></pre></td></tr></table></figure><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="WLAN"><a href="#WLAN" class="headerlink" title="WLAN"></a>WLAN</h3><blockquote><p>  请不要通过修改&#x2F;etc&#x2F;network&#x2F;interfaces 配置文件的方式来连接 WIFI，通过这种方式连接 WIFI 网络使用会有问题。</p></blockquote><h4 id="命令行版"><a href="#命令行版" class="headerlink" title="命令行版"></a>命令行版</h4><ol><li>首先使用<code>nmcli dev wifi</code>命令扫描周围的 WIFI 热点</li><li>然后使用 nmcli 命令连接扫描到的 WIFI 热点 <code>nmcli dev wifi connect wifi_name password wifi_passwd</code><ol><li><code>wifi_name</code> 需要换成想连接的 WIFI 热点的名字</li><li><code>wifi_passwd</code> 需要换成想连接的 WIFI 热点的密码</li></ol></li><li>通过 <code>ip addr show wlan0</code> 命令可以查看 wifi 的 IP 地址</li></ol><h4 id="UI版"><a href="#UI版" class="headerlink" title="UI版"></a>UI版</h4><ol><li>在命令行中输入 <code>nmtui</code> 命令打开 wifi 连接的界面</li></ol>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>查看Apk安装包的签名</title>
    <link href="/2023/a3ad4999/"/>
    <url>/2023/a3ad4999/</url>
    
    <content type="html"><![CDATA[<h1 id="查看apk安装包的签名"><a href="#查看apk安装包的签名" class="headerlink" title="查看apk安装包的签名"></a>查看apk安装包的签名</h1><p>首先，确保你已经安装了Java开发工具包（JDK），以便使用其中的工具。</p><p>查看Android apk的签名信息方式有两种</p><ol><li><p>直接查看apk的签名信息（推荐）</p><ol><li><pre><code class="shell">keytool -list -printcert -jarfile wechat.apk <figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stata"><br>2.   通过apk中的RSA文件查看签名信息<br><br>     1.   将apk后缀改为.<span class="hljs-keyword">zip</span>，然后解压（**apk其实是一个用<span class="hljs-keyword">zip</span>压缩的文件**），再进入<span class="hljs-keyword">META</span>-<span class="hljs-keyword">INF</span>目录，找到RSA文件<br><br>     2.   ```<span class="hljs-keyword">shell</span><br>          keytool -printcert -<span class="hljs-keyword">file</span> COM_TENC.RSA <br></code></pre></td></tr></table></figure></code></pre></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>apk</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Frp</title>
    <link href="/2023/c65a4228/"/>
    <url>/2023/c65a4228/</url>
    
    <content type="html"><![CDATA[<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>frp 是一款高性能的反向代理应用，专注于内网穿透。它支持多种协议，包括 TCP、UDP、HTTP、HTTPS 等，并且具备 P2P 通信功能。使用 frp，您可以安全、便捷地将内网服务暴露到公网，通过拥有公网 IP 的节点进行中转。</p><blockquote><h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p>  通过在具有公网 IP 的节点上部署 frp 服务端，您可以轻松地将内网服务穿透到公网，并享受以下专业特性：</p><ul><li>多种协议支持：客户端服务端通信支持 TCP、QUIC、KCP 和 Websocket 等多种协议。</li><li>TCP 连接流式复用：在单个连接上承载多个请求，减少连接建立时间，降低请求延迟。</li><li>代理组间的负载均衡。</li><li>端口复用：多个服务可以通过同一个服务端端口暴露。</li><li>P2P 通信：流量不必经过服务器中转，充分利用带宽资源。</li><li>客户端插件：提供多个原生支持的客户端插件，如静态文件查看、HTTPS&#x2F;HTTP 协议转换、HTTP、SOCKS5 代理等，以便满足各种需求。</li><li>服务端插件系统：高度可扩展的服务端插件系统，便于根据自身需求进行功能扩展。</li><li>用户友好的 UI 页面：提供服务端和客户端的用户界面，使配置和监控变得更加方便。</li></ul><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>  frp 主要由两个组件组成：客户端(frpc) 和 服务端(frps)。通常情况下，服务端部署在具有公网 IP 地址的机器上，而客户端部署在需要穿透的内网服务所在的机器上。</p><p>  由于内网服务缺乏公网 IP 地址，因此无法直接被非局域网内的用户访问。用户通过访问服务端的 frps，frp 负责根据请求的端口或其他信息将请求路由到相应的内网机器，从而实现通信。</p><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>  在 frp 中，一个代理对应一个需要公开访问的内网服务。一个客户端可以同时配置多个代理，以满足不同的需求。</p><h2 id="代理类型"><a href="#代理类型" class="headerlink" title="代理类型"></a>代理类型</h2><p>  frp 支持多种代理类型，以适应不同的使用场景。以下是一些常见的代理类型：</p><ul><li><strong>TCP</strong>：提供纯粹的 TCP 端口映射，使服务端能够根据不同的端口将请求路由到不同的内网服务。</li><li><strong>UDP</strong>：提供纯粹的 UDP 端口映射，与 TCP 代理类似，但用于 UDP 流量。</li><li><strong>HTTP</strong>：专为 HTTP 应用设计，支持修改 Host Header 和增加鉴权等额外功能。</li><li><strong>HTTPS</strong>：类似于 HTTP 代理，但专门用于处理 HTTPS 流量。</li><li><strong>STCP</strong>：提供安全的 TCP 内网代理，要求在被访问者和访问者的机器上都部署 frpc，不需要在服务端暴露端口。</li><li><strong>SUDP</strong>：提供安全的 UDP 内网代理，与 STCP 类似，需要在被访问者和访问者的机器上都部署 frpc，不需要在服务端暴露端口。</li><li><strong>XTCP</strong>：点对点内网穿透代理，与 STCP 类似，但流量不需要经过服务器中转。</li><li><strong>TCPMUX</strong>：支持服务端 TCP 端口的多路复用，允许通过同一端口访问不同的内网服务。</li></ul></blockquote><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><blockquote><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>  您可以从 GitHub 的 <a href="https://github.com/fatedier/frp/releases">Release</a> 页面中下载最新版本的客户端和服务器二进制文件。所有文件都打包在一个压缩包中，还包含了一份完整的配置参数说明。</p><h2 id="部署-1"><a href="#部署-1" class="headerlink" title="部署"></a>部署</h2><ol><li>解压下载的压缩包。</li><li>将 <code>frpc</code> 复制到内网服务所在的机器上。</li><li>将 <code>frps</code> 复制到拥有公网 IP 地址的机器上，并将它们放在任意目录。</li></ol><h2 id="开始使用！"><a href="#开始使用！" class="headerlink" title="开始使用！"></a>开始使用！</h2><ol><li>编写配置文件，目前支持的文件格式包括 TOML&#x2F;YAML&#x2F;JSON，旧的 INI 格式仍然支持，但已经不再推荐。</li><li>使用以下命令启动服务器：<code>./frps -c ./frps.toml</code>。</li><li>使用以下命令启动客户端：<code>./frpc -c ./frpc.toml</code>。</li><li>如果需要在后台长期运行，建议结合其他工具，如 <code>systemd</code> 和 <code>supervisor</code>。</li></ol></blockquote><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p><a href="https://gofrp.org/zh-cn/docs/examples/">配置示例</a></p><blockquote><p>  具体配置可以参考官方文档，写的挺详细的，不过提示一点，配置文件的配置项有顺序要求，需要注意。</p><p>  例如<code>frpc</code>的配置中<code>auth.token</code> 需要放在全局配置里面，不能放在<code>[[proxies]]</code>等等配置选项后面。</p></blockquote><h2 id="配置文件参考"><a href="#配置文件参考" class="headerlink" title="配置文件参考"></a>配置文件参考</h2><h3 id="frps"><a href="#frps" class="headerlink" title="frps"></a>frps</h3><p><a href="https://github.com/fatedier/frp/blob/dev/conf/frps_full_example.toml">frps</a></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># This configuration file is for reference only. Please do not use this configuration directly to run the program as it may have various issues.</span><br><br><span class="hljs-comment"># A literal address or host name for IPv6 must be enclosed</span><br><span class="hljs-comment"># in square brackets, as in &quot;[::1]:80&quot;, &quot;[ipv6-host]:http&quot; or &quot;[ipv6-host%zone]:80&quot;</span><br><span class="hljs-comment"># For single &quot;bindAddr&quot; field, no need square brackets, like `bindAddr = &quot;::&quot;`.</span><br><span class="hljs-attr">bindAddr</span> = <span class="hljs-string">&quot;0.0.0.0&quot;</span><br><span class="hljs-attr">bindPort</span> = <span class="hljs-number">7000</span><br><br><span class="hljs-comment"># udp port used for kcp protocol, it can be same with &#x27;bindPort&#x27;.</span><br><span class="hljs-comment"># if not set, kcp is disabled in frps.</span><br><span class="hljs-attr">kcpBindPort</span> = <span class="hljs-number">7000</span><br><br><span class="hljs-comment"># udp port used for quic protocol.</span><br><span class="hljs-comment"># if not set, quic is disabled in frps.</span><br><span class="hljs-comment"># quicBindPort = 7002</span><br><br><span class="hljs-comment"># Specify which address proxy will listen for, default value is same with bindAddr</span><br><span class="hljs-comment"># proxyBindAddr = &quot;127.0.0.1&quot;</span><br><br><span class="hljs-comment"># quic protocol options</span><br><span class="hljs-comment"># transport.quic.keepalivePeriod = 10</span><br><span class="hljs-comment"># transport.quic.maxIdleTimeout = 30</span><br><span class="hljs-comment"># transport.quic.maxIncomingStreams = 100000</span><br><br><span class="hljs-comment"># Heartbeat configure, it&#x27;s not recommended to modify the default value</span><br><span class="hljs-comment"># The default value of heartbeatTimeout is 90. Set negative value to disable it.</span><br><span class="hljs-comment"># transport.heartbeatTimeout = 90</span><br><br><span class="hljs-comment"># Pool count in each proxy will keep no more than maxPoolCount.</span><br><span class="hljs-attr">transport.maxPoolCount</span> = <span class="hljs-number">5</span><br><br><span class="hljs-comment"># If tcp stream multiplexing is used, default is true</span><br><span class="hljs-comment"># transport.tcpMux = true</span><br><br><span class="hljs-comment"># Specify keep alive interval for tcp mux.</span><br><span class="hljs-comment"># only valid if tcpMux is true.</span><br><span class="hljs-comment"># transport.tcpMuxKeepaliveInterval = 60</span><br><br><span class="hljs-comment"># tcpKeepalive specifies the interval between keep-alive probes for an active network connection between frpc and frps.</span><br><span class="hljs-comment"># If negative, keep-alive probes are disabled.</span><br><span class="hljs-comment"># transport.tcpKeepalive = 7200</span><br><br><span class="hljs-comment"># transport.tls.force specifies whether to only accept TLS-encrypted connections. By default, the value is false.</span><br><span class="hljs-attr">transport.tls.force</span> = <span class="hljs-literal">false</span><br><br><span class="hljs-comment"># transport.tls.certFile = &quot;server.crt&quot;</span><br><span class="hljs-comment"># transport.tls.keyFile = &quot;server.key&quot;</span><br><span class="hljs-comment"># transport.tls.trustedCaFile = &quot;ca.crt&quot;</span><br><br><span class="hljs-comment"># If you want to support virtual host, you must set the http port for listening (optional)</span><br><span class="hljs-comment"># <span class="hljs-doctag">Note:</span> http port and https port can be same with bindPort</span><br><span class="hljs-attr">vhostHTTPPort</span> = <span class="hljs-number">80</span><br><span class="hljs-attr">vhostHTTPSPort</span> = <span class="hljs-number">443</span><br><br><span class="hljs-comment"># Response header timeout(seconds) for vhost http server, default is 60s</span><br><span class="hljs-comment"># vhostHTTPTimeout = 60</span><br><br><span class="hljs-comment"># tcpmuxHTTPConnectPort specifies the port that the server listens for TCP</span><br><span class="hljs-comment"># HTTP CONNECT requests. If the value is 0, the server will not multiplex TCP</span><br><span class="hljs-comment"># requests on one single port. If it&#x27;s not - it will listen on this value for</span><br><span class="hljs-comment"># HTTP CONNECT requests. By default, this value is 0.</span><br><span class="hljs-comment"># tcpmuxHTTPConnectPort = 1337</span><br><br><span class="hljs-comment"># If tcpmuxPassthrough is true, frps won&#x27;t do any update on traffic.</span><br><span class="hljs-comment"># tcpmuxPassthrough = false</span><br><br><span class="hljs-comment"># Configure the web server to enable the dashboard for frps.</span><br><span class="hljs-comment"># dashboard is available only if webServer.port is set.</span><br><span class="hljs-attr">webServer.addr</span> = <span class="hljs-string">&quot;127.0.0.1&quot;</span><br><span class="hljs-attr">webServer.port</span> = <span class="hljs-number">7500</span><br><span class="hljs-attr">webServer.user</span> = <span class="hljs-string">&quot;admin&quot;</span><br><span class="hljs-attr">webServer.password</span> = <span class="hljs-string">&quot;admin&quot;</span><br><span class="hljs-comment"># webServer.tls.certFile = &quot;server.crt&quot;</span><br><span class="hljs-comment"># webServer.tls.keyFile = &quot;server.key&quot;</span><br><span class="hljs-comment"># dashboard assets directory(only for debug mode)</span><br><span class="hljs-comment"># webServer.assetsDir = &quot;./static&quot;</span><br><br><span class="hljs-comment"># Enable golang pprof handlers in dashboard listener.</span><br><span class="hljs-comment"># Dashboard port must be set first</span><br><span class="hljs-attr">webServer.pprofEnable</span> = <span class="hljs-literal">false</span><br><br><span class="hljs-comment"># enablePrometheus will export prometheus metrics on webServer in /metrics api.</span><br><span class="hljs-attr">enablePrometheus</span> = <span class="hljs-literal">true</span><br><br><span class="hljs-comment"># console or real logFile path like ./frps.log</span><br><span class="hljs-attr">log.to</span> = <span class="hljs-string">&quot;./frps.log&quot;</span><br><span class="hljs-comment"># trace, debug, info, warn, error</span><br><span class="hljs-attr">log.level</span> = <span class="hljs-string">&quot;info&quot;</span><br><span class="hljs-attr">log.maxDays</span> = <span class="hljs-number">3</span><br><span class="hljs-comment"># disable log colors when log.to is console, default is false</span><br><span class="hljs-attr">log.disablePrintColor</span> = <span class="hljs-literal">false</span><br><br><span class="hljs-comment"># DetailedErrorsToClient defines whether to send the specific error (with debug info) to frpc. By default, this value is true.</span><br><span class="hljs-attr">detailedErrorsToClient</span> = <span class="hljs-literal">true</span><br><br><span class="hljs-comment"># auth.method specifies what authentication method to use authenticate frpc with frps.</span><br><span class="hljs-comment"># If &quot;token&quot; is specified - token will be read into login message.</span><br><span class="hljs-comment"># If &quot;oidc&quot; is specified - OIDC (Open ID Connect) token will be issued using OIDC settings. By default, this value is &quot;token&quot;.</span><br><span class="hljs-attr">auth.method</span> = <span class="hljs-string">&quot;token&quot;</span><br><br><span class="hljs-comment"># auth.additionalScopes specifies additional scopes to include authentication information.</span><br><span class="hljs-comment"># Optional values are HeartBeats, NewWorkConns.</span><br><span class="hljs-comment"># auth.additionalScopes = [&quot;HeartBeats&quot;, &quot;NewWorkConns&quot;]</span><br><br><span class="hljs-comment"># auth token</span><br><span class="hljs-attr">auth.token</span> = <span class="hljs-string">&quot;12345678&quot;</span><br><br><span class="hljs-comment"># oidc issuer specifies the issuer to verify OIDC tokens with.</span><br><span class="hljs-attr">auth.oidc.issuer</span> = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-comment"># oidc audience specifies the audience OIDC tokens should contain when validated.</span><br><span class="hljs-attr">auth.oidc.audience</span> = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-comment"># oidc skipExpiryCheck specifies whether to skip checking if the OIDC token is expired.</span><br><span class="hljs-attr">auth.oidc.skipExpiryCheck</span> = <span class="hljs-literal">false</span><br><span class="hljs-comment"># oidc skipIssuerCheck specifies whether to skip checking if the OIDC token&#x27;s issuer claim matches the issuer specified in OidcIssuer.</span><br><span class="hljs-attr">auth.oidc.skipIssuerCheck</span> = <span class="hljs-literal">false</span><br><br><span class="hljs-comment"># userConnTimeout specifies the maximum time to wait for a work connection.</span><br><span class="hljs-comment"># userConnTimeout = 10</span><br><br><span class="hljs-comment"># Only allow frpc to bind ports you list. By default, there won&#x27;t be any limit.</span><br><span class="hljs-attr">allowPorts</span> = [<br>  &#123; start = <span class="hljs-number">2000</span>, end = <span class="hljs-number">3000</span> &#125;,<br>  &#123; single = <span class="hljs-number">3001</span> &#125;,<br>  &#123; single = <span class="hljs-number">3003</span> &#125;,<br>  &#123; start = <span class="hljs-number">4000</span>, end = <span class="hljs-number">50000</span> &#125;<br>]<br><br><span class="hljs-comment"># Max ports can be used for each client, default value is 0 means no limit</span><br><span class="hljs-attr">maxPortsPerClient</span> = <span class="hljs-number">0</span><br><br><span class="hljs-comment"># If subDomainHost is not empty, you can set subdomain when type is http or https in frpc&#x27;s configure file</span><br><span class="hljs-comment"># When subdomain is test, the host used by routing is test.frps.com</span><br><span class="hljs-attr">subDomainHost</span> = <span class="hljs-string">&quot;frps.com&quot;</span><br><br><span class="hljs-comment"># custom 404 page for HTTP requests</span><br><span class="hljs-comment"># custom404Page = &quot;/path/to/404.html&quot;</span><br><br><span class="hljs-comment"># specify udp packet size, unit is byte. If not set, the default value is 1500.</span><br><span class="hljs-comment"># This parameter should be same between client and server.</span><br><span class="hljs-comment"># It affects the udp and sudp proxy.</span><br><span class="hljs-attr">udpPacketSize</span> = <span class="hljs-number">1500</span><br><br><span class="hljs-comment"># Retention time for NAT hole punching strategy data.</span><br><span class="hljs-attr">natholeAnalysisDataReserveHours</span> = <span class="hljs-number">168</span><br><br><span class="hljs-comment"># ssh tunnel gateway</span><br><span class="hljs-comment"># If you want to enable this feature, the bindPort parameter is required, while others are optional.</span><br><span class="hljs-comment"># By default, this feature is disabled. It will be enabled if bindPort is greater than 0.</span><br><span class="hljs-comment"># sshTunnelGateway.bindPort = 2200</span><br><span class="hljs-comment"># sshTunnelGateway.privateKeyFile = &quot;/home/frp-user/.ssh/id_rsa&quot;</span><br><span class="hljs-comment"># sshTunnelGateway.autoGenPrivateKeyPath = &quot;&quot;</span><br><span class="hljs-comment"># sshTunnelGateway.authorizedKeysFile = &quot;/home/frp-user/.ssh/authorized_keys&quot;</span><br><br><span class="hljs-section">[[httpPlugins]]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;user-manager&quot;</span><br><span class="hljs-attr">addr</span> = <span class="hljs-string">&quot;127.0.0.1:9000&quot;</span><br><span class="hljs-attr">path</span> = <span class="hljs-string">&quot;/handler&quot;</span><br><span class="hljs-attr">ops</span> = [<span class="hljs-string">&quot;Login&quot;</span>]<br><br><span class="hljs-section">[[httpPlugins]]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;port-manager&quot;</span><br><span class="hljs-attr">addr</span> = <span class="hljs-string">&quot;127.0.0.1:9001&quot;</span><br><span class="hljs-attr">path</span> = <span class="hljs-string">&quot;/handler&quot;</span><br><span class="hljs-attr">ops</span> = [<span class="hljs-string">&quot;NewProxy&quot;</span>]<br></code></pre></td></tr></table></figure><h3 id="frpc"><a href="#frpc" class="headerlink" title="frpc"></a>frpc</h3><p><a href="https://github.com/fatedier/frp/blob/dev/conf/frpc_full_example.toml">frpc</a></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># This configuration file is for reference only. Please do not use this configuration directly to run the program as it may have various issues.</span><br><br><span class="hljs-comment"># A literal address or host name for IPv6 must be enclosed</span><br><span class="hljs-comment"># in square brackets, as in &quot;[::1]:80&quot;, &quot;[ipv6-host]:http&quot; or &quot;[ipv6-host%zone]:80&quot;</span><br><span class="hljs-comment"># For single &quot;bindAddr&quot; field, no need square brackets, like `bindAddr = &quot;::&quot;`.</span><br><span class="hljs-attr">bindAddr</span> = <span class="hljs-string">&quot;0.0.0.0&quot;</span><br><span class="hljs-attr">bindPort</span> = <span class="hljs-number">7000</span><br><br><span class="hljs-comment"># udp port used for kcp protocol, it can be same with &#x27;bindPort&#x27;.</span><br><span class="hljs-comment"># if not set, kcp is disabled in frps.</span><br><span class="hljs-attr">kcpBindPort</span> = <span class="hljs-number">7000</span><br><br><span class="hljs-comment"># udp port used for quic protocol.</span><br><span class="hljs-comment"># if not set, quic is disabled in frps.</span><br><span class="hljs-comment"># quicBindPort = 7002</span><br><br><span class="hljs-comment"># Specify which address proxy will listen for, default value is same with bindAddr</span><br><span class="hljs-comment"># proxyBindAddr = &quot;127.0.0.1&quot;</span><br><br><span class="hljs-comment"># quic protocol options</span><br><span class="hljs-comment"># transport.quic.keepalivePeriod = 10</span><br><span class="hljs-comment"># transport.quic.maxIdleTimeout = 30</span><br><span class="hljs-comment"># transport.quic.maxIncomingStreams = 100000</span><br><br><span class="hljs-comment"># Heartbeat configure, it&#x27;s not recommended to modify the default value</span><br><span class="hljs-comment"># The default value of heartbeatTimeout is 90. Set negative value to disable it.</span><br><span class="hljs-comment"># transport.heartbeatTimeout = 90</span><br><br><span class="hljs-comment"># Pool count in each proxy will keep no more than maxPoolCount.</span><br><span class="hljs-attr">transport.maxPoolCount</span> = <span class="hljs-number">5</span><br><br><span class="hljs-comment"># If tcp stream multiplexing is used, default is true</span><br><span class="hljs-comment"># transport.tcpMux = true</span><br><br><span class="hljs-comment"># Specify keep alive interval for tcp mux.</span><br><span class="hljs-comment"># only valid if tcpMux is true.</span><br><span class="hljs-comment"># transport.tcpMuxKeepaliveInterval = 60</span><br><br><span class="hljs-comment"># tcpKeepalive specifies the interval between keep-alive probes for an active network connection between frpc and frps.</span><br><span class="hljs-comment"># If negative, keep-alive probes are disabled.</span><br><span class="hljs-comment"># transport.tcpKeepalive = 7200</span><br><br><span class="hljs-comment"># transport.tls.force specifies whether to only accept TLS-encrypted connections. By default, the value is false.</span><br><span class="hljs-attr">transport.tls.force</span> = <span class="hljs-literal">false</span><br><br><span class="hljs-comment"># transport.tls.certFile = &quot;server.crt&quot;</span><br><span class="hljs-comment"># transport.tls.keyFile = &quot;server.key&quot;</span><br><span class="hljs-comment"># transport.tls.trustedCaFile = &quot;ca.crt&quot;</span><br><br><span class="hljs-comment"># If you want to support virtual host, you must set the http port for listening (optional)</span><br><span class="hljs-comment"># <span class="hljs-doctag">Note:</span> http port and https port can be same with bindPort</span><br><span class="hljs-attr">vhostHTTPPort</span> = <span class="hljs-number">80</span><br><span class="hljs-attr">vhostHTTPSPort</span> = <span class="hljs-number">443</span><br><br><span class="hljs-comment"># Response header timeout(seconds) for vhost http server, default is 60s</span><br><span class="hljs-comment"># vhostHTTPTimeout = 60</span><br><br><span class="hljs-comment"># tcpmuxHTTPConnectPort specifies the port that the server listens for TCP</span><br><span class="hljs-comment"># HTTP CONNECT requests. If the value is 0, the server will not multiplex TCP</span><br><span class="hljs-comment"># requests on one single port. If it&#x27;s not - it will listen on this value for</span><br><span class="hljs-comment"># HTTP CONNECT requests. By default, this value is 0.</span><br><span class="hljs-comment"># tcpmuxHTTPConnectPort = 1337</span><br><br><span class="hljs-comment"># If tcpmuxPassthrough is true, frps won&#x27;t do any update on traffic.</span><br><span class="hljs-comment"># tcpmuxPassthrough = false</span><br><br><span class="hljs-comment"># Configure the web server to enable the dashboard for frps.</span><br><span class="hljs-comment"># dashboard is available only if webServer.port is set.</span><br><span class="hljs-attr">webServer.addr</span> = <span class="hljs-string">&quot;127.0.0.1&quot;</span><br><span class="hljs-attr">webServer.port</span> = <span class="hljs-number">7500</span><br><span class="hljs-attr">webServer.user</span> = <span class="hljs-string">&quot;admin&quot;</span><br><span class="hljs-attr">webServer.password</span> = <span class="hljs-string">&quot;admin&quot;</span><br><span class="hljs-comment"># webServer.tls.certFile = &quot;server.crt&quot;</span><br><span class="hljs-comment"># webServer.tls.keyFile = &quot;server.key&quot;</span><br><span class="hljs-comment"># dashboard assets directory(only for debug mode)</span><br><span class="hljs-comment"># webServer.assetsDir = &quot;./static&quot;</span><br><br><span class="hljs-comment"># Enable golang pprof handlers in dashboard listener.</span><br><span class="hljs-comment"># Dashboard port must be set first</span><br><span class="hljs-attr">webServer.pprofEnable</span> = <span class="hljs-literal">false</span><br><br><span class="hljs-comment"># enablePrometheus will export prometheus metrics on webServer in /metrics api.</span><br><span class="hljs-attr">enablePrometheus</span> = <span class="hljs-literal">true</span><br><br><span class="hljs-comment"># console or real logFile path like ./frps.log</span><br><span class="hljs-attr">log.to</span> = <span class="hljs-string">&quot;./frps.log&quot;</span><br><span class="hljs-comment"># trace, debug, info, warn, error</span><br><span class="hljs-attr">log.level</span> = <span class="hljs-string">&quot;info&quot;</span><br><span class="hljs-attr">log.maxDays</span> = <span class="hljs-number">3</span><br><span class="hljs-comment"># disable log colors when log.to is console, default is false</span><br><span class="hljs-attr">log.disablePrintColor</span> = <span class="hljs-literal">false</span><br><br><span class="hljs-comment"># DetailedErrorsToClient defines whether to send the specific error (with debug info) to frpc. By default, this value is true.</span><br><span class="hljs-attr">detailedErrorsToClient</span> = <span class="hljs-literal">true</span><br><br><span class="hljs-comment"># auth.method specifies what authentication method to use authenticate frpc with frps.</span><br><span class="hljs-comment"># If &quot;token&quot; is specified - token will be read into login message.</span><br><span class="hljs-comment"># If &quot;oidc&quot; is specified - OIDC (Open ID Connect) token will be issued using OIDC settings. By default, this value is &quot;token&quot;.</span><br><span class="hljs-attr">auth.method</span> = <span class="hljs-string">&quot;token&quot;</span><br><br><span class="hljs-comment"># auth.additionalScopes specifies additional scopes to include authentication information.</span><br><span class="hljs-comment"># Optional values are HeartBeats, NewWorkConns.</span><br><span class="hljs-comment"># auth.additionalScopes = [&quot;HeartBeats&quot;, &quot;NewWorkConns&quot;]</span><br><br><span class="hljs-comment"># auth token</span><br><span class="hljs-attr">auth.token</span> = <span class="hljs-string">&quot;12345678&quot;</span><br><br><span class="hljs-comment"># oidc issuer specifies the issuer to verify OIDC tokens with.</span><br><span class="hljs-attr">auth.oidc.issuer</span> = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-comment"># oidc audience specifies the audience OIDC tokens should contain when validated.</span><br><span class="hljs-attr">auth.oidc.audience</span> = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-comment"># oidc skipExpiryCheck specifies whether to skip checking if the OIDC token is expired.</span><br><span class="hljs-attr">auth.oidc.skipExpiryCheck</span> = <span class="hljs-literal">false</span><br><span class="hljs-comment"># oidc skipIssuerCheck specifies whether to skip checking if the OIDC token&#x27;s issuer claim matches the issuer specified in OidcIssuer.</span><br><span class="hljs-attr">auth.oidc.skipIssuerCheck</span> = <span class="hljs-literal">false</span><br><br><span class="hljs-comment"># userConnTimeout specifies the maximum time to wait for a work connection.</span><br><span class="hljs-comment"># userConnTimeout = 10</span><br><br><span class="hljs-comment"># Only allow frpc to bind ports you list. By default, there won&#x27;t be any limit.</span><br><span class="hljs-attr">allowPorts</span> = [<br>  &#123; start = <span class="hljs-number">2000</span>, end = <span class="hljs-number">3000</span> &#125;,<br>  &#123; single = <span class="hljs-number">3001</span> &#125;,<br>  &#123; single = <span class="hljs-number">3003</span> &#125;,<br>  &#123; start = <span class="hljs-number">4000</span>, end = <span class="hljs-number">50000</span> &#125;<br>]<br><br><span class="hljs-comment"># Max ports can be used for each client, default value is 0 means no limit</span><br><span class="hljs-attr">maxPortsPerClient</span> = <span class="hljs-number">0</span><br><br><span class="hljs-comment"># If subDomainHost is not empty, you can set subdomain when type is http or https in frpc&#x27;s configure file</span><br><span class="hljs-comment"># When subdomain is test, the host used by routing is test.frps.com</span><br><span class="hljs-attr">subDomainHost</span> = <span class="hljs-string">&quot;frps.com&quot;</span><br><br><span class="hljs-comment"># custom 404 page for HTTP requests</span><br><span class="hljs-comment"># custom404Page = &quot;/path/to/404.html&quot;</span><br><br><span class="hljs-comment"># specify udp packet size, unit is byte. If not set, the default value is 1500.</span><br><span class="hljs-comment"># This parameter should be same between client and server.</span><br><span class="hljs-comment"># It affects the udp and sudp proxy.</span><br><span class="hljs-attr">udpPacketSize</span> = <span class="hljs-number">1500</span><br><br><span class="hljs-comment"># Retention time for NAT hole punching strategy data.</span><br><span class="hljs-attr">natholeAnalysisDataReserveHours</span> = <span class="hljs-number">168</span><br><br><span class="hljs-comment"># ssh tunnel gateway</span><br><span class="hljs-comment"># If you want to enable this feature, the bindPort parameter is required, while others are optional.</span><br><span class="hljs-comment"># By default, this feature is disabled. It will be enabled if bindPort is greater than 0.</span><br><span class="hljs-comment"># sshTunnelGateway.bindPort = 2200</span><br><span class="hljs-comment"># sshTunnelGateway.privateKeyFile = &quot;/home/frp-user/.ssh/id_rsa&quot;</span><br><span class="hljs-comment"># sshTunnelGateway.autoGenPrivateKeyPath = &quot;&quot;</span><br><span class="hljs-comment"># sshTunnelGateway.authorizedKeysFile = &quot;/home/frp-user/.ssh/authorized_keys&quot;</span><br><br><span class="hljs-section">[[httpPlugins]]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;user-manager&quot;</span><br><span class="hljs-attr">addr</span> = <span class="hljs-string">&quot;127.0.0.1:9000&quot;</span><br><span class="hljs-attr">path</span> = <span class="hljs-string">&quot;/handler&quot;</span><br><span class="hljs-attr">ops</span> = [<span class="hljs-string">&quot;Login&quot;</span>]<br><br><span class="hljs-section">[[httpPlugins]]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;port-manager&quot;</span><br><span class="hljs-attr">addr</span> = <span class="hljs-string">&quot;127.0.0.1:9001&quot;</span><br><span class="hljs-attr">path</span> = <span class="hljs-string">&quot;/handler&quot;</span><br><span class="hljs-attr">ops</span> = [<span class="hljs-string">&quot;NewProxy&quot;</span>]<br></code></pre></td></tr></table></figure><h2 id="一个当前使用的配置参考"><a href="#一个当前使用的配置参考" class="headerlink" title="一个当前使用的配置参考"></a>一个当前使用的配置参考</h2><p>Frps</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># Server Addr</span><br><span class="hljs-attr">bindAddr</span> = <span class="hljs-string">&quot;x.x.x.x&quot;</span><br><span class="hljs-attr">bindPort</span> = <span class="hljs-number">32700</span><br><br><span class="hljs-attr">vhostHTTPPort</span> = <span class="hljs-number">32080</span><br><span class="hljs-attr">vhostHTTPSPort</span> = <span class="hljs-number">32443</span><br><br><span class="hljs-comment"># Web Server</span><br><span class="hljs-comment"># 监控网页</span><br><span class="hljs-attr">webServer.addr</span> = <span class="hljs-string">&quot;x.x.x.x&quot;</span><br><span class="hljs-attr">webServer.port</span> = <span class="hljs-number">32777</span><br><span class="hljs-attr">webServer.user</span> = <span class="hljs-string">&quot;user&quot;</span><br><span class="hljs-attr">webServer.password</span> = <span class="hljs-string">&quot;password&quot;</span><br><br><span class="hljs-comment"># auth</span><br><span class="hljs-comment"># 鉴权</span><br><span class="hljs-attr">auth.method</span> = <span class="hljs-string">&quot;token&quot;</span><br><span class="hljs-attr">auth.additionalScopes</span> = [<span class="hljs-string">&quot;NewWorkConns&quot;</span>]<br><span class="hljs-attr">auth.token</span> = <span class="hljs-string">&quot;password&quot;</span><br><br><span class="hljs-comment"># allow port</span><br><span class="hljs-comment"># 配置允许使用的端口范围</span><br><span class="hljs-attr">allowPorts</span> = [<br>  &#123; start = <span class="hljs-number">32005</span>, end = <span class="hljs-number">32032</span> &#125;,<br>  &#123; single = <span class="hljs-number">32064</span> &#125;<br>]<br><br><span class="hljs-comment"># subdomain</span><br><span class="hljs-comment"># 可以通过特定的子域名访问</span><br><span class="hljs-attr">subdomainHost</span> = <span class="hljs-string">&quot;x.xxx.top&quot;</span><br></code></pre></td></tr></table></figure><p>Frpc</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># Server Addr</span><br><span class="hljs-attr">serverAddr</span> = <span class="hljs-string">&quot;x.x.x.x&quot;</span><br><span class="hljs-attr">serverPort</span> = <span class="hljs-number">32700</span><br><span class="hljs-comment"># 用户名配置，避免proxies.name的重名</span><br><span class="hljs-attr">user</span> = <span class="hljs-string">&quot;pandora&quot;</span><br><span class="hljs-comment"># 鉴权</span><br><span class="hljs-attr">auth.method</span> = <span class="hljs-string">&quot;token&quot;</span><br><span class="hljs-attr">auth.token</span> = <span class="hljs-string">&quot;password&quot;</span><br><br><span class="hljs-comment"># tcp 代理</span><br><span class="hljs-section">[[proxies]]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;name&quot;</span><br><span class="hljs-attr">type</span> = <span class="hljs-string">&quot;tcp&quot;</span><br><span class="hljs-attr">localIP</span> = <span class="hljs-string">&quot;127.0.0.1&quot;</span><br><span class="hljs-attr">localPort</span> = <span class="hljs-number">5000</span><br><span class="hljs-attr">remotePort</span> = <span class="hljs-number">32005</span><br><span class="hljs-comment"># 加密</span><br><span class="hljs-attr">transport.useEncryption</span> = <span class="hljs-literal">true</span><br><span class="hljs-attr">transport.useCompression</span> = <span class="hljs-literal">true</span><br><span class="hljs-attr">healthCheck.type</span> = <span class="hljs-string">&quot;tcp&quot;</span><br><br><span class="hljs-comment"># https 代理</span><br><span class="hljs-section">[[proxies]]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;nas_https&quot;</span><br><span class="hljs-attr">type</span> = <span class="hljs-string">&quot;https&quot;</span><br><span class="hljs-attr">localIP</span> = <span class="hljs-string">&quot;127.0.0.1&quot;</span><br><span class="hljs-attr">localPort</span> = <span class="hljs-number">5001</span><br><span class="hljs-attr">transport.useEncryption</span> = <span class="hljs-literal">true</span><br><span class="hljs-attr">transport.useCompression</span> = <span class="hljs-literal">true</span><br><span class="hljs-comment"># 域名配置</span><br><span class="hljs-attr">customDomains</span> = [<span class="hljs-string">&quot;a.x.xxx.top&quot;</span>]<br><br><span class="hljs-comment"># p2p 打洞</span><br><span class="hljs-section">[[proxies]]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;p2p_nas&quot;</span><br><span class="hljs-attr">type</span> = <span class="hljs-string">&quot;xtcp&quot;</span><br><span class="hljs-comment"># 只有共享密钥 (secretKey) 与服务器端一致的用户才能访问该服务</span><br><span class="hljs-attr">secretKey</span> = <span class="hljs-string">&quot;password&quot;</span><br><span class="hljs-attr">localIP</span> = <span class="hljs-string">&quot;127.0.0.1&quot;</span><br><span class="hljs-attr">localPort</span> = <span class="hljs-number">22</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>frp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>踩坑记 BSS段的初始化</title>
    <link href="/2023/96364bb6/"/>
    <url>/2023/96364bb6/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>接手一个项目，调试全靠串口日志，测试同事测试产品的时候无法拿到日志，刚好产品RAM够大，且刚好有SD卡。所以就诞生了将日志缓存在RAM上，在特定条件下将它写到SD卡上的想法。</p><p>开工。</p><p>写完代码之后发现机器<strong>偶尔会无法启动</strong>，无法开机，无任何日志。</p><p>有的时候是<strong>烧录完成代码后重启无法启动</strong>，有些情况下是<strong>烧录完成代码后运行正常，放置一段时间后无法启动</strong>。</p><p>有时候有些无法启动的机器<strong>放置一段时间又成功启动</strong>。</p><p>一段一段代码，屏蔽，编译，验证，发现一个非常无法理解的事，<code>TFCardLogBufferPut</code>函数注释后设备可以正常启动。</p><p>看代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> TF_CARD_LOG_BUFFER_SIZE     (64*1024ul)</span><br><span class="hljs-type">uint8_t</span> tfCardLogBuffer[TF_CARD_LOG_BUFFER_SIZE] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">uint32_t</span> tfCardLogBufferIndex = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">TFCardLogBufferPut</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> data)</span> &#123;<br>    tfCardLogBuffer[tfCardLogBufferIndex] = data;<br>    tfCardLogBufferIndex++;<br>    <span class="hljs-keyword">if</span>( tfCardLogBufferIndex&gt;=(<span class="hljs-keyword">sizeof</span>(tfCardLogBuffer)/<span class="hljs-keyword">sizeof</span>(tfCardLogBuffer[<span class="hljs-number">0</span>]))<span class="hljs-number">-1</span> ) &#123;<br>        tfCardLogBufferIndex = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我实在无法理解，这段代码是如何导致设备无法启动的，后面搁置了一段时间，遂归结于小众芯片不完善导致。</p><p>但是后面这个需求实在是过于旺盛，遂重新开始验证代码。</p><p>当时代码是这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// main.c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> &#123;<br>    <br>    hal_uartInit();<br>    ax32xx_uart0SendByte(<span class="hljs-string">&#x27;a&#x27;</span>);<br>    ax32xx_uart0SendByte(<span class="hljs-string">&#x27;b&#x27;</span>);<br>    hal_uartSendData(<span class="hljs-string">&#x27;1&#x27;</span>);<br>    hal_uartSendData(<span class="hljs-string">&#x27;2&#x27;</span>);<br>    ax32xx_uart0SendByte(<span class="hljs-string">&#x27;c&#x27;</span>);<br>    <br>    hal_sysInit();<br>    <br>    <span class="hljs-comment">//.... some code here</span><br>&#125;<br><br><span class="hljs-comment">// uart.c</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">hal_uartSendData</span><span class="hljs-params">(u8 data)</span><br>&#123;<br>    ax32xx_uart0SendByte(data);<br>    <br>    TFCardLogBufferPut(data);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">ax32xx_uart0SendByte</span><span class="hljs-params">(u8 data)</span><br>&#123;<br>    R_UART_DATA0 = data;<br>    <span class="hljs-keyword">while</span>((R_UART_PEND0 &amp; <span class="hljs-number">0x2</span>)==<span class="hljs-number">0</span>);<br>    R_UART_PEND0 |= <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TF_CARD_LOG_BUFFER_SIZE     (64*1024ul)</span><br><span class="hljs-type">uint8_t</span> tfCardLogBuffer[TF_CARD_LOG_BUFFER_SIZE] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">uint32_t</span> tfCardLogBufferIndex = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">TFCardLogBufferPut</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> data)</span> &#123;<br>    tfCardLogBuffer[tfCardLogBufferIndex] = data;<br>    tfCardLogBufferIndex = (tfCardLogBufferIndex&gt;=(<span class="hljs-keyword">sizeof</span>(tfCardLogBuffer)/<span class="hljs-keyword">sizeof</span>(tfCardLogBuffer[<span class="hljs-number">0</span>]))<span class="hljs-number">-1</span>) ? <span class="hljs-number">0</span> : tfCardLogBufferIndex+<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行后日志是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs log"># 正常运行 的日志<br>ab12c ...<br><br># 无法启动 的日志<br>ab1<br></code></pre></td></tr></table></figure><p>后面我就猜想了很多：</p><ul><li>这个soc不能支持这么大的数值 64KB</li><li>这个位置的内存被改写了</li><li>和冷启动热启动有关</li><li>芯片异常</li></ul><p>后面我猜想，试试把<code>TFCardLogBufferPut</code>函数里面的<code>tfCardLogBufferIndex</code>的数值和<code>data</code>数值输出出来看看。</p><p>这一看不得了，越界了！</p><p>代码：</p><p><img src="/2023/96364bb6/image-20231020190520640.png" alt="image-20231020190520640"></p><p>输出日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs log">ab1z31m00327300<br></code></pre></td></tr></table></figure><p>这个<code>tfCardLogBufferIndex</code>越界了啊！而且初始化赋0并没有成功！这就非常坑爹了！</p><p>后面尝试在调用这个函数之前再次赋0，发现程序运行正常，设备也正常启动。</p><p>查看map文件这个数组和变量也是存放在BSS段的，这就非常令人费解了。</p><p>看到这里我直接就怀疑，就是这个芯片的锅。</p><p>但是别急这还不是让人最震惊的！后面还有让人更加鼻血飙升的。</p><p>最后找FAE排查问题很久，最后发现BSS段在<code>hal_sysInit</code>函数内初始化。</p><p>看代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">ax32xx_sysInit</span><span class="hljs-params">(u32 *saddr,u32 *eaddr)</span><br>&#123;<br>debg(<span class="hljs-string">&quot;sys init\n&quot;</span>);<span class="hljs-comment">// 这个debg会调用 hal_uartSendData 函数输出日志</span><br>    <br>    <span class="hljs-comment">//...</span><br>    <br>ax32xx_wdtClear();<br><br><span class="hljs-comment">//-----cache set</span><br>ax32xx_sysIcacheInit();<br>ax32xx_sysDcacheInit();<br><span class="hljs-comment">//-----bss clear</span><br>ax32xx_sysBSSClear();<br>    <br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>实在是震惊，无法理解这个RAM的初始化为什么放在main函数里面，实在无法理解进入main函数了，c语言环境都没有OK。</p><p>最烦的就是这种xx芯片，总是会有一些让人血压飙升的操作。</p><blockquote><p>  参考ARM MDK在编译的时候BSS初始化的操作是放在<code>__main</code>函数里面，需要注意的是这个<code>__main</code>不是c语言里面的<code>main</code>函数，它是从MDK自带的库文件里链接的一个函数。这个<code>__main</code>函数会初始化这些段，并调用<code>__rt_entry</code>，最终在<code>__rt_entry</code>中将会调用c语言里面的<code>main</code>函数。</p></blockquote><h1 id="教训总结"><a href="#教训总结" class="headerlink" title="教训总结"></a>教训总结</h1><p>在对数组进行访问的时候一定要先检查范围。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 原函数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">TFCardLogBufferPut</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> data)</span> &#123;<br>    tfCardLogBuffer[tfCardLogBufferIndex] = data;<br>    tfCardLogBufferIndex = (tfCardLogBufferIndex&gt;=(<span class="hljs-keyword">sizeof</span>(tfCardLogBuffer)/<span class="hljs-keyword">sizeof</span>(tfCardLogBuffer[<span class="hljs-number">0</span>]))<span class="hljs-number">-1</span>) ? <span class="hljs-number">0</span> : tfCardLogBufferIndex+<span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 改后</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">TFCardLogBufferPut</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> data)</span> &#123;<br>    <span class="hljs-keyword">if</span>( tfCardLogBufferIndex&gt;=(<span class="hljs-keyword">sizeof</span>(tfCardLogBuffer)/<span class="hljs-keyword">sizeof</span>(tfCardLogBuffer[<span class="hljs-number">0</span>]))<span class="hljs-number">-1</span> ) &#123;<br>        tfCardLogBufferIndex = <span class="hljs-number">0</span>;<br>    &#125;<br>    tfCardLogBuffer[tfCardLogBufferIndex] = data;<br>    tfCardLogBufferIndex++;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>embedded</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ProxmoxVE</title>
    <link href="/2023/52f35219/"/>
    <url>/2023/52f35219/</url>
    
    <content type="html"><![CDATA[<h1 id="ProxmoxVE"><a href="#ProxmoxVE" class="headerlink" title="ProxmoxVE"></a>ProxmoxVE</h1><h2 id="一些前置知识"><a href="#一些前置知识" class="headerlink" title="一些前置知识"></a>一些前置知识</h2><h3 id="qcow2-raw-vmdk-磁盘格式的区别"><a href="#qcow2-raw-vmdk-磁盘格式的区别" class="headerlink" title="qcow2 raw vmdk 磁盘格式的区别"></a>qcow2 raw vmdk 磁盘格式的区别</h3><p>KVM 虚拟化中使用的镜像格式通常为 RAW 和 QCOW2 两种格式.</p><blockquote><h2 id="RAW-img"><a href="#RAW-img" class="headerlink" title="RAW (img)"></a>RAW (img)</h2><p>  RAW 的原意是「未被加工的」, 所以 RAW 格式镜像文件又被称为 <em>原始镜像</em> 或 <em>裸设备镜像</em>, 从这些称谓可以看出, RAW 格式镜像文件能够直接当作一个块设备, 以供 GuestOS 使用. 也就是说 KVM 的 GuestOS 可以直接从 RAW 镜像中启动, 就如 HostOS 直接从硬盘中启动一般.</p><ul><li>是一种裸设备格式，通常提供良好的性能。</li><li>简单且原生，易于使用和转换到其他格式。</li><li>支持直接挂载，可以作为文件系统使用。</li><li>不支持快照、压缩或加密等高级功能。</li><li>占用空间取决于实际使用的数据量，类似于物理磁盘。</li></ul><p>  <strong>块设备</strong>: IO 设备中的一类, 将信息存储在固定大小的块中, 并且每个块都有自己的地址, 常用的块设备有硬盘.</p><p>  <strong>因为 RAW 镜像文件赤裸裸的特性带来了下列好处:</strong></p><ul><li>使用 dd 指令创建一个 File 就能够模拟 RAW 镜像文件</li><li>性能较 QCOW2 要更高 (I&#x2F;O 效率更高25%左右)</li><li>支持裸设备的原生特性, 例如: 直接挂载</li><li>能够随意转换格式, 甚至作为其他两种格式转换时的中间格式</li><li>能够使用 dd 指令来追加 RAW 镜像文件的空间</li></ul><p>  <strong>相对的, RAW 镜像文件也具有一个非常大的缺陷, 就是不支持快照.</strong> 所以才有了后来 QCOW 和 QCOW2 的发展.</p><h2 id="QCOW2-QEMU-COW-2"><a href="#QCOW2-QEMU-COW-2" class="headerlink" title="QCOW2 (QEMU-COW 2)"></a>QCOW2 (QEMU-COW 2)</h2><p>  (摘自官方文档)QEMU copy-on-write format with a range of special features, including the ability to take multiple snapshots, smaller images on filesystems that don’t support sparse files, optional AES encryption, and optional zlib compression<br>  QEMU-COW 镜像文件具有一系列特性, 支持包括 <strong>多重快照</strong>(能够创建基于之前镜像的新镜像, 速度更快), <strong>占用更小的存储空间</strong>(不支持稀疏特性, 不会预先分配指定 Size 的存储空间), <strong>可选的 AES 加密方式</strong>, <strong>可选的 zlib 压缩方式</strong> 等功能.</p><p>  QCOW2 镜像格式是 KVM-QEMU 支持的磁盘镜像格式之一, <strong>其表现形式为在一个系统文件中模拟一个具有一定 Size 的块设备.</strong></p><ul><li>支持快照功能，允许在不增加存储空间的前提下创建多个虚拟机状态的快照。</li><li>支持压缩，可以减少存储空间的使用。</li><li>支持加密，以保护虚拟机磁盘数据的安全性。</li><li>支持Copy-on-Write，只有当数据被修改时才会占用新的存储空间。</li><li>性能接近RAW格式，但提供了更多的高级功能。</li></ul><h2 id="VMDK-Virtual-Machine-Disk"><a href="#VMDK-Virtual-Machine-Disk" class="headerlink" title="VMDK (Virtual Machine Disk)"></a>VMDK (Virtual Machine Disk)</h2><ul><li>主要由VMware使用，支持多种VMware产品。</li><li>支持动态分配和固定大小的虚拟硬盘。</li><li>与VMware的虚拟化环境紧密集成，提供了良好的性能和稳定性。</li><li>支持快照功能，但与QCOW2的快照实现不同。</li><li>通常不用于非VMware环境，与其他虚拟化平台的兼容性有限。</li></ul></blockquote><h3 id="网卡怎么选-VirtIO-E1000-RTL8139"><a href="#网卡怎么选-VirtIO-E1000-RTL8139" class="headerlink" title="网卡怎么选 VirtIO E1000 RTL8139"></a>网卡怎么选 VirtIO E1000 RTL8139</h3><p>“<strong>RTL8139</strong>”（古董级别，性能较差，古老系统使用）速率可以达到100Mb&#x2F;s，这个网卡的兼容性最好。</p><blockquote><p>   这个网卡模式是qemu-kvm默认的模拟网卡类型，RTL8139是Realtek半导体公司的一个10&#x2F;100M网卡系列，是曾经非常流行（当然现在看来有点古老）且兼容性好的网卡，几乎所有的现代操作系统都对RTL8139网卡驱动的提供支持。</p></blockquote><p>“<strong>E1000</strong>”（水桶选手，千兆速率，各项都很均衡）速率可以达到1Gb&#x2F;s，这个网卡的兼容性较好。</p><blockquote><p>  提供Intel e1000系列的网卡模拟，纯的QEMU（非qemu-kvm）默认就是提供Intel e1000系列的虚拟网卡。</p><p>  英特尔<code>e1000</code>甚至为相当古老和不知名的操作系统提供了驱动程序。但物理 e1000 网卡的硬件相当复杂，因此会因为需要对其进行仿真而产生一些开销。</p></blockquote><p>“<strong>VirtIO</strong>” （性能之王，兼容极差）速率可以达到10Gb&#x2F;s，这个网卡的兼容性最差，很多系统需要安装特定驱动才能使用。</p><blockquote><p>  是支持半虚拟化IO（virtio）的设备。</p><p>  如果您在虚拟机内运行的内容都支持<code>virtio</code>，它可能会为您提供最佳性能，因为它允许虚拟机跳过大多数相关步骤模拟虚拟网卡并控制虚拟硬件，主机利用实际物理网卡的硬件功能，最大限度地提高虚拟机流量的效益。</p><p>  VirtIO windows的驱动文件可以在这里下载：<a href="https://github.com/virtio-win/virtio-win-pkg-scripts">https://github.com/virtio-win/virtio-win-pkg-scripts</a></p><p>  <a href="https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/archive-virtio/">https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/archive-virtio/</a></p></blockquote><h3 id="硬盘接口怎么选-IDE-SATA-SCSI-VirtIO"><a href="#硬盘接口怎么选-IDE-SATA-SCSI-VirtIO" class="headerlink" title="硬盘接口怎么选 IDE SATA SCSI VirtIO"></a>硬盘接口怎么选 IDE SATA SCSI VirtIO</h3><p>IDE 速度最差，兼容性较好，比较古老的接口了</p><p>SATA 速度不错，兼容性也可以。</p><p>SCSI （通常称为VirtIO SCSI ）</p><p>VirtIO （通常称为VirtIO Block）</p><blockquote><p>  一般来说，不鼓励使用<code>IDE</code>或 ，<code>SATA</code>因为它们相对较慢。在其最佳实践指南中，Proxmox 建议使用 VirtIO SCSI，即<code>SCSI</code>连接到<code>VirtIO SCSI</code>控制器的总线（在最新的 Proxmox 版本上默认选择）。这是假设您在具有快速磁盘阵列的服务器上运行 Proxmox，稍后会详细介绍。</p><p>  使用<code>SCSI</code>或<code>VirtIO</code>。差异可以忽略不计，但两者都远远优于<code>SATA</code>。Proxmox 建议使用，<code>SCSI</code>因为它更新且维护得更好。</p><p>  <img src="/2023/52f35219/bus-types-table.png" alt="img"></p><p>  <img src="/2023/52f35219/image-41.png" alt="img"></p></blockquote><p>即local-lvm对应&#x2F;dev&#x2F;pve&#x2F;data，&#x2F;var&#x2F;lib&#x2F;vz&#x2F;template&#x2F;iso</p><p>默认存在local目录，对应&#x2F;var&#x2F;lib&#x2F;vz</p><h2 id="一些教程"><a href="#一些教程" class="headerlink" title="一些教程"></a>一些教程</h2><p>PVE 安装 <a href="https://www.right.com.cn/forum/thread-8159418-1-1.html">https://www.right.com.cn/forum/thread-8159418-1-1.html</a></p><p>PVE 的群晖安装 <a href="https://post.smzdm.com/p/a8x84l27/">https://post.smzdm.com/p/a8x84l27/</a></p><p><a href="https://www.cnblogs.com/mokou/p/17042705.html">https://www.cnblogs.com/mokou/p/17042705.html</a></p><p><a href="https://post.smzdm.com/p/apv5xvk9/">https://post.smzdm.com/p/apv5xvk9/</a></p><p>群晖引导 <a href="https://github.com/fbelavenuto/arpl">https://github.com/fbelavenuto/arpl</a></p><p><a href="https://wp.gxnas.com/12245.html">https://wp.gxnas.com/12245.html</a></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p> 准备工作</p><ul><li><p>确保符合安装软件的最低要求</p><blockquote><ul><li>CPU: 64bit (Intel EMT64 or AMD64)</li><li><a href="https://pve.proxmox.com/wiki/FAQ#Supported_CPU_chips" title="FAQ">Intel VT&#x2F;AMD-V capable CPU</a>&#x2F;Mainboard for KVM full virtualization support</li><li>RAM: 1 GB RAM, plus additional RAM needed for guests</li><li>Hard drive with at least 16 GiB of space, plus additional space needed for guests</li><li>One network card (NIC)</li></ul></blockquote></li><li><p>下载PVE的ISO镜像<br>  <a href="https://mirrors.tuna.tsinghua.edu.cn/proxmox/iso/">https://mirrors.tuna.tsinghua.edu.cn/proxmox/iso/</a><br>  <a href="https://www.proxmox.com/downloads">https://www.proxmox.com/downloads</a></p></li><li><p>准备一个u盘</p></li><li><p>将ISO写入u盘</p><ul><li>rufus</li><li>Win32DiskImager</li></ul></li><li><p>使电脑从u盘启动</p></li><li><p>重启设备，正式进入安装流程</p></li><li><p>这里有两种安装方式</p><ul><li>图形化界面安装 (Graphical)（首选，用户体验更佳，交互更简单）</li><li>终端UI界面安装 (Terminal UI)（备选，兼容性强，遇到非常新、非常旧的cpu，第一种方法无法使用的情况下就可以选用这种方式）</li></ul></li><li><p>硬盘格式</p><ul><li>这里有好几种硬盘格式可选。EXT4、XFS、ZFS 和 BTRFS。我只有一两个硬盘，数据相对不是特别的重要，就选默认的ext4了。<ul><li>几种格式的对比。<ul><li><a href="https://forum.proxmox.com/threads/choose-between-ext4-xfs-zfs-and-btrfs-why.135128/">Choose between EXT4, XFS, ZFS and BTRFS ? Why ?</a></li><li><a href="https://linux.cn/article-7083-1.html">如何选择文件系统：EXT4、Btrfs 和 XFS</a></li></ul></li></ul></li></ul></li><li><p>系统将会自动安装，安装后会自动重启</p></li><li><p><code>ping</code>对应地址，重启后不久正常通信后即可访问<code>pve ip:8006</code>进入管理界面</p></li><li><p>重启后，PVE显示器也会提示管理地址。</p></li><li><p>至此安装结束</p></li><li><p>推荐安装完成后再安装上一个PVETools。参考下文。</p></li></ul><h1 id="Cmd"><a href="#Cmd" class="headerlink" title="Cmd"></a>Cmd</h1><h2 id="虚拟机-操作指令"><a href="#虚拟机-操作指令" class="headerlink" title="虚拟机 操作指令"></a>虚拟机 操作指令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">取得虚拟机当前状态</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">pvesh get /nodes/&lt;节点<span class="hljs-built_in">id</span>&gt;/qemu/&lt;虚拟机<span class="hljs-built_in">id</span>&gt;/status/current</span><br>pvesh get /nodes/pve/qemu/107/status/current<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">关闭虚拟机</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">pvesh create /nodes/&lt;节点<span class="hljs-built_in">id</span>&gt;/qemu/&lt;虚拟机<span class="hljs-built_in">id</span>&gt;/status/stop</span><br>pvesh create /nodes/pve/qemu/107/status/stop<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动虚拟机</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">pvesh create /nodes/&lt;节点<span class="hljs-built_in">id</span>&gt;/qemu/&lt;虚拟机<span class="hljs-built_in">id</span>&gt;/status/start</span><br>pvesh create /nodes/pve/qemu/107/status/start<br><br><br><br><br><br>qm &lt;命令&gt; &lt;vmid&gt; [选项]<br>qm [create|set] &lt;vmid&gt;  # 创建虚拟机<br>    --memory  &lt;MBYTES&gt;    memory in MB (64 - 8192)<br>    --sockets &lt;N&gt;         set number of CPU sockets &lt;N&gt;<br>    --cores &lt;N&gt;           set cores per socket to &lt;N&gt;<br>    --ostype NAME         specify OS type<br>    --onboot [yes|no]     start at boot<br>    --keyboard XX         set vnc keyboard layout<br>    --cpuunits &lt;num&gt;      CPU weight for a VM<br>    --name &lt;text&gt;         set a name for the VM<br>    --description &lt;text&gt;  set VM description<br>    --boot [a|c|d|n]      specify boot order<br>    --bootdisk &lt;disk&gt;     enable booting from &lt;disk&gt;<br>    --acpi (yes|no)       enable/disable ACPI<br>    --kvm (yes|no)        enable/disable KVM<br>    --tdf (yes|no)        enable/disable time drift fix<br>    --localtime (yes|no)  set the RTC to local time<br>    --vga (gd5446|vesa)   specify VGA type<br>    --vlan[0-9u]          MODEL=XX:XX:XX:XX:XX:XX[,MODEL=YY:YY:YY:YY:YY:YY]<br>    --ide&lt;N&gt;              [volume=]volume,[,media=cdrom|disk]<br>                          [,cyls=c,heads=h,secs=s[,trans=t]]<br>                          [,cache=none|writethrough|writeback]<br>                          [,snapshot=on|off][,cache=on|off][,format=f]<br>                          [,werror=enospc|ignore|report|stop]<br>                          [,rerror=ignore|report|stop]<br>                          [,backup=no|yes]<br>    --ide&lt;N&gt; &lt;GBYTES&gt;     create new disk<br>    --ide&lt;N&gt; delete       remove drive - destroy image<br>    --ide&lt;N&gt; undef        remove drive - keep image<br>    --cdrom &lt;file&gt;        is an alias for --ide2 &lt;file&gt;,media=cdrom<br>    --scsi&lt;N&gt;             [volume=]volume,[,media=cdrom|disk]<br>                          [,cyls=c,heads=h,secs=s[,trans=t]]<br>                          [,snapshot=on|off][,format=f]<br>                          [,cache=none|writethrough|writeback]<br>                          [,werror=enospc|ignore|report|stop]<br>                          [,backup=no|yes]<br>    --scsi&lt;N&gt; &lt;GBYTES&gt;    create new disk<br>    --scsi&lt;N&gt; delete      remove drive - destroy image<br>    --scsi&lt;N&gt; undef       remove drive - keep image<br>    --virtio&lt;N&gt;           [volume=]volume,[,media=cdrom|disk]<br>                          [,cyls=c,heads=h,secs=s[,trans=t]]<br>                          [,snapshot=on|off][,format=f]<br>                          [,cache=none|writethrough|writeback]<br>                          [,werror=enospc|ignore|report|stop]<br>                          [,rerror=ignore|report|stop]<br>                          [,backup=no|yes]<br>    --virtio&lt;N&gt; &lt;GBYTES&gt;  create new disk<br>    --virtio&lt;N&gt; delete    remove drive - destroy image<br>    --virtio&lt;N&gt; undef     remove drive - keep image<br>    <br>qm monitor &lt;vmid&gt;         # 连接到虚拟机控制监视器<br>qm start &lt;vmid&gt;               # 启动实例<br>qm shutdown &lt;vmid&gt;      # 优雅停止实例 发送关机命令<br>qm wait &lt;vmid&gt; [time]   wait until vm is stopped<br>qm stop &lt;vmid&gt;               # 停止实例 强制停止<br>qm reset &lt;vmid&gt;              # 重启实例 相当于stop然后再start<br>qm suspend &lt;vmid&gt;        # 暂停实例<br>qm resume &lt;vmid&gt;         # 恢复实例<br>qm cad &lt;vmid&gt;               #发送按键 ctrl-alt-delete<br>qm destroy &lt;vmid&gt;        # 销毁实例（删除所有已使用/拥有的卷）<br>qm unlock &lt;vmid&gt;         # 清除迁移/备份锁<br>qm status &lt;vmid&gt;          # 显示实例状态<br>qm cdrom &lt;vmid&gt; [&lt;device&gt;] &lt;path&gt;  set cdrom path. &lt;device is ide2 by default&gt;<br>qm cdrom &lt;vmid&gt; [&lt;device&gt;] eject   eject cdrom<br>qm unlink &lt;vmid&gt; &lt;volume&gt;  delete unused disk images<br>qm vncproxy &lt;vmid&gt; &lt;ticket&gt;  open vnc proxy<br>qm vnc &lt;vmid&gt;           start (X11) vncviewer (experimental)<br>qm showcmd &lt;vmid&gt;     # 显示命令行（调试信息）<br>qm list                             # 列出所有虚拟机<br>qm startall                       # 启动所有虚拟机 当onboot=1时<br>qm stopall [timeout]       # 停止所有虚拟机（默认超时为3分钟）<br></code></pre></td></tr></table></figure><h2 id="集群-操作指令"><a href="#集群-操作指令" class="headerlink" title="集群 操作指令"></a>集群 操作指令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看集群资源状况</span><br>pvesh get /cluster/resources<br><br><br><br>pvesr list# 列出存储复制作业<br>ha-manager status   # 查看HA状态<br>pvecm nodes    # 查看集群节点<br>pvecm status    # 查看集群状态<br>pveperf<br>pve-firewall compile  # 查看防火墙规则<br>pve-firewall localnet  # 输出本地网络信息<br>pve-firewall restart    # 重启防火墙<br>pve-firewall stop      # 停止防火墙<br>pve-firewall start      # 启动防火墙<br><br><br><br></code></pre></td></tr></table></figure><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><h2 id="PVE-Tools-的安装"><a href="#PVE-Tools-的安装" class="headerlink" title="PVE Tools 的安装"></a>PVE Tools 的安装</h2><p>Github地址：<a href="https://github.com/ivanhao/pvetools">https://github.com/ivanhao/pvetools</a></p><h2 id="安装软件出现-401-Unauthorized"><a href="#安装软件出现-401-Unauthorized" class="headerlink" title="安装软件出现 401  Unauthorized"></a>安装软件出现 401  Unauthorized</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">E: Failed to fetch https:<span class="hljs-regexp">//</span>enterprise.proxmox.com<span class="hljs-regexp">/debian/</span>pve<span class="hljs-regexp">/dists/</span>buster/InRelease  <span class="hljs-number">401</span>  Unauthorized [IP: <span class="hljs-number">212.224</span>.<span class="hljs-number">123.70</span> <span class="hljs-number">443</span>]<br></code></pre></td></tr></table></figure><ul><li>在pve管理界面内，更新，存储库<ul><li>将带<code>enterprise</code>字样的库禁用。</li></ul></li></ul><h2 id="apt-update-订阅库不可用的问题"><a href="#apt-update-订阅库不可用的问题" class="headerlink" title="apt update 订阅库不可用的问题"></a>apt update 订阅库不可用的问题</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">Err:5 https://enterprise.proxmox.com/debian/ceph-quincy bookworm InRelease  401  Unauthorized [IP: 51.79.228.122 443]<br>Hit:6 http://security.debian.org bookworm-security InRelease<br>Reading package lists... Done<br>E: Failed to fetch https://enterprise.proxmox.com/debian/ceph-quincy/dists/bookworm/InRelease  401  Unauthorized [IP: 51.79.228.122 443]<br>E: The repository &#x27;https://enterprise.proxmox.com/debian/ceph-quincy bookworm In Release&#x27; is not signed.<br>N: Updating from such a repository can&#x27;t be done securely, and is therefore disa bled by default.<br>N: See apt-secure(8) manpage for repository creation and user configuration details.<br></code></pre></td></tr></table></figure><p>The <strong>apt</strong> package manager on the fresh Proxmox host is configured to download packages from <strong>Enterprise Repository</strong> by default. You must have a paid subscription to use this repo. If you don’t have paid subscription you should switch to <strong>No-Subscription Repository</strong>.</p><blockquote><p>  新 Proxmox 主机上的 <strong>apt</strong> 包管理器默认配置为从 <strong>Enterprise Repository 企业存储库</strong> 下载包。 您必须付费订阅才能使用此存储库。 如果您没有付费订阅，您应该切换到<strong>No-Subscription Repository 无订阅存储库</strong>。</p></blockquote><p>Either delete <code>/etc/apt/sources.list.d/pve-enterprise.list</code> file or comment all lines in this file with <code>#</code>.</p><p>Create new file <code>/etc/apt/sources.list.d/pve-no-subscription.list</code> with content:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">deb http://download.proxmox.com/debian/pve buster pve-no-subscription<br><br><span class="hljs-comment"># PVE 8.0</span><br>deb http://download.proxmox.com/debian/pve bookworm pve-no-subscription<br><span class="hljs-comment"># 镜像源</span><br>deb http://mirrors.ustc.edu.cn/proxmox/debian/pve/ bookworm pve-no-subscription<br></code></pre></td></tr></table></figure><h2 id="apt-update-的时候-NO-PUBKEY-问题"><a href="#apt-update-的时候-NO-PUBKEY-问题" class="headerlink" title="apt update 的时候 NO_PUBKEY 问题"></a>apt update 的时候 NO_PUBKEY 问题</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">The following signatures couldn&#x27;t be verified because the public key is not available: NO_PUBKEY 7BF2812E8A6E88E0<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shel">apt-get install gnupg2 -y<br>wget http://download.proxmox.com/debian/key.asc <br>apt-key add key.asc<br></code></pre></td></tr></table></figure><h2 id="修改PVE的管理地址"><a href="#修改PVE的管理地址" class="headerlink" title="修改PVE的管理地址"></a>修改PVE的管理地址</h2><h3 id="无法进入web管理界面"><a href="#无法进入web管理界面" class="headerlink" title="无法进入web管理界面"></a>无法进入web管理界面</h3><ol><li><p>编辑 interface 文件</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">vi /etc/network/<span class="hljs-built_in">int</span>erfaces<br></code></pre></td></tr></table></figure><p>通过键盘上下左右移动到address这行的IP地址，按一次i进入修改状态，修改为新的IP地址，如果需要网关则修改gateway这行，修改完成确认无误后按一次ESC键输入“:wq”回车保存退出。</p></li><li><p>修改显示</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">vi <span class="hljs-regexp">/etc/i</span>ssue<br></code></pre></td></tr></table></figure><p>通过键盘上下左右移动到https:&#x2F;&#x2F;这行的IP地址，按一次i进入修改状态，修改为新的IP地址，端口8006不要改，修改完成确认无误后按一次ESC键输入“:wq”回车保存退出。</p></li><li><p>修改 hosts 文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">vi <span class="hljs-regexp">/etc/</span>hosts<br></code></pre></td></tr></table></figure><p>通过键盘上下左右移动到第2行的IP地址，按一次i进入修改状态，修改为新的IP地址，修改完成确认无误后按一次ESC键输入“:wq”回车保存退出。</p></li><li><p><strong>reboot</strong>，重启PVE！</p></li></ol><h3 id="可以进入web管理界面"><a href="#可以进入web管理界面" class="headerlink" title="可以进入web管理界面"></a>可以进入web管理界面</h3><p>如果是PVE版本大于等于6.1，则可以使用web管理页面的网络选项菜单中修改vmbr0的IP，修改完成后，点击应用配置生效即可。此操作无需重启服务器即可应用新IP。</p><p><img src="/2023/52f35219/2983653-20221011173336293-1137047342.png" alt="img"></p><p>修改显示的访问的链接地址。<br>重启后的提示语还是显示原来的https:&#x2F;&#x2F;旧IP:8006。这个要是以后忘了就容易出问题。可以更改&#x2F;etc&#x2F;hosts文件，也可以在web管理页面主机处修改，修改完记得保存。此操作修改完需要重启才可刷新显示提示语。</p><p><img src="/2023/52f35219/2983653-20221011173352327-326543372.png" alt="img"></p><h2 id="PVE-导入img磁盘文件-qm-importovf-qm-importovf"><a href="#PVE-导入img磁盘文件-qm-importovf-qm-importovf" class="headerlink" title="PVE 导入img磁盘文件 qm importovf qm importovf"></a>PVE 导入img磁盘文件 qm importovf qm importovf</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Create a new VM using parameters <span class="hljs-built_in">read</span> from an OVF manifest</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">An <span class="hljs-built_in">alias</span> <span class="hljs-keyword">for</span> qm disk import.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">          &lt;虚拟机ID&gt; &lt;清单&gt;      &lt;存储&gt; [选项]</span><br>qm importovf &lt;vmid&gt; &lt;manifest&gt; &lt;storage&gt; [OPTIONS]<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">示例</span><br>qm importdisk 102 /var/lib/vz/template/iso/openwrt.img local-lvm<br></code></pre></td></tr></table></figure><h2 id="qemu-img-img转换为qcow2"><a href="#qemu-img-img转换为qcow2" class="headerlink" title="qemu-img img转换为qcow2"></a>qemu-img img转换为qcow2</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">转换</span><br>qemu-img convert -f raw -O qcow2 file.img tofile.qcow2<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">导入</span><br>qm importdisk 101 xxxfile.qcow2 local-lvm<br></code></pre></td></tr></table></figure><h2 id="pvetools工具安装省电后无法睿频"><a href="#pvetools工具安装省电后无法睿频" class="headerlink" title="pvetools工具安装省电后无法睿频"></a>pvetools工具安装省电后无法睿频</h2><h2 id="自动调整运行频率"><a href="#自动调整运行频率" class="headerlink" title="自动调整运行频率"></a>自动调整运行频率</h2><p>网上有很多教程会修改<code>vi /etc/default/grub</code>文件，将<code>driver</code>改成<code>acpi-cpufreq</code>。</p><p>我的CPU是J4125，在<code>intel_cpufreq</code>下也可以使用<code>conservative ondemand userspace powersave performance schedutil</code>这些模式。所有就没有去修改。</p><p><a href="https://blog.51cto.com/picker/5020502">参考</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装</span><br>apt-get install cpufrequtils<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看cpu当前信息</span><br>cpufreq-info<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看可以使用的模式</span><br>cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_governors<br><span class="hljs-meta prompt_"># </span><span class="language-bash">例如J4125这里会输出  conservative ondemand userspace powersave performance schedutil</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看当前运行的模式</span><br>cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor<br></code></pre></td></tr></table></figure><p>cpu运行自动配置文件<code>/etc/init.d/cpufrequtils</code></p><ul><li>这个文件在开机的时候会自动调用，自动运行<ul><li>这个文件主要的内容就是运行<code>cpufreq-set</code>指令调整运行模式和频率</li><li>这个文件会优先读取和使用<code>/etc/default/cpufrequtils</code>文件的内容</li></ul></li><li>编辑这个文件<code>vi /etc/init.d/cpufrequtils</code><ul><li>修改频率 模式 保存</li></ul></li><li>重启</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/sh</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">## BEGIN INIT INFO</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Provides:       cpufrequtils</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Required-Start: <span class="hljs-variable">$remote_fs</span> loadcpufreq</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Required-Stop:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Default-Start:  2 3 4 5</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Default-Stop:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Short-Description: <span class="hljs-built_in">set</span> CPUFreq kernel parameters</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Description: utilities to deal with CPUFreq Linux</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">      kernel support</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">## END INIT INFO</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash"></span><br>DESC=&quot;CPUFreq Utilities&quot;<br><br>PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin<br>CPUFREQ_SET=/usr/bin/cpufreq-set<br>CPUFREQ_INFO=/usr/bin/cpufreq-info<br>CPUFREQ_OPTIONS=&quot;&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">use lsb-base</span><br>. /lib/lsb/init-functions<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Which governor to use. Must be one of the governors listed <span class="hljs-keyword">in</span>:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  <span class="hljs-built_in">cat</span> /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_governors</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment"># and which limits to set. Both MIN_SPEED and MAX_SPEED must be values</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">listed <span class="hljs-keyword">in</span>:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  <span class="hljs-built_in">cat</span> /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_frequencies</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">a value of 0 <span class="hljs-keyword">for</span> any of the two variables will disabling the use of</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">that <span class="hljs-built_in">limit</span> variable.</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment"># WARNING: the correct kernel module must already be loaded or compiled in.</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment"># Set ENABLE to &quot;true&quot; to let the script run at boot time.</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment"># eg:   ENABLE=&quot;true&quot;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">      GOVERNOR=<span class="hljs-string">&quot;ondemand&quot;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">      MAX_SPEED=1000</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">      MIN_SPEED=500</span><br><br>ENABLE=&quot;true&quot;<br>GOVERNOR=&quot;ondemand&quot;<br>MAX_SPEED=&quot;0&quot;<br>MIN_SPEED=&quot;0&quot;<br><br>check_governor_avail() &#123;<br>        info=&quot;/sys/devices/system/cpu/cpu0/cpufreq/scaling_available_governors&quot;<br>        if [ -f $info ] &amp;&amp; grep -q &quot;\&lt;$GOVERNOR\&gt;&quot; $info ; then<br>                return 0;<br>        fi<br>        return 1;<br>&#125;<br><br>[ -x $CPUFREQ_SET ] || exit 0<br><br>if [ -f /etc/default/cpufrequtils ] ; then<br>        . /etc/default/cpufrequtils<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">if</span> not enabled <span class="hljs-keyword">then</span> <span class="hljs-built_in">exit</span> gracefully</span><br>[ &quot;$ENABLE&quot; = &quot;true&quot; ] || exit 0<br><br>if [ -n &quot;$MAX_SPEED&quot; ] &amp;&amp; [ $MAX_SPEED != &quot;0&quot; ] ; then<br>        CPUFREQ_OPTIONS=&quot;$CPUFREQ_OPTIONS --max $MAX_SPEED&quot;<br>fi<br><br>if [ -n &quot;$MIN_SPEED&quot; ] &amp;&amp; [ $MIN_SPEED != &quot;0&quot; ] ; then<br>        CPUFREQ_OPTIONS=&quot;$CPUFREQ_OPTIONS --min $MIN_SPEED&quot;<br>fi<br><br>if [ -n &quot;$GOVERNOR&quot; ] ; then<br>        CPUFREQ_OPTIONS=&quot;$CPUFREQ_OPTIONS --governor $GOVERNOR&quot;<br>fi<br><br>CPUS=$(cat /proc/stat|sed -ne &#x27;s/^cpu\([[:digit:]]\+\).*/\1/p&#x27;)<br>RETVAL=0<br>case &quot;$1&quot; in<br>        start|force-reload|restart|reload)<br>                log_action_begin_msg &quot;$DESC: Setting $GOVERNOR CPUFreq governor&quot;<br>                if check_governor_avail ; then<br>                        for cpu in $CPUS ; do<br>                                log_action_cont_msg &quot;CPU$&#123;cpu&#125;&quot;<br>                                $CPUFREQ_SET --cpu $cpu $CPUFREQ_OPTIONS 2&gt;&amp;1 &gt; /dev/null || \<br>                                        RETVAL=$?<br>                        done<br>                        log_action_end_msg $RETVAL &quot;&quot;<br>                else<br>                        log_action_cont_msg &quot;disabled, governor not available&quot;<br>                        log_action_end_msg $RETVAL<br>                fi<br>                ;;<br>        stop)<br>                ;;<br>        *)<br>                echo &quot;Usage: $0 &#123;start|stop|restart|reload|force-reload&#125;&quot;<br>                exit 1<br>esac<br><br>exit 0<br></code></pre></td></tr></table></figure><h2 id="pve-合并local-lvm和local分区"><a href="#pve-合并local-lvm和local分区" class="headerlink" title="pve 合并local-lvm和local分区"></a>pve 合并local-lvm和local分区</h2><p><a href="https://blog.csdn.net/weixin_52960369/article/details/135450871">参考</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">lsblk 查看一下分区结构</span> <br>lsblk<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">备份一下 虚拟机的磁盘文件。。。 这一步我没做。。。。。 悲剧了</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除 local-lvm 千万注意备份一下 pve/data/ 目录下的 disk 虚拟磁盘文件 PVE8.2.2我照着这么操作直接把磁盘文件给删掉了，我人都傻了。。。。。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">后面几个就是在删除磁盘文件</span><br>lvremove pve/data<br>Removing pool pve/data will remove 3 dependent volume(s). Proceed? [y/n]: y<br>Do you really want to remove active logical volume pve/vm-220-disk-0? [y/n]: y<br>  Logical volume &quot;vm-220-disk-0&quot; successfully removed.<br>Do you really want to remove active logical volume pve/vm-300-disk-0? [y/n]: y<br>  Logical volume &quot;vm-300-disk-0&quot; successfully removed.<br>Do you really want to remove active logical volume pve/vm-220-disk-1? [y/n]: y<br>  Logical volume &quot;vm-220-disk-1&quot; successfully removed.<br>Do you really want to remove active logical volume pve/data? [y/n]: y<br>  Logical volume &quot;data&quot; successfully removed.<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">扩展<span class="hljs-built_in">local</span></span><br>lvextend -l +100%FREE -r pve/root<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看状态</span><br>lsblk<br></code></pre></td></tr></table></figure><p>在管理页面删除local-LVM<br><img src="/ProxmoxVE.assets/image-20240626174453544.png"></p><p>修改 local 的属性将local-lvm的功能加上去。</p><h2 id="安装群晖"><a href="#安装群晖" class="headerlink" title="安装群晖"></a>安装群晖</h2><p><a href="https://post.smzdm.com/p/a2036n3n/">参考</a></p><ul><li>创建虚拟机<ul><li>操作系统<ul><li>不需要使用介质</li></ul></li><li>系统<ul><li>机型，这里大部分教程推荐使用 <code>q35</code><ul><li><code>q35</code>比默认的<code>i440fx</code>机型更新，性能更好</li><li>也有人说<code>i440fx</code>兼容性更好，有些小bug在<code>i440fx</code>上不会出现。</li></ul></li><li>其他默认即可</li></ul></li><li>磁盘<ul><li>这里需要注意群晖只支持<code>sata</code>，无法支持性能更强的<code>scsi</code>。</li><li>后面将引导转换为磁盘的时候也需要注意接口要是<code>sata</code>的。</li></ul></li><li>CPU<ul><li>类型<ul><li>host 代表使用和主机一样的CPU信息和架构（通用性差，性能更优）</li></ul></li></ul></li><li>内存</li><li>网络<ul><li>网络这里有些引导不支持<code>VirtlO</code>，就要要改为<code>E1000</code></li></ul></li></ul></li><li>添加引导<ul><li>将引导<code>*.img</code>文件上传到PVE内</li><li>使用 <code>qm importdisk</code> 指令导入img文件用作磁盘<ul><li><a href="#PVE%20%E5%AF%BC%E5%85%A5img%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%20qm%20importovf%20qm%20importovf">PVE 导入img磁盘文件 qm importovf qm importovf</a></li></ul></li><li>将虚拟机内<code>未使用</code>的磁盘改为<code>sata</code>接口，并添加到虚拟机内</li></ul></li><li>硬盘直通<ul><li>。。。。。</li></ul></li><li></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">args: -device &#x27;qemu-xhci,addr=0x18&#x27; -drive &#x27;id=synoboot,file=/root/synoboot.img,if=none,format=raw&#x27; -device &#x27;usb-storage,id=synoboot,drive=synoboot,bootindex=1&#x27;<br></code></pre></td></tr></table></figure><p>关闭虚拟机，编辑虚拟机配置文件 &#x2F;etc&#x2F;pve&#x2F;qemu-server&#x2F;100.conf ，100是对应虚拟机ID，在顶部添加大佬的这一段代码，img路径改成对应的路径。改完后WebUI没有显示的，禁用掉其他启动项，直接启动虚拟机即可</p><h2 id="硬盘直通"><a href="#硬盘直通" class="headerlink" title="硬盘直通"></a>硬盘直通</h2><p>参考资料：<br><a href="https://foxi.buduanwang.vip/virtualization/1754.html/">Proxmox VE pve硬盘直通</a></p><p>PVE的直通分为两种</p><ul><li>直通控制器（sata控制器、nvme控制器）<ul><li>接近裸机性能，损耗非常低</li><li>是一个物理磁盘，虚拟机可以获取真实硬盘信息，具有smart属性。</li><li>磁盘由虚拟机管理，虚拟机可以获取磁盘控制权</li><li><strong>要求PVE系统不能安装在控制器下属磁盘内</strong></li></ul></li><li>直通单个硬盘或者分区<ul><li>CPU性能越好，越接近裸机性能，损耗较低</li><li>硬盘会在虚拟机内会认为是一个qemu-hdd</li><li>磁盘由PVE管理</li><li>限制<ul><li>sata最大6个</li><li>ide最大3个</li><li>scsi最大128个</li><li>virtio-blk最大32个</li></ul></li></ul></li></ul><p><strong>列出当前的所有磁盘</strong><br>我们可以通过下面命令，列出当前的硬盘列表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls -la /dev/disk/by-id/|grep -v dm|grep -v lvm|grep -v part<br></code></pre></td></tr></table></figure><p>nvme开头的是nvme硬盘，ata开头是走sata或者ata通道的设备。scsi是scsi设备-阵列卡raid或者是直通卡上的硬盘。</p><h3 id="直通单个硬盘-分区"><a href="#直通单个硬盘-分区" class="headerlink" title="直通单个硬盘&amp;分区"></a>直通单个硬盘&amp;分区</h3><p>我们可以通过<code>qm set &lt;vmid&gt; --scsi[n] /dev/disk/by-id/xxxxxxx</code> 进行直通。<code>qm set &lt;vmid&gt; --delete scsi[n]</code>来取消直通。<br>vmid指的是虚拟机ID；–scsi[n]指的是接口（同样的还有scsi、sata、ide、virtio），n指的是端口号；&#x2F;dev….指的是需要直通的硬盘&amp;分区路径</p><p>实例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">qm set 220 --sata1 /dev/disk/by-id/ata-Netac_SSD_512GB_AA20230802512G645320<br><br>qm set 101 --scsi1 /dev/disk/by-id/nvme-INTEL_SSDPE2KX020T8_BTLJ039307142P0BGN<br><br></code></pre></td></tr></table></figure><p>建议为scsi设备，这样性能理论上是最优秀的。</p><p><code>qm help set</code> 可以获取帮助信息。</p><h3 id="直通控制器"><a href="#直通控制器" class="headerlink" title="直通控制器"></a>直通控制器</h3><p>磁盘控制器直通之后，虚拟机可以获得全部的磁盘属性。</p><p>需要注意的是，你需要多个磁盘控制器，且Proxmox VE系统安装在非需要直通的硬盘控制器上，否则会将系统直通给虚拟机，导致系统崩溃。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看PCI控制器</span><br>lspci<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看硬盘分布情况</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">有pve-root的，便是pve所在的硬盘</span><br>lsblk<br><br>ls -la /sys/dev/block/|grep -v loop |grep -v dm<br></code></pre></td></tr></table></figure><p>需要按照这个教程开启硬件直通功能<br><a href="https://foxi.buduanwang.vip/virtualization/pve/561.html/">https://foxi.buduanwang.vip/virtualization/pve/561.html/</a></p><p>开启后在控制面板直接添加PCI设备即可。<br><img src="/2023/52f35219/image-20240729150809676.png"><br><img src="/2023/52f35219/image-20240729150802776.png"></p>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pve</tag>
      
      <tag>virtual</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AUTOSAR</title>
    <link href="/2023/2f4ac7e2/"/>
    <url>/2023/2f4ac7e2/</url>
    
    <content type="html"><![CDATA[<h1 id="AUTOSAR"><a href="#AUTOSAR" class="headerlink" title="AUTOSAR"></a>AUTOSAR</h1><p>autosar是一个组织，是一套汽车软件开发的方法论（框架），是一个软件架构（操作系统 中间件），是一个通信接口。</p><p>统一标准、分散实现、集中配置</p><p>AUTOSAR分为两种，这两种是并存的，一个是Classic AUTOSAR（硬实时系统），一个是Adaptive AUTOSAR（软实时系统），</p><p><img src="/2023/2f4ac7e2/image_9dlPD4Dlwg.png"></p><h1 id="Classic-AUTOSAR"><a href="#Classic-AUTOSAR" class="headerlink" title="Classic AUTOSAR"></a>Classic AUTOSAR</h1><p>Classic AUTOSAR，是基于<a href="https://en.wikipedia.org/wiki/OSEK" title="OSEK的">OSEK的</a>嵌入式实时ECU的标准。</p><p>AUTOSAR 经典平台架构在最高抽象级别上区分了微控制器上运行的三个软件层：Application Layer、Runtime Environment (RTE) 和Basic Software (BSW)。</p><p><img src="/2023/2f4ac7e2/image_T85kwaEFPS.png"></p><p>经典平台的一个基本概念是虚拟功能总线（VFB）。该虚拟总线是一组抽象的 RTE，尚未部署到特定 ECU，并将应用程序与基础设施解耦。它通过专用端口进行通信，这意味着应用软件的通信接口必须映射到这些端口。VFB 处理各个 ECU 内部以及 ECU 之间的通信。从应用程序的角度来看，不需要了解底层技术或依赖关系的详细知识。这支持独立于硬件的应用软件的开发和使用。</p><h1 id="Adaptive-AUTOSAR"><a href="#Adaptive-AUTOSAR" class="headerlink" title="Adaptive AUTOSAR"></a>Adaptive AUTOSAR</h1><p>Adaptive AUTOSAR，linux等，高性能</p><p><img src="/2023/2f4ac7e2/image_iQN8gxa-yL.png"></p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>autosar</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见MCU上电初始化逻辑 以STM32F1 CortexM3 为例</title>
    <link href="/2023/880e7a30/"/>
    <url>/2023/880e7a30/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>每一款芯片是如何启动的都值得去研究，只有明白了它是怎么样启动的，你才能知道为什么你的程序可以运行？程序是从哪里运行来的？运行你写的函数之前执行了哪些操作？</p><p>也只有这样你才有对全局的掌控，才能对代码了然于心，提高你解决复杂问题的能力。</p><blockquote><p>  有一次踩坑，某MCU的BSS段未在<code>main</code>运行之前初始化导致程序运行异常，也是跟这个启动流程有关。</p></blockquote><p>通过了解启动文件，我们可以体会到处理器的架构、指令集、中断向量安排等内容，是非常值得玩味的。</p><h1 id="进入正题"><a href="#进入正题" class="headerlink" title="进入正题"></a>进入正题</h1><h2 id="STM32-上电后做了什么"><a href="#STM32-上电后做了什么" class="headerlink" title="STM32 上电后做了什么"></a>STM32 上电后做了什么</h2><h3 id="图解启动流程"><a href="#图解启动流程" class="headerlink" title="图解启动流程"></a>图解启动流程</h3><p><img src="/2023/880e7a30/STM32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.svg" alt="STM32启动流程"></p><p><img src="/2023/880e7a30/215103893_3_20210208091156505-16901903555945.png" alt="215103893_3_20210208091156505"></p><h3 id="文字详细解读启动流程"><a href="#文字详细解读启动流程" class="headerlink" title="文字详细解读启动流程"></a>文字详细解读启动流程</h3><p><strong>启动过程概览</strong></p><blockquote><p>  1、初始化堆栈指针 SP&#x3D;_initial_sp</p><p>  2、初始化PC指针&#x3D;Reset_Handler</p><p>  3、初始化中断向量表</p><p>  4、配置系统时钟</p><p>  5、调用C 库函数<code>_main</code>初始化用户堆栈、.bss段、.data段，从而最终调用main 函数去到C 的世界</p></blockquote><p>而Cortex-M3内核规定，起始地址必须存放堆顶指针，而第二个地址则必须存放复位中断入口向量地址，这样在Cortex-M3内核复位后，会自动从起始地址的下一个32位空间取出复位中断入口向量，跳转执行复位中断服务程序。</p><p><strong>启动过程涉及的代码</strong></p><blockquote><p>  启动过程涉及的文件不仅包含startup_stm32f10x_hd.s，还涉及到了MDK自带的连接库文件entry.o、entry2.o、entry5.o、entry7.o等（从生成的map文件可以看出来）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asm">Stack_Size      EQU     0x00000400<br><br>                AREA    STACK, NOINIT, READWRITE, ALIGN=3<br>Stack_Mem       SPACE   Stack_Size<br>__initial_sp<br></code></pre></td></tr></table></figure><blockquote><p>  开辟栈的大小为0X00000400（1KB），名字为STACK，NOINIT 即不初始化，可读可写，8（2^3）字节对齐。</p><p>  栈的作用是用于局部变量，函数调用，函数形参等的开销，栈的大小不能超过内部SRAM 的大小。如果编写的程序比较大，定义的局部变量很多，那么就需要修改栈的大小。如果某一天，你写的程序出现了莫名奇怪的错误，并进入了 hardfault 的时候，这时你就要考虑下是不是栈不够大，溢出了。</p><p>  <strong>EQU</strong>：宏定义的伪指令，相当于等于，类似与C 中的define。</p><p>  <strong>AREA</strong>：告诉汇编器汇编一个新的代码段或者数据段。STACK 表示段名，这个可以任意命名；NOINIT 表示不初始化；READWRITE 表示可读可写，ALIGN&#x3D;3，表示按照2^3对齐，即8 字节对齐。</p><p>  <strong>SPACE</strong>：用于分配一定大小的内存空间，单位为字节。这里指定大小等于Stack_Size。标号<code>__initial_sp</code> 紧挨着SPACE 语句放置，表示栈的结束地址，即栈顶地址，栈是由<strong>高向低生长</strong>的。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs asm">; &lt;h&gt; Heap Configuration<br>;   &lt;o&gt;  Heap Size (in Bytes) &lt;0x0-0xFFFFFFFF:8&gt;<br>; &lt;/h&gt;<br><br>Heap_Size       EQU     0x00000200<br><br>                AREA    HEAP, NOINIT, READWRITE, ALIGN=3<br>__heap_base<br>Heap_Mem        SPACE   Heap_Size<br>__heap_limit<br></code></pre></td></tr></table></figure><blockquote><p>  开辟堆的大小为0X00000200（512 字节），名字为HEAP，NOINIT 即不初始化，可读可写，8（2^3）字节对齐。<code>__heap_base</code> 表示对的起始地址，<code>__heap_limit</code> 表示堆的结束地址。堆是由<strong>低向高生长</strong>的，跟栈的生长方向相反。</p><p>  堆主要用来动态内存的分配，像malloc()函数申请的内存就在堆上面。这个在STM32里面用的比较少。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs asm">; Vector Table Mapped to Address 0 at Reset<br>                AREA    RESET, DATA, READONLY; 定义一个数据段，名字为RESET， 可读。并声明 __Vectors 、__Vectors_End 和__Vectors_Size 这三个标号具有全局属性，可供外部的文件调用。<br>                EXPORT  __Vectors<br>                EXPORT  __Vectors_End<br>                EXPORT  __Vectors_Size<br>    <br>__Vectors       DCD     __initial_sp                    ; Top of Stack  栈顶位置，第一个表项是栈顶地址;该处物理地址值即为 __Vetors 标号所表示的值;该地址中存储__initial_sp所表示的地址值，<br>                DCD     Reset_Handler                   ; Reset Handler 复位程序地址<br>                DCD     NMI_Handler                     ; NMI Handler<br>...<br>__Vectors_End<br><br>__Vectors_Size  EQU  __Vectors_End - __Vectors<br><br>                AREA    |.text|, CODE, READONLY<br></code></pre></td></tr></table></figure><blockquote><p>  定义一个数据段，名字为RESET， 可读。并声明 __Vectors 、__Vectors_End 和__Vectors_Size 这三个标号具有全局属性，可供外部的文件调用。</p><p>  <strong>EXPORT</strong>：声明一个标号可被外部的文件使用，使标号具有全局属性。如果是IAR 编译器，则使用的是GLOBAL 这个指令。</p><p>  <code>__Vectors</code> 为向量表起始地址，<code>__Vectors_End</code> 为向量表结束地址，两个相减即可算出向量表大小，也就是<code>__Vectors_Size</code>。</p><p>  向量表从FLASH 的0 地址开始放置，以4 个字节为一个单位，地址0 存放的是栈顶地址，0X04 存放的是复位程序的地址，以此类推。从代码上看，向量表中存放的都是中断服务函数的函数名，可我们知道C 语言中的函数名就是一个地址。</p><p>  <strong>DCD</strong>：分配一个或者多个以字为单位的内存，以四字节对齐，并要求初始化这些内存。在向量表中，DCD 分配了一堆内存，并且以ESR 的入口地址初始化它们。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs asm">; 这里调用 SystemInit 初始化时钟 时钟初始化完成后跳转到main函数<br>; Reset handler<br>Reset_Handler    PROC<br>                 EXPORT  Reset_Handler             [WEAK]<br>     IMPORT  __main<br>     IMPORT  SystemInit<br>                 LDR     R0, =SystemInit<br>                 BLX     R0<br>                 LDR     R0, =__main<br>                 BX      R0<br>                 ENDP<br></code></pre></td></tr></table></figure><blockquote><p>  复位子程序是系统上电后第一个执行的程序，调用SystemInit 函数初始化系统时钟，然后调用C 库函数<code>_mian</code>，最终调用main 函数去到C 的世界。</p><p>  <strong>WEAK</strong>：表示弱定义，如果外部文件优先定义了该标号则首先引用该标号，如果外部文件没有声明也不会出错。这里表示复位子程序可以由用户在其他文件重新实现，这里并不是唯一的。</p><p>  <strong>IMPORT</strong>：表示该标号来自外部文件，跟C 语言中的EXTERN 关键字类似。这里表示<code>SystemInit</code>和<code>__main</code> 这两个函数均来自外部的文件。</p><p>  <code>SystemInit()</code>是一个标准的库函数，在<code>system_stm32f10x.c</code>这个库文件定义。主要作用是配置系统时钟，这里调用这个函数之后，单片机的系统时钟配被配置为72M。</p><p>  <code>__main</code> 是一个标准的C 库函数，主要作用是初始化用户堆栈，并在函数的最后调用main 函数去到C 的世界。这就是为什么我们写的程序都有一个main 函数的原因。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs asm">;*******************************************************************************<br>; User Stack and Heap initialization<br>;*******************************************************************************<br>                 IF      :DEF:__MICROLIB           <br>                <br>                 EXPORT  __initial_sp<br>                 EXPORT  __heap_base<br>                 EXPORT  __heap_limit<br>                <br>                 ELSE<br>                <br>                 IMPORT  __use_two_region_memory    ;定义全局标号__use_two_region_memory<br>                 EXPORT  __user_initial_stackheap   ;声明全局标号__user_initial_stackheap，这样外部程序也可调用此标号，进行堆栈和堆的赋值，在__main函数执行过程中调用<br>                 <br>__user_initial_stackheap                            ;标号__user_initial_stackheap，表示用户堆栈初始化程序入口<br><br>                 LDR     R0, =  Heap_Mem            ;保存堆始地址<br>                 LDR     R1, =(Stack_Mem + Stack_Size);保存栈的大小<br>                 LDR     R2, = (Heap_Mem +  Heap_Size);保存堆的大小<br>                 LDR     R3, = Stack_Mem            ;保存栈顶指针<br>                 BX      LR<br><br>                 ALIGN<br><br>                 ENDIF<br><br>                 END<br><br></code></pre></td></tr></table></figure><blockquote><p>  首先判断是否定义了<code>__MICROLIB </code>，如果定义了这个宏则赋予标号<code>__initial_sp</code>（栈顶地址）、<code>__heap_base</code>（堆起始地址）、<code>__heap_limit</code>（堆结束地址）全局属性，可供外部文件调用。有关这个宏我们在KEIL 里面配置，具体见下图 。然后堆栈的初始化就由C 库函数<code>_main</code> 来完成。</p><p>  <img src="/2023/880e7a30/v2-e38d0eae51917b604ec87c9e767a7049_720w.webp" alt="img"></p><p>  如果没有定义<code>__MICROLIB</code> ， 则采用双段存储器模式， 且声明标号<code>__user_initial_stackheap</code> 具有全局属性，让用户自己来初始化堆栈。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 初始化嵌入式闪存接口、PLL并更新系统核心时钟变量。</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief  Setup the microcontroller system</span><br><span class="hljs-comment">  *         Initialize the Embedded Flash Interface, the PLL and update the </span><br><span class="hljs-comment">  *         SystemCoreClock variable.</span><br><span class="hljs-comment">  * @note   This function should be used only after reset.</span><br><span class="hljs-comment">  * @param  None</span><br><span class="hljs-comment">  * @retval None</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">SystemInit</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(STM32F100xE) || defined(STM32F101xE) || defined(STM32F101xG) || defined(STM32F103xE) || defined(STM32F103xG)</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DATA_IN_ExtSRAM</span><br>    SystemInit_ExtMemCtl(); <br>  <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* DATA_IN_ExtSRAM */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> </span><br><br>  <span class="hljs-comment">/* Configure the Vector Table location -------------------------------------*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(USER_VECT_TAB_ADDRESS)</span><br>  SCB-&gt;VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; <span class="hljs-comment">/* Vector Table Relocation in Internal SRAM. */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* USER_VECT_TAB_ADDRESS */</span></span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="main-做了什么"><a href="#main-做了什么" class="headerlink" title="__main() 做了什么"></a><code>__main()</code> 做了什么</h3><p><a href="https://developer.arm.com/documentation/dui0808/c/chr1358938922456">参考ARM文档</a></p><blockquote><p>  The entry point of a program is at __main in the C library where library code:</p><ol><li>Copies non-root (RO and RW) execution regions from their load addresses to their execution addresses. Also, if any data sections are compressed, they are decompressed from the load address to the execution address.</li><li>Zeroes ZI regions.</li><li>Branches to <code>__rt_entry</code>.</li></ol></blockquote><p>程序的入口点位于 C 库中的 __main，其中库代码：</p><ol><li>将 non-root（RO 和 RW）从其加载地址复制到其执行地址。此外，如果任何数据部分被压缩，它们将从加载地址解压缩到执行地址。</li><li>将 ZI 区域归零。</li><li>跳转到 <code>__rt_entry</code>。</li></ol><blockquote><p>  The library function <code>__rt_entry()</code> runs the program as follows:</p><ol><li><p>Sets up the stack and the heap by one of a number of means that include calling <code>__user_setup_stackheap()</code>, calling <code>__rt_stackheap_init()</code>, or loading the absolute addresses of scatter-loaded regions.</p></li><li><p>Calls <code>__rt_lib_init()</code> to initialize referenced library functions, initialize the locale and, if necessary, set up argc and argv for <code>main()</code>.</p><p>For C++, calls the constructors for any top-level objects by way of <code>__cpp_initialize__aeabi_</code>.</p></li><li><p>Calls <code>main()</code>, the user-level root of the application.</p><p>From <code>main()</code>, your program might call, among other things, library functions.</p></li><li><p>Calls <code>exit()</code> with the value returned by <code>main()</code>.</p></li></ol></blockquote><p>库函数<code>__rt_entry()</code>运行程序如下：</p><ol><li><p>通过多种方式中的一种设置堆栈和堆，包括调用<code>__user_setup_stackheap()</code>、调用<code>__rt_stackheap_init()</code>或加载scatter-loaded  区域的绝对地址。</p></li><li><p>调用<code>__rt_lib_init()</code>初始化引用的库函数、初始化区域设置，并在必要时为<code>main()</code>设置<code>argv</code>和<code>argc</code>参数。</p><p>对于 C++，通过 <code>__cpp_initialize__aeabi_</code> 调用任何top-level对象的构造函数。</p></li><li><p>调用<code>main()</code>，应用程序的 user-level 级别的起始。</p><p>在<code>main()</code>中，您的程序可能会调用库函数等。</p></li><li><p>根据<code>main()</code>的返回值调用<code>exit()</code>。</p></li></ol><h3 id="一些参考"><a href="#一些参考" class="headerlink" title="一些参考"></a>一些参考</h3><blockquote><p>  STM32启动过程–启动文件–分析：<a href="https://www.cnblogs.com/dreamboy2000/p/15806645.html">https://www.cnblogs.com/dreamboy2000/p/15806645.html</a></p><p>  ARM编译器指南 执行环境的初始化和应用程序的执行：<a href="https://developer.arm.com/documentation/dui0808/c/chr1358938922456">https://developer.arm.com/documentation/dui0808/c/chr1358938922456</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>embedded</tag>
      
      <tag>stm32</tag>
      
      <tag>cortexm3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMake的使用</title>
    <link href="/2023/3c5e47f1/"/>
    <url>/2023/3c5e47f1/</url>
    
    <content type="html"><![CDATA[<h1 id="LVGL"><a href="#LVGL" class="headerlink" title="LVGL"></a>LVGL</h1><p>Github：<a href="https://github.com/lvgl/lvgl/">https://github.com/lvgl/lvgl/</a></p><p>LVGL：<a href="https://lvgl.io/">https://lvgl.io/</a></p><p>LVGL（轻巧多功能图形库）是一个免费的开源图形库，提供创建具有易于使用的图形元素、精美的视觉效果和低内存占用的嵌入式 GUI 所需的一切。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>丰富且强大的模块化<a href="https://docs.lvgl.io/master/widgets/index.html">图形组件</a>：按钮 (buttons)、图表 (charts)、列表 (lists)、滑动条 (sliders)、图片 (images) 等</li><li>高级的图形引擎：动画、抗锯齿、透明度、平滑滚动、图层混合等效果</li><li>支持多种<a href="https://docs.lvgl.io/master/overview/indev.html">输入设备</a>：触摸屏、 键盘、编码器、按键等</li><li>支持<a href="https://docs.lvgl.io/master/overview/display.html">多显示设备</a></li><li>不依赖特定的硬件平台，可以在任何显示屏上运行</li><li>配置可裁剪（最低资源占用：64 kB Flash，16 kB RAM）</li><li>基于UTF-8的多语种支持，例如中文、日文、韩文、阿拉伯文等</li><li>可以通过<a href="https://docs.lvgl.io/master/overview/style.html">类CSS</a>的方式来设计、布局图形界面（例如：<a href="https://docs.lvgl.io/master/layouts/flex.html">Flexbox</a>、<a href="https://docs.lvgl.io/master/layouts/grid.html">Grid</a>）</li><li>支持操作系统、外置内存、以及硬件加速（LVGL已内建支持STM32 DMA2D、SWM341 DMA2D、NXP PXP和VGLite）</li><li>即便仅有<a href="https://docs.lvgl.io/master/porting/display.html">单缓冲区(frame buffer)</a>的情况下，也可保证渲染如丝般顺滑</li><li>全部由C编写完成，并支持C++调用</li><li>支持Micropython编程，参见：<a href="https://blog.lvgl.io/2019-02-20/micropython-bindings">LVGL API in Micropython</a></li><li>支持<a href="https://docs.lvgl.io/master/get-started/platforms/pc-simulator.html">模拟器</a>仿真，可以无硬件依托进行开发</li><li>丰富详实的<a href="https://github.com/lvgl/lvgl/tree/master/examples">例程</a></li><li>详尽的<a href="http://docs.lvgl.io/">文档</a>以及API参考手册，可线上查阅或可下载为PDF格式</li></ul><h3 id="硬件要求"><a href="#硬件要求" class="headerlink" title="硬件要求"></a>硬件要求</h3><table><thead><tr><th><strong>要求</strong></th><th><strong>最低要求</strong></th><th><strong>建议要求</strong></th></tr></thead><tbody><tr><td><strong>架构</strong></td><td>16、32、64位微控制器或微处理器</td><td></td></tr><tr><td><strong>时钟</strong></td><td>&gt; 16 MHz</td><td>&gt; 48 MHz</td></tr><tr><td><strong>Flash&#x2F;ROM</strong></td><td>&gt; 64 kB</td><td>&gt; 180 kB</td></tr><tr><td><strong>Static RAM</strong></td><td>&gt; 16 kB</td><td>&gt; 48 kB</td></tr><tr><td><strong>Draw buffer</strong></td><td>&gt; 1 × <em>hor. res.</em> pixels</td><td>&gt; 1&#x2F;10屏幕大小</td></tr><tr><td><strong>编译器</strong></td><td>C99或更新</td><td></td></tr></tbody></table><p><em>注意：资源占用情况与具体硬件平台、编译器等因素有关，上表中仅给出参考值</em></p><h1 id="如何入门"><a href="#如何入门" class="headerlink" title="如何入门"></a>如何入门</h1><p>请按照如下顺序来学习LVGL：</p><ol><li>使用<a href="https://lvgl.io/demos">网页在线例程</a>来体验LVGL</li><li>阅读文档<a href="https://docs.lvgl.io/master/intro/index.html">简介</a>章节来初步了解LVGL</li><li>再来阅读一下文档快速<a href="https://docs.lvgl.io/master/get-started/quick-overview.html">快速概览</a>章节来了解LVGL的基本知识</li><li>学习如何使用<a href="https://docs.lvgl.io/master/get-started/platforms/pc-simulator.html">模拟器</a>来在电脑上仿真LVGL</li><li>试着动手实践一些<a href="https://github.com/lvgl/lvgl/tree/master/examples">例程</a></li><li>参考<a href="https://docs.lvgl.io/master/porting/index.html">移植指南</a>尝试将LVGL移植到一块开发板上，LVGL也已经提供了一些移植好的<a href="https://github.com/lvgl?q=lv_port_">工程</a></li><li>仔细阅读文档<a href="https://docs.lvgl.io/master/overview/index.html">总览</a>章节来更加深入的了解和熟悉LVGL</li><li>浏览文档<a href="https://docs.lvgl.io/master/widgets/index.html">组件(Widgets)</a>章节来了解如何使用它们</li><li>如果你有问题可以到LVGL<a href="http://forum.lvgl.io/">论坛</a>提问</li><li>阅读文档<a href="https://docs.lvgl.io/master/CONTRIBUTING.html">如何向社区贡献</a>章节来看看你能帮LVGL社区做些什么，以促进LVGL软件质量的不断提高</li></ol><h1 id="模拟器入门"><a href="#模拟器入门" class="headerlink" title="模拟器入门"></a>模拟器入门</h1><p>您可以<strong>仅使用PC试用</strong>LVGL（即没有任何开发板）。LVGL将在PC上的模拟器环境中运行，任何人都可以编写和试验真正的LVGL应用程序。</p><p>在PC上使用模拟器具有以下优点：</p><ul><li>硬件独立 - 编写代码，在PC上运行它，并在显示器上查看结果。</li><li>跨平台 - 任何Windows，Linux或macOS系统都可以运行PC模拟器。</li><li>可移植性 - 编写的代码是可移植的，这意味着您可以在迁移到嵌入式硬件时简单地复制它。</li><li>易于验证 - 模拟器对于报告错误也非常有用，因为它为每个用户提供了一个通用平台。因此，最好在模拟器中重现错误并在<a href="https://forum.lvgl.io/">论坛</a>中使用该代码片段。</li></ul><p><a href="https://docs.lvgl.io/master/get-started/platforms/pc-simulator.html">PC 上的模拟器 — LVGL 文档</a></p>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>cmake</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMake的使用</title>
    <link href="/2023/3c5e47f1/"/>
    <url>/2023/3c5e47f1/</url>
    
    <content type="html"><![CDATA[<h1 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h1><p>CMake是开源、跨平台的构建工具，可以让我们通过编写简单的配置文件去生成本地的Makefile，这个配置文件是<strong>独立于运行平台和编译器</strong>的，这样就不用亲自去编写Makefile了，而且配置文件可以直接拿到其它平台上使用，无需修改，非常方便。</p><p><a href="https://blog.csdn.net/whahu1989/article/details/82078563">Linux下CMake简明教程_linux中cmake_爱就是恒久忍耐的博客-CSDN博客</a></p><h1 id="CMake-的安装"><a href="#CMake-的安装" class="headerlink" title="CMake 的安装"></a>CMake 的安装</h1><h2 id="Ubuntu下的安装"><a href="#Ubuntu下的安装" class="headerlink" title="Ubuntu下的安装"></a>Ubuntu下的安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">sudo</span> apt-get install cmake</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">cmake --version</span><br>cmake version 3.16.3<br>.....<br><span class="hljs-meta prompt_"># </span><span class="language-bash">这样就安装好了</span><br></code></pre></td></tr></table></figure><h1 id="CMake语法"><a href="#CMake语法" class="headerlink" title="CMake语法"></a>CMake语法</h1><h2 id="最简单的版本"><a href="#最简单的版本" class="headerlink" title="最简单的版本"></a>最简单的版本</h2><blockquote><p>  环境：只有一个main.c的<code>hello world</code>文件，没有任何依赖。</p></blockquote><p>在<code>main.c</code>的同级目录下建立一个文件，文件名叫<code>CMakeFileLists.txt</code>，这个文件名不能变更，只能是这个形式。</p><p>文件内容如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># cmake的最低版本要求是2.8</span><br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">2.8</span>)<br><br><span class="hljs-comment"># 工程名</span><br><span class="hljs-keyword">project</span>(download)<br><br><span class="hljs-comment"># 使用main.c这个源文件 生成elf文件 生成的文件名字叫main</span><br><span class="hljs-keyword">add_executable</span>(main, main.c)<br></code></pre></td></tr></table></figure><p>我们在当前目录（<code>main.c</code>和<code>CMakeFileLists.txt</code>的目录下）运行<code>cmake .</code>，含义就是在当前目录下执行cmake。执行成功后会生成<code>Makefils</code>以及一些cmake运行时自动生成的文件。</p><p>这个时候我们使用命令<code>make</code>就可以看到正确编译了。</p><h2 id="一个目录下的多个源文件"><a href="#一个目录下的多个源文件" class="headerlink" title="一个目录下的多个源文件"></a>一个目录下的多个源文件</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span> (VERSION <span class="hljs-number">2.8</span>)<br><br><span class="hljs-keyword">project</span> (demo)<br><br><span class="hljs-comment"># 当前目录下的源文件存列表存放到变量SRC_LIST里</span><br><span class="hljs-keyword">aux_source_directory</span>(. SRC_LIST)<br><br><span class="hljs-comment"># 在add_executable里调用SRC_LIST（注意调用变量时的写法）</span><br><span class="hljs-keyword">add_executable</span>(main <span class="hljs-variable">$&#123;SRC_LIST&#125;</span>)<br></code></pre></td></tr></table></figure><p><code>aux_source_directory()</code>也存在弊端，它<strong>会把指定目录下的所有源文件都加进来</strong>，可能会加入一些我们不需要的文件，此时我们可以使用<strong>set命令</strong>去新建变量来存放需要的源文件</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span> (VERSION <span class="hljs-number">2.8</span>)<br><br><span class="hljs-keyword">project</span> (demo)<br><br><span class="hljs-comment"># set 命令设置变量存放源文件</span><br><span class="hljs-keyword">set</span>( SRC_LIST<br> ./main.c<br> ./testFunc1.c<br> ./testFunc.c)<br><br><span class="hljs-keyword">add_executable</span>(main <span class="hljs-variable">$&#123;SRC_LIST&#125;</span>)<br></code></pre></td></tr></table></figure><h2 id="不同目录下的多个源文件"><a href="#不同目录下的多个源文件" class="headerlink" title="不同目录下的多个源文件"></a>不同目录下的多个源文件</h2><blockquote><p>  文件结构</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">./bin<br>./build<br>./include<br>xx.h<br>xxx.h<br>./src<br>xxx.c<br>xx.c<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span> (VERSION <span class="hljs-number">2.8</span>)<br><br><span class="hljs-keyword">project</span> (demo)<br><br><span class="hljs-comment"># 修改输出位置</span><br><span class="hljs-comment"># EXECUTABLE_OUT_PATH和PROJECT_SOURCE_DIR是CMake自带的预定义变量</span><br><span class="hljs-comment"># EXECUTABLE_OUTPUT_PATH ：目标二进制可执行文件的存放位置</span><br><span class="hljs-comment"># PROJECT_SOURCE_DIR：工程的根目录</span><br><span class="hljs-keyword">set</span> (EXECUTABLE_OUTPUT_PATH <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)<br><br><span class="hljs-comment"># 当前src目录下的源文件存列表存放到变量SRC_LIST里</span><br><span class="hljs-keyword">aux_source_directory</span> (src SRC_LIST)<br><br><span class="hljs-comment"># 将include文件夹设定为头文件搜索路径</span><br><span class="hljs-comment"># 该命令是用来向工程添加多个指定头文件的搜索路径，路径之间用空格分隔。</span><br><span class="hljs-keyword">include_directories</span> (<span class="hljs-keyword">include</span>)<br><br><span class="hljs-comment"># 生成elf文件</span><br><span class="hljs-keyword">add_executable</span> (main <span class="hljs-variable">$&#123;SRC_LIST&#125;</span>)<br></code></pre></td></tr></table></figure><h2 id="静态库和动态库的编译"><a href="#静态库和动态库的编译" class="headerlink" title="静态库和动态库的编译"></a>静态库和动态库的编译</h2><p>编译出动态库和静态库，然后等着让其它程序去使用。</p><blockquote><p>  文件结构</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">./bin<br>./build<br>./lib<br>./include<br>xx.h<br>xxx.h<br>./src<br>xxx.c<br>xx.c<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span> (VERSION <span class="hljs-number">3.5</span>)<br><br><span class="hljs-keyword">project</span> (demo)<br><br><span class="hljs-keyword">set</span> (SRC_LIST <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src/xxx.c)<br><br><span class="hljs-comment"># 生成动态库或静态库</span><br><span class="hljs-comment"># 第1个参数指定库的名字；</span><br><span class="hljs-comment"># 第2个参数决定是动态还是静态，如果没有就默认静态；</span><br><span class="hljs-comment"># 第3个参数指定生成库的源文件</span><br><span class="hljs-keyword">add_library</span> (testFunc_shared SHARED <span class="hljs-variable">$&#123;SRC_LIST&#125;</span>)<br><span class="hljs-keyword">add_library</span> (testFunc_static STATIC <span class="hljs-variable">$&#123;SRC_LIST&#125;</span>)<br><br><span class="hljs-comment"># 设置最终生成的库的名称，还有其它功能，如设置库的版本号等等</span><br><span class="hljs-keyword">set_target_properties</span> (testFunc_shared PROPERTIES OUTPUT_NAME <span class="hljs-string">&quot;testFunc&quot;</span>)<br><span class="hljs-keyword">set_target_properties</span> (testFunc_static PROPERTIES OUTPUT_NAME <span class="hljs-string">&quot;testFunc&quot;</span>)<br><br><span class="hljs-keyword">set</span> (LIBRARY_OUTPUT_PATH <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)<br></code></pre></td></tr></table></figure><h2 id="对库进行链接"><a href="#对库进行链接" class="headerlink" title="对库进行链接"></a>对库进行链接</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">find_library</span>(TESTFUNC_LIB testFunc HINTS <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/testFunc/lib)<br><br><span class="hljs-keyword">target_link_libraries</span> (main <span class="hljs-variable">$&#123;TESTFUNC_LIB&#125;</span>)<br></code></pre></td></tr></table></figure><ul><li>find_library: 在指定目录下查找指定库，并把<strong>库的绝对路径</strong>存放到变量里，其第一个参数是变量名称，第二个参数是库名称，第三个参数是HINTS，第4个参数是路径，其它用法可以参考cmake文档</li><li>target_link_libraries: 把目标文件与库文件进行链接</li></ul><p>ps：在lib目录下有testFunc的静态库和动态库，find_library(TESTFUNC_LIB testFunc …默认是查找动态库，如果想直接指定使用动态库还是静态库，可以写成find_library(TESTFUNC_LIB libtestFunc.so …或者find_library(TESTFUNC_LIB libtestFunc.a …</p><p>ps： 查看elf文件使用了哪些库，可以使用readelf -d .&#x2F;xx来查看</p><p>之前本节教程使用的是库查找方法是link_directories，但是很多读者反映运行时有问题，本人去官方文档上查了下，发现不建议使用了，推荐使用find_library或者find_package</p><h2 id="添加编译选项"><a href="#添加编译选项" class="headerlink" title="添加编译选项"></a>添加编译选项</h2><p>有时编译程序时想添加一些编译选项，如-Wall，-std&#x3D;c++11等，就可以使用add_compile_options来进行操作。</p><p><code>add_compile_options(-std=c++11 -Wall) </code></p><h2 id="更加完善的目录结构及编译选项"><a href="#更加完善的目录结构及编译选项" class="headerlink" title="更加完善的目录结构及编译选项"></a>更加完善的目录结构及编译选项</h2><blockquote><p>  文件结构</p><p>  构建的时候我们需要先<code>cd build</code>，然后再<code>cmake ..</code>构建，最后<code>make -j8</code>编译即可。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">.<br>├── build<br>├── CMakeLists.txt<br>├── libzip<br>│   ├── ioapi.c<br>│   ├── ioapi.h<br>│   ├── unzip.c<br>│   └── unzip.h<br>├── main<br>│   └── curl_zip.c<br>├── tools<br>    └── log<br>        └── log.h<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs shell">cmake_minimum_required(VERSION 3.0)<br>project(curl_zip)<br><br>set(Target down)<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置语言标准</span><br>set(CMAKE_C_STANDARD 11)<br>set(CMAKE_CXX_STANDARD 17)<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">为当前路径以及子目录的源文件加入由-D预编译定义</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">add_definitions(-DFOO -DDEBUG ...)</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置C++编译参数(CMAKE_CXX_FLAGS是全局变量)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">set</span>(CMAKE_CXX_FLAGS <span class="hljs-string">&quot;-Wall std=c++11 -Wextra -fPIC -g&quot;</span>)</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置指定的C++编译器版本是必须的，如果不设置，或者为OFF，则指定版本不可用时，会使用上一版本。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">set</span>(CMAKE_CXX_STANDARD_REQUIRED ON)</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置编译器选项</span><br>add_compile_options(-O3 -Wall) <br><br><br>message(&quot;Target=&quot; $&#123;Target&#125;)<br>message(&quot;---------- Start building ----------&quot;)<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置包含路径</span><br>include_directories(    $&#123;PROJECT_SOURCE_DIR&#125;/libzip<br>                        $&#123;PROJECT_SOURCE_DIR&#125;/tools/log<br>)<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">把xxx目录下所有源文件写入变量SRC_LIST</span><br><span class="hljs-meta prompt_">aux_source_directory($</span><span class="language-bash">&#123;PROJECT_SOURCE_DIR&#125;/libzip           SRC_LIST)</span><br><span class="hljs-meta prompt_">aux_source_directory($</span><span class="language-bash">&#123;PROJECT_SOURCE_DIR&#125;/src/curl         SRC_LIST)</span><br><span class="hljs-meta prompt_">aux_source_directory($</span><span class="language-bash">&#123;PROJECT_SOURCE_DIR&#125;/main             SRC_LIST)</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">以SRC_LIST为源文件生成目标文件xxx</span><br><span class="hljs-meta prompt_">add_executable($</span><span class="language-bash">&#123;Target&#125; <span class="hljs-variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建库文件</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">add_library(&lt;name&gt; [STATIC | SHARED | MODULE] [EXCLUDE_FROM_ALL] source1 source2 ... sourceN)</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">目标文件链接的库</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">target_link_libraries() 总是指明 PRIVATE、PUBLIC 、INTERFACE</span><br>target_link_libraries( $&#123;Target&#125;<br>    pthread<br>    curl<br>    z<br>)<br><br>message(&quot;---------- Stop  building ----------&quot;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>cmake</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 应用编程</title>
    <link href="/2023/47a3870e/"/>
    <url>/2023/47a3870e/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-Application-Programming"><a href="#Linux-Application-Programming" class="headerlink" title="Linux Application Programming"></a>Linux Application Programming</h1><h1 id=""><a href="#" class="headerlink" title="&lt;stdio.h&gt;"></a>&lt;stdio.h&gt;</h1><blockquote><p>  英语：standard input&#x2F;output header，标准输入&#x2F;输出头文件）是C语言为输入输出提供的标准库头文件，其前身是迈克·莱斯克20世纪70年代编写的“可移植输入输出程序库”</p></blockquote><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><table><thead><tr><th align="left">标识符</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>size_t</code></td><td align="left">用于表示大小的数据类型</td></tr><tr><td align="left"><code>FILE</code></td><td align="left">记录流的信息的数据结构</td></tr><tr><td align="left"><code>fpos_t</code></td><td align="left">用于在文件中定位的数据类型</td></tr></tbody></table><h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><table><thead><tr><th align="left">标识符</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>NULL</code></td><td align="left">空指针</td></tr><tr><td align="left"><code>_IOFBF</code></td><td align="left">用于控制缓冲方式的参数</td></tr><tr><td align="left"><code>_IOLBF</code></td><td align="left"></td></tr><tr><td align="left"><code>_IONBF</code></td><td align="left"></td></tr><tr><td align="left"><code>BUFSIZ</code></td><td align="left"><code>setbuf</code>函数使用的缓冲区大小</td></tr><tr><td align="left"><code>EOF</code></td><td align="left">文件结尾标志</td></tr><tr><td align="left"><code>FOPEN_MAX</code></td><td align="left">实现保证能够同时打开的文件数量</td></tr><tr><td align="left"><code>FILENAME_MAX</code></td><td align="left">实现保证支持的最长文件名的字符数</td></tr><tr><td align="left"><code>L_tmpnam</code></td><td align="left">存放<code>tmpnam</code>函数生成的临时文件名的<code>char</code>数组的大小</td></tr><tr><td align="left"><code>SEEK_CUR</code></td><td align="left">用于控制文件定位方式的参数</td></tr><tr><td align="left"><code>SEEK_END</code></td><td align="left"></td></tr><tr><td align="left"><code>SEEK_SET</code></td><td align="left"></td></tr><tr><td align="left"><code>TMP_MAX</code></td><td align="left">实现保证能生成的临时文件名个数</td></tr></tbody></table><h3 id="标准流"><a href="#标准流" class="headerlink" title="标准流"></a>标准流</h3><table><thead><tr><th align="left">标识符</th><th align="left">说明</th><th>fd</th></tr></thead><tbody><tr><td align="left"><code>stdin</code></td><td align="left">标准输入流</td><td>0</td></tr><tr><td align="left"><code>stdout</code></td><td align="left">标准输出流</td><td>1</td></tr><tr><td align="left"><code>stderr</code></td><td align="left">标准错误流</td><td>2</td></tr></tbody></table><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><table><thead><tr><th align="left">类型</th><th align="left">函数原型</th></tr></thead><tbody><tr><td align="left">文件操作</td><td align="left"><code>int remove(const char *filename);</code></td></tr><tr><td align="left"></td><td align="left"><code>int rename(const char *old, const char *new);</code></td></tr><tr><td align="left"></td><td align="left"><code>FILE *tmpfile(void);</code></td></tr><tr><td align="left"></td><td align="left"><code>char *tmpnam(char *s);</code></td></tr><tr><td align="left"></td><td align="left"><code>int fclose(FILE *stream);</code></td></tr><tr><td align="left"></td><td align="left"><code>int fflush(FILE *stream);</code></td></tr><tr><td align="left"></td><td align="left"><code>FILE *fopen(const char * restrict filename, const char * restrict mode);</code></td></tr><tr><td align="left"></td><td align="left"><code>FILE *freopen(const char * restrict filename, const char * restrict mode, FILE * restrict stream);</code></td></tr><tr><td align="left"></td><td align="left"><code>void setbuf(FILE * restrict stream, char * restrict buf);</code></td></tr><tr><td align="left"></td><td align="left"><code>int setvbuf(FILE * restrict stream, char * restrict buf, int mode, size_t size);</code></td></tr><tr><td align="left">格式化输入输出</td><td align="left"><code>int fprintf(FILE * restrict stream, const char * restrict format, ...);</code></td></tr><tr><td align="left"></td><td align="left"><code>int fscanf(FILE * restrict stream, const char * restrict format, ...);</code></td></tr><tr><td align="left"></td><td align="left"><code>int printf(const char * restrict format, ...);</code></td></tr><tr><td align="left"></td><td align="left"><code>int scanf(const char * restrict format, ...);</code></td></tr><tr><td align="left"></td><td align="left"><code>int snprintf(char * restrict s, size_t n, const char * restrict format, ...);</code></td></tr><tr><td align="left"></td><td align="left"><code>int sprintf(char * restrict s, const char * restrict format, ...);</code></td></tr><tr><td align="left"></td><td align="left"><code>int sscanf(const char * restrict s, const char * restrict format, ...);</code></td></tr><tr><td align="left"></td><td align="left"><code>int vfprintf(FILE * restrict stream, const char * restrict format, va_list arg);</code></td></tr><tr><td align="left"></td><td align="left"><code>int vfscanf(FILE * restrict stream, const char * restrict format, va_list arg);</code></td></tr><tr><td align="left"></td><td align="left"><code>int vprintf(const char * restrict format, va_list arg);</code></td></tr><tr><td align="left"></td><td align="left"><code>int vscanf(const char * restrict format, va_list arg);</code></td></tr><tr><td align="left"></td><td align="left"><code>int vsnprintf(char * restrict s, size_t n, const char * restrict format, va_list arg);</code></td></tr><tr><td align="left"></td><td align="left"><code>int vsprintf(char * restrict s, const char * restrict format, va_list arg);</code></td></tr><tr><td align="left"></td><td align="left"><code>int vsscanf(const char * restrict s, const char * restrict format, va_list arg);</code></td></tr><tr><td align="left">字符输入输出</td><td align="left"><code>int fgetc(FILE *stream);</code></td></tr><tr><td align="left"></td><td align="left"><code>char *fgets(char * restrict s, int n, FILE * restrict stream);</code></td></tr><tr><td align="left"></td><td align="left"><code>int fputc(int c, FILE *stream);</code></td></tr><tr><td align="left"></td><td align="left"><code>int fputs(const char * restrict s, FILE * restrict stream);</code></td></tr><tr><td align="left"></td><td align="left"><code>int getc(FILE *stream);</code></td></tr><tr><td align="left"></td><td align="left"><code>int getchar(void);</code></td></tr><tr><td align="left"></td><td align="left"><code>int putc(int c, FILE *stream);</code></td></tr><tr><td align="left"></td><td align="left"><code>int putchar(int c);</code></td></tr><tr><td align="left"></td><td align="left"><code>int puts(const char *s);</code></td></tr><tr><td align="left"></td><td align="left"><code>int ungetc(int c, FILE *stream);</code></td></tr><tr><td align="left">直接输入输出</td><td align="left"><code>size_t fread(void * restrict ptr, size_t size, size_t nmemb, FILE * restrict stream);</code></td></tr><tr><td align="left"></td><td align="left"><code>size_t fwrite(const void * restrict ptr, size_t size, size_t nmemb, FILE * restrict stream);</code></td></tr><tr><td align="left">文件内定位</td><td align="left"><code>int fgetpos(FILE * restrict stream, fpos_t * restrict pos);</code></td></tr><tr><td align="left"></td><td align="left"><code>int fseek(FILE *stream, long int offset, int whence);</code></td></tr><tr><td align="left"></td><td align="left"><code>int fsetpos(FILE *stream, const fpos_t *pos);</code></td></tr><tr><td align="left"></td><td align="left"><code>long int ftell(FILE *stream);</code></td></tr><tr><td align="left"></td><td align="left"><code>void rewind(FILE *stream);</code></td></tr><tr><td align="left">错误处理</td><td align="left"><code>void clearerr(FILE *stream);</code></td></tr><tr><td align="left"></td><td align="left"><code>int feof(FILE *stream);</code></td></tr><tr><td align="left"></td><td align="left"><code>int ferror(FILE *stream);</code></td></tr><tr><td align="left"></td><td align="left"><code>void perror(const char *s);</code></td></tr></tbody></table><h3 id="open"><a href="#open" class="headerlink" title="open()"></a>open()</h3><p>open()调用既能打开一个业已存在的文件，也能创建并打开一个新文件。</p><p>若发生错误，则返回−1，并将 errno 置为相应的错误标志。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 使用这个函数需导入以下头文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><br><span class="hljs-comment">// 原型</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">pathname 要打开的文件由参数 pathname 来标识。如果 pathname 是一符号链接，会对其进行解引用。</span><br><span class="hljs-comment">如果调用成功，open()将返回一文件描述符，用于在后续函数调用中指代该文件。若发生错误，则返回−1，并将 errno 置为相应的错误标志。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">flags 为位掩码，用于指定文件的访问模式。</span><br><span class="hljs-comment">常用的有如下几个：</span><br><span class="hljs-comment">O_RDONLY：只读方式打开文件。</span><br><span class="hljs-comment">O_WRONLY：只写方式打开文件。</span><br><span class="hljs-comment">O_RDWR：读写方式打开文件。</span><br><span class="hljs-comment">O_CREAT：如果文件不存在，则创建文件。</span><br><span class="hljs-comment">O_EXCL：与O_CREAT一起使用，如果文件已存在，则返回错误。</span><br><span class="hljs-comment">O_TRUNC：如果文件已存在，将其截断为0字节。</span><br><span class="hljs-comment">O_APPEND：在文件末尾追加写入。</span><br><span class="hljs-comment">O_NONBLOCK：以非阻塞方式打开文件。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">mode 参数仅在创建新文件使用，当调用 open()创建新文件时 mode 指定了文件的访问权限。</span><br><span class="hljs-comment">S_IRUSR：用户可读权限。</span><br><span class="hljs-comment">S_IWUSR：用户可写权限。</span><br><span class="hljs-comment">S_IXUSR：用户可执行权限。</span><br><span class="hljs-comment">S_IRGRP：组可读权限。</span><br><span class="hljs-comment">S_IWGRP：组可写权限。</span><br><span class="hljs-comment">S_IXGRP：组可执行权限。</span><br><span class="hljs-comment">S_IROTH：其他人可读权限。</span><br><span class="hljs-comment">S_IWOTH：其他人可写权限。</span><br><span class="hljs-comment">S_IXOTH：其他人可执行权限。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">return 调用所返回的文件描述符数值</span><br><span class="hljs-comment">调用成功返回一个大于0的数字，这个数字是文件描述符。（后续对打开或创建的文件，进行读或写的操作时候都需要用到这个文件描述符）。调用失败返回-1。</span><br><span class="hljs-comment">SUSv3 规定，如果调用 open()成功，必须保证其返回值为进程未用文件描述符中数值最小者（优先用数值较小的文件描述符）。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags, <span class="hljs-type">mode_t</span> mode)</span>;<br></code></pre></td></tr></table></figure><blockquote><h3 id="open-函数"><a href="#open-函数" class="headerlink" title="open 函数"></a>open 函数</h3><blockquote><p>  open() 是一个系统调用函数，用于在 Linux 系统中打开或者创建一个文件。</p></blockquote>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span>  <span class="hljs-comment">// 使用这个函数需导入以下头文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags, <span class="hljs-type">mode_t</span> mode)</span>;<br></code></pre></td></tr></table></figure><h3 id="fopen函数"><a href="#fopen函数" class="headerlink" title="fopen函数"></a>fopen函数</h3><blockquote><p>  fopen() 函数是标准 C 库中用来打开文件的函数。</p></blockquote>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span> <span class="hljs-comment">// 使用此函数需导入此头文件</span></span><br>FILE *<span class="hljs-title function_">fopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *mode)</span>;<br></code></pre></td></tr></table></figure></blockquote><h3 id="fclose"><a href="#fclose" class="headerlink" title="fclose()"></a>fclose()</h3><p>关闭流 stream。刷新所有的缓冲区（相当于做了fflush）。</p><h4 id="fclose函数的作用"><a href="#fclose函数的作用" class="headerlink" title="fclose函数的作用"></a><strong>fclose函数的作用</strong></h4><ul><li><p><strong>清空相关的缓冲区</strong></p><p>以写文件为例,程序会先将文本信息存入缓冲区中,然后根据缓冲区刷新指令或者等缓冲区满了以后才向文件写入,那么我们如果不使用fclose()关闭流,就有可能有部分文本信息在缓冲区中没有写入到文本文件中,从而导致文本信息缺失.但是这东西看运气.</p></li><li><p><strong>释放内存</strong></p><p>我们知道,如果我们不手动关闭这个流,系统会维持打开的状态,维持当然需要消耗一定的内存资源,本着苍蝇再小也是块肉的原则当然是要把它关掉了,其实如果有很多流在使用后没有关闭,这部分内存资源也是十分可观的.</p></li></ul><h4 id="多次fclose-会发生什么"><a href="#多次fclose-会发生什么" class="headerlink" title="多次fclose()会发生什么"></a>多次fclose()会发生什么</h4><blockquote><p>  <strong>能不能多次对同一个文件描述符调用fclose？</strong></p><p>  <strong>答案是不行的</strong>。</p><p>  为啥不行，我们需要看看fclose到底干了什么</p><p>  fclose关闭的是一个文件流，当调用fclose时，将会使用户态（C库）缓冲区中的数据刷新到内核区域（或通过socket发送，或者仅仅写回硬盘）。<br>  于此同时，fclose会调用free来释放fp所指向的用户态buffer。</p><p>  因此，如果多次调用fclose，会多次调用free来释放一块已经被释放的区域，而这个动作是危险的。<br>  很多解释是说，因为一旦被释放之后，这块区域就属于未知区域。有可能系统已经把该区域分给了其他进程，所以不能多次fclose。</p><p>  但是我看过Linux关于close的内核源码，发现并不是这样，当第一次调用close时，将会把对应的文件描述符数组flip[fp] &#x3D; NULL。如果再调用close时，会在前面判断该项是否为null，如果为null，return -EINVAL;因此，多次调用fclose时会报错，但不会影响系统其他进程。</p><p>  <a href="https://blog.csdn.net/zdavb/article/details/49069803">来源CSDN</a></p></blockquote><blockquote><p>  *<em>调用fclose之后，FILE <em>fp会变成NULL吗？</em></em></p><p>  不会，没有什么机制把fp置空的动作，只是这个时候fp所指向的区域已经不再有效。</p><p>  <a href="https://blog.csdn.net/zdavb/article/details/49069803">来源CSDN</a></p></blockquote><h3 id="fflush"><a href="#fflush" class="headerlink" title="fflush()"></a>fflush()</h3><p>刷新流 stream 的输出缓冲区，将数据刷新到内核缓冲。</p><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>C 库函数 <strong>int fflush(FILE *stream)</strong> 刷新流 stream 的输出缓冲区。</p><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>下面是 fflush() 函数的声明。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-built_in">int</span> fflush(<span class="hljs-keyword">FILE</span> *stream)<br></code></pre></td></tr></table></figure><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul><li><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象指定了一个缓冲流。</li></ul><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>如果成功，该函数返回零值。如果发生错误，则返回 EOF，且设置错误标识符（即 feof）。</p><h3 id="fsync"><a href="#fsync" class="headerlink" title="fsync()"></a>fsync()</h3><p>fsync函数同步内存中所有已修改的文件数据到储存设备。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 头文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-comment">// 原型</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fsync</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span>;<br><br><span class="hljs-comment">// 参数</span><br>fd 是该进程打开来的文件描述符<br><br><span class="hljs-comment">// 返回值</span><br>函数成功执行时，返回<span class="hljs-number">0</span>。失败返回<span class="hljs-number">-1</span>，errno被设为以下的某个值<br>EBADF：文件描述词无效<br>EIO：读写的过程中发生错误<br>EROFS, EINVAL：文件所在的文件系统不支持同步<br>调用 fsync 可以保证文件的修改时间也被更新。fsync 系统调用可以使您精确的强制每次写入都被更新到磁盘中。您也可以使用同步（synchronous）I/O 操作打开一个文件，这将引起所有写数据都立刻被提交到磁盘中。通过在 open 中指定 O_SYNC 标志启用同步I/O。<br></code></pre></td></tr></table></figure><h3 id="perror"><a href="#perror" class="headerlink" title="perror()"></a>perror()</h3><blockquote><p>  errno是一个错误编号，本质上是一个整形的变量，每个错误对应着一个错误编号，当你调用”<strong>某些</strong>“函数出错时，这个函数会更新errno的值。</p><p>  也就是说，并不是所有的函数都会将错误编号输出到errno变量中。</p></blockquote><p><strong>描述</strong></p><p>C 库函数 <strong>void perror(const char *str)</strong> 把一个描述性错误消息输出到标准错误 stderr。首先输出字符串 <strong>str</strong>，后跟一个冒号，然后是一个空格。</p><p><strong>声明</strong></p><p>下面是 perror() 函数的声明。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">void</span> perror(<span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span> *<span class="hljs-built_in">str</span>)<br></code></pre></td></tr></table></figure><p><strong>参数</strong></p><ul><li><strong>str</strong> – 这是 C 字符串，包含了一个自定义消息，将显示在原本的错误消息之前。</li></ul><h1 id="-1"><a href="#-1" class="headerlink" title="&lt;stdlib.h&gt;"></a>&lt;stdlib.h&gt;</h1><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p><code>stdlib.h</code>中定义的常量:</p><table><thead><tr><th>名字</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td><code>NULL</code></td><td>一般定义为<code>0</code>, 或<code>0L</code>, 或<code>(void*)0</code></td><td>表示<a href="https://zh.wikipedia.org/wiki/%E7%A9%BA%E6%8C%87%E9%92%88">空指针</a>常量的<a href="https://zh.wikipedia.org/wiki/%E5%B7%A8%E9%9B%86">宏</a>; 换句话说，一个常量用来表示一个总是指向无效的内存地址的指针值。</td></tr><tr><td><code>EXIT_FAILURE</code></td><td>一个非<code>0</code>值</td><td>用来指示程序失败的结束，一般用于<code>exit()</code>.</td></tr><tr><td><code>EXIT_SUCCESS</code></td><td><code>0</code></td><td>用来指示程序成功的结束，一般用于<code>exit()</code>.</td></tr><tr><td><code>RAND_MAX</code></td><td><code>&gt;= 32767</code></td><td>函数<code>rand()</code>所能返回的最大的值.</td></tr><tr><td><code>MB_CUR_MAX</code></td><td></td><td>当前locale中多字节字符的最大字节数目</td></tr></tbody></table><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><code>stdlib.h</code>中定义的<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型</a>：</p><table><thead><tr><th>名字</th><th>描述</th></tr></thead><tbody><tr><td><code>size_t</code></td><td>算子<code>sizeof</code>返回结果的数据类型，实际上是无符号整型.</td></tr><tr><td><code>div_t</code> ， <code>ldiv_t</code>，<code>lldiv_t</code></td><td>函数<code>div</code>, <code>ldiv</code>, <code>lldiv</code>的返回结果的数据类型，实际上是包含两个整数的结构类型.</td></tr></tbody></table><h3 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h3><p><code>stdlib.h</code>中声明的库函数可分为六类：类型转换、伪随机数、动态内存分配与回收管理、进程控制、搜索及排序、简单数学。</p><table><thead><tr><th>名字</th><th>描述</th></tr></thead><tbody><tr><td>类型转换</td><td></td></tr><tr><td><code>atof</code></td><td>把<a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a>转换为双精度浮点数。相当于<code>strtod(s, (char**)NULL)</code>.</td></tr><tr><td><code>atoi</code></td><td>把字符串转换为整型. 相当于<code>(int)strtol(s, (char**)NULL, 10)</code>.</td></tr><tr><td><code>atol</code></td><td>把字符串转换为长整型. Equivalente a <code>strtol(s, (char**)NULL, 10)</code>.</td></tr><tr><td><code>atoll</code></td><td>把字符串转换为长长整型. Equivalente a <code>strtol(s, (char**)NULL, 10)</code>. 这是<a href="https://zh.wikipedia.org/wiki/C99">C99</a>新增加的库函数。</td></tr><tr><td><code>strtod</code></td><td>把字符串转换为双精度浮点数，检查结果是否溢出，并返回字符串不能转换部分的地址.</td></tr><tr><td><code>strtof</code></td><td>把字符串转换为单精度浮点数，检查结果是否溢出，并返回字符串不能转换部分的地址.</td></tr><tr><td><code>strtold</code></td><td>把字符串转换为长双精度浮点数，检查结果是否溢出，并返回字符串不能转换部分的地址.</td></tr><tr><td><code>strtol</code></td><td>把字符串转换为长整型，检查结果是否溢出，并返回字符串不能转换部分的地址.</td></tr><tr><td><code>strtoll</code></td><td>把字符串转换为<code>long long int</code>，检查结果是否溢出，并返回字符串不能转换部分的地址.</td></tr><tr><td><code>strtoul</code></td><td>把字符串转换为无符号长整形，检查结果是否溢出，并返回字符串不能转换部分的地址.</td></tr><tr><td><code>strtoull</code></td><td>把字符串转换为<code>unsigned long long int</code>，检查结果是否溢出，并返回字符串不能转换部分的地址.</td></tr><tr><td>伪随机数序列生成</td><td></td></tr><tr><td><code>rand</code></td><td>返回在0到RAND_MAX之间的伪随机数. 不接受参数作为随机数种子，因此产生的伪随机数列相同，有利于程序调试。</td></tr><tr><td><code>srand</code></td><td>初始化<code>rand()</code>接受无符号整型参数作为伪随机数种子.如果种子相同，伪随机数列也相同。</td></tr><tr><td>内存的分配与释放</td><td></td></tr><tr><td><code>aligned_alloc</code></td><td>边界对齐的动态内存分配.</td></tr><tr><td><code>calloc</code></td><td>数组的动态内存分配，且初始化为全零</td></tr><tr><td><code>malloc</code></td><td>动态内存分配，其内容不初始化</td></tr><tr><td><code>realloc</code></td><td>释放老的动态内存块，按照给出的尺寸分配新的动态内存块，老的内存块的内容尽量复制到新的内存块</td></tr><tr><td><code>free</code></td><td>系统释放动态分配的内存. 如果是空指针，则无动作发生；如果指针所指不是动态分配的内存块或者是已释放的内存块，则行为是未定义的。</td></tr><tr><td>进程控制&#x2F;与运行环境的沟通</td><td></td></tr><tr><td><code>abort</code></td><td>导致程序非正常的结束，各种流缓冲区与临时文件直接放弃。实际上抛出<code>raise(SIGABRT)</code>，缺省的信号处理行为是使用退出代码3执行终止（terminate）操作。如果<code>SIGABRT</code>被捕捉且信号处理程序不返回，则程序将不终止.</td></tr><tr><td><code>atexit</code></td><td>登记一个函数，当程序使用<code>exit</code>正常退出时被登记的函数自动被调用.</td></tr><tr><td><code>exit</code></td><td>程序正常终止。首先<code>atexit()</code>登记的函数按照登记的逆序被调用；如果多次调用<code>atexit</code>登记了多个函数，按照登记的逆序调用这些函数。如果一个函数被登记了多次，则程序正常退出时该函数也将被调用多次。然后所有缓冲区中的数据被写回(flushed)；所有打开着的流被关闭；<code>tmpfile</code>函数创建的文件被删除。最后，控制权返回给调用环境，返回数值表示程序返回时的状态，0表示<code>EXIT_SUCCESS</code>, 1表示<code>EXIT_FAILURE</code>.</td></tr><tr><td><code>at_quick_exit</code></td><td>登记一个函数，当程序使用<code>quick_exit</code>正常退出时被登记的函数自动被调用.</td></tr><tr><td><code>_Exit</code></td><td>程序正常终止, 但<code>atexit()</code>, <code>at_quick_exit()</code>, <code>signal()</code>登记的函数不被调用; 打开的流、文件是否被关闭，由编译器的实现者决定</td></tr><tr><td><code>getenv</code></td><td>获得某一个环境变量的字符串值，如果该环境变量不存在，返回<code>NULL</code>.</td></tr><tr><td><code>quick_exit</code></td><td>程序正常终止, 但<code>atexit()</code>, 登记的函数不被调用; <code>at_quick_exit()</code>登记的函数按登记顺序的逆序被调用。</td></tr><tr><td><code>system</code></td><td>把参数作为外部环境的命令执行。 如果参数为空，则判断外部环境是否有命令解释器。</td></tr><tr><td>搜索与排序</td><td></td></tr><tr><td><code>bsearch</code></td><td>折半搜索.</td></tr><tr><td><code>qsort</code></td><td>快速排序.</td></tr><tr><td>整数算术</td><td></td></tr><tr><td><code>abs, labs, llabs</code></td><td>计算整数的绝对值.</td></tr><tr><td><code>div, ldiv, lldiv</code></td><td>计算整数除法的商与余数.</td></tr><tr><td>多字节字符&#x2F;宽字符转换</td><td></td></tr><tr><td><code>mblen</code></td><td>计算多字节字符的长度并确定是否为有效字符 .</td></tr><tr><td><code>mbtowc</code></td><td>多字节字符转换为宽字符.</td></tr><tr><td><code>wctomb</code></td><td>宽字符转换为多字节字符.</td></tr><tr><td>多字节字符串&#x2F;宽字符串转换</td><td></td></tr><tr><td><code>mbstowcs</code></td><td>多字节字符串转换为宽字符串.</td></tr><tr><td><code>wcstombs</code></td><td>宽字符串转换为多字节字符串.</td></tr></tbody></table><h3 id="atof-str-转-double"><a href="#atof-str-转-double" class="headerlink" title="atof() str 转 double"></a>atof() str 转 double</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">double</span> <span class="hljs-title function_">atof</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *nptr)</span>;<br></code></pre></td></tr></table></figure><p><strong>函数说明</strong></p><p>atof()会扫描参数nptr字符串，跳过前面的空格字符，直到遇上数字或正负符号才开始做转换，而再遇到非数字或字符串结束时(‘\0’)才结束转换，并将结果返回。参数nptr字符串可包含正负号、小数点或E(e)来表示指数部分，如123.456或123e-2。</p><p><strong>相关函数</strong></p><ul><li><code>strtod(nptr,(char**)NULL)</code></li><li><code>gcvt</code> 浮点型数转换为字符串，取四舍五入</li></ul><h3 id="atoi-str-转-int"><a href="#atoi-str-转-int" class="headerlink" title="atoi() str 转 int"></a>atoi() str 转 int</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">atoi</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str)</span><br></code></pre></td></tr></table></figure><p>将字符串参数<strong>str</strong>转换为整数（int 类型）。</p><p>在字符串的开头，atoi() 方法忽略所有空格，转换紧跟在空格之后的单词，然后在遇到第一个非数字单词时停止。atoi() 模块实现了字符串的整数描述。</p><h4 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h4><ul><li><strong>str</strong> – 这是整数的字符串表示形式。</li></ul><h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><p>此函数将转换后的整数作为 int 值返回。如果无法执行有效的转换，则返回零。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">val = atoi(<span class="hljs-string">&quot;123456&quot;</span>);<br></code></pre></td></tr></table></figure><blockquote><p><strong>atoi</strong> 输入参数少，使用简单，在一些明确知道数值范围的情况下使用比较合适，转换范围相较于strtol（64位环境下）比较小，而且也不知道返回值为0时是转换失败还是转换成功。</p><p><strong>strtol</strong> 输入参数相对较多，用法也更灵活支持转换成不同进制，能够明确的知道输入数据转换出错的位置和错误原因，相比较与atoi，对于0这种特殊的字符串，能更清楚的知道是转换成功的得到的还是转换失败得到的。</p><p>综上，strtol使用更灵活，功能更强大，且可以判断转换结果的正确性，建议字符串转换为整型时使用strtol</p></blockquote><h3 id="atol-str-转-long-int"><a href="#atol-str-转-long-int" class="headerlink" title="atol() str 转 long int"></a>atol() str 转 long int</h3><h3 id="gcvt-double-转-str"><a href="#gcvt-double-转-str" class="headerlink" title="gcvt() double 转 str"></a>gcvt() double 转 str</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *<span class="hljs-title function_">gcvt</span><span class="hljs-params">(<span class="hljs-type">double</span> number，<span class="hljs-type">size_t</span> ndigits，<span class="hljs-type">char</span> *buf)</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">函数说明</span><br><span class="hljs-comment">gcvt()用来将参数number转换成ASCII码字符串，参数ndigits表示显示的位数。gcvt()与ecvt()和fcvt()不同的地方在于，gcvt()所转换后的字符串包含小数点或正负符号。若转换成功，转换后的字符串会放在参数buf指针所指的空间。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">返回值</span><br><span class="hljs-comment">返回一字符串指针，此地址即为buf指针。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="strtod-str-转-double"><a href="#strtod-str-转-double" class="headerlink" title="strtod() str 转 double"></a>strtod() str 转 double</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">double</span> <span class="hljs-title function_">strtod</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *nptr,<span class="hljs-type">char</span> **endptr)</span>;<br></code></pre></td></tr></table></figure><h3 id="strtol-str-转long-int-不同进制"><a href="#strtol-str-转long-int-不同进制" class="headerlink" title="strtol() str 转long int 不同进制"></a>strtol() str 转long int 不同进制</h3><p>C 库函数 <code>strtol()</code> 把参数 <strong>str</strong> 所指向的字符串根据给定的 <strong>base</strong> 转换为一个长整数（类型为 long int 型），base 必须介于 2 和 36（包含）之间，或者是特殊值 0。</p><p>strtol() 方法将具有字符串数据类型的值转换为长整数。strtol() 方法跳过字符串开头的所有空白字符，将连续的字符转换为部分的一部分，然后在到达第一个非数字字符时终止。</p><p><strong>strtol() 函数对异常的返回可以设置errno，从而可以发现异常的返回。</strong></p><h4 id="声明-1"><a href="#声明-1" class="headerlink" title="声明"></a>声明</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title function_">strtol</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str, <span class="hljs-type">char</span> **endptr, <span class="hljs-type">int</span> base)</span><br></code></pre></td></tr></table></figure><h4 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h4><ul><li><strong>str</strong> – 要转换为长整数的字符串。</li><li><strong>endptr</strong> – 对类型为 char* 的对象的引用，其值由函数设置为 <strong>str</strong> 中数值后的下一个字符。</li><li><strong>base</strong> – 基数，必须介于 2 和 36（包含）之间，或者是特殊值 0。</li></ul><h4 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h4><p>该函数返回转换后的长整数，如果没有执行有效的转换，则返回一个零值。</p><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><p>下面的实例演示了 strtol() 函数的用法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">char</span> str[<span class="hljs-number">30</span>] = <span class="hljs-string">&quot;2030300 This is test&quot;</span>;<br><span class="hljs-type">char</span> *ptr;<br><span class="hljs-type">long</span> ret;<br><br>    errno = <span class="hljs-number">0</span>;<br>ret = strtol(str, &amp;ptr, <span class="hljs-number">10</span>);<br>    <span class="hljs-comment">/* Check for various possible errors */</span>  <br>   <span class="hljs-keyword">if</span> ((errno == ERANGE &amp;&amp; (ret == LONG_MAX || ret == LONG_MIN)) || (errno != <span class="hljs-number">0</span> &amp;&amp; ret == <span class="hljs-number">0</span>)) &#123;  <br>       perror(<span class="hljs-string">&quot;strtol&quot;</span>);  <br>       <span class="hljs-built_in">exit</span>(EXIT_FAILURE);  <br>   &#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;数字（无符号长整数）是 %ld\n&quot;</span>, ret);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;字符串部分是 |%s|&quot;</span>, ptr);<br><br>   <span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出：</span><br><span class="hljs-comment">数字（无符号长整数）是 2030300</span><br><span class="hljs-comment">字符串部分是 | This is test|</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="strtoul-str-转-unsigned-long-int"><a href="#strtoul-str-转-unsigned-long-int" class="headerlink" title="strtoul() str 转 unsigned long int"></a>strtoul() str 转 unsigned long int</h3><h3 id="toascii-int-转-ascii"><a href="#toascii-int-转-ascii" class="headerlink" title="toascii() int 转 ascii"></a>toascii() int 转 ascii</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">toascii</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">函数说明</span><br><span class="hljs-comment">toascii()会将参数c转换成7位的unsigned char值，第八位则会被清除，此字符即会被转成ASCII码字符。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">返回值</span><br><span class="hljs-comment">将转换成功的ASCII码字符值返回。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="tolower-大写-转-小写"><a href="#tolower-大写-转-小写" class="headerlink" title="tolower() 大写 转 小写"></a>tolower() 大写 转 小写</h3><h3 id="toupper-小写-转-大写"><a href="#toupper-小写-转-大写" class="headerlink" title="toupper() 小写 转 大写"></a>toupper() 小写 转 大写</h3><h3 id="strtok-用分隔符分解字符串"><a href="#strtok-用分隔符分解字符串" class="headerlink" title="strtok() 用分隔符分解字符串"></a>strtok() 用分隔符分解字符串</h3><h4 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h4><p>C 库函数 <code>strtok()</code> 分解字符串 <strong>str</strong> 为一组字符串，<strong>delim</strong> 为分隔符。</p><h4 id="声明-2"><a href="#声明-2" class="headerlink" title="声明"></a>声明</h4><p>下面是 strtok() 函数的声明。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *<span class="hljs-title function_">strtok</span><span class="hljs-params">(<span class="hljs-type">char</span> *str, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *delim)</span><br></code></pre></td></tr></table></figure><h4 id="参数-3"><a href="#参数-3" class="headerlink" title="参数"></a>参数</h4><ul><li><strong>str</strong> – 要被分解成一组小字符串的字符串。输入NULL则是从上次结束的位置继续查找。</li><li><strong>delim</strong> – 包含分隔符的 C 字符串。</li></ul><h4 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h4><p>该函数返回被分解的第一个子字符串，如果没有可检索的字符串，则返回一个空指针。</p><h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;8.8.8.8&quot;</span><br><span class="hljs-type">char</span> s[] = <span class="hljs-string">&quot;.&quot;</span> <br><span class="hljs-type">char</span> *token;<br>token = strtok(str, s);<br><span class="hljs-keyword">while</span> (token != <span class="hljs-literal">NULL</span>)<br>&#123;<br>    token = strtok(<span class="hljs-literal">NULL</span>, s);<br>&#125;<br></code></pre></td></tr></table></figure><p>让我们编译并运行上面的程序，这将产生以下结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">This is <br> www<span class="hljs-selector-class">.runoob</span><span class="hljs-selector-class">.com</span> <br> website<br></code></pre></td></tr></table></figure><h1 id="-2"><a href="#-2" class="headerlink" title="&lt;netinet&#x2F;in.h&gt;"></a>&lt;netinet&#x2F;in.h&gt;</h1><blockquote><p>  <strong>网络中的数据传输是按 大端 数据格式来传输的。</strong></p><p>  所以在一些设备上需要进行大小端转换，也就是所谓的<strong>网络字节序转换</strong>。</p></blockquote><h3 id="htonl-htons-ntohl-ntohs"><a href="#htonl-htons-ntohl-ntohs" class="headerlink" title="htonl() htons() ntohl() ntohs()"></a>htonl() htons() ntohl() ntohs()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// host to network long</span><br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">htonl</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> hostlong)</span>;<br><span class="hljs-comment">// host to network short</span><br><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">htons</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> hostshort)</span>;<br><br><span class="hljs-comment">// network to host long</span><br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">ntohl</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> netlong)</span>;<br><span class="hljs-comment">// network to host short</span><br><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">ntohs</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> netshort)</span>;<br></code></pre></td></tr></table></figure><h3 id="INET-ADDRSTRLEN-IPv4-str-len"><a href="#INET-ADDRSTRLEN-IPv4-str-len" class="headerlink" title="INET_ADDRSTRLEN IPv4 str len"></a>INET_ADDRSTRLEN IPv4 str len</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 预定义的字符串长度</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INET_ADDRSTRLEN 16</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INET6_ADDRSTRLEN 46</span><br></code></pre></td></tr></table></figure><h1 id="-3"><a href="#-3" class="headerlink" title="&lt;arpa&#x2F;inet.h&gt;"></a>&lt;arpa&#x2F;inet.h&gt;</h1><h3 id="inet-addr-str-转-in-addr"><a href="#inet-addr-str-转-in-addr" class="headerlink" title="inet_addr() str 转 in_addr"></a>inet_addr() str 转 in_addr</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">in_addr_t</span> <span class="hljs-title function_">inet_addr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)</span>;<br></code></pre></td></tr></table></figure><blockquote><p>  如果参数char *cp无效，函数返回-1(INADDR_NONE),</p><p>  这个函数在处理地址为255.255.255.255时也返回－1,</p><p>  255.255.255.255是一个有效的地址，不过inet_addr无法处理;</p></blockquote><p><strong>建议使用 <code>inet_pton()</code> 替代此函数</strong></p><h3 id="inet-aton-str-转-in-addr"><a href="#inet-aton-str-转-in-addr" class="headerlink" title="inet_aton() str 转 in_addr"></a>inet_aton() str 转 in_addr</h3><p><code>inet_ntoa</code>是一个用于将IPv4地址的二进制值转换为点分十进制格式的函数。它的函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">inet_aton</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *cp, <span class="hljs-keyword">struct</span> in_addr *inp)</span>;<br></code></pre></td></tr></table></figure><blockquote><p>  其中，<code>cp</code>是一个指向以点分十进制格式表示的IPv4地址的字符串，<code>inp</code>是一个指向<code>in_addr</code>结构体的指针，该结构体包含了转换后的二进制值。</p><p>  如果转换成功，<code>inet_aton</code>返回非0值，否则返回0值。需要注意的是，如果提供的字符串地址不合法，那么<code>inet_aton</code>返回0值，而不会设置<code>errno</code>。</p></blockquote><p><strong><code>inet_aton</code>已经被弃用，推荐使用<code>inet_pton</code>函数代替。</strong></p><h3 id="inet-ntoa-in-addr-转-str"><a href="#inet-ntoa-in-addr-转-str" class="headerlink" title="inet_ntoa() in_addr 转 str"></a>inet_ntoa() in_addr 转 str</h3><p><code>inet_ntoa</code>是一个用于将IPv4地址的二进制值转换为点分十进制格式的函数。它的函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *<span class="hljs-title function_">inet_ntoa</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> in_addr)</span>;<br></code></pre></td></tr></table></figure><blockquote><p>  其中，<code>in</code>是一个指向<code>in_addr</code>结构体的指针，该结构体包含了IPv4地址的二进制值。</p><p>  <code>inet_ntoa</code>返回一个指向以点分十进制格式表示的IPv4地址的字符串，如果转换失败，则返回<code>NULL</code>。</p></blockquote><p><strong><code>inet_ntoa</code>已经被弃用，推荐使用<code>inet_ntop</code>函数代替。</strong></p><h3 id="inet-pton-str-转-in-addr"><a href="#inet-pton-str-转-in-addr" class="headerlink" title="inet_pton() str 转 in_addr"></a>inet_pton() str 转 in_addr</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">inet_pton</span><span class="hljs-params">(<span class="hljs-type">int</span> af, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-keyword">restrict</span> src , <span class="hljs-type">void</span> *<span class="hljs-keyword">restrict</span> dst )</span>;<br></code></pre></td></tr></table></figure><blockquote><p>  函数中的p和n分别代表<strong>表达式(presentation)<strong>和</strong>数值(numeric)</strong></p><p>  这里的表达式一般是指字符串，数值对于IPv4就是uint32</p></blockquote><p><code>inet_pton()</code> 转换网络主机地址表达式(presentation)为二进制数值(numeric)，支持IPv4 to IPv6，线程安全，可重入。</p><h4 id="参数-4"><a href="#参数-4" class="headerlink" title="参数"></a>参数</h4><ul><li><code>af</code> – 仅支持<code>AF_INET</code>或<code>AF_INET6</code>，IPv4 IPv6</li><li><code>src</code> – 表达式(presentation)字符串</li><li><code>dst</code> – 数值(numeric)指针</li></ul><h4 id="返回值-4"><a href="#返回值-4" class="headerlink" title="返回值"></a>返回值</h4><p>inet_pton () <strong>成功返回1</strong>（网络地址转换成功）。如果src不包含表示指定地址族中有效网络地址的字符串，<strong>则返回 0</strong> 。如果af不包含有效地址族，<strong>则返回 -1</strong> 并将errno设置为EAFNOSUPPORT。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> addr_str[] = <span class="hljs-string">&quot;8.8.8.8&quot;</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> <span class="hljs-title">addr</span>;</span> <br><br><span class="hljs-keyword">if</span>((res = inet_pton(AF_INET, addr_str, &amp;addr)) &lt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// inet_pton error</span><br>    <span class="hljs-keyword">if</span>(res == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// Invalid expression</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res &lt; <span class="hljs-number">0</span> ) &#123;<br>        <span class="hljs-comment">// error</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">// success</span><br></code></pre></td></tr></table></figure><h3 id="inet-ntop-in-addr-转-str"><a href="#inet-ntop-in-addr-转-str" class="headerlink" title="inet_ntop() in_addr 转 str"></a>inet_ntop() in_addr 转 str</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title function_">inet_ntop</span><span class="hljs-params">(<span class="hljs-type">int</span> af, </span><br><span class="hljs-params">                      <span class="hljs-type">const</span> <span class="hljs-type">void</span> *<span class="hljs-keyword">restrict</span> src, </span><br><span class="hljs-params">                      <span class="hljs-type">char</span> *<span class="hljs-keyword">restrict</span> dst, </span><br><span class="hljs-params">                      <span class="hljs-type">socklen_t</span> size)</span>;<br></code></pre></td></tr></table></figure><p><code>inet_ntop()</code> 函数转换二进制数值(numeric)为网络主机地址表达式(presentation)，支持IPv4 to IPv6，线程安全，可重入。</p><h4 id="参数-5"><a href="#参数-5" class="headerlink" title="参数"></a>参数</h4><ul><li><code>af</code> – 仅支持<code>AF_INET</code>或<code>AF_INET6</code>，IPv4 or IPv6</li><li><code>src</code> – 数值(numeric)指针</li><li><code>dst</code> – 表达式(presentation)字符串</li><li><code>size</code> – 此缓冲区可用字节数</li></ul><h4 id="返回值-5"><a href="#返回值-5" class="headerlink" title="返回值"></a>返回值</h4><p>成功时，inet_ntop() 返回一个指向 <code>dst</code> 的<strong>非空指针</strong>。如果有错误则返回<code>NULL</code>，errno设置为指示错误。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> addr_str[<span class="hljs-number">16</span>];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> <span class="hljs-title">addr</span>;</span> <br><br><span class="hljs-keyword">if</span>( inet_ntop(AF_INET, &amp;addr, addr_str, <span class="hljs-keyword">sizeof</span>(addr_str)) == <span class="hljs-literal">NULL</span> ) &#123;<br>    <span class="hljs-comment">// inet_ntop error</span><br>&#125;<br><span class="hljs-comment">// success</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// man 手册</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> buf[<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> in6_addr)];<br>    <span class="hljs-type">int</span> domain, s;<br>    <span class="hljs-type">char</span> str[INET6_ADDRSTRLEN];<br><br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Usage: %s &#123;i4|i6|&lt;num&gt;&#125; string\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    domain = (<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;i4&quot;</span>) == <span class="hljs-number">0</span>) ? AF_INET : (<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;i6&quot;</span>) == <span class="hljs-number">0</span>) ? AF_INET6 : atoi(argv[<span class="hljs-number">1</span>]);<br><br>    s = inet_pton(domain, argv[<span class="hljs-number">2</span>], buf);<br>    <span class="hljs-keyword">if</span> (s &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-number">0</span>)<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Not in presentation format&quot;</span>);<br>        <span class="hljs-keyword">else</span><br>            perror(<span class="hljs-string">&quot;inet_pton&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (inet_ntop(domain, buf, str, INET6_ADDRSTRLEN) == <span class="hljs-literal">NULL</span>) &#123;<br>        perror(<span class="hljs-string">&quot;inet_ntop&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, str);<br><br>    <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h1><blockquote><p>socket 是一种 IPC 方法，它允许位于同一主机（计算机）或使用网络连接起来的不同主机上的应用程序之间交换数据。</p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>使用 socket()系统调用能够创建一个 socket，<strong>它返回一个用来在后续系统调用中引用该 socket 的文件描述符</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">socket</span> <span class="hljs-params">(<span class="hljs-type">int</span> __domain, <span class="hljs-type">int</span> __type, <span class="hljs-type">int</span> __protocol)</span>;<br><br><span class="hljs-comment">// 在绝大部分情况下 protocol=0</span><br>fd = socket(domain, type, protocol)<br></code></pre></td></tr></table></figure><p><strong>socket domain</strong><br>socket 存在于一个通信 domain 中，它确定：</p><ul><li>识别出一个 socket 的方法（即 socket“地址”的格式）；</li><li>通信范围（即是在位于同一主机上的应用程序之间还是在位于使用一个网络连接起来的不同主机上的应用程序之间）。</li></ul><p>现代操作系统至少支持下列 domain</p><ul><li>UNIX (AF_UNIX) domain 允许在同一主机上的应用程序之间进行通信。</li><li>IPv4 (AF_INET) domain 允许在使用因特网协议第 4 版（IPv4）网络连接起来的主机上的应用程序之间进行通信。</li><li>IPv6 (AF_INET6) domain 允许在使用因特网协议第 6 版（IPv6）网络连接起来的主机上的应用程序之间进行通信。</li></ul><table><thead><tr><th>Domain</th><th>执行的通信</th><th>应用程序间的通信</th><th>地址格式</th><th></th></tr></thead><tbody><tr><td>AF_UNIX</td><td>内核中</td><td>同一主机</td><td>路径名</td><td></td></tr><tr><td>AF_INET</td><td>通过 IPv4</td><td>通过 IPv4 网络连接起来的主机</td><td>32 位 IPv4 地址+16 位端口号</td><td></td></tr><tr><td>AF_INET6</td><td>通过 IPv6</td><td>通过 IPv6 网络连接起来的主机</td><td>128 位 IPv6 地址+16 位端口号</td><td></td></tr></tbody></table><p><strong>socket type</strong><br>每个 socket 实现都至少提供了两种 socket：STREAM (流)和 DGRAM (数据报)。这两种 socket 类型在 UNIX 和 Internet domain 中都得到了支持。</p><table><thead><tr><th>属性</th><th>socket 类型</th><th>socket 类型</th></tr></thead><tbody><tr><td></td><td>STREAM</td><td>DGRAM</td></tr><tr><td>可靠地递送？</td><td>yes</td><td>no</td></tr><tr><td>面向连接？</td><td>yes</td><td>no</td></tr><tr><td>消息边界保留？</td><td>no</td><td>yes</td></tr></tbody></table><ol><li><p><strong>SOCK_STREAM</strong> (流)</p><blockquote><p>  流 socket（SOCK_STREAM）提供了一个可靠的双向的字节流通信信道。</p><ul><li>可靠的：表示可以保证发送者传输的数据会完整无缺地到达接收应用程序（假设网络链接和接收者都不会崩溃）或收到一个传输失败的通知。</li><li>双向的：表示数据可以在两个 socket 之间的任意方向上传输。</li><li>字节流：表示与管道一样不存在消息边界的概念（参见 44.1 节）。</li></ul><p>  一个流 socket 类似于使用一对允许在两个应用程序之间进行双向通信的管道，它们之间<br>  的差别在于（Internet domain）socket 允许在网络上进行通信。</p><p>  流 socket 的正常工作需要一对相互连接的 socket，因此流 socket 通常被称为面向连接的。</p></blockquote></li><li><p><strong>SOCK_DGRAM</strong> (数据报)</p><blockquote><p>  允许数据以被称为数据报的消息的形式进行交换。在数据报 socket 中，消息边界得到了保留，但<strong>数据传输是不可靠的</strong>。<strong>消息的到达可能是无序的、重复的或者根本就无法到达</strong>。</p><p>  数据报 socket 是更一般的<strong>无连接 socket 概念的一个示例</strong>。与流 socket 不同，一个数据报socket 在使用时无需与另一个 socket 连接。（在 56.6.2 节中将会看到数据报 socket 可以与另一个 socket 连接，但其语义与连接的流 socket 是不同的。）</p></blockquote></li></ol><p>在 Internet domain 中，<u>数据报 socket 使用了用户数据报协议（UDP）</u>，而<u>流 socket 则（通常）使用了传输控制协议（TCP）</u>。</p><p>一般来讲，在称呼这两种 socket 时不会使用术语“Internet domain 数据报 socket”和“Internet domain 流 socket”，而是分别使用术语“<strong>UDP socket</strong>”和“<strong>TCP socket</strong>”。</p><p><strong>socket 系统调用</strong><br>关键的 socket 系统调用包括以下几种。</p><ul><li>**socket()**系统调用<ul><li>创建一个新 socket。</li></ul></li><li>**bind()**系统调用<ul><li>将一个 socket 绑定到一个地址上。</li><li>通常，服务器需要使用这个调用来将其 socket 绑定到一个众所周知的地址上使得客户端能够定位到该 socket 上。</li></ul></li><li>**listen()**系统调用<ul><li>允许一个流 socket 接受来自其他 socket 的接入连接。</li></ul></li><li>**accept()**系统调用<ul><li>在一个监听流 socket 上接受来自一个对等应用程序的连接，并可选地返回对等 socket 的地址。</li></ul></li><li>**connect()**系统调用<ul><li>建立与另一个 socket 之间的连接。</li></ul></li></ul><blockquote><p>  socket I&#x2F;O 可以使用传统的 read()和 write()系统调用或使用一组 socket 特有的系统调用（如<u>send()、recv()、sendto()以及 recvfrom()</u>）来完成。</p><p>  在默认情况下，这些系统调用在 I&#x2F;O 操作无法被立即完成时会阻塞。<strong>通过使用 fcntl() F_SETFL 操作（5.3 节）来启用 O_NONBLOCK 打开文件状态标记可以执行非阻塞 I&#x2F;O。</strong></p></blockquote><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><h1 id="Misc"><a href="#Misc" class="headerlink" title="Misc."></a>Misc.</h1><h3 id="assert-断言"><a href="#assert-断言" class="headerlink" title="assert() 断言"></a>assert() 断言</h3><p><a href="https://so.csdn.net/so/search?q=assert&spm=1001.2101.3001.7020">assert</a>()是一个调试程序时经常使用的宏，在程序运行时它计算括号内的表达式，如果表达式为FALSE (0), 程序将报告错误，并终止执行。如果表达式不为0，则继续执行后面的语句，它的作用是<strong>终止程序以免导致严重后果，同时也便于查找错误</strong>。</p><p>所需头文件：<code>#include &lt;assert.h&gt;</code></p><p>报告错误的条件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">assert</span><span class="hljs-params">(</span><br><span class="hljs-params">   <span class="hljs-type">int</span> expression</span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><p>参数：Expression (including pointers) that evaluates to nonzero or 0.（表达式【包括指针】是非零或零）</p><p>原理：assert的作用是现计算表达式 expression ，如果其值为假（即为0），那么它先向stderr打印一条出错信息，然后通过调用 abort 来终止程序运行。<br>示例程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">void</span> *<span class="hljs-title function_">memcpy</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvTo, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *pvFrom, <span class="hljs-type">size_t</span> size)</span><br>&#123;<br>assert((pvTo != <span class="hljs-literal">NULL</span>) &amp;&amp; (pvFrom != <span class="hljs-literal">NULL</span>));   <span class="hljs-comment">// 使用断言</span><br><span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><ul><li><p><strong>在函数开始处检验传入参数的合法性</strong></p></li><li><p><strong>每个assert只检验一个条件,因为同时检验多个条件时,如果断言失败,无法直观的判断是哪个条件失败</strong></p></li><li><p><strong>不能使用改变环境的语句,因为assert只在DEBUG个生效,如果这么做,会使用程序在真正运行时遇到问题</strong></p></li><li><p><strong>assert和后面的语句应空一行,以形成逻辑和视觉上的一致感</strong></p></li><li><p><strong>有的地方,assert不能代替条件过滤</strong></p><p>ASSERT只有在Debug版本中才有效，如果编译为Release版本则被忽略掉。</p></li></ul><p><strong>何时需要使用断言</strong></p><ul><li>可以在预计正常情况下程序不会到达的地方放置断言：ASSERT( FALSE );</li><li>断言可以用于检查传递给私有方法的参数。（对于公有方法，因为是提供给外部的接口，所以必须在方法中有相应的参数检验才能保证代码的健壮性）</li><li>使用断言测试方法执行的前置条件和后置条件</li><li>使用断言检查类的不变状态，确保任何情况下，某个变量的状态必须满足。（如age属性应大于0小于某个合适值）</li></ul><p><strong>什么地方不要使用断言</strong></p><p>断言语句不是永远会执行，可以屏蔽也可以启用</p><ul><li>不要使用断言作为公共方法的参数检查，公共方法的参数合法性永远都要执行</li><li>断言语句不可以有任何边界效应，不要使用断言语句去修改变量和改变方法的返回值</li></ul><h1 id="Note-1"><a href="#Note-1" class="headerlink" title="Note"></a>Note</h1><h2 id="sync、fsync、fdatasync、fflush对比"><a href="#sync、fsync、fdatasync、fflush对比" class="headerlink" title="sync、fsync、fdatasync、fflush对比"></a>sync、fsync、fdatasync、fflush对比</h2><blockquote><blockquote><p>  <strong>c库缓冲 —–fflush—–&gt; 内核缓冲 —–fsync—–&gt; 磁盘</strong></p></blockquote><ol><li><p>void sync(void)  函数<strong>只是将所有修改过的块缓冲区排入写队列，然后就返回</strong>，它<strong>并不等待实际写磁盘操作结束</strong>。通常称为update的系统守护进程会周期性地（一般每隔30秒）调用sync函数。这就保证了定期冲洗内核的块缓冲区。命令sync(1)也调用sync函数。</p></li><li><p>int fsync(int fd)  函数是系统提供的系统调用。<strong>只对由文件描述符filedes指定的单一文件起作用，并且等待写磁盘操作结束，然后返回</strong>。fsync可用于数据库这样的应用程序，这种应用程序需要确保将修改过的块立即写到磁盘上。fsync<strong>还会同步更新文件的属性</strong>，即inode部分。</p></li><li><p>int fdatasync(int fd)  函数类似于fsync，但它<strong>只影响文件的数据部分</strong>。它<strong>并不会更新文件的属性</strong>。</p></li><li><p>int fflush(FILE *stream)：标准I&#x2F;O函数（如：fread，fwrite）会在内存建立缓冲，该函数<strong>刷新内存缓冲，将内容写入内核缓冲</strong>，要想将其写入磁盘，还需要调用fsync（先调用fflush后调用fsync，否则不起作用）。fflush接受一个参数<code>FILE *</code>。它还可以刷新标准输入输出。fclose函数在关闭文件之前也会做flush操作</p></li></ol></blockquote><h2 id="关于缓冲"><a href="#关于缓冲" class="headerlink" title="关于缓冲."></a>关于缓冲.</h2><p>C标准库的I&#x2F;O缓冲区有三种类型:全缓冲、行缓冲和无缓冲。当用户程序调用库函数做写操作时, 不同类型的缓冲区具有不同特性。</p><ul><li><p>全缓冲：如果缓冲区写满了就写回内核。<strong>常规文件通常是全缓冲的。</strong></p></li><li><p>行缓冲：如果用户程序写的数据中有换行符就把这一行写回内核,或者如果缓冲区写满了就写回内核。<strong>标准输入和标准输出对应终端设备时通常是行缓冲的。</strong></p></li><li><p>无缓冲：用户程序每次调库函数做写操作都要通过系统调用写回内核。<strong>标准错误输出通常是无缓冲的</strong>，这样用户程序产生的错误信息可以尽快输出到设备。</p></li></ul><blockquote><p>  虽然write系统调用位于C标准库I&#x2F;O缓冲区的底层，被称为Unbuffered I&#x2F;O函数，但在write的底层也可以分配一个内核I&#x2F;O缓冲区，所以write 也不一定是直接写到文件的，也可能写到内核I&#x2F;O缓冲区中。</p><p>  可以使用fsync函数同步至磁盘文件，至于究竟写到了文件中还是内核缓冲区中对于进程来说是没有差别的，如果进程A和进程B打开同一文件，进程A写到内核I&#x2F;O缓冲区中的数据从进程B也能读到，因为内核空间是进程共享的，而c标准库的I&#x2F;O缓冲区则不具有这一特性，因为进程的用户空间是完全独立的。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>speedtest.net 测速</title>
    <link href="/2023/efa34a49/"/>
    <url>/2023/efa34a49/</url>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h2><p>对于以前安装过<code>speedtest-cli</code>版本用户来说，需要先卸载原来的版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install curl<br>curl -s https://packagecloud.io/install/repositories/ookla/speedtest-cli/script.deb.sh | sudo bash<br>sudo apt-get install speedtest<br></code></pre></td></tr></table></figure><h1 id="Service-ID-List"><a href="#Service-ID-List" class="headerlink" title="Service ID List"></a>Service ID List</h1><p><a href="https://williamyaps.github.io/wlmjavascript/servercli.html">Speedtest Server List (williamyaps.github.io)</a></p><blockquote><p>  我们可以在<code>www.speedtest.net</code>可以看到当前所选节点的ID，鼠标停留在当前节点名字上，浏览器会显示这个节点的链接，这个链接最后面的字段<code>id=xxxx</code>就是这个节点的ID。</p></blockquote><p>现在有很多节点已经不能用了，下面的是2023.3.26测试可用的。</p><ul><li>中国电信</li></ul><table><thead><tr><th align="center">节点位置</th><th align="center">服务器id</th></tr></thead><tbody><tr><td align="center">上海</td><td align="center">3633</td></tr><tr><td align="center">广东广州5G</td><td align="center">27594</td></tr><tr><td align="center"></td><td align="center"></td></tr></tbody></table><ul><li>中国联通</li></ul><table><thead><tr><th align="center">节点位置</th><th align="center">服务器id</th></tr></thead><tbody><tr><td align="center">上海</td><td align="center">24447</td></tr><tr><td align="center"></td><td align="center"></td></tr></tbody></table><ul><li>中国移动</li></ul><table><thead><tr><th align="center">节点位置</th><th align="center">服务器id</th></tr></thead><tbody><tr><td align="center">浙江 杭州 5G</td><td align="center">54312</td></tr><tr><td align="center">北京</td><td align="center">25858</td></tr></tbody></table><ul><li>其他</li></ul><table><thead><tr><th>节点位置</th><th>服务器id</th></tr></thead><tbody><tr><td>福州</td><td>56354</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>speedtest</tag>
      
      <tag>tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 应用编程 Zlib Minizip</title>
    <link href="/2023/bb8e62be/"/>
    <url>/2023/bb8e62be/</url>
    
    <content type="html"><![CDATA[<h1 id="linux-下-zlib-的c语言开发"><a href="#linux-下-zlib-的c语言开发" class="headerlink" title="linux 下 zlib 的c语言开发"></a>linux 下 zlib 的c语言开发</h1><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装库 注意其中名称中是 1g 不是 lg   dev是就Development</span> <br>sudo apt install zlib1g-dev<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">编译需要添加 -lz 参数</span><br>gcc ... -lz<br></code></pre></td></tr></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p><a href="https://www.zlib.net/zlib_how.html">zlib Usage Example</a></p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linuxapp</tag>
      
      <tag>zlib</tag>
      
      <tag>minizip</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 应用编程 Curl Libcurl</title>
    <link href="/2023/52593829/"/>
    <url>/2023/52593829/</url>
    
    <content type="html"><![CDATA[<h1 id="linux-下-curl-的c语言开发"><a href="#linux-下-curl-的c语言开发" class="headerlink" title="linux 下 curl 的c语言开发"></a>linux 下 curl 的c语言开发</h1><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="从源码安装"><a href="#从源码安装" class="headerlink" title="从源码安装"></a>从源码安装</h2><p>Curl 的官网下载地址：<a href="http://curl.haxx.se/download/">http://curl.haxx.se/download/</a><br>Curl 的使用例子地址： <a href="https://curl.haxx.se/libcurl/c/example.html">https://curl.haxx.se/libcurl/c/example.html</a></p><p>下载、解压好后…..</p><ul><li><p>配置参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./configure<br></code></pre></td></tr></table></figure></li><li><p>编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make<br></code></pre></td></tr></table></figure></li><li><p>安装到系统</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo make install<br></code></pre></td></tr></table></figure></li><li><p>检查安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">返回版本信息就是安装成功了</span><br>curl --version<br></code></pre></td></tr></table></figure></li></ul><h2 id="从包管理器安装"><a href="#从包管理器安装" class="headerlink" title="从包管理器安装"></a>从包管理器安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">如果出现找不到 curl.h 头文件 就需要安装libcurl</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">成功执行将会在 /user/include/x86_64-linux-gnu/curl 下看到curl.h头文件。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">CentOS:执行以下命令：</span><br>yum install libcurl-dev libcurl-devel<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Ubuntu执行以下命令：</span><br>sudo apt-get install libcurl4-openssl-dev<br></code></pre></td></tr></table></figure><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-lcurl 指定链接库</span><br>gcc ... -l curl<br></code></pre></td></tr></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>&#x2F;&#x2F; TODO</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linuxapp</tag>
      
      <tag>curl</tag>
      
      <tag>libcurl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>License差异对比</title>
    <link href="/2023/79891ac1/"/>
    <url>/2023/79891ac1/</url>
    
    <content type="html"><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://spdx.org/licenses/">SPDX License List</a></p><p>使用 <strong>SPDX 短格式标识符</strong> 以简单、高效、便携和机器可读的方式 传达 FOSS 许可证信息</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> SPDX-License-Identifier: MIT<br><span class="hljs-regexp">/* SPDX-License-Identifier: MIT OR Apache-2.0 */</span><br><span class="hljs-comment"># SPDX-License-Identifier: GPL-2.0-or-later</span><br></code></pre></td></tr></table></figure><h1 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h1><h2 id="什么是“分发”？"><a href="#什么是“分发”？" class="headerlink" title="什么是“分发”？"></a>什么是“分发”？</h2><p>许可证授予的权利，允许你自由使用、修改、复制，但是<strong>在“分发”时就必须遵守许可证的约束</strong>。换言之，如果不”分发”，就不需要遵守。</p><p>分发就是指将版权作品从一个人转移到另一个人。这意味着，如果你是自己使用，不提供给他人，就没有分发。另外，这里的”人”也指”法人”，因此如果使用方是公司，且只在公司内部使用，也不需要遵守许可证[]。</p><p>其中AGPL有个特例：AGPL定义，如果你使用开源软件<strong>提供网络交互服务，那么该行为也定义为“分发”</strong>，即图中的“网络使用即分发”</p><h2 id="什么是“传染性”？"><a href="#什么是“传染性”？" class="headerlink" title="什么是“传染性”？"></a>什么是“传染性”？</h2><p>传染性来源于GPL，GPL的支持者确信自由软件世界应具有自我保护能力和可持续发展性——为了确保自由软件的演绎作品同样“自由”，所以要求只要使用了GPL的代码，那么整个项目都必须以GPL方式公开源代码</p><p>LGPL 在这方面要求就没GPL那么严格，如果只是子系统&#x2F;模块用了，那么只需要子系统&#x2F;模块开源，整个工程不用开源；如果是以动态链接调用LGPL许可证的库，那么项目也不用开源。</p><p>MPL 在这个方面就更宽松，哪个文件用了该许可证的代码，只需要这些文件开源即可，其他文件不受影响</p><p>所以，GPL v2&#x2F;v3、AGPL 属于工程级别的强传染性；LGPL属于库级别的若传染性；MPL 就是文件级别的，传染性可以忽略不计了</p><h2 id="GPL-系列的协议有何区别？"><a href="#GPL-系列的协议有何区别？" class="headerlink" title="GPL 系列的协议有何区别？"></a>GPL 系列的协议有何区别？</h2><p><strong>AGPL 和 GPL 的区别：</strong></p><p>AGPL明确了GPL 2.0&#x2F;3.0关于提供网络服务也属于分发限制的说明：使用GPL的自由软件，但是并不发布与网络之中，则可以自由的使用GPL协议确不开源自己私有的解决方案。AGPL则增加了对此做法的约束。比如使用了AGPL代码的软件是一个网络应用，那么这个软件的所有源码和修改代码也必须开源</p><p><strong>GPL v2 和 GPL v3的主要差异：</strong></p><p>a) GPLv3包含了明确的专利许可</p><p>b) 添加了对数字版权管理和加密签名的限制，不仅要求用户公开源码，还要求公布相关硬件及必要的安装信息。</p><p><strong>GPL 和LGPL的区别：</strong></p><p>主要区别在于传染性方面，GPL是工程级别的强传染，LGPL是库级别的弱传染</p><h2 id="违反开源项目许可有何风险？"><a href="#违反开源项目许可有何风险？" class="headerlink" title="违反开源项目许可有何风险？"></a>违反开源项目许可有何风险？</h2><p>1.被许可人在违反许可证设定的义务时会构成合同违约</p><p>2.开源软件受著作权保护，著作权法著作权法，但是开源许可证本质却是走在了版权保护的对立面，所以其法律效力并没有被明确认可，是否侵权可能需要法院视具体情况而定</p><p>3.在中国，侵权责任和违约责任不能同时主张</p><p>4.在中国，过往的判例都没有涉及开源软件许可证本身</p><p>5.除了面临法律诉讼风险，违反许可证的行为会导致自由软件者和开源社区的排斥，某种程度上会影响违约公司的商业信誉</p><h1 id="差异"><a href="#差异" class="headerlink" title="差异"></a>差异</h1><p><img src="/2023/79891ac1/v2-3a460a2dad345fe0c2e0e79b626aacc9_720w.webp" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>license</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Let&#39;s Encrypt SSL 证书申请</title>
    <link href="/2023/e7fefe87/"/>
    <url>/2023/e7fefe87/</url>
    
    <content type="html"><![CDATA[<h1 id="Let’s-Encrypt-SSL-证书申请"><a href="#Let’s-Encrypt-SSL-证书申请" class="headerlink" title="Let’s Encrypt SSL 证书申请"></a>Let’s Encrypt SSL 证书申请</h1><h1 id="为什么申请？"><a href="#为什么申请？" class="headerlink" title="为什么申请？"></a>为什么申请？</h1><blockquote><h2 id="HTTP：未实施数据加密"><a href="#HTTP：未实施数据加密" class="headerlink" title="HTTP：未实施数据加密"></a>HTTP：未实施数据加密</h2><p>  每个以 HTTP 开头的 URL 链接都使用一种基本类型的“超文本传输协议”。由 Tim Berners-Lee 于 1990 年代初创建，当时互联网仍处于起步阶段，该网络协议标准允许 Web 浏览器和服务器通过数据交换进行通信。</p><p>  HTTP 也被称为“无状态系统”，这意味着它可以按需连接。您单击一个链接，请求连接，您的 Web 浏览器将此请求发送到服务器，服务器通过打开页面进行响应。连接越快，数据呈现给您的速度就越快。</p><p>  作为一种“应用层协议”，HTTP 仍然专注于呈现信息，但不太关心这些信息从一个地方传播到另一个地方的方式。不幸的是，这意味着 HTTP 可能会<a href="https://www.globalsign.com/en/blog/what-is-a-man-in-the-middle-attack">被拦截并可能被更改</a>，从而使信息和信息接收者（即您）都容易受到攻击。</p><h2 id="HTTPS：加密连接"><a href="#HTTPS：加密连接" class="headerlink" title="HTTPS：加密连接"></a>HTTPS：加密连接</h2><p>  HTTPS 不是 HTTP 的对立面，而是它的表弟。两者本质上是相同的，因为它们都指的是相同的“超文本传输协议”，该协议使请求的 Web 数据能够显示在您的屏幕上。但是，HTTPS 仍然略有不同，更先进，也更安全。</p><p>  简单的说，HTTPS协议是HTTP的扩展。缩写中的“S”来自 Secure 一词，它由传输层安全性 (TLS) [<a href="https://www.globalsign.com/en/ssl-information-center/what-is-ssl/">安全套接字层 (SSL)</a>的后继者] 提供支持，这是一种在 Web 服务器和服务器之间建立加密连接的标准安全技术。浏览器。</p><p>  如果没有 HTTPS，您输入网站的任何数据（例如您的用户名&#x2F;密码、信用卡或银行详细信息、任何其他表单提交数据等）都将以明文形式发送，因此容易被拦截或窃听。因此，在输入任何信息之前，您应该始终检查站点是否使用 HTTPS。</p><p>  除了加密服务器和您的浏览器之间传输的数据外，TLS 还验证您正在连接的服务器并保护传输的数据不被篡改。</p><p>  这有助于我这样思考——HTTPS 中的 HTTP 相当于一个目的地，而 SSL 相当于一个旅程。第一个负责将数据显示到屏幕上，第二个负责管理数据到达那里的方式。通过联合力量，他们以安全的方式移动数据。  </p><p>  <a href="https://www.globalsign.com/en/blog/the-difference-between-http-and-https">What’s the difference between HTTP and HTTPS?</a></p></blockquote><p>HTTPS 有助于确保网络安全。毫无疑问，它是比 HTTP 更好的网络协议解决方案。</p><p>将网站开启HTTPS的服务是需要SSL的证书的，我们来看一下如何在Let’s Encrypt上申请免费的SSL证书。</p><blockquote><p>  Let’s Encrypt 是免费、开放和自动化的证书颁发机构。由非盈利组织<a href="https://www.abetterinternet.org/">互联网安全研究小组（ISRG）</a>运营。</p></blockquote><h1 id="申请的前提条件"><a href="#申请的前提条件" class="headerlink" title="申请的前提条件"></a>申请的前提条件</h1><p>我们申请SSL证书的前提条件有下面这几个</p><ol><li>拥有域名，能够自主配置DNS。或者提供Web服务器做验证，在网站目录下放一个文件。</li><li>获取证书的环境要能访问DNS服务器，因为会需要做DNS解析校验。</li><li>需要有远程主机的权限，会需要更新和安装组件。</li><li>公网IP，保留地址无法申请SSL。</li></ol><h1 id="申请步骤"><a href="#申请步骤" class="headerlink" title="申请步骤"></a>申请步骤</h1><p>Let’s Encrypt 的证书申请除去手动申请常见的主要有下面这几种</p><ul><li><code>acme.sh</code>的方式<em>（我当时选取了这个方式）</em></li><li>docker 镜像获取</li><li><code>certbot</code>方式获取证书<em>（官网建议使用这种方式获取证书，可以在不下线的状态下自动执行证书颁发和安装）</em></li></ul><h2 id="acme-sh脚本"><a href="#acme-sh脚本" class="headerlink" title="acme.sh脚本"></a><code>acme.sh</code>脚本</h2><p><a href="https://github.com/acmesh-official/acme.sh">Github链接：An ACME Shell script: acme.sh</a></p><p>Github的README其实介绍的其实很全面，这里copy一下。</p><blockquote><p>  <strong>acme.sh</strong> 实现了 <code>acme</code> 协议, 可以从 letsencrypt 生成免费的证书.</p><p>  主要步骤:</p><ol><li>安装 <strong>acme.sh</strong></li><li>生成证书</li><li>copy 证书到 nginx&#x2F;apache 或者其他服务</li><li>更新证书</li><li>更新 <strong>acme.sh</strong></li><li>出错怎么办, 如何调试</li></ol><p>  下面详细介绍.</p><h1 id="1-安装-acme-sh"><a href="#1-安装-acme-sh" class="headerlink" title="1. 安装 acme.sh"></a>1. 安装 <strong>acme.sh</strong></h1><p>  安装很简单, 一个命令:</p><blockquote><p>  这里输入你的邮箱，这个邮箱有什么用倒是不太清楚</p></blockquote>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl https://get.acme.sh | sh -s email=my@example.com<br></code></pre></td></tr></table></figure><p>  普通用户和 root 用户都可以安装使用. 安装过程进行了以下几步:</p><ol><li>把 acme.sh 安装到你的 <strong>home</strong> 目录下:</li></ol>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">~/.acme.sh/<br></code></pre></td></tr></table></figure><p>  并创建 一个 shell 的 alias, 例如 .bashrc，方便你的使用: <code>alias acme.sh=~/.acme.sh/acme.sh</code></p><ol start="2"><li>自动为你创建 cronjob, 每天 0:00 点自动检测所有的证书, 如果快过期了, 需要更新, 则会自动更新证书.</li></ol><p>  更高级的安装选项请参考: <a href="https://github.com/Neilpang/acme.sh/wiki/How-to-install">https://github.com/Neilpang/acme.sh/wiki/How-to-install</a></p><p>  <strong>安装过程不会污染已有的系统任何功能和文件</strong>, 所有的修改都限制在安装目录中: <code>~/.acme.sh/</code></p><h1 id="2-生成证书"><a href="#2-生成证书" class="headerlink" title="2. 生成证书"></a>2. 生成证书</h1><p>  <strong>acme.sh</strong> 实现了 <strong>acme</strong> 协议支持的所有验证协议. 一般有两种方式验证: http 和 dns 验证.</p><h3 id="1-http-方式需要在你的网站根目录下放置一个文件-来验证你的域名所有权-完成验证-然后就可以生成证书了"><a href="#1-http-方式需要在你的网站根目录下放置一个文件-来验证你的域名所有权-完成验证-然后就可以生成证书了" class="headerlink" title="1. http 方式需要在你的网站根目录下放置一个文件, 来验证你的域名所有权,完成验证. 然后就可以生成证书了."></a>1. http 方式需要在你的网站根目录下放置一个文件, 来验证你的域名所有权,完成验证. 然后就可以生成证书了.</h3>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">acme.sh --issue -d mydomain.com -d www.mydomain.com --webroot /home/wwwroot/mydomain.com/<br></code></pre></td></tr></table></figure><p>  只需要指定域名, 并指定域名所在的网站根目录. <strong>acme.sh</strong> 会全自动的生成验证文件, 并放到网站的根目录, 然后自动完成验证. 最后会聪明的删除验证文件. 整个过程没有任何副作用.</p><p>  如果你用的 <strong>apache</strong>服务器, <strong>acme.sh</strong> 还可以智能的从 <strong>apache</strong>的配置中自动完成验证, 你不需要指定网站根目录:</p>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">acme<span class="hljs-selector-class">.sh</span> <span class="hljs-attr">--issue</span> -d mydomain<span class="hljs-selector-class">.com</span> <span class="hljs-attr">--apache</span><br></code></pre></td></tr></table></figure><p>  如果你用的 <strong>nginx</strong>服务器, 或者反代, <strong>acme.sh</strong> 还可以智能的从 <strong>nginx</strong>的配置中自动完成验证, 你不需要指定网站根目录:</p>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">acme<span class="hljs-selector-class">.sh</span> <span class="hljs-attr">--issue</span> -d mydomain<span class="hljs-selector-class">.com</span> <span class="hljs-attr">--nginx</span><br></code></pre></td></tr></table></figure><p>  <strong>注意, 无论是 apache 还是 nginx 模式, acme.sh在完成验证之后, 会恢复到之前的状态, 都不会私自更改你本身的配置. 好处是你不用担心配置被搞坏, 也有一个缺点, 你需要自己配置 ssl 的配置, 否则只能成功生成证书, 你的网站还是无法访问https. 但是为了安全, 你还是自己手动改配置吧.</strong></p><p>  如果你还没有运行任何 web 服务, <strong>80</strong> 端口是空闲的, 那么 <strong>acme.sh</strong> 还能假装自己是一个webserver, 临时听在<strong>80</strong> 端口, 完成验证:</p>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">acme<span class="hljs-selector-class">.sh</span> <span class="hljs-attr">--issue</span> -d mydomain<span class="hljs-selector-class">.com</span> <span class="hljs-attr">--standalone</span><br></code></pre></td></tr></table></figure><p>  更高级的用法请参考: <a href="https://github.com/Neilpang/acme.sh/wiki/How-to-issue-a-cert">https://github.com/Neilpang/acme.sh/wiki/How-to-issue-a-cert</a></p><h3 id="2-手动-dns-方式-手动在域名上添加一条-txt-解析记录-验证域名所有权"><a href="#2-手动-dns-方式-手动在域名上添加一条-txt-解析记录-验证域名所有权" class="headerlink" title="2. 手动 dns 方式, 手动在域名上添加一条 txt 解析记录, 验证域名所有权."></a>2. 手动 dns 方式, 手动在域名上添加一条 txt 解析记录, 验证域名所有权.</h3><p>  这种方式的好处是, 你不需要任何服务器, 不需要任何公网 ip, 只需要 dns 的解析记录即可完成验证. 坏处是，如果不同时配置 Automatic DNS API，使用这种方式 acme.sh 将无法自动更新证书，每次都需要手动再次重新解析验证域名所有权。</p>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">acme<span class="hljs-selector-class">.sh</span> <span class="hljs-attr">--issue</span> <span class="hljs-attr">--dns</span> -d mydomain<span class="hljs-selector-class">.com</span> \<br> <span class="hljs-attr">--yes-I-know-dns-manual-mode-enough-go-ahead-please</span><br></code></pre></td></tr></table></figure><p>  然后, <strong>acme.sh</strong> 会生成相应的解析记录显示出来, 你只需要在你的域名管理面板中添加这条 txt 记录即可.</p><p>  等待解析完成之后, 重新生成证书:</p>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">acme<span class="hljs-selector-class">.sh</span> <span class="hljs-attr">--renew</span> -d mydomain<span class="hljs-selector-class">.com</span> \<br>  <span class="hljs-attr">--yes-I-know-dns-manual-mode-enough-go-ahead-please</span><br></code></pre></td></tr></table></figure><p>  注意第二次这里用的是 <code>--renew</code></p><p>  dns 方式的真正强大之处在于可以使用域名解析商提供的 api 自动添加 txt 记录完成验证.</p><p>  <strong>acme.sh</strong> 目前支持 cloudflare, dnspod, cloudxns, godaddy 以及 ovh 等数十种解析商的自动集成.</p><p>  以 dnspod 为例, 你需要先登录到 dnspod 账号, 生成你的 api id 和 api key, 都是免费的. 然后:</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">DP_Id</span>=<span class="hljs-string">&quot;1234&quot;</span><br><br><span class="hljs-built_in">export</span> <span class="hljs-attribute">DP_Key</span>=<span class="hljs-string">&quot;sADDsdasdgdsf&quot;</span><br><br>acme.sh --issue --dns dns_dp -d aa.com -d www.aa.com<br></code></pre></td></tr></table></figure><p>  证书就会自动生成了. 这里给出的 api id 和 api key 会被自动记录下来, 将来你在使用 dnspod api 的时候, 就不需要再次指定了. 直接生成就好了:</p>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">acme<span class="hljs-selector-class">.sh</span> <span class="hljs-attr">--issue</span> -d mydomain2<span class="hljs-selector-class">.com</span> <span class="hljs-attr">--dns</span>  dns_dp<br></code></pre></td></tr></table></figure><p>  更详细的 api 用法: <a href="https://github.com/Neilpang/acme.sh/blob/master/dnsapi/README.md">https://github.com/Neilpang/acme.sh/blob/master/dnsapi/README.md</a></p><h3 id="3-其他的激活方式"><a href="#3-其他的激活方式" class="headerlink" title="3. 其他的激活方式"></a>3. 其他的激活方式</h3><p>  <a href="https://github.com/acmesh-official/acme.sh/wiki/How-to-issue-a-cert">https://github.com/acmesh-official/acme.sh/wiki/How-to-issue-a-cert</a></p><h1 id="3-copy-安装-证书"><a href="#3-copy-安装-证书" class="headerlink" title="3. copy&#x2F;安装 证书"></a>3. copy&#x2F;安装 证书</h1><p>  前面证书生成以后, 接下来需要把证书 copy 到真正需要用它的地方.</p><p>  注意, 默认生成的证书都放在安装目录下: <code>~/.acme.sh/</code>, <strong>请不要直接使用此目录下的文件,</strong> 例如: 不要直接让 nginx&#x2F;apache 的配置文件使用这下面的文件. 这里面的文件都是内部使用, 而且目录结构可能会变化.</p><p>  正确的使用方法是使用 <code>--install-cert</code> 命令,并指定目标位置, 然后证书文件会被copy到相应的位置, 例如:</p><h2 id="Apache-example"><a href="#Apache-example" class="headerlink" title="Apache example:"></a>Apache example:</h2>  <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle">acme.sh --install-cert -d example.com \<br>--cert-<span class="hljs-keyword">file</span>      <span class="hljs-regexp">/path/</span>to<span class="hljs-regexp">/certfile/i</span>n<span class="hljs-regexp">/apache/</span>cert.pem  \<br>--key-<span class="hljs-keyword">file</span>       <span class="hljs-regexp">/path/</span>to<span class="hljs-regexp">/keyfile/i</span>n<span class="hljs-regexp">/apache/</span>key.pem  \<br>--fullchain-<span class="hljs-keyword">file</span> <span class="hljs-regexp">/path/</span>to<span class="hljs-regexp">/fullchain/</span>certfile<span class="hljs-regexp">/apache/</span>fullchain.pem \<br>--reloadcmd     <span class="hljs-string">&quot;service apache2 force-reload&quot;</span><br></code></pre></td></tr></table></figure><h2 id="Nginx-example"><a href="#Nginx-example" class="headerlink" title="Nginx example:"></a>Nginx example:</h2>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">acme<span class="hljs-selector-class">.sh</span> <span class="hljs-attr">--install-cert</span> -d example<span class="hljs-selector-class">.com</span> \<br><span class="hljs-attr">--key-file</span>       /path/to/keyfile/<span class="hljs-keyword">in</span>/nginx/key<span class="hljs-selector-class">.pem</span>  \<br><span class="hljs-attr">--fullchain-file</span> /path/to/fullchain/nginx/cert<span class="hljs-selector-class">.pem</span> \<br><span class="hljs-attr">--reloadcmd</span>     <span class="hljs-string">&quot;service nginx force-reload&quot;</span><br></code></pre></td></tr></table></figure><p>  (一个小提醒, 这里用的是 <code>service nginx force-reload</code>, 不是 <code>service nginx reload</code>, 据测试, <code>reload</code> 并不会重新加载证书, 所以用的 <code>force-reload</code>)</p><blockquote><p>  我当时使用这个命令的时候发现用 <code>service nginx force-reload</code>  报没有权限，然后是将当前用户</p></blockquote><p>  Nginx 的配置 <code>ssl_certificate</code> 使用 <code>/etc/nginx/ssl/fullchain.cer</code> ，而非 <code>/etc/nginx/ssl/&lt;domain&gt;.cer</code> ，否则 <a href="https://www.ssllabs.com/ssltest/">SSL Labs</a> 的测试会报 <code>Chain issues Incomplete</code> 错误。</p><p>  <code>--install-cert</code>命令可以携带很多参数, 来指定目标文件. 并且可以指定 reloadcmd, 当证书更新以后, reloadcmd会被自动调用,让服务器生效.</p><p>  详细参数请参考: <a href="https://github.com/Neilpang/acme.sh#3-install-the-issued-cert-to-apachenginx-etc">https://github.com/Neilpang/acme.sh#3-install-the-issued-cert-to-apachenginx-etc</a></p><p>  值得注意的是, 这里指定的所有参数都会被自动记录下来, 并在将来证书自动更新以后, 被再次自动调用.</p><h1 id="4-查看已安装证书信息"><a href="#4-查看已安装证书信息" class="headerlink" title="4. 查看已安装证书信息"></a>4. 查看已安装证书信息</h1>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs routeros">acme.sh --<span class="hljs-built_in">info</span> -d example.com<br><span class="hljs-comment"># 会输出如下内容：</span><br><span class="hljs-attribute">DOMAIN_CONF</span>=/root/.acme.sh/example.com/example.com.conf<br><span class="hljs-attribute">Le_Domain</span>=example.com<br><span class="hljs-attribute">Le_Alt</span>=<span class="hljs-literal">no</span><br><span class="hljs-attribute">Le_Webroot</span>=dns_ali<br>Le_PreHook=<br>Le_PostHook=<br>Le_RenewHook=<br><span class="hljs-attribute">Le_API</span>=https://acme-v02.api.letsencrypt.org/directory<br>Le_Keylength=<br><span class="hljs-attribute">Le_OrderFinalize</span>=https://acme-v02.api.letsencrypt.org/acme/finalize/23xxxx150/781xxxx4310<br><span class="hljs-attribute">Le_LinkOrder</span>=https://acme-v02.api.letsencrypt.org/acme/order/233xxx150/781xxxx4310<br><span class="hljs-attribute">Le_LinkCert</span>=https://acme-v02.api.letsencrypt.org/acme/cert/04cbd28xxxxxx349ecaea8d07<br><span class="hljs-attribute">Le_CertCreateTime</span>=1649358725<br><span class="hljs-attribute">Le_CertCreateTimeStr</span>=Thu Apr  7 19:12:05 UTC 2022<br><span class="hljs-attribute">Le_NextRenewTimeStr</span>=Mon Jun  6 19:12:05 UTC 2022<br><span class="hljs-attribute">Le_NextRenewTime</span>=1654456325<br>Le_RealCertPath=<br>Le_RealCACertPath=<br><span class="hljs-attribute">Le_RealKeyPath</span>=/etc/acme/example.com/privkey.pem<br><span class="hljs-attribute">Le_ReloadCmd</span>=service nginx force-reload<br><span class="hljs-attribute">Le_RealFullChainPath</span>=/etc/acme/example.com/chain.pem<br></code></pre></td></tr></table></figure><h1 id="5-更新证书"><a href="#5-更新证书" class="headerlink" title="5. 更新证书"></a>5. 更新证书</h1><p>  目前证书在 60 天以后会自动更新, 你无需任何操作. 今后有可能会缩短这个时间, 不过都是自动的, 你不用关心.</p><p>  请确保 cronjob 正确安装, 看起来是类似这样的:</p>  <figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">crontab  -l<br><br>56 * * * * <span class="hljs-string">&quot;/root/.acme.sh&quot;</span><span class="hljs-string">/acme.sh</span> <span class="hljs-params">--cron</span> <span class="hljs-params">--home</span> <span class="hljs-string">&quot;/root/.acme.sh&quot;</span> &gt; <span class="hljs-string">/dev/null</span><br></code></pre></td></tr></table></figure><h1 id="6-关于修改ReloadCmd"><a href="#6-关于修改ReloadCmd" class="headerlink" title="6. 关于修改ReloadCmd"></a>6. 关于修改ReloadCmd</h1><p>  目前修改<code>ReloadCmd</code>没有专门的命令，可以通过重新安装证书来实现修改<code>reloadCmd</code>的目的。 此外，安装证书后，相关信息是保存在<code>~/.acme.sh/example.com/example.conf</code>文件下的，内容就是<code>acme.sh --info -d example.com</code>输出的信息，不过<code>ReloadCmd</code>在文件中使用了Base64编码。理论上可以通过直接修改该文件来修改<code>ReloadCmd</code>，且修改时，无需Base64编码，直接写命令原文<code>acme.sh</code>也可以识别。 不过，<code>example.conf</code>文件的位置和内容格式以后可能会改变！<code>example.conf</code>一直都是内部使用, 后面有可能会改为用 sqlite 或者mysql 格式存储. 所以一般不建议自己修改。</p><h1 id="7-更新-acme-sh"><a href="#7-更新-acme-sh" class="headerlink" title="7. 更新 acme.sh"></a>7. 更新 acme.sh</h1><p>  目前由于 acme 协议和 letsencrypt CA 都在频繁的更新, 因此 acme.sh 也经常更新以保持同步.</p><p>  升级 acme.sh 到最新版 :</p>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">acme<span class="hljs-selector-class">.sh</span> <span class="hljs-attr">--upgrade</span><br></code></pre></td></tr></table></figure><p>  如果你不想手动升级, 可以开启自动升级:</p>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">acme<span class="hljs-selector-class">.sh</span> <span class="hljs-attr">--upgrade</span> <span class="hljs-attr">--auto-upgrade</span><br></code></pre></td></tr></table></figure><p>  之后, acme.sh 就会自动保持更新了.</p><p>  你也可以随时关闭自动更新:</p>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">acme<span class="hljs-selector-class">.sh</span> <span class="hljs-attr">--upgrade</span> <span class="hljs-attr">--auto-upgrade</span>  <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h1 id="8-出错怎么办："><a href="#8-出错怎么办：" class="headerlink" title="8. 出错怎么办："></a>8. 出错怎么办：</h1><p>  如果出错, 请添加 debug log：</p>  <figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">acme.sh <span class="hljs-params">--issue</span>  <span class="hljs-string">.....</span>  <span class="hljs-params">--debug</span> <br></code></pre></td></tr></table></figure><p>  或者：</p>  <figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">acme.sh <span class="hljs-params">--issue</span>  <span class="hljs-string">.....</span>  <span class="hljs-params">--debug</span>  2<br></code></pre></td></tr></table></figure><p>  请参考： <a href="https://github.com/Neilpang/acme.sh/wiki/How-to-debug-acme.sh">https://github.com/Neilpang/acme.sh/wiki/How-to-debug-acme.sh</a></p><p>  最后, 本文并非完全的使用说明, 还有很多高级的功能, 更高级的用法请参看其他 wiki 页面.</p><p>  <a href="https://github.com/Neilpang/acme.sh/wiki">https://github.com/Neilpang/acme.sh/wiki</a></p></blockquote><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run --rm  -itd  \<br>  -v &quot;$(pwd)/out&quot;:/acme.sh  \<br>  -e Ali_Key=&quot;xxxxxx&quot; \<br>  -e Ali_Secret=&quot;xxxx&quot; \<br>  neilpang/acme.sh  --issue --dns dns_ali -d domain.cn -d *.domain.cn<br></code></pre></td></tr></table></figure><p>详细用法，可以参考：<a href="https://github.com/Neilpang/acme.sh/wiki/Run-acme.sh-in-docker">传送门</a></p><blockquote><h1 id="acme-sh-💕-docker"><a href="#acme-sh-💕-docker" class="headerlink" title="acme.sh 💕 docker"></a>acme.sh 💕 docker</h1><p>  作为 docker 的忠实粉丝之一，我知道我们讨厌在 docker 主机上安装任何东西，即使它只是复制一个 shell 脚本。</p><p>  用于 letsencrypt ssl 证书的带有 acme.sh 的自动化 nginx 反向代理 docker 图像： https: <a href="https://github.com/Neilpang/letsproxy">&#x2F;&#x2F;github.com&#x2F;Neilpang&#x2F;letsproxy</a></p><p>  部署到 docker 容器并重新加载它：<a href="https://github.com/Neilpang/acme.sh/wiki/deploy-to-docker-containers">https :&#x2F;&#x2F;github.com&#x2F;Neilpang&#x2F;acme.sh&#x2F;wiki&#x2F;deploy-to-docker-containers</a></p><p>  所以，这里出现了“docker 中的 acme.sh”。</p><ol><li>基于<strong>alpine</strong>，只有 5MB 大小。</li><li>作为可执行文件运行或作为守护进程运行</li><li>支持所有命令行参数。</li></ol><h1 id="1-说“Hello-World”"><a href="#1-说“Hello-World”" class="headerlink" title="1.说“Hello World”"></a>1.说“Hello World”</h1>  <figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">docker <span class="hljs-keyword">run</span><span class="language-bash"> --<span class="hljs-built_in">rm</span> neilpang/acme.sh</span><br></code></pre></td></tr></table></figure><h1 id="2-用作可执行文件："><a href="#2-用作可执行文件：" class="headerlink" title="2.用作可执行文件："></a>2.用作可执行文件：</h1>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">docker run <span class="hljs-attr">--rm</span>  -it  \<br>  -v <span class="hljs-string">&quot;$(pwd)/out&quot;</span>:/acme<span class="hljs-selector-class">.sh</span>  \<br>  <span class="hljs-attr">--net</span>=host \<br>  neilpang/acme<span class="hljs-selector-class">.sh</span>  <span class="hljs-attr">--issue</span> -d example<span class="hljs-selector-class">.com</span>  <span class="hljs-attr">--standalone</span><br></code></pre></td></tr></table></figure><p>  您可以在此处使用<strong>acme.sh</strong>支持的<strong>任何命令</strong>，其他示例：</p>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-id">#revoke</span> <span class="hljs-selector-tag">a</span> cert<br>docker run <span class="hljs-attr">--rm</span>  -it  \<br>  -v <span class="hljs-string">&quot;$(pwd)/out&quot;</span>:/acme<span class="hljs-selector-class">.sh</span>  \<br>  <span class="hljs-attr">--net</span>=host \<br>  neilpang/acme<span class="hljs-selector-class">.sh</span>  <span class="hljs-attr">--revoke</span> -d example<span class="hljs-selector-class">.com</span><br><span class="hljs-selector-id">#use</span> dns mode<br>docker run <span class="hljs-attr">--rm</span>  -it  \<br>  -v <span class="hljs-string">&quot;$(pwd)/out&quot;</span>:/acme<span class="hljs-selector-class">.sh</span>  \<br>  neilpang/acme<span class="hljs-selector-class">.sh</span>  <span class="hljs-attr">--issue</span> <span class="hljs-attr">--dns</span> -d example<span class="hljs-selector-class">.com</span><br><span class="hljs-selector-id">#run</span> cron job<br>docker run <span class="hljs-attr">--rm</span>  -it  \<br>  -v <span class="hljs-string">&quot;$(pwd)/out&quot;</span>:/acme<span class="hljs-selector-class">.sh</span>  \<br>  <span class="hljs-attr">--net</span>=host \<br>  neilpang/acme<span class="hljs-selector-class">.sh</span>  <span class="hljs-attr">--cron</span><br></code></pre></td></tr></table></figure><p>  无论如何，您可以像调用真正的 shell 脚本一样调用<strong>neilpang&#x2F;acme.sh。</strong></p><h1 id="3-将-acme-sh-作为-docker-守护进程运行。"><a href="#3-将-acme-sh-作为-docker-守护进程运行。" class="headerlink" title="3. 将 acme.sh 作为 docker 守护进程运行。"></a>3. 将 acme.sh 作为 docker 守护进程运行。</h1><ol><li>将 acme.sh 作为 docker 守护进程运行，以便它可以自动处理更新 cronjob。</li></ol>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker <span class="hljs-built_in">run</span> --rm  -itd  \<br>  -v <span class="hljs-string">&quot;<span class="hljs-variable">$(pwd)</span>/out&quot;</span>:/acme.sh  \<br>  <span class="hljs-attribute">--net</span>=host \<br>  <span class="hljs-attribute">--name</span>=acme.sh \<br>  neilpang/acme.sh daemon<br></code></pre></td></tr></table></figure><ol start="2"><li>然后你就可以使用<code>docker exec</code>来执行任何acme.sh 命令了。</li></ol>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">docker  exec  acme<span class="hljs-selector-class">.sh</span> <span class="hljs-attr">--help</span><br>docker  exec  acme<span class="hljs-selector-class">.sh</span> <span class="hljs-attr">--issue</span> -d example<span class="hljs-selector-class">.com</span>  <span class="hljs-attr">--standalone</span><br></code></pre></td></tr></table></figure><p>  是的，再次强调，您可以在此处使用<strong>acme.sh</strong>支持的<strong>任何命令</strong>。</p></blockquote><h2 id="Certbot"><a href="#Certbot" class="headerlink" title="Certbot"></a>Certbot</h2><p><a href="https://certbot.eff.org/">https://certbot.eff.org/</a></p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ssl</tag>
      
      <tag>https</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PowerShell</title>
    <link href="/2022/a2c49dae/"/>
    <url>/2022/a2c49dae/</url>
    
    <content type="html"><![CDATA[<h1 id="PowerShell"><a href="#PowerShell" class="headerlink" title="PowerShell"></a>PowerShell</h1><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><h2 id="PowerShell-Oh-My-Posh-美化"><a href="#PowerShell-Oh-My-Posh-美化" class="headerlink" title="PowerShell + Oh My Posh 美化"></a>PowerShell + Oh My Posh 美化</h2><p><a href="https://www.edgeless.top/PowerShell%E7%BE%8E%E5%8C%96/">参考 PowerShell美化</a></p><h2 id="PowerShell-获取当前文件夹名称-仅获取当前文件夹名"><a href="#PowerShell-获取当前文件夹名称-仅获取当前文件夹名" class="headerlink" title="PowerShell 获取当前文件夹名称 仅获取当前文件夹名"></a>PowerShell 获取当前文件夹名称 仅获取当前文件夹名</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">(<span class="hljs-built_in">get-item</span> .).name<br></code></pre></td></tr></table></figure><h2 id="Powershell获取当前时间"><a href="#Powershell获取当前时间" class="headerlink" title="Powershell获取当前时间"></a>Powershell获取当前时间</h2><p><a href="http://www.splaybow.com/post/powershell-get-date.html">参考 PowerShell使用Get-Date获取日期和时间</a></p><p>在PowerShell中直接调用<code>Get-Date</code>，可以返回当前的日期和时间，包括年、月、日、时、分、秒。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">PS</span> &gt; <span class="hljs-built_in">Get-Date</span><br><span class="hljs-number">2022</span>年<span class="hljs-number">12</span>月<span class="hljs-number">19</span>日 <span class="hljs-number">21</span>:<span class="hljs-number">32</span>:<span class="hljs-number">28</span><br></code></pre></td></tr></table></figure><p>使用<code>-Format</code>参数来获取<code>Get-Date</code>中的年、月、日、时、分、秒。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs txt">yyyy 年<br>M    月<br>d    日<br>h    小时（12小时制）<br>H    小时（24小时制）<br>m    分钟<br>s    秒<br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">PS</span> &gt; <span class="hljs-built_in">Get-Date</span> <span class="hljs-literal">-Format</span> HH:mm:ss<br><span class="hljs-number">21</span>:<span class="hljs-number">34</span>:<span class="hljs-number">11</span><br></code></pre></td></tr></table></figure><h2 id="Powershell-ANSI颜色"><a href="#Powershell-ANSI颜色" class="headerlink" title="Powershell ANSI颜色"></a>Powershell ANSI颜色</h2><p>参考:<br><a href="https://juejin.cn/post/6920241597846126599">了解 ANSI 转义码的 color 设置</a><br><a href="https://zhuanlan.zhihu.com/p/570148970">ANSI转义代码</a></p><blockquote><p>  To use one of the ANSI escape codes, we need a literal <a href="https://en.wikipedia.org/wiki/Escape_character#ASCII_escape_character">ESC character</a>. This is octal 033, or decimal 27. In Bash, you would use <code>&quot;\033&quot;</code> or <code>&quot;\e&quot;</code>; There’s no direct equivalent sequence in PowerShell but you can instead embed an expression: <code>&quot;$([char]27)&quot;</code></p><p>  PowerShell 中没有直接等效的序列，但您可以改为嵌入一个表达式：<code>&quot;$([char]27)&quot;</code>，也就是说要将<code>\e</code>修改为<code>$([char]27)</code></p><p>  例如<code>\e[32;1m text \e[0m</code> 修改为 <code>$([char]27)[32;1m text $([char]27)[0m</code></p></blockquote><p><strong>ANSI Escape code编码中有专门控制字符颜色的控制符，</strong>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">\e[37;44;3;1m<br></code></pre></td></tr></table></figure><ul><li><code>\e</code> 代表开始ANSI Escape code</li><li><code>[</code> 代表转义序列开始符 CSI，Control Sequence Introducer</li><li><code>37;44;4;1</code> 代表以<code>; </code>分隔的文本样式控制符，其中 37 代表文本前景色为白色，44代表背景为蓝色，3代表斜体，1代表加粗，<code>;</code>的数量不做限制</li><li><code>m</code> 代表结束控制符序列</li></ul><h4 id="常用文本样式控制符"><a href="#常用文本样式控制符" class="headerlink" title="常用文本样式控制符"></a>常用文本样式控制符</h4><table><thead><tr><th>代码</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td>0</td><td>重置&#x2F;正常</td><td>关闭所有属性。</td></tr><tr><td>1</td><td>粗体或增加强度</td><td></td></tr><tr><td>2</td><td>弱化（降低强度）</td><td>未广泛支持。</td></tr><tr><td>3</td><td>斜体</td><td>未广泛支持。有时视为反相显示。</td></tr><tr><td>4</td><td>下划线</td><td></td></tr><tr><td>5</td><td>缓慢闪烁</td><td>低于每分钟150次。</td></tr><tr><td>6</td><td>快速闪烁</td><td>MS-DOS ANSI.SYS；每分钟150以上；未广泛支持。</td></tr><tr><td>7</td><td>反显</td><td>前景色与背景色交换。</td></tr><tr><td>8</td><td>隐藏</td><td>未广泛支持。</td></tr><tr><td>9</td><td>划除</td><td>字符清晰，但标记为删除。未广泛支持。</td></tr><tr><td>10</td><td>主要（默认）字体</td><td></td></tr><tr><td>11–19</td><td>替代字体</td><td>选择替代字体</td></tr><tr><td>20</td><td>尖角体</td><td>几乎无支持。</td></tr><tr><td>21</td><td>关闭粗体或双下划线</td><td>关闭粗体未广泛支持；双下划线几乎无支持。</td></tr><tr><td>22</td><td>正常颜色或强度</td><td>不强不弱。</td></tr><tr><td>23</td><td>非斜体、非尖角体</td><td></td></tr><tr><td>24</td><td>关闭下划线</td><td>去掉单双下划线。</td></tr><tr><td>25</td><td>关闭闪烁</td><td></td></tr><tr><td>27</td><td>关闭反显</td><td></td></tr><tr><td>28</td><td>关闭隐藏</td><td></td></tr><tr><td>29</td><td>关闭划除</td><td></td></tr><tr><td>30–37</td><td>设置前景色</td><td>参见下面的颜色表。</td></tr><tr><td>38</td><td>设置前景色</td><td>下一个参数是5;n或2;r;g;b，见下。</td></tr><tr><td>39</td><td>默认前景色</td><td>由具体实现定义（按照标准）。</td></tr><tr><td>40–47</td><td>设置背景色</td><td>参见下面的颜色表。</td></tr><tr><td>48</td><td>设置背景色</td><td>下一个参数是5;n或2;r;g;b，见下。</td></tr><tr><td>49</td><td>默认背景色</td><td>由具体实现定义（按照标准）。</td></tr><tr><td>51</td><td>Framed</td><td></td></tr><tr><td>52</td><td>Encircled</td><td></td></tr><tr><td>53</td><td>上划线</td><td></td></tr><tr><td>54</td><td>Not framed or encircled</td><td></td></tr><tr><td>55</td><td>关闭上划线</td><td></td></tr><tr><td>60</td><td>表意文字下划线或右边线</td><td>几乎无支持。</td></tr><tr><td>61</td><td>表意文字双下划线或双右边线</td><td></td></tr><tr><td>62</td><td>表意文字上划线或左边线</td><td></td></tr><tr><td>63</td><td>表意文字双上划线或双左边线</td><td></td></tr><tr><td>64</td><td>表意文字着重标志</td><td></td></tr><tr><td>65</td><td>表意文字属性关闭</td><td>重置60–64的所有效果。</td></tr><tr><td>90–97</td><td>设置明亮的前景色</td><td>aixterm（非标准）。</td></tr><tr><td>100–107</td><td>设置明亮的背景色</td><td>aixterm（非标准）。</td></tr></tbody></table><p>颜色对照表</p><p><img src="/PowerShell.assets/e9436bb4998a4fbf9bd5abbe74121ccdtplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp" alt="3bit-color"></p><h2 id="Powershell-修改提示符的文字内容和颜色"><a href="#Powershell-修改提示符的文字内容和颜色" class="headerlink" title="Powershell 修改提示符的文字内容和颜色"></a>Powershell 修改提示符的文字内容和颜色</h2><p><a href="https://www.lfhacks.com/tech/powershell-prompt-customization/">参考: Powershell 修改提示符的文字内容和颜色</a></p><p><a href="https://blog.vvzero.com/2019/07/22/set-user-alias-for-windows-PowerShell/">参考: 为 Windows PowerShell 设置 User Alias （命令别名）</a></p><ol><li><p>首先我们先找到Powershell的配置文件的路径, 我们输入命令<code>echo $profile</code>就能显示.</p></li><li><p>如果这个文件不存在, 我们输入命令<code>notepad $Profile</code>或者<code>code $Profile</code>去新建一个文件.</p></li><li><p>Powershell 有一个特殊的函数： <code>prompt</code> 函数，这个函数规定了提示符的内容和外观。</p><p>我们可以利用下面的命令可以查看当前使用的 <code>prompt</code> 函数的内容：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">(<span class="hljs-built_in">Get-Command</span> Prompt).ScriptBlock<br></code></pre></td></tr></table></figure></li><li><p>通过 <code>prompt</code> 函数的返回值我们就能自定义提示符。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">prompt</span></span> &#123;<br>  <span class="hljs-string">&quot;<span class="hljs-variable">$</span>([char]27)[32m&quot;</span> + <span class="hljs-variable">$</span>(<span class="hljs-built_in">Get-Date</span> <span class="hljs-literal">-Format</span> HH:mm:ss) + <span class="hljs-string">&quot;<span class="hljs-variable">$</span>([char]27)[0m&quot;</span> +<br>  <span class="hljs-string">&quot;<span class="hljs-variable">$</span>([char]27)[95m&quot;</span> + <span class="hljs-variable">$</span>((<span class="hljs-built_in">get-item</span> .).name) + <span class="hljs-string">&quot;<span class="hljs-variable">$</span>([char]27)[0m&quot;</span> +<br>  <span class="hljs-string">&quot;<span class="hljs-variable">$</span>([char]27)[33m&gt;<span class="hljs-variable">$</span>([char]27)[0m&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>  第一行 <code>Get-Date</code>获取当前系统的时间, <code>-Format</code>格式化使用<code>HH:mm:ss</code>的格式, 前后使用了ANSI颜色转义将前景色设置为深绿色</p><p>  第二行 <code>(get-item .).name</code>获取了当前文件夹的名称, 并设置前景色为深紫色</p><p>  第三行 输出一个深黄色的<code>&gt;</code>符号</p></blockquote></li><li><p>输入 <code>. $Profile</code> 命令生效。(注意这里是大小写不敏感的)</p></li></ol><h2 id="Powershell-起别名-User-Alias-命令别名"><a href="#Powershell-起别名-User-Alias-命令别名" class="headerlink" title="Powershell 起别名(User Alias) 命令别名"></a>Powershell 起别名(User Alias) 命令别名</h2><p><a href="https://blog.vvzero.com/2019/07/22/set-user-alias-for-windows-PowerShell/">参考 为 Windows PowerShell 设置 User Alias （命令别名）</a></p><blockquote><p>  我们的思路就是将命令设置成为一个<code>function</code>, 运行这个<code>function</code>执行特定的指令即可.</p></blockquote><p>两个思路:</p><ol><li><p>使用<code>New-Alias</code>指令, 添加到Powershell的<code>$Profile</code>文件里面, 每次启动运行一次. 这个命令里面不能含有空格.</p><p><a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/new-alias?view=powershell-7.3">参考 Microsoft的Powershell文档</a></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 此命令创建一个名为 List 的别名来表示 Get-ChildItem cmdlet。</span><br><span class="hljs-built_in">New-Alias</span> <span class="hljs-literal">-Name</span> <span class="hljs-string">&quot;List&quot;</span> <span class="hljs-built_in">Get-ChildItem</span><br><span class="hljs-comment"># 为notepad++ 设置别名 np</span><br><span class="hljs-built_in">New-Alias</span> <span class="hljs-literal">-Name</span> <span class="hljs-string">&quot;np&quot;</span> notepad++.exe<br></code></pre></td></tr></table></figure></li><li><p>使用<code>function</code>指令, 添加到Powershell的<code>$Profile</code>文件里面, 把指令当作<code>function</code>的名称来调用, 这样命令可以带有空格.</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 带参数的function</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">np</span>+</span> &#123;<br>    <span class="hljs-keyword">param</span> (<br>        <span class="hljs-variable">$ComputerName</span><br>    )<br>    notepad++.exe <span class="hljs-variable">$ComputerName</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ps</tag>
      
      <tag>powershell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zsh 安装 配置</title>
    <link href="/2022/d911b12b/"/>
    <url>/2022/d911b12b/</url>
    
    <content type="html"><![CDATA[<h1 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h1><p><strong>Zsh</strong>是一个为交互使用而设计的shell，它也是一种强大的脚本语言。<em>bash</em>、ksh 和 <em>tcsh</em> 的许多有用特性都被合并到 <em>zsh</em> 中; 添加了许多原始功能。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Ubuntu</span> <br>sudo apt-get install zsh<br></code></pre></td></tr></table></figure><blockquote><p>  zsh非常强大，同时它的配置也是较为繁杂，所以我们使用“oh my zsh”这个框架来简化我们的配置流程。</p></blockquote><p><code>cat /etc/shells</code> 查看当前系统有哪些shell版本<br><code>echo $SHELL</code> 查看当前使用的shell版本</p><p>安装完成后会在<code>~</code>目录下产生一个<code>.zshrc</code>这个跟<code>.bashrc</code>是一样的文件，只是配置的对象不一样。<code>rc</code>就是启动的意思，启动zsh读取的配置就是这个文件。</p><h1 id="Oh-My-Zsh"><a href="#Oh-My-Zsh" class="headerlink" title="Oh My Zsh"></a>Oh My Zsh</h1><p><a href="https://ohmyz.sh/">官网</a></p><p>Oh My Zsh 是一个令人愉快的、开源的、社区驱动的框架，用于管理你的 Zsh 配置。它捆绑了数千个有用的功能、助手、插件、主题和一些东西 让你大喊大叫… “Oh My ZSH!”</p><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sh -c &quot;$(wget https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)&quot;<br></code></pre></td></tr></table></figure><p>安装完成后发现<code>~</code>目录下会有一个<code>.oh-my-zsh</code>文件夹，文件夹内的一些文件主要用处</p><ul><li><code>themes</code> 一些主题文件</li><li><code>plugins</code> 插件，我们的插件就下载放在这个文件夹里面</li></ul><p>Powerlevel10k 是用于 Zsh 美化的一个非常酷的主题，它强调速度、 灵活性和开箱即用的体验。</p><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="zsh-syntax-highlighting-语法高亮"><a href="#zsh-syntax-highlighting-语法高亮" class="headerlink" title="zsh-syntax-highlighting 语法高亮"></a>zsh-syntax-highlighting 语法高亮</h3><p>插件功能：这个包为<code>shell zsh</code>提供语法突出显示。它允许高亮显示在<code>zsh</code>提示符下输入到交互式终端的命令。这有助于在运行命令之前检查它们，特别是在捕获语法错误方面。<br>例：在你输入某个命令时，如果该命令不存在，那么它显示为红色；否则，它会变成绿色。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting<br></code></pre></td></tr></table></figure><p>将 <code>zsh-syntax-highlighting</code> 添加到 <code>~/.zshrc</code> 中</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">plugins=(--other-- zsh-syntax-highlighting)<br></code></pre></td></tr></table></figure><h3 id="zsh-autosuggestions-自动补全"><a href="#zsh-autosuggestions-自动补全" class="headerlink" title="zsh-autosuggestions 自动补全"></a>zsh-autosuggestions 自动补全</h3><p>插件功能：输入命令时可提示自动补全（灰色部分），按tab键（→ ）即可补全。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/zsh-users/zsh-autosuggestions.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions<br></code></pre></td></tr></table></figure><p>将 <code>zsh-autosuggestions</code> 添加到 <code>~/.zshrc</code> 中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">plugins=(--other-- zsh-autosuggestions)<br><span class="hljs-meta prompt_"># </span><span class="language-bash">空格分隔不同的插件</span><br></code></pre></td></tr></table></figure><h1 id="Powerlevel10k"><a href="#Powerlevel10k" class="headerlink" title="Powerlevel10k"></a>Powerlevel10k</h1><p><a href="https://github.com/romkatv/powerlevel10k">https://github.com/romkatv/powerlevel10k</a></p><h2 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h2><h3 id="安装字体"><a href="#安装字体" class="headerlink" title="安装字体"></a>安装字体</h3><blockquote><p>  powerlevel10k里面使用了很多的图标，而这些图标只有一些特定的字体才能显示，所以我们需要安装这些字体这样才能正常显示，我们称这些有很多图标的字体为<code>Nerd Fonts</code>。</p></blockquote><p>首先我们需要先安装一下字体，我们先下载官方推荐的<code>MesloLGS NF</code>字体来配置。</p><ul><li>Download these four ttf files:<ul><li>[MesloLGS NF Regular.ttf](<a href="https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS">https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS</a> NF Regular.ttf)</li><li>[MesloLGS NF Bold.ttf](<a href="https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS">https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS</a> NF Bold.ttf)</li><li>[MesloLGS NF Italic.ttf](<a href="https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS">https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS</a> NF Italic.ttf)</li><li>[MesloLGS NF Bold Italic.ttf](<a href="https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS">https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS</a> NF Bold Italic.ttf)</li></ul></li><li>Double-click on each file and click “Install”. This will make <code>MesloLGS NF</code> font available to all applications on your system.</li></ul><blockquote><p>  我们如果是在ssh配置远程主机的时候，是在本地的主机上安装这个字体。</p><p>  字体影响的是显示，ssh显示是在本地渲染的，所以肯定是在本地主机上安装字体。</p></blockquote><h4 id="其他的Nerd-Fonts字体"><a href="#其他的Nerd-Fonts字体" class="headerlink" title="其他的Nerd Fonts字体"></a>其他的<code>Nerd Fonts</code>字体</h4><p><a href="https://github.com/ryanoasis/nerd-fonts">https://github.com/ryanoasis/nerd-fonts</a></p><p>我们可以在这里下载一些打过补丁的热门字体。</p><h3 id="安装Powerlevel10k"><a href="#安装Powerlevel10k" class="headerlink" title="安装Powerlevel10k"></a>安装Powerlevel10k</h3><p>官方的README文档提出了几种安装方式，它推荐使用手动安装方式。</p><h4 id="Manual"><a href="#Manual" class="headerlink" title="Manual"></a>Manual</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ~/powerlevel10k<br>echo &#x27;source ~/powerlevel10k/powerlevel10k.zsh-theme&#x27; &gt;&gt;~/.zshrc<br></code></pre></td></tr></table></figure><h4 id="Oh-My-Zsh-1"><a href="#Oh-My-Zsh-1" class="headerlink" title="Oh My Zsh"></a>Oh My Zsh</h4><ol><li><p>Clone the repository:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone --depth=1 https://github.com/romkatv/powerlevel10k.git $&#123;ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom&#125;/themes/powerlevel10k<br></code></pre></td></tr></table></figure></li><li><p>在<code>~/.zshrc</code>文件中，设置<code>ZSH_THEME=&quot;powerlevel10k/powerlevel10k&quot;</code></p></li></ol><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>安装好后我们启动zsh，在zsh环境下输入<code>p10k configure</code>用于配置p10k</p><blockquote><p>  这一步我在<code>MobaXterm</code>下进行，发现可配置的选项缺失很多，后面在<code>Windows Terminal</code>重新配置发现显示是正常的。</p><p>  <code>MobaXterm</code>下<code>Fira Code</code>字体似乎显示也有些问题，<code>MesloLGS NF</code>就是正常的。</p><p>  23.8.1 p10k启动配置的时候如果选Unicode，该选项下会有尽量多图标的选项。MobaXterm里面如果出现历史候选词没有变灰色的情况可以在<code>Terminal Type</code>里面修改成<code>xterm-256color</code>，除此之外其他的没有尝试</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>zsh</tag>
      
      <tag>shell</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ip 转换成 Location 的Api</title>
    <link href="/2022/4dd4ea8a/"/>
    <url>/2022/4dd4ea8a/</url>
    
    <content type="html"><![CDATA[<h1 id="ip-to-location"><a href="#ip-to-location" class="headerlink" title="ip to location"></a>ip to location</h1><h2 id="ipwhois"><a href="#ipwhois" class="headerlink" title="ipwhois"></a>ipwhois</h2><p>IPWHOIS.IO的IP地理定位API的URL格式很简单。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">http://ipwhois.app/json/&#123;IP&#125;<br></code></pre></td></tr></table></figure><p>例如，我们可以用以下IP地址发出API请求：47.9.123.84。</p><p><img src="/2022/4dd4ea8a/ipwhois-api.png" alt="img"></p><p><strong>参考链接:</strong></p><ul><li><a href="https://webdamn.com/ip-geolocation-api/">IP Geolocation API – IPWHOIS.IO</a></li><li><a href="https://webdamn.com/how-to-integrate-ip-geolocation-api-with-php/">How to Integrate IP Geolocation API with PHP</a></li><li><a href="https://webdamn.com/scrape-search-result-data-using-serpapi-with-python/">Scrape Search Result Data using SerpApi with Python</a></li><li><a href="https://webdamn.com/get-geocoding-using-positionstack-api-with-php/">Get Geocoding using Positionstack API with PHP</a></li><li><a href="https://webdamn.com/flight-data-using-aviationstack-api-with-php/">Flight Data using Aviationstack API with PHP</a></li><li><a href="https://webdamn.com/get-address-information-using-geocode-api-with-php/">Get Address Information using Geocode API with PHP</a></li><li><a href="https://webdamn.com/review-scraping-using-reviewapi-with-php/">Review Scraping using ReviewAPI with PHP</a></li><li><a href="https://webdamn.com/simple-web-scraping-with-zenscrape-api-using-php/">Simple Web Scraping with Zenscrape API using PHP</a></li><li><a href="https://webdamn.com/scrape-search-result-with-zenserp-api-using-php/">Scrape Search Result with Zenserp API using PHP</a></li><li><a href="https://webdamn.com/build-user-agent-lookup-system-using-userstack-api-with-php/">Build User Agent Lookup System using Userstack API with PHP</a></li><li><a href="https://webdamn.com/build-ip-lookup-website-using-ipapi-with-php/">Build IP Lookup Website using ipapi with PHP</a></li><li><a href="https://webdamn.com/build-weather-website-with-weatherstack-api-using-php/">Build Weather Website with Weatherstack API using PHP</a></li><li><a href="https://webdamn.com/get-website-visitors-info-using-ipstack-api-with-php/">Get Website Visitors Info using IPStack API with PHP</a></li><li><a href="https://webdamn.com/scrape-serp-data-using-serpstack-api-with-python/">Scrape SERP Data using SerpStack API with Python</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ip</tag>
      
      <tag>location</tag>
      
      <tag>api</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单位换算</title>
    <link href="/2022/6fb71d96/"/>
    <url>/2022/6fb71d96/</url>
    
    <content type="html"><![CDATA[<h1 id="单位换算"><a href="#单位换算" class="headerlink" title="单位换算"></a>单位换算</h1><h1 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">★ -----------------</span><br>1 km = 1000 m<br>1 m  = 100  cm<br>1 cm = 10   mm<br>1 mm = 1000 um<br><br>1    inch = 2.54 cm<br>1/10 inch = 2.54 mm<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">--------------------</span><br>1 km = 1000 m<br>1 m  = 10   dm<br>1 dm = 10   cm<br>1 cm = 10   mm<br>1 m  = 1000 mm<br>1 mm = 1000 um<br>1 um = 1000 nm<br>1 nm = 1000 pm <br>1 pm = 1000 fm<br>1 fm = 1000 am<br>...<br>1 inch              = 2.54 cm<br>1 cm                = 0.3937008 inch<br>...<br><span class="hljs-meta prompt_"># </span><span class="language-bash"></span><br><span class="language-bash">1 海里(nautical mile) = 1852 m = 1.852 km</span><br>1 km                = 0.5399568 海里(nautical mile)<br>...<br><span class="hljs-meta prompt_"># </span><span class="language-bash">英制长度单位</span><br>1 英里(mile)          = 1.609344 km<br>1 km                = 0.6213712 英里(mile)<br>...<br><span class="hljs-meta prompt_"># </span><span class="language-bash">天文学长度单位</span><br>1 光年                = 9.4653×10^12 km<br>1 天文单位 ≈ 1.496亿 千米<br>...<br><span class="hljs-meta prompt_"># </span><span class="language-bash">我国传统的长度单位</span><br>1 km                = 2 里<br>1 里                 = 150 丈 = 500 米<br>1 丈                 = 10尺<br>1 丈                 = 3.33米<br>1 尺                 = 3.33分米<br>1 m                 = 0.3 丈 = 3 尺 = 30 寸<br>1 cm                = 3 分 = 30 厘<br><br></code></pre></td></tr></table></figure><h1 id="时间单位"><a href="#时间单位" class="headerlink" title="时间单位"></a>时间单位</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">★ -----------------</span><br>1 s  = 1000 ms<br>1 ms = 1000 us<br>1 us = 1000 ns<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">   -----------------</span><br>1 minute = 60 s<br>1 s  = 1000 ms<br>1 ms = 1000 us<br>1 us = 1000 ns<br>1 ns = 1000 ps<br><br>100年      = 1世纪<br>365.25天   = 1年<br>1平太阳日     = 24小时3分56.555秒<br>1恒星日      = 23小时56分4.091秒<br>1太阳年(回归年) = 365.2422天(= 365天5小时48分46秒)<br>1恒星年      = 365.2564天(= 365天6小时9分9.5秒)<br>1朔望月      = 29.5306天<br>1恒星月      = 27.3712天<br>1太阳年      = 12个朔望日 = 354.36天<br></code></pre></td></tr></table></figure><h1 id="速度"><a href="#速度" class="headerlink" title="速度"></a>速度</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">★ -----------------</span><br>1 m/s  = 3.6 km/h<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">   -----------------</span><br>1 mph  = 1.609344 km/h<br>1 km/h = 0.6213712 mph<br><br></code></pre></td></tr></table></figure><h1 id="温度"><a href="#温度" class="headerlink" title="温度"></a>温度</h1><p>$$<br>℉ &#x3D; ℃ * (9&#x2F;5) + 32<br>$$</p><p>$$<br>℃ &#x3D; (℉ - 32)*(5&#x2F;9)<br>$$</p><p>$$<br>K &#x3D; ℃ + 273.15<br>$$</p><p>$$<br>℃ &#x3D; K - 273.15<br>$$</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">25 ℃ = 298.15 K = 77 F<br></code></pre></td></tr></table></figure><h1 id="电容单位"><a href="#电容单位" class="headerlink" title="电容单位"></a>电容单位</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>1 F  = 1000 mF<br>1 mF = 1000 uF<br>1 uF = 1000 nF<br>1 nF = 1000 pF<br></code></pre></td></tr></table></figure><p><img src="/2022/6fb71d96/tutorials068_001_zh.gif" alt="C"></p><ul><li>数值中的<code>R</code>代表小数点<code>.</code></li></ul><table><thead><tr><th align="left">标示</th><th align="left">电阻</th><th align="left">电容</th><th align="left">电感</th></tr></thead><tbody><tr><td align="left">120</td><td align="left">12Ω</td><td align="left">12pF</td><td align="left">12μH</td></tr><tr><td align="left">122</td><td align="left">1.2kΩ</td><td align="left">1.2nF</td><td align="left">1.2mH</td></tr><tr><td align="left">124</td><td align="left">120kΩ</td><td align="left">120nF</td><td align="left">120mH</td></tr><tr><td align="left">126</td><td align="left">12MΩ</td><td align="left">12μF</td><td align="left">12H</td></tr><tr><td align="left">R15</td><td align="left">0.15Ω</td><td align="left">0.15pF</td><td align="left">0.15μH</td></tr><tr><td align="left">1R5</td><td align="left">1.5Ω</td><td align="left">1.5pF</td><td align="left">1.5μH</td></tr></tbody></table><table><thead><tr><th align="center">误差符号</th><th align="center">误差</th></tr></thead><tbody><tr><td align="center">Ｆ</td><td align="center">±1％</td></tr><tr><td align="center">Ｇ</td><td align="center">±2％</td></tr><tr><td align="center">Ｊ</td><td align="center">±5％</td></tr><tr><td align="center">Ｋ</td><td align="center">±10％</td></tr><tr><td align="center">Ｍ</td><td align="center">±20％</td></tr><tr><td align="center">Ｚ</td><td align="center">80%,－20%</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>unit</tag>
      
      <tag>m</tag>
      
      <tag>cm</tag>
      
      <tag>mm</tag>
      
      <tag>s</tag>
      
      <tag>us</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android 文件传输模式 电脑无法识别</title>
    <link href="/2022/3db44d04/"/>
    <url>/2022/3db44d04/</url>
    
    <content type="html"><![CDATA[<h1 id="android-文件传输模式-电脑无法识别"><a href="#android-文件传输模式-电脑无法识别" class="headerlink" title="android 文件传输模式 电脑无法识别"></a>android 文件传输模式 电脑无法识别</h1><p>最近android手机连接电脑选择传输文件模式，电脑不再识别手机。选择照片模式就没有问题。</p><p>手机选择文件传输模式后 选择自动搜索驱动程序 安装后会 提示“这个inf中的服务安装段落无效”。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li><p>按“Win+X” 点击 “设备管理器”</p></li><li><p>在设备管理器中找到你的手机，名字可能是你的手机型号，可能是未知设备 ，</p></li><li><p>右键选择更新驱动程序.</p></li><li><p>选择 “浏览计算机以查找驱动程序软件”</p></li><li><p>选择 “让我从计算机上的可用驱动程序列表中选取”</p></li><li><p>在列表里面找到“便携设备” (可能没有这一步操作)</p></li><li><p>选择 “MTP USB 设备”</p><p><img src="/2022/3db44d04/1636599848857.png" alt="win10系统识别不了USB设备解决方法介绍-Win10系统识别不了USB设备怎么办-53系统之家"></p></li><li><p>点击 “下一步”</p></li><li><p>回到设备管理器看到设备已经可用正确运作了</p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.android.com/studio/run/oem-usb">安装原始设备制造商 (OEM) USB 驱动程序</a></p><p><a href="https://developer.android.com/studio/run/win-usb">获取 Google USB 驱动程序</a></p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>android</tag>
      
      <tag>mtp</tag>
      
      <tag>pc</tag>
      
      <tag>driver</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tmux 终端复用器(Terminal Multiplexer)</title>
    <link href="/2022/9d389561/"/>
    <url>/2022/9d389561/</url>
    
    <content type="html"><![CDATA[<h1 id="tmux-终端复用器-terminal-multiplexer"><a href="#tmux-终端复用器-terminal-multiplexer" class="headerlink" title="tmux 终端复用器(terminal multiplexer)"></a>tmux 终端复用器(terminal multiplexer)</h1><p>☆为重要内容</p><h1 id="Tmux-简介"><a href="#Tmux-简介" class="headerlink" title="Tmux 简介"></a>Tmux 简介</h1><p>tmux 终端复用器(terminal multiplexer)</p><h2 id="tmux-能干什么"><a href="#tmux-能干什么" class="headerlink" title="tmux 能干什么"></a>tmux 能干什么</h2><p>命令行的典型使用方式是，打开一个终端窗口（terminal window，以下简称”窗口”），在里面输入命令。<strong>用户与计算机的这种临时的交互，称为一次”会话”（session）</strong> 。</p><p>会话的一个重要特点是，窗口与其中启动的进程是<a href="https://www.ruanyifeng.com/blog/2016/02/linux-daemon.html">连在一起</a>的。打开窗口，会话开始；关闭窗口，会话结束，会话内部的进程也会随之终止，不管有没有运行完。</p><p>一个典型的例子就是，<a href="https://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html">SSH 登录</a>远程计算机，打开一个远程窗口执行一个命令例如<code>iperf3 -s</code>。这时，关掉SSH，会发现<code>iperf3</code>进程也被关掉了。这是因为<code>iperf3</code>属于SSH的子进程，SSH作为父进程，如果父进程关掉了，子进程也就关掉了。</p><p>为了解决这个问题，会话与窗口可以”解绑”：窗口关闭时，会话并不终止，而是继续运行，等到以后需要的时候，再让会话”绑定”其他窗口。</p><p><strong>Tmux 就是会话与窗口的”解绑”工具，将它们彻底分离。</strong></p><blockquote><ul><li>它允许在单个窗口中，同时访问多个会话。这对于同时运行多个命令行程序很有用。</li><li>它可以让新窗口”接入”已经存在的会话。</li><li>它允许每个会话有多个连接窗口，因此可以多人实时共享会话。</li><li>它还支持窗口任意的垂直和水平拆分。</li></ul></blockquote><p>类似的终端复用器还有 GNU Screen。Tmux 与它功能相似，但是更易用，也更强大。</p><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p>Tmux 一般需要自己安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Ubuntu 或 Debian</span><br>$ <span class="hljs-built_in">sudo</span> apt-get install tmux<br><br><span class="hljs-comment"># 启动</span><br>$ tmux<br><br><span class="hljs-comment"># 退出</span><br>$ <span class="hljs-built_in">exit</span><br></code></pre></td></tr></table></figure><p>启动后底部<u>左边</u>是<strong>窗口</strong>信息（编号和名称），<u>右侧</u>是系统信息。</p><p><img src="/2022/9d389561/image-20220929235001871.png" alt="image-20220929235001871"></p><p>按下<code>Ctrl+d</code>或者显式输入<code>exit</code>命令，就可以退出 Tmux 窗口。</p><h2 id="前缀键☆"><a href="#前缀键☆" class="headerlink" title="前缀键☆"></a><strong>前缀键</strong>☆</h2><p>Tmux 窗口有大量的快捷键。所有快捷键都要通过前缀键唤起。默认的前缀键是<code>Ctrl+b</code>，即先按下<code>Ctrl+b</code>，快捷键才会生效。</p><p>举例来说，帮助命令的快捷键是<code>Ctrl+b ?</code>。它的用法是，在 Tmux 窗口中，先按下<code>Ctrl+b</code>，再按下<code>?</code>，就会显示帮助信息。</p><p>然后，按下 ESC 键或<code>q</code>键，就可以退出帮助。</p><h2 id="会话-窗格-窗口-的概念☆"><a href="#会话-窗格-窗口-的概念☆" class="headerlink" title="会话  窗格  窗口  的概念☆"></a><strong>会话  窗格  窗口  的概念</strong>☆</h2><blockquote><p>  会话 session<br>  窗口 windows<br>  窗格 pane</p></blockquote><ul><li><code>tmux new</code>的是会话, 会话可以包括多个窗口, 窗口内可以有多个窗格</li></ul><ul><li><code>tmux ls</code> 列出的是会话</li></ul><p><img src="/2022/9d389561/image-20220930003505311.png" alt="image-20220930003505311"></p><h1 id="会话的管理"><a href="#会话的管理" class="headerlink" title="会话的管理"></a>会话的管理</h1><h2 id="快捷键☆"><a href="#快捷键☆" class="headerlink" title="快捷键☆"></a>快捷键☆</h2><p>下面是一些会话相关的快捷键。</p><blockquote><ul><li><code>Ctrl+b d</code>：分离当前会话。</li><li><code>Ctrl+b s</code>：列出所有会话。</li><li><code>Ctrl+b $</code>：重命名当前会话。</li></ul></blockquote><h2 id="3-1-new新建会话☆"><a href="#3-1-new新建会话☆" class="headerlink" title="3.1 new新建会话☆"></a>3.1 new新建会话☆</h2><p>第一个启动的 Tmux 窗口，编号是<code>0</code>，第二个窗口的编号是<code>1</code>，以此类推。这些窗口对应的会话，就是 0 号会话、1 号会话。</p><p>使用编号区分会话，不太直观，更好的方法是为会话起名。</p><blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 直接新建一个</span><br>$ tmux<br><span class="hljs-comment"># 新建并设置一个名字</span><br>$ tmux new -s &lt;session-name&gt;<br></code></pre></td></tr></table></figure></blockquote><p>上面命令新建一个指定名称的会话。</p><p>在<code>tmux</code>内应该是无法执行这个指令的, 需要分屏参考下面的窗格操作章节.</p><h2 id="3-2-detach分离会话☆"><a href="#3-2-detach分离会话☆" class="headerlink" title="3.2 detach分离会话☆"></a>3.2 detach分离会话☆</h2><p>在 Tmux 窗口中，按下<code>Ctrl+b d</code>或者输入<code>tmux detach</code>命令，就会将当前会话与窗口分离。</p><blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux detach<br></code></pre></td></tr></table></figure></blockquote><p>上面命令执行后，就会退出当前 Tmux 窗口，但是会话和里面的进程仍然在后台运行。</p><p><code>tmux ls</code>命令可以查看当前所有的 Tmux 会话。</p><blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux <span class="hljs-built_in">ls</span><br><span class="hljs-comment"># or</span><br>$ tmux list-session<br></code></pre></td></tr></table></figure></blockquote><h2 id="3-3-attach接入会话☆"><a href="#3-3-attach接入会话☆" class="headerlink" title="3.3 attach接入会话☆"></a>3.3 attach接入会话☆</h2><p><code>tmux attach</code>命令用于重新接入某个已存在的会话。</p><blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用会话编号</span><br>$ tmux attach -t 0<br><br><span class="hljs-comment"># 使用会话名称</span><br>$ tmux attach -t &lt;session-name&gt;<br></code></pre></td></tr></table></figure></blockquote><h2 id="3-4-kill-session杀死会话☆"><a href="#3-4-kill-session杀死会话☆" class="headerlink" title="3.4 kill-session杀死会话☆"></a>3.4 kill-session杀死会话☆</h2><p><code>tmux kill-session</code>命令用于杀死某个会话。</p><blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用会话编号</span><br>$ tmux kill-session -t 0<br><br><span class="hljs-comment"># 使用会话名称</span><br>$ tmux kill-session -t &lt;session-name&gt;<br></code></pre></td></tr></table></figure></blockquote><h2 id="3-5-切换会话"><a href="#3-5-切换会话" class="headerlink" title="3.5 切换会话"></a>3.5 切换会话</h2><p><code>tmux switch</code>命令用于切换会话。</p><blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用会话编号</span><br>$ tmux switch -t 0<br><br><span class="hljs-comment"># 使用会话名称</span><br>$ tmux switch -t &lt;session-name&gt;<br></code></pre></td></tr></table></figure></blockquote><h2 id="3-6-重命名会话"><a href="#3-6-重命名会话" class="headerlink" title="3.6 重命名会话"></a>3.6 重命名会话</h2><p><code>tmux rename-session</code>命令用于重命名会话。</p><blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux rename-session -t 0 &lt;new-name&gt;<br></code></pre></td></tr></table></figure></blockquote><p>上面命令将0号会话重命名。</p><h1 id="窗格操作"><a href="#窗格操作" class="headerlink" title="窗格操作"></a>窗格操作</h1><h2 id="快捷键☆-1"><a href="#快捷键☆-1" class="headerlink" title="快捷键☆"></a>快捷键☆</h2><blockquote><ul><li><code>Ctrl+b %</code>：划分左右两个窗格。☆</li><li><code>Ctrl+b &quot;</code>：划分上下两个窗格。☆</li><li><code>Ctrl+b &lt;arrow key&gt;</code>：光标切换到其他窗格。<code>&lt;arrow key&gt;</code>是指向要切换到的窗格的方向键，比如切换到下方窗格，就按方向键<code>↓</code>。☆</li><li><code>Ctrl+b ;</code>：光标切换到上一个窗格。</li><li><code>Ctrl+b o</code>：光标切换到下一个窗格。</li><li><code>Ctrl+b &#123;</code>：当前窗格与上一个窗格交换位置。☆</li><li><code>Ctrl+b &#125;</code>：当前窗格与下一个窗格交换位置。☆</li><li><code>Ctrl+b Ctrl+o</code>：所有窗格向前移动一个位置，第一个窗格变成最后一个窗格。</li><li><code>Ctrl+b Alt+o</code>：所有窗格向后移动一个位置，最后一个窗格变成第一个窗格。</li><li><code>Ctrl+b x</code>：关闭当前窗格。☆</li><li><code>Ctrl+b !</code>：将当前窗格拆分为一个独立窗口。</li><li><code>Ctrl+b z</code>：当前窗格全屏显示，再使用一次会变回原来大小。</li><li><code>Ctrl+b Ctrl+&lt;arrow key&gt;</code>：按箭头方向调整窗格大小。☆</li><li><code>Ctrl+b q</code>：显示窗格编号。</li></ul></blockquote><h2 id="5-1-划分窗格"><a href="#5-1-划分窗格" class="headerlink" title="5.1 划分窗格"></a>5.1 划分窗格</h2><p><code>tmux split-window</code>命令用来划分窗格。</p><blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 划分上下两个窗格</span><br>$ tmux split-window<br><br><span class="hljs-comment"># 划分左右两个窗格</span><br>$ tmux split-window -h<br></code></pre></td></tr></table></figure></blockquote><h2 id="5-2-移动光标"><a href="#5-2-移动光标" class="headerlink" title="5.2 移动光标"></a>5.2 移动光标</h2><p><code>tmux select-pane</code>命令用来移动光标位置。</p><blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 光标切换到上方窗格</span><br>$ tmux select-pane -U<br><br><span class="hljs-comment"># 光标切换到下方窗格</span><br>$ tmux select-pane -D<br><br><span class="hljs-comment"># 光标切换到左边窗格</span><br>$ tmux select-pane -L<br><br><span class="hljs-comment"># 光标切换到右边窗格</span><br>$ tmux select-pane -R<br></code></pre></td></tr></table></figure></blockquote><h2 id="5-3-交换窗格位置"><a href="#5-3-交换窗格位置" class="headerlink" title="5.3 交换窗格位置"></a>5.3 交换窗格位置</h2><p><code>tmux swap-pane</code>命令用来交换窗格位置。</p><blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 当前窗格上移</span><br>$ tmux swap-pane -U<br><br><span class="hljs-comment"># 当前窗格下移</span><br>$ tmux swap-pane -D<br></code></pre></td></tr></table></figure></blockquote><h1 id="窗口管理"><a href="#窗口管理" class="headerlink" title="窗口管理"></a>窗口管理</h1><h2 id="快捷键☆-2"><a href="#快捷键☆-2" class="headerlink" title="快捷键☆"></a>快捷键☆</h2><p>下面是一些窗口操作的快捷键。</p><blockquote><ul><li><code>Ctrl+b c</code>：创建一个新窗口，状态栏会显示多个窗口的信息。</li><li><code>Ctrl+b p</code>：切换到上一个窗口（按照状态栏上的顺序）。</li><li><code>Ctrl+b n</code>：切换到下一个窗口。</li><li><code>Ctrl+b &lt;number&gt;</code>：切换到指定编号的窗口，其中的<code>&lt;number&gt;</code>是状态栏上的窗口编号。</li><li><code>Ctrl+b w</code>：从列表中选择窗口。</li><li><code>Ctrl+b ,</code>：窗口重命名。</li></ul></blockquote><h2 id="6-1-新建窗口"><a href="#6-1-新建窗口" class="headerlink" title="6.1 新建窗口"></a>6.1 新建窗口</h2><p><code>tmux new-window</code>命令用来创建新窗口。</p><blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux new-window<br><br><span class="hljs-comment"># 新建一个指定名称的窗口</span><br>$ tmux new-window -n &lt;window-name&gt;<br></code></pre></td></tr></table></figure></blockquote><h2 id="6-2-切换窗口"><a href="#6-2-切换窗口" class="headerlink" title="6.2 切换窗口"></a>6.2 切换窗口</h2><p><code>tmux select-window</code>命令用来切换窗口。</p><blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 切换到指定编号的窗口</span><br>$ tmux select-window -t &lt;window-number&gt;<br><br><span class="hljs-comment"># 切换到指定名称的窗口</span><br>$ tmux select-window -t &lt;window-name&gt;<br></code></pre></td></tr></table></figure></blockquote><h2 id="6-3-重命名窗口"><a href="#6-3-重命名窗口" class="headerlink" title="6.3 重命名窗口"></a>6.3 重命名窗口</h2><p><code>tmux rename-window</code>命令用于为当前窗口起名（或重命名）。</p><blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux rename-window &lt;new-name&gt;<br></code></pre></td></tr></table></figure></blockquote><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><h2 id="一些其他的快捷键"><a href="#一些其他的快捷键" class="headerlink" title="一些其他的快捷键"></a>一些其他的快捷键</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 列出所有快捷键，及其对应的 Tmux 命令</span><br>$ tmux list-keys<br><br><span class="hljs-comment"># 列出所有 Tmux 命令及其参数</span><br>$ tmux list-commands<br><br><span class="hljs-comment"># 列出当前所有 Tmux 会话的信息</span><br>$ tmux info<br><br><span class="hljs-comment"># 重新加载当前的 Tmux 配置</span><br>$ tmux source-file ~/.tmux.conf<br></code></pre></td></tr></table></figure><h2 id="开启鼠标支持"><a href="#开启鼠标支持" class="headerlink" title="开启鼠标支持"></a>开启鼠标支持</h2><p>tmux2 以上版本和 tmux2 以上版本有所不同</p><blockquote><p>  查看版本<code>tmux -V</code></p><p>  注意大写</p></blockquote><h3 id="tmux2-以上"><a href="#tmux2-以上" class="headerlink" title="tmux2 以上"></a>tmux2 以上</h3><p><strong>写入配置文件</strong></p><p>在<code>~/.tmux.conf</code>中加入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Enable mouse mode (tmux 2.1 and above)</span><br><span class="hljs-built_in">set</span> -g mouse on<br><br><span class="hljs-comment"># Mouse based copy</span><br>bind-key -T copy-mode-vi MouseDragEnd1Pane send -X copy-pipe-and-cancel <span class="hljs-string">&quot;reattach-to-user-namespace pbcopy&quot;</span><br>bind-key -T copy-mode MouseDragEnd1Pane send -X copy-pipe-and-cancel <span class="hljs-string">&quot;reattach-to-user-namespace pbcopy&quot;</span> <br></code></pre></td></tr></table></figure><p><strong>临时使用</strong></p><p>按完前缀ctrl+B后，再按冒号：进入<code>命令行</code>模式，输入<code>set -g mouse on</code></p><h3 id="tmux2-以下"><a href="#tmux2-以下" class="headerlink" title="tmux2 以下"></a>tmux2 以下</h3><p><strong>写入配置文件</strong></p><p>在<code>~/.tmux.conf</code>中加入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">setw -g mouse-resize-pane on<br>setw -g mouse-select-pane on<br>setw -g mouse-select-window on<br>setw -g mode-mouse on<br></code></pre></td></tr></table></figure><blockquote><p>  这几行的作用分别是:<br>  开启用鼠标拖动调节pane的大小（拖动位置是pane之间的分隔线）<br>  开启用鼠标点击pane来激活该pane<br>  开启用鼠标点击来切换活动window（点击位置是状态栏的窗口名称）<br>  开启window&#x2F;pane里面的鼠标支持（也即可以用鼠标滚轮回滚显示窗口内容，此时还可以用鼠标选取文本）</p></blockquote><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.hamvocke.com/blog/a-quick-and-easy-guide-to-tmux/">A Quick and Easy Guide to tmux</a></li><li><a href="https://danielmiessler.com/study/tmux/">Tactical tmux: The 10 Most Important Commands</a></li><li><a href="https://linuxize.com/post/getting-started-with-tmux/">Getting started with Tmux</a></li><li><a href="https://www.ruanyifeng.com/blog/2019/10/tmux.html">阮一峰</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>tmux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JPEG JPEG2000 WebP PNG GIF对比</title>
    <link href="/2022/bc4a75ff/"/>
    <url>/2022/bc4a75ff/</url>
    
    <content type="html"><![CDATA[<h1 id="图像的显示原理"><a href="#图像的显示原理" class="headerlink" title="图像的显示原理"></a>图像的显示原理</h1><h2 id="有损-无损压缩"><a href="#有损-无损压缩" class="headerlink" title="有损&#x2F;无损压缩"></a>有损&#x2F;无损压缩</h2><p>图片文件格式有可能会对图片的文件大小进行不同程度的压缩，图片的压缩分为有损压缩和无损压缩两种。</p><h3 id="有损压缩"><a href="#有损压缩" class="headerlink" title="有损压缩"></a>有损压缩</h3><p>对图像本身的改变，在保存图像时保留了较多的亮度信息，而将色相和色纯度的信息和周围的像素进行合并，合并的比例不同，压缩的比例也不同，由于信息量减少了，所以压缩比可以很高，图像质量也会相应的下降。并且这种损失是不可逆的，我们不可能从有一个有损压缩过的图片中恢复出全来的图片。常见的有损压缩手段，是按照一定的算法将临近的像素点进行合并。<br><strong>有损压缩的原理：</strong> <em>删除景物边缘的某些颜色部分，当人们在屏幕上观看这个场景图片，大脑会利用在景物上看到的颜色填补所丢失的颜色部分。</em><br><strong>有损压缩的优缺点：</strong> <em>是保持颜色的逐渐变化，删除图像中颜色的突然变化。生物学中的大量实验证明，人类大脑会利用与附近最接近的颜色来填补所丢失的颜色。例如，对于蓝色天空背景上的一朵白云，有损压缩的方法就是删除图像中景物边缘的某些颜色部分。当在·屏幕上看这幅图时，大脑会利用在景物上看到的颜色填补所丢失的颜色部分。利用有损压缩技术，某些数据被有意地删除了，而被取消的数据也不再恢复。 无可否认，利用有损压缩技术可以大大地压缩文件的数据，但是会影响图像质量。如果使用了有损压缩的图像仅在屏幕上显示，可能对图像质量影响不太大，至少对于人类眼睛的识别程度来说区别不大。可是，如果要把一幅经过有损压缩技术处理的图像用高分辨率打印机打印出来，那么图像质量就会有明显的受损痕迹。</em></p><h3 id="无损压缩"><a href="#无损压缩" class="headerlink" title="无损压缩"></a>无损压缩</h3><p>无损压缩的基本原理是相同的颜色信息只需保存一次。压缩图像的软件首先会确定图像中哪些区域是相同的，哪些是不同的。包括了重复数据的图像(如蓝天) 就可以被压缩，只有蓝天的起始点和终结点需要被记录下来。但是蓝色可能还会有不同的深浅，天空有时也可能被树木、山峰或其他的对象掩盖，这些就需要另外记录。从本质上看，无损压缩的方法可以删除一些重复数据，大大减少要在磁盘上保存的图像尺寸。但是，无损压缩的方法并不能减少图像的内存占用量，这是因为，当从磁盘上读取图像时，软件又会把丢失的像素用适当的颜色信息填充进来。如果要减少图像占用内存的容量，就必须使用有损压缩方法。<br><strong>无损压缩的特点：</strong> <em>相同的颜色信息只需保存一次。</em><br><strong>无损压缩的原理：</strong> <em>首先辨别出相同颜色的区域，然后把这些相同的数据信息进行压缩记录，也就是记录它的颜色信息、起始和终止位置。</em></p><h2 id="索引色-直接色"><a href="#索引色-直接色" class="headerlink" title="索引色&#x2F;直接色"></a>索引色&#x2F;直接色</h2><p>计算机在表示颜色的时候，有两种形式，一种称作索引颜色(Index Color)，一种称作直接颜色(Direct Color)。</p><h3 id="索引色。"><a href="#索引色。" class="headerlink" title="索引色。"></a>索引色。</h3><p>是一种以有限的方式管理数字图像颜色的技术，以节省计算机内存和文件存储，同时加速显示刷新和文件传输。即用一个数字来代表（索引）一种颜色，在存储图片的时候，存储一个数字的组合，同时存储数字到图片颜色的映射。这种方式只能存储有限种颜色，通常是256种颜色，对应到计算机系统中，使用一个字节的数字来索引一种颜色。</p><h3 id="直接色。"><a href="#直接色。" class="headerlink" title="直接色。"></a>直接色。</h3><p>使用四个数字来代表一种颜色，这四个数字分别代表这个颜色中红色、绿色、蓝色以及透明度（即rgba）。现在流行的显示设备可以在这四个维度分别支持256种变化，所以直接色可以表示2的32次方种颜色。当然并非所有的直接色都支持这么多种，为压缩空间使用，有可能只有表达红、绿、蓝的三个数字，每个数字也可能不支持256种变化之多</p><h2 id="位图-矢量图"><a href="#位图-矢量图" class="headerlink" title="位图&#x2F;矢量图"></a>位图&#x2F;矢量图</h2><h3 id="位图。"><a href="#位图。" class="headerlink" title="位图。"></a>位图。</h3><p>位图也叫做点阵图，栅格图像，像素图。简单的说，就是最小单位由像素构成的图，缩放会失真。构成位图的最小单位是像素，位图就是由像素阵列的排列来实现其显示效果的，每个像素有自己的颜色信息，在对位图图像进行编辑操作的时候，可操作的对象是每个像素，我们可以改变图像的色相、饱和度、明度，从而改变图像的显示效果。举个例子来说，位图图像就好比在巨大的沙盘上画好的画，当你从远处看的时候，画面细腻多彩，但是当你靠的非常近的时候，你就能看到组成画面的每粒沙子以及每个沙粒单纯的不可变化颜色。</p><h3 id="矢量图，"><a href="#矢量图，" class="headerlink" title="矢量图，"></a>矢量图，</h3><p>也叫做向量图。矢量图并不纪录画面上每一点的信息，而是纪录了元素形状及颜色的算法，当你打开一付矢量图的时候，软件对图形象对应的函数进行运算，将运算结果[图形的形状和颜色]显示给你看。无论显示画面是大还是小，画面上的对象对应的算法是不变的，所以，即使对画面进行倍数相当大的缩放，其显示效果仍然相同(不失真)。</p><h1 id="JPEG-JPEG2000-WebP"><a href="#JPEG-JPEG2000-WebP" class="headerlink" title="JPEG JPEG2000 WebP"></a>JPEG JPEG2000 WebP</h1><blockquote><p>  摘录自知乎: </p><p>  原文: <a href="https://zhuanlan.zhihu.com/p/19586108">https://zhuanlan.zhihu.com/p/19586108</a></p><p>  作者: <a href="https://www.zhihu.com/people/xhacker">柳东原</a> This Xhacker has super Big Cat power.</p></blockquote><p><strong>压缩性能综合看来，WebP 略好于 JPEG2000，而这两者都明显好于 JPEG。</strong></p><p>前段时间测试了一下这三种有损图像压缩算法的质量。（WebP 也能支持无损，不过这里只测试有损。）</p><p>测试结果（<a href="https://link.zhihu.com/?target=http://en.wikipedia.org/wiki/Structural_similarity">SSIM Index</a> 可理解为图片与原图片的相似度）：</p><p><img src="/2022/bc4a75ff/6dd37790364b1a5e709f8e67adab81d3_r.jpg" alt="img"></p><p><img src="/2022/bc4a75ff/868c8f801447ee85c0867556cdb1f705_r.jpg" alt="img"></p><p><img src="/2022/bc4a75ff/85ab2ef874126a10072e4669d9cd7c90_720w.jpg" alt="img"></p><p><img src="/2022/bc4a75ff/ea62d92a63b45aa121eb0ccfce4a97fd_720w.jpg" alt="img"></p><p><img src="/2022/bc4a75ff/6cdab6a9efdf3df3fba2657314d81734_720w.jpg" alt="img"></p><p><img src="/2022/bc4a75ff/323465387e562470441127b8f0cc992e_720w.jpg" alt="img"></p><p>测试细节：对于 JPEG 使用 libjpeg 压缩，JPEG 2000 使用 OpenJPEG，WebP 使用 libwebp。</p><h1 id="JPEG-PNG-GIF-WEBP"><a href="#JPEG-PNG-GIF-WEBP" class="headerlink" title="JPEG PNG GIF WEBP"></a>JPEG PNG GIF WEBP</h1><p><strong>综合看来</strong></p><ul><li>PNG 可以保存透明信息, 比较适合颜色单一, 主要是纯色的图像, ( logo&#x2F;icon&#x2F;透明图 )</li><li>JPEG 适用颜色种类多样 且颜色变化明显的图片 ( 一般照片 )</li><li>GIF 支持动画,透明, 只有8位颜色 ( 动图 )</li><li>WEBP 文件小, 支持透明, 有损无损压缩, 支持动画, 兼容性不好 ( 网页图像 )</li></ul><h2 id="JPEG"><a href="#JPEG" class="headerlink" title="JPEG"></a>JPEG</h2><p>JPEG是有损的、采用直接色的、位图。JPEG也是一种针对照片影像而广泛使用的有损压缩标准方法。JPEG图片格式的设计目标，是在不影响人类可分辨的图片质量的前提下，尽可能的压缩文件大小。这意味着JPEG去掉了一部分图片的原始信息，也即是进行了有损压缩。JPEG的图片的优点，是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，用来表达更生动的图像效果，比如颜色渐变。</p><ul><li>特性：适用于存储色彩丰富、层次分明的图片，不适合于线条绘图（drawing）和其他文字或图标（iconic）的图形，因为它的压缩方法用在这些类型的图形上，得到的结果并不好(PNG和GIF通常是用来存储这类的图形)</li></ul><h2 id="PNG"><a href="#PNG" class="headerlink" title="PNG"></a>PNG</h2><p>便携式网络图形是一种无损压缩的位图图形格式，支持索引、灰度、RGB三种颜色方案以及Alpha通道等特性</p><ul><li>特性：如果保存文本，线条或类似的边缘清晰，有大块相同颜色区域的图像，PNG格式的压缩效果就要比JPEG好很多，并且不会出现JPEG那样的高对比度区域的图像有损。如果图像既有清晰边缘，又有照片图像的特点，就需要在这两种格式之间权衡一下了。JPEG不支持透明度。<br>PNG格式有8位、24位、32位三种形式,其中8位PNG支持两种不同 的透明形式（索引透明和alpha透明）,24位PNG不支持透明,32位 PNG 在24位基础上增加了8位透明通道（32-24&#x3D;&#x3D;&#x3D;8）,因此可展现256级透明程度。</li></ul><h3 id="PNG8"><a href="#PNG8" class="headerlink" title="PNG8"></a>PNG8</h3><p>PNG8是<strong>无损的、使用索引色的、点阵图</strong>,支持不透明、索引透明、Alpha透明，都最多只能展示256（2的8次方）种颜色，所以“PNG8”格式更适合那些颜色比较单一的图像，例如纯色、logo、图标等；因为颜色数量少，所以图片的体积也会更小；</p><ul><li><p>PNG8(不透明),默认PNG8</p></li><li><p>PNG8(索引色透明),简单说可以理解为静态的GIF<br>指定一个像素点是不是透明<br>但是PNG由于算法的优势,体积比较少<br>所以,静态GIF完全可用PNG8取代</p></li><li><p>PNG8(Alpha透明),牛逼在可指定像素点的透明度,例如50%透明度<br>这种优点在于比PNG24&#x2F;32体积小,因为也只有256色嘛<br>缺点在于IE6支持不好,会把半透明的像素点显示成全透明</p></li></ul><h3 id="PNG24"><a href="#PNG24" class="headerlink" title="PNG24"></a>PNG24</h3><p>是PNG的直接色版本。PNG24是<strong>无损的、使用直接色的、点阵图</strong>,支持2的24次方种颜色，表现为不透明。用三个8bits分别去表示 R（红）、G（绿）、B（蓝）。R(0255),G(0255),B(0~255)，可以表达256乘以256乘以256&#x3D;16777216种颜色的图片，这样PNG24就能比PNG8表示色彩更丰富的图片,图片的清晰度也会更好，图片质量更高，当然图片的大小也会相应增加，所以“PNG24”的图片比较适合像摄影作品之类颜色比较丰富的图片<br>PNG24与JPG一样能表达丰富的图片细节，但并不能替代JPG。图片存储为PNG24比存储为JPG，文件大小至少是JPG的5倍，但在图片品质上的提升却微乎其微。所以除非对品质的要求极高，否则色彩丰富的网络图片还是推荐使用JPG</p><h3 id="PNG32"><a href="#PNG32" class="headerlink" title="PNG32"></a>PNG32</h3><p>支持2的32次方种颜色，32位是我们最常使用的格式，它是在PNG在24位的PNG基础上增加了8位的透明信息，支持不同程度的半透效果</p><h3 id="PNG8-PNG24-PNG32三者的区别在于："><a href="#PNG8-PNG24-PNG32三者的区别在于：" class="headerlink" title="PNG8\PNG24\PNG32三者的区别在于："></a>PNG8\PNG24\PNG32三者的区别在于：</h3><ul><li>PNG-32每个像素的深度为32bits，其中RGBA四个通道各占8bits。所谓的RGBA四个通道，就是红，绿，蓝，透明 这四种色值各自的大小，都用8bits来表示（0～255）。</li><li>PNG-24的像素深度为24bits，其中RGB三个通道各占8bits。</li><li>PNG-8则是使用8位的索引色。</li></ul><h2 id="GIF"><a href="#GIF" class="headerlink" title="GIF"></a>GIF</h2><p>GIF是一种<strong>无损、使用于索引色的、位图</strong>。由于采用了无损压缩，相比古老的bmp格式，尺寸较小，而且支持透明和动画。缺点是由于gif只存储8位索引（也就是最多能表达2^8&#x3D;256种颜色），色彩复杂、细节丰富的图片不适合保存为gif格式。色彩简单的logo、icon、线框图适合采用gif格式。</p><p>静态GIF完全可用PNG8取代</p><h2 id="WEBP"><a href="#WEBP" class="headerlink" title="WEBP"></a>WEBP</h2><p>WebP图片是一种同时提供了<strong>有损压缩与无损压缩、使用直接色的、位图</strong>，由Google开发。与png、jpg相比，相同的视觉体验下，WebP图像的尺寸缩小了大约30％。另外，WebP图像格式还支持有损压缩、无损压缩、透明和动画。理论上完全可以替代png、jpg、gif等图片格式，当然目前webp的还没有得到全面的支持。</p><p>WEBP与PNG压缩对比</p><p><img src="/2022/bc4a75ff/formatpng.png" alt="img"></p><p>可以得出结论：</p><blockquote><p>  PNG 转 WebP 的压缩率要高于 PNG 原图压缩率，同样支持有损与无损压缩<br>  转换后的 WebP 体积大幅减少，图片质量也得到保障（同时肉眼几乎无法看出差异）<br>  转换后的 WebP 支持 Alpha 透明和 24-bit 颜色数，不存在 PNG8 色彩不够丰富和在浏览器中可能会出现毛边的问题</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jpeg</tag>
      
      <tag>webp</tag>
      
      <tag>jpeg2000</tag>
      
      <tag>image</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件后缀与文件</title>
    <link href="/2022/631793c8/"/>
    <url>/2022/631793c8/</url>
    
    <content type="html"><![CDATA[<h1 id="文件后缀与文件"><a href="#文件后缀与文件" class="headerlink" title="文件后缀与文件"></a>文件后缀与文件</h1><table><thead><tr><th>后缀</th><th>名称描述</th><th>简述</th></tr></thead><tbody><tr><td><code>.DS_Store</code></td><td>Desktop Services Store</td><td>Mac OS X操作系统所创造的隐藏文件，类似<code>desktop.ini</code></td></tr></tbody></table><h2 id="编辑历史"><a href="#编辑历史" class="headerlink" title="编辑历史"></a>编辑历史</h2><table><thead><tr><th>date</th><th>note</th></tr></thead><tbody><tr><td>2022.9.15</td><td>First Version</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h2 id="DS-Store"><a href="#DS-Store" class="headerlink" title=".DS_Store"></a>.DS_Store</h2><blockquote><p>  DS_Store，英文全称是 Desktop Services Store（桌面服务存储），开头的 DS 是 Desktop Services（桌面服务） 的缩写。它是一种由macOS系统自动创建的隐藏文件，存在于每一个用「Finder」打开过的文件夹下面。</p><p>  <code>.DS_Store</code> 是一种由苹果公司的Mac OS X操作系统所创造的隐藏文件，目的在于存贮目录的自定义属性，例如文件们的图标位置或者是背景色的选择。该文件由<code>Finder</code>创建并维护，类似于<code>Microsoft Windows</code>中的<code>desktop.ini</code>文件。</p></blockquote><h2 id="RTF"><a href="#RTF" class="headerlink" title=".RTF"></a>.RTF</h2><blockquote><p>  <strong>富文本格式</strong>（<strong>Rich Text Format</strong>）即<strong>RTF格式</strong>，又称<strong>多文本格式</strong>，是由<a href="https://zh.wikipedia.org/wiki/%E5%BE%AE%E8%BD%AF">微软</a>公司开发的跨平台<a href="https://zh.wikipedia.org/wiki/%E6%96%87%E6%A1%A3">文档</a>格式。大多数的<a href="https://zh.wikipedia.org/wiki/%E6%96%87%E5%AD%97%E5%A4%84%E7%90%86">文字处理</a>软件都能读取和保存RTF文档。</p><h2 id="支持软件"><a href="#支持软件" class="headerlink" title="支持软件"></a>支持软件</h2><ul><li><a href="https://zh.wikipedia.org/wiki/WordPad">WordPad</a>（<a href="https://zh.wikipedia.org/wiki/Microsoft_Windows">Microsoft Windows</a>）&#x2F; <a href="https://zh.wikipedia.org/wiki/%E6%96%87%E5%AD%97%E7%B7%A8%E8%BC%AF_(%E6%87%89%E7%94%A8%E7%A8%8B%E5%BC%8F)">文本编辑</a>（<a href="https://zh.wikipedia.org/wiki/Mac_OS">Mac OS</a>）</li><li><a href="https://zh.wikipedia.org/wiki/Microsoft_Word">Microsoft Word</a></li><li><a href="https://zh.wikipedia.org/wiki/Apache_OpenOffice">Apache OpenOffice</a> &#x2F; <a href="https://zh.wikipedia.org/wiki/LibreOffice">LibreOffice</a></li><li><a href="https://zh.wikipedia.org/zh-cn/WPS_Office">WPS Office</a></li><li><a href="https://zh.wikipedia.org/wiki/EIOffice">EIOffice</a></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DS_Store</tag>
      
      <tag>rtf</tag>
      
      <tag>后缀</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zip Gzip Bzip2 Tar 的区别和差异</title>
    <link href="/2022/613d8edd/"/>
    <url>/2022/613d8edd/</url>
    
    <content type="html"><![CDATA[<h1 id="zip-gzip-bzip2-tar-命令的区别和差异"><a href="#zip-gzip-bzip2-tar-命令的区别和差异" class="headerlink" title="zip gzip bzip2 tar 命令的区别和差异"></a>zip gzip bzip2 tar 命令的区别和差异</h1><ul><li><code>gzip</code> 和 <code>bzip2</code>用于压缩单个文件。bzip2 比 gzip 具有更高的压缩率，同样的也会需要<strong>更多更多更多</strong>时间来进行压缩。</li><li><code>tar</code>格式的包只是将文件归档在一起, 并不会有任何压缩。</li><li><code>zip</code> 和 <code>tar</code> 命令用于压缩和归档文件夹。</li></ul><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>zip</td><td><code>.zip</code></td><td>可以压缩目录</td><td>源文件会保留</td><td>专门的压缩命令</td></tr><tr><td>gzip</td><td><code>.gz</code></td><td>只能压缩文件</td><td>压缩后源文件会被删除</td><td></td></tr><tr><td>bzip2</td><td><code>.bz2</code></td><td>只能压缩文件</td><td>加<code>-k</code>参数源文件可以保留</td><td></td></tr><tr><td>tar</td><td><code>.tar</code></td><td>可以压缩目录</td><td>源文件会保留</td><td>linux包大多是这形态<br>将目录打包成一个文件<code>Tape archive</code></td></tr><tr><td>xz</td><td><code>.xz</code></td><td></td><td></td><td></td></tr></tbody></table><h2 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h2><h2 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h2><p>该<code>gzip</code>程序用于压缩一个或多个文件。执行时，它将原始文件替换为原始文件的压缩版本。使用 gzip 压缩的文件具有扩展名<code>.gz</code></p><h2 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h2><p>该<code>bzip2</code>命令类似于 gzip，但使用不同的压缩算法，以牺牲压缩速度为代价归档更高级别的压缩。使用 bzip2 压缩的文件具有扩展名<code>.bz2</code></p><h2 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h2><p><code>tar</code>命令，首字母缩略词<em><strong>Tape archive</strong></em>用于创建存档文件。tar 存档可以由单独的文件、一个或多个目录层次结构或两者的混合组成。tar 文件有扩展名<code>.tar</code></p><h2 id="xz"><a href="#xz" class="headerlink" title="xz"></a>xz</h2><p><code>xz</code>是一个通用的数据压缩工具，命令行语法类似于 gzip 和 bzip2 。它根据选择的操作模式压缩或解压缩每个文件。用 xz 压缩的文件具有扩展名<code>.xz</code></p><h1 id="Zip-和-Unzip"><a href="#Zip-和-Unzip" class="headerlink" title="Zip 和 Unzip"></a>Zip 和 Unzip</h1><h2 id="zip-1"><a href="#zip-1" class="headerlink" title="zip"></a>zip</h2><p><strong>命令格式</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">zip [-r] [压缩后文件名] [文件或目录]<br></code></pre></td></tr></table></figure><p><strong>命令描述</strong></p><ul><li><code>zip</code>命令用来对文件进行打包操作。zip是个使用广泛的压缩程序，文件经它压缩后会另外产生具有“.zip”扩展名的压缩文件；</li><li>在linux压缩后的文件，基本都可以在Windows系统中解压；Windows中压缩的文件，在Linux中不一定可用，但是zip格式的压缩文件，可以做到可用；</li><li>zip的压缩比不是很高；</li></ul><p><strong>示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 压缩文件</span><br>$ zip a.zip a.txt<br><span class="hljs-comment"># 查看压缩后的文件</span><br>$ <span class="hljs-built_in">ls</span><br>a.txt  a.zip  <br><br><span class="hljs-comment"># 2. -r：压缩文件夹</span><br>$ zip -r test.zip testDir/<br>$ <span class="hljs-built_in">ls</span><br>testDir  test.zip<br><br><span class="hljs-comment"># 3. -x 排除文件</span><br>$ zip -r test2.zip testDir/ -x <span class="hljs-string">&quot;testDir/hello*&quot;</span> -x <span class="hljs-string">&quot;testDir/dir/*&quot;</span><br></code></pre></td></tr></table></figure><h2 id="unzip-解压"><a href="#unzip-解压" class="headerlink" title="unzip 解压"></a>unzip 解压</h2><p><strong>命令格式</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">unzip [选项] 文件名<br></code></pre></td></tr></table></figure><p><strong>命令描述</strong></p><p><code>unzip</code>命令用于解压缩由zip命令压缩的“.zip”压缩包。</p><p><strong>选项</strong></p><ul><li>-n：解压缩时不要覆盖原有的文件；</li><li>-o：不必先询问用户，unzip执行后覆盖原有的文件；</li><li>-d &lt;目录&gt;：指定文件解压缩后所要存储的目录(不指定目录，默认解压到当前目录)</li></ul><p><strong>示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 解压文件到家目录</span><br>$ unzip test.zip -d ~<br></code></pre></td></tr></table></figure><h1 id="Gzip-和-Gunzip"><a href="#Gzip-和-Gunzip" class="headerlink" title="Gzip 和 Gunzip"></a>Gzip 和 Gunzip</h1><h2 id="gzip-1"><a href="#gzip-1" class="headerlink" title="gzip"></a><strong>gzip</strong></h2><p><strong>命令格式</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">gzip [文件]<br></code></pre></td></tr></table></figure><p><strong>命令描述</strong></p><p><code>gzip</code>命令 用来压缩文件。gzip是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多处“<code>.gz</code>”扩展名。<code>gzip</code>只能压缩文件，不能压缩文件夹，压缩后原文件会被删除</p><p><code>gzip</code>是在Linux系统中经常使用的一个对文件进行压缩和解压缩的命令，既方便又好用。gzip不仅可以用来压缩大的、较少使用的文件以节省磁盘空间，还可以和tar命令一起构成Linux操作系统中比较流行的压缩文件格式。据统计，gzip命令对文本文件有60%～70%的压缩率。减少文件大小有两个明显的好处，一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间。</p><p><strong>示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 压缩文件</span><br>$ gzip a.txt<br><span class="hljs-comment"># 查看压缩后的文件，源文件被删除</span><br>$ <span class="hljs-built_in">ls</span><br>a.txt.gz<br></code></pre></td></tr></table></figure><h2 id="gunzip-解压"><a href="#gunzip-解压" class="headerlink" title="gunzip 解压"></a>gunzip 解压</h2><p><strong>命令格式</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">gzip [文件]<br></code></pre></td></tr></table></figure><p><strong>命令描述</strong></p><p><code>gunzip</code>命令用来解压缩文件。gunzip是个使用广泛的解压缩程序，它用于解开被gzip压缩过的文件，这些压缩文件预设最后的扩展名为<code>.gz</code>。</p><p><strong>示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 解压文件，解压后压缩文件被删除</span><br>$ gunzip a.txt.gz<br>$ <span class="hljs-built_in">ls</span><br>a.txt <br></code></pre></td></tr></table></figure><h1 id="Bzip2"><a href="#Bzip2" class="headerlink" title="Bzip2"></a>Bzip2</h1><h2 id="bzip2-1"><a href="#bzip2-1" class="headerlink" title="bzip2"></a>bzip2</h2><p><strong>命令格式</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">bzip2 [选项] [文件]<br></code></pre></td></tr></table></figure><p><strong>命令描述</strong></p><ul><li>bzip2命令用于压缩“<code>.bz2</code>”格式的压缩包，是<code>gzip</code>的升级版本，可以保留原文件；</li><li>bzip2的压缩比比较高，可用于压缩较大文件的压缩；</li><li>bzip2也是只对文件进行压缩，如果相对目录进行压缩的话，可以配合 <code>tar</code>命令使用，使用 <code>tar -jcvf</code> 文件名 完成打包压缩。</li></ul><p><strong>选项</strong></p><p>-k（keep）：保留原文件（不删除原文件）</p><p><strong>示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># bzip2 压缩文件</span><br>$ bzip2 -k a.txt<br>$ <span class="hljs-built_in">ls</span><br>a.txt  a.txt.bz2<br><br><span class="hljs-comment"># 配合使用tar 命令，完成打包压缩</span><br>$ <span class="hljs-built_in">mkdir</span> music<br>$ tar -jcvf music.tar.bz2 music/<br>$ <span class="hljs-built_in">ls</span><br>music  music.tar.bz2<br></code></pre></td></tr></table></figure><h2 id="bunzip2-解压"><a href="#bunzip2-解压" class="headerlink" title="bunzip2 解压"></a>bunzip2 解压</h2><p><strong>命令格式</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">bunzip2 [选项] [文件]<br></code></pre></td></tr></table></figure><p><strong>命令描述</strong></p><ul><li>解压缩“<code>.bz2</code>”格式的压缩文件；</li><li>gunzip的升级版，可以使用<code>-k</code>保留原文件；</li><li>可以配合使用tar命令，完成解压缩解包： <code>tar -jxvf 文件名</code></li></ul><p><strong>选项</strong></p><p>-k（keep）：保留原文件（不删除原文件）</p><p><strong>示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">ls</span><br>a.txt.bz2  music.tar.bz2<br><br><span class="hljs-comment"># 解压缩文件</span><br>$ bunzip2 -k a.txt.bz2<br>$ <span class="hljs-built_in">ls</span><br>a.txt  a.txt.bz2  music.tar.bz2<br><br><span class="hljs-comment"># 使用tar完成解压解包</span><br>$ tar -jxvf music.tar.bz2<br>$ <span class="hljs-built_in">ls</span><br>a.txt  a.txt.bz2  music  music.tar.bz2<br></code></pre></td></tr></table></figure><h1 id="tar-1"><a href="#tar-1" class="headerlink" title="tar"></a>tar</h1><h2 id="tar-2"><a href="#tar-2" class="headerlink" title="tar"></a>tar</h2><p><strong>命令格式</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">tar [选项] [压缩后文件名] [目录]<br></code></pre></td></tr></table></figure><p><strong>命令描述</strong></p><p>打包目录，将目录打包成一个文件，同时可以压缩，压缩后的拓展名为<code>.tar.gz</code>，这个拓展名在下载Linux相关安装包时很常见。</p><p>使用<code>tar</code>命令时，如果想要打包并压缩一个目录，可以有两种方法进行：</p><ol><li>先利用tar命令打包目录为一个文件，然后使用gzip压缩</li><li>直接利用tar命令打包并压缩 (简单方便，推荐使用)</li></ol><p>解压时也有两种方式：</p><ol><li>先使用gunzip解压缩，再使用tar解包</li><li>直接利用tar命令解压缩并解包 (简单方便，推荐使用)</li></ol><p><strong>选项</strong></p><ul><li>-c：打包(将所有文件变成一个文件 Create  a new archive)</li><li>-x：解包</li><li>-v：显示详细信息</li><li>-f：指定文件名</li><li>-z：打包同时压缩&#x2F;解压缩  ，gzip压缩</li><li>-j：生成压缩文件 ，bzip2压缩</li></ul><p><strong>示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 压缩</span><br>tar -zcvf movie2.tar.gz movie<br><span class="hljs-comment"># 解压</span><br>tar -zxvf movie2.tar.gz<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1、2为    打包压缩    的两种方法</span><br><span class="hljs-comment"># 1. 使用 tar -cvf 打包，然后使用gzip压缩</span><br>$ tar -cvf movie.tar movie/<br>$ <span class="hljs-built_in">ls</span><br>movie  movie.tar<br>$ gzip movie.tar<br>$ <span class="hljs-built_in">ls</span><br>movie  movie.tar.gz<br><br><span class="hljs-comment"># 2. 使用 tar -zcvf 打包并压缩</span><br>$ tar -zcvf movie2.tar.gz movie<br>$ <span class="hljs-built_in">ls</span><br>movie  movie2.tar.gz<br><br><span class="hljs-comment"># 3、4为     解压缩并解包     的两种方法</span><br><span class="hljs-comment"># 3. 先使用gunzip解压缩，然后 tar -xvf解包</span><br>$ gunzip movie.tar.gz<br>$ <span class="hljs-built_in">ls</span><br>movie2.tar.gz  movie.tar<br>$ tar -xvf movie.tar<br>movie/<br>$ <span class="hljs-built_in">ls</span><br>movie  movie2.tar.gz  movie.tar<br><br><span class="hljs-comment"># 4. 使用tar -zxvf 解压缩并解包</span><br>$ tar -zxvf movie2.tar.gz<br>$ <span class="hljs-built_in">ls</span><br>movie  movie2.tar.gz  movie.tar<br></code></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://techviewleo.com/compress-uncompress-files-tar-gzip-bzip2-xz-linux/">LPIC 101 – Compress and Uncompress Files Using tar, gzip, bzip2 and xz on Linux</a></p><p><a href="https://en.wikipedia.org/wiki/List_of_archive_formats#Comparison">List of archive formats</a></p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>zip</tag>
      
      <tag>gzip</tag>
      
      <tag>bzip</tag>
      
      <tag>tar</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MD5</title>
    <link href="/2022/45a589a3/"/>
    <url>/2022/45a589a3/</url>
    
    <content type="html"><![CDATA[<h1 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h1><p><strong>MD5消息摘要算法</strong>（英语：MD5 Message-Digest Algorithm），一种被广泛使用的<a href="https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A2%BC%E9%9B%9C%E6%B9%8A%E5%87%BD%E6%95%B8">密码散列函数</a>，可以产生出一个128位（16个字符(BYTES)）的散列值（hash value），用于确保信息传输完整一致。将<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE">数据</a>（如一段文字）运算变为另一固定长度值，是散列算法的基础原理。</p><p><strong>参考</strong></p><p><a href="https://zhuanlan.zhihu.com/p/121492822">MD5破解的几种方法</a></p><p><a href="https://en.wikipedia.org/wiki/MD5">Wiki MD5</a></p><h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><ul><li><p>不可逆向的</p><blockquote><p>  我们没办法把MD5码还原对应的原文。道理很简单，任意长度的数据经过MD5处理后，所包含的信息量已经大大减少，那是不可能再次还原成为原始信息的。</p></blockquote></li><li><p>原文中作一个小变化其散列也会发生巨大的变化</p><blockquote>  <figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-symbol">MD5</span>(<span class="hljs-string">&quot;The quick brown fox jumps over the lazy dog&quot;</span>)<br>= <span class="hljs-number">9</span>e107d9d372bb6826bd81d3542a419d6<br></code></pre></td></tr></table></figure><p>  比如用c取代d, 其MD5值发生了巨大的变化</p>  <figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-symbol">MD5</span>(<span class="hljs-string">&quot;The quick brown fox jumps over the lazy cog&quot;</span>)<br>= <span class="hljs-number">1055</span>d3e698d289f2af8663725127bd4b<br></code></pre></td></tr></table></figure></blockquote></li><li><p>已被破解</p><blockquote><p>  通俗点讲就是，可以找到一个A和一个B，使hash（A）&#x3D;hash（B），而真正有用的是给定一个A能得到B，使hash（A）&#x3D;hash（B），而王小云能做到这样</p></blockquote></li></ul><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>MD5 摘要已在<a href="https://en.wikipedia.org/wiki/Software">软件</a>世界中广泛使用，以确保传输的文件已完好无损地到达。例如，文件服务器通常会为文件提供预先计算的 MD5（称为<a href="https://en.wikipedia.org/wiki/Md5sum">md5sum</a>）<a href="https://en.wikipedia.org/wiki/Checksum">校验和</a>，以便用户可以将下载文件的校验和与其进行比较。</p><p><img src="/2022/45a589a3/350px-CPT-Hashing-File-Transmission.png" alt="350px-CPT-Hashing-File-Transmission.svg"></p><p>由于很容易产生 MD5 冲突，因此创建文件的人可能会创建具有相同校验和的第二个文件，因此该技术无法防止某些形式的恶意篡改。</p><p>在某些情况下，校验和是不可信的（例如，如果它是通过与下载文件相同的渠道获得的，他人可能修改了文件后再次修改了MD5，使得MD5并不可信），在这种情况下，MD5 只能提供错误检查功能：“它会识别损坏或不完整的下载，这变成下载较大文件时更有可能。”</p><h1 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h1><h2 id="穷举法-字典法"><a href="#穷举法-字典法" class="headerlink" title="穷举法&amp;字典法"></a>穷举法&amp;字典法</h2><p><strong>穷举法非常简单，就是不停地尝试各种字符的排列组合，看哪一个组合的MD5码能对上。</strong>可惜缺点是太耗费时间了。我们举个栗子，假设我们要破解一个6位大小写字母和数字混合的密码，那么一共有(26+26+10)<sup>6</sup> 种组合。这个数的大小超过500亿。</p><p>既然计算如此费时，能不能考虑<strong>把计算结果以映射表的形式存放起来，一个萝卜一个坑</strong>，一个原文对应着一个MD5码呢？可以呀！这就是传说中的“字典法”。将已知的MD5码查表，直接反查出原文。<strong>字典法体现了算法设计的“以空间换时间”的思想。</strong>缺点是比较耗费空间。不过现在硬盘的价格变得白菜价了，空间开销不算什么。</p><p><a href="https://www.cmd5.com/password.aspx">CMD5 反查网站</a></p><p><a href="https://www.somd5.com/">SMD5 反查网站</a></p><h2 id="哈希链表-彩虹表法"><a href="#哈希链表-彩虹表法" class="headerlink" title="哈希链表&amp;彩虹表法"></a>哈希链表&amp;彩虹表法</h2><blockquote><p>  如果说穷举法太耗费时间，字典法太耗费存储空间的话，我们能不能考虑在时间消耗和空间消耗之间折中呢？我们可以考虑用链表将一系列有意义的原文和MD5码串起来。</p><p>  要构造这样的链表，我们需要两个函数：哈希函数H(x)和衰减函数（reduction function）R(x)。哈希函数可以是MD5，也可以是其他的消息摘要算法。H(x)的值域是R(x)的定义域，R(x)的值域是H(x)的定义域。<strong>R(x)不是H(x)的反函数。</strong></p><p>  将一个原文不停地使用H(x)和R(x)交替进行运算k次，再将原文本身和运算结果以链表的形式串接起来，就可以得到结点个数为2k+1的链表。实际存放的时候只存放首端和末端两个原文即可。<strong>这种链表叫做“哈希链表”，体现了算法设计的“时空权衡”（Space and Time Tradeoffs）。</strong></p><p>  举个栗子，假设原文s&#x3D;abcabc，经过2次交替运算，得到以下的链表：</p><p>  abcabc-&gt;H(x)-&gt;3C8B0D7A-&gt;R(x)-&gt;eopmca-&gt;H(x)-&gt;7E9F216C-&gt;R(x)-&gt;rapper</p><p>  以上数据均为举例编造的，仅为说明原理使用。那我们存放这个链表的时候，只需要记录abcabc和rapper两个原文即可。</p><p>  假设我们要破解的摘要值（哈希链表的H(x)不一定是MD5算法，这里用更准确的说法代替MD5码）是7E9F216C，经过R(x)运算得到rapper，说明我们要寻找的原文就在以rapper为末端的哈希链表中。从首端开始经过多次运算，我们发现eopmca的摘要值就是7E9F216C。于是就反查出7E9F216C对应的原文是eopmca。</p><p>  <strong>如果在生成哈希链表的时候依次使用多个不一样的R(x)，此时的哈希链表就是“彩虹表”。</strong></p><p>  这里有已经计算好的彩虹表：<a href="https://link.zhihu.com/?target=http://project-rainbowcrack.com/table.htm">http://project-rainbowcrack.com</a></p></blockquote><h2 id="差分攻击"><a href="#差分攻击" class="headerlink" title="差分攻击"></a>差分攻击</h2><p>上面介绍的穷举法、字典法和彩虹表法都是暴力破解，适用于任何的消息摘要算法。</p><p>真正意义上MD5算法的破解，是2004年山东大学王小云教授提出的MD5碰撞方法。她所用到的方法正是差分攻击。</p><p><a href="https://www.sohu.com/a/501560600_121106869">她是这样的“中国密码女神”！</a> </p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>md5</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpaceDesk手机用作电脑屏幕</title>
    <link href="/2022/471570a6/"/>
    <url>/2022/471570a6/</url>
    
    <content type="html"><![CDATA[<h1 id="SpaceDesk"><a href="#SpaceDesk" class="headerlink" title="SpaceDesk"></a>SpaceDesk</h1><p>在windows主机上虚拟出一块屏幕, 通过网络传输到其他带屏设备上.</p><ul><li>投屏到手机支持触摸</li></ul><h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p><a href="https://www.spacedesk.net/">https://www.spacedesk.net/</a></p><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><h2 id="软件没有验证功能-不安全"><a href="#软件没有验证功能-不安全" class="headerlink" title="软件没有验证功能(不安全)"></a>软件没有验证功能(不安全)</h2><p>有一次在公司用手机客户端, 直接连接上了公司其他同事的电脑屏幕.</p><p>公司的网络ip是dhcp的无法固定, 而且网络质量并不好, 所以我选择电脑开热点 手机连电脑热点.</p><p>防火墙加规则,只允许热点网段的IP入站.</p><p><img src="/2022/471570a6/image-20220811195054454.png" alt="image-20220811195054454"></p><p><img src="/2022/471570a6/image-20220811194925793.png" alt="image-20220811194925793"></p>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>spacedesk</tag>
      
      <tag>投屏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Jlink 烧写SPI Flash存储芯片</title>
    <link href="/2022/fd90dc4c/"/>
    <url>/2022/fd90dc4c/</url>
    
    <content type="html"><![CDATA[<h1 id="使用Jlink-烧写SPI-Flash存储芯片"><a href="#使用Jlink-烧写SPI-Flash存储芯片" class="headerlink" title="使用Jlink 烧写SPI Flash存储芯片"></a>使用Jlink 烧写SPI Flash存储芯片</h1><p>参考:</p><p><a href="https://www.segger.com/products/debug-probes/j-link/tools/j-flash-spi/">https://www.segger.com/products/debug-probes/j-link/tools/j-flash-spi/</a></p><h1 id="硬件连接"><a href="#硬件连接" class="headerlink" title="硬件连接"></a>硬件连接</h1><h2 id="SPI-Single"><a href="#SPI-Single" class="headerlink" title="SPI &amp; Single"></a>SPI &amp; Single</h2><p><img src="/2022/fd90dc4c/formatpng.png" alt="img"></p><p><img src="/2022/fd90dc4c/pinout-spi-20-pin.gif" alt="引出线 spi 20 针"></p><h2 id="QSPI-Quad"><a href="#QSPI-Quad" class="headerlink" title="QSPI &amp; Quad"></a>QSPI &amp; Quad</h2><p><img src="/2022/fd90dc4c/pinout-qspi-20-pin.png" alt="img"></p><blockquote><p>  注意:</p><p>  这里要注意的一点，正版的Jlink仿真器1脚是输入引脚，是外部提供参考电平的，但由于现在大部分的JLink仿真器都是学习(dao)版的，1脚不是输入，而是3.3v的输出(并不确定也有可能是5V的, 盗版的Jlink真的是什么乱七八糟的都有)，所以正常情况下可以直接用这个管教来给SPI Flash供电。</p><p>  <strong>关于 nRESET 的注意事项</strong>：如果有另一个设备&#x2F;外围设备也控制 SPI 闪存（例如闪存连接到的 CPU），则 J-Link 的 nRESET 应连接到目标系统的复位或 CPU 的复位引脚确保 J-Link 可以在对 SPI 闪存进行编程时保持 CPU 处于复位状态。</p><p>  <strong>一开始没注意到这个功能, 现在回过头来再看, 有这个功能之后烧芯片简直不要太简单, 根本不需要拆芯片了, 直接用芯片夹就可以烧录了.</strong></p></blockquote><h1 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h1><p>安装Jlink套件的时候会自带<code>JFlashSPI.exe</code>在开始菜单名称应该类似<code>J-Flash SPI</code>, 这是J-Flash的GUI程序,还有一个命令行的不多做介绍.</p><blockquote><p>  如果没有找到自带的, 请更新Jlink套件, 旧版确实不带这个东西.</p><p>  Segger Jlink套件下载链接 <a href="https://www.segger.com/downloads/jlink/">https://www.segger.com/downloads/jlink/</a></p></blockquote><p><img src="/2022/fd90dc4c/image-20220826224742256.png" alt="image-20220826224742256"></p><p>点击<code>target -&gt; connet</code>连接到Jlink, 它会自动检测大部分SPI闪存, </p><blockquote><p>  有时候识别的具体型号并不准确, 但是这不重要他们参数类似, 可以正常完成编程的工作.</p><p>  Jlink支持的SPI Flash型号可以在<a href="https://www.segger.com/products/debug-probes/j-link/technology/cpus-and-devices/supported-spi-flashes/">点击这里</a>找到.</p></blockquote><p>点击<code>file -&gt; open data file </code>我们打开要烧录的文件.</p><blockquote><p>  bin 文件需要设定起始地址</p><p>  hex文件自带了位置信息</p></blockquote><p>点击<code>target -&gt; auto</code>可以自动将文件烧录进去 还会进行读回校验.</p><p>至此烧录完成.</p><p><strong>Tips:</strong></p><blockquote><p>  点击<code>target -&gt; read back</code> 可以将SPI Flash内的数据读取出来<br>  点击<code>options -&gt; settings -&gt; setup -&gt; interface speed</code>可以修改时钟速度. </p></blockquote><p><strong>Other:</strong></p><p>Jlink真的是超级牛的工具, J-Scope, RTT这些都很好用, 还有很多高级功能我还没用上.<br>我前面有写过RTT的笔记, 在调试一个项目的时候没法使用串口, 当时就是用RTT搭建了一个log平台.</p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="winbood-W25Q128封装"><a href="#winbood-W25Q128封装" class="headerlink" title="winbood W25Q128封装"></a>winbood W25Q128封装</h2><p><img src="/2022/fd90dc4c/image-20220826104542006.png" alt="image-20220826104542006"></p><p><img src="/2022/fd90dc4c/20210622091839750557.png" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>flash</tag>
      
      <tag>spi</tag>
      
      <tag>j-link</tag>
      
      <tag>jlink</tag>
      
      <tag>j-tag</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tags Label Category</title>
    <link href="/2022/c65e1067/"/>
    <url>/2022/c65e1067/</url>
    
    <content type="html"><![CDATA[<p>知乎  <a href="https://www.zhihu.com/people/songvision">千鸟</a></p><blockquote><p>  这问题要分两个层面来解读：</p><p>  <strong>首先是Tag与Category的区别。</strong>Category往往限制在一个维度里，当树状结构复杂到不可调和时，出现瓶颈是迟早的事。Category的问题在于，既不能完全满足用户需求，也不能完全表达创建者对内容属性的认知。而Tag反之都成立，完全互补。</p><p>  <strong>其次是Label与Tag的区别。</strong>于对内容的概括出现偏差，但显然这种问题不是tag，在内容组织范畴那应该是什么？答案就是label，除产品描述，其应用范畴还涉及功能名称、模块名称、导航名称、引导文字等等场景。我认为tag与label之间有三个显著差异：</p><ol><li>label是本身的，tag是附加的；</li><li>label强调是一种标志，tag强调是一种记号；</li><li>label标明信息之间的归属，tag区别信息之间的差异。</li></ol></blockquote><p>知乎 郑讯</p><blockquote><p>  Tag，标签，一般包含一段内容的属性，可以是分类，可以是话题，也可以是作者，地理信息等。</p><p>  Label，标记，是网页框架中一个区域的功能概括。比如知乎首页上的“浏览”、“问题”、“通知”就是label。选择不同的标记，相应区域的功能就会发生变化。</p><p>  category，分类，可以理解为种属概念。一段内容有且只有一个种属的分类。和Tag不同的是一段内容可以有多个tag，并且tag是未预先设定的，一段内容可以有多个Tag，也可以没有Tag。但caterory在一个分类标准下只有一个。</p></blockquote><p>知乎 李楠</p><blockquote><p>  <strong>Category</strong></p><p>  Category 是非常理想化和一根筋的分类方式。图书馆这种死板到头的地方用的多。但是他们也遇到了问题：“苏菲的世界”到底是“哲学”，还是“文学”？</p><p>  物理世界无力从根本上解决这种问题（但似乎不少讨论）。问过我们学校的图书馆，似乎他们方式还比较靠谱：<strong>买两本，两处放。</strong></p><p>  分类对象数字化之后， Category 的影响还在（早期的门户找点跨界的东西就很悲剧）。直到 Web2.0 ， Tag 竟然才开始流行。</p><p>  <strong>Tag</strong></p><p>  Tag 是更好的分类方式的原因是：</p><p>  1</p><p>  “类别”本来就不应该事先定义：人不是上帝。</p><p>  从一个个具体对象的“属性”中，总结出“类别”是最自然的模式。也是“人”可以做到的事情。</p><p>  2</p><p>  “属性”本来就应该可以自然的表现为多个。</p><p>  苏菲的世界终于可以自然的打上“哲学”和“文学”的 Tag 了，或者再加个“少儿读物”。这种思考方式比 Category 优雅太多。</p><p>  Tag 最终普及，背后恐怕有<a href="https://www.zhihu.com/search?q=%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:12226710%7D">软件工程</a>上 OO 普及（面向对象）的因素。<strong>“面向对象”不仅仅是的程序构建方式，更是认识世界的方法论的进步。</strong></p><p>  “属性”跟随“对象”，比“对象”属于“类别”更自然，不机械。 。</p><p>  <strong>Tag 的改进</strong></p><p>  Tag 本身也可以看作“对象”。</p><p>  那么就有针对 Tag 的操作，比如“搜索”，“排序”，“关联对象”。也有 Tag 本身的属性，比如“使用次数”，“关注人数”等等。</p><p>  如何能在使用 Tag 的系统中，根据这些数据，计算出最适合的对象，就要靠算法的优化和运营的调整了。</p></blockquote><p>知乎 <a href="https://www.zhihu.com/people/zheng-wei-42-9">榆木脑袋</a></p><blockquote><p>  Catagory是逻辑清晰的。Tag是随意自由的。在看到一个信息的时候我们需要自由捕获自己头脑中的闪光。在重新审视或再利用我们收集的信息时，就需要清晰的逻辑条理。</p><p>  以文件管理为例：</p><p>  在标记Tag时需求有二：一是能够方便增加新的Tag，二是能够很方便的看到已有的Tag，并能同时把已有标签赋予当前信息。</p><p>  在查找文件时个人觉得需要有的功能是：一是有固定的几个入口，也就是根目录；二是可以增加根节点；三是根目录可以指定某几个Tag，也可以不是；三如果根目录不是Tag，需要定义关联到此根目录（分类）下的Tag；四（重点功能）根目录下不直接列出信息或文件（时间长了，某一Tag下文件会相当多），而是列出关联Tag的所有文件的其它Tag，显示为子目录，并标识出此子目录中的文件数量。五（作为管理功能）此时可以定义哪些Tag不在此根目录下出现。六设置某个Tag或某类Tag(文件数量大过一个数量)下仍不列出文件而是继续列出Tag；七子目录（Tag）下，上级目录Tag不再出现。</p><p>  我个人非常偏好使用树形目录结构，但苦恼于文件的多重分类和文件进行多重分类时的繁琐。经过多方搜索只找到三个比较符合的软件，一个是PinKM，一个是蓝码动力图片管理软件，一个是国外的Tabbles。但都因标签管理和整理的繁琐而放弃。</p></blockquote><p><strong>个人理解</strong></p><ul><li>Catagory 是属于严格的分类方法, 一个东西应当只属于一个Catagory内, 而且它是有层级关系的</li><li>Tags 是可有可无的, 一个东西可以有很多的Tags, 它是无层级关系的,</li></ul>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tags</tag>
      
      <tag>label</tag>
      
      <tag>category</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>静态网页 静态博客</title>
    <link href="/2022/f96c3c41/"/>
    <url>/2022/f96c3c41/</url>
    
    <content type="html"><![CDATA[<h1 id="静态网页"><a href="#静态网页" class="headerlink" title="静态网页"></a>静态网页</h1><h1 id="静态网页生成器"><a href="#静态网页生成器" class="headerlink" title="静态网页生成器"></a>静态网页生成器</h1><p><a href="https://jekyllrb.com/">Jekyll</a>（由 Github 构建的用于为其 Github 页面提供支持的 Ruby 生成器）、</p><p><a href="https://gohugo.io/">Hugo</a>（构建在 Go 编程之上的极快静态生成器）语言）和</p><p><a href="https://hexo.io/">Hexo</a>（基于 Node.js 的快速网站生成器）。</p><p><strong>参考</strong></p><p><a href="https://www.techiediaries.com/jekyll-hugo-hexo/">How to Choose the Right Static Generator: Jekyll vs. Hugo vs. Hexo</a></p><p><a href="https://stackshare.io/stackups/hexo-vs-hugo-vs-jekyll">StackShare</a></p><h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><p>TBD</p><h2 id="Jekyll"><a href="#Jekyll" class="headerlink" title="Jekyll"></a>Jekyll</h2><p>TBD</p><h2 id="Hugo"><a href="#Hugo" class="headerlink" title="Hugo"></a>Hugo</h2><p>TBD</p><h1 id="Hexo-1"><a href="#Hexo-1" class="headerlink" title="Hexo"></a>Hexo</h1><h2 id="Hexo-部署"><a href="#Hexo-部署" class="headerlink" title="Hexo 部署"></a>Hexo 部署</h2><p><a href="https://hexo.io/zh-cn/docs/">HEXO文档_参考链接</a></p><p><strong>要求:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Node.js (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)<br></code></pre></td></tr></table></figure><p>安装Node.js，windows下载安装包即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt update <br>sudo apt install nodejs<br>sudo apt install npm<br></code></pre></td></tr></table></figure><p><strong>部署:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 全局安装</span><br>npm install hexo-cli -g<br><span class="hljs-comment"># 或者 local 安装</span><br>npm install hexo-cli<br><br><span class="hljs-comment"># 全局安装</span><br>hexo -v<br><span class="hljs-comment"># local安装</span><br>npx hexo -v<br></code></pre></td></tr></table></figure><h2 id="Hexo-CMD"><a href="#Hexo-CMD" class="headerlink" title="Hexo CMD"></a>Hexo CMD</h2><h3 id="Init-初始化"><a href="#Init-初始化" class="headerlink" title="Init 初始化"></a>Init 初始化</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init [folder]<br></code></pre></td></tr></table></figure><p>新建一个网站。如果没有设置 <code>folder</code> ，Hexo 默认在目前的文件夹建立网站。</p><h3 id="new-新建"><a href="#new-新建" class="headerlink" title="new 新建"></a>new 新建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new [layout] &lt;title&gt;<br>hexo new <span class="hljs-string">&quot;post title with whitespace&quot;</span><br>hexo new page --path about/me <span class="hljs-string">&quot;About me&quot;</span><br>hexo new page -p     about/me <span class="hljs-string">&quot;About me&quot;</span><br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>, <code>--path</code></td><td align="left">自定义新文章的路径</td></tr><tr><td align="left"><code>-r</code>, <code>--replace</code></td><td align="left">如果存在同名文章，将其替换</td></tr><tr><td align="left"><code>-s</code>, <code>--slug</code></td><td align="left">文章的 Slug，作为新文章的文件名和发布后的 URL</td></tr></tbody></table><h3 id="generate-生成"><a href="#generate-生成" class="headerlink" title="generate 生成"></a>generate 生成</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 生成静态文件。</span><br>hexo generate<br><span class="hljs-comment"># 该命令可以简写为</span><br>hexo g<br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">选项</th><th></th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">-d</td><td>–deploy</td><td align="left"><strong>文件生成后立即部署网站</strong></td></tr><tr><td align="left">-w</td><td>–watch</td><td align="left"><strong>监视文件变动</strong></td></tr><tr><td align="left">-b</td><td>–bail</td><td align="left">生成过程中如果发生任何未处理的异常则抛出异常</td></tr><tr><td align="left">-f</td><td>–force</td><td align="left">强制重新生成文件 Hexo 引入了差分机制，<br>如果 <code>public</code> 目录存在，那么 <code>hexo g</code> 只会重新生成改动的文件。<br/>使用该参数的效果接近 <code>hexo clean &amp;&amp; hexo generate</code></td></tr><tr><td align="left">-c</td><td>–concurrency</td><td align="left">最大同时生成文件的数量，默认无限制</td></tr></tbody></table><h3 id="publish-草稿"><a href="#publish-草稿" class="headerlink" title="publish 草稿"></a>publish 草稿</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">hexo publish [layout] <span class="hljs-tag">&lt;<span class="hljs-name">filename</span>&gt;</span><br></code></pre></td></tr></table></figure><p>发表草稿。</p><h3 id="server-服务器"><a href="#server-服务器" class="headerlink" title="server 服务器"></a>server 服务器</h3><p>在服务器启动期间，Hexo 会监视文件变动并自动更新，您无须重启服务器。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta">hexo <span class="hljs-keyword">server</span><br>hexo s<br></code></pre></td></tr></table></figure><p>启动服务器。默认情况下，访问网址为： <code>http://localhost:4000/</code>。</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>, <code>--port</code></td><td align="left">重设端口</td></tr><tr><td align="left"><code>-s</code>, <code>--static</code></td><td align="left">只使用静态文件(不会更新)</td></tr><tr><td align="left"><code>-l</code>, <code>--log</code></td><td align="left">启动日记记录，使用覆盖记录格式</td></tr><tr><td align="left"><code>-i</code></td><td align="left"><code>hexo server -i 192.168.1.1</code> 指定监听的IP</td></tr></tbody></table><h3 id="deploy-部署"><a href="#deploy-部署" class="headerlink" title="deploy 部署"></a>deploy 部署</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment"># 部署网站。</span><br>hexo <span class="hljs-keyword">deploy</span><br><span class="hljs-comment"># 该命令可以简写为：</span><br>hexo d<br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-g</code>, <code>--generate</code></td><td align="left">部署之前预先生成静态文件</td></tr></tbody></table><h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prolog">hexo render &lt;file1&gt; [file2] ...<br></code></pre></td></tr></table></figure><p>渲染文件。</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-o</code>, <code>--output</code></td><td align="left">设置输出路径</td></tr></tbody></table><h3 id="migrate"><a href="#migrate" class="headerlink" title="migrate"></a>migrate</h3><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">hexo</span> migrate &lt;<span class="hljs-keyword">type</span>&gt;<br></code></pre></td></tr></table></figure><p>从其他博客系统 <a href="https://hexo.io/zh-cn/docs/migration">迁移内容</a>。</p><h3 id="clean-清理"><a href="#clean-清理" class="headerlink" title="clean 清理"></a>clean 清理</h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>hexo clean<br></code></pre></td></tr></table></figure><p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p><p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>hexo list &lt;<span class="hljs-keyword">type</span>&gt;<br></code></pre></td></tr></table></figure><p>列出网站资料。</p><h2 id="Hexo-Config-yml"><a href="#Hexo-Config-yml" class="headerlink" title="Hexo _Config.yml"></a>Hexo _Config.yml</h2><blockquote><h3 id="Home-page-setting"><a href="#Home-page-setting" class="headerlink" title="Home page setting"></a>Home page setting</h3><p>  <code>index_generator.order_by</code>  文章的顺序</p><ul><li><code>-date</code> 默认情况下按日期降序排序(从新到旧)。</li><li><code>-update</code> 按更新时间排序(<code>-</code> &#x3D; 从新到旧)。</li></ul></blockquote><h1 id="Hexo-Theme"><a href="#Hexo-Theme" class="headerlink" title="Hexo Theme"></a>Hexo Theme</h1><p>我是直接在github搜索 <code>hexo theme</code>看到了几个 star 比较多而且比较活跃的 repository </p><ul><li><p><strong><a href="https://github.com/ppoffice/hexo-theme-icarus">icarus</a></strong> 5.5K star</p><p><img src="/2022/f96c3c41/68747470733a2f2f70706f66666963652e6769746875622e696f2f6865786f2d7468656d652d6963617275732f67616c6c6572792f707265766965772e706e673f31.png" alt="img"></p></li><li><p><strong><a href="https://github.com/fluid-dev/hexo-theme-fluid">fluid</a></strong> 4.8K star</p><p><img src="/2022/f96c3c41/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666c7569642d6465762f737461746963406d61737465722f6865786f2d7468656d652d666c7569642f73637265656e73686f74732f696e6465782e706e67.png" alt="ScreenShot"></p></li><li><p><a href="https://github.com/blinkfox/hexo-theme-matery">matery</a>(blinkfox) 4.5K star</p><p><img src="/2022/f96c3c41/687474703a2f2f7374617469632e626c696e6b666f782e636f6d2f6d61746572792d32303138313230322d312e706e67.png" alt="首页"></p><p><img src="/2022/f96c3c41/687474703a2f2f7374617469632e626c696e6b666f782e636f6d2f6d61746572792d32303138313230322d332e706e67.png" alt="首页文章列表"></p></li><li><p><strong><a href="https://github.com/jerryc127/hexo-theme-butterfly">butterfly</a></strong> 4.3K star</p><p><img src="/2022/f96c3c41/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f6a65727279633132372f43444e406d322f696d672f7468656d652d627574746572666c792d726561646d652e706e67.png" alt="img"></p></li><li><p><a href="https://github.com/volantis-x/hexo-theme-volantis">volantis</a> 1.5k star</p><p><img src="/2022/f96c3c41/68747470733a2f2f692e6c6f6c692e6e65742f323032302f30332f31382f663550516c576973766d397a62674b2e6a7067.jpeg" alt="img"></p><p><img src="/2022/f96c3c41/68747470733a2f2f692e6c6f6c692e6e65742f323032302f30332f31382f585742476639354532743162646e6c2e6a7067.jpeg" alt="img"></p></li></ul><p>其中 <code>fluid</code> 和 <code>volantis</code> 最对我胃口, 最后选择的 <code>fluid</code>, 后期可能会改成<code>volantis</code>或者<code>icarus</code>试试看, 主要是喜欢简洁些, 又能有一定的观赏性的.</p><h2 id="Fluid"><a href="#Fluid" class="headerlink" title="Fluid"></a>Fluid</h2><p>参考文档</p><p><a href="https://hexo.fluid-dev.com/docs/guide/">https://hexo.fluid-dev.com/docs/guide/</a></p><p>theme 的 Github</p><p><a href="https://github.com/fluid-dev/hexo-theme-fluid">https://github.com/fluid-dev/hexo-theme-fluid</a></p><h3 id="自带的内置图标库"><a href="#自带的内置图标库" class="headerlink" title="自带的内置图标库"></a>自带的内置图标库</h3><p><a href="https://hexo.fluid-dev.com/docs/icon/#%E5%86%85%E7%BD%AE%E7%A4%BE%E4%BA%A4%E5%9B%BE%E6%A0%87">内置社交图标</a> </p><p><img src="/2022/f96c3c41/iconfont.f8319467.png" alt="内置图标"></p><h1 id="Hexo-Note"><a href="#Hexo-Note" class="headerlink" title="Hexo Note"></a>Hexo Note</h1><h2 id="Hexo-Permalink简化"><a href="#Hexo-Permalink简化" class="headerlink" title="Hexo Permalink简化"></a>Hexo Permalink简化</h2><p>参考:</p><p><a href="https://blog.csdn.net/Galahadzhou/article/details/105355733">Hexo Permalink简化</a></p><p>Note:</p><p>使用<code>hexo-abbrlink</code>插件实现</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># install</span><br>npm install hexo-abbrlink --save<br><span class="hljs-comment"># setting edit _config.yml</span><br>permalink: posts/:abbrlink.html<br>abbrlink:<br>  alg: crc32  <span class="hljs-comment"># 算法：crc16(default) and crc32</span><br>  rep: hex    <span class="hljs-comment"># 进制：dec(default) and hex</span><br><br></code></pre></td></tr></table></figure><h2 id="hexo-图片链接问题"><a href="#hexo-图片链接问题" class="headerlink" title="hexo 图片链接问题"></a>hexo 图片链接问题</h2><p><strong><code>hexo</code>本地图片显示问题</strong></p><p>使用<code>hexo</code>生成静态资源后,由于<code>url</code>的问题会出现图片加载的问题,现在网上的文章及官方的解决方案大概分为三种:</p><ol><li>将图片放入<code>source/images</code>目录下,每次<code>generate</code>都会生成图片,在使用相对或绝对路径进行引用</li><li>配置<code>hexo</code>的<code>_config.yml</code>文件, 将 <code>post_asset_folder</code> 设置为<code>true</code>, 这样每次new 生成一个文章时都会同步生成一个同名的文件夹,然后设置相对或绝对路径. </li><li>使用<code>hexo</code>官方的解决方案,使用模版变量, <code>&#123;% asset_img slug [title] %&#125; </code> </li><li>!new!. <code>hexo init</code>的时候会自动copy一个插件 <code>hexo-renderer-marked</code> 这个插件可以开启相对路径的支持,但是需要改一些代码</li></ol><p>但是在配置过程中发现这三种方式都多多少少存在一些问题,前两中首页跟内容页会有一个加载失败的问题,而第三种则失去了<code>markdown</code>的意义.</p><p><strong>方法四:</strong></p><p>官方手册上提到过, <a href="https://github.com/hexojs/hexo-renderer-marked">hexo-renderer-marked</a> 3.1.0已经开始支持相对路径了.但是可以看到它支持的路径似乎并不合理, 其他的md阅读器是不能识别这样的路径的.</p><p><img src="/2022/f96c3c41/image-20220815153651988.png" alt="image-20220815153651988"></p><p>参考: <a href="https://github.com/hexojs/hexo-renderer-marked/issues/216">https://github.com/hexojs/hexo-renderer-marked/issues/216</a></p><ol><li><p>修改<code>_config.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">marked:</span><br>  <span class="hljs-attr">prependRoot:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">postAsset:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li><li><p>修改文件<code>node_modules\hexo-renderer-marked\lib\renderer.js</code></p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (!<span class="hljs-regexp">/^(#|\/\/|http(s)?:)/</span>.<span class="hljs-title function_">test</span>(href) &amp;&amp; !relative_link &amp;&amp; prependRoot) &#123;<br>  <span class="hljs-keyword">if</span> (!href.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;/&#x27;</span>) &amp;&amp; !href.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;\\&#x27;</span>) &amp;&amp; postPath) &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title class_">PostAsset</span> = hexo.<span class="hljs-title function_">model</span>(<span class="hljs-string">&#x27;PostAsset&#x27;</span>);<br>    <span class="hljs-comment">// findById requires forward slash</span><br>    <span class="hljs-comment">// ***************** Add the following code *******************</span><br>    <span class="hljs-keyword">const</span> fixPostPath = <span class="hljs-title function_">join</span>(postPath, <span class="hljs-string">&#x27;../&#x27;</span>);<br>    <span class="hljs-keyword">const</span> asset = <span class="hljs-title class_">PostAsset</span>.<span class="hljs-title function_">findById</span>(<span class="hljs-title function_">join</span>(fixPostPath, href.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\\/g</span>, <span class="hljs-string">&#x27;/&#x27;</span>)));<br>    <span class="hljs-comment">// const asset = PostAsset.findById(join(postPath, href.replace(/\\/g, &#x27;/&#x27;)));</span><br>    <span class="hljs-comment">// ************************** End *****************************</span><br>    <span class="hljs-comment">// asset.path is backward slash in Windows</span><br>    <span class="hljs-keyword">if</span> (asset) href = asset.<span class="hljs-property">path</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\\/g</span>, <span class="hljs-string">&#x27;/&#x27;</span>);<br>  &#125;<br>  href = url_for.<span class="hljs-title function_">call</span>(hexo, href);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>enjoy it</li></ol><p><strong>方法二:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"># 设置<br><span class="hljs-attr">post_asset_folder</span>:<span class="hljs-literal">true</span><br># 安装插件 asset-image<br>npm install <span class="hljs-attr">https</span>:<span class="hljs-comment">//github.com/CodeFalling/hexo-asset-image  --save</span><br># typora中设置图片为相对路径 看下图<br>./$&#123;filename&#125;<br># 运行查看<br>hexo clean &amp;&amp; hexo generate &amp;&amp; hexo s <br></code></pre></td></tr></table></figure><p><img src="/2022/f96c3c41/image-20220815133503275.png" alt="image-20220815133503275"></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><blockquote><p>   Env:使用方法四</p><ul><li>文件名不能带有空格, title 可以带空格 (<code>hexo new</code>的时候需要注意这一点)<ul><li>修改 <code>node_modules\hexo-renderer-marked\lib\renderer.js</code>文件可能可以改善这点. -&gt; TBD</li></ul></li><li>md文件名要和图片等等资源文件夹同名 -&gt; 注定了不能使用 <code>./$&#123;filename&#125;.assets</code>这种方案, 一定要改成<code>./$&#123;filename&#125;</code>才行</li></ul></blockquote><h2 id="Hexo-跳过一些文件-不渲染某些文件"><a href="#Hexo-跳过一些文件-不渲染某些文件" class="headerlink" title="Hexo 跳过一些文件,不渲染某些文件"></a>Hexo 跳过一些文件,不渲染某些文件</h2><p>搜索引擎确认网站所有权时往往会提供一个html文件来进行验证，要是这个文件被渲染了，验证自然就会失败了。或者，有时候会写一些简单的html示例页面或<code>README.md</code>，这也是不希望Hexo渲染的。因此有必要针对某个文件或者目录进行排除。</p><p>Hexo博客的基本内容是一些Markdown文件，放在<code>source/_post</code>文件夹下，每个文件对应一篇文章。除此之外，放在<code>source</code>文件夹下的所有开头不是下划线的文件，在<code>hexo generate</code>的时候，都会被拷贝到<code>public</code>文件夹下。但是，Hexo默认会渲染所有的HTML和Markdown文件，导致我的README.md直接转成html格式了。。。</p><p>怎么样避开这个坑呢？如果只有一个HTML文件的话，可以简单地在文件开头加上<code>layout: false</code>一行即可：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">layout:</span> <span class="hljs-literal">false</span><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-string">&lt;html&gt;</span><br><span class="hljs-string">...</span><br></code></pre></td></tr></table></figure><p>如果有多个要避开渲染的md文件，显然是不可能使用这种方法的。这时候需要使用<code>skip_render</code>配置。根据<a href="https://hexo.io/zh-cn/docs/configuration.html">Hexo文档</a>中的说明，通过在<code>_config.yml</code>配置文件中使用<code>skip_render</code>参数，可以跳过指定文件的渲染。使用方式如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">skip_render</span>:<span class="hljs-meta"> [games/**, depview/**, knowledge/**]</span><br></code></pre></td></tr></table></figure><p>这里的路径匹配可以使用正则表达式。</p><p><strong>注意：<code>skip_render</code>参数设置的路径是相对于<code>source</code>目录的路径。</strong>例如，需要跳过渲染source&#x2F;README.md，只需要设置 <code>skip_render:README.md</code>。</p><p>在设置了跳过渲染之后，最好使用<code>hexo clean</code>清除以前的编译结果，保证配置生效。</p><h2 id="hexo-开启RSS订阅-feed-atom"><a href="#hexo-开启RSS订阅-feed-atom" class="headerlink" title="hexo 开启RSS订阅 feed atom"></a>hexo 开启RSS订阅 feed atom</h2><p>基于<code>hexo-generator-feed</code></p><p>先安装这个包:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-generator-feed<br></code></pre></td></tr></table></figure><p>然后在在<code>_config.yml</code>文件中配置该插件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feed:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">atom</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">atom.xml</span><br>    <span class="hljs-attr">limit:</span> <span class="hljs-number">20</span><br>    <span class="hljs-attr">hub:</span><br>    <span class="hljs-attr">content:</span><br>    <span class="hljs-attr">content_limit:</span><br>    <span class="hljs-attr">content_limit_delim:</span> <span class="hljs-string">&#x27; &#x27;</span><br>    <span class="hljs-attr">order_by:</span> <span class="hljs-string">-date</span><br>    <span class="hljs-attr">icon:</span> <span class="hljs-string">/images/favicon.png</span><br></code></pre></td></tr></table></figure><blockquote><p>  参数的含义：</p><ul><li><code>type</code>: <code>RSS</code>的类型(<code>atom/rss2</code>)</li><li><code>path</code>: 文件路径,默认是<code>atom.xml/rss2.xml</code></li><li><code>limit</code>: 展示文章的数量,使用<strong>0</strong>或则<strong>false</strong>代表展示全部</li><li><code>hub</code>:</li><li><code>content</code>: 在<code>RSS</code>文件中是否包含内容 ,有3个值 <code>true/false</code>默认不填为<code>false</code></li><li><code>content_limit</code>: 指定内容的长度作为摘要,仅仅在上面<code>content</code>设置为<code>false</code>和<code>没有自定义的描述出现</code></li><li><code>content_limit_delim</code>: 上面截取描述的分隔符,截取内容是以指定的这个分隔符作为截取结束的标志.在达到规定的内容长度之前最后出现的这个分隔符之前的内容,，防止从中间截断.</li><li><code>order_by</code>: 顺序排列方式</li><li><code>icon</code>: 图标路径</li></ul></blockquote><p>配置好之后运行<code>hexo clean &amp; hexo g</code>就可以找到你博客的<code>pubilc</code> 文件夹下发现<code>atom.xml</code>文件了</p><p>我们可以在<code>关于(about)</code>页面添加RSS源, 有些主题可以在头像下面自动开启, 这些都是后话了.</p><p>配置RSS的时候发现还有一些其他的推送方式, 比如邮件推送, 浏览器通知推送等等.</p><h3 id="RSS阅读器"><a href="#RSS阅读器" class="headerlink" title="RSS阅读器"></a>RSS阅读器</h3><p><a href="https://feedly.com/">Feedly.com</a> 这个比较满意, 文章显示和界面都不错</p><p><a href="https://www.inoreader.com/">inoreader</a>: 订阅的文章展示效果也还不错(卡片形式).</p><p><a href="https://theoldreader.com/">the old reader</a>: 这个是比较老牌的RSS阅读器了</p><p>参考链接:</p><p><a href="https://segmentfault.com/a/1190000012647294">为hexo博客添加RSS订阅功能</a></p><p><a href="https://sean10.github.io/2020/06/27/hexo%E5%BC%80%E5%90%AFatom%E8%AE%A2%E9%98%85/">hexo开启atom订阅</a></p><h2 id="hexo-静态网页压缩"><a href="#hexo-静态网页压缩" class="headerlink" title="hexo 静态网页压缩"></a>hexo 静态网页压缩</h2><p>了解到有三个插件可以做到这个功能(<code>hexo-neat</code>, <code>gulp</code>, <code>Hexo-all-minifier</code>)</p><p><code>gulp</code>存在各种乱七八糟的依赖关系, 推荐直接用<code>Hexo-all-minifier</code>一套走.</p><h3 id="1-hexo-neat"><a href="#1-hexo-neat" class="headerlink" title="1. hexo-neat"></a>1. hexo-neat</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">npm install hexo-neat --save</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在 _config.yml 添加配置</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">博文压缩</span><br>neat_enable: true<br><span class="hljs-meta prompt_"># </span><span class="language-bash">压缩html</span><br>neat_html:<br>  enable: true<br>  exclude:<br><span class="hljs-meta prompt_"># </span><span class="language-bash">压缩css</span><br>neat_css:<br>  enable: true<br>  exclude:<br>    - &#x27;**/*.min.css&#x27;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">压缩js</span><br>neat_js:<br>  enable: true<br>  mangle: true<br>  output:<br>  compress:<br>  exclude:<br>    - &#x27;**/*.min.js&#x27;<br>    - &#x27;**/jquery.fancybox.pack.js&#x27;<br>    - &#x27;**/index.js&#x27;<br></code></pre></td></tr></table></figure><h3 id="2-gulp"><a href="#2-gulp" class="headerlink" title="2. gulp"></a>2. gulp</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装gulp</span><br>npm install gulp --save<br><span class="hljs-comment"># 安装gulp依赖</span><br>npm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp-imagemin --save<br></code></pre></td></tr></table></figure><p><strong>创建 gulpfile.js 文件</strong></p><p>在<code>Hexo</code>站点根目录下创建<code>gulpfile.js</code>文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-keyword">var</span> gulp = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gulp&#x27;</span>);<br><span class="hljs-keyword">var</span> minifycss = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gulp-minify-css&#x27;</span>);<br><span class="hljs-keyword">var</span> uglify = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gulp-uglify&#x27;</span>);<br><span class="hljs-keyword">var</span> htmlmin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gulp-htmlmin&#x27;</span>);<br><span class="hljs-keyword">var</span> htmlclean = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gulp-htmlclean&#x27;</span>);<br><span class="hljs-keyword">var</span> imagemin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gulp-imagemin&#x27;</span>);<br><span class="hljs-comment">// 压缩css文件</span><br>gulp.<span class="hljs-title function_">task</span>(<span class="hljs-string">&#x27;minify-css&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> gulp.<span class="hljs-title function_">src</span>(<span class="hljs-string">&#x27;./public/**/*.css&#x27;</span>)<br>  .<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">minifycss</span>())<br>  .<span class="hljs-title function_">pipe</span>(gulp.<span class="hljs-title function_">dest</span>(<span class="hljs-string">&#x27;./public&#x27;</span>));<br>&#125;);<br><span class="hljs-comment">// 压缩html文件</span><br>gulp.<span class="hljs-title function_">task</span>(<span class="hljs-string">&#x27;minify-html&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> gulp.<span class="hljs-title function_">src</span>(<span class="hljs-string">&#x27;./public/**/*.html&#x27;</span>)<br>  .<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">htmlclean</span>())<br>  .<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">htmlmin</span>(&#123;<br>    <span class="hljs-attr">removeComments</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">minifyJS</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">minifyCSS</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">minifyURLs</span>: <span class="hljs-literal">true</span>,<br>  &#125;))<br>  .<span class="hljs-title function_">pipe</span>(gulp.<span class="hljs-title function_">dest</span>(<span class="hljs-string">&#x27;./public&#x27;</span>))<br>&#125;);<br><span class="hljs-comment">// 压缩js文件</span><br>gulp.<span class="hljs-title function_">task</span>(<span class="hljs-string">&#x27;minify-js&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> gulp.<span class="hljs-title function_">src</span>([<span class="hljs-string">&#x27;./public/**/.js&#x27;</span>,<span class="hljs-string">&#x27;!./public/js/**/*min.js&#x27;</span>])<br>        .<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">uglify</span>())<br>        .<span class="hljs-title function_">pipe</span>(gulp.<span class="hljs-title function_">dest</span>(<span class="hljs-string">&#x27;./public&#x27;</span>));<br>&#125;);<br><span class="hljs-comment">// 压缩 public/demo 目录内图片</span><br>gulp.<span class="hljs-title function_">task</span>(<span class="hljs-string">&#x27;minify-images&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    gulp.<span class="hljs-title function_">src</span>(<span class="hljs-string">&#x27;./public/demo/**/*.*&#x27;</span>)<br>        .<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">imagemin</span>(&#123;<br>           <span class="hljs-attr">optimizationLevel</span>: <span class="hljs-number">5</span>, <span class="hljs-comment">//类型：Number  默认：3  取值范围：0-7（优化等级）</span><br>           <span class="hljs-attr">progressive</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">//类型：Boolean 默认：false 无损压缩jpg图片</span><br>           <span class="hljs-attr">interlaced</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">//类型：Boolean 默认：false 隔行扫描gif进行渲染</span><br>           <span class="hljs-attr">multipass</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">//类型：Boolean 默认：false 多次优化svg直到完全优化</span><br>        &#125;))<br>        .<span class="hljs-title function_">pipe</span>(gulp.<span class="hljs-title function_">dest</span>(<span class="hljs-string">&#x27;./public/uploads&#x27;</span>));<br>&#125;);<br><span class="hljs-comment">// 默认任务 gulp 4.0 适用的方式</span><br>gulp.<span class="hljs-title function_">task</span>(<span class="hljs-string">&#x27;default&#x27;</span>, gulp.<span class="hljs-title function_">parallel</span>(<span class="hljs-string">&#x27;minify-html&#x27;</span>, <span class="hljs-string">&#x27;minify-css&#x27;</span>, <span class="hljs-string">&#x27;minify-js&#x27;</span><br> <span class="hljs-comment">//build the website</span><br>));<br></code></pre></td></tr></table></figure><p>只要每次在执行<code>hexo g</code>命令后执行<code>gulp</code>就可以进行静态资源压缩，压缩后再同步到github上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo cl &amp; hexo g &amp; gulp<br>hexo d<br></code></pre></td></tr></table></figure><h4 id="注意-这里部署的时候出了一个问题"><a href="#注意-这里部署的时候出了一个问题" class="headerlink" title="注意: 这里部署的时候出了一个问题"></a><strong>注意: 这里部署的时候出了一个问题</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">Error [ERR_REQUIRE_ESM]: require() of ES Module xxx\hexo\node_modules\gulp-imagemin\index.js from xxx\hexo\gulpfile.js not supported.<br>Instead change the require of index.js <span class="hljs-keyword">in</span> xxx\hexo\gulpfile.js to a dynamic import() <span class="hljs-built_in">which</span> is available <span class="hljs-keyword">in</span> all CommonJS modules.<br>    at Object.&lt;anonymous&gt; (xxx\hexo\gulpfile.js:6:16)<br>    at async Promise.all (index 0) &#123;<br>  code: <span class="hljs-string">&#x27;ERR_REQUIRE_ESM&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>  gulp-imagemin 8.0.0 and above are now ESM only. You can downgrade gulp-imagemin to 7.1.0 which is commonjs and it should work fine.</p><blockquote><p>  This package is now pure ESM. Please read this.</p></blockquote><p>  <a href="https://github.com/sindresorhus/gulp-imagemin/releases/tag/v8.0.0">https://github.com/sindresorhus/gulp-imagemin/releases/tag/v8.0.0</a></p></blockquote><p><strong>最终找到说是包的版本太高导致的</strong></p><p>重新安装特定版本的包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 先卸载掉这些包</span><br>npm uninstall gulp<br>npm uninstall gulp-htmlclean gulp-htmlmin gulp-clean-css gulp-uglify gulp-imagemin<br>npm uninstall gulp-minify-css <br><br><span class="hljs-comment"># 重新安装</span><br>npm install gulp@4.0.2 --save<br>npm install gulp-htmlclean@4.0.2 gulp-htmlmin@5.0.1 gulp-clean-css@4.2.0 gulp-uglify@3.0.2 gulp-imagemin@7.1.0 --save<br>npm install gulp-babel@8.0.0 babel-preset-env@1.7.0 babel-preset-mobx@2.0.0 --save<br>npm install gulp-miniify-css@1.2.4 -save<br></code></pre></td></tr></table></figure><blockquote><p>  包的版本可以参考这个<br>  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;babel-preset-env&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^1.7.0&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;babel-preset-mobx&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^2.0.0&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;gulp&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^4.0.2&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;gulp-babel&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^8.0.0&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;gulp-clean-css&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^4.2.0&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;gulp-htmlclean&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^2.7.22&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;gulp-htmlmin&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^5.0.1&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;gulp-imagemin&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^7.1.0&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;gulp-uglify&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^3.0.2&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;gulp-minify-css&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^1.2.4&quot;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure></p></blockquote><p>把<code>gulpfile.js</code>也改动了一下, </p><p>在<code>minify-images</code>项里面我的图片是随文章存放的, 并不是全部存放在<code>img</code>等文件夹下面, 所以只能用全文件匹配去做图片压缩, 代价就是速度很忙, 希望有大佬来指点一下如何更好的修改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> gulp      = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gulp&#x27;</span>)<br><span class="hljs-keyword">let</span> htmlmin   = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gulp-htmlmin&#x27;</span>)<br><span class="hljs-keyword">let</span> htmlclean = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gulp-htmlclean&#x27;</span>)<br><span class="hljs-keyword">let</span> uglify    = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gulp-uglify&#x27;</span>)<br><span class="hljs-keyword">let</span> imagemin  = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gulp-imagemin&#x27;</span>)<br><span class="hljs-keyword">var</span> minifycss = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gulp-minify-css&#x27;</span>);<br><br><span class="hljs-comment">// 压缩html</span><br>gulp.<span class="hljs-title function_">task</span>(<span class="hljs-string">&#x27;minify-html&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 匹配所有 .html结尾的文件</span><br>    <span class="hljs-keyword">return</span> gulp.<span class="hljs-title function_">src</span>(<span class="hljs-string">&#x27;./public/**/*.html&#x27;</span>)<br>        .<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">htmlclean</span>())<br>        .<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">htmlmin</span>(&#123;<br>            <span class="hljs-attr">removeComments</span>: <span class="hljs-literal">true</span>,<br>            <span class="hljs-attr">minifyJS</span>: <span class="hljs-literal">true</span>,<br>            <span class="hljs-attr">minifyCSS</span>: <span class="hljs-literal">true</span>,<br>            <span class="hljs-attr">minifyURLs</span>: <span class="hljs-literal">true</span>,<br>        &#125;))<br>        .<span class="hljs-title function_">pipe</span>(gulp.<span class="hljs-title function_">dest</span>(<span class="hljs-string">&#x27;./public&#x27;</span>))<br>&#125;);<br><br><span class="hljs-comment">// 压缩css</span><br>gulp.<span class="hljs-title function_">task</span>(<span class="hljs-string">&#x27;minify-css&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> gulp.<span class="hljs-title function_">src</span>(<span class="hljs-string">&#x27;./public/**/*.css&#x27;</span>)<br>        .<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">minifycss</span>())<br>        .<span class="hljs-title function_">pipe</span>(gulp.<span class="hljs-title function_">dest</span>(<span class="hljs-string">&#x27;./public&#x27;</span>));<br>&#125;);<br><br><span class="hljs-comment">// 压缩js</span><br>gulp.<span class="hljs-title function_">task</span>(<span class="hljs-string">&#x27;minify-js&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> gulp.<span class="hljs-title function_">src</span>([<span class="hljs-string">&#x27;./public/**/.js&#x27;</span>, <span class="hljs-string">&#x27;!./public/js/**/*min.js&#x27;</span>])<br>        .<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">uglify</span>())<br>        .<span class="hljs-title function_">pipe</span>(gulp.<span class="hljs-title function_">dest</span>(<span class="hljs-string">&#x27;./public&#x27;</span>));<br>&#125;)<br><br><span class="hljs-comment">// 压缩图片</span><br>gulp.<span class="hljs-title function_">task</span>(<span class="hljs-string">&#x27;minify-images&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> gulp.<span class="hljs-title function_">src</span>(<span class="hljs-string">&#x27;./public/**/*.*&#x27;</span>)<br>        .<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">imagemin</span>(&#123;<br>            <span class="hljs-attr">optimizationLevel</span>: <span class="hljs-number">5</span>, <span class="hljs-comment">//类型：Number  默认：3  取值范围：0-7（优化等级）</span><br>            <span class="hljs-attr">progressive</span>: <span class="hljs-literal">true</span>,    <span class="hljs-comment">//类型：Boolean 默认：false 无损压缩jpg图片</span><br>            <span class="hljs-attr">interlaced</span>: <span class="hljs-literal">false</span>,    <span class="hljs-comment">//类型：Boolean 默认：false 隔行扫描gif进行渲染</span><br>            <span class="hljs-attr">multipass</span>: <span class="hljs-literal">false</span>,     <span class="hljs-comment">//类型：Boolean 默认：false 多次优化svg直到完全优化</span><br>        &#125;))<br>        .<span class="hljs-title function_">pipe</span>(gulp.<span class="hljs-title function_">dest</span>(<span class="hljs-string">&#x27;./public&#x27;</span>));<br>&#125;)<br><br>gulp.<span class="hljs-title function_">task</span>(<span class="hljs-string">&#x27;default&#x27;</span>, gulp.<span class="hljs-title function_">series</span>(<span class="hljs-string">&#x27;minify-html&#x27;</span>, <span class="hljs-string">&#x27;minify-css&#x27;</span>, <span class="hljs-string">&#x27;minify-js&#x27;</span>, <span class="hljs-string">&#x27;minify-images&#x27;</span>))<br></code></pre></td></tr></table></figure><h3 id="3-Hexo-all-minifier"><a href="#3-Hexo-all-minifier" class="headerlink" title="3. Hexo-all-minifier"></a>3. Hexo-all-minifier</h3><blockquote><p>  <a href="https://github.com/chenzhutian/hexo-all-minifier">https://github.com/chenzhutian/hexo-all-minifier</a></p><p>  <a href="https://archive.vincent0700.com/2019/12/31/034_Usage_of_hexo-all-minifier_copy/">Hexo 资源压缩 | hexo-all-minifier</a></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装</span><br>npm install hexo-all-minifier --save<br><br><span class="hljs-comment"># 在_config.yml文件添加配置</span><br>all_minifier: <span class="hljs-literal">true</span><br><br><span class="hljs-comment"># </span><br>hexo cl &amp; hexo g <br></code></pre></td></tr></table></figure><h2 id="Hexo-Sitemap"><a href="#Hexo-Sitemap" class="headerlink" title="Hexo Sitemap"></a>Hexo Sitemap</h2><blockquote><p>   据网友所言: 谷歌就xx乱爬, 百度就xx乱删, 必应就xx不收录</p></blockquote><p>为了让博文能够被google或百度检索，需要先将网站收录到他们的库里面，我们可以在谷歌的站长平台里面提交我们的sitemap文件，告诉浏览器应该我们的站点有哪些页面，这样他就会去爬取收录了。</p><blockquote><p>  站点地图是一种文件，您可以在其中提供与您网站中的网页、视频或其他文件有关的信息，还可以说明这些内容之间的关系。Google 等搜索引擎会读取此文件，以便更高效地抓取您的网站。站点地图会告诉 Google 您认为网站中的哪些网页和文件比较重要，还会提供与这些文件有关的重要信息。例如，网页上次更新的时间和网页是否有任何备用的语言版本。</p><p>  您可以使用站点地图提供与特定类型的网页内容（包括<a href="https://developers.google.com/search/docs/advanced/sitemaps/video-sitemaps">视频</a>、<a href="https://developers.google.com/search/docs/advanced/sitemaps/image-sitemaps">图片</a>和<a href="https://developers.google.com/search/docs/advanced/sitemaps/news-sitemap">新闻</a>内容）有关的信息。例如：</p><ul><li>站点地图视频条目可以指定视频的时长、评分以及适合哪些年龄段的受众。</li><li>站点地图图片条目中可包含网页中所含图片的位置。</li><li>站点地图新闻条目中可包含报道标题和发布日期。</li></ul><p>  <strong>我需要站点地图吗？</strong></p><p>  如果您网站上的网页链接得当，那么 Google 通常能够发现其中的大多数网页。链接得当是指您认为重要的所有网页都可以通过某些形式的导航（例如您网站的菜单，或您放入网页中的链接）抵达。即便如此，站点地图仍有助于我们更加高效地抓取规模更大、更复杂的网站或更特殊的文件。</p></blockquote><h3 id="生成sitemap-xml"><a href="#生成sitemap-xml" class="headerlink" title="生成sitemap.xml"></a>生成<code>sitemap.xml</code></h3><p>首先我们安装生成sitemao的插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 谷歌的</span><br>npm install hexo-generator-sitemap --save<br><span class="hljs-comment"># 百度的</span><br>npm install hexo-generator-baidu-sitemap --save<br></code></pre></td></tr></table></figure><p>修改配置文件<code>_config.yml</code>增加下面这些内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">Plugins:<br>- hexo-generator-sitemap<br>- hexo-generator-baidu-sitemap<br><br>baidusitemap:<br>  path: baidusitemap.xml<br>sitemap:<br>  path: sitemap.xml<br></code></pre></td></tr></table></figure><p>生成<code>sitemap.xml</code>文件, 重新生成网站, 在网站根目录就可以看到<code>sitemap.xml</code>文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo cl &amp; hexo g <br></code></pre></td></tr></table></figure><h3 id="提交sitemap-xml"><a href="#提交sitemap-xml" class="headerlink" title="提交sitemap.xml"></a>提交<code>sitemap.xml</code></h3><p><a href="https://www.google.com/webmasters/tools">GoogleSearchConsole</a></p><p><a href="https://www.bing.com/webmasters/">BingWebMaster</a></p><p><a href="https://ziyuan.baidu.com/site/index">百度资源平台</a></p><p><strong>下面讲一下谷歌的</strong></p><p>登录<a href="https://www.google.com/webmasters/tools">GoogleSearchConsole</a>, 按照提示验证站点的所有权</p><p>打开谷歌控制台选择-&gt;<strong>索引</strong>-&gt;<strong>站点地图</strong>，在添加新的站点地图中填入你的<code>sitemap.xml</code>的路径, 这里直接写<code>sitemap.xml</code>即可。</p><p><img src="/2022/f96c3c41/image-20220918004138059.png" alt="image-20220918004138059"></p><blockquote><p>   这个谷歌真是让我大无语, 一直显示无法获取, 一直没法解决这个问题, 网址检查显示没什么问题, 但是一直显示无法获取真是麻了.</p><p>  求助群友后他们推荐使用 Hexo-SEO-AutoPush</p></blockquote><h3 id="收录查询"><a href="#收录查询" class="headerlink" title="收录查询"></a>收录查询</h3><ol><li><p>通过网站管理平台的控制台去看数据</p></li><li><p>搜索引擎直接搜索</p></li></ol><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">site:</span>oikiou.top<br></code></pre></td></tr></table></figure><h3 id="手动生成Sitemap文件"><a href="#手动生成Sitemap文件" class="headerlink" title="手动生成Sitemap文件"></a>手动生成Sitemap文件</h3><p><a href="https://www.xml-sitemaps.com/">https://www.xml-sitemaps.com/</a></p><h2 id="Hexo-SEO-AutoPush的使用"><a href="#Hexo-SEO-AutoPush的使用" class="headerlink" title="Hexo-SEO-AutoPush的使用"></a>Hexo-SEO-AutoPush的使用</h2><p><a href="https://github.com/Lete114/Hexo-SEO-AutoPush">https://github.com/Lete114/Hexo-SEO-AutoPush</a></p><blockquote><p>  注意以下几点: </p><ol><li>由于生成的 actions 是在<code>.github/workflows/HexoSeoAutoPush.yml</code>，点开头的文件或文件夹都会被视为隐藏文件，所以 hexo 不会将隐藏文件部署到 pages，需要新增配置<code>ignore_hidden</code></li></ol><pre><code class="hljs"> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">deploy:<br> ignore_hidden: <span class="hljs-literal">false</span> <span class="hljs-comment"># 忽略隐藏文件及文件夹(目录)</span><br></code></pre></td></tr></table></figure> </code></pre><ol start="2"><li><p>Bing的<code>API</code>在登录控制台后的<em>右上角齿轮上</em>可以找到, 如果找不到可能是界面更新导致的, 请参考官方文档</p></li><li><p>注意google的信息填写方式</p><p><code>google_private_key</code>是填写Json内的 <code>private_key </code> 不是<code>private_key_id </code>注意区分. </p><p>而且<code>google_private_key </code> 是带双引号的需要注意, 而<code>google_client_email</code>填写的时候是不带双引号的.</p><table><thead><tr><th>名称</th><th>形似</th><th>说明</th></tr></thead><tbody><tr><td>google_client_email</td><td><a href="mailto:&#120;&#x78;&#120;&#64;&#x78;&#x78;&#x78;&#46;&#x78;&#x78;&#120;&#46;&#x67;&#115;&#101;&#114;&#118;&#x69;&#99;&#101;&#97;&#x63;&#99;&#111;&#117;&#x6e;&#x74;&#x2e;&#x63;&#111;&#x6d;">&#120;&#x78;&#120;&#64;&#x78;&#x78;&#x78;&#46;&#x78;&#x78;&#120;&#46;&#x67;&#115;&#101;&#114;&#118;&#x69;&#99;&#101;&#97;&#x63;&#99;&#111;&#117;&#x6e;&#x74;&#x2e;&#x63;&#111;&#x6d;</a></td><td>【必填】Value 输入谷歌的 client_email</td></tr><tr><td>google_private_key</td><td>“—–BEGIN PRIVATE KEY—–\nxxxxxx\n—–END PRIVATE KEY—–\n”</td><td>【必填】Value 输入谷歌的 private_key （注意：填写的时候需要使用<strong>双引号</strong>包起来，如: <code>&quot;private_key&quot;</code>）</td></tr></tbody></table></li></ol></blockquote><p>在Github内点击Action-&gt;Hexo SEO Auto Push -&gt; 查看执行情况 没有报错就是执行的没问题, 稍等片刻刷新控制台就可以看到提交的信息.</p><p>打开<a href="https://www.bing.com/webmasters/">Home - Bing Webmaster Tools</a>, <code>URL提交</code>标签</p><p>在<a href="https://console.cloud.google.com/apis/dashboard">Google Cloud Platform</a> 中查看.</p><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意:"></a><strong>注意:</strong></h3><p>部署的时候报了下面这个错误, 当时弄这个东西的时候是半夜, 脑子不清醒(各位同学注意早睡早起, 熬夜效率是极其低下的), <code>private_key</code>填写错了发生了这个错误, 有相似错误的同学可以看看是不是<code>private_key</code>有问题.</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs awk">Run npx hexoautopush *** ***<br>Error: error:<span class="hljs-number">0909006</span>C:PEM routines:get_name:no start line<br>    at Sign.sign (internal<span class="hljs-regexp">/crypto/</span>sig.js:<span class="hljs-number">110</span>:<span class="hljs-number">29</span>)<br>    at Object.sign (<span class="hljs-regexp">/xxx/</span>node_modules<span class="hljs-regexp">/jwa/i</span>ndex.js:<span class="hljs-number">152</span>:<span class="hljs-number">45</span>)<br>    at Object.jwsSign [as sign] (<span class="hljs-regexp">/xxx/</span>node_modules<span class="hljs-regexp">/jws/</span>lib/sign-stream.js:<span class="hljs-number">32</span>:<span class="hljs-number">24</span>)<br>    at GoogleToken.requestToken (<span class="hljs-regexp">/xxx/</span>node_modules<span class="hljs-regexp">/gtoken/</span>build<span class="hljs-regexp">/src/i</span>ndex.js:<span class="hljs-number">225</span>:<span class="hljs-number">31</span>)<br>    at GoogleToken.getTokenAsyncInner (<span class="hljs-regexp">/xxx/</span>node_modules<span class="hljs-regexp">/gtoken/</span>build<span class="hljs-regexp">/src/i</span>ndex.js:<span class="hljs-number">163</span>:<span class="hljs-number">21</span>)<br>    at GoogleToken.getTokenAsync (<span class="hljs-regexp">/xxx/</span>node_modules<span class="hljs-regexp">/gtoken/</span>build<span class="hljs-regexp">/src/i</span>ndex.js:<span class="hljs-number">142</span>:<span class="hljs-number">55</span>)<br>    at GoogleToken.getToken (<span class="hljs-regexp">/xxx/</span>node_modules<span class="hljs-regexp">/gtoken/</span>build<span class="hljs-regexp">/src/i</span>ndex.js:<span class="hljs-number">94</span>:<span class="hljs-number">21</span>)<br>    at JWT.refreshTokenNoCache (<span class="hljs-regexp">/xxx/</span>node_modules<span class="hljs-regexp">/google-auth-library/</span>build<span class="hljs-regexp">/src/</span>auth/jwtclient.js:<span class="hljs-number">171</span>:<span class="hljs-number">36</span>)<br>    at JWT.refreshToken (<span class="hljs-regexp">/xxx/</span>node_modules<span class="hljs-regexp">/google-auth-library/</span>build<span class="hljs-regexp">/src/</span>auth/oauth2client.js:<span class="hljs-number">145</span>:<span class="hljs-number">25</span>)<br>    at JWT.authorizeAsync (<span class="hljs-regexp">/xxx/</span>node_modules<span class="hljs-regexp">/google-auth-library/</span>build<span class="hljs-regexp">/src/</span>auth/jwtclient.js:<span class="hljs-number">152</span>:<span class="hljs-number">35</span>) &#123;<br>  library: <span class="hljs-string">&#x27;PEM routines&#x27;</span>,<br>  <span class="hljs-keyword">function</span>: <span class="hljs-string">&#x27;get_name&#x27;</span>,<br>  reason: <span class="hljs-string">&#x27;no start line&#x27;</span>,<br>  code: <span class="hljs-string">&#x27;ERR_OSSL_PEM_NO_START_LINE&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Hexo博客修改Archive页面显示文章数量"><a href="#Hexo博客修改Archive页面显示文章数量" class="headerlink" title="Hexo博客修改Archive页面显示文章数量"></a>Hexo博客修改Archive页面显示文章数量</h2><p>默认情况下，Hexo无法对主页、Archive页面、标签页面每页显示文章数量进行单独设置</p><p>这里我们借助<code>hexo-generator-archive</code>来实现这个功能, 因为Archive分页的话看起来贼难受, 如果能将所有的文章全部显示那就舒服了.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 先安装包</span><br>npm install hexo-generator-archive --save<br></code></pre></td></tr></table></figure><p>编辑<code>_config.yml</code>新增以下内容</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Pagination</span><br><span class="hljs-comment">## Set per_page to 0 to disable pagination</span><br><span class="hljs-attr">index_generator:</span><br>  <span class="hljs-attr">per_page:</span> <span class="hljs-number">32</span><br><br><span class="hljs-attr">index_generator:</span><br>  <span class="hljs-attr">per_page:</span> <span class="hljs-number">5</span><br><br><span class="hljs-attr">archive_generator:</span><br>  <span class="hljs-attr">per_page:</span> <span class="hljs-number">20</span>  <span class="hljs-comment">#为0时表示不分页全展示</span><br>  <span class="hljs-attr">yearly:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment">#按年生成归档</span><br>  <span class="hljs-attr">monthly:</span> <span class="hljs-literal">false</span> <span class="hljs-comment">#按月生成归档</span><br><br><span class="hljs-attr">tag_generator:</span><br>  <span class="hljs-attr">per_page:</span> <span class="hljs-number">10</span><br><br><span class="hljs-attr">category_generator:</span><br>  <span class="hljs-attr">per_page:</span> <span class="hljs-number">50</span><br></code></pre></td></tr></table></figure><blockquote><p>  注意:上面归档设置中的按年或者按月，需要修改模板给出对应的链接入口，对于没有兴趣修改模板的同学，可以将此处设为false，减少生成页面时的工作量。</p></blockquote><h1 id="Comment-评论系统"><a href="#Comment-评论系统" class="headerlink" title="Comment 评论系统"></a>Comment 评论系统</h1><h2 id="cusdis-系统"><a href="#cusdis-系统" class="headerlink" title="cusdis 系统"></a>cusdis 系统</h2><p>功能较少,看起来非常轻量, 也可以私有部署,正打算私有部署的时候看到了<code>twikoo</code>所以就转入<code>twikoo</code>了,因为cusdis现阶段功能确实有些少.</p><h2 id="twikoo-系统"><a href="#twikoo-系统" class="headerlink" title="twikoo 系统"></a>twikoo 系统</h2><p>twikoo支持docker私有部署，这是它吸引我的一点，这也是我对比几个之后最终敲定下来选择的。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>官网：<a href="https://twikoo.js.org/">https://twikoo.js.org/</a></p><p>Docker：<a href="https://hub.docker.com/r/imaegoo/twikoo">https://hub.docker.com/r/imaegoo/twikoo</a></p><p><del>私有docker部署部署半天还是不成功, 看起来像是需要HTTPS才行.</del></p><p>功能挺丰富的,<del>就是半天没部署成功</del></p><blockquote><p>  部署后没有启用HTTPS<br>  fluid 配置里面又启动了强行使用HTTPS,<br>  F12,看consel发现,ERR_SSL_PROTOCOL_ERROR,被重定向到了HTTPS去了</p></blockquote><h3 id="Docker部署"><a href="#Docker部署" class="headerlink" title="Docker部署"></a>Docker部署</h3><p>安装好docker后直接运行下面的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在当前文件夹下创建Data文件用于存放 twikoo 的评论数据</span><br>docker run --name twikoo -e TWIKOO_THROTTLE=512 -p 8884:8080 -v $&#123;PWD&#125;/data:/app/data -d --restart=always imaegoo/twikoo<br></code></pre></td></tr></table></figure><p>测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl http://localhost:8080/<br></code></pre></td></tr></table></figure><p>看到有输出就表示正常部署了。</p><h4 id="启用HTTPS"><a href="#启用HTTPS" class="headerlink" title="启用HTTPS"></a>启用HTTPS</h4><p>配置前置 Nginx 服务器或负载网关，以通过 HTTPS 访问 Twikoo，如下 Nginx 配置可供参考。</p><p><code>service nginx status</code> 我们可以找到nginx的配置文件在哪。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">http &#123;<br>    server &#123;<br>        listen       80;<br>        listen       [::]:80;<br>        # 重定向到https<br>        return       301 https://$server_name$request_uri;<br>    &#125;<br>    server &#123;<br>        listen       443 ssl;<br>        listen       [::]:443 ssl;<br>        # 下面两就是证书文件<br>        ssl_certificate      cert/fullchain.pem;<br>        ssl_certificate_key  cert/privkey.pem;<br>        # 连接到docker twikoo的端口<br>        location / &#123;<br>            proxy_pass   http://127.0.0.1:8080;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用Caddy将会变得非常简单</p><p>Caddy 的配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">www.youdomain.com &#123;<br>    encode zstd gzip<br>    reverse_proxy 127.0.0.1:8884<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="dockers-部署后升级"><a href="#dockers-部署后升级" class="headerlink" title="dockers 部署后升级"></a>dockers 部署后升级</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">　拉取新版本</span> <br>docker pull imaegoo/twikoo<br><span class="hljs-meta prompt_"># </span><span class="language-bash">停止旧版本容器</span> <br>docker stop twikoo<br><span class="hljs-meta prompt_">#</span><span class="language-bash">　删除旧版本容器</span> <br>docker rm twikoo<br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动新版本容器</span><br>dockr run .......<br></code></pre></td></tr></table></figure><h3 id="关于设置面板的头像风格类型"><a href="#关于设置面板的头像风格类型" class="headerlink" title="关于设置面板的头像风格类型"></a>关于设置面板的头像风格类型</h3><blockquote><p>  头像风格类型<br>  404：如果没有任何图像与电子邮件哈希无关，则不加载任何图像，而是返回HTTP 404（找不到文件）响应<br>  mp：（神秘人物）一个人的简单卡通风格的轮廓（不随电子邮件哈希值而变化）<br>  identicon：基于电子邮件哈希的几何图案<br>  monsterid：生成的具有不同颜色，面孔等的“怪物”<br>  wavatar：生成的具有不同特征和背景的面孔<br>  retro：生成的令人敬畏的8位街机风格像素化面孔<br>  robohash：具有不同颜色，面部等的生成的机器人<br>  blank：透明的PNG图像（以下为演示目的添加到HTML的边框）</p></blockquote><ul><li><p>Twikoo我是用的docker,nginx和ssl配置可以参考<a href="https://hub.docker.com/r/imaegoo/twikoo">DockerHub</a>, https的端口是可以更改的, 默认的443占用了换成别的就好.</p></li><li><p>twikoo的即时推送尝试了几个譬如 Qmsq, server酱等等发现又一系列的问题 都不尽如人意  最后选择的是最简单的邮件通知.</p></li></ul><h2 id="remark42"><a href="#remark42" class="headerlink" title="remark42"></a>remark42</h2><h1 id="部署平台-托管平台"><a href="#部署平台-托管平台" class="headerlink" title="部署平台(托管平台)"></a>部署平台(托管平台)</h1><p><a href="https://i.vince.pub/p/hexo-static/">常见静态网站托管平台使用及多节点部署方案</a></p><p><img src="/2022/f96c3c41/2fc062cb2.svg" alt="节点"></p><p>现阶段比较好的方案是<code>coding</code>和<code>github+netlify</code>.</p><h1 id="一些资源"><a href="#一些资源" class="headerlink" title="一些资源"></a>一些资源</h1><p><strong>字体族（<code>font-family</code>）</strong></p><blockquote><p>   <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-family">https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-family</a></p></blockquote><p><strong>调色板灵感</strong></p><blockquote><p>   <a href="https://www.webdesignrankings.com/resources/lolcolors/">https://www.webdesignrankings.com/resources/lolcolors/</a></p></blockquote><p><strong>ISO-8601 日期</strong></p><blockquote><p>  <a href="http://momentjs.cn/docs/#/parsing/string-format/">http://momentjs.cn/docs/#/parsing/string-format/</a></p></blockquote><p><strong>代码高亮风格</strong></p><blockquote><p>  highlightjs:  <a href="https://highlightjs.org/static/demo/">https://highlightjs.org/static/demo/</a></p><p>  prismjs:  <a href="https://prismjs.com/">https://prismjs.com/</a></p></blockquote><p><strong>Logo生成器</strong></p><blockquote><p>  adobe: <a href="https://www.adobe.com/express/create/logo">https://www.adobe.com/express/create/logo</a></p></blockquote><p><strong>图床</strong></p><blockquote><p>  <a href="https://postimg.cc/">https://postimg.cc/</a></p></blockquote><p><strong>壁纸</strong></p><blockquote><p>  <a href="https://wallpapercrafter.com/">https://wallpapercrafter.com/</a></p></blockquote><p><strong>实时获取网站的<code>Favicon.ion</code>文件</strong></p><blockquote><p>  <a href="https://tools.ly522.com/ico/">https://tools.ly522.com/ico/</a></p><p>  远程实时获取并显示网站的Favicon.ico文件，美化网站外链显示效果。</p></blockquote><p><strong>bing壁纸接口</strong></p><blockquote>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://bing.img.run/uhd.php&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Bing每日壁纸UHD超高清原图&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://bing.img.run/1920x1080.php&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Bing每日壁纸1080P高清&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://bing.img.run/1366x768.php&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Bing每日壁纸普清&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://bing.img.run/m.php&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Bing每日壁纸手机版1080P高清&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://bing.img.run/rand_uhd.php&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;随机获取Bing历史壁纸UHD超高清原图&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://bing.img.run/rand.php&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;随机获取Bing历史壁纸1080P高清&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://bing.img.run/rand_1366x768.php&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;随机获取Bing历史壁纸普清&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://bing.img.run/rand_m.php&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;随机获取Bing历史壁纸手机版1080P高清&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure></blockquote><h1 id="一些知识"><a href="#一些知识" class="headerlink" title="一些知识"></a>一些知识</h1><h2 id="Creative-Commons-licenses"><a href="#Creative-Commons-licenses" class="headerlink" title="Creative Commons licenses"></a>Creative Commons licenses</h2><p><a href="https://www.wur.nl/en/article/What-are-Creative-Commons-licenses.htm">What are Creative Commons licenses?</a></p><p><img src="/2022/f96c3c41/licences_3bf0e9af_670x502.jpg" alt="知识共享许可.jpg"></p><h2 id="Gravatar-Cravatar"><a href="#Gravatar-Cravatar" class="headerlink" title="Gravatar &amp; Cravatar"></a>Gravatar &amp; Cravatar</h2><p><a href="https://en.gravatar.com/">Gravatar</a> &amp; <a href="https://cravatar.cn/">Cravatar</a>的差异</p><h3 id="Gravatar"><a href="#Gravatar" class="headerlink" title="Gravatar"></a>Gravatar</h3><p>Gravatar是一项用于提供在全球范围内使用的头像服务。只要你在Gravatar的服务器上上传了你自己的头像，你便可以在其他任何支持Gravatar的博客、论坛等地方使用它。</p><h3 id="Cravatar-cn"><a href="#Cravatar-cn" class="headerlink" title="Cravatar  (cn)"></a>Cravatar  (cn)</h3><p>Cravatar 是 Gravatar 在中国的完美替代方案,从此你可以自由的上传和分享头像。</p><p><strong>与 Gravatar API 兼容</strong></p><p>为了降低你的使用成本，我们的 API 规范始终保持与 Gravatar 100% 兼容</p><p><strong>独有的三级头像匹配机制</strong></p><p>当访客请求自己的头像时，我们会按此顺序分三级匹配头像：<strong>Cravatar-&gt;Gravatar-&gt;QQ 头像</strong>，对于博客站，这平均可以为 70% 的访客提供准确的头像</p>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>jekyll</tag>
      
      <tag>fluid</tag>
      
      <tag>cusdis</tag>
      
      <tag>twikoo</tag>
      
      <tag>blog</tag>
      
      <tag>gravatar</tag>
      
      <tag>cravatar</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hyper-V</title>
    <link href="/2022/c6d84d87/"/>
    <url>/2022/c6d84d87/</url>
    
    <content type="html"><![CDATA[<h1 id="家庭版启用Hyper-V"><a href="#家庭版启用Hyper-V" class="headerlink" title="家庭版启用Hyper-V"></a>家庭版启用Hyper-V</h1><p>若要检查 Windows 版本及内部版本号，选择 Windows 徽标键 + R，然后键入“winver”，选择“确定”。更新到“设置”菜单中的<a href="ms-settings:windowsupdate">最新 Windows 版本</a>。</p><p>将下面代码改成<code>.bat</code>文件，管理员运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">pushd &quot;%~dp0&quot;<br>dir /b %SystemRoot%\servicing\Packages\*Hyper-V*.mum &gt;hv.txt<br>for /f %%i in (&#x27;findstr /i . hv.txt 2^&gt;nul&#x27;) do dism /online /norestart /add-package:&quot;%SystemRoot%\servicing\Packages\%%i&quot;<br>del hv.txt<br>Dism /online /enable-feature /featurename:Microsoft-Hyper-V -All /LimitAccess /ALL<br>Pause<br></code></pre></td></tr></table></figure><p>重启后在控制面板-&gt;程序和功能-&gt;启用或关闭Windows功能-&gt;勾选Hyper-V复选框</p><h2 id="卸载-禁用"><a href="#卸载-禁用" class="headerlink" title="卸载 &amp; 禁用"></a>卸载 &amp; 禁用</h2><ol><li><p>在控制面板中禁用 Hyper-V</p><ol><li>在“控制面板”中，打开“程序和功能”。</li><li>选择“启用或关闭 Windows 功能”。</li><li>展开 <strong>Hyper-V</strong>，展开 <strong>Hyper-V 平台</strong>，然后清除“Hyper-V 虚拟机监控程序”复选框。</li></ol></li><li><p>在 PowerShell 中禁用 Hyper-V</p><ol><li><p>打开提升权限的 PowerShell 窗口。</p></li><li><p>运行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Disable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V-Hypervisor<br></code></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hyperv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符集和字符编码</title>
    <link href="/2022/438d1de3/"/>
    <url>/2022/438d1de3/</url>
    
    <content type="html"><![CDATA[<h1 id="字符集和字符编码"><a href="#字符集和字符编码" class="headerlink" title="字符集和字符编码"></a>字符集和字符编码</h1><p><a href="https://www.cnblogs.com/skynet/archive/2011/05/03/2035105.html">字符集和字符编码 (Charset &amp; Encoding)</a></p><p><a href="http://www.knowsky.com/resource/gb2312tbl.htm">GB2312简体中文编码表</a></p><p><a href="http://tools.jb51.net/table/gb2312">GB2312简体中文编码表</a></p><p><a href="https://www.unicode.org/charts/">Unicode码查询</a></p><p><a href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84">Unicode字符平面映射</a></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>字符集（Charset）</strong>：是一个系统支持的所有抽象字符的集合。字符是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等。</p><p>常见字符集：ASCII字符集、GB2312字符集、BIG5字符集、GB18030字符集、Unicode字符集等。计算机要准确的处理各种字符集文字，需要进行字符编码，以便计算机能够识别和存储各种文字。</p><p><strong>字符编码（Character Encoding）</strong>：是一套法则，使用该法则能够对自然语言的字符的一个集合（如字母表或音节表），与其他东西的一个集合（如号码、数字或电脉冲）进行配对。即在符号集合与数字系统之间建立对应关系，它是信息处理的一项基本技术。通常人们用符号集合（一般情况下就是文字）来表达信息。而以计算机为基础的信息处理系统则是利用元件（硬件）不同状态的组合来存储和处理信息的。元件不同状态的组合能代表数字系统的数字，因此字符编码就是将符号转换为计算机可以接受的数字系统的数，称为数字代码。</p><h2 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h2><p><strong>ASCII字符集</strong>：主要包括控制字符（回车键、退格、换行键等）；可显示字符（英文大小写字符、阿拉伯数字和西文符号）。</p><p><strong>ASCII编码</strong>：将ASCII字符集转换为计算机可以接受的数字系统的数的规则。使用7位（bits）表示一个字符，共128字符；但是7位编码的字符集只能支持128个字符，为了表示更多的常用字符欧洲对ASCII进行了扩展，ASCII扩展字符集使用8位（bits）表示一个字符，共256字符。ASCII字符集映射到数字编码规则如下图所示：</p><p><img src="/2022/438d1de3/2011050311372042.png" alt="img"></p><p><img src="/2022/438d1de3/201105031137219627.png" alt="img"></p><h2 id="GBxxx"><a href="#GBxxx" class="headerlink" title="GBxxx"></a>GBxxx</h2><p>中国把那些127号之后的奇异符号们（即EASCII、扩充ASCII）取消掉，规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字。前面的一个字节（他称之为高字节）从0xA1用到 0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。在这些编码里，还把数学符号、罗马希腊的 字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。</p><p>上述编码规则就是<strong>GB2312</strong>。<strong>GB2312</strong>或<strong>GB2312-80</strong>是<a href="http://zh.wikipedia.org/wiki/%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E5%9B%BD%E5%AE%B6%E6%A0%87%E5%87%86">中国国家标准</a><a href="http://zh.wikipedia.org/wiki/%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87">简体中文</a><a href="http://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E9%9B%86">字符集</a>，全称《<strong>信息交换用汉字编码字符集·基本集</strong>》，又称<a href="http://zh.wikipedia.org/wiki/%E5%9B%BD%E5%AE%B6%E6%A0%87%E5%87%86%E4%BB%A3%E7%A0%81"><strong>GB0</strong></a>，由<a href="http://zh.wikipedia.org/w/index.php?title=%E4%B8%AD%E5%9B%BD%E5%9B%BD%E5%AE%B6%E6%A0%87%E5%87%86%E6%80%BB%E5%B1%80&action=edit&redlink=1">中国国家标准总局</a>发布，<a href="http://zh.wikipedia.org/wiki/1981%E5%B9%B4">1981年</a><a href="http://zh.wikipedia.org/wiki/5%E6%9C%881%E6%97%A5">5月1日</a>实施。GB2312编码通行于中国大陆；<a href="http://zh.wikipedia.org/wiki/%E6%96%B0%E5%8A%A0%E5%9D%A1">新加坡</a>等地也采用此编码。GB2312的出现，基本满足了汉字的计算机处理需要，它所收录的汉字已经覆盖中国大陆99.75%的使用频率。对于<a href="http://zh.wikipedia.org/wiki/%E4%BA%BA%E5%90%8D">人名</a>、<a href="http://zh.wikipedia.org/wiki/%E5%8F%A4%E6%B1%89%E8%AF%AD">古汉语</a>等方面出现的<a href="http://zh.wikipedia.org/wiki/%E7%BD%95%E7%94%A8%E5%AD%97">罕用字</a>，GB2312不能处理，这导致了后来<a href="http://zh.wikipedia.org/wiki/GBK">GBK</a>及<a href="http://zh.wikipedia.org/wiki/GB_18030">GB 18030</a>汉字字符集的出现。</p><p><a href="http://www.knowsky.com/resource/gb2312tbl.htm">GB2312简体中文编码表</a></p><p><a href="http://tools.jb51.net/table/gb2312">GB2312简体中文编码表</a></p><h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p>Unicode编码系统为表达任意语言的任意字符而设计。它使用4字节的数字来表达每个字母、符号，或者表意文字(ideograph)。每个字符对应一个数字，每个数字对应一个字符，即不存在二义性，不再需要记录”模式”了。U+0041总是代表’A’，即使这种语言没有’A’这个字符。</p><p>在计算机科学领域中，<strong>Unicode</strong>（<strong>统一码</strong>、<strong>万国码</strong>、<strong>单一码</strong>、<strong>标准万国码</strong>）是业界的一种标准，它可以使电脑得以体现世界上数十种文字的系统。</p><p>（<strong>可以这样理解：Unicode是字符集，UTF-32&#x2F; UTF-16&#x2F; UTF-8是三种字符编码方案。</strong>）</p><p><a href="https://www.unicode.org/charts/">Unicode码查询</a></p><p><a href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84">Unicode字符平面映射</a></p><h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h3><p>EF BB BF　　　 UTF-8<br>FE FF　　　　　UTF-16&#x2F;UCS-2, little endian<br>FF FE　　　　　UTF-16&#x2F;UCS-2, big endian<br>FF FE 00 00　　UTF-32&#x2F;UCS-4, little endian.<br>00 00 FE FF　　UTF-32&#x2F;UCS-4, big-endian.</p><ul><li><strong>字符集和字符编码</strong></li></ul><p><img src="/2022/438d1de3/v2-aee5ae604328ab912b285d03b6c62273_720w.jpg" alt="img"></p><h3 id="UTF-32"><a href="#UTF-32" class="headerlink" title="UTF-32"></a>UTF-32</h3><p>上述使用4字节的数字来表达每个字母、符号，或者表意文字(ideograph)，每个数字代表唯一的至少在某种语言中使用的符号的编码方案，称为UTF-32。UTF-32又称<strong>UCS-4</strong>是一种将<a href="http://zh.wikipedia.org/wiki/Unicode">Unicode</a>字符编码的协定，对每个字符都使用4字节。就空间而言，是非常没有效率的。</p><p>这种方法有其优点，最重要的一点就是可以在常数时间内定位字符串里的第N个字符，因为第N个字符从第4×Nth个字节开始。虽然每一个码位使用固定长定的字节看似方便，它并不如其它Unicode编码使用得广泛。</p><h3 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h3><p>对于UTF-32和UTF-16编码方式还有一些其他不明显的缺点。不同的计算机系统会以不同的顺序保存字节。这意味着字符U+4E2D在UTF-16编码方式下可能被保存为4E 2D或者2D 4E，这取决于该系统使用的是大尾端(big-endian)还是小尾端(little-endian)。为了解决这个问题，多字节的Unicode编码方式定义了一个”字节顺序标记(Byte Order Mark)”，它是一个特殊的非打印字符，你可以把它包含在文档的开头来指示你所使用的字节顺序。对于UTF-16，字节顺序标记是U+FEFF。如果收到一个以字节FFFE开头的UTF-16编码的文档，你就能确定它的字节顺序是单向的(one way)的了；如果它以FEFF开头，则可以确定字节顺序反向了。</p><p><strong>具体编码方式</strong></p><p>Unicode范围<code>U+10000</code><del><code>U+10FFFF</code>：将Unicode值减去（0x10000），得到20bit长的值。再将Unicode分为高10位和低10位。<a href="https://www.zhihu.com/search?q=UTF-16%E7%BC%96%E7%A0%81&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:106379925%7D">UTF-16编码</a>的高位是2 Byte，高10位Unicode范围为<code>0</code>-<code>0x3FF</code>，将Unicode值加上<code>0XD800</code>，得到高位代理（或称为前导代理，存储高位）；低位也是2 Byte，低十位Unicode范围一样为<code>0</code></del><code>0x3FF</code>，将Unicode值加上<code>0xDC00</code>,得到低位代理（或称为后尾代理，存储低位）</p><p>根据上面的转换方式，我们就能够将Unicode码根据UTF-16的编码方式进行转换。下面我们仍然通过两个例子来看下：</p><ul><li><code>U+0020</code>，这个值的范围在第一部分，即经过UTF-16编码后，结果仍然为<code>U+0020</code>，在内存中的顺序为<code>00 20</code>。</li><li><code>U+12345</code>, 这个值的范围在第二部分，因此需要先减去<code>0x10000</code>，得到<code>0x02345</code>，拆分成高10位<code>00 0000 1000</code>和低10位<code>11 0100 0101</code>。根据上面规则加上特定值后，高位代理值为<code>D808</code>，低位代理值为<code>DF45</code>，最终内存中的顺序为<code>D8 08 DF 45</code>。</li></ul><h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><p><strong>UTF-8</strong>（8-bit Unicode Transformation Format）是一种针对<a href="http://zh.wikipedia.org/wiki/Unicode">Unicode</a>的可变长度<a href="http://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81">字符编码</a>（<a href="http://zh.wikipedia.org/w/index.php?title=%E5%AE%9A%E9%95%BF%E7%A0%81&action=edit&redlink=1">定长码</a>），也是一种<a href="http://zh.wikipedia.org/w/index.php?title=%E5%89%8D%E7%BC%80%E7%A0%81&action=edit&redlink=1">前缀码</a>。它可以用来表示Unicode标准中的任何字符，且其编码中的第一个<a href="http://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82">字节</a>仍与<a href="http://zh.wikipedia.org/wiki/ASCII">ASCII</a>兼容，这使得原来处理ASCII字符的<a href="http://zh.wikipedia.org/wiki/%E8%BB%9F%E9%AB%94">软件</a>无须或只须做少部份修改，即可继续使用。因此，它逐渐成为<a href="http://zh.wikipedia.org/wiki/%E9%9B%BB%E5%AD%90%E9%83%B5%E4%BB%B6">电子邮件</a>、<a href="http://zh.wikipedia.org/wiki/%E7%B6%B2%E9%A0%81">网页</a>及其他<a href="http://zh.wikipedia.org/wiki/%E5%84%B2%E5%AD%98%E8%A3%9D%E7%BD%AE">存储</a>或传送文字的应用中，优先采用的编码。<a href="http://zh.wikipedia.org/wiki/%E7%B6%B2%E9%9A%9B%E7%B6%B2%E8%B7%AF%E5%B7%A5%E7%A8%8B%E5%B7%A5%E4%BD%9C%E5%B0%8F%E7%B5%84">互联网工程工作小组</a>（IETF）要求所有<a href="http://zh.wikipedia.org/wiki/%E7%B6%B2%E9%9A%9B%E7%B6%B2%E8%B7%AF">互联网</a><a href="http://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE">协议</a>都必须支持UTF-8编码。</p><p>UTF-8使用一至四个<a href="http://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82">字节</a>为每个字符编码</p><p><strong>具体编码方式</strong></p><p><img src="/2022/438d1de3/v2-121a14291638f0b28e1dde7c95d2d379_720w.jpg" alt="img"></p><p>根据上表，解读 UTF-8 编码非常简单。如果一个字节的第一位是<code>0</code>，则这个字节单独就是一个字符；如果第一位是<code>1</code>，则连续有多少个<code>1</code>，就表示当前字符占用多少个字节。<br>下面，还是以汉字<code>严</code>为例，演示如何实现 <a href="https://www.zhihu.com/search?q=UTF-8+%E7%BC%96%E7%A0%81&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:790551384%7D">UTF-8 编码</a>。<br><code>严</code>的 Unicode 是<code>4E25</code>（<code>100111000100101</code>），根据上表，可以发现<code>4E25</code>处在第三行的范围内（<code>0000 0800 - 0000 FFFF</code>），因此<code>严</code>的 UTF-8 编码需要三个字节，即格式是<code>1110xxxx 10xxxxxx 10xxxxxx</code>。然后，从<code>严</code>的最右边<a href="https://www.zhihu.com/search?q=%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:790551384%7D">二进制位</a>开始，依次从右往左填入上边格式中的<code>x</code>，多出的位补<code>0</code>。这样就得到了，<code>严</code>的 UTF-8 编码是<code>11100100 10111000 10100101</code>，转换成<a href="https://www.zhihu.com/search?q=%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:790551384%7D">十六进制</a>就是<code>E4 B8 A5</code>。</p><p><strong>优点</strong></p><ul><li>UTF-8是ASCII的一个<a href="http://zh.wikipedia.org/wiki/%E8%B6%85%E9%9B%86">超集</a>。因为一个纯ASCII字符串也是一个合法的UTF-8字符串，所以现存的ASCII文本不需要转换。为传统的扩展ASCII字符集设计的软件通常可以不经修改或很少修改就能与UTF-8一起使用。</li><li>使用标准的面向字节的排序例程对UTF-8排序将产生与*于Unicode代码点排序相同的结果。（尽管这只有有限的有用性，因为在任何特定语言或文化下都不太可能有仍可接受的文字排列顺序。）</li><li>UTF-8和UTF-16都是<a href="http://zh.wikipedia.org/wiki/%E5%8F%AF%E6%89%A9%E5%B1%95%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80">可扩展标记语言</a>文档的标准编码。所有其它编码都必须通过显式或文本声明来指定。</li><li>任何<a href="http://zh.wikipedia.org/w/index.php?title=%E9%9D%A2%E5%90%91%E5%AD%97%E8%8A%82&action=edit&redlink=1">面向字节</a>的<a href="http://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95">字符串搜索算法</a>都可以用于UTF-8的数据（只要输入仅由完整的UTF-8字符组成）。但是，对于包含字符记数的正则表达式或其它结构必须小心。</li><li>UTF-8字符串可以由一个简单的算法可靠地识别出来。就是，一个字符串在任何其它编码中表现为合法的UTF-8的可能性很低，并随字符串长度增长而减小。举例说，字符值C0,C1,F5至FF从来没有出现。为了更好的可靠性，可以使用正则表达式来统计非法过长和替代值（可以查看<a href="http://www.w3.org/International/questions/qa-forms-utf-8">W3 FAQ: Multilingual Forms</a>上的验证UTF-8字符串的正则表达式）。</li></ul><p><strong>缺点</strong></p><p>因为每个字符使用不同数量的字节编码，所以寻找串中第N个字符是一个O(N)复杂度的操作 — 即，串越长，则需要更多的时间来定位特定的字符。同时，还需要位变换来把字符编码成字节，把字节解码成字符。</p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>character encoding</tag>
      
      <tag>gb2312</tag>
      
      <tag>utf-8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VScode插件CommentTranslate在WSL内无效</title>
    <link href="/2022/1d3ed0f3/"/>
    <url>/2022/1d3ed0f3/</url>
    
    <content type="html"><![CDATA[<h1 id="VScode插件CommentTranslate在WSL内无效"><a href="#VScode插件CommentTranslate在WSL内无效" class="headerlink" title="VScode插件CommentTranslate在WSL内无效"></a>VScode插件CommentTranslate在WSL内无效</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/intellism/vscode-comment-translate/issues/64">https://github.com/intellism/vscode-comment-translate/issues/64</a></p><ol><li><p>找到相关语言语法规则文件。如C&#x2F;CPP、bat、css、java、python，这些文件都是在Windows版本的VSCode中内置的，文件路径在 <code>C:\Users\ **userNmae** \AppData\Local\Programs\Microsoft VS Code\resources\app\extensions</code>改过安装路径的是<code>Microsoft VS Code\resources\app\extensions</code></p><p><img src="/2022/1d3ed0f3/image-20220811202401467.png" alt="image-20220811202401467"></p></li></ol><p>​</p><ol><li><p>将语法规则的<strong>高亮规则</strong>文件夹拷贝到远程vscode的相关插件目录。以C语言为例，将<code>cpp</code>目录下的高亮规则文件夹<code>syntaxes</code>拷贝到远程C&#x2F;C++插件（<code>ms-vscode.cpptools-x.x.x</code>）目录下。如果你使用SSH远程，远程插件的目录在<code>~/.vscode-server/extensions/ms-vscode.cpptools-x.x.x</code>。</p><p><img src="/2022/1d3ed0f3/image-20220811202845203.png" alt="image-20220811202845203"></p></li><li><p>修改远程插件，添加语法高亮规则。修改远程插件的<code>package.json</code>文件，如C&#x2F;C++插件（<code>ms-vscode.cpptools-x.x.x</code>）目录下的<code>package.json</code>文件，将刚才cpp语法规则文件夹中的<code>package.json</code>文件的”<code>grammars</code>“部分拷贝出来，粘贴到远程插件的<code>package.json</code>的<code>contributes</code>部分中去。</p><p>如果遇到格式难以复制，可以全选内容然后按Shift+Alt+F格式化选定内容。<img src="/2022/1d3ed0f3/image-20220811202944334.png" alt="image-20220811202944334"></p></li></ol><p><img src="/2022/1d3ed0f3/image-20220811203114753.png" alt="image-20220811203114753"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-string">&quot;grammars&quot;</span>: [<br>          &#123;<br>              <span class="hljs-string">&quot;language&quot;</span>: <span class="hljs-string">&quot;c&quot;</span>,<br>              <span class="hljs-string">&quot;scopeName&quot;</span>: <span class="hljs-string">&quot;source.c&quot;</span>,<br>              <span class="hljs-string">&quot;path&quot;</span>: <span class="hljs-string">&quot;./syntaxes/c.tmLanguage.json&quot;</span><br>          &#125;,<br>          &#123;<br>              <span class="hljs-string">&quot;language&quot;</span>: <span class="hljs-string">&quot;cpp&quot;</span>,<br>              <span class="hljs-string">&quot;scopeName&quot;</span>: <span class="hljs-string">&quot;source.cpp.embedded.macro&quot;</span>,<br>              <span class="hljs-string">&quot;path&quot;</span>: <span class="hljs-string">&quot;./syntaxes/cpp.embedded.macro.tmLanguage.json&quot;</span><br>          &#125;,<br>          &#123;<br>              <span class="hljs-string">&quot;language&quot;</span>: <span class="hljs-string">&quot;cpp&quot;</span>,<br>              <span class="hljs-string">&quot;scopeName&quot;</span>: <span class="hljs-string">&quot;source.cpp&quot;</span>,<br>              <span class="hljs-string">&quot;path&quot;</span>: <span class="hljs-string">&quot;./syntaxes/cpp.tmLanguage.json&quot;</span><br>          &#125;,<br>          &#123;<br>              <span class="hljs-string">&quot;scopeName&quot;</span>: <span class="hljs-string">&quot;source.c.platform&quot;</span>,<br>              <span class="hljs-string">&quot;path&quot;</span>: <span class="hljs-string">&quot;./syntaxes/platform.tmLanguage.json&quot;</span><br>          &#125;,<br>          &#123;<br>              <span class="hljs-string">&quot;language&quot;</span>: <span class="hljs-string">&quot;cuda-cpp&quot;</span>,<br>              <span class="hljs-string">&quot;scopeName&quot;</span>: <span class="hljs-string">&quot;source.cuda-cpp&quot;</span>,<br>              <span class="hljs-string">&quot;path&quot;</span>: <span class="hljs-string">&quot;./syntaxes/cuda-cpp.tmLanguage.json&quot;</span><br>          &#125;<br>      ],<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vscode</tag>
      
      <tag>commenttranslate</tag>
      
      <tag>wsl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建KMS</title>
    <link href="/2022/3ef2a47d/"/>
    <url>/2022/3ef2a47d/</url>
    
    <content type="html"><![CDATA[<h1 id="KMS"><a href="#KMS" class="headerlink" title="KMS"></a>KMS</h1><p>KMS（Key Management Service），密钥管理服务</p><p>能够通过KMS进行激活的一般称为VL版,即VOLUME授权版，一般不会单独在零售市场进行发售，一般是直接向企业提供电子ISO映像进行批量授权安装，基于对KMS原理研究成果，我们可以自行搭建KMS激活服务器，实现每180天一次的自动激活，使得系统一直保持激活状态。</p><p>KMS可以激活VOL版本的windows系统和office软件</p><h1 id="Docker-部署KMS服务器"><a href="#Docker-部署KMS服务器" class="headerlink" title="Docker 部署KMS服务器"></a>Docker 部署KMS服务器</h1><p><a href="https://registry.hub.docker.com/r/teddysun/kms">https://registry.hub.docker.com/r/teddysun/kms</a></p><ol><li><p>Pull the image</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull teddysun/kms<br></code></pre></td></tr></table></figure><p>This pulls the latest release of KMS server. It can be found at Docker Hub.</p></li><li><p>Start a container</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d -p 1688:1688 --name kms --restart=always teddysun/kms<br></code></pre></td></tr></table></figure><p>Note: The TCP port number <code>1688</code> must be opened in firewall.</p></li></ol><h1 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h1><h2 id="激活windows"><a href="#激活windows" class="headerlink" title="激活windows"></a>激活windows</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 待激活的主机上指定KMS服务器</span><br>slmgr /skms service_address(你搭建的服务器的地址)<br><br><span class="hljs-comment"># 手动激活</span><br>slmgr /ato<br><br><span class="hljs-comment"># 如果激活失败 尝试更改成GVLK KEY再次激活</span><br><span class="hljs-comment"># 运行以下命令查看系统版本 </span><br>wmic os get caption<br><br><span class="hljs-comment"># 访问下面的网址获取key</span><br><span class="hljs-comment"># https://docs.microsoft.com/zh-cn/windows-server/get-started/kms-client-activation-keys</span><br><span class="hljs-comment"># https://technet.microsoft.com/en-us/library/jj612867.aspx</span><br><span class="hljs-comment"># 得到对应key之后，使用管理员权限运行cmd执行安装key：</span><br>slmgr /ipk xxxxx-xxxxx-xxxxx-xxxxx<br><br><span class="hljs-comment"># 手动激活</span><br>slmgr /ato<br></code></pre></td></tr></table></figure><h2 id="激活office"><a href="#激活office" class="headerlink" title="激活office"></a>激活office</h2><p>首先你的OFFICE必须是VOL版本，否则无法激活。 找到你的office安装目录，比如</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">C:<span class="hljs-string">\Program</span> Files (x86)<span class="hljs-string">\Microsoft</span> Office<span class="hljs-string">\Office16</span><br></code></pre></td></tr></table></figure><p>64位的就是</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">C:<span class="hljs-string">\Program</span> Files<span class="hljs-string">\Microsoft</span> Office<span class="hljs-string">\Office16</span><br></code></pre></td></tr></table></figure><p>office16是office2016，office15就是2013，office14就是2010.</p><p>然后目录对的话，该目录下面应该有个OSPP.VBS。</p><p>直接输入下面的指令去指定KMS服务器</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell">cscript <span class="hljs-string">&quot;C:\Program Files (x86)\Microsoft Office\Office16\OSPP.VBS&quot;</span> /sethst:service_address(你搭建的服务器的地址)<br><span class="hljs-comment"># or</span><br>cscript <span class="hljs-string">&quot;C:\Program Files\Microsoft Office\Office16\OSPP.VBS&quot;</span> /sethst:service_address(你搭建的服务器的地址)<br><br><span class="hljs-comment"># cscript &quot;C:\Program Files\Microsoft Office\Office16\OSPP.VBS&quot; /sethst:8.8.8.8</span><br></code></pre></td></tr></table></figure><p>一般来说，“一句命令已经完成了”，但一般office不会马上连接kms服务器进行激活，所以我们额外补充一条手动激活命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cscript ospp.vbs /act<br></code></pre></td></tr></table></figure><h1 id="如果遇到报错，请检查："><a href="#如果遇到报错，请检查：" class="headerlink" title="如果遇到报错，请检查："></a>如果遇到报错，请检查：</h1><blockquote><ol><li>你的系统&#x2F;OFFICE是否是批量VL版本</li><li>是否以管理员权限运行CMD</li><li>你的系统&#x2F;OFFICE是否修改过KEY&#x2F;未安装GVLK KEY</li><li>检查你的网络连接</li><li>服务器繁忙，多试试（点击检查KMS服务是否可用）</li><li>根据出错代码自己搜索出错原因</li></ol></blockquote><h2 id="windows没有密钥"><a href="#windows没有密钥" class="headerlink" title="windows没有密钥"></a>windows没有密钥</h2><ul><li>windows VOL KEY</li></ul><p><a href="https://docs.microsoft.com/zh-cn/windows-server/get-started/kmsclientkeys">https://docs.microsoft.com/zh-cn/windows-server/get-started/kmsclientkeys</a></p><h2 id="检查windows版本"><a href="#检查windows版本" class="headerlink" title="检查windows版本"></a>检查windows版本</h2><ul><li>检查office是否是VOL版本</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 命令提示符（管理员）执行：cd “office的安装目录”</span><br><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;C:\Program Files (x86)\Microsoft Office\Office16&quot;</span><br><span class="hljs-comment"># or</span><br><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;C:\Program Files\Microsoft Office\Office16&quot;</span><br><br><span class="hljs-comment"># 执行：</span><br>cscript ospp.vbs /dstatus<br></code></pre></td></tr></table></figure><p>在显示的信息中，如果有“VOLUME”字样就是VOL版，即支持KMS激活</p><h2 id="office-密钥"><a href="#office-密钥" class="headerlink" title="office 密钥"></a>office 密钥</h2><ul><li>卸载office的密钥</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 命令提示符（管理员）执行：cd “office的安装目录”</span><br><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;C:\Program Files (x86)\Microsoft Office\Office16&quot;</span><br><span class="hljs-comment"># or</span><br><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;C:\Program Files\Microsoft Office\Office16&quot;</span><br><br><span class="hljs-comment"># 查看当前状态</span><br>cscript ospp.vbs /dstatus<br><br><span class="hljs-comment"># 找到 Last 5 characters of installed product key:XXXXX 语句</span><br><span class="hljs-comment"># 卸载密钥</span><br>cscript ospp.vbs /unpkey:XXXXX<br></code></pre></td></tr></table></figure><ul><li>查找office的VOL KEY</li></ul><p><a href="https://docs.microsoft.com/zh-cn/DeployOffice/vlactivation/gvlks">https://docs.microsoft.com/zh-cn/DeployOffice/vlactivation/gvlks</a></p><ul><li><p>安装密钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Office 专业增强版 2016</span><br>cscript ospp.vbs /inpkey:XQNVK-8JYDB-WJ9W3-YJ8YR-WFG99<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kms</tag>
      
      <tag>office</tag>
      
      <tag>volume</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSL证书的申请和自动续期</title>
    <link href="/2022/82aca4fc/"/>
    <url>/2022/82aca4fc/</url>
    
    <content type="html"><![CDATA[<h1 id="SSL证书的申请和自动续期"><a href="#SSL证书的申请和自动续期" class="headerlink" title="SSL证书的申请和自动续期"></a>SSL证书的申请和自动续期</h1><p>Let’s Encrypt 证书续期</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/a2d0209fa3f5">https://www.jianshu.com/p/a2d0209fa3f5</a></p><p><a href="https://www.cnblogs.com/esofar/p/9291685.html">快速签发 Let’s Encrypt 证书指南</a></p><p><a href="https://certbot.eff.org/">https://certbot.eff.org/</a></p><h1 id="acme-sh-申请"><a href="#acme-sh-申请" class="headerlink" title="acme.sh 申请"></a>acme.sh 申请</h1><p>用 acme.sh申请来自动续期ssl证书<br> acme说明：<a href="https://links.jianshu.com/go?to=https://github.com/Neilpang/acme.sh/wiki/%E8%AF%B4%E6%98%8E">https://github.com/Neilpang/acme.sh/wiki/说明</a></p><h2 id="通过在网站根目录存放文件来验证域名"><a href="#通过在网站根目录存放文件来验证域名" class="headerlink" title="通过在网站根目录存放文件来验证域名"></a>通过在网站根目录存放文件来验证域名</h2><ol><li><p>下载acme<code>curl https://get.acme.sh | sh</code>  安装完成后必须关闭当前终端，重新开启一个以使acme.sh命令生效</p></li><li><p>执行生成和自动更新命令：<code>acme.sh --issue -d mydomain.com -d www.mydomain.com --webroot /var/www/mydomain.com/</code></p><blockquote><h2 id="通过在网站根目录存放文件来验证域名-1"><a href="#通过在网站根目录存放文件来验证域名-1" class="headerlink" title="通过在网站根目录存放文件来验证域名"></a>通过在网站根目录存放文件来验证域名</h2>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">acme.sh --issue -d mydomain.com -d www.mydomain.com --webroot /home/wwwroot/mydomain.com/<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果你用的 nginx服务器, 或者反代, acme.sh 还可以智能的从 nginx的配置中自动完成验证, 你不需要指定网站根目录:</span><br>acme.sh --issue -d mydomain.com --nginx<br></code></pre></td></tr></table></figure><h2 id="通过DNS解析添加TXT解析记录验证"><a href="#通过DNS解析添加TXT解析记录验证" class="headerlink" title="通过DNS解析添加TXT解析记录验证"></a>通过DNS解析添加TXT解析记录验证</h2>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">acme.sh --issue --dns -d mydomain.com \<br> --yes-I-know-dns-manual-mode-enough-go-ahead-please<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">然后, acme.sh 会生成相应的解析记录显示出来, 你只需要在你的域名管理面板中添加这条 txt 记录即可.等待解析完成之后, 重新生成证书:</span><br><br>acme.sh --renew -d mydomain.com \<br>  --yes-I-know-dns-manual-mode-enough-go-ahead-please<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">注意第二次这里用的是 --renew</span><br></code></pre></td></tr></table></figure></blockquote></li><li><p>安装证书 <code>cd /etc/nginx; mkdir ssl</code></p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">acme.sh  --installcert  -d  <span class="hljs-tag">&lt;<span class="hljs-name">domain</span>&gt;</span>.com   \<br>        --key-file   /etc/nginx/ssl/<span class="hljs-tag">&lt;<span class="hljs-name">domain</span>&gt;</span>.key \<br>        --fullchain-file /etc/nginx/ssl/fullchain.cer \<br>        --reloadcmd  &quot;service nginx force-reload&quot;<br></code></pre></td></tr></table></figure><ol start="4"><li>配置nginx使用ssl</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash">server &#123;<br>    listen 80 default_server;<br>    listen 443 http2 ssl;<br>    listen [::]:80 default_server;<br><br>    ssl_certificate /etc/nginx/ssl/fullchain.cer;<br>    ssl_certificate_key /etc/nginx/ssl/domain.key;<br>    <span class="hljs-comment">#http转https</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable">$scheme</span> = http ) &#123;<span class="hljs-built_in">return</span> 301 https://$host<span class="hljs-variable">$request_uri</span>;&#125;<br>    root /var/www/html;<br><br>    index index.html index.htm index.nginx-debian.html;<br>    server_name _;<br><br>    ssl_certificate /etc/nginx/ssl/fullchain.cer;<br>    ssl_certificate_key /etc/nginx/ssl/domain.key;<br><br>    location /test &#123;<br>          proxy_pass       http://127.0.0.1:3000;<br>          proxy_http_version 1.1;<br>          proxy_set_header Upgrade <span class="hljs-variable">$http_upgrade</span>;<br>          proxy_set_header Connection <span class="hljs-string">&quot;upgrade&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>前端的Upgrade请求发送给后端服务器，Upgrade和Connection的头信息必须被显式的设置。一旦我们完成以上设置，NGINX就可以处理WebSocket连接了。查看配置在哪里<code>ps -ef|grep nginx</code><br> 多个域名的话，配多个nginx.conf配置。</p><ol start="5"><li>查看是否有每日任务<br> <code>crontab -l #查看你的任务</code><br> 手动更新证书<code>acme.sh --renew -d domain.com</code></li></ol><h1 id="certbot"><a href="#certbot" class="headerlink" title="certbot"></a>certbot</h1><p><a href="https://certbot.eff.org/">文档</a></p><p>Ubuntu + nginx <a href="https://certbot.eff.org/instructions?ws=nginx&os=ubuntufocal">https://certbot.eff.org/instructions?ws=nginx&amp;os=ubuntufocal</a></p><p>用certbot来自动续期ssl证书</p><ul><li>需要注意的是安装证书的时候最好把nginx关掉先</li></ul>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ssl</tag>
      
      <tag>https</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nintendo Switch</title>
    <link href="/2022/f15ac6f4/"/>
    <url>/2022/f15ac6f4/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><h2 id="认识Switch的启动方式"><a href="#认识Switch的启动方式" class="headerlink" title="认识Switch的启动方式"></a>认识Switch的启动方式</h2><p>使用大气层(Atmosphere)的switch是通过 软破&#x2F;硬破 的方式启动SD卡上的大气层。然后大气层再去启动switch的破解版OS。</p><p>这里的大气层就有点类似于bootloader的感觉，但是不同的大气层(Atmosphere)版本能支持的SwitchOS的版本是不一样的，例如<code>Atmosphère 1.5.3 Support was added for 16.0.3</code>但是<code>Atmosphère 1.5.0 Support was added for 16.0.0</code>，这也是为什么有的时候我们升级SwitchOS需要先更新大气层。</p><h2 id="SD卡内文件结构"><a href="#SD卡内文件结构" class="headerlink" title="SD卡内文件结构"></a>SD卡内文件结构</h2><p><img src="/2022/f15ac6f4/image-20221103090149675.png" alt="image-20221103090149675"></p><blockquote><p>  在更新和升级中，一般来说<code>Nintendo</code>和<code>emuMMC</code>是不会去删除的。</p><p>  Atmosphere需要更新的大版本一般来说除了上面这两个文件夹保留，其他的都要删掉。同时需要注意要更新注入文件fulse.bin</p></blockquote><h1 id="SwitchOS-相关"><a href="#SwitchOS-相关" class="headerlink" title="SwitchOS 相关"></a>SwitchOS 相关</h1><h2 id="三种不同的OS"><a href="#三种不同的OS" class="headerlink" title="三种不同的OS"></a>三种不同的OS</h2><p><img src="/2022/f15ac6f4/image-20221103092334424.png" alt="image-20221103092334424"></p><ul><li>大气层-真实系统<ul><li>使用的是机身的正版系统, 插件是使用的是大气层的插件</li></ul></li><li>大气层-虚拟系统<ul><li>使用的是SD卡内全虚拟的系统</li></ul></li></ul><h2 id="查看当前OS版本和环境"><a href="#查看当前OS版本和环境" class="headerlink" title="查看当前OS版本和环境"></a>查看当前OS版本和环境</h2><p><img src="/2022/f15ac6f4/image-20221103090700699.png" alt="image-20221103090700699"></p><h2 id="系统升级"><a href="#系统升级" class="headerlink" title="系统升级"></a>系统升级</h2><p><img src="/2022/f15ac6f4/image-20221103090149675.png" alt="image-20221103090149675"></p><ul><li>系统升级相关<ul><li>一般来说<code>Nintendo</code>和<code>emuMMC</code>是需要保留的文件, 其他文件是大气层系统相关的文件</li><li>小版本升级可以直接在相册内用<code>daybreak</code>升级<code>14.1.1-&gt;14.1.2</code>, 大版本升级<code>14.1.2-&gt;15.0.0</code>因为可能需要升级大气层系统(atmosphere)所以需要把SD卡拆下来, 删掉除了<code>Nintendo</code>和<code>emuMMC</code>之外的全部文件, 然后找升级包去覆盖掉.</li></ul></li></ul><blockquote><p>  大气层虚拟系统升级分为两部分依次进行：</p><ul><li><p>第1步.大气层更新：<br><a href="https://github.com/AK478BB/AK-Atmosphere/releases/">下载最新版本整合包</a>，保留TF卡中nintendo和emummc文件夹，其它文件全部删除，将最新整合包内的文件和文件夹放入TF卡根目录。<br>补充：如果用第三方软件JKSV或Checkpiont存档过，可以将TF卡根目录JKSV或Checkpiont文件夹一并保留；另外金手指、汉化补丁、MOD等均在TF卡根目录<code>atmosphere\contents</code>文件夹内，可提前拷出。</p></li><li><p>第2步.虚拟系统固件升级：<br><a href="https://darthsternie.net/switch-firmwares/">下载需要升级的系统固件</a>，解压后放在TF卡根目录，用Daybreak升级。<br>进虚拟系统相册，打开Daybreak：<br>1).选择已解压并复制到TF卡的固件包，程序会先验证刷机包，验证通过之后选择Continue。<br>2).选择恢复出厂设置还是保留数据刷机，选Preserve settings。<br>3).选择驱动选择，选Install(fat32+exfat)。<br>4).最后会询问你是否决定要更新系统，选continue。<br>5).刷机进度走完之后会让你选择关机还是重启，选Reboot。<br>升级完毕</p></li></ul><p>  P.S.<br>  一、不拔卡更新大气层方法：<br>  进相册，选reboot_to_payload，进入到hekate，选“TOOLS”–进“USB TOOLS”–选“SD Card”，相当于读卡器功能，然后按照步骤更新整合包即可，当然拷贝游戏文件也可以。</p><p>二、 升级后打开游戏报错，可尝试进一次维护模式：<br>  开机一直按住音量+不松手，出蓝色界面后按下音量-，此时是一起按住音量+和音量-的，即可进入到维护模式，什么也不做按一下电源键关机。</p><p>三、安装游戏推荐用DBI，简要教程：<br>  连接电脑，打开DBI，选Run MTP responder，电脑端打开switch，里面有多个盘符，常用两个：<br>  1.安装游戏到SD卡：打开盘符MicroSD install，直接把游戏拖进去或复制粘贴进去即可安装，NSP、NSZ、XCI、XCZ格式均支持；可以一起拖多个文件进去。<br>  2.往SD卡拷贝文件：盘符External SD Card。<br>  3.cleanup orphaned files清除无效数据，是个不错的功能。</p></blockquote><h2 id="资源及参考链接"><a href="#资源及参考链接" class="headerlink" title="资源及参考链接"></a>资源及参考链接</h2><p><a href="https://darthsternie.net/switch-firmwares/">Switch 离线升级固件(分为 大陆版 和 @全球版)</a> 我这台是全球版的</p><p><a href="https://shipengliang.com/games/switch-%E5%A4%A7%E6%B0%94%E5%B1%82-atmosphere-%E5%A6%82%E4%BD%95%E7%A6%BB%E7%BA%BF%E5%8D%87%E7%BA%A7%E7%B3%BB%E7%BB%9F.html">Switch 大气层 Atmosphere 如何离线升降级系统</a></p><p><a href="https://shipengliang.com/games/switch-firmware-%e5%9b%ba%e4%bb%b6%e4%b8%8b%e8%bd%bd.html">Switch Firmware固件最新版、NS 历史版本下载列表：</a></p><p><a href="https://github.com/Atmosphere-NX/Atmosphere/releases">Atmosphere-NX&#x2F;Atmosphere Github链接</a></p><p><a href="https://github.com/AK478BB/AK-Atmosphere/releases/">AK原版大气层整合包</a></p><h1 id="安装游戏"><a href="#安装游戏" class="headerlink" title="安装游戏"></a>安装游戏</h1><ul><li>需要准备的工具<ul><li>游戏资源</li><li>NS-Usbloader PC端程序</li><li>Awoo NS端</li><li>USB-C 线缆</li></ul></li></ul><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><ul><li>如果可以请优先支持正版</li><li>优先点击广告, 请勿白嫖</li><li>为众人抱薪者，不可使其冻毙于风雪</li></ul><p><a href="https://xxxxx520.com/27637.html">https://xxxxx520.com/27637.html</a></p><p><a href="https://xxxxx520.net/3892.html">https://xxxxx520.net/3892.html</a></p><h2 id="NS-Usbloader-PC端"><a href="#NS-Usbloader-PC端" class="headerlink" title="NS-Usbloader PC端"></a>NS-Usbloader PC端</h2><ul><li>通过USB安装游戏, 以及电脑端开机注入都可用</li><li>这个需要java环境, 安装JRE(Java Runtime Environment)即可.</li><li>这个工具也可以把电脑当作注入器用</li></ul><p><a href="https://github.com/developersu/ns-usbloader/">https://github.com/developersu/ns-usbloader/</a></p><h2 id="NX-Loader-安卓端"><a href="#NX-Loader-安卓端" class="headerlink" title="NX-Loader 安卓端"></a>NX-Loader 安卓端</h2><ul><li>需要一根OTG线和一根typec线</li><li>可以把手机当作注入器</li></ul><p><a href="https://github.com/DavidBuchanan314/NXLoader">Get the APK release</a></p><p><a href="https://github.com/DavidBuchanan314/NXLoader">NXLoader: My first Android app: Launch Fusée Gelée payloads from stock Android</a></p><h2 id="Awoo-NS端"><a href="#Awoo-NS端" class="headerlink" title="Awoo NS端"></a>Awoo NS端</h2><ul><li>NS端安装游戏</li><li>有些游戏安装不了，可以尝试长按R启动任意一个游戏，再用awoo安装</li></ul><p><a href="https://github.com/Huntereb/Awoo-Installer">https://github.com/Huntereb/Awoo-Installer</a></p><h1 id="金手指-作弊器"><a href="#金手指-作弊器" class="headerlink" title="金手指(作弊器)"></a>金手指(作弊器)</h1><p>进入NS的相册, 将NS作为U盘挂载到电脑, <code>DBI -&gt; Run MTP responder</code>, 找到这个目录<code>此电脑\Switch\1: External SD Card\atmosphere\contents</code>这个目录就是NS的金手指存放位置.</p><p>目录下64位16进制的文件夹名, 这个序号就代表着不同的游戏.</p><p>我们找到对应游戏, 打开文件夹后, 里面会有一个<code>cheats</code>的文件夹, 我们打开它, 里面有一个<code>*.txt</code>文件, 这个文件应该记录的就是内存地址, 我们去网络上找到别人保存好的内存地址信息(<code>cheats</code>文件), 放到这个<code>atmosphere\contents</code>目录下, 在NS端就能看到对应的金手指修改选项了, 注意可能需要关掉游戏重新开一下.</p><h2 id="64位游戏ID-对应-游戏名查询"><a href="#64位游戏ID-对应-游戏名查询" class="headerlink" title="64位游戏ID 对应 游戏名查询"></a>64位游戏ID 对应 游戏名查询</h2><p>调出特斯拉界面选择金手指, 即可查到游戏ID</p><p><a href="https://github.com/ibnux/switch-cheat/blob/master/GAMES.md">https://github.com/ibnux/switch-cheat/blob/master/GAMES.md</a></p><p><a href="https://switchbrew.org/w/index.php?title=Title_list/Games">https://switchbrew.org/w/index.php?title=Title_list/Games</a></p><h2 id="cheats-金手指"><a href="#cheats-金手指" class="headerlink" title="cheats 金手指"></a>cheats 金手指</h2><p><a href="https://github.com/ibnux/switch-cheat">https://github.com/ibnux/switch-cheat</a></p><h1 id="Misc"><a href="#Misc" class="headerlink" title="Misc."></a>Misc.</h1><h2 id="TX-转-大气层"><a href="#TX-转-大气层" class="headerlink" title="TX 转 大气层"></a>TX 转 大气层</h2><p><a href="https://www.bilibili.com/video/BV1DZ4y1B777/?spm_id_from=333.788">https://www.bilibili.com/video/BV1DZ4y1B777/?spm_id_from=333.788</a></p><h2 id="特斯拉插件-Tesla-Menu-类似快捷菜单"><a href="#特斯拉插件-Tesla-Menu-类似快捷菜单" class="headerlink" title="特斯拉插件(Tesla-Menu) 类似快捷菜单"></a>特斯拉插件(Tesla-Menu) 类似快捷菜单</h2><blockquote><p>  <strong>Switch特斯拉插件</strong>(Tesla-Menu)是一个很实用的功能插件的集合。可以直接在switch系统的任何界面通过组合按键调取左屏幕弹窗打开各种功能的快捷开关！目前已经实现的，开关switch硬件信息显示，开关FPS显示，<strong>开关超频</strong>，切换TV模式，这个平台就好比是简洁版相册，相册里面的各种软件就是完整版，这个Tesla-Menu平台提供的功能就相当于缩减版！不用复杂的操作，只是简单的开关，好处就是精简不占用太多资源！不用来返相册去开关软件！</p></blockquote><p>调出菜单: <code>L + ↓</code></p><p>FPS界面调出: 同时按下 <code>左右摇杆</code></p>]]></content>
    
    
    <categories>
      
      <category>more_interest</category>
      
    </categories>
    
    
    <tags>
      
      <tag>switch</tag>
      
      <tag>nintendo</tag>
      
      <tag>game</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker</title>
    <link href="/2022/f5f9fa9b/"/>
    <url>/2022/f5f9fa9b/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h1 id="Docker是什么-如何理解Docker"><a href="#Docker是什么-如何理解Docker" class="headerlink" title="Docker是什么&amp;如何理解Docker"></a>Docker是什么&amp;如何理解Docker</h1><p>Docker的底层原理</p><p>cgroup</p><p>namespace</p><p>容器(container)有不同的状态, 停止状态</p><p>镜像(image)是docker生命周期中的构建或打包阶段, 而容器(container)则是启动或执行阶段.</p><p>docker hub</p><p>!!ADD ME!!</p><p><img src="/2022/f5f9fa9b/architecture.svg" alt="Docker Architecture Diagram"></p><p><img src="/2022/f5f9fa9b/mark4536000.image" alt="img"></p><p><img src="/2022/f5f9fa9b/watermark16682557597978.png" alt="x"></p><p><img src="/2022/f5f9fa9b/watermark.png" alt="xx"></p><p><img src="/2022/f5f9fa9b/202111041612065293278565.png" alt="何種應用適合PaaS平台容器/微服務架構釋疑| 網管人"></p><h2 id="Docker-和-VM-的区别"><a href="#Docker-和-VM-的区别" class="headerlink" title="Docker 和 VM 的区别"></a>Docker 和 VM 的区别</h2><p>二者的不同：</p><ul><li>VM(VMware)在宿主机器、宿主机器操作系统的基础上创建虚拟层、虚拟化的操作系统、虚拟化的仓库，然后再安装应用；</li><li>Container(Docker容器)，在宿主机器、宿主机器操作系统上创建Docker引擎，在引擎的基础上再安装应用。</li></ul><p><img src="/2022/f5f9fa9b/9114e4a753de14a7531e867b908e6660.png" alt="img"></p><p><strong>与传统VM特性对比：</strong><br>作为一种轻量级的虚拟化方式，Docker在运行应用上跟传统的虚拟机方式相比具有显著优势：</p><ul><li>Docker 容器很快，启动和停止可以在秒级实现，这相比传统的虚拟机方式要快得多。</li><li>Docker 容器对系统资源需求很少，一台主机上可以同时运行数千个Docker容器。</li><li>Docker 通过类似Git的操作来方便用户获取、分发和更新应用镜像，指令简明，学习成本较低。</li><li>Docker 通过Dockerfile配置文件来支持灵活的自动化创建和部署机制，提高工作效率。</li><li>Docker 容器除了运行其中的应用之外，基本不消耗额外的系统资源，保证应用性能的同时，尽量减小系统开销。</li><li>Docker 利用Linux系统上的多种防护机制实现了严格可靠的隔离。从1.3版本开始，Docker引入了安全选项和镜像签名机制，极大地提高了使用Docker的安全性。</li></ul><table><thead><tr><th>特性</th><th>Docker</th><th>VM</th></tr></thead><tbody><tr><td>启动速度</td><td>秒级</td><td>分钟级</td></tr><tr><td>硬盘使用</td><td>一般为MB</td><td>一般为GB</td></tr><tr><td>性能</td><td>接近原生</td><td>弱于原生</td></tr><tr><td>系统支持量</td><td>单机支持上千个容器</td><td>一般几十个</td></tr></tbody></table><h1 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h1><p><strong>Docker Desktop</strong></p><p>参考官方的安装<a href="https://docs.docker.com/get-docker/">文档</a></p><p>Ubuntu的安装参考<a href="https://docs.docker.com/desktop/install/ubuntu/">文档</a></p><p><strong>Docker Engine</strong></p><p>Engine安装<a href="https://docs.docker.com/engine/install/ubuntu/">文档</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Add Docker<span class="hljs-string">&#x27;s official GPG key:</span></span><br>sudo apt-get update<br>sudo apt-get install ca-certificates curl gnupg<br>sudo install -m 0755 -d /etc/apt/keyrings<br>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg<br>sudo chmod a+r /etc/apt/keyrings/docker.gpg<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">Add the repository to Apt sources:</span></span><br>echo \<br>  &quot;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \<br><span class="hljs-meta prompt_">  $</span><span class="language-bash"><span class="hljs-string">(. /etc/os-release &amp;&amp; echo &quot;$VERSION_CODENAME&quot;) stable&quot; | \</span></span><br><span class="hljs-string"><span class="language-bash">  sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span></span><br>sudo apt-get update<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">Install Docker</span></span><br>sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">Add your user to the docker group</span></span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">可以运行docker命令不再加sudo</span></span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">!注意! 需要注销后重新登录</span></span><br>sudo usermod -aG docker $USER<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">Testing the installation</span></span><br>docker version<br>sudo docker run hello-world<br></code></pre></td></tr></table></figure><h1 id="Docker入门-命令"><a href="#Docker入门-命令" class="headerlink" title="Docker入门&amp;命令"></a>Docker入门&amp;命令</h1><h2 id="☆-docker-run"><a href="#☆-docker-run" class="headerlink" title="☆ docker run"></a>☆ docker run</h2><p><strong>docker run ：</strong>创建一个新的容器并运行一个命令</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><code>-a stdin</code>: 指定标准输入输出内容类型，可选 STDIN&#x2F;STDOUT&#x2F;STDERR 三项；</li><li>☆<code>-d</code>: 后台运行容器，并返回容器ID；</li><li>☆<code>-i</code>: 以交互模式运行容器，通常与 -t 同时使用；</li><li><code>-P</code>: 随机端口映射，容器内部端口<strong>随机</strong>映射到主机的端口</li><li><code>-p</code>: 指定端口映射，格式为：<strong>主机(宿主)端口:容器端口</strong></li><li>☆<code>-t</code>: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</li><li>☆<code>--name=&quot;nginx-lb&quot;</code>: 为容器指定一个名称；</li><li><code>--dns 8.8.8.8</code>: 指定容器使用的DNS服务器，默认和宿主一致；</li><li><code>--dns-search example.com</code>: 指定容器DNS搜索域名，默认和宿主一致；</li><li><code>-h &quot;mars&quot;</code>: 指定容器的hostname；</li><li>☆<code>-e username=&quot;ritchie&quot;</code>: 设置环境变量；</li><li><code>--env-file=[]</code>: 从指定文件读入环境变量；</li><li><code>--cpuset=&quot;0-2&quot; or --cpuset=&quot;0,1,2&quot;</code>: 绑定容器到指定CPU运行；</li><li><code>-m</code>:设置容器使用内存最大值；</li><li><code>--net=&quot;bridge&quot;</code>: 指定容器的网络连接类型，支持 bridge&#x2F;host&#x2F;none&#x2F;container: 四种类型；</li><li><code>--link=[]</code>: 添加链接到另一个容器；</li><li><code>--expose=[]</code>: 开放一个端口或一组端口；</li><li>☆<code>--volume , -v</code>: 绑定一个卷, (或者称作<strong>映射文件夹</strong>，将特定文件夹映射到特定目录)</li><li><code>–rm</code>: 容器退出时自动删除</li><li>☆<code>--restart </code>: 指定重启策略 容器在退出时应该或不应该如何重新启动。可选参数有<code>no</code>、<code> always</code>、<code>on-failure[:max-retries]</code>、<code>unless-stopped</code></li></ul><h3 id="设置工作目录-w"><a href="#设置工作目录-w" class="headerlink" title="设置工作目录 (-w)"></a>设置工作目录 (-w)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker  run -w /path/to/dir/ -i -t  ubuntu <span class="hljs-built_in">pwd</span><br>/path/to/dir<br></code></pre></td></tr></table></figure><p><code>-w</code> 允许命令在给定的目录中执行，这里是 <code>/path/to/dir/</code>。 如果路径不存在，则在容器内创建。</p><h3 id="挂载卷-v-–read-only"><a href="#挂载卷-v-–read-only" class="headerlink" title="挂载卷 (-v, –read-only)"></a>挂载卷 (-v, –read-only)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker  run  -v `<span class="hljs-built_in">pwd</span>`:`<span class="hljs-built_in">pwd</span>` -w `<span class="hljs-built_in">pwd</span>` -i -t  ubuntu <span class="hljs-built_in">pwd</span><br><br><span class="hljs-comment"># 只读(ro)和读写(rw)权限</span><br>docker run -v <span class="hljs-variable">$PWD</span>/web:var/www/html/web:ro<br></code></pre></td></tr></table></figure><p><code>-v</code>标志将当前工作目录挂载到容器中。 <code>-w</code> 让命令在当前工作目录中执行，方法是将工作目录更改为pwd返回的值。所以这个组合使用容器执行命令，但在当前工作目录中。</p><h3 id="发布或者暴露端口-p-–expose"><a href="#发布或者暴露端口-p-–expose" class="headerlink" title="发布或者暴露端口 (-p, –expose)"></a>发布或者暴露端口 (-p, –expose)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -p 127.0.0.1:80:8080/tcp ubuntu bash<br></code></pre></td></tr></table></figure><p>这将容器的端口8080绑定到主机的127.0.0.1上的TCP端口80。还可以指定udp和sctp端口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run --expose 80 ubuntu bash<br></code></pre></td></tr></table></figure><p>这会暴露容器的端口80，而不会将端口发布到主机系统接口。</p><h3 id="设置环境变量-e-–env-–env-file"><a href="#设置环境变量-e-–env-–env-file" class="headerlink" title="设置环境变量(-e, –env, –env-file)"></a>设置环境变量(-e, –env, –env-file)</h3><p>可以通过<code>-e, --env, --env-file</code> 设置容器的环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -e MYVAR1 --<span class="hljs-built_in">env</span> MYVAR2=foo --env-file ./env.list ubuntu bash<br></code></pre></td></tr></table></figure><p>本地已经export的环境变量，可以不用&#x3D;号和值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> VAR1=value1<br><span class="hljs-built_in">export</span> VAR2=value2<br><br>$ docker run --<span class="hljs-built_in">env</span> VAR1 --<span class="hljs-built_in">env</span> VAR2 ubuntu <span class="hljs-built_in">env</span> | grep VAR<br>VAR1=value1<br>VAR2=value2<br></code></pre></td></tr></table></figure><h3 id="在容器上设置元数据-l-–label-–label-file"><a href="#在容器上设置元数据-l-–label-–label-file" class="headerlink" title="在容器上设置元数据(-l, –label, –label-file)"></a>在容器上设置元数据(-l, –label, –label-file)</h3><p>可以通过<code>-l, --label, --label-file</code> 设置容器的label：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -l my-label --label com.example.foo=bar ubuntu bash<br></code></pre></td></tr></table></figure><h3 id="将容器连接到网络-–network"><a href="#将容器连接到网络-–network" class="headerlink" title="将容器连接到网络(–network)"></a>将容器连接到网络(–network)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -itd --network=my-net busybox<br>docker run -itd --network=my-net --ip=10.10.9.75 busybox<br></code></pre></td></tr></table></figure><p>也可以使用 <code>docker connect</code> 命令</p><h3 id="从容器挂载卷-–volumes-from"><a href="#从容器挂载卷-–volumes-from" class="headerlink" title="从容器挂载卷(–volumes-from)"></a>从容器挂载卷(–volumes-from)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run --volumes-from 777f7dc92da7 --volumes-from ba8c0c54f0f2:ro -i -t ubuntu <span class="hljs-built_in">pwd</span><br></code></pre></td></tr></table></figure><h2 id="☆-docker-start-stop-restart"><a href="#☆-docker-start-stop-restart" class="headerlink" title="☆ docker start&#x2F;stop&#x2F;restart"></a>☆ docker start&#x2F;stop&#x2F;restart</h2><p><strong>docker start</strong> :启动一个或多个已经被停止的容器</p><p><strong>docker stop</strong> :停止一个运行中的容器</p><p><strong>docker restart</strong> :重启容器</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker start [OPTIONS] CONTAINER [CONTAINER...]<br>docker stop [OPTIONS] CONTAINER [CONTAINER...]<br>docker restart [OPTIONS] CONTAINER [CONTAINER...]<br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><p>启动已被停止的容器myrunoob</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker start myrunoob<br></code></pre></td></tr></table></figure><p>停止运行中的容器myrunoob</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker stop myrunoob<br></code></pre></td></tr></table></figure><p>重启容器myrunoob</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker restart myrunoob<br></code></pre></td></tr></table></figure><h2 id="docker-kill"><a href="#docker-kill" class="headerlink" title="docker kill"></a>docker kill</h2><p><strong>docker kill</strong> :杀掉一个运行中的容器。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker kill [OPTIONS] CONTAINER [CONTAINER...]<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><code>-s</code>:向容器发送一个信号</li></ul><p><strong>实例</strong></p><p>杀掉运行中的容器“docker_ubuntu”</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">kill</span> -s KILL docker_ubuntu</span><br>docker_ubuntu<br></code></pre></td></tr></table></figure><h2 id="☆-docker-rm"><a href="#☆-docker-rm" class="headerlink" title="☆ docker rm"></a>☆ docker rm</h2><p><strong>docker rm ：</strong>删除一个或多个容器。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rm [OPTIONS] CONTAINER [CONTAINER...]<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><code>-f</code> :通过 SIGKILL 信号强制删除一个运行中的容器。</li><li><code>-l</code>:移除容器间的网络连接，而非容器本身。</li><li><code>-v</code>:删除与容器关联的卷。</li></ul><p><strong>实例</strong></p><p>强制删除容器 db01、db02：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rm -f db01 db02<br></code></pre></td></tr></table></figure><p>移除容器 nginx01 对容器 db01 的连接，连接名 db：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rm -l db <br></code></pre></td></tr></table></figure><p>删除容器 nginx01, 并删除容器挂载的数据卷：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rm -v nginx01<br></code></pre></td></tr></table></figure><p>删除所有已经停止的容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rm $(docker ps -a -q)<br></code></pre></td></tr></table></figure><h2 id="docker-pause-unpause"><a href="#docker-pause-unpause" class="headerlink" title="docker pause&#x2F;unpause"></a>docker pause&#x2F;unpause</h2><p><strong>docker pause</strong> :暂停容器中所有的进程。</p><p><strong>docker unpause</strong> :恢复容器中所有的进程。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pause CONTAINER [CONTAINER...]<br>docker unpause CONTAINER [CONTAINER...]<br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><p>暂停数据库容器db01提供服务。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pause db01<br></code></pre></td></tr></table></figure><p>恢复数据库容器 db01 提供服务。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker unpause db01<br></code></pre></td></tr></table></figure><h2 id="docker-create"><a href="#docker-create" class="headerlink" title="docker create"></a>docker create</h2><p><strong>docker create ：</strong>创建一个新的容器但不启动它</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker create [OPTIONS] IMAGE [COMMAND] [ARG...]<br></code></pre></td></tr></table></figure><p>语法同 <code>docker run</code></p><p><strong>实例</strong></p><p>使用docker镜像nginx:latest创建一个容器,并将容器命名为myrunoob</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker create  --name myrunoob  nginx:latest      <br>09b93464c2f75b7b69f83d56a9cfc23ceb50a48a9db7652ee4c27e3e2cb1961f<br></code></pre></td></tr></table></figure><h2 id="☆-docker-exec"><a href="#☆-docker-exec" class="headerlink" title="☆ docker exec"></a>☆ docker exec</h2><p><strong>docker exec ：</strong>在运行的容器中执行命令</p><ul><li>典型的使用, 在docker中运行<code>bash</code>, 所使用的命令就是<code>docker exec -ti my_container /bin/bash</code></li></ul><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec [OPTIONS] CONTAINER COMMAND [ARG...]<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><code>-d</code>:分离模式: 在后台运行</li><li><code>-i</code>:即使没有附加也保持STDIN 打开</li><li><code>-t</code>:分配一个伪终端</li></ul><p><strong>实例</strong></p><p>在容器 mynginx 中以交互模式执行容器内 &#x2F;root&#x2F;runoob.sh 脚本:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker exec -it mynginx /bin/sh /root/runoob.sh<br>http://www.runoob.com/<br></code></pre></td></tr></table></figure><p>在容器 mynginx 中开启一个交互模式的终端:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker exec -i -t  mynginx /bin/bash<br>root@b1a0703e41e7:/#<br></code></pre></td></tr></table></figure><p>也可以通过 <strong>docker ps -a</strong> 命令查看已经在运行的容器，然后使用容器 ID 进入容器。</p><p>查看已经在运行的容器 ID：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">docker ps -a</span> <br>...<br>9df70f9a0714        openjdk             &quot;/usercode/script.sh…&quot; <br>...<br></code></pre></td></tr></table></figure><p>第一列的 9df70f9a0714 就是容器 ID。</p><p>通过 exec 命令对指定的容器执行 bash:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">docker <span class="hljs-built_in">exec</span> -it 9df70f9a0714 /bin/bash</span><br></code></pre></td></tr></table></figure><h2 id="↓-容器管理-container-↓"><a href="#↓-容器管理-container-↓" class="headerlink" title="↓ 容器管理 container ↓"></a>↓ 容器管理 container ↓</h2><h2 id="☆-docker-ps"><a href="#☆-docker-ps" class="headerlink" title="☆ docker ps"></a>☆ docker ps</h2><p><strong>docker ps :</strong> 列出容器</p><ul><li>典型使用方法, 列出所有的容器(container), <code>docker ps -a</code></li></ul><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker ps [OPTIONS]<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><code>-a</code> :显示所有的容器，包括未运行的。</li><li><code>-f</code> :根据条件过滤显示的内容。</li><li><code>--format</code> :指定返回值的模板文件。</li><li><code>-l</code>:显示最近创建的容器。</li><li><code>-n</code>:列出最近创建的n个容器。</li><li><code>--no-trunc</code> :不截断输出。</li><li><code>-q</code> :静默模式，只显示容器编号。</li><li><code>-s</code>:显示总的文件大小。</li></ul><p><strong>实例</strong></p><p>列出所有在运行的容器信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker ps<br>CONTAINER ID   IMAGE          COMMAND                ...  PORTS                    NAMES<br>09b93464c2f7   nginx:latest   &quot;nginx -g &#x27;daemon off&quot; ...  80/tcp, 443/tcp          myrunoob<br>96f7f14e99ab   mysql:5.6      &quot;docker-entrypoint.sh&quot; ...  0.0.0.0:3306-&gt;3306/tcp   mymysql<br></code></pre></td></tr></table></figure><p>输出详情介绍：</p><p><strong>CONTAINER ID:</strong> 容器 ID。</p><p><strong>IMAGE:</strong> 使用的镜像。</p><p><strong>COMMAND:</strong> 启动容器时运行的命令。</p><p><strong>CREATED:</strong> 容器的创建时间。</p><p><strong>STATUS:</strong> 容器状态。</p><p>状态有7种：</p><ul><li>created（已创建）</li><li>restarting（重启中）</li><li>running（运行中）</li><li>removing（迁移中）</li><li>paused（暂停）</li><li>exited（停止）</li><li>dead（死亡）</li></ul><p><strong>PORTS:</strong> 容器的端口信息和使用的连接类型（tcp\udp）。</p><p><strong>NAMES:</strong> 自动分配的容器名称。</p><p>列出最近创建的5个容器信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker ps -n 5<br>CONTAINER ID        IMAGE               COMMAND                   CREATED           <br>09b93464c2f7        nginx:latest        &quot;nginx -g &#x27;daemon off&quot;    2 days ago   ...     <br>b8573233d675        nginx:latest        &quot;/bin/bash&quot;               2 days ago   ...     <br>b1a0703e41e7        nginx:latest        &quot;nginx -g &#x27;daemon off&quot;    2 days ago   ...    <br>f46fb1dec520        5c6e1090e771        &quot;/bin/sh -c &#x27;set -x \t&quot;   2 days ago   ...   <br>a63b4a5597de        860c279d2fec        &quot;bash&quot;                    2 days ago   ...<br></code></pre></td></tr></table></figure><p>列出所有创建的容器ID。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker ps -a -q<br>09b93464c2f7<br>b8573233d675<br>b1a0703e41e7<br>f46fb1dec520<br>a63b4a5597de<br>6a4aa42e947b<br>de7bb36e7968<br>43a432b73776<br>664a8ab1a585<br>ba52eb632bbd<br>...<br></code></pre></td></tr></table></figure><h2 id="docker-inspect-获取容器信息"><a href="#docker-inspect-获取容器信息" class="headerlink" title="docker inspect 获取容器信息"></a>docker inspect 获取容器信息</h2><p><strong>docker inspect :</strong> 获取容器&#x2F;镜像的元数据。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker inspect [OPTIONS] NAME|ID [NAME|ID...]<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><code>-f</code> :指定返回值的模板文件。</li><li><code>-s</code>显示总的文件大小。</li><li><code>--type</code>为指定类型返回JSON。</li></ul><p><strong>实例</strong></p><p>获取镜像mysql:5.6的元信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker inspect mysql:5.6<br>[<br>    &#123;<br>        &quot;Id&quot;: &quot;sha256:2c0964ec182ae9a045f866bbc2553087f6e42bfc16074a74fb820af235f070ec&quot;,<br>        &quot;RepoTags&quot;: [<br>            &quot;mysql:5.6&quot;<br>        ],<br>        &quot;RepoDigests&quot;: [],<br>        &quot;Parent&quot;: &quot;&quot;,<br>        &quot;Comment&quot;: &quot;&quot;,<br>        &quot;Created&quot;: &quot;2016-05-24T04:01:41.168371815Z&quot;,<br>        &quot;Container&quot;: &quot;e0924bc460ff97787f34610115e9363e6363b30b8efa406e28eb495ab199ca54&quot;,<br>        &quot;ContainerConfig&quot;: &#123;<br>            &quot;Hostname&quot;: &quot;b0cf605c7757&quot;,<br>            &quot;Domainname&quot;: &quot;&quot;,<br>            &quot;User&quot;: &quot;&quot;,<br>            &quot;AttachStdin&quot;: false,<br>            &quot;AttachStdout&quot;: false,<br>            &quot;AttachStderr&quot;: false,<br>            &quot;ExposedPorts&quot;: &#123;<br>                &quot;3306/tcp&quot;: &#123;&#125;<br>            &#125;,<br>...<br></code></pre></td></tr></table></figure><p>获取正在运行的容器mymysql的 IP。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker inspect --format=&#x27;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27; mymysql<br>172.17.0.3<br></code></pre></td></tr></table></figure><h2 id="☆-docker-top-查看容器内进程信息"><a href="#☆-docker-top-查看容器内进程信息" class="headerlink" title="☆ docker top 查看容器内进程信息"></a>☆ docker top 查看容器内进程信息</h2><p>**docker top :**查看容器中运行的进程信息，支持 ps 命令参数。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker top [OPTIONS] CONTAINER [ps OPTIONS]<br></code></pre></td></tr></table></figure><p>容器运行时不一定有&#x2F;bin&#x2F;bash终端来交互执行top命令，而且容器还不一定有top命令，可以使用docker top来实现查看container中正在运行的进程。</p><p><strong>实例</strong></p><p>查看容器mymysql的进程信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~/mysql$ docker top mymysql<br>UID    PID    PPID    C      STIME   TTY  TIME       CMD<br>999    40347  40331   18     00:58   ?    00:00:02   mysqld<br></code></pre></td></tr></table></figure><p>查看所有运行容器的进程信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span>  `docker ps |grep Up|awk <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span>`;<span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span> \ &amp;&amp;docker top <span class="hljs-variable">$i</span>; <span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><h2 id="☆-docker-update-动态更新容器配置"><a href="#☆-docker-update-动态更新容器配置" class="headerlink" title="☆ docker update 动态更新容器配置"></a>☆ docker update 动态更新容器配置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker update [OPTIONS] CONTAINER [CONTAINER...]<br></code></pre></td></tr></table></figure><blockquote><p><strong>The <code>docker update</code> and <code>docker container update</code> commands are not supported for Windows containers.</strong></p></blockquote><table><thead><tr><th>名称、简写</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><code>--blkio-weight</code></td><td></td><td>块 IO（相对权重），介于 10 到 1000 之间，或 0 禁用（默认 0）</td></tr><tr><td><code>--cpu-period</code></td><td></td><td>限制CPU CFS（完全公平调度程序）周期</td></tr><tr><td><code>--cpu-quota</code></td><td></td><td>限制CPU CFS（完全公平调度程序）配额</td></tr><tr><td><code>--cpu-rt-period</code></td><td></td><td>限制CPU实时周期（以微秒为单位）</td></tr><tr><td><code>--cpu-rt-runtime</code></td><td></td><td>将CPU实时运行时间限制在微秒级</td></tr><tr><td><a href="https://docs.docker.com/engine/reference/commandline/update/#cpu-shares"><code>--cpu-shares</code></a>,<a href="https://docs.docker.com/engine/reference/commandline/update/#cpu-shares"><code>-c</code></a></td><td></td><td>CPU 份额（相对权重）</td></tr><tr><td><code>--cpus</code></td><td></td><td>CPU数量</td></tr><tr><td><code>--cpuset-cpus</code></td><td></td><td>允许执行的 CPU (0-3, 0,1)</td></tr><tr><td><code>--cpuset-mems</code></td><td></td><td>允许执行的 MEM (0-3, 0,1)</td></tr><tr><td><a href="https://docs.docker.com/engine/reference/commandline/update/#memory"><code>--memory</code></a>,<a href="https://docs.docker.com/engine/reference/commandline/update/#memory"><code>-m</code></a></td><td></td><td>内存限制 (bytes)</td></tr><tr><td><code>--memory-reservation</code></td><td></td><td>内存软限制</td></tr><tr><td><code>--memory-swap</code></td><td></td><td>交换限制等于内存加交换：-1 启用无限制交换</td></tr><tr><td><code>--pids-limit</code></td><td></td><td><a href="https://docs.docker.com/engine/api/v1.40/"><strong>API 1.40+</strong></a> 调整容器 pid 限制（设置 -1 表示无限制）</td></tr><tr><td><a href="https://docs.docker.com/engine/reference/commandline/update/#restart"><code>--restart</code></a></td><td></td><td>容器退出时应用的重新启动策略</td></tr></tbody></table><h4 id="restart"><a href="#restart" class="headerlink" title="restart"></a>restart</h4><p>–restart具体参数值详细信息：</p><table><thead><tr><th>flag</th><th>描述</th></tr></thead><tbody><tr><td><code>no</code></td><td>不要自动重启容器。 （默认）</td></tr><tr><td><code>on-failure[:max-retries]</code></td><td>如果容器因错误而退出（表现为非零退出代码），请重新启动容器。 （可选）使用该选项限制 Docker 守护进程尝试重新启动容器的次数<code>:max-retries</code>。该<code>on-failure</code>策略仅在容器因失败退出时提示重新启动。<strong>如果守护进程重新启动，它不会重新启动容器。</strong></td></tr><tr><td><code>always</code></td><td>如果容器停止，请务必重新启动容器。如果手动停止，则只有当 Docker 守护进程重新启动或手动重新启动容器本身时，它才会重新启动。 （请参阅<a href="https://docs.docker.com/config/containers/start-containers-automatically/#restart-policy-details">重启政策详细信息</a>中列出的第二个项目符号 ）</td></tr><tr><td><code>unless-stopped</code></td><td>与 类似<code>always</code>，只不过当容器停止（手动或其他方式）时，即使 Docker 守护进程重新启动，它也不会重新启动。</td></tr></tbody></table><ul><li>no - 容器退出时，不重启容器；</li><li>on-failure - 只有在非0状态退出时才从新启动容器；</li><li>always - 无论退出状态是如何，都重启容器；</li></ul><p>还可以在使用on-failure策略时，指定<a href="https://pythonjishu.com/tag/docker/">Docker</a>将尝试重新启动容器的最大次数。默认情况下，Docker将尝试永远重新启动容器。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker <span class="hljs-built_in">run</span> <span class="hljs-attribute">--restart</span>=on-failure:10 &lt;CONTAINER ID&gt;<br></code></pre></td></tr></table></figure><h2 id="docker-attach-附着容器"><a href="#docker-attach-附着容器" class="headerlink" title="docker attach 附着容器"></a>docker attach 附着容器</h2><p>**docker attach :**附着到正在运行中的容器。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker attach [OPTIONS] CONTAINER<br></code></pre></td></tr></table></figure><p><code>--no-stdin=false</code> 不连接标准输入</p><p><code>--sig-proxy=true</code> 将所有信号传递给进程（非TTY模式时也一样）但不传送SIGCHLD、SIGKILL、SIGSTOP信号。经常使用的信号如下：</p><h4 id="detach"><a href="#detach" class="headerlink" title="detach"></a><strong>detach</strong></h4><p>要在不退出 shell 的情况下分离 tty，请使用转义序列<code>Ctrl+P</code>后跟<code>Ctrl+ Q</code>。更多细节<a href="https://docs.docker.com/engine/reference/commandline/attach/">在这里</a>。</p><ul><li>docker run -t -i → 可以<code>^P^Q</code>使用 docker attach 分离和重新附加</li><li>docker run -i → 不能用<code>^P^Q</code>;分离 会破坏标准输入</li><li>docker run → 不能用<code>^P^Q</code>;分离 可以 SIGKILL 客户端；可以使用 docker attach 重新附加</li><li><code>docker attach --sig-proxy=false</code> 可以使用 <code>^C</code>来进行detach, <code>CTRL+c</code></li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a><strong>注意</strong></h3><p>要attach上去的容器必须正在运行，可以同时连接上同一个container来共享屏幕（与screen命令的attach类似）。</p><blockquote><p>  官方文档中说attach后可以通过CTRL-C来detach，但实际上经过我的测试，如果container当前在运行bash，CTRL-C自然是当前行的输入，没有退出；如果container当前正在前台运行进程，如输出nginx的access.log日志，CTRL-C不仅会导致退出容器，而且还stop了。这不是我们想要的，detach的意思按理应该是脱离容器终端，但容器依然运行。好在attach是可以带上–sig-proxy&#x3D;false来确保CTRL-D或CTRL-C不会关闭容器。</p></blockquote><p><strong>实例</strong></p><p>容器mynginx将访问日志指到标准输出，连接到容器查看访问信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker attach --sig-proxy=false mynginx<br>192.168.239.1 - - [10/Jul/2016:16:54:26 +0000] &quot;GET / HTTP/1.1&quot; 304 0 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36&quot; &quot;-&quot;<br></code></pre></td></tr></table></figure><h2 id="docker-events"><a href="#docker-events" class="headerlink" title="docker events"></a>docker events</h2><p><strong>docker events :</strong> 从服务器获取实时事件</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker events [OPTIONS]<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><strong>-f ：</strong>根据条件过滤事件；</li><li><strong>–since ：</strong>从指定的时间戳后显示所有事件;</li><li><strong>–until ：</strong>流水时间显示到指定的时间为止；</li></ul><p><strong>实例</strong></p><p>显示docker 2016年7月1日后的所有事件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~/mysql$ docker events  --since=&quot;1467302400&quot;<br>2016-07-08T19:44:54.501277677+08:00 network connect 66f958fd13dc4314ad20034e576d5c5eba72e0849dcc38ad9e8436314a4149d4 (container=b8573233d675705df8c89796a2c2687cd8e36e03646457a15fb51022db440e64, name=bridge, type=bridge)<br>2016-07-08T19:44:54.723876221+08:00 container start b8573233d675705df8c89796a2c2687cd8e36e03646457a15fb51022db440e64 (image=nginx:latest, name=elegant_albattani)<br>2016-07-08T19:44:54.726110498+08:00 container resize b8573233d675705df8c89796a2c2687cd8e36e03646457a15fb51022db440e64 (height=39, image=nginx:latest, name=elegant_albattani, width=167)<br>2016-07-08T19:46:22.137250899+08:00 container die b8573233d675705df8c89796a2c2687cd8e36e03646457a15fb51022db440e64 (exitCode=0, image=nginx:latest, name=elegant_albattani)<br>...<br></code></pre></td></tr></table></figure><p>显示docker 镜像为mysql:5.6 2016年7月1日后的相关事件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~/mysql$ docker events -f &quot;image&quot;=&quot;mysql:5.6&quot; --since=&quot;1467302400&quot; <br>2016-07-11T00:38:53.975174837+08:00 container start 96f7f14e99ab9d2f60943a50be23035eda1623782cc5f930411bbea407a2bb10 (image=mysql:5.6, name=mymysql)<br>2016-07-11T00:51:17.022572452+08:00 container kill 96f7f14e99ab9d2f60943a50be23035eda1623782cc5f930411bbea407a2bb10 (image=mysql:5.6, name=mymysql, signal=9)<br>2016-07-11T00:51:17.132532080+08:00 container die 96f7f14e99ab9d2f60943a50be23035eda1623782cc5f930411bbea407a2bb10 (exitCode=137, image=mysql:5.6, name=mymysql)<br>2016-07-11T00:51:17.514661357+08:00 container destroy 96f7f14e99ab9d2f60943a50be23035eda1623782cc5f930411bbea407a2bb10 (image=mysql:5.6, name=mymysql)<br>2016-07-11T00:57:18.551984549+08:00 container create c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (image=mysql:5.6, name=mymysql)<br>2016-07-11T00:57:18.557405864+08:00 container attach c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (image=mysql:5.6, name=mymysql)<br>2016-07-11T00:57:18.844134112+08:00 container start c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (image=mysql:5.6, name=mymysql)<br>2016-07-11T00:57:19.140141428+08:00 container die c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (exitCode=1, image=mysql:5.6, name=mymysql)<br>2016-07-11T00:58:05.941019136+08:00 container destroy c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (image=mysql:5.6, name=mymysql)<br>2016-07-11T00:58:07.965128417+08:00 container create a404c6c174a21c52f199cfce476e041074ab020453c7df2a13a7869b48f2f37e (image=mysql:5.6, name=mymysql)<br>2016-07-11T00:58:08.188734598+08:00 container start a404c6c174a21c52f199cfce476e041074ab020453c7df2a13a7869b48f2f37e (image=mysql:5.6, name=mymysql)<br>2016-07-11T00:58:20.010876777+08:00 container top a404c6c174a21c52f199cfce476e041074ab020453c7df2a13a7869b48f2f37e (image=mysql:5.6, name=mymysql)<br>2016-07-11T01:06:01.395365098+08:00 container top a404c6c174a21c52f199cfce476e041074ab020453c7df2a13a7869b48f2f37e (image=mysql:5.6, name=mymysql)<br></code></pre></td></tr></table></figure><p>如果指定的时间是到秒级的，需要将时间转成时间戳。如果时间为日期的话，可以直接使用，如–since&#x3D;”2016-07-01”。</p><h2 id="☆-docker-logs"><a href="#☆-docker-logs" class="headerlink" title="☆ docker logs"></a>☆ docker logs</h2><p><strong>docker logs :</strong> 获取容器的日志</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker logs [OPTIONS] CONTAINER<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><code>-f</code> : 跟踪日志输出</li><li><code>--since</code>显示某个开始时间的所有日志</li><li><code>-t</code> 显示时间戳</li><li><code>--tail</code>仅列出最新N条容器日志</li></ul><p><strong>实例</strong></p><p>跟踪查看容器mynginx的日志输出。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker logs -f mynginx<br>192.168.239.1 - - [10/Jul/2016:16:53:33 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36&quot; &quot;-&quot;<br>2016/07/10 16:53:33 [error] 5#5: *1 open() &quot;/usr/share/nginx/html/favicon.ico&quot; failed (2: No such file or directory), client: 192.168.239.1, server: localhost, request: &quot;GET /favicon.ico HTTP/1.1&quot;, host: &quot;192.168.239.130&quot;, referrer: &quot;http://192.168.239.130/&quot;<br>192.168.239.1 - - [10/Jul/2016:16:53:33 +0000] &quot;GET /favicon.ico HTTP/1.1&quot; 404 571 &quot;http://192.168.239.130/&quot; &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36&quot; &quot;-&quot;<br>192.168.239.1 - - [10/Jul/2016:16:53:59 +0000] &quot;GET / HTTP/1.1&quot; 304 0 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36&quot; &quot;-&quot;<br>...<br></code></pre></td></tr></table></figure><p>查看容器mynginx从2016年7月1日后的最新10条日志。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker logs --since=&quot;2016-07-01&quot; --tail=10 mynginx<br></code></pre></td></tr></table></figure><h2 id="docker-wait"><a href="#docker-wait" class="headerlink" title="docker wait"></a>docker wait</h2><p><strong>docker wait :</strong> 阻塞运行直到容器停止，然后打印出它的退出代码。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker wait [OPTIONS] CONTAINER [CONTAINER...]<br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker wait CONTAINER<br></code></pre></td></tr></table></figure><h2 id="docker-export-导出"><a href="#docker-export-导出" class="headerlink" title="docker export 导出"></a>docker export 导出</h2><p>**docker export :**将文件系统作为一个tar归档文件导出到STDOUT。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker export [OPTIONS] CONTAINER<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><code>-o</code>将输入内容写到文件。</li></ul><p><strong>实例</strong></p><p>将id为a404c6c174a2的容器按日期保存为tar文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker export -o mysql-`date +%Y%m%d`.tar a404c6c174a2<br>runoob@runoob:~$ ls mysql-`date +%Y%m%d`.tar<br>mysql-20160711.tar<br></code></pre></td></tr></table></figure><h2 id="docker-port"><a href="#docker-port" class="headerlink" title="docker port"></a>docker port</h2><p><strong>docker port :</strong> 列出指定的容器的端口映射，或者查找将PRIVATE_PORT NAT到面向公众的端口。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker port [OPTIONS] CONTAINER [PRIVATE_PORT[/PROTO]]<br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><p>查看容器mynginx的端口映射情况。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker port mymysql<br>3306/tcp -&gt; 0.0.0.0:3306<br></code></pre></td></tr></table></figure><h2 id="docker-stats-统计"><a href="#docker-stats-统计" class="headerlink" title="docker stats 统计"></a>docker stats 统计</h2><p><strong>docker stats :</strong> 统计显示容器资源的使用情况，包括：CPU、内存、网络 I&#x2F;O 等。</p><p>stats: abbr. 统计（statistics）；</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker stats [OPTIONS] [CONTAINER...]<br></code></pre></td></tr></table></figure><p>OPTIONS 说明：</p><ul><li><code>--all , -a</code> :显示所有的容器，包括未运行的。</li><li><code>format</code> :指定返回值的模板文件。</li><li><code>--no-stream</code> :展示当前状态就直接退出了，不再实时更新。</li><li><code>--no-trunc</code> :不截断输出。</li></ul><p><strong>实例</strong></p><p>列出所有在运行的容器信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$  docker stats<br>CONTAINER ID        NAME                                    CPU %               MEM USAGE / LIMIT     MEM %               NET I/O             BLOCK I/O           PIDS<br>b95a83497c91        awesome_brattain                        0.28%               5.629MiB / 1.952GiB   0.28%               916B / 0B           147kB / 0B          9<br>67b2525d8ad1        foobar                                  0.00%               1.727MiB / 1.952GiB   0.09%               2.48kB / 0B         4.11MB / 0B         2<br>e5c383697914        test-1951.1.kay7x1lh1twk9c0oig50sd5tr   0.00%               196KiB / 1.952GiB     0.01%               71.2kB / 0B         770kB / 0B          1<br>4bda148efbc0        random.1.vnc8on831idyr42slu578u3cr      0.00%               1.672MiB / 1.952GiB   0.08%               110kB / 0B          578kB / 0B          2<br></code></pre></td></tr></table></figure><p>输出详情介绍：</p><p><strong>CONTAINER ID 与 NAME:</strong> 容器 ID 与名称。</p><p><strong>CPU % 与 MEM %:</strong> 容器使用的 CPU 和内存的百分比。</p><p><strong>MEM USAGE &#x2F; LIMIT:</strong> 容器正在使用的总内存，以及允许使用的内存总量。</p><p><strong>NET I&#x2F;O:</strong> 容器通过其网络接口发送和接收的数据量。</p><p><strong>BLOCK I&#x2F;O:</strong> 容器从主机上的块设备读取和写入的数据量。</p><p><strong>PIDs:</strong> 容器创建的进程或线程数。</p><p>根据容器等 ID 或名称现实信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker stats awesome_brattain 67b2525d8ad1<br><br>CONTAINER ID        NAME                CPU %               MEM USAGE / LIMIT     MEM %               NET I/O             BLOCK I/O           PIDS<br>b95a83497c91        awesome_brattain    0.28%               5.629MiB / 1.952GiB   0.28%               916B / 0B           147kB / 0B          9<br>67b2525d8ad1        foobar              0.00%               1.727MiB / 1.952GiB   0.09%               2.48kB / 0B         4.11MB / 0B         2<br></code></pre></td></tr></table></figure><p>以 JSON 格式输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker stats nginx --no-stream --format &quot;&#123;&#123; json . &#125;&#125;&quot;<br>  &#123;&quot;BlockIO&quot;:&quot;0B / 13.3kB&quot;,&quot;CPUPerc&quot;:&quot;0.03%&quot;,&quot;Container&quot;:&quot;nginx&quot;,&quot;ID&quot;:&quot;ed37317fbf42&quot;,&quot;MemPerc&quot;:&quot;0.24%&quot;,&quot;MemUsage&quot;:&quot;2.352MiB / 982.5MiB&quot;,&quot;Name&quot;:&quot;nginx&quot;,&quot;NetIO&quot;:&quot;539kB / 606kB&quot;,&quot;PIDs&quot;:&quot;2&quot;&#125;<br></code></pre></td></tr></table></figure><p>输出指定的信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker stats --all --format &quot;table &#123;&#123;.Container&#125;&#125;\t&#123;&#123;.CPUPerc&#125;&#125;\t&#123;&#123;.MemUsage&#125;&#125;&quot; fervent_panini 5acfcb1b4fd1 drunk_visvesvaraya big_heisenberg<br>  &#123;&quot;BlockIO&quot;:&quot;0B / 13.3kB&quot;,&quot;CPUPerc&quot;:&quot;0.03%&quot;,&quot;Container&quot;:&quot;nginx&quot;,&quot;ID&quot;:&quot;ed37317fbf42&quot;,&quot;MemPerc&quot;:&quot;0.24%&quot;,&quot;MemUsage&quot;:&quot;2.352MiB / 982.5MiB&quot;,&quot;Name&quot;:&quot;nginx&quot;,&quot;NetIO&quot;:&quot;539kB / 606kB&quot;,&quot;PIDs&quot;:&quot;2&quot;&#125;<br><br>CONTAINER                CPU %               MEM USAGE / LIMIT<br>fervent_panini           0.00%               56KiB / 15.57GiB<br>5acfcb1b4fd1             0.07%               32.86MiB / 15.57GiB<br>drunk_visvesvaraya       0.00%               0B / 0B<br>big_heisenberg           0.00%               0B / 0B<br></code></pre></td></tr></table></figure><h2 id="↓-镜像管理-image-↓"><a href="#↓-镜像管理-image-↓" class="headerlink" title="↓ 镜像管理 image ↓"></a>↓ 镜像管理 image ↓</h2><h2 id="Docker-commit"><a href="#Docker-commit" class="headerlink" title="Docker commit"></a>Docker commit</h2><p><a href="https://yeasy.gitbook.io/docker_practice/image/commit">参考链接: 利用 commit 理解镜像构成</a></p><p>**docker commit :**从容器创建一个新的镜像。</p><blockquote><p>  我们并不推荐使用这个命令构建image, 我们会推荐使用更加强大的Dockerfile来进行构建</p></blockquote><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><p><code>-a</code> :提交的镜像作者；</p></li><li><p><code>-c</code>使用Dockerfile指令来创建镜像；</p></li><li><p><code>-m</code>提交时的说明文字；</p></li><li><p><code>-p</code> :在commit时，将容器暂停。</p></li></ul><p><strong>实例</strong></p><p>将容器a404c6c174a2 保存为新的镜像,并添加提交人信息和说明信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker commit -a &quot;runoob.com&quot; -m &quot;my apache&quot; a404c6c174a2  mymysql:v1 <br>sha256:37af1236adef1544e8886be23010b66577647a40bc02c0885a6600b33ee28057<br>runoob@runoob:~$ docker images mymysql:v1<br>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br>mymysql             v1                  37af1236adef        15 seconds ago      329 MB<br></code></pre></td></tr></table></figure><blockquote><p>  <strong><code>Docker commit</code>释义</strong></p><p>  要知道，当我们运行一个容器的时候（如果不使用卷的话），我们做的任何文件修改都会被记录于容器存储层里。而 Docker 提供了一个 <code>docker commit</code> 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。</p><p>  <strong>慎用 <code>docker commit</code></strong></p><p>  使用 <code>docker commit</code> 命令虽然可以比较直观的帮助理解镜像分层存储的概念，但是实际环境中并不会这样使用。</p><p>  首先，如果仔细观察之前的 <code>docker diff webserver</code> 的结果，你会发现除了真正想要修改的 <code>/usr/share/nginx/html/index.html</code> 文件外，由于命令的执行，还有很多文件被改动或添加了。这还仅仅是最简单的操作，如果是安装软件包、编译构建，那会有大量的无关内容被添加进来，将会导致镜像极为臃肿。</p><p>  此外，使用 <code>docker commit</code> 意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为 <strong>黑箱镜像</strong>，换句话说，就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知。而且，即使是这个制作镜像的人，过一段时间后也无法记清具体的操作。这种黑箱镜像的维护工作是非常痛苦的。</p><p>  而且，回顾之前提及的镜像所使用的分层存储的概念，除当前层外，之前的每一层都是不会发生改变的，换句话说，任何修改的结果仅仅是在当前层进行标记、添加、修改，而不会改动上一层。如果使用 <code>docker commit</code> 制作镜像，以及后期修改的话，每一次修改都会让镜像更加臃肿一次，所删除的上一层的东西并不会丢失，会一直如影随形的跟着这个镜像，即使根本无法访问到。这会让镜像更加臃肿。</p></blockquote><h2 id="☆-docker-cp-Copy-Data"><a href="#☆-docker-cp-Copy-Data" class="headerlink" title="☆ docker cp (Copy Data)"></a>☆ docker cp (Copy Data)</h2><p><code>docker cp</code> :用于容器与主机之间的数据拷贝。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-<br>docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><code>-L</code>保持源目标中的链接</li></ul><p><strong>实例</strong></p><p>将主机&#x2F;www&#x2F;runoob目录拷贝到容器96f7f14e99ab的&#x2F;www目录下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker cp /www/runoob 96f7f14e99ab:/www/<br></code></pre></td></tr></table></figure><p>将主机&#x2F;www&#x2F;runoob目录拷贝到容器96f7f14e99ab中，目录重命名为www。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker cp /www/runoob 96f7f14e99ab:/www<br></code></pre></td></tr></table></figure><p>将容器96f7f14e99ab的&#x2F;www目录拷贝到主机的&#x2F;tmp目录中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker cp  96f7f14e99ab:/www /tmp/<br></code></pre></td></tr></table></figure><h2 id="docker-diff"><a href="#docker-diff" class="headerlink" title="docker diff"></a>docker diff</h2><p><code>docker diff</code> : 检查容器里文件结构的更改。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker diff [OPTIONS] CONTAINER<br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><p>查看容器mymysql的文件结构更改。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker diff mymysql<br>A /logs<br>A /mysql_data<br>C /run<br>C /run/mysqld<br>A /run/mysqld/mysqld.pid<br>A /run/mysqld/mysqld.sock<br>C /tmp<br></code></pre></td></tr></table></figure><h2 id="↓-镜像仓库管理-↓"><a href="#↓-镜像仓库管理-↓" class="headerlink" title="↓ 镜像仓库管理 ↓"></a>↓ 镜像仓库管理 ↓</h2><h2 id="docker-login-logout"><a href="#docker-login-logout" class="headerlink" title="docker login&#x2F;logout"></a>docker login&#x2F;logout</h2><p><strong>docker login :</strong> 登陆到一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub</p><p><strong>docker logout :</strong> 登出一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker login [OPTIONS] [SERVER]<br>docker logout [OPTIONS] [SERVER]<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><code>-u</code> :登陆的用户名</li><li><code>-p</code> :登陆的密码</li></ul><p><strong>实例</strong></p><p>登陆到Docker Hub</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker login -u 用户名 -p 密码<br></code></pre></td></tr></table></figure><p>登出Docker Hub</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker logout<br></code></pre></td></tr></table></figure><h2 id="docker-pull"><a href="#docker-pull" class="headerlink" title="docker pull"></a>docker pull</h2><p><strong>docker pull :</strong> 从镜像仓库中拉取或者更新指定镜像</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull [OPTIONS] NAME[:TAG|@DIGEST]<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><p><code>-a</code> :拉取所有 tagged 镜像</p></li><li><p><code>--disable-content-trust</code>忽略镜像的校验,默认开启</p></li></ul><p><strong>实例</strong></p><p>从Docker Hub下载java最新版镜像。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull java<br></code></pre></td></tr></table></figure><p>从Docker Hub下载REPOSITORY为java的所有镜像。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull -a java<br></code></pre></td></tr></table></figure><h2 id="docker-push"><a href="#docker-push" class="headerlink" title="docker push"></a>docker push</h2><p><strong>docker push :</strong> 将本地的镜像上传到镜像仓库,要先登陆到镜像仓库</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker push [OPTIONS] NAME[:TAG]<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><code>--disable-content-trust</code> :忽略镜像的校验,默认开启</li></ul><p><strong>实例</strong></p><p>上传本地镜像myapache:v1到镜像仓库中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker push myapache:v1<br></code></pre></td></tr></table></figure><h2 id="☆-docker-search"><a href="#☆-docker-search" class="headerlink" title="☆ docker search"></a>☆ docker search</h2><p><strong>docker search :</strong> 从Docker Hub查找镜像</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker search [OPTIONS] TERM<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><code>--automated</code> :只列出 automated build类型的镜像；</li><li><code>--no-trunc</code> :显示完整的镜像描述；</li><li><code>-f &lt;过滤条件&gt;</code>:列出收藏数不小于指定值的镜像。</li></ul><p><strong>实例</strong></p><p>从 Docker Hub 查找所有镜像名包含 java，并且收藏数大于 10 的镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker search -f stars=10 java<br>NAME                  DESCRIPTION                           STARS   OFFICIAL   AUTOMATED<br>java                  Java is a concurrent, class-based...   1037    [OK]       <br>anapsix/alpine-java   Oracle Java 8 (and 7) with GLIBC ...   115                [OK]<br>develar/java                                                 46                 [OK]<br>isuper/java-oracle    This repository contains all java...   38                 [OK]<br>lwieske/java-8        Oracle Java 8 Container - Full + ...   27                 [OK]<br>nimmis/java-centos    This is docker images of CentOS 7...   13                 [OK]<br></code></pre></td></tr></table></figure><p>参数说明：</p><p><strong>NAME:</strong> 镜像仓库源的名称</p><p><strong>DESCRIPTION:</strong> 镜像的描述</p><p><strong>OFFICIAL:</strong> 是否 docker 官方发布</p><p><strong>stars:</strong> 类似 Github 里面的 star，表示点赞、喜欢的意思。</p><p><strong>AUTOMATED:</strong> 自动构建。</p><h2 id="↓-本地镜像管理-↓"><a href="#↓-本地镜像管理-↓" class="headerlink" title="↓ 本地镜像管理 ↓"></a>↓ 本地镜像管理 ↓</h2><h2 id="☆-docker-images"><a href="#☆-docker-images" class="headerlink" title="☆ docker images"></a>☆ docker images</h2><p><strong>docker images :</strong> 列出本地镜像。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker images [OPTIONS] [REPOSITORY[:TAG]]<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><p><code>-a</code> :列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；</p></li><li><p><code>--digests</code> :显示镜像的摘要信息；</p></li><li><p><code>-f</code> :显示满足条件的镜像；</p></li><li><p><code>--format</code> :指定返回值的模板文件；</p></li><li><p><code>--no-trunc</code> :显示完整的镜像信息；</p></li><li><p><code>-q</code> :只显示镜像ID。</p></li></ul><p><strong>实例</strong></p><p>查看本地镜像列表。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker images<br>REPOSITORY              TAG                 IMAGE ID            CREATED             SIZE<br>mymysql                 v1                  37af1236adef        5 minutes ago       329 MB<br>runoob/ubuntu           v4                  1c06aa18edee        2 days ago          142.1 MB<br>&lt;none&gt;                  &lt;none&gt;              5c6e1090e771        2 days ago          165.9 MB<br>httpd                   latest              ed38aaffef30        11 days ago         195.1 MB<br>alpine                  latest              4e38e38c8ce0        2 weeks ago         4.799 MB<br>mongo                   3.2                 282fd552add6        3 weeks ago         336.1 MB<br>redis                   latest              4465e4bcad80        3 weeks ago         185.7 MB<br>php                     5.6-fpm             025041cd3aa5        3 weeks ago         456.3 MB<br>python                  3.5                 045767ddf24a        3 weeks ago         684.1 MB<br>...<br></code></pre></td></tr></table></figure><p>列出本地镜像中REPOSITORY为ubuntu的镜像列表。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@runoob:~# docker images  ubuntu<br>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br>ubuntu              14.04               90d5884b1ee0        9 weeks ago         188 MB<br>ubuntu              15.10               4e3b13c8a266        3 months ago        136.3 MB<br></code></pre></td></tr></table></figure><h2 id="docker-rmi"><a href="#docker-rmi" class="headerlink" title="docker rmi"></a>docker rmi</h2><p><strong>docker rmi :</strong> 删除本地一个或多个镜像。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rmi [OPTIONS] IMAGE [IMAGE...]<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><p><code>-f</code> :强制删除；</p></li><li><p><code>--no-prune</code>不移除该镜像的过程镜像，默认移除；</p></li></ul><p><strong>实例</strong></p><p>强制删除本地镜像 runoob&#x2F;ubuntu:v4。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@runoob:~# docker rmi -f runoob/ubuntu:v4<br>Untagged: runoob/ubuntu:v4<br>Deleted: sha256:1c06aa18edee44230f93a90a7d88139235de12cd4c089d41eed8419b503072be<br>Deleted: sha256:85feb446e89a28d58ee7d80ea5ce367eebb7cec70f0ec18aa4faa874cbd97c73<br></code></pre></td></tr></table></figure><h2 id="docker-tag"><a href="#docker-tag" class="headerlink" title="docker tag"></a>docker tag</h2><p><strong>docker tag :</strong> 标记本地镜像，将其归入某一仓库。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker tag [OPTIONS] IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG]<br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><p>将镜像ubuntu:15.10标记为 runoob&#x2F;ubuntu:v3 镜像。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@runoob:~# docker tag ubuntu:15.10 runoob/ubuntu:v3<br>root@runoob:~# docker images   runoob/ubuntu:v3<br>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br>runoob/ubuntu       v3                  4e3b13c8a266        3 months ago        136.3 MB<br></code></pre></td></tr></table></figure><h2 id="☆-docker-build"><a href="#☆-docker-build" class="headerlink" title="☆ docker build"></a>☆ docker build</h2><p><strong>docker build</strong> 命令用于使用 Dockerfile 创建镜像。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build [OPTIONS] PATH | URL | -<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><code>--build-arg=[]</code>设置镜像创建时的变量；</li><li><code>--cpu-shares</code>设置 cpu 使用权重；</li><li><code>--cpu-period</code>限制 CPU CFS周期；</li><li><code>--cpu-quota</code>限制 CPU CFS配额；</li><li><code>--cpuset-cpus</code>指定使用的CPU id；</li><li><code>--cpuset-mems</code>指定使用的内存 id；</li><li><code>--disable-content-trust</code>忽略校验，默认开启；</li><li><code>-f</code> :指定要使用的Dockerfile路径；</li><li><code>--force-rm</code>设置镜像过程中删除中间容器；</li><li><code>--isolation</code>使用容器隔离技术；</li><li><code>--label=[]</code>设置镜像使用的元数据；</li><li><code>-m</code>设置内存最大值；</li><li><code>--memory-swap</code>:设置Swap的最大值为内存+swap，”-1”表示不限swap；</li><li><code>--no-cache</code>:创建镜像的过程不使用缓存；</li><li><code>--pull</code>:尝试去更新镜像的新版本；</li><li><code>--quiet, -q</code>:安静模式，成功后只输出镜像 ID；</li><li><code>--rm</code>:设置镜像成功后删除中间容器；</li><li><code>--shm-size</code>:设置&#x2F;dev&#x2F;shm的大小，默认值是64M；</li><li><code>--ulimit</code>:Ulimit配置。</li><li><code>--squash</code>:将 Dockerfile 中所有的操作压缩为一层。</li><li><strong>–tag, -t:</strong> 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。</li><li><strong>–network:</strong> 默认 default。在构建期间设置RUN指令的网络模式</li></ul><p><strong>实例</strong></p><p>使用当前目录的 Dockerfile 创建镜像，标签为 runoob&#x2F;ubuntu:v1。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build -t runoob/ubuntu:v1 . <br></code></pre></td></tr></table></figure><p>使用URL <strong>github.com&#x2F;creack&#x2F;docker-firefox</strong> 的 Dockerfile 创建镜像。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build github.com/creack/docker-firefox<br></code></pre></td></tr></table></figure><p>也可以通过 -f Dockerfile 文件的位置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker build -f /path/to/a/Dockerfile .</span><br></code></pre></td></tr></table></figure><p>在 Docker 守护进程执行 Dockerfile 中的指令前，首先会对 Dockerfile 进行语法检查，有语法错误时会返回：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker build -t <span class="hljs-built_in">test</span>/myapp .</span><br>Sending build context to Docker daemon 2.048 kB<br>Error response from daemon: Unknown instruction: RUNCMD<br></code></pre></td></tr></table></figure><h2 id="docker-history"><a href="#docker-history" class="headerlink" title="docker history"></a>docker history</h2><p><strong>docker history :</strong> 查看指定镜像的创建历史。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker history [OPTIONS] IMAGE<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><p><code>-H</code>:以可读的格式打印镜像大小和日期，默认为true；</p></li><li><p><code>--no-trunc</code> :显示完整的提交记录；</p></li><li><p><code>-q</code> :仅列出提交记录ID。</p></li></ul><p><strong>实例</strong></p><p>查看本地镜像runoob&#x2F;ubuntu:v3的创建历史。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@runoob:~# docker history runoob/ubuntu:v3<br>IMAGE             CREATED           CREATED BY                                      SIZE      COMMENT<br>4e3b13c8a266      3 months ago      /bin/sh -c #(nop) CMD [&quot;/bin/bash&quot;]             0 B                 <br>&lt;missing&gt;         3 months ago      /bin/sh -c sed -i &#x27;s/^#\s*\(deb.*universe\)$/   1.863 kB            <br>&lt;missing&gt;         3 months ago      /bin/sh -c set -xe   &amp;&amp; echo &#x27;#!/bin/sh&#x27; &gt; /u   701 B               <br>&lt;missing&gt;         3 months ago      /bin/sh -c #(nop) ADD file:43cb048516c6b80f22   136.3 MB<br></code></pre></td></tr></table></figure><h2 id="docker-save"><a href="#docker-save" class="headerlink" title="docker save"></a>docker save</h2><p><strong>docker save :</strong> 将指定镜像保存成 tar 归档文件。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker save [OPTIONS] IMAGE [IMAGE...]<br></code></pre></td></tr></table></figure><p>OPTIONS 说明：</p><ul><li><code>-o</code>:输出到的文件。</li></ul><p><strong>实例</strong></p><p>将镜像 runoob&#x2F;ubuntu:v3 生成 my_ubuntu_v3.tar 文档</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker save -o my_ubuntu_v3.tar runoob/ubuntu:v3<br>runoob@runoob:~$ ll my_ubuntu_v3.tar<br>-rw------- 1 runoob runoob 142102016 Jul 11 01:37 my_ubuntu_v3.ta<br></code></pre></td></tr></table></figure><h2 id="docker-load"><a href="#docker-load" class="headerlink" title="docker load"></a>docker load</h2><p><strong>docker load :</strong> 导入使用 <a href="https://www.runoob.com/docker/docker-save-command.html">docker save</a> 命令导出的镜像。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker load [OPTIONS]<br></code></pre></td></tr></table></figure><p>OPTIONS 说明：</p><ul><li><p><code>--input , -i</code>: 指定导入的文件，代替 STDIN。</p></li><li><p><code>--quiet , -q</code>: 精简输出信息。</p></li></ul><p><strong>实例</strong></p><p>导入镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker image <span class="hljs-built_in">ls</span></span><br><br>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker load &lt; busybox.tar.gz</span><br><br>Loaded image: busybox:latest<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker images</span><br>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br>busybox             latest              769b9341d937        7 weeks ago         2.489 MB<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker load --input fedora.tar</span><br><br>Loaded image: fedora:rawhide<br><br>Loaded image: fedora:20<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker images</span><br><br>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br>busybox             latest              769b9341d937        7 weeks ago         2.489 MB<br>fedora              rawhide             0d20aec6529d        7 weeks ago         387 MB<br>fedora              20                  58394af37342        7 weeks ago         385.5 MB<br>fedora              heisenbug           58394af37342        7 weeks ago         385.5 MB<br>fedora              latest              58394af37342        7 weeks ago         385.5 MB<br></code></pre></td></tr></table></figure><h2 id="docker-import"><a href="#docker-import" class="headerlink" title="docker import"></a>docker import</h2><p><strong>docker import :</strong> 从归档文件中创建镜像。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><p><code>-c</code>:应用docker 指令创建镜像；</p></li><li><p><code>-m</code>:提交时的说明文字；</p></li></ul><p><strong>实例</strong></p><p>从镜像归档文件my_ubuntu_v3.tar创建镜像，命名为runoob&#x2F;ubuntu:v4</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker import  my_ubuntu_v3.tar runoob/ubuntu:v4  <br>sha256:63ce4a6d6bc3fabb95dbd6c561404a309b7bdfc4e21c1d59fe9fe4299cbfea39<br>runoob@runoob:~$ docker images runoob/ubuntu:v4<br>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br>runoob/ubuntu       v4                  63ce4a6d6bc3        20 seconds ago      142.1 MB<br></code></pre></td></tr></table></figure><h2 id="docker-info"><a href="#docker-info" class="headerlink" title="docker info"></a>docker info</h2><p><code>docker info</code> : 显示 Docker 信息，主机详细系统信息，镜像和容器信息。</p><h2 id="docker-version"><a href="#docker-version" class="headerlink" title="docker version"></a>docker version</h2><p><code>docker version</code> :显示 Docker 版本信息。</p><h1 id="Dockerfile的使用"><a href="#Dockerfile的使用" class="headerlink" title="Dockerfile的使用"></a>Dockerfile的使用</h1><h3 id="什么是-Dockerfile？"><a href="#什么是-Dockerfile？" class="headerlink" title="什么是 Dockerfile？"></a>什么是 Dockerfile？</h3><p>Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。</p><h2 id="构建环境"><a href="#构建环境" class="headerlink" title="构建环境"></a>构建环境</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">❯ mkdir web_docker<br>❯ cd web_docker<br>❯ touch Dockerfile<br>❯ tree .. -f<br>..<br>└── ../web_docker<br>    └── ../web_docker/Dockerfile<br></code></pre></td></tr></table></figure><p>在上面的命令中, 我们创建了 <code>web_docker</code>文件夹, <code>web_docker</code>文件夹就是我们的构建环境(build environment), docker称此环境为上下文(context)，或者构建上下文(context), docker会在构建镜像时构建上下文和该上下文中的文件和目录，上传到docker守护进程，这样docker守护进程就能直接访问你想在镜像中存储的任何代码文件和其他数据。</p><h2 id="dockerfile-示例"><a href="#dockerfile-示例" class="headerlink" title="dockerfile 示例"></a>dockerfile 示例</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># version 0.0.1</span><br><span class="hljs-keyword">FROM</span> ubuntu:<span class="hljs-number">14.04</span><br><span class="hljs-keyword">MAINTAINER</span> James Turnbull <span class="hljs-string">&quot;james@example.com&quot;</span><br><span class="hljs-keyword">ENV</span> REFRESHED_AT <span class="hljs-number">2014</span>-<span class="hljs-number">06</span>-<span class="hljs-number">01</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get update</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get -y -q install nginx</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;Hi i am in you container&#x27;</span> &gt; /usr/share/nginx/html/index.html</span><br><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><blockquote><p>  Dockerfile也支持注释, 使用#开头就是注释了</p></blockquote><hr><h2 id="指令详解"><a href="#指令详解" class="headerlink" title="指令详解"></a>指令详解</h2><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><p>构建镜像基于哪个镜像</p><h3 id="MANTAINER"><a href="#MANTAINER" class="headerlink" title="MANTAINER"></a>MANTAINER</h3><p>镜像维护者 姓名 邮箱地址</p><h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><p>用于执行后面跟着的命令行命令。有以下俩种格式：</p><p>shell 格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">RUN &lt;命令行命令&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;命令行命令&gt; 等同于，在终端操作的 shell 命令。</span><br></code></pre></td></tr></table></figure><p>exec 格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]<br><span class="hljs-meta prompt_"># </span><span class="language-bash">例如：</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">RUN [<span class="hljs-string">&quot;./test.php&quot;</span>, <span class="hljs-string">&quot;dev&quot;</span>, <span class="hljs-string">&quot;offline&quot;</span>] 等价于 RUN ./test.php dev offline</span><br></code></pre></td></tr></table></figure><h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h3><p>复制指令，从上下文目录中复制文件或者目录到容器里指定路径。</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">COPY [--chown=<span class="hljs-tag">&lt;<span class="hljs-name">user</span>&gt;</span>:<span class="hljs-tag">&lt;<span class="hljs-name">group</span>&gt;</span>] <span class="hljs-tag">&lt;<span class="hljs-name">源路径1</span>&gt;</span>...  <span class="hljs-tag">&lt;<span class="hljs-name">目标路径</span>&gt;</span><br>COPY [--chown=<span class="hljs-tag">&lt;<span class="hljs-name">user</span>&gt;</span>:<span class="hljs-tag">&lt;<span class="hljs-name">group</span>&gt;</span>] [&quot;<span class="hljs-tag">&lt;<span class="hljs-name">源路径1</span>&gt;</span>&quot;,...  &quot;<span class="hljs-tag">&lt;<span class="hljs-name">目标路径</span>&gt;</span>&quot;]<br></code></pre></td></tr></table></figure><p>**[–chown&#x3D;<user>:<group>]**：可选参数，用户改变复制到容器内文件的拥有者和属组。</p><p>**&lt;源路径&gt;**：源文件或者源目录，这里可以是通配符表达式，其通配符规则要满足 Go 的 filepath.Match 规则。例如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">COPY</span><span class="language-bash"> hom* /mydir/</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> hom?.txt /mydir/</span><br></code></pre></td></tr></table></figure><p>**&lt;目标路径&gt;**：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建。</p><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><p>ADD 指令和 COPY 的使用格类似（同样需求下，官方推荐使用 COPY）。功能也类似，不同之处如下：</p><ul><li>ADD 的优点：在执行 &lt;源文件&gt; 为 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，会自动复制并解压到 &lt;目标路径&gt;。</li><li>ADD 的缺点：在不解压的前提下，无法复制 tar 压缩文件。会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。具体是否使用，可以根据是否需要自动解压来决定。</li></ul><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p>类似于 RUN 指令，用于运行程序，但二者运行的时间点不同:</p><ul><li>CMD 在docker run 时运行。</li><li>RUN 是在 docker build。</li></ul><p><strong>作用</strong>：为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。</p><p><strong>注意</strong>：如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效。</p><p>格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">CMD</span><span class="language-bash"> &lt;shell 命令&gt; </span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;&lt;可执行文件或命令&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param1&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param2&gt;&quot;</span>,...] </span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;&lt;param1&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param2&gt;&quot;</span>,...]  <span class="hljs-comment"># 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数</span></span><br></code></pre></td></tr></table></figure><p>推荐使用第二种格式，执行过程比较明确。第一种格式实际上在运行的过程中也会自动转换成第二种格式运行，并且默认可执行文件是 sh。</p><h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><p>类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。</p><p>但是, 如果运行 docker run 时使用了 –entrypoint 选项，将覆盖 ENTRYPOINT 指令指定的程序。</p><p><strong>优点</strong>：在执行 docker run 的时候可以指定 ENTRYPOINT 运行所需的参数。</p><p><strong>注意</strong>：如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。</p><p>格式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">ENTRYPOINT <span class="hljs-selector-attr">[<span class="hljs-string">&quot;&lt;executeable&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param1&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param2&gt;&quot;</span>,...]</span><br></code></pre></td></tr></table></figure><p>可以搭配 CMD 命令使用：一般是变参才会使用 CMD ，这里的 CMD 等于是在给 ENTRYPOINT 传参，以下示例会提到。</p><p>示例：</p><p>假设已通过 Dockerfile 构建了 nginx:test 镜像：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> nginx<br><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;nginx&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>] <span class="hljs-comment"># 定参</span></span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;/etc/nginx/nginx.conf&quot;</span>] <span class="hljs-comment"># 变参 </span></span><br></code></pre></td></tr></table></figure><p>1、不传参运行</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">$ docker <span class="hljs-keyword">run</span><span class="language-bash">  nginx:<span class="hljs-built_in">test</span></span><br></code></pre></td></tr></table></figure><p>容器内会默认运行以下命令，启动主进程。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">nginx -c <span class="hljs-regexp">/etc/</span>nginx/nginx.conf<br></code></pre></td></tr></table></figure><p>2、传参运行</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">$ docker <span class="hljs-keyword">run</span><span class="language-bash">  nginx:<span class="hljs-built_in">test</span> -c /etc/nginx/new.conf</span><br></code></pre></td></tr></table></figure><p>容器内会默认运行以下命令，启动主进程(&#x2F;etc&#x2F;nginx&#x2F;new.conf:假设容器内已有此文件)</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">nginx -c <span class="hljs-regexp">/etc/</span>nginx/<span class="hljs-keyword">new</span>.conf<br></code></pre></td></tr></table></figure><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p>设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">ENV <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span><br>ENV <span class="hljs-tag">&lt;<span class="hljs-name">key1</span>&gt;</span>=<span class="hljs-tag">&lt;<span class="hljs-name">value1</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">key2</span>&gt;</span>=<span class="hljs-tag">&lt;<span class="hljs-name">value2</span>&gt;</span>...<br></code></pre></td></tr></table></figure><p>以下示例设置 NODE_VERSION &#x3D; 7.2.0 ， 在后续的指令中可以通过 $NODE_VERSION 引用：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENV</span> NODE_VERSION <span class="hljs-number">7.2</span>.<span class="hljs-number">0</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> curl -SLO <span class="hljs-string">&quot;https://nodejs.org/dist/v<span class="hljs-variable">$NODE_VERSION</span>/node-v<span class="hljs-variable">$NODE_VERSION</span>-linux-x64.tar.xz&quot;</span> \</span><br><span class="language-bash">  &amp;&amp; curl -SLO <span class="hljs-string">&quot;https://nodejs.org/dist/v<span class="hljs-variable">$NODE_VERSION</span>/SHASUMS256.txt.asc&quot;</span></span><br></code></pre></td></tr></table></figure><h3 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h3><p>构建参数，与 ENV 作用一致。不过作用域不一样。ARG 设置的环境变量仅对 Dockerfile 内有效，也就是说只有 docker build 的过程中有效，构建好的镜像内不存在此环境变量。</p><p>构建命令 docker build 中可以用 –build-arg &lt;参数名&gt;&#x3D;&lt;值&gt; 来覆盖。</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">ARG <span class="hljs-tag">&lt;<span class="hljs-name">参数名</span>&gt;</span>[=<span class="hljs-tag">&lt;<span class="hljs-name">默认值</span>&gt;</span>]<br></code></pre></td></tr></table></figure><h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><p>定义匿名数据卷。在启动容器时忘记挂载数据卷，会自动挂载到匿名卷。</p><p>作用：</p><ul><li>避免重要的数据，因容器重启而丢失，这是非常致命的。</li><li>避免容器不断变大。</li></ul><p>格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">VOLUME</span><span class="language-bash"> [<span class="hljs-string">&quot;&lt;路径1&gt;&quot;</span>, <span class="hljs-string">&quot;&lt;路径2&gt;&quot;</span>...]</span><br><span class="hljs-keyword">VOLUME</span><span class="language-bash"> &lt;路径&gt;</span><br></code></pre></td></tr></table></figure><p>在启动容器 docker run 的时候，我们可以通过 -v 参数修改挂载点。</p><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><p>仅仅只是声明端口。</p><p>作用：</p><ul><li>帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。</li><li>在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。</li></ul><p>格式：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">EXPOSE</span> &lt;端口<span class="hljs-number">1</span>&gt;<span class="hljs-meta"> [&lt;端口2&gt;...]</span><br></code></pre></td></tr></table></figure><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><p>指定工作目录。用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在。以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR 会帮你建立目录。</p><p>docker build 构建镜像过程中的，每一个 RUN 命令都是新建的一层。只有通过 WORKDIR 创建的目录才会一直存在。</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">WORKDIR <span class="hljs-tag">&lt;<span class="hljs-name">工作目录路径</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h3><p>用于指定执行后续命令的用户和用户组，这边只是切换后续命令执行的用户（用户和用户组必须提前已经存在）。</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">USER <span class="hljs-tag">&lt;<span class="hljs-name">用户名</span>&gt;</span>[:<span class="hljs-tag">&lt;<span class="hljs-name">用户组</span>&gt;</span>]<br></code></pre></td></tr></table></figure><h3 id="HEALTHCHECK"><a href="#HEALTHCHECK" class="headerlink" title="HEALTHCHECK"></a>HEALTHCHECK</h3><p>用于指定某个程序或者指令来监控 docker 容器服务的运行状态。</p><p>格式：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dos">HEALTHCHECK [选项] <span class="hljs-built_in">CMD</span> &lt;命令&gt;：设置检查容器健康状况的命令<br>HEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令<br><br>HEALTHCHECK [选项] <span class="hljs-built_in">CMD</span> &lt;命令&gt; : 这边 <span class="hljs-built_in">CMD</span> 后面跟随的命令使用，可以参考 <span class="hljs-built_in">CMD</span> 的用法。<br></code></pre></td></tr></table></figure><h3 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h3><p>用于延迟构建命令的执行。简单的说，就是 Dockerfile 里用 ONBUILD 指定的命令，在本次构建镜像的过程中不会执行（假设镜像为 test-build）。当有新的 Dockerfile 使用了之前构建的镜像 FROM test-build ，这时执行新镜像的 Dockerfile 构建时候，会执行 test-build 的 Dockerfile 里的 ONBUILD 指定的命令。</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">ONBUILD <span class="hljs-tag">&lt;<span class="hljs-name">其它指令</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h3><p>LABEL 指令用来给镜像添加一些元数据（metadata），以键值对的形式，语法格式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">LABEL <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>=<span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>=<span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>=<span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span> ...<br></code></pre></td></tr></table></figure><p>比如我们可以添加镜像的作者：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">LABEL org<span class="hljs-selector-class">.opencontainers</span><span class="hljs-selector-class">.image</span>.authors=<span class="hljs-string">&quot;runoob&quot;</span><br></code></pre></td></tr></table></figure><h1 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h1>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>dockerfile</tag>
      
      <tag>namespace</tag>
      
      <tag>cgroup</tag>
      
      <tag>dockerhub</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RDPWrap</title>
    <link href="/2022/a8b000ae/"/>
    <url>/2022/a8b000ae/</url>
    
    <content type="html"><![CDATA[<h1 id="RDPWrap"><a href="#RDPWrap" class="headerlink" title="RDPWrap"></a>RDPWrap</h1><ul><li>RDP程序源Github</li></ul><p><a href="https://github.com/stascorp/rdpwrap">https://github.com/stascorp/rdpwrap</a></p><ul><li>新版RDP配置文件</li></ul><p><a href="https://raw.githubusercontent.com/saurav-biswas/rdpwrap-1/master/res/rdpwrap.ini">https://raw.githubusercontent.com/saurav-biswas/rdpwrap-1/master/res/rdpwrap.ini</a></p><p><a href="https://github.com/affinityv/INI-RDPWRAP">https://github.com/affinityv/INI-RDPWRAP</a></p><p>win11可用 <a href="https://raw.githubusercontent.com/sebaxakerhtc/rdpwrap.ini/master/rdpwrap.ini">https://raw.githubusercontent.com/sebaxakerhtc/rdpwrap.ini/master/rdpwrap.ini</a></p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ol><li><p><code>install.bat</code>安装</p></li><li><p><code>RDPConf.exe</code>检查是否成功开启</p><p><img src="/2022/a8b000ae/image-20211209105711309.png" alt="image-20211209105711309"></p></li><li><p>新的操作系统一般来说第三项是红色的,如果是绿色的就表示正常可以使用了</p></li><li><p>如果异常按以下进行操作</p><ol><li>管理员打开<code>PowerShell</code>运行<code>get-service termservice|stop-service -force</code>停掉RDP进程</li><li>从<a href="https://raw.githubusercontent.com/saurav-biswas/rdpwrap-1/master/res/rdpwrap.ini">RDP配置文件</a>下载新的配置文件</li><li>将下载的配置文件复制到<code>C:\Program Files\RDP Wrapper\rdpwrap.ini</code>替换原文件</li><li>管理员打开<code>PowerShell</code>运行<code>get-service termservice|start-service</code>重新运行RDP</li><li><code>RDPConf.exe</code>检查已经成功开启</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>rdpwrap</tag>
      
      <tag>rdp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Typora强制升级解决办法</title>
    <link href="/2022/77d62815/"/>
    <url>/2022/77d62815/</url>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>This beta version of Typora is expired, please download and install a newer version.</p><p>解决typora强制升级问题</p><blockquote><p>This beta version of Typora is expired, please download and install a newer version.</p></blockquote><p>网上一堆的什么改时间改文件只读的办法都不太行, </p><p>最后找到了改<code>buildtime</code>的办法成功解决了这个问题, </p><p>有能力的请支持正版.</p><p>测试环境是 <code>typora:0.11.18</code> 成功</p><h1 id="详细"><a href="#详细" class="headerlink" title="详细"></a>详细</h1><blockquote><p><a href="https://www.52pojie.cn/thread-1646214-1-1.html">https://www.52pojie.cn/thread-1646214-1-1.html</a> (这里可以找到需要换掉的<code>app.asar</code>文件)</p><p><a href="https://blog.51cto.com/liangdongchang/5357264">https://blog.51cto.com/liangdongchang/5357264</a></p></blockquote><p>最简单的操作就是用破解<code>app.asar</code>文件替换掉原来的文件</p><p>注意备份, 替换 <code>C:\Program Files\Typora\resources\app.asar</code>即可</p><h1 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h1><p>感谢先驱<br><a href="https://github.com/fossabot/typoraCracker">https://github.com/fossabot/typoraCracker</a></p><h1 id="正式版本激活方式"><a href="#正式版本激活方式" class="headerlink" title="正式版本激活方式"></a>正式版本激活方式</h1><p>参考：<a href="https://github.com/DiamondHunters/NodeInject_Hook_example">https://github.com/DiamondHunters/NodeInject_Hook_example</a></p><p><a href="https://zhuanlan.zhihu.com/p/661170065">https://zhuanlan.zhihu.com/p/661170065</a></p><blockquote><p>  V1.76实测通过</p></blockquote><p><code>node_inject.exe</code> 注册钩子修改node_modules.asar文件，<code>license-gen.exe</code>生成注册序列号。</p><ol><li><p>正常安装软件。安装结束不要勾选 <em>“运行程序”</em>。</p></li><li><p>将<code>node_inject.exe</code> 和<code>license-gen.exe</code>复制到typora安装目录。</p><ol><li>例如 <code>C:\Program Files\Typora</code> （需要管理员权限启用CMD）</li></ol></li><li><p>打开CMD窗口</p><ol><li>先运行 <code>node_inject.exe</code>。</li><li>生成序列号 <code>license-gen.exe</code>。</li><li>命令行内直接运行 <code>Typora.exe</code>。</li><li>输入序列号激活，激活如果出现网络错误、序列号异常、请重启软件再次尝试或重启电脑再次尝试。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">14:30:02Typora&gt;.\node_inject.exe<br>extracting node_modules.asar<br>adding hook.js<br>applying patch<br>packing node_modules.asar<br>done!<br>14:30:20Typora&gt;<br>14:30:23Typora&gt;.\license-gen.exe<br>License for you: DVSAKM-4G2U53-ZPPHUK-9XLDK8<br>14:30:31Typora&gt;.\Typora.exe<br>14:30:32Typora&gt;<br>Hook Init<br>Require events<br>Require electron-fetch<br>Hooking electron-fetch<br>Require fs<br>Require package.json<br>console.log override blocked<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>typora</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows下使用Makefile</title>
    <link href="/2022/714f1d49/"/>
    <url>/2022/714f1d49/</url>
    
    <content type="html"><![CDATA[<h1 id="1-安装MinGW"><a href="#1-安装MinGW" class="headerlink" title="1.安装MinGW"></a>1.安装MinGW</h1><p>在MinGW的bin目录下有一个文件叫<code>mingw32-make.exe</code> 运行它就跟<code>make</code>指令类似</p><p><img src="/2022/714f1d49/watermarkpic_center.png" alt="在这里插入图片描述"></p><h1 id="2-CMD-终端运行Makefile-mingw32-make"><a href="#2-CMD-终端运行Makefile-mingw32-make" class="headerlink" title="2. CMD 终端运行Makefile (mingw32-make)"></a>2. CMD 终端运行Makefile (mingw32-make)</h1><p>在cmd终端下直接输入<code>mingw32-make</code>然后回车就可以进行编译了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">Microsoft Windows [版本 10.0.16299.967]<br>(c) 2017 Microsoft Corporation。保留所有权利。<br><br>D:\Project\Code\C++\hello&gt; mingw32-make.exe<br>g++    -c -o main.o main.cpp<br>g++ -std=c++17 -o main main.o<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>makefile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MS-DOS</title>
    <link href="/2022/ddff0c71/"/>
    <url>/2022/ddff0c71/</url>
    
    <content type="html"><![CDATA[<h1 id="MS-DOS"><a href="#MS-DOS" class="headerlink" title="MS-DOS"></a>MS-DOS</h1><p><strong>CMD(windows-commands)</strong></p><p><a href="https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/windows-commands">Windows Commands</a></p><p>在cmd内<code>/?</code>即可获得帮助信息</p><h2 id="FOR"><a href="#FOR" class="headerlink" title="FOR"></a>FOR</h2><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs tex">对一组文件中的每一个文件执行某个特定命令。<br><br>FOR <span class="hljs-comment">%variable IN (set) DO command [command-parameters]</span><br><br>  <span class="hljs-comment">%variable  指定一个单一字母可替换的参数。</span><br>  (set)      指定一个或一组文件。可以使用通配符。<br>  command    指定对每个文件执行的命令。<br>  command-parameters <br>             为特定命令指定参数或命令行开关。<br><br>在批处理程序中使用 FOR 命令时，指定变量请使用 <span class="hljs-comment">%%variable</span><br>而不要用 <span class="hljs-comment">%variable。变量名称是区分大小写的，所以 %i 不同于 %I.</span><br><br>如果启用命令扩展，则会支持下列 FOR 命令的其他格式:<br><br>FOR /D <span class="hljs-comment">%variable IN (set) DO command [command-parameters]</span><br><br>    如果集中包含通配符，则指定与目录名匹配，而不与文件名匹配。<br><br>FOR /R [[drive:]path] <span class="hljs-comment">%variable IN (set) DO command [command-parameters]</span><br><br>    检查以 [drive:]path 为根的目录树，指向每个目录中的 FOR 语句。<br>    如果在 /R 后没有指定目录规范，则使用当前目录。如果集仅为一个单点(.)字符，<br>    则枚举该目录树。<br><br>FOR /L <span class="hljs-comment">%variable IN (start,step,end) DO command [command-parameters]</span><br><br>    该集表示以增量形式从开始到结束的一个数字序列。因此，(1,1,5)将产生序列<br>    1 2 3 4 5，(5,-1,1)将产生序列(5 4 3 2 1)<br><br>FOR /F [&quot;options&quot;] <span class="hljs-comment">%variable IN (file-set) DO command [command-parameters]</span><br>FOR /F [&quot;options&quot;] <span class="hljs-comment">%variable IN (&quot;string&quot;) DO command [command-parameters]</span><br>FOR /F [&quot;options&quot;] <span class="hljs-comment">%variable IN (&#x27;command&#x27;) DO command [command-parameters]</span><br><br>    或者，如果有 usebackq 选项:<br><br>FOR /F [&quot;options&quot;] <span class="hljs-comment">%variable IN (file-set) DO command [command-parameters]</span><br>FOR /F [&quot;options&quot;] <span class="hljs-comment">%variable IN (&quot;string&quot;) DO command [command-parameters]</span><br>FOR /F [&quot;options&quot;] <span class="hljs-comment">%variable IN (&#x27;command&#x27;) DO command [command-parameters]</span><br><br>    fileset 为一个或多个文件名。继续到 fileset 中的下一个文件之前，<br>    每份文件都被打开、读取并经过处理。处理包括读取文件，将其分成一行行的文字，<br>    然后将每行解析成零或更多的符号。然后用已找到的符号字符串变量值调用 For 循环。<br>    以默认方式，/F 通过每个文件的每一行中分开的第一个空白符号。跳过空白行。<br>    你可通过指定可选 &quot;options&quot; 参数替代默认解析操作。这个带引号的字符串包括一个<br>    或多个指定不同解析选项的关键字。这些关键字为:<br><br>        eol=c           - 指一个行注释字符的结尾(就一个)<br>        skip=n          - 指在文件开始时忽略的行数。<br>        delims=xxx      - 指分隔符集。这个替换了空格和制表符的<br>                          默认分隔符集。<br>        tokens=x,y,m-n  - 指每行的哪一个符号被传递到每个迭代<br>                          的 for 本身。这会导致额外变量名称的分配。m-n<br>                          格式为一个范围。通过 nth 符号指定 mth。如果<br>                          符号字符串中的最后一个字符星号，<br>                          那么额外的变量将在最后一个符号解析之后<br>                          分配并接受行的保留文本。<br>        usebackq        - 指定新语法已在下类情况中使用:<br>                          在作为命令执行一个后引号的字符串并且一个单<br>                          引号字符为文字字符串命令并允许在 file-set<br>                          中使用双引号扩起文件名称。<br><br>    某些范例可能有助:<br><br>FOR /F &quot;eol=; tokens=2,3* delims=, &quot; <span class="hljs-comment">%i in (myfile.txt) do @echo %i %j %k</span><br><br>    会分析 myfile.txt 中的每一行，忽略以分号打头的那些行，将<br>    每行中的第二个和第三个符号传递给 for 函数体，用逗号和/或<br>    空格分隔符号。请注意，此 for 函数体的语句引用 <span class="hljs-comment">%i 来</span><br>    获得第二个符号，引用 <span class="hljs-comment">%j 来获得第三个符号，引用 %k</span><br>    来获得第三个符号后的所有剩余符号。对于带有空格的文件<br>    名，你需要用双引号将文件名括起来。为了用这种方式来使<br>    用双引号，还需要使用 usebackq 选项，否则，双引号会<br>    被理解成是用作定义某个要分析的字符串的。<br><br>    <span class="hljs-comment">%i 在 for 语句中显式声明，%j 和 %k 是通过</span><br>    tokens= 选项隐式声明的。可以通过 tokens= 一行<br>    指定最多 26 个符号，只要不试图声明一个高于字母 &quot;z&quot; 或<br>    &quot;Z&quot; 的变量。请记住，FOR 变量是单一字母、分大小写和全局的变量；<br>    而且，不能同时使用超过 52 个。<br><br>    还可以在相邻字符串上使用 FOR /F 分析逻辑，方法是，<br>    用单引号将括号之间的 file-set 括起来。这样，该字符<br>    串会被当作一个文件中的一个单一输入行进行解析。<br><br>    最后，可以用 FOR /F 命令来分析命令的输出。方法是，将<br>    括号之间的 file-set 变成一个反括字符串。该字符串会<br>    被当作命令行，传递到一个子 CMD.EXE，其输出会被捕获到<br>    内存中，并被当作文件分析。如以下例子所示:<br><br>      FOR /F &quot;usebackq delims==&quot; <span class="hljs-comment">%i IN (`set`) DO @echo %i</span><br><br>    会枚举当前环境中的环境变量名称。<br><br>另外，FOR 变量参照的替换已被增强。你现在可以使用下列<br>选项语法:<br><br>     <span class="hljs-comment">%~I          - 删除任何引号(&quot;)，扩展 %I</span><br>     <span class="hljs-comment">%~fI        - 将 %I 扩展到一个完全合格的路径名</span><br>     <span class="hljs-comment">%~dI        - 仅将 %I 扩展到一个驱动器号</span><br>     <span class="hljs-comment">%~pI        - 仅将 %I 扩展到一个路径</span><br>     <span class="hljs-comment">%~nI        - 仅将 %I 扩展到一个文件名</span><br>     <span class="hljs-comment">%~xI        - 仅将 %I 扩展到一个文件扩展名</span><br>     <span class="hljs-comment">%~sI        - 扩展的路径只含有短名</span><br>     <span class="hljs-comment">%~aI        - 将 %I 扩展到文件的文件属性</span><br>     <span class="hljs-comment">%~tI        - 将 %I 扩展到文件的日期/时间</span><br>     <span class="hljs-comment">%~zI        - 将 %I 扩展到文件的大小</span><br>     <span class="hljs-comment">%~$PATH:I   - 查找列在路径环境变量的目录，并将 %I 扩展</span><br>                   到找到的第一个完全合格的名称。如果环境变量名<br>                   未被定义，或者没有找到文件，此组合键会扩展到<br>                   空字符串<br><br>可以组合修饰符来得到多重结果:<br><br>     <span class="hljs-comment">%~dpI       - 仅将 %I 扩展到一个驱动器号和路径</span><br>     <span class="hljs-comment">%~nxI       - 仅将 %I 扩展到一个文件名和扩展名</span><br>     <span class="hljs-comment">%~fsI       - 仅将 %I 扩展到一个带有短名的完整路径名</span><br>     <span class="hljs-comment">%~dp$PATH:I - 搜索列在路径环境变量的目录，并将 %I 扩展</span><br>                   到找到的第一个驱动器号和路径。<br>     <span class="hljs-comment">%~ftzaI     - 将 %I 扩展到类似输出线路的 DIR</span><br><br>在以上例子中，<span class="hljs-comment">%I 和 PATH 可用其他有效数值代替。%~ 语法</span><br>用一个有效的 FOR 变量名终止。选取类似 <span class="hljs-comment">%I 的大写变量名</span><br>比较易读，而且避免与不分大小写的组合键混淆。<br></code></pre></td></tr></table></figure><h2 id="dir"><a href="#dir" class="headerlink" title="dir"></a>dir</h2><p>列出文件</p><h2 id="cls"><a href="#cls" class="headerlink" title="cls"></a>cls</h2><p>清屏</p><h2 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h2><blockquote><p>  keyword: cmd timeout 无效</p><p>  做一个延时执行的批处理命令，选用timeout命令来实现，但是碰到一个情况是写完后直接双击运行时，timeout 命令运行不了。</p><p>  <strong>选择管理员权限运行就可以了。</strong></p><p>  bat命令需要查看权限，注意使用win+R进入cmd是具有管理员权限的，但是直接双击打开的bat文件是没有管理员权限的，没有对应的权限，有些对系统级别的控制，会出现奇怪的现象。</p></blockquote><h1 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE"></a>NOTE</h1><h2 id="mklinkC盘程序搬家"><a href="#mklinkC盘程序搬家" class="headerlink" title="mklinkC盘程序搬家"></a>mklinkC盘程序搬家</h2><p>命令参数</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">mklink<span class="hljs-string">[[/d]|[/h]|[/j]]</span>&lt;Link&gt;&lt;Target&gt;<br></code></pre></td></tr></table></figure><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>&#x2F;d</td><td>创建目录符号链接。默认情况下，mklink会创建文件符号链接。</td></tr><tr><td>&#x2F;H</td><td>创建硬链接而不是符号链接。</td></tr><tr><td>&#x2F;J</td><td>创建目录连接。</td></tr><tr><td>&lt;链接&gt;</td><td>指定正在创建的符号链接的名称。</td></tr><tr><td>&lt;目标&gt;</td><td>指定新符号链接引用的路径（相对或绝对）。</td></tr><tr><td>&#x2F;？</td><td>在命令提示符下显示帮助。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>ms-dos</tag>
      
      <tag>cmd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++</title>
    <link href="/2022/5751eea2/"/>
    <url>/2022/5751eea2/</url>
    
    <content type="html"><![CDATA[<h1 id="C-Bref"><a href="#C-Bref" class="headerlink" title="C++ Bref"></a>C++ Bref</h1><p>C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。</p><p>C++ 被认为是一种<strong>中级</strong>语言，它综合了高级语言和低级语言的特点。</p><p>C++ 是由 Bjarne Stroustrup 于 1979 年在新泽西州美利山贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，最初命名为带类的C，后来在 1983 年更名为 C++。</p><p>C++ 是 C 的一个超集，事实上，任何合法的 C 程序都是合法的 C++ 程序。</p><p><strong>注意：</strong>使用静态类型的编程语言是在编译时执行类型检查，而不是在运行时执行类型检查。</p><h2 id="类-Class"><a href="#类-Class" class="headerlink" title="类 Class"></a>类 Class</h2><p>类是虚拟的, 统称, 对象是类的实体</p><h2 id="对象-Objects"><a href="#对象-Objects" class="headerlink" title="对象 Objects"></a>对象 Objects</h2><p>objects &#x3D; attributes + services &#x3D; data + operations</p><p>对象 &#x3D; 属性 + 服务 &#x3D; 数据 + 操作</p><p><img src="/2022/5751eea2/image-20220506211131674.png" alt="image-20220506211131674"></p><ul><li>Data 要避免去直接操作, 应该通过Operations去交互</li></ul><p> 三个特性</p><ul><li>封装</li><li>继承</li><li>多态</li></ul><h2 id="Objects-Class"><a href="#Objects-Class" class="headerlink" title="Objects &amp; Class"></a>Objects &amp; Class</h2><p>类是虚拟的, 统称, 对象是类的实体</p><p>猫 -&gt; 种类 -&gt; Class</p><p>这只猫 -&gt; 实体 -&gt; Objects</p><p><img src="/2022/5751eea2/image-20220506210930554.png" alt="image-20220506210930554"></p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>C++ 完全支持面向对象的程序设计，包括面向对象开发的四大特性：</p><ul><li>封装</li><li>抽象</li><li>继承</li><li>多态</li></ul><p>C++ 程序可以定义为对象的集合，这些对象通过调用彼此的方法进行交互。</p><h2 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h2><p>标准的 C++ 由三个重要部分组成：</p><ul><li>核心语言，提供了所有构件块，包括变量、数据类型和常量，等等。</li><li>C++ 标准库，提供了大量的函数，用于操作文件、字符串等。</li><li>标准模板库（STL），提供了大量的方法，用于操作数据结构等。</li></ul><h1 id="hello-word"><a href="#hello-word" class="headerlink" title="hello word"></a>hello word</h1><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span><span class="hljs-comment">// include io stream 后缀是不必要的是Windows的错觉</span></span><br><span class="hljs-comment">// 如果这里包含的是 iostream.h 则不再需要 using namespace std; 标准库也会有所不同</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-comment">// Standard 标准命名空间</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Hello world!&quot;</span> &lt;&lt; endl;<span class="hljs-comment">// c out   end line</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">g++ -v<br><span class="hljs-comment"># 使用gcc编译</span><br>gcc main.cpp -lstdc++ -o main<br><span class="hljs-comment"># g++ 程序 g++ 是将 gcc 默认语言设为 C++ 的一个特殊的版本</span><br>g++ main.cpp -o main<br><span class="hljs-comment"># 运行它</span><br>./main<br></code></pre></td></tr></table></figure><h3 id="g-编译器"><a href="#g-编译器" class="headerlink" title="g++编译器"></a>g++编译器</h3><p>g++ 有些系统默认是使用 C++98，我们可以指定使用 C++11 来编译 main.cpp 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">g++ -g -Wall -std=c++11 main.cpp<br></code></pre></td></tr></table></figure><h4 id="g-常用命令选项"><a href="#g-常用命令选项" class="headerlink" title="g++ 常用命令选项"></a>g++ 常用命令选项</h4><table><thead><tr><th align="left">选项</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">-ansi</td><td align="left">只支持 ANSI 标准的 C 语法。这一选项将禁止 GNU C 的某些特色， 例如 asm 或 typeof 关键词。</td></tr><tr><td align="left">-c</td><td align="left">只编译并生成目标文件。</td></tr><tr><td align="left">-DMACRO</td><td align="left">以字符串”1”定义 MACRO 宏。</td></tr><tr><td align="left">-DMACRO&#x3D;DEFN</td><td align="left">以字符串”DEFN”定义 MACRO 宏。</td></tr><tr><td align="left">-E</td><td align="left">只运行 C 预编译器。</td></tr><tr><td align="left">-g</td><td align="left">生成调试信息。GNU 调试器可利用该信息。</td></tr><tr><td align="left">-IDIRECTORY</td><td align="left">指定额外的头文件搜索路径DIRECTORY。</td></tr><tr><td align="left">-LDIRECTORY</td><td align="left">指定额外的函数库搜索路径DIRECTORY。</td></tr><tr><td align="left">-lLIBRARY</td><td align="left">连接时搜索指定的函数库LIBRARY。</td></tr><tr><td align="left">-m486</td><td align="left">针对 486 进行代码优化。</td></tr><tr><td align="left">-o</td><td align="left">FILE 生成指定的输出文件。用在生成可执行文件时。</td></tr><tr><td align="left">-O0</td><td align="left">不进行优化处理。</td></tr><tr><td align="left">-O</td><td align="left">或 -O1 优化生成代码。</td></tr><tr><td align="left">-O2</td><td align="left">进一步优化。</td></tr><tr><td align="left">-O3</td><td align="left">比 -O2 更进一步优化，包括 inline 函数。</td></tr><tr><td align="left">-shared</td><td align="left">生成共享目标文件。通常用在建立共享库时。</td></tr><tr><td align="left">-static</td><td align="left">禁止使用共享连接。</td></tr><tr><td align="left">-UMACRO</td><td align="left">取消对 MACRO 宏的定义。</td></tr><tr><td align="left">-w</td><td align="left">不生成任何警告信息。</td></tr><tr><td align="left">-Wall</td><td align="left">生成所有警告信息。</td></tr></tbody></table><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h2><p>基本语法和c非常类似,   ;   结尾等等</p><h2 id="三字符组-etc"><a href="#三字符组-etc" class="headerlink" title="三字符组(??&#x3D; etc.)"></a>三字符组(??&#x3D; etc.)</h2><p><strong>一种古老的语法</strong></p><p>三字符组就是用于表示另一个字符的三个字符序列，又称为三字符序列。三字符序列总是以两个问号开头。</p><table><thead><tr><th align="left">三字符组</th><th align="left">替换</th></tr></thead><tbody><tr><td align="left">??&#x3D;</td><td align="left">#</td></tr><tr><td align="left">…..</td><td align="left">….</td></tr></tbody></table><h2 id="数据类型-bool-etc"><a href="#数据类型-bool-etc" class="headerlink" title="数据类型(bool etc.)"></a>数据类型(bool etc.)</h2><p>C++ 就是在以前的c拓展了一个 bool</p><p>C++ 为程序员提供了种类丰富的内置数据类型和用户自定义的数据类型。下表列出了七种基本的 C++ 数据类型：</p><table><thead><tr><th align="left">类型</th><th align="left">关键字</th></tr></thead><tbody><tr><td align="left">布尔型</td><td align="left">bool</td></tr><tr><td align="left">字符型</td><td align="left">char</td></tr><tr><td align="left">整型</td><td align="left">int</td></tr><tr><td align="left">浮点型</td><td align="left">float</td></tr><tr><td align="left">双浮点型</td><td align="left">double</td></tr><tr><td align="left">无类型</td><td align="left">void</td></tr><tr><td align="left">宽字符型</td><td align="left">wchar_t</td></tr></tbody></table><p>其实 wchar_t 是这样来的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> <span class="hljs-type">wchar_t</span>;<br></code></pre></td></tr></table></figure><h2 id="存储类-auto-register-etc"><a href="#存储类-auto-register-etc" class="headerlink" title="存储类(auto register etc.)"></a>存储类(auto register etc.)</h2><p>存储类定义 C++ 程序中变量&#x2F;函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C++ 程序中可用的存储类：</p><ul><li>auto</li><li>register</li><li>static</li><li>extern</li><li>mutable</li><li>thread_local (C++11)</li></ul><p>从 C++ 17 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用。</p><h3 id="auto-存储类"><a href="#auto-存储类" class="headerlink" title="auto 存储类"></a>auto 存储类</h3><p>自 C++ 11 以来，<strong>auto</strong> 关键字用于两种情况：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。</p><p>C++98标准中auto关键字用于自动变量的声明，但由于使用极少且多余，在 C++17 中已删除这一用法。</p><p>根据初始化表达式自动推断被声明的变量的类型，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">auto</span> f=<span class="hljs-number">3.14</span>;      <span class="hljs-comment">//double </span><br><span class="hljs-keyword">auto</span> <span class="hljs-title function_">s</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>)</span>;  <span class="hljs-comment">//const char* </span><br><span class="hljs-keyword">auto</span> z = new <span class="hljs-keyword">auto</span>(<span class="hljs-number">9</span>); <span class="hljs-comment">// int* </span><br><span class="hljs-keyword">auto</span> x1 = <span class="hljs-number">5</span>, x2 = <span class="hljs-number">5.0</span>, x3=<span class="hljs-string">&#x27;r&#x27;</span>;<span class="hljs-comment">//错误，必须是初始化为同一类型</span><br></code></pre></td></tr></table></figure><h3 id="register-存储类"><a href="#register-存储类" class="headerlink" title="register 存储类"></a>register 存储类</h3><p><strong>register</strong> 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 ‘&amp;’ 运算符（因为它没有内存位置）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">&#123;   <br><span class="hljs-keyword">register</span> <span class="hljs-type">int</span>  miles; <br>&#125;<br></code></pre></td></tr></table></figure><p>寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 ‘register’ 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。</p><h3 id="mutable-存储类"><a href="#mutable-存储类" class="headerlink" title="mutable 存储类"></a>mutable 存储类</h3><p><strong>mutable</strong> 说明符仅适用于类的对象，这将在本教程的最后进行讲解。它允许对象的成员替代常量。也就是说，mutable 成员可以通过 const 成员函数修改。</p><h3 id="thread-local-存储类"><a href="#thread-local-存储类" class="headerlink" title="thread_local 存储类"></a>thread_local 存储类</h3><p>使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。</p><p>thread_local 说明符可以与 static 或 extern 合并。</p><p>可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。</p><p>以下演示了可以被声明为 thread_local 的变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">thread_local</span> <span class="hljs-type">int</span> x;  <span class="hljs-comment">// 命名空间下的全局变量 </span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span> &#123;</span>    <br>    <span class="hljs-type">static</span> <span class="hljs-keyword">thread_local</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s; <span class="hljs-comment">// 类的static成员变量 </span><br>&#125;; <br><span class="hljs-type">static</span> <span class="hljs-keyword">thread_local</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> X::s;  <span class="hljs-comment">// X::s 是需要定义的  </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123;    <br>    <span class="hljs-keyword">thread_local</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; v;  <span class="hljs-comment">// 本地变量 </span><br>&#125;<br><br><br></code></pre></td></tr></table></figure><h2 id="数学运算-cos-sin-etc"><a href="#数学运算-cos-sin-etc" class="headerlink" title="数学运算(cos sin etc.)"></a>数学运算(cos sin etc.)</h2><p>C++ 内置了丰富的数学函数，可对各种数字进行运算。下表列出了 C++ 中一些有用的内置的数学函数。</p><p>为了利用这些函数，您需要引用数学头文件 **<cmath>**。</p><table><thead><tr><th align="left">序号</th><th align="left">函数 &amp; 描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>double cos(double);</strong> 该函数返回弧度角（double 型）的余弦。</td></tr><tr><td align="left">2</td><td align="left"><strong>double sin(double);</strong> 该函数返回弧度角（double 型）的正弦。</td></tr><tr><td align="left">3</td><td align="left"><strong>double tan(double);</strong> 该函数返回弧度角（double 型）的正切。</td></tr><tr><td align="left">4</td><td align="left"><strong>double log(double);</strong> 该函数返回参数的自然对数。</td></tr><tr><td align="left">5</td><td align="left"><strong>double pow(double, double);</strong> 假设第一个参数为 x，第二个参数为 y，则该函数返回 x 的 y 次方。</td></tr><tr><td align="left">6</td><td align="left"><strong>double hypot(double, double);</strong> 该函数返回两个参数的平方总和的平方根，也就是说，参数为一个直角三角形的两个直角边，函数会返回斜边的长度。</td></tr><tr><td align="left">7</td><td align="left"><strong>double sqrt(double);</strong> 该函数返回参数的平方根。</td></tr><tr><td align="left">8</td><td align="left"><strong>int abs(int);</strong> 该函数返回整数的绝对值。</td></tr><tr><td align="left">9</td><td align="left"><strong>double fabs(double);</strong> 该函数返回任意一个浮点数的绝对值。</td></tr><tr><td align="left">10</td><td align="left"><strong>double floor(double);</strong> 该函数返回一个小于或等于传入参数的最大整数。</td></tr></tbody></table><h2 id="随机数-rand-etc"><a href="#随机数-rand-etc" class="headerlink" title="随机数(rand etc.)"></a>随机数(rand etc.)</h2><p>在许多情况下，需要生成随机数。关于随机数生成器，有两个相关的函数。一个是 **rand()**，该函数只返回一个伪随机数。生成随机数之前必须先调用 <strong>srand()</strong> 函数。</p><p>下面是一个关于生成随机数的简单实例。实例中使用了 <strong>time()</strong> 函数来获取系统时间的秒数，通过调用 rand() 函数来生成随机数</p><h2 id="字符串-string-etc"><a href="#字符串-string-etc" class="headerlink" title="字符串(string etc.)"></a>字符串(string etc.)</h2><p>C++ 提供了以下两种类型的字符串表示形式：</p><ul><li>C 风格字符串</li><li><strong>C++ 引入的 string 类类型</strong></li></ul><p>C++ 标准库提供了 <strong>string</strong> 类类型，支持上述所有的操作，另外还增加了其他更多的功能。我们将学习 C++ 标准库中的这个类，现在让我们先来看看下面这个实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string str1 = <span class="hljs-string">&quot;str1&quot;</span>;<br>    string str2 = <span class="hljs-string">&quot;str2&quot;</span>;<br>    string str3 = <span class="hljs-string">&quot;str3&quot;</span>;<br>    <span class="hljs-comment">// 无法实现 string str3 = &quot;str3&quot; + &quot;str3949499&quot;;  两个静态的string无法相加</span><br><br>    <span class="hljs-comment">// 字符串可以 直接相加</span><br>    str3 = str1 + str2;<br>    cout &lt;&lt; <span class="hljs-string">&quot;str3 : &quot;</span> &lt;&lt; str3 &lt;&lt; endl;<br>    <span class="hljs-comment">// 字符串可以 追加</span><br>    str3 += str1;<br>    cout &lt;&lt; <span class="hljs-string">&quot;str3 : &quot;</span> &lt;&lt; str3 &lt;&lt; endl;<br>    <span class="hljs-comment">// 从cin中直接获取</span><br>    cin &gt;&gt; str3;<br>    cout &lt;&lt; <span class="hljs-string">&quot;str3 : &quot;</span> &lt;&lt; str3 &lt;&lt; endl;<br>    <span class="hljs-comment">// 直接get到size</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;str3.size() : &quot;</span> &lt;&lt; str<span class="hljs-number">3.</span><span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="基本输入输出-cin-cout-cerr-clog"><a href="#基本输入输出-cin-cout-cerr-clog" class="headerlink" title="基本输入输出(cin cout cerr clog)"></a>基本输入输出(cin cout cerr clog)</h2><h3 id="I-O-库头文件"><a href="#I-O-库头文件" class="headerlink" title="I&#x2F;O 库头文件"></a>I&#x2F;O 库头文件</h3><table><thead><tr><th align="left">头文件</th><th align="left">函数和描述</th></tr></thead><tbody><tr><td align="left"><iostream></td><td align="left">该文件定义了 <strong>cin、cout、cerr</strong> 和 <strong>clog</strong> 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。</td></tr><tr><td align="left"><iomanip></td><td align="left">该文件通过所谓的参数化的流操纵器（比如 <strong>setw</strong> 和 <strong>setprecision</strong>），来声明对执行标准化 I&#x2F;O 有用的服务。</td></tr><tr><td align="left"><fstream></td><td align="left">该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。</td></tr></tbody></table><h3 id="标准输出流（cout）"><a href="#标准输出流（cout）" class="headerlink" title="标准输出流（cout）"></a>标准输出流（cout）</h3><p>预定义的对象 <strong>cout</strong> 是 <strong>iostream</strong> 类的一个实例。cout 对象”连接”到标准输出设备，通常是显示屏。<strong>cout</strong> 是与流插入运算符 &lt;&lt; 结合使用的，C++ 编译器根据要输出变量的数据类型，选择合适的流插入运算符来显示值。&lt;&lt; 运算符被重载来输出内置类型（整型、浮点型、double 型、字符串和指针）的数据项。</p><p>流插入运算符 &lt;&lt; 在一个语句中可以多次使用，如上面实例中所示，<strong>endl</strong> 用于在行末添加一个换行符。</p><p><code>cout &lt;&lt; str_cin &lt;&lt; endl;</code></p><h4 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h4><h5 id="ostream-类的成员方法"><a href="#ostream-类的成员方法" class="headerlink" title="ostream 类的成员方法"></a>ostream 类的成员方法</h5><table><thead><tr><th>成员函数</th><th>说明</th></tr></thead><tbody><tr><td>flags(fmtfl)</td><td>当前格式状态全部替换为 fmtfl。注意，fmtfl 可以表示一种格式，也可以表示多种格式。</td></tr><tr><td>precision(n)</td><td>设置输出浮点数的精度为 n。</td></tr><tr><td>width(w)</td><td>指定输出宽度为 w 个字符。</td></tr><tr><td>fill(c)</td><td>在指定输出宽度的情况下，输出的宽度不足时用字符 c 填充（默认情况是用空格填充）。</td></tr><tr><td>setf(fmtfl, mask)</td><td>在当前格式的基础上，追加 fmtfl 格式，并删除 mask 格式。其中，mask 参数可以省略。</td></tr><tr><td>unsetf(mask)</td><td>在当前格式的基础上，删除 mask 格式。</td></tr></tbody></table><h5 id="fmtfl-和-mask-参数可选值"><a href="#fmtfl-和-mask-参数可选值" class="headerlink" title="fmtfl 和 mask 参数可选值"></a>fmtfl 和 mask 参数可选值</h5><table><thead><tr><th>标 志</th><th>作 用</th></tr></thead><tbody><tr><td>ios::boolapha</td><td>把 true 和 false 输出为字符串</td></tr><tr><td>ios::left</td><td>输出数据在本域宽范围内向左对齐</td></tr><tr><td>ios::right</td><td>输出数据在本域宽范围内向右对齐</td></tr><tr><td>ios::internal</td><td>数值的符号位在域宽内左对齐，数值右对齐，中间由填充字符填充</td></tr><tr><td>ios::dec</td><td>设置整数的基数为 10</td></tr><tr><td>ios::oct</td><td>设置整数的基数为 8</td></tr><tr><td>ios::hex</td><td>设置整数的基数为 16</td></tr><tr><td>ios::showbase</td><td>强制输出整数的基数（八进制数以 0 开头，十六进制数以 0x 打头）</td></tr><tr><td>ios::showpoint</td><td>强制输出浮点数的小点和尾数 0</td></tr><tr><td>ios::uppercase</td><td>在以科学记数法格式 E 和以十六进制输出字母时以大写表示</td></tr><tr><td>ios::showpos</td><td>对正数显示“+”号</td></tr><tr><td>ios::scientific</td><td>浮点数以科学记数法格式输出</td></tr><tr><td>ios::fixed</td><td>浮点数以定点格式（小数形式）输出</td></tr><tr><td>ios::unitbuf</td><td>每次输出之后刷新所有的流</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">double</span> a = <span class="hljs-number">1.23</span>;<br>    <span class="hljs-comment">//设定后续输出的浮点数的精度为 4</span><br>    <span class="hljs-built_in">cout</span>.precision(<span class="hljs-number">4</span>);<br>    <span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-string">&quot;precision: &quot;</span>&lt;&lt; a &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-comment">//设定后续以科学计数法的方式输出浮点数</span><br>    <span class="hljs-built_in">cout</span>.setf(ios::scientific);<br>    <span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-string">&quot;scientific：&quot;</span>&lt;&lt; a &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="iomanip-格式化输出"><a href="#iomanip-格式化输出" class="headerlink" title="iomanip 格式化输出"></a>iomanip 格式化输出</h4><table><thead><tr><th>流操纵算子</th><th>作  用</th><th></th></tr></thead><tbody><tr><td>*dec</td><td>以十进制形式输出整数</td><td></td></tr><tr><td>hex</td><td>以十六进制形式输出整数</td><td></td></tr><tr><td>oct</td><td>以八进制形式输出整数</td><td></td></tr><tr><td>fixed</td><td>以普通小数形式输出浮点数</td><td></td></tr><tr><td>scientific</td><td>以科学计数法形式输出浮点数</td><td></td></tr><tr><td>left</td><td>左对齐，即在宽度不足时将填充字符添加到右边</td><td></td></tr><tr><td>*right</td><td>右对齐，即在宽度不足时将填充字符添加到左边</td><td></td></tr><tr><td>setbase(b)</td><td>设置输出整数时的进制，b&#x3D;8、10 或 16</td><td></td></tr><tr><td>setw(w)</td><td>指定输出宽度为 w 个字符，或输入字符串时读入 w 个字符。注意，该函数所起的作用是一次性的，即只影响下一次 cout 输出。</td><td></td></tr><tr><td>setfill(c)</td><td>在指定输出宽度的情况下，输出的宽度不足时用字符 c 填充（默认情况是用空格填充）</td><td></td></tr><tr><td>setprecision(n)</td><td>设置输出浮点数的精度为 n。  在使用非 fixed 且非 scientific 方式输出的情况下，n 即为有效数字最多的位数，如果有效数字位数超过 n，则小数部分四舍五人，或自动变为科学计 数法输出并保留一共 n 位有效数字。  在使用 fixed 方式和 scientific 方式输出的情况下，n 是小数点后面应保留的位数。</td><td></td></tr><tr><td>setiosflags(mask)</td><td>在当前格式状态下，追加 mask 格式，mask 参数可选择表 2 中的所有值。</td><td></td></tr><tr><td>resetiosflags(mask)</td><td>在当前格式状态下，删除 mask 格式，mask 参数可选择表 2 中的所有值。</td><td></td></tr><tr><td>boolapha</td><td>把 true 和 false 输出为字符串</td><td></td></tr><tr><td>*noboolalpha</td><td>把 true 和 false 输出为 0、1</td><td></td></tr><tr><td>showbase</td><td>输出表示数值的进制的前缀</td><td></td></tr><tr><td>*noshowbase</td><td>不输出表示数值的进制.的前缀</td><td></td></tr><tr><td>showpoint</td><td>总是输出小数点</td><td></td></tr><tr><td>*noshowpoint</td><td>只有当小数部分存在时才显示小数点</td><td></td></tr><tr><td>showpos</td><td>在非负数值中显示 +</td><td></td></tr><tr><td>*noshowpos</td><td>在非负数值中不显示 +</td><td></td></tr><tr><td>uppercase</td><td>十六进制数中使用 A~E。若输出前缀，则前缀输出 0X，科学计数法中输出 E</td><td></td></tr><tr><td>*nouppercase</td><td>十六进制数中使用 a~e。若输出前缀，则前缀输出 0x，科学计数法中输出 e。</td><td></td></tr><tr><td>internal</td><td>数值的符号（正负号）在指定宽度内左对齐，数值右对 齐，中间由填充字符填充。</td><td></td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">//以十六进制输出整数</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; hex &lt;&lt; <span class="hljs-number">16</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-comment">//删除之前设定的进制格式，以默认的 10 进制输出整数</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; resetiosflags(ios::basefield)&lt;&lt; <span class="hljs-number">16</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-type">double</span> a = <span class="hljs-number">123</span>;<br>    <span class="hljs-comment">//以科学计数法的方式输出浮点数</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; scientific &lt;&lt; a &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-comment">//删除之前设定的科学计数法的方法</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; resetiosflags(ios::scientific) &lt;&lt; a &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="标准输入流（cin）"><a href="#标准输入流（cin）" class="headerlink" title="标准输入流（cin）"></a>标准输入流（cin）</h3><p>预定义的对象 <strong>cin</strong> 是 <strong>iostream</strong> 类的一个实例。cin 对象附属到标准输入设备，通常是键盘。<strong>cin</strong> 是与流提取运算符 &gt;&gt; 结合使用的，</p><p><code>cin &gt;&gt; str_cin;</code></p><h3 id="标准错误流（cerr）"><a href="#标准错误流（cerr）" class="headerlink" title="标准错误流（cerr）"></a>标准错误流（cerr）</h3><p>预定义的对象 <strong>cerr</strong> 是 <strong>iostream</strong> 类的一个实例。cerr 对象附属到标准输出设备，通常也是显示屏，但是 <strong>cerr</strong> 对象是非缓冲的，且每个流插入到 cerr 都会立即输出。</p><h3 id="标准日志流（clog）"><a href="#标准日志流（clog）" class="headerlink" title="标准日志流（clog）"></a>标准日志流（clog）</h3><p>预定义的对象 <strong>clog</strong> 是 <strong>iostream</strong> 类的一个实例。clog 对象附属到标准输出设备，通常也是显示屏，但是 <strong>clog</strong> 对象是缓冲的。这意味着每个流插入到 clog 都会先存储在缓冲区，直到缓冲填满或者缓冲区刷新时才会输出。</p><h2 id="引用-注意区别于指针"><a href="#引用-注意区别于指针" class="headerlink" title="引用&amp; (注意区别于指针)"></a>引用&amp; (注意区别于指针)</h2><h4 id="C-引用-vs-指针"><a href="#C-引用-vs-指针" class="headerlink" title="C++ 引用 vs 指针"></a>C++ 引用 vs 指针</h4><p>引用很容易与指针混淆，它们之间有三个主要的不同：</p><ul><li>不存在空引用。引用必须连接到一块合法的内存。</li><li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。</li><li>引用必须在创建时被初始化。指针可以在任何时间被初始化。</li></ul><p><strong>引用符号:&amp;</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span>&amp; j=i;<span class="hljs-comment">//引用</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Max</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; a, <span class="hljs-type">int</span>&amp; b)</span></span>;<span class="hljs-comment">//引用传参</span><br></code></pre></td></tr></table></figure><h2 id="new-delete-动态内存分配"><a href="#new-delete-动态内存分配" class="headerlink" title="new delete 动态内存分配"></a>new delete 动态内存分配</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> * pi = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">225</span>); <span class="hljs-comment">//分配的同时 初始化值</span><br><br><span class="hljs-type">int</span> * pia = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>]; <span class="hljs-comment">//数据的new和delete</span><br><span class="hljs-keyword">delete</span> []pia;<span class="hljs-comment">// 带方括号释放</span><br></code></pre></td></tr></table></figure><p>具体差别可以参考</p><p>[new delete malloc free]: ..\embedded!Main\嵌入式编程学习笔记.md#C类##newdeletemallocfree“new delete malloc free”</p><p>[new delete malloc free](..\embedded!Main\嵌入式编程学习笔记.md##new delete malloc free)</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的<strong>形式参数</strong>。</p><p>形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。</p><p>当调用函数时，有三种向函数传递参数的方式：</p><table><thead><tr><th align="left">调用类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/cplusplus/cpp-function-call-by-value.html">传值调用</a></td><td align="left">该方法把参数的实际值赋值给函数的形式参数。<br>在这种情况下，修改函数内的形式参数对实际参数没有影响。</td></tr><tr><td align="left"><a href="https://www.runoob.com/cplusplus/cpp-function-call-by-pointer.html">指针调用</a></td><td align="left">该方法把参数的地址赋值给形式参数。<br/>在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。</td></tr><tr><td align="left"><a href="https://www.runoob.com/cplusplus/cpp-function-call-by-reference.html">引用调用</a></td><td align="left">该方法把参数的引用赋值给形式参数。<br/>在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。</td></tr></tbody></table><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>当您定义一个函数，您可以为参数列表中后边的每一个参数指定默认值。当调用函数时，如果实际参数的值留空，则使用这个默认值。</p><p>这是通过在函数定义中使用赋值运算符来为参数赋值的。调用函数时，如果未传递参数的值，则会使用默认值，如果指定了值，则会忽略默认值，使用传递的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> a=<span class="hljs-number">1</span>, <span class="hljs-type">int</span> b=<span class="hljs-number">2</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//do thing</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Lambda函数-匿名函数"><a href="#Lambda函数-匿名函数" class="headerlink" title="Lambda函数 匿名函数"></a>Lambda函数 匿名函数</h3><p>C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。</p><p>Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。</p><p>Lambda 表达式本质上与函数声明非常类似。Lambda 表达式具体形式如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 有返回值</span><br>[capture](parameters)-&gt;<span class="hljs-keyword">return</span>-type&#123;body&#125;<br><span class="hljs-comment">// 无返回值</span><br>[capture](parameters)&#123;body&#125;<br><br><span class="hljs-comment">// 例子</span><br>[](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)&#123; <span class="hljs-keyword">return</span> x &lt; y ; &#125;<br><span class="hljs-comment">// 如果没有参数,空的圆括号()可以省略。</span><br>[]&#123; ++global_x; &#125; <br><span class="hljs-comment">// 在一个更为复杂的例子中，返回类型可以被明确的指定</span><br>[](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) -&gt; <span class="hljs-type">int</span> &#123; <span class="hljs-type">int</span> z = x + y; <span class="hljs-keyword">return</span> z + x; &#125;<br></code></pre></td></tr></table></figure><p>关于capture里面的值如何获取：</p><blockquote><p>  []      &#x2F;&#x2F; 沒有定义任何变量。使用未定义变量会引发错误。<br>  [x, &amp;y] &#x2F;&#x2F; x以传值方式传入（默认），y以引用方式传入。<br>  [&amp;]     &#x2F;&#x2F; 任何被使用到的外部变量都隐式地以引用方式加以引用。<br>  [&#x3D;]     &#x2F;&#x2F; 任何被使用到的外部变量都隐式地以传值方式加以引用。<br>  [&amp;, x]  &#x2F;&#x2F; x显式地以传值方式加以引用。其余变量以引用方式加以引用。<br>  [&#x3D;, &amp;z] &#x2F;&#x2F; z显式地以引用方式加以引用。其余变量以传值方式加以引用。</p></blockquote><ul><li><p>值捕获 与函数中的值传递类似。lambda表达式捕获的是变量的一个拷贝，因此我们如果在lambda表达式后面改变该变量值的话，不会影响捕获前的该变量值，这就是所谓的值捕获</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br>[a]()&#123;<span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;<span class="hljs-variable">%d</span>\n&quot;</span>, a;);&#125;<br></code></pre></td></tr></table></figure></li><li><p>引用捕获 引用捕获和值捕获形式完全一样，只是在捕获列表中传的是变量的引用，类似于函数中的引用传递，变成下面这个样子</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br>[&amp;a]()&#123;<span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;<span class="hljs-variable">%d</span>\n&quot;</span>, a;);&#125;<br></code></pre></td></tr></table></figure></li><li><p>隐式捕获的方式，就是捕获的列表可以用<code>=</code>和<code>&amp;</code>代替，让编译器隐式的推断你使用的是哪个变量，然后这两个字符表示捕获的类型<code>=</code>表示值捕获，<code>&amp;</code>是引用捕获；写出来之后就变成了如下的形式：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br>[=]()&#123;<span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;<span class="hljs-variable">%d</span>\n&quot;</span>, a);&#125;;<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 捕获</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string str1 = <span class="hljs-string">&quot;str1&quot;</span>;<br>    string str2 = <span class="hljs-string">&quot;str2&quot;</span>;<br>    string str3 = <span class="hljs-string">&quot;str3&quot;</span>;<br>    <br>    <span class="hljs-comment">// 这是传值捕获</span><br>    <span class="hljs-keyword">auto</span> fun = [str1, str2]() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;5 str1 : &quot;</span> &lt;&lt; str1 &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;5 str2 : &quot;</span> &lt;&lt; str2 &lt;&lt; endl;<br>    &#125;;<br>    cout &lt;&lt; <span class="hljs-string">&quot;1 str1 : &quot;</span> &lt;&lt; str1 &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;1 str2 : &quot;</span> &lt;&lt; str2 &lt;&lt; endl;<br>    str1 += str2;<br>    str2 += str1;<br>    <span class="hljs-built_in">fun</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;2 str1 : &quot;</span> &lt;&lt; str1 &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;2 str2 : &quot;</span> &lt;&lt; str2 &lt;&lt; endl;<br>    <br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 输出</span><br><span class="hljs-number">1</span> str1 : str1<br><span class="hljs-number">1</span> str2 : str2<br><span class="hljs-number">5</span> str1 : str1<br><span class="hljs-number">5</span> str2 : str2<br><span class="hljs-number">2</span> str1 : str1str2<br><span class="hljs-number">2</span> str2 : str2str1str2<br><br><span class="hljs-comment">// 被当成普通函数使用了</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string str1 = <span class="hljs-string">&quot;str1&quot;</span>;<br>    string str2 = <span class="hljs-string">&quot;str2&quot;</span>;<br>    string str3 = <span class="hljs-string">&quot;str3&quot;</span>;<br>    <br>    <span class="hljs-keyword">auto</span> stradd = [&amp;](string&amp; stra,string&amp; strb) &#123;<br>        cout &lt;&lt; stra &lt;&lt; endl;<br>        cout &lt;&lt; strb &lt;&lt; endl;<br>        stra += strb;<br>        strb += stra;<br>    &#125;;<br>    <br>    cout &lt;&lt; <span class="hljs-string">&quot;1 str1 : &quot;</span> &lt;&lt; str1 &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;1 str2 : &quot;</span> &lt;&lt; str2 &lt;&lt; endl;<br>    <span class="hljs-built_in">stradd</span>(str1, str2);<br>    cout &lt;&lt; <span class="hljs-string">&quot;2 str1 : &quot;</span> &lt;&lt; str1 &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;2 str2 : &quot;</span> &lt;&lt; str2 &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//输出</span><br><span class="hljs-number">1</span> str1 : str1<br><span class="hljs-number">1</span> str2 : str2<br>str1<br>str2<br><span class="hljs-number">2</span> str1 : str1str2<br><span class="hljs-number">2</span> str2 : str2str1str2<br></code></pre></td></tr></table></figure><ul><li>这个知识点没看懂是匿了什么名, 不知所云, 难道和匿名没关系?只是捕获的功能?</li></ul><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><ul><li>确保函数名一致，在调用时根据参数来判断调用那个函数。</li><li>其参数个数或类型有所不同。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Max</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Max</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span></span>;<br><br><br><span class="hljs-built_in">Max</span>(<span class="hljs-number">112</span>, <span class="hljs-number">223</span>)<br><span class="hljs-built_in">Max</span>(<span class="hljs-number">1.2</span>, <span class="hljs-number">2.3</span>)<br></code></pre></td></tr></table></figure><h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><ul><li>对象是类的实例</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>;<span class="hljs-comment">//类的声明，在被引用前声明，被其他类引用相互引用</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span><br>&#123;<br>    <span class="hljs-type">int</span> a;<span class="hljs-comment">//默认私有属性，数据成员不能初始化 //int a(20);错误</span><br><span class="hljs-keyword">public</span>:<span class="hljs-comment">//公有成员</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Fun</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<span class="hljs-comment">//这里放声明，或者直接定义在类里面(直接定义在类里面默认内联)</span><br><span class="hljs-keyword">private</span>:<span class="hljs-comment">//私有成员</span><br><span class="hljs-keyword">protected</span>:<span class="hljs-comment">//保护成员</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MyClass::Fun</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><span class="hljs-comment">//可以定义在类里面，也可以定义在外面</span></span><br><span class="hljs-function"></span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ul><li><strong>与类同名</strong></li><li>(有但不指定)返回值</li><li><strong>可重载</strong></li><li>可以有传入参数</li><li>创建对象时自动调用</li><li>初始化由类中声明顺序决定，与初始化列表顺序无关</li><li>初始化列表优先于构造函数内的赋值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Line</span><br>&#123;<br>   <span class="hljs-keyword">public</span>:<br>      <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setLength</span><span class="hljs-params">( <span class="hljs-type">double</span> len )</span></span>;<br>      <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getLength</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span></span>;<br>      <span class="hljs-built_in">Line</span>(<span class="hljs-type">double</span> len);  <span class="hljs-comment">// 这是构造函数</span><br> <br>   <span class="hljs-keyword">private</span>:<br>      <span class="hljs-type">double</span> length;<br>&#125;;<br><span class="hljs-comment">// 成员函数定义，包括构造函数</span><br>Line::<span class="hljs-built_in">Line</span>( <span class="hljs-type">double</span> len)<br>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Object is being created, length = &quot;</span> &lt;&lt; len &lt;&lt; endl;<br>    length = len;<br>&#125;<br> <br></code></pre></td></tr></table></figure><h4 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h4><p>使用初始化列表来初始化字段：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">Line::<span class="hljs-built_in">Line</span>( <span class="hljs-type">double</span> len): <span class="hljs-built_in">length</span>(len)<br>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Object is being created, length = &quot;</span> &lt;&lt; len &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的语法等同于如下语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">Line::<span class="hljs-built_in">Line</span>( <span class="hljs-type">double</span> len)<br>&#123;<br>    length = len;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Object is being created, length = &quot;</span> &lt;&lt; len &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>假设有一个类 C，具有多个字段 X、Y、Z 等需要进行初始化，同理地，您可以使用上面的语法，只需要在不同的字段使用逗号进行分隔，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">C::<span class="hljs-built_in">C</span>( <span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b, <span class="hljs-type">double</span> c): <span class="hljs-built_in">X</span>(a), <span class="hljs-built_in">Y</span>(b), <span class="hljs-built_in">Z</span>(c)<br>&#123;<br>  ....<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><ul><li>类名前加 ~</li><li>不能有返回值</li><li>无参数，不重载</li><li>销毁系统自动调用</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">~<span class="hljs-built_in">MyClass</span>()<br>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Delete MyClass:&quot;</span> &lt;&lt; name &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h3><ul><li>与类同名</li><li>只有一个参数即对同类引用</li></ul><p><strong>被调用的情况</strong></p><ul><li>用类的已知对象初始化另一个正在创建的对象</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">MyClass</span>( <span class="hljs-type">const</span> MyClass&amp; cIn )<br>&#123;<br>    x = cIn.x;<br>    y = cIn.y;<br>    name = cIn.name;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Copy MyClass&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h2><p>this指针指向类对象的地址</p><p><strong>以下两函数等价</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MyClass::Fun</span><span class="hljs-params">( <span class="hljs-type">int</span> in )</span></span><br><span class="hljs-function"></span>&#123;<br>x = in;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MyClass::Fun</span><span class="hljs-params">( <span class="hljs-type">int</span> in )</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">this</span>-&gt;x = in;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="静态成员-static"><a href="#静态成员-static" class="headerlink" title="静态成员 static"></a>静态成员 static</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>所有类的对象有一个相同唯一的  数据成员 (共同点)</p><ul><li><p>static 声明的 数据成员(初始化不加static)</p></li><li><p>作用域是类范围类</p></li><li><p>必须要进行初始化，文件作用域进行初始化</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<span class="hljs-comment">//公有成员</span><br>    <span class="hljs-built_in">MyClass</span>( xxx ):xxx <span class="hljs-comment">//构造函数</span><br>&#123;<br>cont++;<span class="hljs-comment">//静态与非静态 数据成员访问方式一致，每构造一个类就会++</span><br>&#125;<br><span class="hljs-keyword">private</span>:<span class="hljs-comment">//私有成员</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> cont;<br>&#125;<br><br><span class="hljs-type">int</span> MyClass::cont = <span class="hljs-number">0</span>;<span class="hljs-comment">//文件作用范围 初始化</span><br><br></code></pre></td></tr></table></figure><h3 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h3><p>所有类的对象有一个相同唯一的   函数 (操作)，该函数不能直接访问非静态成员(static 变量)。</p><ul><li>static 声明的函数(类外定义不能加static)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<span class="hljs-comment">//公有成员</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span></span>;<br><span class="hljs-keyword">private</span>:<span class="hljs-comment">//私有成员</span><br><span class="hljs-type">int</span> x, y;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> cont;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyClass::Print</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><span class="hljs-comment">//不加static</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Print1&quot;</span> &lt;&lt; cont &lt;&lt; endl;<span class="hljs-comment">//不能使用 this ，不能引用 x、y</span><br>&#125;<br><br><br>MyClass A,B;<br><br>MyClass.<span class="hljs-built_in">Print</span>();<span class="hljs-comment">//建议访问方式 (表明该成员属于类，而不是对象)</span><br>A.<span class="hljs-built_in">Print</span>();<span class="hljs-comment">//效果一致不建议使用</span><br>B.<span class="hljs-built_in">Print</span>();<span class="hljs-comment">//效果一致不建议使用</span><br></code></pre></td></tr></table></figure><h2 id="常成员-const"><a href="#常成员-const" class="headerlink" title="常成员 const"></a>常成员 const</h2><h3 id="常对象"><a href="#常对象" class="headerlink" title="常对象"></a>常对象</h3><ul><li>不可更改</li><li>定义时必须初始化</li><li>只能调用 常成员函数(有const)，不能调用一般的成员函数(没有const的一般函数)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">&lt;类名&gt; <span class="hljs-type">const</span> &lt;对象名&gt;<br><span class="hljs-type">const</span> &lt;类名&gt; &lt;对象名&gt;<br><br><span class="hljs-function"><span class="hljs-type">const</span> MyClass <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="常数据成员"><a href="#常数据成员" class="headerlink" title="常数据成员"></a>常数据成员</h3><ul><li>只能通过构造函数成员初始化列表显式初始化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<span class="hljs-comment">//公有成员</span><br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> i):<span class="hljs-built_in">a</span>(i) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetCont</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">private</span>:<span class="hljs-comment">//私有成员</span><br><span class="hljs-type">int</span> x, y;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> a;<br>&#125;;<br><br><span class="hljs-type">int</span> MyClass::a = <span class="hljs-number">9</span>;<span class="hljs-comment">//初始化</span><br></code></pre></td></tr></table></figure><h3 id="常成员函数"><a href="#常成员函数" class="headerlink" title="常成员函数"></a>常成员函数</h3><ul><li>声明 定义都需要const</li><li>常成员函数 不能更改对象的数据成员</li><li>可重载</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++">&lt;返回类型&gt; &lt;成员函数名&gt; (&lt;参数表&gt;) <span class="hljs-type">const</span>;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<span class="hljs-comment">//公有成员</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetCont</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">private</span>:<span class="hljs-comment">//私有成员</span><br><span class="hljs-type">int</span> x, y;<br>    <span class="hljs-type">int</span> cont;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MyClass::GetCont</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span> <span class="hljs-type">const</span><span class="hljs-comment">//需要加const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//return cont++;//不允许更改 数据成员</span><br>    <span class="hljs-keyword">return</span> cont;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h1 id="Lib"><a href="#Lib" class="headerlink" title="Lib"></a>Lib</h1><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><ul><li>每个头文件只声明一个类</li><li>#ifndef 防止重复包含</li><li>cpp 和 h 文件应该同名</li></ul><h2 id="读取文件发现数据长度不对"><a href="#读取文件发现数据长度不对" class="headerlink" title="读取文件发现数据长度不对"></a>读取文件发现数据长度不对</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 方法一</span><br>InLogFile.<span class="hljs-built_in">seekg</span>(<span class="hljs-number">0</span>, ios::end);<br>streampos pos = InLogFile.<span class="hljs-built_in">tellg</span>();<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> length = pos;<br><br>InLogFile.<span class="hljs-built_in">seekg</span>(<span class="hljs-number">0</span>, ios::beg);<br><span class="hljs-type">char</span> * pBuffer = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[length];<br><span class="hljs-built_in">memset</span>(pBuffer, <span class="hljs-number">0</span>, length);<br>InLogFile.<span class="hljs-built_in">read</span>(pBuffer, length);<br><br><br><span class="hljs-comment">// 方法二</span><br>std::string strr;<br>&#123; <span class="hljs-comment">// 读出全部文件</span><br>    <span class="hljs-function">std::ifstream <span class="hljs-title">in</span><span class="hljs-params">(InFilePath)</span></span>;<br>    std::ostringstream tmp;<br>    tmp &lt;&lt; in.<span class="hljs-built_in">rdbuf</span>();<br>    strr = tmp.<span class="hljs-built_in">str</span>();<br>&#125;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;length&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; length &lt;&lt; endl;<br>cout &lt;&lt; strr.<span class="hljs-built_in">length</span>() &lt;&lt; endl;<br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">12552<br>12352<br></code></pre></td></tr></table></figure><p>他们的输出结果似乎不太一样, 好像是对 <code>0D 0A</code> 的数量计算方法不太一致导致的.</p><h2 id="读取文件全部内容"><a href="#读取文件全部内容" class="headerlink" title="读取文件全部内容"></a>读取文件全部内容</h2><p>iostream著名专家Dietmar Kuehl给出了两个读取方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::ifstream <span class="hljs-title">in</span><span class="hljs-params">(<span class="hljs-string">&quot;some.file&quot;</span>)</span></span>;<br><span class="hljs-function">std::isreambuf_iterator&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title">begin</span><span class="hljs-params">(in)</span></span>;<br>std::isreambuf_iterator&lt;<span class="hljs-type">char</span>&gt; end;<br><span class="hljs-function">std::string <span class="hljs-title">some_str</span><span class="hljs-params">(begin, end)</span></span>;<span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::ifstream <span class="hljs-title">in</span><span class="hljs-params">(<span class="hljs-string">&quot;some.file&quot;</span>)</span></span>;<br>std::ostringstream tmp;<br>tmp &lt;&lt; in.<span class="hljs-built_in">rdbuf</span>();<br>std::string str = tmp.<span class="hljs-built_in">str</span>();<br></code></pre></td></tr></table></figure><h2 id="C-C-调用exe文件"><a href="#C-C-调用exe文件" class="headerlink" title="C&#x2F;C++调用exe文件"></a>C&#x2F;C++调用exe文件</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C 此为命令行控制台方法</span><br><span class="hljs-type">char</span>* a1 = (<span class="hljs-type">char</span>*)<span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-type">char</span>* a2 = (<span class="hljs-type">char</span>*)<span class="hljs-string">&quot;world&quot;</span>;<br><span class="hljs-type">char</span>* a3 = (<span class="hljs-type">char</span>*)<span class="hljs-string">&quot;!&quot;</span>;<br><span class="hljs-type">char</span> s[<span class="hljs-number">100</span>];<br>sprintf_s(s,<span class="hljs-string">&quot;%s %s %s %s &quot;</span>,<span class="hljs-string">&quot;./ceshi.exe&quot;</span>,a1,a2,a3);<br>system(s);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c/c++</tag>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Wordpress</title>
    <link href="/2022/aa858de8/"/>
    <url>/2022/aa858de8/</url>
    
    <content type="html"><![CDATA[<h1 id="Wordpress"><a href="#Wordpress" class="headerlink" title="Wordpress"></a>Wordpress</h1><h2 id="LNMP安装"><a href="#LNMP安装" class="headerlink" title="LNMP安装"></a>LNMP安装</h2><p><a href="https://lnmp.org/">https://lnmp.org/</a></p><p><strong>LNMP一键安装包是什么?</strong></p><p>LNMP一键安装包是一个用Linux Shell编写的可以为CentOS&#x2F;RHEL&#x2F;Fedora&#x2F;Aliyun&#x2F;Amazon、Debian&#x2F;Ubuntu&#x2F;Raspbian&#x2F;Deepin&#x2F;Mint Linux VPS或独立主机安装LNMP(Nginx&#x2F;MySQL&#x2F;PHP)、LNMPA(Nginx&#x2F;MySQL&#x2F;PHP&#x2F;Apache)、LAMP(Apache&#x2F;MySQL&#x2F;PHP)生产环境的Shell程序。</p><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 登录</span><br>mysql -u root -p<br><br><span class="hljs-comment"># 如果报找不到命令 cd到对应目录去登录</span><br><span class="hljs-built_in">cd</span> /usr/local/mariadb10/bin/<br>./mysql -u root -p<br><br><span class="hljs-comment"># 切换到mysql数据库</span><br>use mysql<br><br><span class="hljs-comment"># 执行以下命令，创建 MariaDB 数据库。例如 “wordpress”。</span><br>CREATE DATABASE IF NOT EXISTS wordpress;<br><br><span class="hljs-comment"># 执行以下命令，创建一个新用户。例如 “user”，登录密码为 123456。</span><br>CREATE USER <span class="hljs-string">&#x27;user&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> IDENTIFIED BY <span class="hljs-string">&#x27;123456&#x27;</span>;<br><br><span class="hljs-comment"># 执行以下命令，赋予用户对 “wordpress” 数据库的全部权限。</span><br>GRANT ALL PRIVILEGES ON wordpress.* TO <span class="hljs-string">&#x27;user&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> IDENTIFIED BY <span class="hljs-string">&#x27;123456&#x27;</span>;<br><br><span class="hljs-comment"># 执行以下命令，设置 root 帐户密码</span><br>ALTER USER root@localhost IDENTIFIED VIA mysql_native_password USING PASSWORD(<span class="hljs-string">&#x27;输入您的密码&#x27;</span>);<br><br><span class="hljs-comment"># 执行以下命令，使所有配置生效。</span><br>FLUSH PRIVILEGES;<br><br><span class="hljs-comment"># 退出</span><br>\q<br></code></pre></td></tr></table></figure><h2 id="Wordpress-1"><a href="#Wordpress-1" class="headerlink" title="Wordpress"></a>Wordpress</h2><h4 id="修改-WordPress-配置文件"><a href="#修改-WordPress-配置文件" class="headerlink" title="修改 WordPress 配置文件"></a>修改 WordPress 配置文件</h4><ol><li><p>依次执行以下命令，进入 WordPress 安装目录，将<code>wp-config-sample.php</code>文件复制到<code>wp-config.php</code>文件中，并将原先的示例配置文件保留作为备份。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /home/wwwroot/wordpress<br></code></pre></td></tr></table></figure><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">cp</span> <span class="hljs-keyword">wp</span>-config-sample.php <span class="hljs-keyword">wp</span>-config.php<br></code></pre></td></tr></table></figure></li><li><p>执行以下命令，打开并编辑新创建的配置文件。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">vim</span> <span class="hljs-keyword">wp</span>-config.php<br></code></pre></td></tr></table></figure></li><li><p>按 <strong>i</strong> 切换至编辑模式，找到文件中 MySQL 的部分，并将相关配置信息修改为 <a href="https://cloud.tencent.com/document/product/213/8044#database">配置 WordPress 数据库</a> 中的内容。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-comment">// ** MySQL settings - You can get this info from your web host ** //</span><br><span class="hljs-comment">/** The name of the database for WordPress */</span><br><span class="hljs-class"><span class="hljs-keyword">define</span></span>(<span class="hljs-string">&#x27;DB_NAME&#x27;</span>, <span class="hljs-string">&#x27;wordpress&#x27;</span>);<br>    <br><span class="hljs-comment">/** MySQL database username */</span><br><span class="hljs-class"><span class="hljs-keyword">define</span></span>(<span class="hljs-string">&#x27;DB_USER&#x27;</span>, <span class="hljs-string">&#x27;user&#x27;</span>);<br>    <br><span class="hljs-comment">/** MySQL database password */</span><br><span class="hljs-class"><span class="hljs-keyword">define</span></span>(<span class="hljs-string">&#x27;DB_PASSWORD&#x27;</span>, <span class="hljs-string">&#x27;123456&#x27;</span>);<br>    <br><span class="hljs-comment">/** MySQL hostname */</span><br><span class="hljs-class"><span class="hljs-keyword">define</span></span>(<span class="hljs-string">&#x27;DB_HOST&#x27;</span>, <span class="hljs-string">&#x27;localhost&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>修改完成后，按 <strong>Esc</strong>，输入 <strong>:wq</strong>，保存文件返回。</p></li></ol><h3 id="开启HTTPS支持"><a href="#开启HTTPS支持" class="headerlink" title="开启HTTPS支持"></a>开启HTTPS支持</h3><h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><h2 id="获取域名"><a href="#获取域名" class="headerlink" title="获取域名"></a>获取域名</h2><p>这里有一个免费的域名, 先凑合用着吧</p><p><a href="https://www.freenom.com/">https://www.freenom.com/</a></p><blockquote><p>  freenom 注册方法</p><p>  <a href="https://zhuanlan.zhihu.com/p/115535965">https://zhuanlan.zhihu.com/p/115535965</a></p><p>  Freenom常见问题解决方法</p><p>  <a href="http://www.360doc.com/content/21/0124/00/30583588_958609144.shtml">http://www.360doc.com/content/21/0124/00/30583588_958609144.shtml</a></p></blockquote><ul><li><p>注册的时候搜索要加上后缀不然会显示  不可用</p></li><li><p>checkout 到购物车改成 12月 free</p></li><li><p>谷歌邮箱直接登录 登录后要更改自己的个人信息里面的地址(改成ip所在地) 不然无法成功注册</p></li><li><p>菜单栏 servers -&gt; my domains 就可以看到地址了</p></li><li><p>最后再修改一下NS服务器</p><ul><li><p>Manage Domain -&gt; Management Tools -&gt; nameserver -&gt; Use custom nameservers (enter below)</p></li><li><p>这里填写cloudflare 或者 dnspod 给出来的 Nameservers 就好了</p></li><li><p>类似于</p></li><li><table><thead><tr><th align="left">Type</th><th align="left">Value</th></tr></thead><tbody><tr><td align="left">NS</td><td align="left">katja.ns.cloudflare.com</td></tr><tr><td align="left">NS</td><td align="left">kirk.ns.cloudflare.com</td></tr></tbody></table></li></ul></li></ul><h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><p>域名的<a href="https://www.vpsgo.com/tag/ns%E8%AE%B0%E5%BD%95">NS记录</a>（<a href="https://www.vpsgo.com/tag/name-server">Name Server</a>）是指处理域名解析的服务器，说白点就是你的域名由谁家来解析。一般购买了域名后，默认的NS记录就是指向域名提供商的（例如NameSilo的默认就由它自己解析）。你可以修改域名的NS记录，让它由不同的解析服务商来解析，例如可以指向<a href="https://www.vpsgo.com/tag/cloudflare">Cloudflare</a>或者<a href="https://www.vpsgo.com/tag/dnspod">DNSPod</a>。</p><p>之后DNS（Domain Name System），常用的<a href="https://www.vpsgo.com/tag/dns%E8%AE%B0%E5%BD%95">DNS记录</a>包括域名解析中A记录、CNAME、MX记录。<a href="https://www.vpsgo.com/tag/%E5%9F%9F%E5%90%8Da%E8%AE%B0%E5%BD%95">域名A记录</a>又称为IP指向，就是说你这个域名代表什么IP；域名CNAME是指别名指向，就是说指向另一个域名，例如可以设置test.vpsgo.com指向<a href="http://www.vpsgo.com;域名的mx记录就是邮件交换记录,是做邮件服务器需要设置的.本文主要介绍域名a记录解析./">www.vpsgo.com；域名的MX记录就是邮件交换记录，是做邮件服务器需要设置的。本文主要介绍域名A记录解析。</a></p><blockquote><p>  cloudflare 解析</p><p>  <a href="https://zhuanlan.zhihu.com/p/56423186">https://zhuanlan.zhihu.com/p/56423186</a></p><p>  <a href="https://www.vpsgo.com/domain-ns-cloudflare-dnspod.html#NS">https://www.vpsgo.com/domain-ns-cloudflare-dnspod.html#NS</a></p></blockquote><h1 id="HTTPS-SSL-TLS"><a href="#HTTPS-SSL-TLS" class="headerlink" title="HTTPS SSL&#x2F;TLS"></a>HTTPS SSL&#x2F;TLS</h1><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><h3 id="acme-sh"><a href="#acme-sh" class="headerlink" title="acme.sh"></a>acme.sh</h3><p><a href="https://ruby-china.org/topics/31983">https://ruby-china.org/topics/31983</a></p><p><a href="https://ruby-china.org/topics/28471">https://ruby-china.org/topics/28471</a></p><p><a href="https://ruby-china.org/topics/25543">https://ruby-china.org/topics/25543</a></p><p><a href="https://ruby-china.org/topics/31942">https://ruby-china.org/topics/31942</a></p><h3 id="caddy"><a href="#caddy" class="headerlink" title="caddy"></a>caddy</h3><p><a href="https://caddyserver.com/docs/quick-starts/https">https://caddyserver.com/docs/quick-starts/https</a></p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装 acme.sh</span><br>curl https://get.acme.sh | sh<br><br><span class="hljs-comment"># 然后重新载入一下 .bashrc</span><br><span class="hljs-built_in">source</span> ~/.bashrc <br><br><span class="hljs-comment"># 至此acme安装完成</span><br>acme.sh<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 注册账号</span><br><span class="hljs-built_in">sudo</span> ~/.acme.sh/acme.sh --register-account -m jackliuworkemail@gmail.com  --server zerossl<br><br><span class="hljs-comment"># 为lager.cf创建密钥</span><br><span class="hljs-comment"># -k 表示密钥长度，后面的值可以是 ec-256 、ec-384、2048、3072、4096、8192，带有 ec 表示生成的是 ECC 证书，没有则是 RSA 证书。在安全性上 256 位的 ECC 证书等同于 3072 位的 RSA 证书。</span><br><span class="hljs-built_in">sudo</span> ~/.acme.sh/acme.sh --issue -d lager.cf --standalone -k ec-256<br><br><span class="hljs-comment"># 由于 Let&#x27;s Encrypt 的证书有效期只有 3 个月，因此需要 90 天至少要更新一次证书，acme.sh 脚本会每 60 天自动更新证书。也可以手动更新。</span><br><span class="hljs-comment"># 查看计划任务</span><br> crontab -l<br><span class="hljs-comment"># 手动更新 ECC 证书，执行：</span><br><span class="hljs-built_in">sudo</span> ~/.acme.sh/acme.sh --renew -d lager.cf --force --ecc<br><br><span class="hljs-comment"># 请注意：reloadcmd非常重要。证书可以自动续订，但是，如果没有正确的“reloadcmd”，证书可能无法刷新到您的服务器（如nginx或apache），那么您的网站将无法在60天内显示续订证书。</span><br><span class="hljs-comment"># 注意：无论什么情况，密钥(即上面的lager.cf.key)都不能泄漏，如果你不幸泄漏了密钥，可以使用 acme.sh 将原证书吊销，再生成新的证书，吊销方法请自行参考 acme.sh 的手册</span><br>acme.sh --installcert -d lager.cf \<br>--keypath       /usr/local/nginx/ssl/lager.cf.key \<br>--fullchainpath /usr/local/nginx/ssl/lager.cf.cer \<br>--reloadcmd     <span class="hljs-string">&quot;sudo service nginx force-reload&quot;</span>  --force --ecc<br><br><span class="hljs-comment"># 生成 dhparam.pem 文件</span><br>openssl dhparam -out /usr/local/nginx/ssl/lager.cf.pem 2048<br><br><br><span class="hljs-comment"># 配置nginx 启用 https</span><br>vim /usr/local/nginx/conf/nginx.conf<br><br><span class="hljs-comment"># 检查配置</span><br><span class="hljs-built_in">sudo</span> service nginx configtest<br><span class="hljs-comment"># 重启服务</span><br><span class="hljs-built_in">sudo</span> service nginx restart<br><br><br><span class="hljs-comment">#验证 SSL</span><br><span class="hljs-comment">#访问 ssllabs.com 输入你的域名，检查 SSL 的配置是否都正常：</span><br>https://ssllabs.com/ssltest/analyze.html?d=ruby-china.org<br></code></pre></td></tr></table></figure><h3 id="一些注意事项"><a href="#一些注意事项" class="headerlink" title="一些注意事项"></a>一些注意事项</h3><ul><li><code>ssl_dhparam</code> 未配置，将导致 ssllabs.com 的评分降到 B，并给 <code>This server supports weak Diffie-Hellman (DH) key exchange parameters. Grade capped to B.</code> 的警告。</li><li><code>ssl_prefer_server_ciphers on</code> 也是一个必要的配置，否则会 A+ 变成 A-;</li><li>如果你需要兼容老系统或老浏览器的话，你需要配置 <code>ssl_ciphers</code>，详见 <a href="https://wiki.mozilla.org/Security/Server_Side_TLS">Mozilla Server_Side_TLS 的介绍</a>，Nginx 里面 <code>ssl_ciphers</code> 默认值是 <code>HIGH:!aNULL:!MD5;</code> <a href="https://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_ciphers">ref</a></li></ul><h2 id="acme-sh-1"><a href="#acme-sh-1" class="headerlink" title="acme.sh"></a>acme.sh</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看证书列表</span><br>acme.sh --list<br><br><span class="hljs-comment"># 删除证书</span><br>acme.sh remove Main_Domain (证书的主域名，上述证书列表中可看见)<br><br><span class="hljs-comment"># 升级 acme.sh 到最新版 :</span><br>acme.sh --upgrade<br><br><span class="hljs-comment"># 如果你不想手动升级, 可以开启自动升级:</span><br>acme.sh --upgrade --auto-upgrade<br><br><span class="hljs-comment">#你也可以随时关闭自动更新:</span><br>acme.sh --upgrade --auto-upgrade 0 <br><br><span class="hljs-comment"># 如果出错, 请添加 debug log：</span><br>acme.sh --issue ..... --debug <br><span class="hljs-comment"># 或者：</span><br>acme.sh --issue ..... --debug 2<br></code></pre></td></tr></table></figure><h2 id="ngix"><a href="#ngix" class="headerlink" title="ngix"></a>ngix</h2><h3 id="nginx-config-1"><a href="#nginx-config-1" class="headerlink" title="nginx config 1"></a>nginx config 1</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">server &#123;<br>    listen 80; <span class="hljs-comment">#如果硬性要求全部走https协议，这一行去除</span><br>    listen 443 ssl http2; <span class="hljs-comment">#如果硬性要求全部走https协议，这里去除ssl</span><br>    server_name chandao.test.com;<br><br>    ssl_certificate /usr/local/nginx/ssl_cert/test.com/chandao.test.com.cer;<br>    ssl_certificate_key /usr/local/nginx/ssl_cert/test.com/chandao.test.com.key;<br>    ssl_dhparam /usr/local/nginx/ssl/lager.cf.pem;<br><br>    <span class="hljs-comment">#ssl性能调优</span><br>    <span class="hljs-comment">#nginx 1.13.0支持了TLSv1.3,TLSv1.3相比之前的TLSv1.2、TLSv1.1等性能大幅提升</span><br>    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;<br>    <span class="hljs-comment"># ssl_ciphers EECDH+CHACHA20:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5;</span><br>    <span class="hljs-comment"># ssl_prefer_server_ciphers on|off 作用：是否由服务器决定采用哪种加密算法</span><br>    <span class="hljs-comment"># 如果ssl协议支持tlsv1 tls1.1这种老协议，设置为 on ，并配合ssl_ciphers使用</span><br>    <span class="hljs-comment"># 如果ssl协议只支持tlsv1.2 tlsv1.3新协议，设置为 off （nginx默认为off），因为新协议不再采纳此参数</span><br>    ssl_prefer_server_ciphers on;<br>    ssl_session_timeout 10m;<br>    <span class="hljs-comment">#使用ssl_session_cache优化https下Nginx的性能</span><br>    ssl_session_cache <span class="hljs-built_in">builtin</span>:1000 shared:SSL:10m;<br>    <span class="hljs-comment">#OCSP Stapling 开启。OCSP是用于在线查询证书吊销情况的服务，使用OCSP Stapling能将证书有效状态的信息缓存到服务器，提高 TLS 握手速度</span><br>    ssl_stapling on;<br>    <span class="hljs-comment">#OCSP Stapling 验证开启</span><br>    ssl_stapling_verify on;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="nginx-config-2"><a href="#nginx-config-2" class="headerlink" title="nginx config 2"></a>nginx config 2</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">http</span> &#123;<br>  <span class="hljs-comment"># 新增</span><br>  <span class="hljs-attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="hljs-number">1</span> TLSv1.<span class="hljs-number">2</span>;<br>  <span class="hljs-attribute">ssl_prefer_server_ciphers</span> <span class="hljs-literal">on</span>;<br>  <span class="hljs-comment"># 兼容其他老浏览器的 ssl_ciphers 设置请访问 https://wiki.mozilla.org/Security/Server_Side_TLS</span><br><br>  <span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span> default_server;<br>    <span class="hljs-comment"># 新增</span><br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">443</span> ssl;<br>    <span class="hljs-attribute">ssl_certificate</span>         /home/ubuntu/www/ssl/www.your-app.com.key.pem;<br>    <span class="hljs-attribute">ssl_certificate_key</span>     /home/ubuntu/www/ssl/www.your-app.com.key;<br>    <span class="hljs-comment"># ssl_dhparam </span><br>    <span class="hljs-attribute">ssl_dhparam</span>             /home/ubuntu/www/ssl/dhparam.pem;<br><br>    <span class="hljs-comment"># 其他省略</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>80 重定向到 443</p><p>这些办法试了好多次都不太行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">server &#123;<br>  listen       80 default_server;<br>  server_name  www.lager.cf;<br>  <span class="hljs-built_in">return</span> 301 https://$server_name<span class="hljs-variable">$request_uri</span>;<br>&#125;<br><br><br>server &#123;<br>    listen      80;<br>    server_name    www.awesomes.cn,awesomes.cn;<br>    rewrite ^(.*)$  https://$host<span class="hljs-variable">$1</span> permanent;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="v2ray-tls-websocket-流量伪装"><a href="#v2ray-tls-websocket-流量伪装" class="headerlink" title="v2ray + tls + websocket 流量伪装"></a>v2ray + tls + websocket 流量伪装</h1><p><a href="https://www.bwgss.org/616.html">https://www.bwgss.org/616.html</a></p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><ol><li><p>证书(Certificate) – *.cer *.crt</p></li><li><p>私钥(Private Key) – *.key</p></li><li><p>证书签名请求(Certificate signing request) – *.csr</p></li><li><p>编码方式: 1. pem - base64编码 2. der - 二进制编码(少见), cer,key,csr 均可用这两种编码方式</p></li><li><p>证书吊销列表(Certificate Revocation List) – *.crl</p></li><li><p>jks（javakeystone）— 是JAVA的keytools证书工具支持的证书私钥格式，javakeystone 里面存放着key和信任的CA，key和CA可以有多个。</p></li></ol><p><img src="/2022/aa858de8/1606053801673.png" alt="Wordpress"></p>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ssl</tag>
      
      <tag>https</tag>
      
      <tag>wordpress</tag>
      
      <tag>web</tag>
      
      <tag>mysql</tag>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CatDrive猫盘</title>
    <link href="/2022/eae787f0/"/>
    <url>/2022/eae787f0/</url>
    
    <content type="html"><![CDATA[<h1 id="刷机"><a href="#刷机" class="headerlink" title="刷机"></a>刷机</h1><p>刷机教程很多很多，这边就不赘述了</p><p><a href="https://www.jianshu.com/p/77e529fb35f9">https://www.jianshu.com/p/77e529fb35f9</a></p><p><a href="https://www.huakings.cn/post/283.html">https://www.huakings.cn/post/283.html</a></p><ul><li>建议备好串口刷砖必备</li><li>猫盘ssh 用户名 <strong>root</strong> 密码 <strong>Etech12</strong></li></ul><h1 id="变砖刷机"><a href="#变砖刷机" class="headerlink" title="变砖刷机"></a>变砖刷机</h1><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.bilibili.com/video/av73492887">https://www.bilibili.com/video/av73492887</a></p><p><a href="https://www.huakings.cn/post/186.html">https://www.huakings.cn/post/186.html</a></p><p><a href="http://wiki.espressobin.net/tiki-index.php?page=Bootloader+recovery+via+UART">http://wiki.espressobin.net/tiki-index.php?page=Bootloader+recovery+via+UART</a></p><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p><strong>猫盘引导过程</strong></p><p><img src="/2022/eae787f0/image-20211225204417854.png" alt="image-20211225204417854"></p><p>从 A3720 机器引导，再到SPI FLASH引导，再到SATA硬盘或者EMMC启动</p><p>出现<code>&gt;E</code>就是SPI引导没了，需要用厂商工具把SPI引导刷一遍。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p><img src="/2022/eae787f0/image-20211225203501999.png" alt="image-20211225203501999"></p><p>发现出现<code>&gt;E</code>，这就说明猫盘SPI引导没了，需要重新刷入uboot，进行救砖。</p><p>首先，需要预装VM启用厂商的Linux环境(ezremaster.iso)，安装VM这步跳过。</p><blockquote><p>创建虚拟机的时候操作系统可以选择Linux 2.2.x内核，</p></blockquote><p>串口的USB设备加到VM内，然后开机。</p><p>输入如下代码，回车运行后会让输入port，<code>/dev/ttyUSB0</code>一般是<code>0</code>输入0回车就会开始刷SPI，然后会出现++++++++，在此期间可以按几下回车。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo sh /wtpd/shua.sh<br></code></pre></td></tr></table></figure><p><img src="/2022/eae787f0/image-20211225204613427.png" alt="image-20211225204613427"></p><p>等一段时间就会出现<code>marvell&gt;&gt;</code>，至此就已经救砖成功。</p><p><img src="/2022/eae787f0/image-20211225205017895.png" alt="image-20211225205017895"></p><p>接下来就可以用<code>bubt</code>命令正常刷SPI引导了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">bubt full.bin spi usb<br></code></pre></td></tr></table></figure><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><h2 id="LED-FAN-控制脚本"><a href="#LED-FAN-控制脚本" class="headerlink" title="LED FAN 控制脚本"></a>LED FAN 控制脚本</h2><p>参考: <a href="https://bbs.nas66.com/thread-9007-1-1.html">https://bbs.nas66.com/thread-9007-1-1.html</a></p><p>参考: <a href="https://bbs.nas66.com/thread-13810-1-1.html">https://bbs.nas66.com/thread-13810-1-1.html</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir -p /a_usr<br>cat &gt; /a_usr/ledfan.sh &lt;&lt;EOF<br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/sh</span><br>if [ ! -d /sys/class/gpio/gpio450 ] ; then<br>echo 450 &gt; /sys/class/gpio/export<br>fi<br>echo out &gt; /sys/class/gpio/gpio450/direction<br>i2cset -y -f 0 0x45 0x00 0x55<br>i2cset -y -f 0 0x45 0x01 0x01<br>i2cset -y -f 0 0x45 0x30 0x07 <br>rm -r /tmp/led/<br>mkdir /tmp/led/<br>echo 1 &gt; /tmp/led/leds.flag<br>while true<br>do<br>sata_temp=&quot;\$(smartctl -a /dev/hda -d ata | sed -n &#x27;/Temperature_Celsius/p&#x27; | awk &#x27;&#123;print $10&#125;&#x27;)&quot;<br>sata=&quot;\$(hdparm -C /dev/sda |grep &#x27;drive&#x27;|awk &#x27;&#123;print \$4&#125;&#x27;)&quot;<br>ledss=&quot;\$(cat /tmp/led/leds.flag)&quot;<br>if [ \$sata = standby ];then<br>led=&quot;0x03&quot;<br>leds=&quot;0&quot;<br>fi<br>if [ \$sata = active/idle ];then<br>led=&quot;0x73&quot;<br>leds=&quot;1&quot;<br>fi<br>if [ \$sata_temp -ge 55 ];then<br>if [ -f &quot;/tmp/led/led31.flag&quot; ] &amp;&amp; [ \$ledss = \$leds ];then <br>sleep 15<br>continue<br>fi<br>i2cset -y -f 0 0x45 0x32 0x00<br>i2cset -y -f 0 0x45 0x33 0x00<br>i2cset -y -f 0 0x45 0x31 \$&#123;led&#125;<br>i2cset -y -f 0 0x45 0x34 255<br>echo 1 &gt; /sys/class/gpio/gpio450/value<br>rm -rf /tmp/led/led*.flag<br>touch /tmp/led/led31.flag<br>echo \$&#123;leds&#125; &gt; /tmp/led/leds.flag<br>fi<br>if [ \$sata_temp -ge 45 ] &amp;&amp; [ \$sata_temp -lt 55 ];then<br>if [ -f &quot;/tmp/led/led33.flag&quot; ] &amp;&amp; [ \$ledss = \$leds ];then<br>sleep 15 <br>continue<br>fi<br>i2cset -y -f 0 0x45 0x31 0x00<br>i2cset -y -f 0 0x45 0x32 0x00<br>i2cset -y -f 0 0x45 0x33 \$&#123;led&#125;<br>i2cset -y -f 0 0x45 0x36 255<br>echo 1 &gt; /sys/class/gpio/gpio450/value<br>rm -rf /tmp/led/led*.flag<br>touch /tmp/led/led33.flag<br>echo \$&#123;leds&#125; &gt; /tmp/led/leds.flag<br>fi<br>if [ \$sata_temp -lt 45 ];then<br>if [ -f &quot;/tmp/led/led32.flag&quot; ] &amp;&amp; [ \$ledss = \$leds ];then<br>sleep 15 <br>continue<br>fi<br>i2cset -y -f 0 0x45 0x31 0x00<br>i2cset -y -f 0 0x45 0x33 0x00<br>i2cset -y -f 0 0x45 0x32 \$&#123;led&#125;<br>i2cset -y -f 0 0x45 0x35 255<br>echo 0 &gt; /sys/class/gpio/gpio450/value<br>rm -rf /tmp/led/led*.flag<br>touch /tmp/led/led32.flag<br>echo \$&#123;leds&#125; &gt; /tmp/led/leds.flag<br>fi<br>sleep 15<br>done<br>EOF<br>bash /a_usr/ledfan.sh<br></code></pre></td></tr></table></figure><h2 id="修改SN半白脚本"><a href="#修改SN半白脚本" class="headerlink" title="修改SN半白脚本"></a>修改SN半白脚本</h2><p>下面的<code>00:11:32:12:34:56</code>最好改成壳子上自己的MAC</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd ~ &amp;&amp; wget -N --no-check-certificate https://www.huakings.cn/mp202003/macsn.sh &amp;&amp; chmod +x macsn.sh &amp;&amp; bash macsn.sh 00:11:32:12:34:56 1860ABCDE1860 &amp;&amp; rm -f /root/macsn.sh<br></code></pre></td></tr></table></figure><p>macsn.sh脚本详细内容如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs shell">macstr=$1<br>sn=$2<br>mac=($&#123;macstr//:/ &#125;)<br>if [ $&#123;#mac[@]&#125; != 6 ];<br>then<br>echo mac address error!<br>exit<br>fi<br>for var in $&#123;mac[@]&#125;<br>do<br>if echo $var | grep -q &#x27;[^0-9A-F]&#x27;<br>then <br>echo mac address error!<br>exit<br>fi <br>if  [[ $&#123;#var&#125; != 2  ]] <br>then<br>echo mac address error!!<br>exit<br>fi<br>done<br>if  [[ $&#123;#sn&#125; != 13  ]] <br>then<br>echo sn error:The SN Length must be 13<br>exit<br>fi<br><br>for((i=0;i&lt;6;i++));<br>do <br>declare -i macchecksum+=0x$&#123;mac[i]&#125;<br>done<br>declare -i macchecksum=$macchecksum%256<br>for((i=0;i&lt;13;i++));<br>do <br>declare -i checksum+=$(printf &#x27;%d&#x27; &quot;&#x27;$&#123;sn:$i:1&#125;&quot;)<br>done<br>if [ $&#123;#checksum&#125; == 3 ];<br>then<br>echo -e -n &quot;\x$&#123;mac[0]&#125;\x$&#123;mac[1]&#125;\x$&#123;mac[2]&#125;\x$&#123;mac[3]&#125;\x$&#123;mac[4]&#125;\x$&#123;mac[5]&#125;\<br>\x$(printf &#x27;%x&#x27; $macchecksum)\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0&quot;\<br>\SN=$sn&quot;,CHK=&quot;$checksum\<br>&quot;\x0\x0\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x3C\x0\x0\x0\<br>\x0\x0\x0\x0\x1\x1\x0\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x1\x1\x1\x1\<br>\x0\x1\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x1\x1\x1\x1\<br>\x1\x0\x1\x1\x1\x1\x1\x0\<br>\x1\x1\x1\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x1\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0&quot; &gt; vender.bin<br>else<br>echo -e -n &quot;\x$&#123;mac[0]&#125;\x$&#123;mac[1]&#125;\x$&#123;mac[2]&#125;\x$&#123;mac[3]&#125;\x$&#123;mac[4]&#125;\x$&#123;mac[5]&#125;\<br>\x$(printf &#x27;%x&#x27; $macchecksum)\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0&quot;\<br>\SN=$sn&quot;,CHK=&quot;$checksum\<br>&quot;\x0\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x3C\x0\x0\x0\<br>\x0\x0\x0\x0\x1\x1\x0\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x1\x1\x1\x1\<br>\x0\x1\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x1\x1\x1\x1\<br>\x1\x0\x1\x1\x1\x1\x1\x0\<br>\x1\x1\x1\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x1\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0&quot; &gt; vender.bin<br>fi<br>dd if=vender.bin of=/dev/mtdblock3<br>rm vender.bin<br>echo Update Success! MAC:$macstr SN:$sn<br></code></pre></td></tr></table></figure><h2 id="解决猫盘掉ip问题"><a href="#解决猫盘掉ip问题" class="headerlink" title="解决猫盘掉ip问题"></a>解决猫盘掉ip问题</h2><h3 id="最蠢的办法，检查无IP重启"><a href="#最蠢的办法，检查无IP重启" class="headerlink" title="最蠢的办法，检查无IP重启"></a>最蠢的办法，检查无IP重启</h3><p>将下面脚本添加到，群晖的开机启动</p><p>控制面板-任务计划-新增-触发的任务-用户自定义脚本-开机启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>dt=`date &#x27;+%d/%m/%Y %H:%M:%S&#x27;`<br>echo &quot;$dt&quot;<br>sleep 60<br>num=`ping -c20 223.5.5.5 | tail -2 | head -1 | cut -f 3 -d&quot;,&quot; | cut -f 1 -d&quot;%&quot; | cut -f 2 -d&quot; &quot;`<br>echo $num<br>echo $?<br>if [ $? -eq 0 -a $num -eq 0 ]; then<br>echo &quot;$dt ok&quot; &gt;&gt; /result.txt<br>else<br>echo &quot;$dt noip loss $num reboot&quot; &gt;&gt; /result.txt<br>reboot<br>fi<br></code></pre></td></tr></table></figure><h3 id="其它办法"><a href="#其它办法" class="headerlink" title="其它办法"></a>其它办法</h3><p><a href="https://bbs.nas66.com/thread-17505-1-1.html">https://bbs.nas66.com/thread-17505-1-1.html</a></p><p><a href="https://bbs.nas66.com/thread-16639-1-1.html">https://bbs.nas66.com/thread-16639-1-1.html</a></p><p><a href="https://bbs.nas66.com/thread-7843-1-1.html">https://bbs.nas66.com/thread-7843-1-1.html</a></p><p><a href="https://bbs.nas66.com/thread-9350-1-1.html">https://bbs.nas66.com/thread-9350-1-1.html</a></p><p><a href="https://bbs.nas66.com/thread-4593-5-3.html">https://bbs.nas66.com/thread-4593-5-3.html</a></p><h2 id="群晖回退x3p"><a href="#群晖回退x3p" class="headerlink" title="群晖回退x3p"></a>群晖回退x3p</h2><p><a href="https://bbs.nas66.com/forum.php?mod=viewthread&tid=2661">https://bbs.nas66.com/forum.php?mod=viewthread&amp;tid=2661</a></p><p>主要就是刷x3p的UBOOT，插U盘，U盘放x3p的自动安装镜像</p>]]></content>
    
    
    <categories>
      
      <category>more_interest</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>cat_drive</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PC Software</title>
    <link href="/2022/fc18738/"/>
    <url>/2022/fc18738/</url>
    
    <content type="html"><![CDATA[<h1 id="PC-Windows"><a href="#PC-Windows" class="headerlink" title="PC Windows"></a>PC Windows</h1><h1 id="扫描修复系统"><a href="#扫描修复系统" class="headerlink" title="扫描修复系统"></a>扫描修复系统</h1><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">sfc <span class="hljs-string">/SCANNOW</span><br></code></pre></td></tr></table></figure><h1 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h1><h3 id="刷新DNS"><a href="#刷新DNS" class="headerlink" title="刷新DNS"></a>刷新DNS</h3><p><code>ipconfig /flushdns</code></p><h3 id="nslookup"><a href="#nslookup" class="headerlink" title="nslookup"></a>nslookup</h3><p><img src="/2022/fc18738/image-20220402175405670.png" alt="image-20220402175405670"></p><p><img src="/2022/fc18738/image-20220402175432533.png" alt="image-20220402175432533"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs bash">nslookup<br><br><span class="hljs-comment"># 设置查询类型 name server</span><br><span class="hljs-built_in">set</span> <span class="hljs-built_in">type</span>=ns<br><br><span class="hljs-comment"># 查询根服务器</span><br>.<br><br><span class="hljs-comment"># Non-authoritative 代表非权威应答 一般是缓存来的</span><br><span class="hljs-comment"># authoritative 表权威应答 根服务器直接返回的</span><br><br><span class="hljs-comment"># 设置查询类型 a ipv4地址</span><br><span class="hljs-built_in">set</span> <span class="hljs-built_in">type</span>=a<br><br><span class="hljs-comment"># 查询根服务器的ipv4地址</span><br>.<br><br><span class="hljs-comment"># 设置dns服务器地址</span><br>server 198.41.0.4<br><br><span class="hljs-comment"># 设置查询类型 name server</span><br><span class="hljs-built_in">set</span> <span class="hljs-built_in">type</span>=ns<br><br><span class="hljs-comment"># 查询cf域名服务器</span><br>cf.<br><br><span class="hljs-comment"># 设置查询类型 a ipv4地址</span><br><span class="hljs-built_in">set</span> <span class="hljs-built_in">type</span>=a<br><br><span class="hljs-comment"># 查询cf域名服务器的ipv4地址</span><br>cf.<br><br>..........<br><br><br>lager.cf.<br></code></pre></td></tr></table></figure><h1 id="硬链接-符号链接"><a href="#硬链接-符号链接" class="headerlink" title="硬链接&amp;符号链接"></a>硬链接&amp;符号链接</h1><blockquote><p>  mklink<br>  创建符号链接。</p><p>  MKLINK [[&#x2F;D] | [&#x2F;H] | [&#x2F;J]] Link Target</p><pre><code class="hljs">      /D      创建目录符号链接。默认为文件              符号链接。      /H      创建硬链接而非符号链接。      /J      创建目录联接。      Link    指定新的符号链接名称。      Target  指定新链接引用的路径              (相对或绝对)。</code></pre></blockquote><table><thead><tr><th></th><th>硬链接（Hard Link）</th><th>目录联接（Junction Point）</th><th>符号链接（Symbolic Link）</th></tr></thead><tbody><tr><td>命令</td><td><code>mklink /H Link Target</code></td><td><code>mklink /J Link Target</code></td><td><code>mklink /D Link Target</code></td></tr><tr><td>作用</td><td>为某文件创建别名，可让不同的路径对应同一个文件的数据。</td><td></td><td></td></tr><tr><td>链接到文件</td><td>✔️</td><td>❌</td><td>❌</td></tr><tr><td>链接到文件夹</td><td>❌</td><td>✔️</td><td>✔️</td></tr><tr><td>需要提升为管理员权限</td><td>需要</td><td>不需要</td><td>通常需要 <code>[坑1]</code></td></tr><tr><td>跨驱动器卷（盘符）</td><td>❌</td><td>✔️（仅本地计算机）</td><td>✔️（包括 SMB 文件或路径）</td></tr><tr><td>操作系统支持</td><td>Windows NT 3.1 开始支持 Windows 2000 开始有 API <code>CreateHardLink()</code> Windows NT 6.0 开始能使用 <code>mklink /H</code></td><td>Windows 2000+</td><td>Windows Vista+</td></tr><tr><td>可链接到不存在的目标</td><td>❌</td><td>✔️</td><td>✔️</td></tr><tr><td>可链接到相对目录</td><td>❌</td><td>❌（可以使用相对路径创建，但创建完即变绝对路径）</td><td>✔️</td></tr><tr><td>删除方法</td><td>del</td><td>rd</td><td>rd &#x2F; del</td></tr><tr><td>当链接被单独删除后</td><td>只有所有指向原始文件的硬链接和原始文件全部删除后文件数据才会被删除。</td><td>Windows Vista 之后原始文件夹不受影响；Windows 2000&#x2F;XP&#x2F;2003 会导致原始子文件夹被删除。</td><td>原始文件夹不受影响。</td></tr><tr><td>当原始文件被单独删除后</td><td>硬链接依然能正常访问到文件的数据。</td><td>目录联接失效，指向不存在的目录。</td><td>符号链接失效，指向不存在的目录</td></tr></tbody></table><p>比较 Windows 上四种不同的文件（夹）链接方式（NTFS 的硬链接、目录联接、符号链接，和大家熟知的快捷方式）</p><p><a href="https://blog.walterlv.com/post/ntfs-link-comparisons.html">https://blog.walterlv.com/post/ntfs-link-comparisons.html</a></p><p>Windows中的硬链接和软链接（hard link 和 Symbolic link）</p><p><a href="https://www.cnblogs.com/Naylor/p/7597869.html">https://www.cnblogs.com/Naylor/p/7597869.html</a></p><p>Windows下mklink使用, 硬链接, 软链接和快捷方式的区别</p><p><a href="https://blog.csdn.net/guyue35/article/details/49761347">https://blog.csdn.net/guyue35/article/details/49761347</a></p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dos">创建链接:<br>mklink /j D:\System\Desktop\Project  D:\Project<br><br><br><br>删除的命令：<br><span class="hljs-built_in">rmdir</span> 链接名称<br>例如：<span class="hljs-built_in">rmdir</span> d:\recivefiles <span class="hljs-built_in">rmdir</span> d:\develop<br>删除虚拟链接目录，并不会删除真实文件，注意，不能使用<span class="hljs-built_in">del</span>命令，<span class="hljs-built_in">del</span>命令会删除真实文件<br></code></pre></td></tr></table></figure><p>拓展 :  linux下的软链接和硬链接</p><blockquote><p>  同样，在Windows下，链接的功能也是被实现了的（虽然我们不会经常发现）。在Linux下，我们都知道链接有两种形式：硬链接和软链接。所谓硬链接，我们可以理解为硬链接持有的是文件本身（而不是路径）的引用。也就是说，当我们给一个名为a.txt的文件建立硬链接（b.txt）后，那么b.txt指向的位置就是a.txt这个文件本身，而此时，a.txt和b.txt是同级平行的，这个文本文件此时同时拥有两个文件名。当我们删除a.txt时，只是删除了a.txt这个文件名，这个文件仍然被b.txt所引用，所以我们还能够通过b.txt访问。而软链接，持有的则是原链接路径。比如a.txt位于 <del>&#x2F;Document&#x2F;a.txt ，那么为其建立软链接b.txt的内容就是”</del>&#x2F;Document&#x2F;a.txt”，此时，我们访问b.txt，其实是在按照a.txt的路径去访问a.txt。如果我们这时删除a.txt这个文件，那么b.txt也会无效，因为路径已经断掉。</p></blockquote><h1 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE"></a>NOTE</h1><h2 id="窗口主题色-活动和非活动窗口"><a href="#窗口主题色-活动和非活动窗口" class="headerlink" title="窗口主题色 活动和非活动窗口"></a>窗口主题色 活动和非活动窗口</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">regedit 编辑<br>计算机\HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\DWM<br><br><span class="hljs-comment"># 活动窗口颜色 </span><br><span class="hljs-comment"># 32位值就是 颜色的RGB 注意的是这里不知道是大小端的问题还是其他什么问题需要RGB数值转换成BGR样式</span><br>AccentColor <br><br><span class="hljs-comment"># 非活动窗口颜色 </span><br>AccentColorInactive <br></code></pre></td></tr></table></figure><h2 id="添加永久路由"><a href="#添加永久路由" class="headerlink" title="添加永久路由"></a>添加永久路由</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">route -p add <br><br>route ADD 157.0.0.0 MASK 255.0.0.0  157.55.80.1 METRIC 3 IF 2<br>       destination^      ^mask      ^gateway     metric^    ^<br>                                                   Interface^<br></code></pre></td></tr></table></figure><h2 id="各类特定文件夹"><a href="#各类特定文件夹" class="headerlink" title="各类特定文件夹"></a>各类特定文件夹</h2><p><code>win+r</code>输入对应内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">启动文件夹</span><br>shell:startup<br><span class="hljs-meta prompt_"># </span><span class="language-bash">发送到右键菜单</span><br>shell:sendto<br></code></pre></td></tr></table></figure><h2 id="修改WIFI位置"><a href="#修改WIFI位置" class="headerlink" title="修改WIFI位置"></a>修改WIFI位置</h2><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\NetworkList\Profiles<br></code></pre></td></tr></table></figure><ul><li>展开“Profiles”项，其下面的子项是都是一个网络连接，可以通过查看“ProfilesName”来分辨，双击打开“<code>Category</code>”，</li><li>打开编辑窗口后，修改“数值数据”，这里数值0代表公用网络，1代表专用网络，2代表域网络，设置完后点击确定即可。</li></ul><h2 id="填加开机启动"><a href="#填加开机启动" class="headerlink" title="填加开机启动"></a>填加开机启动</h2><ol><li>添加<code>Windows</code>开机自动执行<code>init-wsl.bat</code>脚本</li></ol><p><code>Windows</code>键+<code>R</code>，输入<code>regedit</code>打开注册列表，在地址栏输入<code>计算机\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run</code>定位到对应注册表位置，右键新建一个字符串值，键入<code>init-wsl.bat</code>脚本绝对路径即可，如下图！</p><p><img src="/2022/fc18738/regedit-add-init-wsl.png" alt="set regedit service"></p><p>重启计算机即可发现，<code>WSL</code>中的<code>Docker</code>服务已经被启动，通过<code>192.168.33.10</code>可以直接访问到<code>WSL</code>内部的网络！</p><h2 id="windows-10-LTSC-wsappx占用大量cpu"><a href="#windows-10-LTSC-wsappx占用大量cpu" class="headerlink" title="windows 10 LTSC wsappx占用大量cpu"></a>windows 10 LTSC wsappx占用大量cpu</h2><ul><li><strong>win R输入 regedit 进注册表</strong></li><li><strong>打开注册表路径：HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\AppXSvc</strong></li><li><strong>双击右侧start 把3改为4重启就可以了。</strong></li><li><strong>如果要启用这个功能再改为3即可。</strong></li></ul><p>修改成功后运行更新程序，更新到最新，微软已经修复此问题。</p><h2 id="win下命令行查看文件MD5"><a href="#win下命令行查看文件MD5" class="headerlink" title="win下命令行查看文件MD5"></a>win下命令行查看文件MD5</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">certutil -hashfile filename MD5<br>certutil -hashfile filename SHA1<br>certutil -hashfile filename SHA256<br></code></pre></td></tr></table></figure><p>CRC32需要额外的程序</p><p><a href="https://esrg.sourceforge.net/utils_win_up/md5sum/">https://esrg.sourceforge.net/utils_win_up/md5sum/</a></p>]]></content>
    
    
    <categories>
      
      <category>more_interest</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>pc</tag>
      
      <tag>software</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式</title>
    <link href="/2022/2f57a694/"/>
    <url>/2022/2f57a694/</url>
    
    <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h1 id="正则表达式-语法"><a href="#正则表达式-语法" class="headerlink" title="正则表达式 - 语法"></a>正则表达式 - 语法</h1><h2 id="可打印普通字符匹配"><a href="#可打印普通字符匹配" class="headerlink" title="可打印普通字符匹配"></a>可打印普通字符匹配</h2><p>普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。</p><table><thead><tr><th align="left">字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>.</code></td><td align="left">匹配除换行符（\n、\r）之外的任何单个字符，相等于 <code>[^\n\r]</code>。</td></tr><tr><td align="left"><code>\w</code></td><td align="left">匹配字母、数字、下划线。等价于 [A-Za-z0-9_]<br><code>\W 匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。</code></td></tr><tr><td align="left"><code>[\s\S]</code></td><td align="left">匹配所有。<code>\s</code> 是匹配所有空白符，包括换行，<code>\S</code> 非空白符，不包括换行。</td></tr><tr><td align="left"><code>[ABC]</code></td><td align="left">匹配 <code>[...]</code> 中的所有字符，<br/>例如 <code>[aeiou]</code> 匹配字符串 “google runoob taobao” 中所有的 e o u a 字母。</td></tr><tr><td align="left"><code>[^ABC]</code></td><td align="left">匹配除了 <code>[...]</code> 中字符的所有字符，<br/>例如 <code>[^aeiou]</code> 匹配字符串 “google runoob taobao” 中除了 e o u a 字母的所有字母。</td></tr><tr><td align="left"><code>[A-Z]</code></td><td align="left"><code>[A-Z]</code> 表示一个区间，匹配所有大写字母，[a-z] 表示所有小写字母。</td></tr><tr><td align="left"><code>\d</code></td><td align="left">匹配一个数字字符。等价于<code>[0-9]</code>。</td></tr><tr><td align="left"><code>\D</code></td><td align="left">匹配一个非数字字符。等价于<code>[^0-9]</code>。</td></tr><tr><td align="left"><code>\xnn</code></td><td align="left">十六进制转义字符序列。匹配两个十六进制数字<em>nn</em>表示的字符。<br/>例如，“<code>\x41</code>”匹配“<code>A</code>”。“<code>\x041</code>”则等价于“<code>\x04&amp;1</code>”。正则表达式中可以使用ASCII编码。</td></tr><tr><td align="left"><code>\num</code></td><td align="left">向后引用（back-reference）一个子字符串（substring），该子字符串与正则表达式的第<em>num</em>个用括号围起来的捕捉群（capture group）子表达式（subexpression）匹配。<br/>其中<code>num</code>是从1开始的十进制正整数，其上限可能是9[<a href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F#cite_note-3">注 2]</a>、31[<a href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F#cite_note-4">注 3]</a>、99甚至无限[<a href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F#cite_note-5">注 4]</a>。<br/>例如：“<code>(.)\1</code>”匹配两个连续的相同字符。</td></tr><tr><td align="left"><code>\n</code></td><td align="left">标识一个八进制转义值或一个向后引用。<br/>如果<code>\n</code>之前至少<code>n</code>个获取的子表达式，则<code>n</code>为向后引用。<br/>否则，如果<code>n</code>为八进制数字（0-7），则<code>n</code>为一个八进制转义值。</td></tr><tr><td align="left"><code>\nm</code></td><td align="left">3位八进制数字，标识一个八进制转义值或一个向后引用。<br/>如果<code>\nm</code>之前至少有<code>nm</code>个获得子表达式，则<em>nm</em>为向后引用。<br/>如果<code>\nm</code>之前至少有<code>n</code>个获取，则<em>n</em>为一个后跟文字<em>m</em>的向后引用。<br/>如果前面的条件都不满足，若<code>n</code>和<code>m</code>均为八进制数字（0-7），则<code>\nm</code>将匹配八进制转义值<em>nm</em>。</td></tr><tr><td align="left"><code>\nml</code></td><td align="left">如果<code>n</code>为八进制数字（0-3），且<code>m</code>和<code>l</code>均为八进制数字（0-7），则匹配八进制转义值<code>nml</code>。</td></tr><tr><td align="left"><code>\un</code></td><td align="left">Unicode转义字符序列。其中<code>n</code>是一个用四个十六进制数字表示的Unicode字符。<br/>例如，<code>\u00A9</code>匹配著作权符号（©）。</td></tr></tbody></table><h2 id="非打印字符匹配"><a href="#非打印字符匹配" class="headerlink" title="非打印字符匹配"></a>非打印字符匹配</h2><p>非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列：</p><table><thead><tr><th align="left">字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>\cx</code></td><td align="left">匹配由x指明的控制字符。<br/>例如， <code>\cM</code> 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td></tr><tr><td align="left"><code>\f</code></td><td align="left">匹配一个换页符。等价于 \x0c 和 \cL。</td></tr><tr><td align="left"><code>\n</code></td><td align="left">匹配一个换行符。等价于 \x0a 和 \cJ。</td></tr><tr><td align="left"><code>\r</code></td><td align="left">匹配一个回车符。等价于 \x0d 和 \cM。</td></tr><tr><td align="left"><code>\s</code></td><td align="left">匹配任何空白字符，包括空格、制表符、换页符等等。<br/>等价于<code> [\f\n\r\t\v]</code>。注意 Unicode 正则表达式会匹配全角空格符。</td></tr><tr><td align="left"><code>\S</code></td><td align="left">匹配任何非空白字符。等价于 <code>[^ \f\n\r\t\v]</code>。</td></tr><tr><td align="left"><code>\t</code></td><td align="left">匹配一个制表符。等价于 \x09 和 \cI。</td></tr><tr><td align="left"><code>\v</code></td><td align="left">匹配一个垂直制表符。等价于 \x0b 和 \cK。</td></tr><tr><td align="left"><code>\W</code></td><td align="left">匹配任何非单词字符。等价于“<code>[^A-Za-z0-9_]</code>”。</td></tr></tbody></table><h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><table><thead><tr><th align="left">特别字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>\</code></td><td align="left">将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。<br>例如， ‘n’ 匹配字符 ‘n’。’\n’ 匹配换行符。序列 <code>&#39;\\&#39;</code> 匹配 <code>&quot;\&quot;</code></td></tr><tr><td align="left"><code>^</code></td><td align="left">匹配输入字符串的开始位置，<br>当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。<br>要匹配 ^ 字符本身，请使用 <code>\^</code>。</td></tr><tr><td align="left"><code>$</code></td><td align="left">匹配输入字符串的结尾位置。<br>如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\n’ 或 ‘\r’。要匹配 $ 字符本身，请使用<code> \$</code>。</td></tr><tr><td align="left"><code>( )</code></td><td align="left">标记一个子表达式的开始和结束位置。<br>子表达式可以获取供以后使用。要匹配这些字符，请使用<code>\(</code>和<code> \)</code>。</td></tr><tr><td align="left"><code>*</code></td><td align="left">匹配前面的子表达式零次或多次。要匹配 <code>* </code>字符，请使用<code> \*</code>。</td></tr><tr><td align="left"><code>+</code></td><td align="left">匹配前面的子表达式一次或多次。要匹配 <code>+</code> 字符，请使用 <code>\+</code>。</td></tr><tr><td align="left"><code>?</code></td><td align="left">匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 ?。</td></tr><tr><td align="left"><code>.</code></td><td align="left">匹配除换行符 <code>\n</code> 之外的任何单字符。要匹配<code> .</code> ，请使用 <code>\.</code> 。</td></tr><tr><td align="left"><code>[</code></td><td align="left">标记一个中括号表达式的开始。要匹配 <code>[</code>，请使用 <code>\[</code>。</td></tr><tr><td align="left"><code>&#123;</code></td><td align="left">标记限定符表达式的开始。要匹配<code> &#123;</code>，请使用<code> \&#123;</code>。</td></tr><tr><td align="left">&#96;</td><td align="left">&#96;</td></tr></tbody></table><h2 id="限定符-表达式匹配次数"><a href="#限定符-表达式匹配次数" class="headerlink" title="限定符(表达式匹配次数)"></a>限定符(表达式匹配次数)</h2><p>限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。</p><p>请注意，限定符出现在范围表达式之后。</p><table><thead><tr><th align="left">字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>*</code></td><td align="left">匹配前面的子表达式零次或多次。<br/>例如，<strong>zo*</strong> 能匹配 <strong>“z”</strong> 以及 <strong>“zoo”<strong>。</strong></strong>* 等价于 **{0,}**。</td></tr><tr><td align="left"><code>+</code></td><td align="left">匹配前面的子表达式一次或多次。<br/>例如，<strong>zo+</strong> 能匹配 <strong>“zo”</strong> 以及 “**zoo”**，但不能匹配 <strong>“z”<strong>。</strong>+</strong> 等价于 **{1,}**。</td></tr><tr><td align="left"><code>? </code></td><td align="left">匹配前面的子表达式零次或一次。<br>例如，<strong>do(es)?</strong> 可以匹配 <strong>“do”</strong> 、 <strong>“does”<strong>、 <strong>“doxy”</strong> 中的 <strong>“do”</strong> 。</strong>?</strong> 等价于 **{0,1}**。</td></tr><tr><td align="left"><code>&#123;n&#125;</code></td><td align="left">n 是一个非负整数。匹配确定的 <strong>n</strong> 次。<br/>例如，<strong>o{2}</strong> 不能匹配 <strong>“Bob”</strong> 中的 <strong>o</strong>，但是能匹配 <strong>“food”</strong> 中的两个 <strong>o</strong>。</td></tr><tr><td align="left"><code>&#123;n,&#125; </code></td><td align="left">n 是一个非负整数。至少匹配n 次。<br/>例如，<strong>o{2,}</strong> 不能匹配 <strong>“Bob”</strong> 中的 <strong>o</strong>，但能匹配 <strong>“foooood”</strong> 中的所有 <strong>o</strong>。<strong>o{1,}</strong> 等价于 <strong>o+<strong>。</strong>o{0,}</strong> 则等价于 **o***。</td></tr><tr><td align="left"><code>&#123;n,m&#125;</code></td><td align="left">m 和 n 均为非负整数，其中 n &lt;&#x3D; m。最少匹配 n 次且最多匹配 m 次。<br/>例如，<strong>o{1,3}</strong> 将匹配 <strong>“fooooood”</strong> 中的前三个 <strong>o</strong>。<strong>o{0,1}</strong> 等价于 **o?**。<br/>请注意在逗号和两个数之间不能有空格。</td></tr></tbody></table><h2 id="定位符-确定-固定位置"><a href="#定位符-确定-固定位置" class="headerlink" title="定位符(确定 固定位置)"></a>定位符(确定 固定位置)</h2><p>定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。</p><table><thead><tr><th align="left">字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>^</code></td><td align="left">匹配输入字符串<strong>开始</strong>的位置。<br>如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。</td></tr><tr><td align="left"><code>$</code></td><td align="left">匹配输入字符串<strong>结尾</strong>的位置。<br/>如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。</td></tr><tr><td align="left"><code>\b</code></td><td align="left">匹配一个<strong>单词边界</strong>，即字与空格间的位置。</td></tr><tr><td align="left"><code>\B</code></td><td align="left">非单词边界匹配。</td></tr></tbody></table><h2 id="选择-捕获-保存"><a href="#选择-捕获-保存" class="headerlink" title="选择(捕获 保存)"></a>选择(捕获 保存)</h2><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td><code>(pattern)</code></td><td>匹配pattern并获取这一匹配的子字符串。该子字符串用于向后引用。</td></tr></tbody></table><ul><li><p><strong>()</strong> 表示捕获分组，**()** 会把每个分组里的匹配的值保存起来， 多个匹配值可以通过数字 n 来查看(<strong>n</strong> 是一个数字，表示第 n 个捕获组的内容)。</p></li><li><p>缓冲区编号从 1 开始。</p></li><li><p>每个缓冲区都可以使用 <strong><code>$n</code></strong> 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。例如 <code>$1</code>,<code>$2</code> 等等</p><ul><li>需要注意的是菜鸟教程里面写这里是用<code>/n</code>匹配, 在notepad++里面这个没问题, 但是VSCode并不能识别这个</li></ul></li><li><p>可以使用非捕获元字符 <code> ?:</code> 、<code>?=</code> 或 <code>?!</code> 来重写捕获，忽略对相关匹配的保存。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 原始串</span><br>https://en.wikipedia.org/wiki/Regular_expression<br>$ (\w+)://(.+?)/(.+)<br>$  <span class="hljs-variable">$1</span> \n <span class="hljs-variable">$2</span> \n <span class="hljs-variable">$3</span><br><span class="hljs-comment"># 替换后</span><br> https <br> en.wikipedia.org <br> wiki/Regular_expression<br></code></pre></td></tr></table></figure><h3 id="非捕获元"><a href="#非捕获元" class="headerlink" title="非捕获元 ?: ?= ?&lt;= ?! ?&lt;!"></a>非捕获元 <code>?: ?= ?&lt;= ?! ?&lt;!</code></h3><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td><code>(pattern)</code></td><td>匹配pattern并获取这一匹配的子字符串。该子字符串用于向后引用。</td></tr><tr><td></td><td></td></tr><tr><td><code>(?:pattern)</code></td><td>匹配pattern<strong>但不获取</strong>匹配的子字符串(shy groups)<br>也就是说这是一个非获取匹配，不存储匹配的子字符串用于向后引用。<br>这在使用或字符“&#96;(</td></tr><tr><td></td><td></td></tr><tr><td><code>(?=pattern)</code></td><td><strong>正向肯定预查</strong>（look ahead positive assert），在任何<strong>匹配</strong>pattern的字符串开始处匹配查找字符串。<br>这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。<br/>例如，“&#96;Windows(?&#x3D;95</td></tr><tr><td><code>(?!pattern)</code></td><td><strong>正向否定预查</strong>（negative assert），在任何<strong>不匹配</strong>pattern的字符串开始处匹配查找字符串。<br/>这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。<br/>例如“&#96;Windows(?!95</td></tr><tr><td></td><td></td></tr><tr><td><code>(?&lt;=pattern)</code></td><td><strong>反向肯定预查</strong>（look behind positive assert），与正向肯定预查类似，只是方向相反。<br/>例如，“&#96;(?&lt;&#x3D;95</td></tr><tr><td><code>(?&lt;!pattern)</code></td><td><strong>反向否定预查</strong>，与正向否定预查类似，只是方向相反。<br/>例如“&#96;(?&lt;!95</td></tr></tbody></table><h1 id="正则表达式-修饰符"><a href="#正则表达式-修饰符" class="headerlink" title="正则表达式 - 修饰符"></a>正则表达式 - 修饰符</h1><p>标记也称为修饰符，正则表达式的标记用于指定额外的匹配策略。</p><p>标记不写在正则表达式里，标记位于表达式之外，格式如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/pattern/</span>flags<br></code></pre></td></tr></table></figure><p>下表列出了正则表达式常用的修饰符：</p><table><thead><tr><th align="left">修饰符</th><th align="left">含义</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>i</code></td><td align="left">ignore - 不区分大小写</td><td align="left">将匹配设置为不区分大小写，搜索时不区分大小写: A 和 a 没有区别。</td></tr><tr><td align="left"><code>g</code></td><td align="left">global - 全局匹配</td><td align="left">查找所有的匹配项。</td></tr><tr><td align="left"><code>m</code></td><td align="left">multi line - 多行匹配</td><td align="left">使边界字符 <strong>^</strong> 和 <strong>$</strong> 匹配每一行的开头和结尾，记住是多行，而不是整个字符串的开头和结尾。</td></tr><tr><td align="left"><code>s</code></td><td align="left">特殊字符圆点 <strong>.</strong> 中包含换行符 <strong>\n</strong></td><td align="left">默认情况下的圆点 <strong>.</strong> 是匹配除换行符 <strong>\n</strong> 之外的任何字符，加上 <strong>s</strong> 修饰符之后, <strong>.</strong> 中包含换行符 \n。</td></tr></tbody></table><h1 id="正则表达式-优先级"><a href="#正则表达式-优先级" class="headerlink" title="正则表达式 - 优先级"></a>正则表达式 - 优先级</h1><table><thead><tr><th align="center">优先权</th><th align="center">符号</th></tr></thead><tbody><tr><td align="center">最高</td><td align="center"><code>\</code></td></tr><tr><td align="center">高</td><td align="center"><code>()</code>、<code>(?:)</code>、<code>(?=)</code>、<code>[]</code></td></tr><tr><td align="center">中</td><td align="center"><code>*</code>、<code>+</code>、<code>?</code>、<code>&#123;n&#125;</code>、<code>&#123;n,&#125;</code>、<code>&#123;n,m&#125;</code></td></tr><tr><td align="center">低</td><td align="center"><code>^</code>、<code>$</code>、中介字符</td></tr><tr><td align="center">次最低</td><td align="center">串接，即相邻字符连接在一起</td></tr><tr><td align="center">最低</td><td align="center">&#96;</td></tr></tbody></table><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><h2 id="贪婪匹配-非贪婪匹配"><a href="#贪婪匹配-非贪婪匹配" class="headerlink" title="贪婪匹配( ) 非贪婪匹配(?)"></a>贪婪匹配( ) 非贪婪匹配(?)</h2><p><strong>贪婪：</strong>下面的表达式匹配从开始小于符号 (&lt;) 到关闭 h1 标记的大于符号 (&gt;) 之间的所有内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 原字符串</span><br>&lt;h1&gt;贪婪匹配 非贪婪匹配&lt;/h1&gt;<br><span class="hljs-comment"># 贪婪匹配</span><br>$ &lt;.*&gt;<br><span class="hljs-comment"># 匹配到的字符串</span><br>&lt;h1&gt;贪婪匹配 非贪婪匹配&lt;/h1&gt;<br></code></pre></td></tr></table></figure><p><strong>非贪婪：</strong>如果您只需要匹配开始和结束 <code>h1 </code>标签，下面的非贪婪表达式只匹配<code> &lt;h1&gt;</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 原字符串</span><br>&lt;h1&gt;贪婪匹配 非贪婪匹配&lt;/h1&gt;<br><span class="hljs-comment"># 非贪婪匹配</span><br>$ &lt;.*?&gt;<br><span class="hljs-comment"># 匹配到的字符串</span><br>&lt;h1&gt;<br></code></pre></td></tr></table></figure><p>通过在 *<strong><strong>、</strong>+</strong> 或 <strong>?</strong> 限定符之后放置 **?**，该表达式从”贪婪”表达式转换为”非贪婪”表达式或者最小匹配。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">正则表达式 Wiki</a></p><p><a href="https://www.runoob.com/regexp/regexp-syntax.html">正则表达式 菜鸟教程</a></p><h1 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h1><h2 id="常用正则表达式匹配"><a href="#常用正则表达式匹配" class="headerlink" title="常用正则表达式匹配"></a>常用正则表达式匹配</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#用户名</span><br>/^[a-z0-9_-]&#123;3,16&#125;$/<br><span class="hljs-comment">#密码</span><br>/^[a-z0-9_-]&#123;6,18&#125;$/<br><span class="hljs-comment">#十六进制值颜色 #ff02ff etc.</span><br>/^#?([a-f0-9]&#123;6&#125;|[a-f0-9]&#123;3&#125;)$/<br><span class="hljs-comment">#电子邮箱</span><br>/^([a-z0-9_\.-]+)@([\da-z\.-]+)\.([a-z\.]&#123;2,6&#125;)$/<br>/^[a-z\d]+(\.[a-z\d]+)*@([\da-z](-[\da-z])?)+(\.&#123;1,2&#125;[a-z]+)+$/<br><span class="hljs-comment">#URL</span><br>/^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]&#123;2,6&#125;)([\/\w \.-]*)*\/?$/<br><span class="hljs-comment">#IP 地址</span><br>/((<span class="hljs-number">2</span>[<span class="hljs-number">0</span>-<span class="hljs-number">4</span>]\d|<span class="hljs-number">25</span>[<span class="hljs-number">0</span>-<span class="hljs-number">5</span>]|[<span class="hljs-number">01</span>]?\d\d?)\.)&#123;<span class="hljs-number">3</span>&#125;(<span class="hljs-number">2</span>[<span class="hljs-number">0</span>-<span class="hljs-number">4</span>]\d|<span class="hljs-number">25</span>[<span class="hljs-number">0</span>-<span class="hljs-number">5</span>]|[<span class="hljs-number">01</span>]?\d\d?)/<br>/^(?:(?:<span class="hljs-number">25</span>[<span class="hljs-number">0</span>-<span class="hljs-number">5</span>]|<span class="hljs-number">2</span>[<span class="hljs-number">0</span>-<span class="hljs-number">4</span>][<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]|[<span class="hljs-number">01</span>]?[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>][<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]?)\.)&#123;<span class="hljs-number">3</span>&#125;(?:<span class="hljs-number">25</span>[<span class="hljs-number">0</span>-<span class="hljs-number">5</span>]|<span class="hljs-number">2</span>[<span class="hljs-number">0</span>-<span class="hljs-number">4</span>][<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]|[<span class="hljs-number">01</span>]?[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>][<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]?)$/<br>#HTML 标签<br>/^&lt;([a-z]+)([^&lt;]+)*(?:&gt;(.*)&lt;\/\<span class="hljs-number">1</span>&gt;|\s+\/&gt;)$/<br>#删除代码\\注释<br>(?&lt;!http:|\S)//.*$<br>#Unicode编码中的汉字范围<br>/^[\u2E80-\u9FFF]+$/<br></code></pre></td></tr></table></figure><h2 id="正则表达式替换"><a href="#正则表达式替换" class="headerlink" title="正则表达式替换"></a>正则表达式替换</h2><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs inform7">原始串 <br>str<span class="hljs-comment">[1]</span>abc<span class="hljs-comment">[991]</span>; <br>str<span class="hljs-comment">[2]</span>abc<span class="hljs-comment">[992]</span>; <br>str<span class="hljs-comment">[11]</span>abc<span class="hljs-comment">[993]</span>; <br>str<span class="hljs-comment">[22]</span>abc<span class="hljs-comment">[994]</span>; <br>str<span class="hljs-comment">[111]</span>abc<span class="hljs-comment">[995]</span>; <br>str<span class="hljs-comment">[222]</span>abc<span class="hljs-comment">[996]</span>; <br>str<span class="hljs-comment">[1111]</span>abc<span class="hljs-comment">[997]</span>; <br>str<span class="hljs-comment">[2222]</span>abc<span class="hljs-comment">[999]</span>; <br><br>目标串： <br>abc<span class="hljs-comment">[1]</span>; <br>abc<span class="hljs-comment">[2]</span>; <br>abc<span class="hljs-comment">[11]</span>; <br>abc<span class="hljs-comment">[22]</span>; <br>abc<span class="hljs-comment">[111]</span>; <br>abc<span class="hljs-comment">[222]</span>; <br>abc<span class="hljs-comment">[1111]</span>; <br>abc<span class="hljs-comment">[2222]</span>; <br><br>处理： <br>查找串：str/<span class="hljs-comment">[(<span class="hljs-comment">[0-9]</span>+)/]</span>abc/<span class="hljs-comment">[<span class="hljs-comment">[0-9]</span>+/]</span> <br>替换串：abc<span class="hljs-comment">[/1]</span> <br></code></pre></td></tr></table></figure><h2 id="正则表达式示例"><a href="#正则表达式示例" class="headerlink" title="正则表达式示例"></a>正则表达式示例</h2><p>下面列出一些正则表达式示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br><span class="hljs-comment"># 一个单词连续出现的位置。</span><br>/\b([a-z]+) \1\b/gi<br><span class="hljs-comment"># 匹配一个 URL 解析为协议、域、端口及相对路径。</span><br>/(\w+):\/\/([^/:]+)(:\d*)?([^# ]*)/<br><span class="hljs-comment"># 定位章节的位置。</span><br>/^(?:Chapter|Section) [1-9][0-9]&#123;0,1&#125;$/<br><span class="hljs-comment"># a 至 z 共 26个 字母再加一个 - 号。</span><br>/[-a-z]/<br><span class="hljs-comment"># 可匹配 chapter，而不能匹配 terminal。</span><br>/ter\b/<br><span class="hljs-comment"># 可匹配 chapter，而不能匹配 aptitude。</span><br>/\Bapt/<br><span class="hljs-comment"># 可匹配 Windows95 或 Windows98 或 WindowsNT，当找到一个匹配后，从 Windows 后面开始进行下一次的检索匹配。</span><br>/Windows(?=95 |98 |NT )/<br><span class="hljs-comment"># 匹配空行。</span><br>/^\s*$/<br><span class="hljs-comment"># 验证由两位数字、一个连字符再加 5 位数字组成的 ID 号。</span><br>/\d&#123;2&#125;-\d&#123;5&#125;/<br><span class="hljs-comment"># 匹配 HTML 标签</span><br>&lt;[a-zA-Z]+.*?&gt;([\s\S]*?)&lt;/[a-zA-Z]*?&gt;<br><br><span class="hljs-comment"># 匹配 &#123;hello&#125;</span><br>hello<br><span class="hljs-comment"># 匹配 &#123;gray, grey&#125;</span><br>gray|grey<br><span class="hljs-comment"># 匹配 &#123;gray, grey&#125;</span><br>gr(a|e)y<br><span class="hljs-comment">#  匹配 &#123;gray, grey&#125;</span><br>gr[ae]y<br><span class="hljs-comment">#  匹配 &#123;babble, bebble, bibble, bobble, bubble&#125;</span><br>b[aeiou]bble<br><span class="hljs-comment">#  匹配 &#123;bat, cat, hat, mat, nat, oat, pat, Pat, ot&#125;</span><br>[b-chm-pP]at|ot<br><span class="hljs-comment">#  匹配 &#123;color, colour&#125;</span><br>colou?r<br><span class="hljs-comment">#  匹配 &#123;regex, regexes, regexp, regexps&#125;</span><br>rege(x(es)?|xps?)<br><span class="hljs-comment">#  匹配 &#123;ggle, gogle, google, gooogle, goooogle, ...&#125;</span><br>go*gle<br><span class="hljs-comment">#  匹配 &#123;gogle, google, gooogle, goooogle, ...&#125;</span><br>go+gle<br><span class="hljs-comment">#  匹配 &#123;google, googoogle, googoogoogle, googoogoogoogle, ...&#125;</span><br>g(oog)+le<br><span class="hljs-comment">#  匹配 &#123;zzz&#125;</span><br>z&#123;3&#125;<br><span class="hljs-comment">#  匹配 &#123;zzz, zzzz, zzzzz, zzzzzz&#125;</span><br>z&#123;3,6&#125;<br><span class="hljs-comment">#  匹配 &#123;zzz, zzzz, zzzzz, ...&#125;</span><br>z&#123;3,&#125;<br><span class="hljs-comment">#  匹配 &#123;Brainf**k, brainf**k&#125;</span><br>[Bb]rainf\*\*k<br><span class="hljs-comment">#  匹配 &#123;0,1,2,3,4,5,6,7,8,9&#125;</span><br>\d<br><span class="hljs-comment">#  匹配 11 个数字，以 1 开头</span><br>1\d&#123;10&#125;<br><span class="hljs-comment">#  匹配 2 到 36 范围内的整数</span><br>[2-9]|[12]\d|3[0-6]<br><span class="hljs-comment">#  匹配 Hello 后跟换行符，后跟 world</span><br>Hello\nworld<br><span class="hljs-comment"># 包含一个正整数或包含两位小数位的浮点数。</span><br>\d+(\.\d\d)?<br><span class="hljs-comment"># 排除 *、@ 、# 三个特色符号</span><br>[^*@#]<br><span class="hljs-comment">#  匹配 // 开头的注释</span><br>//[^\r\n]*[\r\n]<br><span class="hljs-comment">#  匹配以 &quot;dog&quot; 开始</span><br>^dog<br><span class="hljs-comment">#  匹配以 &quot;dog&quot; 结尾</span><br>dog$<br><span class="hljs-comment"># is exactly &quot;dog&quot;</span><br>^dog$<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>正则表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决 Chrome由贵单位管理 惠普 谷歌浏览器 HP</title>
    <link href="/2021/320cfc33/"/>
    <url>/2021/320cfc33/</url>
    
    <content type="html"><![CDATA[<p>关键词:<br>Chrome由贵单位管理 惠普 HP 谷歌浏览器 浏览器由所属组织管理</p><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>惠普 HP ProBook 450 G8 Notebook PC<br>WIndows10 19042.1415<br>谷歌浏览器 版本 96.0.4664.45（正式版本） （64 位）</p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ol><li>网上说了很多删除注册表的答案,删除完了只是临时解决,重启后问题依旧,注册表被恢复<br> <code>\HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Google\Chrome</code></li><li>思路是找出谁访问修改了这一段注册表, 然后找到了 Process Monitor 软件, 发现注册表的修改是在开机的时候被修改的, 这个软件我也还不太会用, 不知道怎么样才能让他捕获到开机的修改, 随搜索相关文章, 最后发现居然是惠普的锅,简直离了个大谱.</li><li>把这个服务关掉, 就可以解决问题, 我当时把它文件也删掉了!<br><img src="/2021/320cfc33/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Li05rW355qE5Z-O,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"></li><li>批处理方案<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs dos">@<span class="hljs-built_in">echo</span> off<br><span class="hljs-comment">rem Automates instructions from google found here https://support.google.com/chrome/a/answer/9844476?hl=en</span><br><span class="hljs-comment">rem Removes the &#x27;Managed by your organization&#x27; from Google Chrome and prevents persistence</span><br><span class="hljs-built_in">echo</span> Make sure you have backed up your registry. Ready to go ahead?<br><span class="hljs-built_in">pause</span><br><span class="hljs-built_in">cls</span><br><span class="hljs-built_in">echo</span> Working...<br><span class="hljs-built_in">echo</span> Exiting Chrome (<span class="hljs-keyword">if</span> running)<br><span class="hljs-built_in">taskkill</span> /f /im chrome.exe<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">exist</span> &quot;C:\Program Files (x86)\Google\Policies&quot; <span class="hljs-built_in">RMDIR</span> /S /Q &quot;C:\Program Files (x86)\Google\Policies&quot;<br>reg delete HKEY_CURRENT_USER\SOFTWARE\Google\Chrome /f /va <br>reg delete HKEY_LOCAL_MACHINE\SOFTWARE\Google\Chrome /f /va <br>reg delete HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Google\Chrome /f /va <br>reg delete HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Google\Update\ClientState\&#123;<span class="hljs-number">430</span>FD4D0-B729-<span class="hljs-number">4</span>F61-AA34-<span class="hljs-number">91526481799</span>D&#125; /f /va <br>reg delete HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Google\Chrome\ExtensionInstallForcelist /f<br><span class="hljs-built_in">echo</span> Stopping and Disabling Sound Research Service<br>sc stop SECOMNService<br>sc config SECOMNService <span class="hljs-built_in">start</span>= disabled<br><span class="hljs-built_in">echo</span> Complete!<br><span class="hljs-built_in">pause</span><br></code></pre></td></tr></table></figure></li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://cihansol.com/blog/index.php/2021/07/17/uncovering-hps-potentially-unwanted-applications">Uncovering HP’s Potentially Unwanted Applications(主要参考)</a><br><a href="https://support.google.com/chrome/a/answer/9844476?hl=en#zippy=,windows">Stop managing Chrome browser</a><br><a href="https://meta.appinn.net/t/topic/26165">https://meta.appinn.net/t/topic/26165</a></p><h1 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h1><p><del>吐槽CSDN的Markdown好难用啊,为什么一删除换行把前面的也删除了? 写个github还被审核未通过? 是时候考虑一些别的方案了</del> </p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hp</tag>
      
      <tag>chrome</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VSCode多行编辑被占用</title>
    <link href="/2021/9f39ed86/"/>
    <url>/2021/9f39ed86/</url>
    
    <content type="html"><![CDATA[<p>关键词:</p><p>查看 Windows 10 快捷键 占用 VSCode 多行编辑 ctrl alt uparrow</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>VSCode 的多行编辑 ctrl + alt +uparrow 失效.<br>电脑环境:win10 19042.1387</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol><li><p>检查VSCode的快捷键设置,<img src="https://img-blog.csdnimg.cn/c85c8402840543d4a4b7afcf26e04bc0.png" alt="VSCode1"><br>看起来是没有问题的,</p></li><li><p>以前也遇到过这个情况当时是把VSCode重装后就好了看,这次试了试似乎并不行.</p></li><li><p>检查是不是其他软件占用了全局快捷键,搜索发现很多相关软件都失效不能用.</p><ul><li>PChunter <strong>很久没更新了不支持我的电脑的当前版本</strong></li><li>FindGlobalHotkey  <strong>无效</strong></li><li>spy++ <strong>太复杂,可能我不太会用也是没找到是不是什么按键占用了</strong></li><li><a href="https://www.zhihu.com/question/288316686/answer/1656650885">win10怎么查看快捷键是被什么占用了？</a></li><li><a href="https://github.com/BlackINT3/OpenArk">OpenArk </a> <strong>(最终解决方案)</strong></li></ul></li><li><p>github下载OpenArk后打开就能看到快捷键占用, 输入对应快捷键就可以筛选,<br><strong>最终找到万恶之源, 电脑插着耳机没有发现在播歌, 网易云关掉全局快捷键, 问题消失</strong><br><img src="/2021/9f39ed86/9b96c314b5994739a4db98c7d00c834b.png" alt="VSCode2"></p></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/BlackINT3/OpenArk">https://github.com/BlackINT3/OpenArk</a><br><img src="/2021/9f39ed86/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Li05rW355qE5Z-O,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="VSCode3"></p><h1 id="其他冲突的快捷键"><a href="#其他冲突的快捷键" class="headerlink" title="其他冲突的快捷键"></a>其他冲突的快捷键</h1><p>ctrl + shift + f 和微软的拼音输入法有冲突</p>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>vscode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WSL</title>
    <link href="/2021/784ee20b/"/>
    <url>/2021/784ee20b/</url>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>若要检查 Windows 版本及内部版本号，选择 Windows 徽标键 + R，然后键入“winver”，选择“确定”。更新到“设置”菜单中的<a href="ms-settings:windowsupdate">最新 Windows 版本</a>。</p><p><em><strong>IF</strong></em> (Windows 10 版本 2004 及更高版本（内部版本 19041 及更高版本）或 Windows 11)</p><p><a href="https://docs.microsoft.com/zh-cn/windows/wsl/install">一键自动安装 WSL</a></p><p><em><strong>ELSE</strong></em></p><p><a href="https://docs.microsoft.com/zh-cn/windows/wsl/install-manual">旧版 WSL 的手动安装步骤(可以更改WSL系统的存放位置)</a></p><h2 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h2><blockquote><p>   手动安装的优点是避免Linux的镜像文件(<code>ext4.vhdx</code>)存放在C盘, 存放<code>ext4.vhdx</code>的位置可以自定义.</p></blockquote><p>以下指令需要在<strong>管理员</strong>下的 powershell 运行</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment"># 1 开启Microsoft-Windows-Subsystem-Linux</span><br>dism.exe <span class="hljs-string">/online</span> <span class="hljs-string">/enable-feature</span> <span class="hljs-string">/featurename</span><span class="hljs-function">:Microsoft-Windows-Subsystem-Linux</span> <span class="hljs-string">/all</span> <span class="hljs-string">/norestart</span><br><br><span class="hljs-comment"># 2 开启VirtualMachinePlatform</span><br>dism.exe <span class="hljs-string">/online</span> <span class="hljs-string">/enable-feature</span> <span class="hljs-string">/featurename</span><span class="hljs-function">:VirtualMachinePlatform</span> <span class="hljs-string">/all</span> <span class="hljs-string">/norestart</span><br><br><span class="hljs-comment"># 3 重启</span><br><span class="hljs-comment"># reboot</span><br><br><span class="hljs-comment"># 4 安装WLS2内核更新包</span><br>https:<span class="hljs-string">//wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi</span><br><br><span class="hljs-comment"># 5 将WSL2设为默认</span><br>wsl <span class="hljs-params">--set-default-version</span> 2<br><br><span class="hljs-comment"># 6 下载离线包(可以避免将WSL的系统装在C盘)</span><br>https:<span class="hljs-string">//docs.microsoft.com/zh-cn/windows/wsl/install-manual</span><br><span class="hljs-comment"># example</span><br>https:<span class="hljs-string">//aka.ms/wslubuntu2004</span><br>https:<span class="hljs-string">//aka.ms/wsl-ubuntu-1804</span><br>https:<span class="hljs-string">//aka.ms/wsl-debian-gnulinux</span><br><span class="hljs-comment"># 离线包下载完成后解压缩 运行目录内的ubuntu.exe</span><br><span class="hljs-comment"># 会提示输入用户名和密码</span><br><br><span class="hljs-comment"># 7 (可选)安装 windows终端</span><br>https:<span class="hljs-string">//docs.microsoft.com/en-us/windows/terminal/get-started</span> 可选 <br></code></pre></td></tr></table></figure><h2 id="卸载-禁用"><a href="#卸载-禁用" class="headerlink" title="卸载 &amp; 禁用"></a>卸载 &amp; 禁用</h2><ol><li><p>在控制面板中禁用 Hyper-V</p><ol><li>在“控制面板”中，打开“程序和功能”。</li><li>选择“启用或关闭 Windows 功能”。</li><li>展开 <strong>Hyper-V</strong>，展开 <strong>Hyper-V 平台</strong>，然后清除“Hyper-V 虚拟机监控程序”复选框。</li></ol></li><li><p>在 PowerShell 中禁用 Hyper-V</p><ol><li><p>打开提升权限的 PowerShell 窗口。</p></li><li><p>运行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Disable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V-Hypervisor<br></code></pre></td></tr></table></figure></li></ol></li></ol><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><h2 id="U盘挂载"><a href="#U盘挂载" class="headerlink" title="U盘挂载"></a>U盘挂载</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1 新建文件夹g</span><br>sudo mkdir /mnt/g<br><span class="hljs-meta prompt_"># </span><span class="language-bash">2 挂载盘符g</span><br>sudo mount -t drvfs g: /mnt/g<br><span class="hljs-meta prompt_"># </span><span class="language-bash">大功告成。进入/mnt/g即可操作</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">弹出移动硬盘，这样才能在windows下正常弹出，否则是会一直占用的。</span><br>sudo umount /mnt/g<br></code></pre></td></tr></table></figure><h2 id="映射wsl文件系统"><a href="#映射wsl文件系统" class="headerlink" title="映射wsl文件系统"></a>映射wsl文件系统</h2><p><img src="/2021/784ee20b/image-20211129131237501.png" alt="image-20211129131237501"></p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">\\wsl<span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure><p>通过 <code>\\wsl$</code> 访问 Linux 文件时将使用 WSL 分发版的默认用户。 因此，任何访问 Linux 文件的 Windows 应用都具有与默认用户相同的权限。</p><h2 id="wsl关机"><a href="#wsl关机" class="headerlink" title="wsl关机"></a>wsl关机</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wsl --shutdown<br></code></pre></td></tr></table></figure><h2 id="wsl-配置文件"><a href="#wsl-配置文件" class="headerlink" title="wsl 配置文件"></a>wsl 配置文件</h2><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># Settings apply across all Linux distros running on WSL 2</span><br><span class="hljs-section">[wsl2]</span><br><br><span class="hljs-comment"># Limits VM memory to use no more than 4 GB, this can be set as whole numbers using GB or MB</span><br><span class="hljs-attr">memory</span>=<span class="hljs-number">4</span>GB <br><br><span class="hljs-comment"># Sets the VM to use two virtual processors</span><br><span class="hljs-attr">processors</span>=<span class="hljs-number">2</span><br><br><span class="hljs-comment"># Specify a custom Linux kernel to use with your installed distros. The default kernel used can be found at https://github.com/microsoft/WSL2-Linux-Kernel</span><br><span class="hljs-attr">kernel</span>=C:\\temp\\myCustomKernel<br><br><span class="hljs-comment"># Sets additional kernel parameters, in this case enabling older Linux base images such as Centos 6</span><br><span class="hljs-attr">kernelCommandLine</span> = vsyscall=emulate<br><br><span class="hljs-comment"># Sets amount of swap storage space to 8GB, default is 25% of available RAM</span><br><span class="hljs-comment"># 虚拟内存</span><br><span class="hljs-attr">swap</span>=<span class="hljs-number">8</span>GB<br><br><span class="hljs-comment"># Sets swapfile path location, default is %USERPROFILE%\AppData\Local\Temp\swap.vhdx</span><br><span class="hljs-attr">swapfile</span>=C:\\temp\\wsl-swap.vhdx<br><br><span class="hljs-comment"># Disable page reporting so WSL retains all allocated memory claimed from Windows and releases none back when free</span><br><span class="hljs-attr">pageReporting</span>=<span class="hljs-literal">false</span><br><br><span class="hljs-comment"># Turn off default connection to bind WSL 2 localhost to Windows localhost</span><br><span class="hljs-attr">localhostforwarding</span>=<span class="hljs-literal">true</span><br><br><span class="hljs-comment"># Disables nested virtualization</span><br><span class="hljs-attr">nestedVirtualization</span>=<span class="hljs-literal">false</span><br><br><span class="hljs-comment"># Turns on output console showing contents of dmesg when opening a WSL 2 distro for debugging</span><br><span class="hljs-attr">debugConsole</span>=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>打开powershell输入<code>~</code>切换目录</p><p><code>code .wslconfig</code>编辑配置</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[wsl2]</span><br><span class="hljs-attr">memory</span>=<span class="hljs-number">2</span>GB<br><span class="hljs-attr">swap</span>=<span class="hljs-number">2</span>GB<br><span class="hljs-attr">localhostForwarding</span>=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h2 id="WSL-配置代理"><a href="#WSL-配置代理" class="headerlink" title="WSL 配置代理"></a>WSL 配置代理</h2><p><strong>获取主机 IP      主机 IP 保存在 &#x2F;etc&#x2F;resolv.conf 中</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> hostip=$(<span class="hljs-built_in">cat</span> /etc/resolv.conf |grep -oP <span class="hljs-string">&#x27;(?&lt;=nameserver\ ).*&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> https_proxy=<span class="hljs-string">&quot;http://<span class="hljs-variable">$&#123;hostip&#125;</span>:10881&quot;</span><br><span class="hljs-built_in">export</span> http_proxy=<span class="hljs-string">&quot;http://<span class="hljs-variable">$&#123;hostip&#125;</span>:10881&quot;</span><br><br><span class="hljs-built_in">export</span> http_proxy=<span class="hljs-string">&quot;socks5://<span class="hljs-variable">$&#123;hostip&#125;</span>:7890&quot;</span><br><span class="hljs-built_in">export</span> https_proxy=<span class="hljs-string">&quot;socks5://<span class="hljs-variable">$&#123;hostip&#125;</span>:7890&quot;</span><br><br><span class="hljs-built_in">export</span> all_proxy=<span class="hljs-string">&quot;socks5://<span class="hljs-variable">$&#123;hostip&#125;</span>:10880&quot;</span><br><span class="hljs-built_in">export</span> all_proxy=<span class="hljs-string">&quot;http://<span class="hljs-variable">$&#123;hostip&#125;</span>:10881&quot;</span><br></code></pre></td></tr></table></figure><ul><li>在wsl尝试用<code>export all_proxy</code>socks5做代理感觉总是调不通, 换成http就好了  不知道是为啥</li></ul><h2 id="wsl-conf-wslconfig配置文件"><a href="#wsl-conf-wslconfig配置文件" class="headerlink" title="wsl.conf .wslconfig配置文件"></a>wsl.conf .wslconfig配置文件</h2><p>参考文档:</p><p><a href="https://docs.microsoft.com/zh-cn/windows/wsl/wsl-config">WSL 中的高级设置配置</a></p><blockquote><h2 id="wsl-conf"><a href="#wsl-conf" class="headerlink" title="wsl.conf"></a>wsl.conf</h2><ul><li>以 <code>/etc</code> unix 文件的形式存储在分发目录中。</li><li>用于按分布配置设置。 此文件中配置的设置将仅应用于包含存储此文件的目录的特定 Linux 分发版。</li><li>可用于版本、WSL 1 或 WSL 2 运行的分发版。</li><li>若要访问已安装的发行版的 <code>/etc</code> 目录，请使用发行版的命令行和 <code>cd /</code> 访问根目录，然后使用 <code>ls</code> 列出文件或使用 <code>explorer.exe .</code> 在 Windows 文件资源管理器中查看。 目录路径应如下所示： <code>/etc/wsl.conf</code></li></ul><h2 id="wslconfig"><a href="#wslconfig" class="headerlink" title=".wslconfig"></a>.wslconfig</h2><ul><li>存储在目录中 <code>%UserProfile%</code> 。</li><li>用于跨作为 WSL 2 版本运行的所有已安装 Linux 分发版全局配置设置。</li><li><strong>只能用于 WSL 2 运行的分发</strong>版。 作为 WSL 1 运行的分发版不会受到此配置的影响，因为它们未作为虚拟机运行。</li><li>要访问 <code>%UserProfile%</code> 目录，请在 PowerShell 中使用 <code>cd ~</code> 访问主目录（通常是用户配置文件 <code>C:\Users\&lt;UserName&gt;</code>），或者可以打开 Windows 文件资源管理器并在地址栏中输入 <code>%UserProfile%</code>。 目录路径应如下所示： <code>C:\Users\&lt;UserName&gt;\.wslconfig</code></li></ul></blockquote><h3 id="wsl-conf-的配置-unix"><a href="#wsl-conf-的配置-unix" class="headerlink" title="wsl.conf 的配置 (unix )"></a>wsl.conf 的配置 (unix )</h3><p>wsl.conf 文件支持四个部分：<code>automount</code>、<code>network</code>、<code>interop</code>、<code>user</code> 、<code>[boot]</code>。 </p><p><strong>配置文件示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Automatically mount Windows drive when the distribution is launched</span><br>[automount]<br><br><span class="hljs-comment"># Set to true will automount fixed drives (C:/ or D:/) with DrvFs under the root directory set above. Set to false means drives won&#x27;t be mounted automatically, but need to be mounted manually or with fstab.</span><br>enabled = <span class="hljs-literal">true</span><br><br><span class="hljs-comment"># Sets the directory where fixed drives will be automatically mounted. This example changes the mount location, so your C-drive would be /c, rather than the default /mnt/c. </span><br>root = /<br><br><span class="hljs-comment"># DrvFs-specific options can be specified.  </span><br>options = <span class="hljs-string">&quot;metadata,uid=1003,gid=1003,umask=077,fmask=11,case=off&quot;</span><br><br><span class="hljs-comment"># Sets the `/etc/fstab` file to be processed when a WSL distribution is launched.</span><br>mountFsTab = <span class="hljs-literal">true</span><br><br><span class="hljs-comment"># Network host settings that enable the DNS server used by WSL 2. This example changes the hostname, sets generateHosts to false, preventing WSL from the default behavior of auto-generating /etc/hosts, and sets generateResolvConf to false, preventing WSL from auto-generating /etc/resolv.conf, so that you can create your own (ie. nameserver 1.1.1.1).</span><br>[network]<br>hostname = DemoHost<br>generateHosts = <span class="hljs-literal">false</span><br>generateResolvConf = <span class="hljs-literal">false</span><br><br><span class="hljs-comment"># Set whether WSL supports interop process like launching Windows apps and adding path variables. Setting these to false will block the launch of Windows processes and block adding $PATH environment variables.</span><br>[interop]<br>enabled = <span class="hljs-literal">false</span><br>appendWindowsPath = <span class="hljs-literal">false</span><br><br><span class="hljs-comment"># Set the user when launching a distribution with WSL.</span><br>[user]<br>default = DemoUser<br><br><span class="hljs-comment"># Set a command to run when a new WSL instance launches. This example starts the Docker container service.</span><br>[boot]<br><span class="hljs-built_in">command</span> = service docker start<br></code></pre></td></tr></table></figure><h4 id="自动装载设置-automount"><a href="#自动装载设置-automount" class="headerlink" title="自动装载设置 automount"></a>自动装载设置 automount</h4><p>节标签：<code>[automount]</code></p><table><thead><tr><th align="left">key</th><th align="left">值</th><th align="left">default</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">enabled</td><td align="left">boolean</td><td align="left">是</td><td align="left"><code>true</code> 导致固定驱动器（即 <code>C:/</code> 或 <code>D:/</code>）自动装载到 DrvFs 中的 <code>/mnt</code> 下。 <code>false</code> 表示驱动器不会自动装载，但你仍可以手动或通过 <code>fstab</code> 装载驱动器。</td></tr><tr><td align="left">mountFsTab</td><td align="left">boolean</td><td align="left">是</td><td align="left"><code>true</code> 设置启动 WSL 时要处理的 <code>/etc/fstab</code>。 &#x2F;etc&#x2F;fstab 是可在其中声明其他文件系统的文件，类似于 SMB 共享。 因此，在启动时，可以在 WSL 中自动装载这些文件系统。</td></tr><tr><td align="left">root</td><td align="left">string</td><td align="left"><code>/mnt/</code></td><td align="left">设置固定驱动器要自动装载到的目录。 默认情况下，此设置设置为 <code>/mnt/</code>，因此 Windows 文件系统 C 驱动器已装载到 <code>/mnt/c/</code>。 如果更改为<code>/mnt/``/windir/</code>，应会看到已装载到<code>/windir/c</code>的固定 C 驱动器。</td></tr><tr><td align="left">选项</td><td align="left">逗号分隔的值列表，例如 uid、gid 等，请参阅下面的自动装载选项</td><td align="left">空字符串</td><td align="left">下面列出了自动装载选项值，并追加到默认 DrvFs 装载选项字符串。 <strong>只能指定特定于 DrvFs 的选项。</strong></td></tr></tbody></table><h4 id="网络设置-network"><a href="#网络设置-network" class="headerlink" title="网络设置 network"></a>网络设置 network</h4><p>节标签：<code>[network]</code></p><table><thead><tr><th align="left">key</th><th align="left">值</th><th align="left">default</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">generateHosts</td><td align="left">boolean</td><td align="left"><code>true</code></td><td align="left"><code>true</code> 将 WSL 设置为生成 <code>/etc/hosts</code>。 <code>hosts</code> 文件包含主机名对应的 IP 地址的静态映射。</td></tr><tr><td align="left">generateResolvConf</td><td align="left">boolean</td><td align="left"><code>true</code></td><td align="left"><code>true</code> 将 WSL 设置为生成 <code>/etc/resolv.conf</code>。 <code>resolv.conf</code> 包含能够将给定主机名解析为其 IP 地址的 DNS 列表。</td></tr><tr><td align="left">hostname</td><td align="left">string</td><td align="left">Windows 主机名</td><td align="left">设置要用于 WSL 分发的主机名。</td></tr></tbody></table><h4 id="互操作设置-interop"><a href="#互操作设置-interop" class="headerlink" title="互操作设置 interop"></a>互操作设置 interop</h4><p>节标签：<code>[interop]</code></p><p>这些选项在预览体验成员内部版本 17713 和更高版本中可用。</p><table><thead><tr><th align="left">key</th><th align="left">值</th><th align="left">default</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">enabled</td><td align="left">boolean</td><td align="left"><code>true</code></td><td align="left">设置此键可确定 WSL 是否支持启动 Windows 进程。</td></tr><tr><td align="left">appendWindowsPath</td><td align="left">boolean</td><td align="left"><code>true</code></td><td align="left">设置此键可确定 WSL 是否会将 Windows 路径元素添加到 $PATH 环境变量。</td></tr></tbody></table><h4 id="用户设置-user"><a href="#用户设置-user" class="headerlink" title="用户设置 user"></a>用户设置 user</h4><p>节标签：<code>[user]</code></p><p>这些选项在版本 18980 及更高版本中可用。</p><table><thead><tr><th align="left">key</th><th align="left">值</th><th align="left">default</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">default</td><td align="left">字符串</td><td align="left">首次运行时创建的初始用户名</td><td align="left">设置此键指定在首次启动 WSL 会话时以哪个用户身份运行。</td></tr></tbody></table><h4 id="启动设置-boot"><a href="#启动设置-boot" class="headerlink" title="启动设置 boot"></a>启动设置 boot</h4><p>启动设置仅适用于 Windows 11 和 Server 2022。</p><p>节标签：<code>[boot]</code></p><table><thead><tr><th align="left">key</th><th align="left">值</th><th align="left">default</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">命令</td><td align="left">string</td><td align="left">“”</td><td align="left">你希望在 WSL 实例启动时运行的命令字符串。 此命令以根用户身份运行。 例如： <code>service docker start</code></td></tr></tbody></table><h3 id="wslconfig-的配置-windows"><a href="#wslconfig-的配置-windows" class="headerlink" title=".wslconfig 的配置 (windows)"></a>.wslconfig 的配置 (windows)</h3><blockquote><p>  全局 <code>.wslconfig</code> 配置选项仅适用于在 Windows 内部版本 19041 及更高版本中作为 WSL 2 运行的分发版。 请记住，可能需要运行 <code>wsl --shutdown</code> 来关闭 WSL 2 VM，然后重启 WSL 实例以使这些更改生效。</p></blockquote><p><strong>配置文件示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Settings apply across all Linux distros running on WSL 2</span><br>[wsl2]<br><br><span class="hljs-comment"># Limits VM memory to use no more than 4 GB, this can be set as whole numbers using GB or MB</span><br>memory=4GB <br><br><span class="hljs-comment"># Sets the VM to use two virtual processors</span><br>processors=2<br><br><span class="hljs-comment"># Specify a custom Linux kernel to use with your installed distros. The default kernel used can be found at https://github.com/microsoft/WSL2-Linux-Kernel</span><br>kernel=C:\\temp\\myCustomKernel<br><br><span class="hljs-comment"># Sets additional kernel parameters, in this case enabling older Linux base images such as Centos 6</span><br>kernelCommandLine = vsyscall=<span class="hljs-built_in">emulate</span><br><br><span class="hljs-comment"># Sets amount of swap storage space to 8GB, default is 25% of available RAM</span><br>swap=8GB<br><br><span class="hljs-comment"># Sets swapfile path location, default is %USERPROFILE%\AppData\Local\Temp\swap.vhdx</span><br>swapfile=C:\\temp\\wsl-swap.vhdx<br><br><span class="hljs-comment"># Disable page reporting so WSL retains all allocated memory claimed from Windows and releases none back when free</span><br>pageReporting=<span class="hljs-literal">false</span><br><br><span class="hljs-comment"># Turn off default connection to bind WSL 2 localhost to Windows localhost</span><br>localhostforwarding=<span class="hljs-literal">true</span><br><br><span class="hljs-comment"># Disables nested virtualization</span><br>nestedVirtualization=<span class="hljs-literal">false</span><br><br><span class="hljs-comment"># Turns on output console showing contents of dmesg when opening a WSL 2 distro for debugging</span><br>debugConsole=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>节标签：<code>[wsl2]</code></p><table><thead><tr><th align="left">key</th><th align="left">值</th><th align="left">default</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">内核 (kernel)</td><td align="left">字符串</td><td align="left">Microsoft 内置内核提供的收件箱</td><td align="left">自定义 Linux 内核的绝对 Windows 路径。</td></tr><tr><td align="left">内存</td><td align="left">大小</td><td align="left">Windows 上总内存的 50% 或 8GB，以较小者为准；在 20175 之前的版本上：Windows 上总内存的 80%</td><td align="left">要分配给 WSL 2 VM 的内存量。</td></tr><tr><td align="left">处理器</td><td align="left">数字</td><td align="left">Windows 上相同数量的处理器</td><td align="left">要分配给 WSL 2 VM 的处理器数量。</td></tr><tr><td align="left">localhostForwarding</td><td align="left">boolean</td><td align="left"><code>true</code></td><td align="left">一个布尔值，用于指定绑定到 WSL 2 VM 中的通配符或 localhost 的端口是否应可通过 <code>localhost:port</code> 从主机连接。</td></tr><tr><td align="left">kernelCommandLine</td><td align="left">字符串</td><td align="left">空白</td><td align="left">其他内核命令行参数。</td></tr><tr><td align="left">swap</td><td align="left">大小</td><td align="left">Windows 上 25% 的内存大小四舍五入到最接近的 GB</td><td align="left">要向 WSL 2 VM 添加的交换空间量，0 表示无交换文件。 交换存储是基于磁盘的 RAM，当内存需求超过硬件设备的限制时使用。</td></tr><tr><td align="left">swapFile</td><td align="left">字符串</td><td align="left"><code>%USERPROFILE%\AppData\Local\Temp\swap.vhdx</code></td><td align="left">交换虚拟硬盘的绝对 Windows 路径。</td></tr><tr><td align="left">pageReporting</td><td align="left">boolean</td><td align="left"><code>true</code></td><td align="left">默认设置 <code>true</code> 使 Windows 能够回收分配给 WSL 2 虚拟机的未使用的内存。</td></tr><tr><td align="left">guiApplications</td><td align="left">boolean*</td><td align="left"><code>true</code></td><td align="left">一个布尔值，用于在 WSL 中打开或关闭对 GUI 应用程序 (<a href="https://github.com/microsoft/wslg">WSLg</a>) 的支持。 仅适用于Windows 11。</td></tr><tr><td align="left">debugConsole</td><td align="left">boolean*</td><td align="left"><code>false</code></td><td align="left">一个布尔值，用于在 WSL 2 发行版实例启动时打开显示 <code>dmesg</code> 内容的输出控制台窗口。 仅适用于Windows 11。</td></tr><tr><td align="left">nestedVirtualization</td><td align="left">boolean*</td><td align="left"><code>true</code></td><td align="left">用于打开或关闭嵌套虚拟化的布尔值，使其他嵌套 VM 能够在 WSL 2 中运行。 仅适用于Windows 11。</td></tr><tr><td align="left">vmIdleTimeout</td><td align="left">number*</td><td align="left"><code>60000</code></td><td align="left">VM 在关闭之前处于空闲状态的毫秒数。 仅适用于Windows 11。</td></tr></tbody></table><p>具有 <code>path</code> 值的条目必须是带有转义反斜杠的 Windows 路径，例如：<code>C:\\Temp\\myCustomKernel</code></p><p>具有 <code>size</code> 值的条目必须是后跟单位的大小，例如 <code>8GB</code> 或 <code>512MB</code>。</p><p>值类型后具有 * 的条目仅在Windows 11可用。</p><h2 id="WSL导出与迁移"><a href="#WSL导出与迁移" class="headerlink" title="WSL导出与迁移"></a>WSL导出与迁移</h2><blockquote><p>   我们可以选择手动安装wsl, 这样我们可以避免将wsl安装在c盘, 手动安装的时候, 将下载下来的<code>&lt;distro&gt;.appx</code>文件直接解压, 例如将<code>Ubuntu_1604.2019.523.0_x64.appx</code>解压, 解压出来的文件夹内就包含了<code>ubuntu1604.exe</code>, 运行他就可以启动wsl, 这样可以避免wsl的迁移.</p></blockquote><p><strong>查看WSL分发版本</strong></p><p>在<code>Windows PowerShell</code>中输入如下命令, 查看当前子系统的状态和版本信息.</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">wsl -l <span class="hljs-comment">--all  -v</span><br></code></pre></td></tr></table></figure><p>结果如下:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">  NAME      STATE           <span class="hljs-keyword">VERSION</span><br>* Ubuntu    Running         <span class="hljs-number">2</span><br>  Debian    <span class="hljs-literal">Stopped</span>         <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>导出分发版为tar文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">递归创建文件夹</span><br>mkdir -p d:\system\wsl\ubuntu20.04\<br><span class="hljs-meta prompt_"># </span><span class="language-bash">进入文件夹</span><br>cd d:\system\wsl\ubuntu20.04\<br><span class="hljs-meta prompt_"># </span><span class="language-bash">导出tar包 到当前目录</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">(如果显示的子系统的`NAME`是带有版本号的话需要注意的是这里第二个参数就要带上参数, 例如`Ubuntu-20.04`)</span><br>wsl --export Ubuntu .\ubuntu20.04.tar<br></code></pre></td></tr></table></figure><blockquote>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">--export &lt;发行版&gt; &lt;FileName&gt; [选项]<br>        将发行版导出为 tar 文件。<br>        对于标准输出，文件名可以为 -。<br><br>        选项:<br>            --vhd<br>                指定该发行版应导出为 .vhdx 文件。<br></code></pre></td></tr></table></figure></blockquote><p><strong>注销当前分发版</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wsl --unregister Ubuntu<br></code></pre></td></tr></table></figure><p><strong>重新导入并安装WSL</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wsl --import Ubuntu .\ .\ubuntu20.04.tar --version 2<br></code></pre></td></tr></table></figure><blockquote>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">--import &lt;发行版&gt; &lt;InstallLocation&gt; &lt;FileName&gt; [选项]<br>        将指定的 tar 文件作为新发行版导入。<br>        对于标准输入，文件名可以为 -。<br><br>        选项:<br>            --version &lt;版本&gt;<br>                指定新发行版要使用的版本。<br><br>            --vhd<br>                指定提供的文件是 .vhdx 文件，而不是 tar 文件。<br>                此操作会在指定的安装位置复制 .vhdx 文件。<br></code></pre></td></tr></table></figure></blockquote><p><strong>设置默认登陆用户为安装时用户名</strong></p><blockquote><p>  (如果显示的子系统的<code>NAME</code>是带有版本号的话需要注意的是这里第二个参数就要带上参数, 例如<code>Ubuntu-20.04</code>)</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ubuntu config --default-user Username<br></code></pre></td></tr></table></figure><p><strong>删除tar文件(可选)</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm .\ubuntu20.04.tar<br></code></pre></td></tr></table></figure><h2 id="语言和缺字体"><a href="#语言和缺字体" class="headerlink" title="语言和缺字体"></a>语言和缺字体</h2><p>wsl是没有中文字体的，所以在安装使用Firefox等软件时，无法正常显示中文字体，所以我们可以通过使用Windows自带字体的方式，来实现快速安装中文字体（以Ubuntu为例）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo ln -s /mnt/c/Windows/Fonts /usr/share/fonts/font<br></code></pre></td></tr></table></figure><p>我们只需要将Windows下的字体目录链接到WSL目录下即可然后再刷新一下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">fc-cache -fv<br></code></pre></td></tr></table></figure><p>这样就可以正常显示中文字体了。</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>linux</tag>
      
      <tag>wsl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手动添加JLink不支持的芯片</title>
    <link href="/2021/30f8332a/"/>
    <url>/2021/30f8332a/</url>
    
    <content type="html"><![CDATA[<h1 id="手动添加JLink不支持的芯片"><a href="#手动添加JLink不支持的芯片" class="headerlink" title="手动添加JLink不支持的芯片"></a>手动添加JLink不支持的芯片</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>市场上的新芯片层出不穷，JLink的官方支持不可能完全跟得上，这就尴尬了。但是好在Segger在设计时就想到了这一点，允许用户自己添加新芯片或扩展官方已经支持的芯片。本文只讲如何添加新芯片，参考的资料为<code>UM08001_JLink.pdf</code>中的第12章——<code>Open Flashloader</code>。</p><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p>在添加前，JFlash里找不到BARROT的任何型号，</p><p>添加后如下图</p><p><img src="/2021/30f8332a/image-20211019164827957.png" alt="image-20211019164827957"></p><h2 id="添加方法"><a href="#添加方法" class="headerlink" title="添加方法"></a>添加方法</h2><ul><li><p>找到Jlink安装目录下的<code>JLinkDevices.xml</code>并打开；</p></li><li><p>默认位置<code>C:\Program Files\SEGGER\JLink</code></p><p>在打开的文件添加如下内容，因为这个文件里没有任何BARROT的芯片，所以我添加到文件末尾，如果文件已经有同厂家的其它芯片，建议还是放一起，方便维护。效果和代码放下面了，代码的解释在后面！</p><p><img src="/2021/30f8332a/image-20211019164859196.png" alt="image-20211019164859196"></p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--                  --&gt;</span><br><span class="hljs-comment">&lt;!-- BARROT (BR8551) --&gt;</span><br><span class="hljs-comment">&lt;!--                  --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Device</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">ChipInfo</span> <span class="hljs-attr">Vendor</span>=<span class="hljs-string">&quot;BARROT&quot;</span> <span class="hljs-attr">Name</span>=<span class="hljs-string">&quot;BR8551&quot;</span> <span class="hljs-attr">Core</span>=<span class="hljs-string">&quot;JLINK_CORE_CORTEX_M3&quot;</span> <span class="hljs-attr">WorkRAMAddr</span>=<span class="hljs-string">&quot;0x2000C000&quot;</span> <span class="hljs-attr">WorkRAMSize</span>=<span class="hljs-string">&quot;0x00004000&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">FlashBankInfo</span> <span class="hljs-attr">Name</span>=<span class="hljs-string">&quot;ROM&quot;</span> <span class="hljs-attr">BaseAddr</span>=<span class="hljs-string">&quot;0x00000000&quot;</span> <span class="hljs-attr">MaxSize</span>=<span class="hljs-string">&quot;0x00060000&quot;</span> <span class="hljs-attr">Loader</span>=<span class="hljs-string">&quot;D:\\Project\\Panda\\Code\\bamboo\\panda\\tools\\Keil\\VFlash.FLM&quot;</span> <span class="hljs-attr">LoaderType</span>=<span class="hljs-string">&quot;FLASH_ALGO_TYPE_OPEN&quot;</span> <span class="hljs-attr">AlwaysPresent</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">FlashBankInfo</span> <span class="hljs-attr">Name</span>=<span class="hljs-string">&quot;LR_IROM1&quot;</span> <span class="hljs-attr">BaseAddr</span>=<span class="hljs-string">&quot;0x10000000&quot;</span> <span class="hljs-attr">MaxSize</span>=<span class="hljs-string">&quot;0x00080000&quot;</span> <span class="hljs-attr">Loader</span>=<span class="hljs-string">&quot;D:\\Project\\Panda\\Code\\bamboo\\panda\\tools\\Keil\\VFlash.FLM&quot;</span> <span class="hljs-attr">LoaderType</span>=<span class="hljs-string">&quot;FLASH_ALGO_TYPE_OPEN&quot;</span> <span class="hljs-attr">AlwaysPresent</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Device</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>保存文件就添加完了，可以验证是否如文章开头的效果一样</li></ul></li></ul><h2 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h2><ul><li>最开始的三行是注释，注释嘛，随便写了，清晰明了就行；</li><li><code>&lt;Device&gt;</code>和<code>&lt;/Device&gt;</code>必须成对出现，而且没有属性表。每个（系列）芯片都对应着这么一对。</li><li><code>ChipInfo</code>是描述芯片的信息，必须在 <code>&lt;Device&gt;</code>和<code>&lt;/Device&gt;</code>内。</li></ul><table><thead><tr><th align="center">参数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Vendor</td><td align="center">芯片厂家的名字，比如这里的”BARROT”</td></tr><tr><td align="center">Name</td><td align="center">芯片的具体型号，我用的就是BR8551</td></tr><tr><td align="center">Core</td><td align="center">芯片的内核，这个必须是JLink支持的内核之一，具体的名字可以在文档里的12.5.3.1    Attribute values - Core章节找到。</td></tr><tr><td align="center">WorkRAMAddr</td><td align="center">芯片RAM的起始地址，这个可以在用户手册里找到，也可以打开SDK里的官方例程，然后在工程配置里找到</td></tr><tr><td align="center">WorkRAMSize</td><td align="center">芯片RAM的大小，同样可以在用户手册里找到，也可以打开SDK里的官方例程，然后在工程配置里找到</td></tr><tr><td align="center">Aliases</td><td align="center">同系列的相同RAM和FLASH的型号</td></tr><tr><td align="center">JLinkScriptFile</td><td align="center">高级用法，有些芯片操作比较特殊，可以通过脚本去实现，这里我用不上</td></tr></tbody></table><hr><ul><li><code>FlashBankInfo</code>描述芯片的Flash信息，有多块flash的话，每块对应一个<code>FlashBankInfo</code>。</li></ul><table><thead><tr><th align="center">参数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Name</td><td align="center">flash的名字，名字可以随便起</td></tr><tr><td align="center">BaseAddr</td><td align="center">flash的起始地址，可以在用户手册里找到</td></tr><tr><td align="center">MaxSize</td><td align="center">flash的大小，可以在用户手册里找到</td></tr><tr><td align="center">Loader</td><td align="center">烧录的算法，segger官方的是*.elf格式，*.flm是ARM的格式，keil里就用这个。这个路径可以是绝对地址也可以是相对地址，相对地址的话是从<code>JLinkDevices.xml</code>所在的路径为起始地址。</td></tr><tr><td align="center">LoaderType</td><td align="center">必须是12.5.4.1    Attribute values - LoaderType中列出的类型之一，目前只有FLASH_ALGO_TYPE_OPEN一个类型，而*.flm是支持这个类型的</td></tr><tr><td align="center">AlwaysPresent</td><td align="center">指示这个块flash是不是一直存在，本文是内部flash，当然一直存在</td></tr></tbody></table><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/d7fae221ac47">工欲善其事，必先利其器：动手给JLink添加官方不支持的芯片</a></p>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>j-link</tag>
      
      <tag>jlink</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CAD</title>
    <link href="/2021/154e1146/"/>
    <url>/2021/154e1146/</url>
    
    <content type="html"><![CDATA[<h1 id="CAD"><a href="#CAD" class="headerlink" title="CAD"></a>CAD</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul><li><p>对象捕捉：端点、中点、圆心、、、、、</p></li><li></li><li><p>shift正交</p></li><li><p>shift按住，取消选择</p></li><li><p>连续画直线，空格取消</p></li><li><p>画直线，c键闭合</p></li></ul><h1 id="形状"><a href="#形状" class="headerlink" title="形状"></a>形状</h1><h2 id="直线"><a href="#直线" class="headerlink" title="直线"></a>直线</h2><p>L键</p><h2 id="圆"><a href="#圆" class="headerlink" title="圆"></a>圆</h2><p>C键</p><h3 id="圆心-半径"><a href="#圆心-半径" class="headerlink" title="圆心 半径"></a>圆心 半径</h3><p>D键切换成直径</p><h3 id="两点"><a href="#两点" class="headerlink" title="两点"></a>两点</h3><h3 id="三点"><a href="#三点" class="headerlink" title="三点"></a>三点</h3><h3 id="相切-相切-半径"><a href="#相切-相切-半径" class="headerlink" title="相切 相切 半径"></a>相切 相切 半径</h3><h3 id="相切-相切-相切"><a href="#相切-相切-相切" class="headerlink" title="相切 相切 相切"></a>相切 相切 相切</h3><p>快捷键不详</p><h2 id="圆弧"><a href="#圆弧" class="headerlink" title="圆弧"></a>圆弧</h2><p>ARC键</p><p>逆时针画圆弧</p><h2 id="多段线"><a href="#多段线" class="headerlink" title="多段线"></a>多段线</h2><p>PLI键</p><ul><li>可以赋予宽度</li></ul><h3 id="合并多段线"><a href="#合并多段线" class="headerlink" title="合并多段线"></a>合并多段线</h3><ol><li>PE (pedit 多段线编辑)</li><li>m 选择多段线</li><li>选中后空格确认</li><li>y 转换</li><li>j 合并</li><li></li></ol><h2 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h2><h2 id="多边形"><a href="#多边形" class="headerlink" title="多边形"></a>多边形</h2><p>POL 键</p><h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><h2 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h2><p>m 键 move</p><h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>co </p><h2 id="拉伸"><a href="#拉伸" class="headerlink" title="拉伸"></a>拉伸</h2><p>s</p><h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>ro </p><ul><li>起点开始 逆时针</li><li>c 复制，原来的保留并复制</li><li>r 参照，参照线旋转</li></ul><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p>mi</p><h2 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h2><p>sc</p><ul><li>r参照，参照边长缩放</li></ul><h2 id="对齐缩放"><a href="#对齐缩放" class="headerlink" title="对齐缩放"></a>对齐缩放</h2><p>al</p><ul><li>根据边对齐，根据边长缩放</li></ul><h2 id="修剪"><a href="#修剪" class="headerlink" title="修剪"></a>修剪</h2><p>tr</p><ul><li>不选基线默认修剪</li></ul><h2 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h2><p>ex</p><ul><li>不选基线默认延伸</li></ul><h2 id="倒角"><a href="#倒角" class="headerlink" title="倒角"></a>倒角</h2><p>cha</p><h2 id="圆角"><a href="#圆角" class="headerlink" title="圆角"></a>圆角</h2><p>f</p><h2 id="光顺曲线"><a href="#光顺曲线" class="headerlink" title="光顺曲线"></a>光顺曲线</h2><p>两个曲线光滑连接</p><h2 id="矩形阵列"><a href="#矩形阵列" class="headerlink" title="矩形阵列"></a>矩形阵列</h2><h2 id="路径阵列"><a href="#路径阵列" class="headerlink" title="路径阵列"></a>路径阵列</h2><h2 id="圆形阵列"><a href="#圆形阵列" class="headerlink" title="圆形阵列"></a>圆形阵列</h2><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><h2 id="修改注释标准"><a href="#修改注释标准" class="headerlink" title="修改注释标准 (,-&gt;.)"></a>修改注释标准 (,-&gt;.)</h2><p>标注样式-&gt;修改-&gt;主单位-&gt;逗号改成点号</p><h2 id="空心字-文字转换成线"><a href="#空心字-文字转换成线" class="headerlink" title="空心字 文字转换成线"></a>空心字 文字转换成线</h2><p><strong>注意：</strong>安装默认不安装拓展工具，如果txtexp找不到命令，需要重装，安装的时候选择组件的时候选上Express Tools。</p><ol><li>mt 创建文字</li><li>txtexp 将文字分解成文字轮廓</li></ol>]]></content>
    
    
    <categories>
      
      <category>more_interest</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cad</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PC Hardware</title>
    <link href="/2021/86880617/"/>
    <url>/2021/86880617/</url>
    
    <content type="html"><![CDATA[<h1 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h1><h2 id="ITX-主板的孔位图"><a href="#ITX-主板的孔位图" class="headerlink" title="ITX 主板的孔位图"></a>ITX 主板的孔位图</h2><p>括号中的数值单位是mm，下面的数值单位是inch。</p><p><img src="/2021/86880617/v2-adfa6cb86a379f8ea31c62416c3a9b93_720w.jpg" alt="img"></p><h2 id="ATX-孔位图"><a href="#ATX-孔位图" class="headerlink" title="ATX 孔位图"></a>ATX 孔位图</h2><p>数值单位是inch</p><p><img src="/2021/86880617/v2-19cb957be912ef88b779a7ed04de4eaf_720w.jpg" alt="img"></p><h1 id="DISK"><a href="#DISK" class="headerlink" title="DISK"></a>DISK</h1><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.snia.org/technology-communities/sff/specifications">SNIA协会定义</a></li><li>SFF-8301 (3.5” Form Factor Drive Dimensions)</li><li>SFF-8201 (2.5” Form Factor Drive Dimensions)</li></ul><h2 id="2-5”"><a href="#2-5”" class="headerlink" title="2.5”"></a>2.5”</h2><p>定义于SFF-8201, 长度为101.85mm (max), 宽度为69.85，厚度有不同规格，从5mm到19.05mm不等。常用的笔记本硬盘是7mm厚度，企业级硬盘是15mm，螺丝孔为公制M3标准。</p><p><img src="/2021/86880617/image-20211026113925717.png" alt="image-20211026113925717"></p><p><img src="/2021/86880617/image-20211026113951361.png" alt="image-20211026113951361"></p><p><img src="/2021/86880617/image-20211026114009000.png" alt="image-20211026114009000"></p><p><img src="/2021/86880617/image-20211026114023653.png" alt="image-20211026114023653"></p><h2 id="3-5”"><a href="#3-5”" class="headerlink" title="3.5”"></a>3.5”</h2><p>定义于SFF-8301,长度为147.00mm, 宽度为101.60mm，厚度有不同规格：17.80-42.00mm。通常硬盘的厚度都是小于26.10mm，螺丝孔为6-32 UNC-2B英制标准，公制M3.5也能凑合用。</p><p><img src="/2021/86880617/image-20211026114433027.png" alt="image-20211026114433027"></p><p><img src="/2021/86880617/image-20211026114447507.png" alt="image-20211026114447507"></p><h1 id="Lenovo-私有定义"><a href="#Lenovo-私有定义" class="headerlink" title="Lenovo 私有定义"></a>Lenovo 私有定义</h1><h2 id="主板-1"><a href="#主板-1" class="headerlink" title="主板"></a>主板</h2><h3 id="USB2-0-接口"><a href="#USB2-0-接口" class="headerlink" title="USB2.0 接口"></a>USB2.0 接口</h3><p><img src="/2021/86880617/image-20211026120339401.png" alt="image-20211026120339401"></p><p><img src="/2021/86880617/image-20211026120205476.png" alt="image-20211026120205476"></p><h3 id="F-PANEL"><a href="#F-PANEL" class="headerlink" title="F_PANEL"></a>F_PANEL</h3><p><img src="/2021/86880617/image-20211026120411691.png" alt="image-20211026120411691"></p><p><img src="/2021/86880617/image-20211026120130016.png" alt="image-20211026120130016"></p>]]></content>
    
    
    <categories>
      
      <category>more_interest</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pc</tag>
      
      <tag>hardware</tag>
      
      <tag>lenovo</tag>
      
      <tag>disk</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Synology 群晖</title>
    <link href="/2021/ee60585b/"/>
    <url>/2021/ee60585b/</url>
    
    <content type="html"><![CDATA[<h1 id="群晖"><a href="#群晖" class="headerlink" title="群晖"></a>群晖</h1><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="资源及参考链接"><a href="#资源及参考链接" class="headerlink" title="资源及参考链接"></a>资源及参考链接</h2><p><a href="https://www.openos.org/threads/dsm-6-2-3-2020-12-27.29/">https://www.openos.org/threads/dsm-6-2-3-2020-12-27.29/</a></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li><p><strong>引导系统装哪里？</strong><br>非常关键的问题，DSM采用系统和数据相分离的结构，也就是说引导系统需要独立安装在一个设备上，通常是U盘&#x2F;SD&#x2F;TF卡、或者SSD硬盘上。数据需要额外安装独立的硬盘上。</p></li><li><p><strong>引导系统安装盘 (U盘&#x2F;USB flash drive&#x2F;随身碟)</strong><br>无论是U盘还是TF卡，其实128MB或以上就足够了，USB 2.0&#x2F;3.0都可以。</p></li><li><p><strong>数据存储硬盘 (硬盘)</strong><br>机械硬盘或者固态硬盘都可以，这个没有限制，容量当然越大越好。</p></li><li><p>一般来说安装黑群晖至少需要两个文件, 一个是黑群晖的引导文件, 一个是群晖DSM的系统文件.</p></li></ul><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><blockquote><p>  黑群晖系统: DSM 6.2.0–6.2.3<br>  引导版本: 1.04b (首选推荐版本)<br>  针对机型: DS918+<br>  引导方式: 传统BIOS和UEFI<br>  引导下载地址<br>  <a href="https://www.openos.org/downloads/synology-dsm-6-2-1-loader-v1-04b.15/">https://www.openos.org/downloads/synology-dsm-6-2-1-loader-v1-04b.15/</a></p><p>  DS918+ DSM 6.2.3-25426 Update2 系统<br>  <a href="https://global.download.synology.com/download/DSM/release/6.2.3/25426/DSM_DS918+_25426.pat">https://global.download.synology.com/download/DSM/release/6.2.3/25426/DSM_DS918+_25426.pat</a></p><p>  其他DSM系统版本请看这里<br>  <a href="https://archive.synology.com/download">https://archive.synology.com/download</a></p></blockquote><ol><li><p>下载群晖的引导文件, 推荐下载<code>v1.04b.for.dms.6.2.1.synoboot-ds918.zip</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">http://down.nas2x.com/synology/dsm/6.2/synoboot/<br><span class="hljs-comment"># 里面有三个文件</span><br>dsm.6.2.synoboot_ds3615xs.1.03b.zip                02-Aug-2018 10:43     17M<br>dsm.6.2.synoboot_ds3617xs.1.03b.zip                02-Aug-2018 10:42     20M<br>v1.04b.for.dms.6.2.1.synoboot-ds918.zip            25-Jan-2019 18:30     21M<br></code></pre></td></tr></table></figure></li><li><p>下载群晖的系统, 根据上面的引导下载系统, 上面选的是<code>DS918+</code>的话, 这里下载<code>DS918+</code>就好.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># DS918+</span><br>https://global.download.synology.com/download/DSM/release/6.2.3/25426/DSM_DS918+_25426.pat<br><span class="hljs-comment"># 其他DSM系统</span><br>https://archive.synology.com/download<br></code></pre></td></tr></table></figure></li><li><p>修改引导程序配置文件,</p><p>使用<code>ChipEasy</code>或者<code>ChipGenius</code>查找到U盘的VID和PID。</p><p>以下图为例，这个U盘的VID是0930，PID是6544。</p><p><strong>请记录好这两个值。下面修改配置文件需要用到。</strong></p><p><img src="/2021/ee60585b/07.png" alt="IMG"></p></li><li><p>编辑配置文件grub.cfg.</p><p>打开DiskGenius, 在顶部选择硬盘-打开虚拟硬盘文件, 选择刚刚下载的<code>.img</code>引导文件并打开.</p><p><img src="/2021/ee60585b/kc6jjxmd.png" alt="IMG"></p><p>在左边找到刚刚打开的img文件, 点击展开<code>ESP-&gt;grub</code>, 在右边找到<code>grub.cfg</code>, 选择复制到桌面.</p><p><img src="/2021/ee60585b/kccTMt.md.png" alt="IMG"></p><p>使用文本编辑器修改<code>line22-line25</code>的数据,</p><p>需要注意的是<code>VID</code>和<code>PID</code>必须要和U盘的数值匹配好.</p><p><code>SN</code>和<code>MAC1</code>是在洗半白的时候需要修改的数值, 是非必须修改的.</p><blockquote><p>set vid&#x3D;0x058f U盘的VID 实体机必须修改，虚拟机无需修改<br>set pid&#x3D;0x6387 U盘的PID 实体机必须修改，虚拟机无需修改<br>set sn&#x3D;A8ODN02468 序列号 可以不修改<br>set mac1&#x3D;0011322CA603 mac地址 可以不修改</p></blockquote><p>注意:vid和pid的0x是十六进制的意思是不要删除掉的，只需要修改后面的4位.</p><p><img src="/2021/ee60585b/06.png" alt="IMG"></p><p>回到DiskGenius内将原来的<code>grub.cfg</code>文件替换掉, 我这里是先将<code>img</code>镜像里面的<code>grub.cfg</code>文件删除, 再右键选择新增文件将编辑好的<code>grub.cfg</code>文件放入其中.</p><p>关闭DiskGenius完成<code>img</code>引导的修改.</p></li><li><p><strong>制作引导U盘</strong></p><p>使用<code>Win32 Disk Imager</code>磁盘映像工具将<code>img</code>引导文件写入U盘内.</p><blockquote><p>  下载地址:<a href="https://sourceforge.net/projects/win32diskimager/">https://sourceforge.net/projects/win32diskimager/</a><br>  中文版:<a href="https://www.openos.org/downloads/win32-disk-imager.2/">https://www.openos.org/downloads/win32-disk-imager.2/</a></p></blockquote><ul><li><p>先在软件界面右侧设备(Device) 部分选择U盘的盘符。<br>（建议在操作前移除所有其他的USB存储设备，以防选择错误导致其他U盘或移动硬盘数据丢失）。</p></li><li><p>再点击软件界面 映像文件(Image File)右侧蓝色文件夹图标，选择之前下载的synoboot.img文件。</p></li><li><p>最后再点击写入(Write)。</p></li></ul><p><img src="/2021/ee60585b/w11.png" alt="IMG"></p></li><li><p>安装群晖系统</p><p>插入U盘，并且在主板上设置默认从U盘启动</p><p>默认选择从U盘启动后选择第1个选项<code>DS3617xs 6.1 Baremetal with Jun&#39;s Mod v1.02-alpha</code>按回车。</p><p><img src="/2021/ee60585b/2017041711.png" alt="IMG"></p></li><li><p>找到设备IP地址</p><p>这里需要稍微等一等提示<code>Please open [http://find.synology.com](http://find.synology.com/) to continue</code>后等个1-2分钟在浏览器里面输入<a href="http://find.synology.com/">http://find.synology.com/</a> ，搜索DSM，如果没有找到，那么使用SynologyAssistant查找. <a href="https://cndl.synology.cn/download/Tools/Assistant/6.1-15030/Windows/synology-assistant-6.1-15030.exe">点击下载Windows版本</a> </p><p>能进路由器管理页面的, 较好的方案是看一下群晖获取的IP是多少, 浏览器直接进去这个<code>IP:5000</code>的网页即可, 免去搜寻的麻烦.</p><blockquote><p>  若多次测试还是无法搜索到群晖，那可能是网卡不支持,<br>  详情请查看DSM黑群晖网卡支持列表<br>  <a href="https://www.openos.org/threads/dsm-6-1-supported-drivers.42/">https://www.openos.org/threads/dsm-6-1-supported-drivers.42/</a></p></blockquote><p><img src="/2021/ee60585b/201704zoz.png" alt="IMG"></p></li><li><p>上传系统文件.</p><p>根据提示继续，点击<code>手动安装</code>后选择之前下载的pat文件，然后再点击<code>立即安装</code>。</p><p><img src="/2021/ee60585b/201704opo.png" alt="IMG"></p><p><img src="/2021/ee60585b/201704ada.png" alt="IMG"></p></li><li><p>安装之后完成一些配置后就可以进入系统界面了.</p></li></ol><h2 id="安装后的注意事项"><a href="#安装后的注意事项" class="headerlink" title="安装后的注意事项"></a>安装后的注意事项</h2><blockquote><p>  <strong>安装完成后的基本设置和注意事项</strong><br>  1,不要升级，不要升级，不要升级。可以去控制面板下面的-更新和还原里面设置。<br>  2,还是不要升级，去计划任何里面关闭DSM自动更新选项。<br>  3,在存储空间管理员里面设置存储空间后才可以进行其他的操作，如共享文件夹或安装其他套件。<br>  4,DSM 6.x配置文件grub.cfg修改: <a href="https://www.openos.org/threads/dsm-6-x-grub-cfg-mac-sn.36/">https://www.openos.org/threads/dsm-6-x-grub-cfg-mac-sn.36/</a></p><p>  群辉Synology DSM 添加硬盘&#x2F;存储空间的方法<br>  <a href="https://www.openos.org/threads/synology-dsm-hdd.30/">https://www.openos.org/threads/synology-dsm-hdd.30/</a></p><p>  6.1驱动支持列表<br>  <a href="https://www.openos.org/threads/dsm-6-1-supported-drivers.42/">https://www.openos.org/threads/dsm-6-1-supported-drivers.42/</a></p><p>  经过测试，引导文件支持DSM 6.1.1-15101<br>  但是不支持从老版本升级升级，仅限全新安装<br>  安装后更新到update 2没有问题<br>  <a href="https://www.openos.org/downloads/xpenology-dsm-6-1-1.8/history">https://www.openos.org/downloads/xpenology-dsm-6-1-1.8/history</a></p></blockquote><blockquote><p>  安装完成后可以下载一些相关的手机端应用<br>  DS Finder<br>  DS File<br>  DS photo</p></blockquote><h1 id="编译引导安装群晖"><a href="#编译引导安装群晖" class="headerlink" title="编译引导安装群晖"></a>编译引导安装群晖</h1><p>Github： <a href="https://github.com/fbelavenuto/arpl/">https://github.com/fbelavenuto/arpl/</a> （这个在2023年停更了）<br>Github：<a href="https://github.com/RROrg/rr/releases">https://github.com/RROrg/rr/releases</a> （这个在更新，但是出现不久，据说是新的，也有说是arpl的迭代版本）</p><ol><li><p>到release页面下载<code>arpl-1.1-beta2a.img.zip</code>，解压后得到<code>arpl.img</code>文件。</p><ol><li>物理机安装群晖的，使用rufus吧<code>arpl.img</code>文件写入到U盘中</li><li>虚拟机安装的，将这个文件导入虚拟机，并将其设置为启动盘</li></ol></li><li><p>开机设为启动项</p></li><li><p>跳出显示画面，按默认选项走就好</p></li><li><p>如果设备连接的路由器打开了DHCP的话，屏幕可以看到已经显示了<code>IP:7601</code>这样的地址。</p><ol><li><img src="/2021/ee60585b/image-20230828230148188.png" alt="image-20230828230148188"></li></ol></li><li><p>我们需要连接到设备进行一些配置</p><ol><li>方式一 通过终端<ol><li>机器插上键盘</li><li>从设备调用“menu.sh”命令。</li></ol></li><li>方式二 通过网络配置<ol><li>另外一台电脑，打开刚刚屏幕上显示的网址配置</li></ol></li><li>方式三 通过ssh配置<ol><li>使用ssh客户端，用户名： <code>root</code> 和密码： <code>Redp1lL-1s-4weSomE</code></li></ol></li></ol></li><li><p><code>Choose a model</code>选择你喜欢的型号 （DS918+ 兼容性好）</p><ol><li><img src="/2021/ee60585b/image-20230828230737102.png" alt="image-20230828230737102"></li><li>这里有个型号选择的参考 <a href="http://d.nas50.cn/?id=16">网址</a><br> <img src="/%E7%BE%A4%E6%99%96.assets/image-20240626182531055.png"></li></ol></li><li><p><code>Choose a Build Number</code> 可以选最新的版本，这个版本对应群晖系统的版本</p><ol><li><img src="/2021/ee60585b/image-20230828230902591.png" alt="image-20230828230902591"></li></ol></li><li><p><code>Choose a serial number</code> 序列号配置</p><ol><li><code>Generate a random serial number</code> 随机生成一个序列号</li></ol></li><li><p><code>Addons</code> 是和十代cpu核显驱动相关的配置（这里根据CPU去配置）</p></li><li><p><code>build the loader</code> 编译loader程序</p><ol><li>这个需要一点时间稍微等一下</li><li><img src="/2021/ee60585b/image-20230828231118050.png" alt="image-20230828231118050"></li></ol></li><li><p><code>boot the loader</code> 启动编译好的boot</p><ol><li><img src="/2021/ee60585b/image-20230828231334846.png" alt="image-20230828231334846"></li></ol></li><li><p>boot引导到DSM之后，屏幕就不会再更新信息了</p></li><li><p>访问群晖的页面</p><ol><li>路由器找到群晖的IP，访问<code>IP:5000</code></li><li>浏览器输入 <a href="https://finds.synology.com/">https://finds.synology.com/</a> 寻找刚刚安装启动的NAS</li></ol></li><li><p>DSM系统安装参照上篇，DSM系统安装就是一样的了。</p></li></ol><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><h2 id="SSH访问启动盘"><a href="#SSH访问启动盘" class="headerlink" title="SSH访问启动盘"></a>SSH访问启动盘</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir /mnt/boot<br>cd /dev<br>sudo mount -t vfat synoboot1 /mnt/boot<br>cd /mnt/boot<br></code></pre></td></tr></table></figure><h2 id="半洗白-SN"><a href="#半洗白-SN" class="headerlink" title="半洗白 SN"></a>半洗白 SN</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li>全黑版本的群晖VideoStation不能离线转码，PhotoStation和Moments的略缩图和人像识别也会有问题</li><li>半洗白就是转码和缩略图一类的可用</li><li>全白就是多了QC，这个就没必要了(白嫖个系统就好了,就不要去嫖别人的服务器了)</li><li>主要通过Docker+DDSM来获得SN</li><li>群辉新版的Docker 18.09.0-0506已经关闭了DDSM安装，可下载17.05.0版本的Docker</li></ul><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><ol><li><p>下载17.05.0的Docker，可以在<a href="https://archive.synology.com/download/Package/Docker/17.05.0-0401">群晖官网下载</a>。</p></li><li><p>下载DDSM，可在<a href="https://archive.synology.com/download/Os/DSM/6.2.3-25426">群晖官网下载</a>，注意要对应自己DSM的版本。</p></li><li><p>首先在套件中心点手动安装把第一步下载的17.05.0的Docker放进去。</p></li><li><p>打开Docker-左侧DSM-点击新增-下一步-下一步-下一步-手动上传，把刚刚下载的DDSM放进去，等待他安装完成。</p></li><li><p>安装完成后，进入DDSM群晖的控制面板。</p></li><li><p>在信息栏可看到SN和MAC，复制DDSM的SN和MAC保存下来。</p></li><li><p>SSH接入DSM群晖，挂载启动盘BOOT，修改<code>/grub/grub.cfg</code>文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">挂载启动盘BOOT</span><br>mkdir /mnt/boot<br>cd /dev<br>sudo mount -t vfat synoboot1 /mnt/boot<br>cd /mnt/boot<br></code></pre></td></tr></table></figure></li><li><p>重启。</p></li></ol><p><img src="/2021/ee60585b/image-20211018141146176.png" alt="image-20211018141146176"></p><h2 id="半洗白后moments人脸识别不出来"><a href="#半洗白后moments人脸识别不出来" class="headerlink" title="半洗白后moments人脸识别不出来"></a>半洗白后moments人脸识别不出来</h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>当群晖系统升级到6.22-24922以后，Moments也升级到了1.3.X，新的bug也随着版本升级来了”人物或者主题经常识别不出来“，经查日志后发现是Moments1.3插件有bug引导的，有问题的插件为“<strong>libsynophoto-plugin-detection.so</strong>”，经测试该插件在Moments1.2版本中是正常的。</p><h3 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h3><ol><li><p>群晖上启用SSH，并将moments停用</p></li><li><p>MobaXterm连接群晖，启用root登录</p><ol><li><code>sudo -i</code></li><li><code>vi /etc/ssh/sshd_config</code></li><li>找到#PermitRootLogin prohibit password，这一行最后，按回车，然后输入 <code>PermitRootLogin yes</code></li><li>修改root密码<code>synouser --setpw root 你的密码</code></li><li>重启</li></ol></li><li><p>用root重新登录，将libsynophoto-plugin-detection.so插件替换掉</p><ol><li>找到目录：&#x2F;var&#x2F;packages&#x2F;SynologyMoments&#x2F;target&#x2F;usr&#x2F;lib&#x2F;libsynophoto-plugin-detection.so</li><li>将原文件先备份一下</li><li>用现有新文件将他替换掉</li><li>新文件权限修改一下</li></ol></li><li><p>将moments启用，问题解决</p></li></ol><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.zhihu.com/question/428454266/answer/1681110862?ivk_sa=1024320u">https://www.zhihu.com/question/428454266/answer/1681110862?ivk_sa=1024320u</a></p><p><a href="https://blog.csdn.net/weixin_36059505/article/details/112766321">https://blog.csdn.net/weixin_36059505/article/details/112766321</a></p><h2 id="群晖安装-ipkg-包管理"><a href="#群晖安装-ipkg-包管理" class="headerlink" title="群晖安装 ipkg 包管理"></a>群晖安装 ipkg 包管理</h2><p><strong>仅适用于x86平台，ARM平台需要修改链接</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">以 root 用户执行</span><br>sudo -i<br>cd /volume1/@tmp<br>wget http://ipkg.nslu2-linux.org/feeds/optware/syno-i686/cross/unstable/syno-i686-bootstrap_1.2-7_i686.xsh<br>chmod +x syno-i686-bootstrap_1.2-7_i686.xsh<br>sh syno-i686-bootstrap_1.2-7_i686.xsh<br>rm syno-i686-bootstrap_1.2-7_i686.xsh<br>ipkg update<br>reboot<br></code></pre></td></tr></table></figure><h2 id="CPU频率调整"><a href="#CPU频率调整" class="headerlink" title="CPU频率调整"></a>CPU频率调整</h2><ol><li><p>Linux的&#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpuxxx&#x2F;cpufreq目录存储着第xxx个CPU的一些参数，例如最小最大平均频率，bios限制频率。</p></li><li><p>使用如下命令可以查看支持的工作模式：</p> <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/sys/</span>devices<span class="hljs-regexp">/system/</span>cpu<span class="hljs-regexp">/cpu0/</span>cpufreq/scaling_available_governors<br></code></pre></td></tr></table></figure><table><thead><tr><th>模式</th><th>介绍</th></tr></thead><tbody><tr><td>powersave</td><td>只会保持最低频率，节能省电</td></tr><tr><td>userspace</td><td>自定义频率</td></tr><tr><td>ondemand</td><td>一有cpu计算量的任务，就会立即达到最大频率运行，等执行完毕就立即回到最低频率</td></tr><tr><td>conservative</td><td>根据负载状态自动在频率上下限调整</td></tr><tr><td>performance</td><td>保持以最大频率运行</td></tr></tbody></table></li><li><p>通过下面指令可以看第*个CPU核心的工作状态，</p> <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/sys/</span>devices<span class="hljs-regexp">/system/</span>cpu<span class="hljs-regexp">/cpu*/</span>cpufreq/scaling_governor<br></code></pre></td></tr></table></figure></li></ol><p>安装cpufreq-info：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">ipkg update<br>ipkg <span class="hljs-keyword">install</span> cpufrequtils<br></code></pre></td></tr></table></figure><p>查看CPU频率和模式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cpufreq-info<br></code></pre></td></tr></table></figure><p>修改模式：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">cpufreq-<span class="hljs-built_in">set</span> -c * -g <span class="hljs-built_in">MODE</span><br></code></pre></td></tr></table></figure><p>例如将四个核心全部ondemand：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gams">cpufreq-<span class="hljs-keyword">set</span> -c <span class="hljs-comment">0 -g ondemand</span><br>cpufreq-<span class="hljs-keyword">set</span> <span class="hljs-comment">-c 1 -g ondemand</span><br>cpufreq-<span class="hljs-keyword">set</span> <span class="hljs-comment">-c 2 -g ondemand</span><br>cpufreq-<span class="hljs-keyword">set</span> <span class="hljs-comment">-c 3 -g ondemand</span><br></code></pre></td></tr></table></figure><p>为了下次开机也自动生效，可以手动添加启动脚本。将其存成.sh，开启启动即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#/bin/bash</span><br>/opt/<span class="hljs-built_in">bin</span>/cpufreq-<span class="hljs-built_in">set</span> -c <span class="hljs-number">0</span> -g ondemand<br>/opt/<span class="hljs-built_in">bin</span>/cpufreq-<span class="hljs-built_in">set</span> -c <span class="hljs-number">1</span> -g ondemand<br>/opt/<span class="hljs-built_in">bin</span>/cpufreq-<span class="hljs-built_in">set</span> -c <span class="hljs-number">2</span> -g ondemand<br>/opt/<span class="hljs-built_in">bin</span>/cpufreq-<span class="hljs-built_in">set</span> -c <span class="hljs-number">3</span> -g ondemand<br></code></pre></td></tr></table></figure><h2 id="lm-sensors-风扇控制"><a href="#lm-sensors-风扇控制" class="headerlink" title="lm-sensors 风扇控制"></a>lm-sensors 风扇控制</h2><p>执行安装命令</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">ipkg <span class="hljs-keyword">install</span> lm-sensors<br></code></pre></td></tr></table></figure><p>查看温度</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sensors</span><br></code></pre></td></tr></table></figure><p>配置风扇控制，这块主要的目的只检测风扇在那一路，一般主板会涉及到多个风扇，但不一定都会安装，所以通过pwmconfig来检测与测试风扇的转速控制。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> pwmconfig<br></code></pre></td></tr></table></figure><p>使用fancontrol自动控制风扇转速，他的原理就是定时执行脚本，监控CPU温度、根据不同的温度区间控制PWM值，从而改变风扇的转速。<br>当转速降低了后，噪音自然就解决了。</p><p>fancontrol会依赖pwmconfig命令生成的配置文件。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs routeros">/etc/fancontrol<br><br>-----------配置内容如下--------------<br><span class="hljs-comment"># Configuration file generated by pwmconfig, changes will be lost</span><br><span class="hljs-attribute">INTERVAL</span>=10<br><span class="hljs-attribute">DEVPATH</span>=hwmon0=devices/platform/coretemp.0 <span class="hljs-attribute">hwmon1</span>=devices/platform/it87.2624<br><span class="hljs-attribute">DEVNAME</span>=hwmon0=coretemp <span class="hljs-attribute">hwmon1</span>=it8772<br><span class="hljs-attribute">FCTEMPS</span>=hwmon1/device/pwm2=hwmon0/device/temp3_input<br>FCFANS= hwmon1/device/<span class="hljs-attribute">pwm2</span>=hwmon1/device/fan2_input<br><span class="hljs-attribute">MINTEMP</span>=hwmon1/device/pwm2=20<br><span class="hljs-attribute">MAXTEMP</span>=hwmon1/device/pwm2=60<br><span class="hljs-attribute">MINSTART</span>=hwmon1/device/pwm2=150<br><span class="hljs-attribute">MINSTOP</span>=hwmon1/device/pwm2=100<br></code></pre></td></tr></table></figure><p>默认生成的配置基本能够满足需求，经过测试风扇在2000转左右噪音相对能够接受。</p><h2 id="VideoStation"><a href="#VideoStation" class="headerlink" title="VideoStation"></a>VideoStation</h2><p>参考：</p><p><a href="https://zhuanlan.zhihu.com/p/357332211">关于群晖NAS video station TMDB连接测试失败及搜刮结果下载失败的解决方案</a></p><p><a href="https://zhuanlan.zhihu.com/p/152351243">（群晖）关于Video Station内电影及电视剧封面简介为空白的处理方法</a></p><h3 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤"></a>步骤</h3><ul><li><p>TMDB的图片服务器被屏蔽需要修改hosts 加上 api.themoviedb.org 的ip</p></li><li><p>修改hosts后即可测试，已经连通</p></li><li><p>搜刮信息会出现下载失败，主要是下载图片的url需要切换一下</p><p>  编辑 util_themoviedb.php 文件</p>  <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">cd /var/packages/VideoStation/target/plugins<br>vi util_themoviedb.php<br></code></pre></td></tr></table></figure>  <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text"># 找到下面的语句<br>define(&#x27;API_URL&#x27;, &#x27;https://api.themoviedb.org/3/&#x27;);<br>define(&#x27;BANNER_URL&#x27;, &#x27;https://image.tmdb.org/t/p/w500&#x27;);<br>define(&#x27;BACKDROUP_URL&#x27;, &#x27;https://image.tmdb.org/t/p/original&#x27;);<br><br># 我们只需要把改为<br>image.tmdb.org<br># 改为<br>www.themoviedb.org<br></code></pre></td></tr></table></figure></li></ul><h2 id="Gogs"><a href="#Gogs" class="headerlink" title="Gogs"></a>Gogs</h2><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/cfan927/article/details/100862989">【工具】群晖利用docker安装Gogs代码管理平台</a></p><h3 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤"></a>步骤</h3><ol><li><p>打开“Docker”-&gt;”注册表”，搜索Gogs并“右键”-&gt;“下载此映像”</p><p><img src="/2021/ee60585b/watermark.png" alt="在这里插入图片描述"></p></li><li><p>在”映像“页面中安装Gogs容器后，切换到”容器“页面，然后双击打开Gogs详情页</p><ol><li>设定容器的本地端口</li><li>设定桌面快捷方式</li></ol></li><li><p>Gogs配置</p><ol><li><p>数据库类型。</p><p>这里我是个人用，所以就选<code>SQLite</code>，比较好备份，备份的时候可以整个打包走。</p><p>如果选用mariaDB就按下面的步骤配置</p><blockquote><ol><li><p>Windows中用ssh登录群晖服务器，cd到mariaDB目录下：</p><p> <code>cd /volume1/@appstore/MariaDB10/usr/local/mariadb10/bin/</code></p></li><li><p>输入命令 <code>./mysql -u root -p</code>，然后输入密码，连接数据库</p></li><li><p>输入命令 <code>use mysql</code>切换到mysql数据库</p></li><li><p>创建数据库gogs<br> <code>CREATE DATABASE IF NOT EXISTS gogs;</code></p></li><li><p>输入下面的命令获取数据库远程访问权限 ：</p><p> <code>GRANT ALL PRIVILEGES ON gogs.* TO &#39;user&#39;@&#39;%&#39; IDENTIFIED BY &#39;password&#39; WITH GRANT OPTION;</code><br> 其中user为用户名<br> password为用户密码</p></li><li><p>然后用<code>show databases;</code>命令查看一下结果</p></li></ol></blockquote></li><li><p>ssh建议使用内置ssh服务器，注意的是使用内置ssh服务器的时候就不能再使用22端口了，需要改掉</p></li><li><p>HTTP端口和应用URL这里需要注意，如果配置了bredge网络，这里是端口是gogs的端口，应用URL的端口是对外的配置网络时候配置的端口。</p></li></ol></li><li><p>gogs:port 设定相关参数即可</p></li><li><p>着重需要说明的是：</p><ol><li>NULL</li></ol></li><li><p>tips</p><ol><li>删除数据库  <code>DROP DATABASE gogs;</code></li></ol></li></ol><h3 id="Note-1"><a href="#Note-1" class="headerlink" title="Note"></a>Note</h3><ul><li>gogs 的配置保存在<code>/data/gogs/conf/app.ini</code> 参考下图</li></ul><p><img src="/2021/ee60585b/image-20211103161058734.png" alt="image-20211103161058734"></p><ul><li><strong>注意</strong> MariaDB的port默认是不开的，需要去套件里面打开。</li></ul><blockquote><ol><li><strong>Domain</strong> 填写Docker宿主机的物理IP地址，或者域名地址,注意这里是不带 http的 如： 192.168.137.140 或 git.mydomain.com</li><li><strong>SSH port</strong> 假如Docker映射的端口是 10022:22 那么这里就填写宿主机开放的端口 10022</li><li><strong>HTTP port</strong> 假如Docker映射的端口是 10080:3000 这里要填容器内的监听端口 3000</li><li><strong>Application URL</strong> 这里要填写的格式为 http(s)?&#x2F; + Domain + HTTP port ，比如：<a href="http://git.mydomain.com/10080">http://git.mydomain.com/10080</a> 。还需要注意的一点是，如果你用了nginx来映射宿主机的 10080 端口，这里要去掉后面的端口，即 <a href="http://git.mydomain.com/%EF%BC%8C%E8%AF%B4%E7%99%BD%E4%BA%86%E5%B0%B1%E6%98%AF%E4%BD%A0%E5%9C%A8%E5%A4%96%E9%83%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8A%E8%AE%BF%E9%97%AE%E7%9A%84%E5%9C%B0%E5%9D%80%E3%80%82">http://git.mydomain.com/，说白了就是你在外部浏览器上访问的地址。</a></li></ol></blockquote><ul><li><strong>注意</strong>非标准port的ssh需要注意clone地址是否正确</li></ul><h4 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h4><p><a href="https://github.com/gogs/gogs/discussions/6876">https://github.com/gogs/gogs/discussions/6876</a></p><ul><li><strong>数据备份</strong></li><li>因为容器内的 <code>/data</code> 目录是直接挂载到宿主机的，我们把容器内备份目录设置为 <code>/data</code> ， 方便宿主机将备份文件同步到远程备份服务器。</li><li>这是直接在宿主机上执行的命令。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker container exec gogs su - git -s /bin/ash \<br>-c &quot;/app/gogs/gogs backup \<br>--config=/data/gogs/conf/app.ini \<br>--target=/data&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">注意挂载目录的权限</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">也可以在docker命令行中手动执行命令来备份</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">打开命令交互窗口</span><br>docker exec -ti gogs bash<br><span class="hljs-meta prompt_"># </span><span class="language-bash">gogs是git用户运行的 需要 先切换到git用户</span><br>su - git <br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看备份命令的格式</span><br>/app/gogs/gogs backup -h<br><span class="hljs-meta prompt_"># </span><span class="language-bash">执行备份  config自然就是配置文件了 target是输出的目录</span><br>/app/gogs/gogs backup --config=/data/gogs/conf/app.ini --target=/data/<br></code></pre></td></tr></table></figure><ul><li><p><strong>数据恢复</strong></p></li><li><p>用docker<strong>完成gogs部署</strong>之后，执行下面命令</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker container exec -it gogs su - git -s /bin/ash \<br>-c &quot;/app/gogs/gogs restore \<br>--config=/data/gogs/conf/app.ini \<br>--tempdir=/data \<br>--from=/data/gogs-backup-20211230091744.zip&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">同样的这里如果手动执行的话就是这样的啦</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">记得先在docker部署好gogs</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">打开命令交互窗口</span><br>docker exec -ti gogs bash<br><span class="hljs-meta prompt_"># </span><span class="language-bash">gogs是git用户运行的 需要 先切换到git用户</span><br>su - git <br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看恢复命令的格式</span><br>/app/gogs/gogs restore -h<br><span class="hljs-meta prompt_"># </span><span class="language-bash">执行恢复</span><br>/app/gogs/gogs restore --config=/data/gogs/conf/app.ini --tempdir=/data --from=/data/gogs-backup-xxx.zip<br></code></pre></td></tr></table></figure><ul><li><p><strong>注意：</strong></p></li><li><p>备份和恢复时，使用的 gogs 版本必须是一致的</p></li><li><p>备份和恢复时，使用的 mysql 版本必须是一致的</p></li></ul><h4 id="自述文档"><a href="#自述文档" class="headerlink" title="自述文档"></a>自述文档</h4><p>Create a plain text file then move to directory <code>custom/conf/readme/README</code> and <strong>restart Gogs.</strong></p><ul><li><code>&#123;Name&#125;</code>: Repository name</li><li><code>&#123;Description&#125;</code>: Repository description</li><li><code>&#123;CloneURL.SSH&#125;</code>: Repository SSH clone address</li><li><code>&#123;CloneURL.HTTPS&#125;</code>: Repository HTTP&#x2F;HTTPS clone address</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">&#123;Name&#125;</span><br>&#123;Name&#125; Repository<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># Tip</span></span><br>You can get the development version of this repo via<br>**git clone &#123;CloneURL.SSH&#125;**<br>or<br>**git clone &#123;CloneURL.HTTPS&#125;**<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># Bref</span></span><br>&#123;Description&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># Details</span></span><br><br></code></pre></td></tr></table></figure><h2 id="zerotier"><a href="#zerotier" class="headerlink" title="zerotier"></a>zerotier</h2><table><thead><tr><th>img name</th><th>last version</th><th>notes</th></tr></thead><tbody><tr><td>henrist-zerotier-one1</td><td>1.6.6</td><td>没有自动配置路由</td></tr><tr><td>bltavares zerotier</td><td>1.6.6</td><td>网络不通</td></tr><tr><td>zyclonite&#x2F;zerotier&#x2F;</td><td>1.8.4</td><td>没有自动配置路由 配置路由后正常</td></tr><tr><td>spikhalskiy-zerotier1</td><td>1.8.2</td><td>运行会报错<code>zerotier-cli: /usr/lib/libstdc++.so.6: no version information available (required by zerotier-cli)</code>, 没有自动配置路由 配置路由后正常</td></tr><tr><td>zerotier-zerotier-synology</td><td>1.8.4</td><td>没有自动配置路由 配置路由后正常</td></tr></tbody></table><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs livescript">docker run <span class="hljs-string">\</span><br>  -d <span class="hljs-string">\</span><br>  --restart always <span class="hljs-string">\</span><br>  --name zerotier-one <span class="hljs-string">\</span><br>  --device /dev/net/tun <span class="hljs-string">\</span><br>  --net host <span class="hljs-string">\</span><br>  --cap-add NET_ADMIN <span class="hljs-string">\</span><br>  --cap-add SYS_ADMIN <span class="hljs-string">\</span><br>  -v /<span class="hljs-keyword">var</span>/lib/zerotier-one:/<span class="hljs-keyword">var</span>/lib/zerotier-one <span class="hljs-string">\</span><br>  zerotier/zerotier-synology<br></code></pre></td></tr></table></figure><h2 id="第三方套件"><a href="#第三方套件" class="headerlink" title="第三方套件"></a>第三方套件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">矿神</span><br>https://spk.imnks.com/<br></code></pre></td></tr></table></figure><h2 id="群晖的备份-还原"><a href="#群晖的备份-还原" class="headerlink" title="群晖的备份 还原"></a>群晖的备份 还原</h2><p>晖硬盘接到电脑上使用diskgenius查看，有三个分区：系统、swap交换分区、数据存储区，所有的硬盘都有这三个分区。</p><blockquote><p>  交换分区，英文是swap，意思是“交换”、“实物交易”。 它的功能就是在内存不够的情况下，操作系统先把内存中暂时不用的数据，存到硬盘的交换空间，腾出内存来让别的程序运行，和Windows的虚拟内存（pagefile.sys）的作用是一样的。</p></blockquote><p><img src="/2021/ee60585b/image-20220918161100014.png" alt="image-20220918161100014"></p><p>弄清楚这三个分区是做什么的就很简单了, 我们备份和还原自然也就是备份和还原第一个系统分区了.</p><p>需要注意的是群晖的系统存在于任何一块硬盘内, <strong>所以还原分区的时候需要将分区还原到每一块硬盘内才行</strong>.</p><blockquote><p>  如果只还原一块后，开机进入系统，系统会提示修复，虽然也能成功但是并不建议这么做</p></blockquote><h2 id="群晖-硬盘扩容-硬盘升级"><a href="#群晖-硬盘扩容-硬盘升级" class="headerlink" title="群晖 硬盘扩容 硬盘升级"></a>群晖 硬盘扩容 硬盘升级</h2><p>紧跟上面, 如果我们需要进行硬盘扩容, 比如原来的硬盘128G, 现在购入一块新硬盘256G, 我们需要用256去替换原来的硬盘, 但是现有设备上盘位已经插满了或者是属于单盘位的机器, 这时候就要把硬盘拆下来手动将数据进行转移.</p><blockquote><p>  我的大致思路是使用DG全盘拷贝到256G硬盘上(当时尝试的时候没有找到这方面的文章, 不知道该怎么样操作, 担心数据出问题所以就用了全盘拷贝), 然后上电开机SSH登录上去扩容一下分区就好.</p></blockquote><p><strong>克隆数据</strong></p><p>首先打开<code>DiskGenius</code>软件 选择 -&gt; <code>工具</code> -&gt; <code>克隆磁盘</code> 我这里选的是按扇区全盘克隆.</p><p>讲道理来说将<code>系统区</code>、<code>数据存储区</code>拷贝过去, 再划分出<code>swap交换分区</code>应该也是可以的.</p><p>等待克隆完成.</p><p><strong>扩容分区</strong></p><p>磁盘克隆完成后, 旧的硬盘先不能格式化掉, 需要先留着以防万一.</p><p>将新的硬盘安装回群晖, 并上电开机, 开机一切正常, 查看存储管理器会发现, 256的磁盘只显示了128G, 这个时候我们就需要登录SSH进行下一步操作了.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 首先查看一下新放进去的盘的挂载位置</span><br>$ fdisk -l<br>Disk /dev/sda: 232.9 GiB, 250059350016 bytes, 488397168 sectors<br>Units: sectors of 1 * 512 = 512 bytes<br>Sector size (logical/physical): 512 bytes / 512 bytes<br>I/O size (minimum/optimal): 512 bytes / 512 bytes<br>Disklabel <span class="hljs-built_in">type</span>: dos<br><br><span class="hljs-comment"># 上面可以看到 设备在`/dev/sda` 这里的sda里面的a是按顺序来的 第二个第三个盘就是sdb sdc 类推</span><br><span class="hljs-comment"># 输入命令后它会让我们输入结束地址, 我们这里直接回车, 设定地址为最末尾</span><br>$ parted /dev/sda resizepart 3<br>End?  [250GB]?<br>Information: You may need to update /etc/fstab.<br><br><span class="hljs-comment"># 这里运行的时候报错了, 但是时间有点久没有记录下来给忘记了, 哎这些东西还是不能拖, 要立刻记录下来才行</span><br>$ resize2fs -f /dev/sda3 <br>resize2fs 1.42.6 (21-Sep-2012)<br>.....<br><br><span class="hljs-comment"># 再次查看扩容完成</span><br>$ fdisk -l<br></code></pre></td></tr></table></figure><p><strong>参考:</strong></p><p><a href="https://imnks.com/389.html">群晖升级硬盘 磁盘克隆后的简单扩容教程</a></p><h2 id="PVE-Exsi-硬盘扩容"><a href="#PVE-Exsi-硬盘扩容" class="headerlink" title="PVE Exsi 硬盘扩容"></a>PVE Exsi 硬盘扩容</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo fdisk /dev/sdb<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">输入 p 查考分区情况</span><br>Command (m for help): p<br><br>Disk /dev/sdb: 64 GiB, 68719476736 bytes, 134217728 sectors<br>Disk model: HARDDISK<br>Units: sectors of 1 * 512 = 512 bytes<br>Sector size (logical/physical): 512 bytes / 512 bytes<br>I/O size (minimum/optimal): 512 bytes / 512 bytes<br>Disklabel type: dos<br>Disk identifier: 0x6776aa49<br><br>Device     Boot    Start      End  Sectors  Size Id Type<br>/dev/sdb1           8192 16785407 16777216    8G fd Linux raid autodetect<br>/dev/sdb2       16785408 20979711  4194304    2G fd Linux raid autodetect<br>/dev/sdb3       21241856 66904063 45662208 21.8G fd Linux raid autodetect<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">输入 q 退出</span><br>Command (m for help): q<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">输入命令，给存储池扩容（命令中的3，对应/dev/sdb3）</span><br>parted /dev/sdb resizepart 3 100%<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">再次使用此命令查看分区表是否正确</span><br>sudo fdisk /dev/sdb<br></code></pre></td></tr></table></figure><p>shell操作完成后在群晖的存储管理器，就看到系统提示”<strong>检测到未使用的硬盘空间，请单击立即扩充以扩充此存储池</strong>“，点蓝色的”<strong>立即扩充</strong>“；</p><h2 id="群晖安装USB网卡驱动-AX88179A-6-2-3"><a href="#群晖安装USB网卡驱动-AX88179A-6-2-3" class="headerlink" title="群晖安装USB网卡驱动 AX88179A 6.2.3"></a>群晖安装USB网卡驱动 AX88179A 6.2.3</h2><p><img src="/2021/ee60585b/image-20220926214605083.png" alt="image-20220926214605083"></p><ol><li><p>将USB网卡插入群晖</p></li><li><p>下载驱动程序 <a href="%E7%BE%A4%E6%99%96.assets/ax88179_178a.ko.zip">ax88179_178a.ko.zip</a></p></li><li><p>解压后将<code>ax88179_178a.ko</code>文件复制到群晖的<code>/lib/modules/</code>目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> /volume......./ax88179_178a.ko /lib/modules<br></code></pre></td></tr></table></figure></li><li><p>使用命令 <code>chmod 644 ax88179_178a.ko</code>修改文件权限为<code>-rw-r--r--</code></p></li><li><p>加载驱动<code>insmod /lib/modules/ax88179_178a.ko </code> </p><ol><li><p>我这里当时报错了, 但是似乎并没有什么影响</p></li><li><p><code>insmod: ERROR: could not insert module /lib/modules/ax88179_178a.ko: Invalid module format</code></p></li><li><p>拓展一下</p><blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 获取已加载的驱动列表</span><br>lsmod<br><span class="hljs-comment"># 卸载驱动</span><br><span class="hljs-comment"># 参数为lsmod获取到的驱动名称，而不是路径</span><br>rmmod ax88179_178a<br></code></pre></td></tr></table></figure></blockquote></li></ol></li><li><p>启用网卡 <code>ifconfig eth1 up</code></p></li><li><p>重新启动</p></li></ol><blockquote><p>  网上很多blog写需要添加启动项, 但是我这里并没有添加 看起来也没有什么问题.</p><p>  添加启动项的操作是在群晖的<code>设置</code>里面 添加一个<code>任务计划</code>开机触发执行下面这个脚本</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">insmod /lib/modules/ax88179_178a.ko<br>ifconfig eth1 up<br></code></pre></td></tr></table></figure></blockquote><h2 id="PC通过群晖的网卡桥接上网"><a href="#PC通过群晖的网卡桥接上网" class="headerlink" title="PC通过群晖的网卡桥接上网"></a>PC通过群晖的网卡桥接上网</h2><p><strong>注意</strong>:首先需要确定Open vSwitch是开启的. 控制面板-&gt;网络-&gt;网络界面-&gt;管理，打开Open vSwitch（如果使用了VMM套件会自动开启，而且提示无法禁用）.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 路径图</span><br>网关(路由器) &lt;-eth0-&gt; 群晖 &lt;-eth1-&gt; PC<br></code></pre></td></tr></table></figure><p>装了群晖的Virtual Machine Manager后一个接口会多出来一块网卡, 其中<code>eth0</code>是物理网卡, <code>ovs_eth0</code>是Open vSwitch这个网络管理工具虚拟出来的网卡.</p><p>一般来说<code>eth0</code>会空闲, 流量都是通过<code>ovs_eth0</code>这个虚拟网卡, 其中<code>eth0</code>会被配置成与<code>ovs_eth0</code>桥接</p><hr><p><strong>修改配置文件</strong></p><p>如你的电脑接在群晖的第一个网口<code>eth0</code>就修改<code>ifcfg-eth0</code>，接的是第二个网口<code>eth1</code>就修改<code>ifcfg-eth1</code>(本例)。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 编辑</span><br>vim /etc/sysconfig/network-scripts/ifcfg-eth1<br><span class="hljs-comment"># 将BRIDGE 改成ovs_eth0</span><br><span class="hljs-comment"># 原BRIDGE=ovs_eth1</span><br>BRIDGE=ovs_eth0<br><br></code></pre></td></tr></table></figure><blockquote><p>   <code>/etc/sysconfig/network-scripts/ifcfg-eth1</code>文件参数简介</p><p>  <img src="/2021/ee60585b/1841273-20191019215624473-1921771223.png" alt="img"></p></blockquote><p><strong>命令修改</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看当前网桥 可以看到有两个网桥 ovs_eth0 和 ovs_eth1</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">ovs-vsctl show</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">我们将网桥 ovs_eth1 删除, 并将 eth1 加入到 网桥ovs_eth0</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">ovs-vsctl del-br ovs_eth1</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">ovs-vsctl add-port ovs_eth0 eth1</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">再次查看网桥状态</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">ovs-vsctl show</span><br>Bridge &quot;ovs_eth0&quot;<br>        Port &quot;eth1&quot;<br>            Interface &quot;eth1&quot;<br>        Port &quot;eth0&quot;<br>            Interface &quot;eth0&quot;<br>        Port &quot;ovs_eth0&quot;<br>            Interface &quot;ovs_eth0&quot;<br>                type: internal<br><span class="hljs-meta prompt_"># </span><span class="language-bash">此时eth0和eth1全部在ovs_eth0内，即两个网口处于同一个交换机内。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将eth1和电脑相连，发现电脑可以正常从路由器获取IP地址，并正常上网</span><br></code></pre></td></tr></table></figure><h2 id="PC通过群晖的网卡NAT上网"><a href="#PC通过群晖的网卡NAT上网" class="headerlink" title="PC通过群晖的网卡NAT上网"></a>PC通过群晖的网卡NAT上网</h2><p>这里主要是利用<code>iptable</code>路由流量.</p><p>首先补个<code>iptable</code>的教程</p><p><a href="https://wooyun.js.org/drops/Iptables%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B.html">Iptables入门教程</a></p><ol><li>我们需要先给<code>局域网2 eth1</code>设置一个静态ip <code>192.168.88.1/24 gw 192.168.88.1</code></li><li>然后在DHCP服务器端开启<code>局域网2 eth1</code>的DHCP服务, 网关填<code>192.168.88.1</code></li><li>然后配置<code>iptable</code>开启网口转发</li></ol><p><img src="/2021/ee60585b/image-20221121215936519.png" alt="image-20221121215936519"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">开启群晖的转发功能</span><br>echo &quot;1&quot; &gt; /proc/sys/net/ipv4/ip_forward<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">为PC添加 去往群晖的 路由表 群晖开了对应接口的DHCP就不需要了</span><br>route add -net 192.168.88.0/24 gw 192.168.88.1<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在群晖中添加iptable 策略</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">配置 NAT 服务器，执行命令</span><br>iptables -t nat -A POSTROUTING -s 192.168.88.0/24 -o ovs_eth0 -j MASQUERADE<br><span class="hljs-meta prompt_"># </span><span class="language-bash">-t 表名</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-A 在指定链的末尾添加（--append）一条新的规则</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-s 指定数据包的源地址参数，可以使IP地址、网络地址、主机名</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">   192.168.88.0 表示 192.168.88.x 的整个网络。</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">-o 输出接口</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">-j 目标动作或跳转</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">   MASQUERADE 则表示从 NAT 服务器的网卡上自动获取当前的 IP 地址来做端口转发。否则，基于目标的网络地址转换模式（即 DNAT）需要在每次 NAT 服务器连接外网的 IP 地址变更的时候重新配置端口转发。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">也可以使用源地址目标转换模式（即 SNAT），命令是</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">** 这里和上面选其一即可 **</span><br>iptables -t nat -A POSTROUTING -s 192.168.88.0/24 -o ovs_eth0 -j SNAT --to-source 192.168.20.2<br><span class="hljs-meta prompt_"># </span><span class="language-bash">显然这种方式也会依赖命令中指定的通向外网的 IP 地址，所以仍然不够灵活。推荐使用第一种方式。</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">允许端口转发</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">此命令将允许经过 eth1 网卡（连接内网）的所有数据包通向外网的转发。</span><br>iptables -A FORWARD -i eth1 -j ACCEPT<br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者 仅允许转发192.168.88.0/24段的报文</span><br>iptables -A FORWARD -s 192.168.88.0/24 -j ACCEPT<br></code></pre></td></tr></table></figure><p><strong>参考</strong></p><p><a href="https://blog.csdn.net/liuzhanchun/article/details/106819839">Linux 内部路由实现及网口转发之理论篇</a></p><p><a href="https://blog.csdn.net/luozhen07/article/details/48051005">Linux 系统双网卡实现内网端口转发</a></p>]]></content>
    
    
    <categories>
      
      <category>more_interest</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>synology</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决 Github 无法打开</title>
    <link href="/2021/db5fa6fe/"/>
    <url>/2021/db5fa6fe/</url>
    
    <content type="html"><![CDATA[<h1 id="解决-Github-无法打开"><a href="#解决-Github-无法打开" class="headerlink" title="解决 Github 无法打开"></a>解决 Github 无法打开</h1><h2 id="SwitchHosts"><a href="#SwitchHosts" class="headerlink" title="SwitchHosts"></a>SwitchHosts</h2><ol><li><p>下载 SwitchHosts <a href="https://github.com/oldj/SwitchHosts">Github</a> 下载要是太慢可以 用gitee镜像一下github的库 这里放一个别人镜像过的 <a href="https://gitee.com/itas109/SwitchHosts?_from=gitee_search">Gitee</a></p></li><li><p>安装后新建一个配置</p><ul><li>Title: 随意  Type: Remote  URL:   Auto Refresh: 最好选 1 hour</li></ul><p><img src="/2021/db5fa6fe/image-20211015220230835.png" alt="image-20211015220230835"></p><ul><li>可选的URL：<ul><li>520Github <a href="https://raw.hellogithub.com/hosts">https://raw.hellogithub.com/hosts</a></li><li>ineo6 <a href="https://gitee.com/ineo6/hosts/raw/master/hosts">https://gitee.com/ineo6/hosts/raw/master/hosts</a></li><li>有看到网上还有多个网站同时更新的，但是看到更新速度不够快，也就放弃了。</li></ul></li></ul></li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://github.com/ineo6/hosts">https://github.com/ineo6/hosts</a></p><p><a href="https://github.com/521xueweihan/GitHub520">https://github.com/521xueweihan/GitHub520</a></p><h2 id="Chrome-插件方式"><a href="#Chrome-插件方式" class="headerlink" title="Chrome 插件方式"></a>Chrome 插件方式</h2><p><a href="https://github.com/gauseen/faster-hosts">FasterHosts</a> 是个 Chrome 插件，主要原理是拦截浏览器的某些请求，将 <code>domain</code> 替换成访问速度较快的那个。hosts 资源来自 <a href="https://github.com/521xueweihan/GitHub520">GitHub520</a>，每 1 小时更新一次。</p><blockquote><ol><li>下载 <a href="https://github.com/gauseen/faster-hosts/archive/master.zip">FasterHosts</a> 然后解压，找到 <code>extension</code> 子目录</li><li>打开 Chrome，输入: <code>chrome://extensions/</code></li><li>打开「开发者模式」</li><li>选择「加载已解压的扩展程序」，然后定位到刚才解压的文件夹里面的 <code>extension</code> 目录，确定</li><li>这就安装好了，关闭「开发者模式」</li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github</tag>
      
      <tag>hosts</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派连上手机热点如何查看它的IP</title>
    <link href="/2021/6561f7ab/"/>
    <url>/2021/6561f7ab/</url>
    
    <content type="html"><![CDATA[<p>关键词:</p><p>手机 热点 查看 接入 热点 IP 树莓派连上手机热点如何查看它的IP</p><h1 id="树莓派连上手机热点如何查看它的IP"><a href="#树莓派连上手机热点如何查看它的IP" class="headerlink" title="树莓派连上手机热点如何查看它的IP"></a>树莓派连上手机热点如何查看它的IP</h1><h1 id="序："><a href="#序：" class="headerlink" title="序："></a>序：</h1><h4 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h4><p>原来都是通过网线连接树莓派的，当时设置过wifi，这次把树莓派带出去用，就没有带网线，手机上显示已经连接上了，但是不知道怎么查看树莓派的ip。相信点进来的都是小米手机把，点名批评小米，隔壁华为荣耀都能直接看到。</p><h4 id="通过阅读本文你能知道什么？"><a href="#通过阅读本文你能知道什么？" class="headerlink" title="通过阅读本文你能知道什么？"></a>通过阅读本文你能知道什么？</h4><ul><li>如何通过app查看连上热点的ip</li></ul><p>如果本文对你有帮助，请不要吝啬你的点赞，让别人也能看到，如果你有更好的见解，非常希望你能提出指导意见！</p><p>@[toc]</p><h1 id="软件："><a href="#软件：" class="headerlink" title="软件："></a>软件：</h1><p><strong>终端</strong> or <strong>Terminal Emulator</strong><br>各大应用商店可下，实在不行可以从<a href="https://jackpal.github.io/Android-Terminal-Emulator/">这个页面</a>下载</p><h1 id="详细："><a href="#详细：" class="headerlink" title="详细："></a>详细：</h1><p>输入指令 <strong>ip neigh</strong> 就能获得相关的ip地址信息<br><img src="/2021/6561f7ab/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Li05rW355qE5Z-O,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="树莓派"></p>]]></content>
    
    
    <categories>
      
      <category>raspberry</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ip</tag>
      
      <tag>raspberry</tag>
      
      <tag>ap</tag>
      
      <tag>wifi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>J-Link RTT的使用方法</title>
    <link href="/2021/18d811b/"/>
    <url>/2021/18d811b/</url>
    
    <content type="html"><![CDATA[<h1 id="J-Link-RTT-JTrace"><a href="#J-Link-RTT-JTrace" class="headerlink" title="J-Link RTT &amp; JTrace"></a>J-Link RTT &amp; JTrace</h1><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>Jlink可用直接输出调试信息，省去串口工具（配置麻烦+硬件接线乱+占用IO）</p><p>Jlink输出调试信息有两种</p><ul><li>Jlink的Trace</li><li>Jlink的RTT (Real Time Transfer)</li></ul><h2 id="Jlink-Trace"><a href="#Jlink-Trace" class="headerlink" title="Jlink Trace"></a>Jlink Trace</h2><hr><p>！！！待完善！！！</p><hr><p>MDK 环境下：</p><p><img src="/2021/18d811b/132307095276873.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ITM_Port8(n)    (*((volatile unsigned char *)(0xE0000000+4*n)))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ITM_Port16(n)   (*((volatile unsigned short*)(0xE0000000+4*n)))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ITM_Port32(n)   (*((volatile unsigned long *)(0xE0000000+4*n)))</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEMCR           (*((volatile unsigned long *)(0xE000EDFC)))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TRCENA          0x01000000</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fputc</span><span class="hljs-params">(<span class="hljs-type">int</span> ch, FILE *f)</span> <br>&#123;<br>  <span class="hljs-keyword">if</span> (DEMCR &amp; TRCENA) &#123;<br>    <span class="hljs-keyword">while</span> (ITM_Port32(<span class="hljs-number">0</span>) == <span class="hljs-number">0</span>);<br>    ITM_Port8(<span class="hljs-number">0</span>) = ch;<br>  &#125;<br>  <span class="hljs-keyword">return</span>(ch);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="RTT"><a href="#RTT" class="headerlink" title="RTT"></a>RTT</h2><p><a href="https://www.segger.com/products/debug-probes/j-link/technology/about-real-time-transfer/">Jlink RTT 官网资料</a></p><p>RTT其实原理就是读取RAM上某个Buff的数据，这个Buff可以通过RTT的CB(control block)找到。</p><h3 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h3><p>下载Jlink的工具后，安装后程序目录有Samples文件夹(default: C:\Program Files\SEGGER\JLink\Samples)，文件夹内就有RTT的源码。</p><ol><li>将源码的<code>RTT/</code>目录下 <code>SEGGER_RTT_Printf.c</code>  <code>SEGGER_RTT.c</code> 两个文件添加到工程里，并解决头文件包含问题。</li><li>看 <code>Examples/</code>目录下就有使用历程，移植到你的工程就好。可以参考<code>Main_RTT_InputEchoApp.c</code>和<code>Main_RTT_PrintfTest.c</code>。</li><li>打开 <code>J-Link RTT Viewer</code>软件，选择<code>Device</code>，输入<code>RTT Control Block</code>的地址connect即可。<ol><li><code>RTT Control Block</code>的地址可以输入RAM的范围让<code>J-Link RTT Viewer</code>软件自己去搜索。</li><li>也可手动输入，而RTT_V754a的<code>RTT Control Block</code>是<code>_SEGGER_RTT</code> 在<code> file:SEGGER_RTT.c line:279</code>。<img src="/2021/18d811b/image-20210917214218565.png" alt="image-20210917214218565"></li></ol></li><li>一顿操作下来正常就可以收到数据了。</li></ol><h3 id="RTT-源码"><a href="#RTT-源码" class="headerlink" title="RTT 源码"></a>RTT 源码</h3><h4 id="Included-files"><a href="#Included-files" class="headerlink" title="Included files"></a>Included files</h4><ul><li><code>RTT/</code><ul><li><code>SEGGER_RTT.c</code>               - RTT的主要模块。</li><li><code>SEGGER_RTT.h</code>               - RTT的主要模块。</li><li><code>SEGGER_RTT_ASM_ARMv7M.S</code>    - ARMv7M 的优化实现</li><li><code>SEGGER_RTT_Printf.c</code>        - (‘ SEGGER_RTT_Printf() ‘)的简单实现。</li></ul></li><li><code>Syscalls/</code><ul><li><code>SEGGER_RTT_Syscalls_*.c</code>    - <code>printf()</code> 重定向</li></ul></li><li><code>Config/</code><ul><li><code>SEGGER_RTT_Conf.h</code>          - RTT配置文件。</li></ul></li><li><code>Examples/</code><ul><li><code>Main_RTT_InputEchoApp.c</code>    - Example application which echoes input on Channel 0.</li><li><code>Main_RTT_MenuApp.c</code>         - Example application to demonstrate RTT bi-directional functionality.</li><li><code>Main_RTT_PrintfTest.c</code>      - Example application to test RTT’s simple printf implementation.</li><li><code>Main_RTT_SpeedTestApp.c</code>    - Example application to measure RTT performance. (Requires embOS)</li></ul></li></ul><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><table><thead><tr><th align="center">函数名称</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">SEGGER_RTT_Read()</td><td align="center">从输入缓冲区读取数据。</td></tr><tr><td align="center">SEGGER_RTT_Write()</td><td align="center">将数据写入输出缓冲区。</td></tr><tr><td align="center">SEGGER_RTT_WriteString()</td><td align="center">将\0结尾字符串写入输出缓冲区。</td></tr><tr><td align="center">SEGGER_RTT_printf()</td><td align="center">将格式化的字符串写入输出缓冲区。</td></tr><tr><td align="center">SEGGER_RTT_GetKey()</td><td align="center">从输入缓冲区 0 中获取一个字符。</td></tr><tr><td align="center">SEGGER_RTT_HasKey()</td><td align="center">检查输入缓冲区 0 中是否有字符可用。</td></tr><tr><td align="center">SEGGER_RTT_WaitKey()</td><td align="center">等待输入缓冲区 0 中的字符可用并获取它。</td></tr><tr><td align="center">SEGGER_RTT_ConfigUpBuffer()</td><td align="center">配置向上（输出）缓冲区。</td></tr><tr><td align="center">SEGGER_RTT_ConfigDownBuffer()</td><td align="center">配置向下（输入）缓冲区。</td></tr><tr><td align="center">SEGGER_RTT_Init()</td><td align="center">仅使用 RAM 目标时初始化 RTT 控制块结构。</td></tr><tr><td align="center">SEGGER_RTT_SetTerminal()</td><td align="center">将“虚拟”终端设置为通过 Write 和 WriteString 用于通道 0 上的输出。</td></tr><tr><td align="center">SEGGER_RTT_TerminalOut()</td><td align="center">通过“虚拟”终端发送以\0结尾的字符串。</td></tr></tbody></table><h3 id="RTT-软件"><a href="#RTT-软件" class="headerlink" title="RTT 软件"></a>RTT 软件</h3><p><img src="/2021/18d811b/image-20210918101414512.png" alt="image-20210918101414512"></p><ul><li><p><code>J-Link RTT Viewer</code>软件用的比较多</p></li><li><p><code>J-Link RTT Logger</code>软件可以将输出的数据保存到文件，并显示通信速率和通信数据量。</p></li><li><p><code>J-Link RTT Client</code>可以在调试的时候，充当客户端，输出数据。据说支持中文</p></li></ul><h3 id="note："><a href="#note：" class="headerlink" title="note："></a>note：</h3><ul><li>程序如果跑在RAM中，J-Link可能会错误地识别出init部分中的块，而不是数据部分中的实际块。为了防止这种情况，将SEGGER_RTT_IN_RAM的定义设置为1。现在，J-Link将在应用程序中调用第一个SEGGER_RTT函数之后找到正确的RTT缓冲区。建议在应用程序开始时调用SEGGER_RTT_Init()。</li></ul><h4 id="不同通道输出数据"><a href="#不同通道输出数据" class="headerlink" title="不同通道输出数据"></a>不同通道输出数据</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">SEGGER_RTT_TerminalOut(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;SEGGER_RTT_TerminalOut 0\r\n&quot;</span>);<br>SEGGER_RTT_TerminalOut(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;SEGGER_RTT_TerminalOut 1\r\n&quot;</span>);<br>SEGGER_RTT_TerminalOut(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;SEGGER_RTT_TerminalOut 2\r\n&quot;</span>);<br><br><br><br>SEGGER_RTT_SetTerminal(<span class="hljs-number">0</span>);<br>SEGGER_RTT_printf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;SEGGER_RTT_printf 0\r\n&quot;</span>);<br>SEGGER_RTT_SetTerminal(<span class="hljs-number">1</span>);<br>SEGGER_RTT_printf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;SEGGER_RTT_printf 1\r\n&quot;</span>);<br>SEGGER_RTT_SetTerminal(<span class="hljs-number">2</span>);<br>SEGGER_RTT_printf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;SEGGER_RTT_printf 2\r\n&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="输出带颜色的字符"><a href="#输出带颜色的字符" class="headerlink" title="输出带颜色的字符"></a>输出带颜色的字符</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Control sequences, based on ANSI.</span><br><span class="hljs-comment">// Can be used to control color, and clear the screen</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_RESET                <span class="hljs-string">&quot;\x1B[0m&quot;</span>         <span class="hljs-comment">// Reset to default colors</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_CLEAR                <span class="hljs-string">&quot;\x1B[2J&quot;</span>         <span class="hljs-comment">// Clear screen, reposition cursor to top left</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_BLACK           <span class="hljs-string">&quot;\x1B[2;30m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_RED             <span class="hljs-string">&quot;\x1B[2;31m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_GREEN           <span class="hljs-string">&quot;\x1B[2;32m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_YELLOW          <span class="hljs-string">&quot;\x1B[2;33m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_BLUE            <span class="hljs-string">&quot;\x1B[2;34m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_MAGENTA         <span class="hljs-string">&quot;\x1B[2;35m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_CYAN            <span class="hljs-string">&quot;\x1B[2;36m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_WHITE           <span class="hljs-string">&quot;\x1B[2;37m&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_BRIGHT_BLACK    <span class="hljs-string">&quot;\x1B[1;30m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_BRIGHT_RED      <span class="hljs-string">&quot;\x1B[1;31m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_BRIGHT_GREEN    <span class="hljs-string">&quot;\x1B[1;32m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_BRIGHT_YELLOW   <span class="hljs-string">&quot;\x1B[1;33m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_BRIGHT_BLUE     <span class="hljs-string">&quot;\x1B[1;34m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_BRIGHT_MAGENTA  <span class="hljs-string">&quot;\x1B[1;35m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_BRIGHT_CYAN     <span class="hljs-string">&quot;\x1B[1;36m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_BRIGHT_WHITE    <span class="hljs-string">&quot;\x1B[1;37m&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_BLACK             <span class="hljs-string">&quot;\x1B[24;40m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_RED               <span class="hljs-string">&quot;\x1B[24;41m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_GREEN             <span class="hljs-string">&quot;\x1B[24;42m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_YELLOW            <span class="hljs-string">&quot;\x1B[24;43m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_BLUE              <span class="hljs-string">&quot;\x1B[24;44m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_MAGENTA           <span class="hljs-string">&quot;\x1B[24;45m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_CYAN              <span class="hljs-string">&quot;\x1B[24;46m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_WHITE             <span class="hljs-string">&quot;\x1B[24;47m&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_BRIGHT_BLACK      <span class="hljs-string">&quot;\x1B[4;40m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_BRIGHT_RED        <span class="hljs-string">&quot;\x1B[4;41m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_BRIGHT_GREEN      <span class="hljs-string">&quot;\x1B[4;42m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_BRIGHT_YELLOW     <span class="hljs-string">&quot;\x1B[4;43m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_BRIGHT_BLUE       <span class="hljs-string">&quot;\x1B[4;44m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_BRIGHT_MAGENTA    <span class="hljs-string">&quot;\x1B[4;45m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_BRIGHT_CYAN       <span class="hljs-string">&quot;\x1B[4;46m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_BRIGHT_WHITE      <span class="hljs-string">&quot;\x1B[4;47m&quot;</span></span><br><br><br>SEGGER_RTT_WriteString(<span class="hljs-number">0</span>,RTT_CTRL_RESET<span class="hljs-string">&quot;Red: &quot;</span>\<br>                       RTT_CTRL_TEXT_RED<span class="hljs-string">&quot;This text is red.&quot;</span>\<br>                       RTT_CTRL_BG_BRIGHT_GREEN<span class="hljs-string">&quot;This background is green.\r\n&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="输入字符"><a href="#输入字符" class="headerlink" title="输入字符"></a>输入字符</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(SEGGER_RTT_HasKey())<br>&#123;<br>    <span class="hljs-type">char</span> r = SEGGER_RTT_GetKey();<br>    SEGGER_RTT_WriteString(<span class="hljs-number">0</span>,<span class="hljs-string">&quot;input:%c\r\n&quot;</span>, r);<br>&#125;<br><br><br><span class="hljs-keyword">if</span>(SEGGER_RTT_HasKey())<br>&#123;<br>    ReadNum = SEGGER_RTT_Read(<span class="hljs-number">0</span>,&amp;acIn[<span class="hljs-number">0</span>], <span class="hljs-keyword">sizeof</span>(acIn));<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">20</span>;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">0x0A</span> != acIn[i])<br>        &#123;<br>            ReadNum++;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    SEGGER_RTT_Write(<span class="hljs-number">0</span>,acIn,ReadNum);<br>    ReadNum=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(acIn,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(acIn));<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>j-link</tag>
      
      <tag>rtt</tag>
      
      <tag>serial</tag>
      
      <tag>debug</tag>
      
      <tag>jlink</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hex 文件格式解析</title>
    <link href="/2021/d3f98b78/"/>
    <url>/2021/d3f98b78/</url>
    
    <content type="html"><![CDATA[<h1 id="Hex-文件格式解析"><a href="#Hex-文件格式解析" class="headerlink" title="Hex 文件格式解析"></a>Hex 文件格式解析</h1><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://developer.arm.com/documentation/ka003292/1-0">Intel HEX File Format Keil</a></p><p><a href="https://en.wikipedia.org/wiki/Intel_HEX">Intel HEX Wiki</a></p><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><ul><li>以行为单位，每行以冒号开头，内容全部为16进制码（以ASCII码形式显示）</li><li>在HEX文件里面，每一行代表一个记录。记录的基本格式为如表所示</li></ul><table><thead><tr><th><strong>冒号</strong></th><th><strong>本行数据长度</strong></th><th><strong>本行数据起始地址</strong></th><th><strong>数据类型</strong></th><th><strong>数据</strong></th><th><strong>校验码</strong></th></tr></thead><tbody><tr><td></td><td>1 byte</td><td>2 bytes</td><td>1 byte</td><td>n byte</td><td>1 byte</td></tr></tbody></table><p><img src="/2021/d3f98b78/hex_format.jpg" alt="Hex文件格式解析"></p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Start code</td><td>one character, an ASCII colon ‘:’</td></tr><tr><td>Byte count</td><td>两个十六进制数字（一个十六进制数字对），表示数据字段中的字节数（十六进制数字对）。最大字节数为 255 (0xFF)。16 (0x10) 和 32 (0x20) 是常用的字节数。</td></tr><tr><td>Address</td><td>四位十六进制数字，表示数据的 16 位起始内存地址偏移量。数据的物理地址是通过将此偏移量添加到先前建立的基地址来计算的，从而允许内存寻址超出 16 位地址的 64 KB 限制。默认为零的基地址可以通过各种类型的记录进行更改。基地址和地址偏移量始终表示为<a href="https://en.wikipedia.org/wiki/Big_endian">大端</a>值。</td></tr><tr><td>Record type</td><td>两个十六进制数字，<em>00</em>到<em>05</em>，定义数据字段的含义。参考下文</td></tr><tr><td>Data</td><td>一个由<em>n</em>个字节组成的数据序列，由 <em>2n</em> 个十六进制数字表示。一些记录省略了这个字段（<em>n</em>等于零）。数据字节的含义和解释取决于应用程序。</td></tr><tr><td>Checksum</td><td>two hex digits, a computed value that can be used to verify the record has no errors.计算校验和前所有16进制码的累加和。</td></tr></tbody></table><h3 id="指令类型-Record-type"><a href="#指令类型-Record-type" class="headerlink" title="指令类型 Record type"></a>指令类型 Record type</h3><p>指令类型<code>Record type</code>的值一般是<code>00~05</code>，这表示了，当前这行<code>hex</code>格式的数据，所代表的含义：</p><table><thead><tr><th>十六进制代码</th><th>记录类型</th><th align="center">描述</th><th align="center">Example</th></tr></thead><tbody><tr><td><strong>00</strong></td><td>数据</td><td align="center">包含数据和该数据的16位起始地址。字节计数指定记录中的数据字节数。右侧显示的示例为0B （十一）个数据字节（61， 64， 64， 72， 65， 73， 73， 20， 67， 61， 70）位于以地址开头的连续地址 0010。</td><td align="center"><code>:0B 0010 00 6164647265737320676170 A7</code></td></tr><tr><td><strong>01</strong></td><td>文件结束</td><td align="center">每个文件在文件的最后一行必须恰好发生一次。数据字段为空（因此字节数为00），并且地址字段通常为 0000。</td><td align="center"><code>:00 0000 01 FF</code></td></tr><tr><td><strong>02</strong></td><td>扩展段地址</td><td align="center">数据字段包含一个16位的段基址（因此字节数始终为02）与80x86实模式寻址兼容。地址字段（通常为0000）被忽略。最近的段地址02记录乘以16，然后加到每个后续数据记录地址，以形成数据的物理起始地址。这允许寻址多达1 MB的地址空间。</td><td align="center"><code>:02 0000 02 1200 EA</code></td></tr><tr><td><strong>03</strong></td><td>起始段地址</td><td align="center">对于80x86处理器，请指定CS：IP寄存器的初始内容（即起始执行地址）。地址字段是0000，字节数始终为04，前两个数据字节是CS值，后两个是IP值。</td><td align="center"><code>:04 0000 03 00003800 C1</code></td></tr><tr><td><strong>04</strong></td><td>扩展线性地址</td><td align="center">允许32位寻址（最大4GiB）。记录的地址字段将被忽略（通常是0000），其字节数始终为02。两个数据字节（大字节序）为所有后续类型指定32位绝对地址的高16位00记录; 这些高位地址位适用于下一个04记录。类型的绝对地址00 通过组合最近的高16位地址位形成记录 04 用低16位的地址记录 00记录。如果是类型00 记录之前没有任何类型 04 记录，然后其高16位地址位默认为0000。</td><td align="center"><code>:02 0000 04 FFFF FC</code></td></tr><tr><td><strong>05</strong></td><td>起始线性地址</td><td align="center">地址字段是 0000（未使用），字节数始终为04。四个数据字节代表一个32位地址值（big-endian）。对于80386和更高版本的CPU，此地址将加载到EIP寄存器中。<br/><strong>（仅限 MDK-ARM）</strong>起始线性地址记录指定应用程序的起始地址。这些记录包含完整的线性 32 位地址。</td><td align="center"><code>:04 0000 05 000000CD 2A</code></td></tr></tbody></table><h5 id="扩展线性地址记录-HEX386"><a href="#扩展线性地址记录-HEX386" class="headerlink" title="扩展线性地址记录 (HEX386)"></a>扩展线性地址记录 (HEX386)</h5><p>扩展线性地址记录也称为 32 位地址记录和 HEX386 记录。这些记录包含数据地址的高 16 位（位 16-31）。扩展线性地址记录总是有两个数据字节，如下所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">:02000004FFFFFC<br></code></pre></td></tr></table></figure><p>在哪里：</p><ul><li><strong>02</strong>是记录中的数据字节数。</li><li><strong>0000</strong>是地址字段。对于扩展线性地址记录，此字段始终为 0000。</li><li><strong>04</strong>是记录类型 04（扩展的线性地址记录）。</li><li><strong>FFFF</strong>是地址的高 16 位。</li><li><strong>FC</strong>是记录的校验和，计算方式为<br>01h + NOT(02h + 00h + 00h + 04h + FFh + FFh)。</li></ul><p>读取扩展线性地址记录时，存储在数据字段中的扩展线性地址将被保存并应用于从 Intel HEX 文件读取的后续记录。线性地址保持有效，直到被另一个扩展地址记录改变。</p><p>数据记录的绝对内存地址是通过将记录中的地址字段与扩展线性地址记录的移位地址数据相加得到的。下面的例子说明了这个过程。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-type">Address</span> from the <span class="hljs-class"><span class="hljs-keyword">data</span> record&#x27;s address field      2462</span><br><span class="hljs-type">Extended</span> linear address record <span class="hljs-class"><span class="hljs-keyword">data</span> field     <span class="hljs-type">FFFF</span></span><br>                                              <span class="hljs-comment">--------</span><br><span class="hljs-type">Absolute</span>-memory address                       <span class="hljs-type">FFFF2462</span><br></code></pre></td></tr></table></figure><h5 id="扩展段地址记录-HEX86"><a href="#扩展段地址记录-HEX86" class="headerlink" title="扩展段地址记录 (HEX86)"></a>扩展段地址记录 (HEX86)</h5><p>扩展段地址记录（也称为 HEX86 记录）包含数据地址段的第 4-19 位。扩展段地址记录总是有两个数据字节，如下所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">:020000021200EA<br></code></pre></td></tr></table></figure><p>在哪里：</p><ul><li><strong>02</strong>是记录中的数据字节数。</li><li><strong>0000</strong>是地址字段。对于扩展段地址记录，该字段始终为 0000。</li><li><strong>02</strong>是记录类型 02（扩展段地址记录）。</li><li><strong>1200</strong>是地址段。</li><li><strong>EA</strong>是记录的校验和，计算方式为<br>01h + NOT(02h + 00h + 00h + 02h + 12h + 00h)。</li></ul><p>当读取扩展段地址记录时，存储在数据字段中的扩展段地址被保存并应用于从 Intel HEX 文件读取的后续记录。段地址保持有效，直到被另一个扩展地址记录改变。</p><p>数据记录的绝对内存地址是通过将记录中的地址字段添加到来自扩展段地址记录的移位地址数据中获得的。以下示例说明了此过程。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-type">Address</span> from the <span class="hljs-class"><span class="hljs-keyword">data</span> record&#x27;s address field     2462</span><br><span class="hljs-type">Extended</span> segment address record <span class="hljs-class"><span class="hljs-keyword">data</span> field      1200</span><br>                                             <span class="hljs-comment">--------</span><br><span class="hljs-type">Absolute</span> memory address                      <span class="hljs-number">00014462</span><br></code></pre></td></tr></table></figure><h5 id="起始线性地址记录（仅限-MDK-ARM）"><a href="#起始线性地址记录（仅限-MDK-ARM）" class="headerlink" title="起始线性地址记录（仅限 MDK-ARM）"></a>起始线性地址记录（仅限 MDK-ARM）</h5><p>起始线性地址记录指定应用程序的起始地址。这些记录包含完整的线性 32 位地址。起始线性地址记录总是有四个数据字节，如下所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">:04000005000000CD2A<br></code></pre></td></tr></table></figure><p>在哪里：</p><ul><li><strong>04</strong>是记录中的数据字节数。</li><li><strong>0000</strong>是地址字段。对于起始线性地址记录，该字段始终为 0000。</li><li><strong>05</strong>是记录类型 05（起始线性地址记录）。</li><li><strong>000000CD</strong>是应用程序的 4 字节线性起始地址。</li><li><strong>2A</strong>是记录的校验和，计算方式为<br>01h + NOT(04h + 00h + 00h + 05h + 00h + 00h + 00h + CDh)。</li></ul><p>Start Linear Address 指定了 __main（pre-main）函数的地址，而不是通常在调用 SystemInit() 之后调用 __main 的启动代码的地址。奇数线性起始地址指定 __main 是为 Thumb 指令集编译的。</p><p>起始线性地址记录可以出现在 hex 文件中的任何位置。在大多数情况下，可以忽略此记录，因为它不包含对闪存进行编程所需的信息。</p><h5 id="文件结束-EOF-记录"><a href="#文件结束-EOF-记录" class="headerlink" title="文件结束 (EOF) 记录"></a>文件结束 (EOF) 记录</h5><p>英特尔 HEX 文件必须以文件结束 (EOF) 记录结尾。此记录在记录类型字段中必须具有值 01。EOF 记录始终如下所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">:00000001FF<br></code></pre></td></tr></table></figure><p>在哪里：</p><ul><li><strong>00</strong>是记录中的数据字节数。</li><li><strong>0000</strong>是数据在内存中的位置。文件尾记录中的地址是无意义的并且被忽略。地址 0000h 是典型的。</li><li><strong>01</strong>是记录类型 01（文件结束记录）。</li><li><strong>FF</strong>是记录的校验和，计算方式为<br>01h + NOT(00h + 00h + 00h + 01h)。</li></ul><h2 id="tip"><a href="#tip" class="headerlink" title="tip"></a>tip</h2><ul><li><strong>用Notepad++打开hex文件，会自动上色、换行</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>XIP 片内执行 eXecute in Place</title>
    <link href="/2021/2c1a46d6/"/>
    <url>/2021/2c1a46d6/</url>
    
    <content type="html"><![CDATA[<h1 id="XIP-eXecute-In-Place"><a href="#XIP-eXecute-In-Place" class="headerlink" title="XIP   eXecute In Place"></a>XIP   eXecute In Place</h1><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><p>eXecute In Place，即芯片内执行，是指CPU直接从存储器中读取程序代码执行。</p><p>应用程序可以直接在flash闪存内运行，不必再把代码读到系统RAM中。flash内执行是指nor flash不需要初始化，可以直接在flash内执行代码。但往往<strong>只执行部分代码</strong>，比如<strong>初始化RAM</strong>。好处即是程序代码无需占用内存，减少内存的要求。</p><p><strong>所谓片内执行不是说程序在存储器内执行，CPU的基本功能是取指、译码、运行。Nor Flash能在芯片内执行，指的是CPU能够直接从Nor flash中取指令，供后面的译码器和执行器来使用。</strong></p><p>为实现XIP，必须满足几个条件：</p><ol><li><p>存储器必须提供与内存相似的接口给CPU。</p></li><li><p>该接口必须提供足够快的读取操作，并具有随机访问模式。</p></li><li><p>如有文件系统，则需要提供合适的映射功能</p></li><li><p>程序链接时需要知道存储器的地址或地址与位置无关。</p></li><li><p>程序不能修改已加载映像中的数据。</p></li></ol><p>NOR Flash和EEPROM通常能满足上述要求。</p><h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p><strong>nandflash也可以实现XIP</strong></p><p>“所谓XIP,就是CODE是在FLASH上直接运行. NANDFLASH只是不适合做XIP,但并不是不能做XIP“要一段CODE能够正确的运行,要保证它的CODE是连续的,正确的.由于一些电气特性的原因,NOR FLASH能够做到这一点,不存在坏道或坏块,所以能够做XIP.</p><p><strong>NOR Flash 和 NAND Flash</strong></p><p>NOR Flash具备随机读取给一个地址就能读一个数据，NAND Flash是一次读一块数据，一个地址读出一块数据。</p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xip</tag>
      
      <tag>nor</tag>
      
      <tag>nand</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VSCode</title>
    <link href="/2021/9be43835/"/>
    <url>/2021/9be43835/</url>
    
    <content type="html"><![CDATA[<h1 id="VSCode"><a href="#VSCode" class="headerlink" title="VSCode"></a>VSCode</h1><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul><li>格式化代码 【Shift】+【Alt】+F</li></ul><h2 id="多行编辑"><a href="#多行编辑" class="headerlink" title="多行编辑"></a>多行编辑</h2><ul><li><p><code>Ctrl+Alt+UpArrow</code> <code>Ctrl+Alt+DownArrow</code></p></li><li><p><code>Alt+Click</code> 鼠标点击多行编辑</p></li><li><p><code>Ctrl+Shift+L</code> 对应文本多行编辑</p></li></ul><h2 id="行操作"><a href="#行操作" class="headerlink" title="行操作"></a>行操作</h2><ul><li><code>Shift+Alt+UpArrow</code> <code>Shift+Alt+DownArrow</code> 复制当前行</li><li><code>Alt+UpArrow</code> <code>Alt+DownArrow</code> 移动当前行</li></ul><h2 id="工作区配置"><a href="#工作区配置" class="headerlink" title="工作区配置"></a>工作区配置</h2><p>xx.code-workspace</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs shell">&#123;<br>    &quot;folders&quot;: [<br>        &#123;<br>            &quot;path&quot;: &quot;..&quot;,<br>            &quot;name&quot;: &quot;ds300&quot;<br>        &#125;<br>    ],<br>    &quot;settings&quot;: &#123;<br>        &quot;files.exclude&quot;: &#123;<br>        # 这里不要带 / 前缀<br>            &quot;ax32_platform_demo/product/ds500/**&quot;: true,<br>            &quot;si/&quot;: true<br>        &#125;,<br>        &quot;search.exclude&quot;: &#123;<br>            &quot;**.project&quot;: true,<br>            &quot;**.lst&quot;: true,<br>            &quot;**.mk&quot;: true,<br>            &quot;**.txt&quot;: true,<br>            &quot;**.map&quot;: true<br>        &#125;,<br>        &quot;doxdocgen.file.copyrightTag&quot;: [<br>            &quot;@copyright COPYRIGHT Depstech®&quot;<br>        ],<br>        &quot;C_Cpp.default.defines&quot;: [<br>            &quot;DEPSTECH_PRODUCT=2&quot;<br>        ],<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="setting-json"><a href="#setting-json" class="headerlink" title="setting.json"></a>setting.json</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;files.exclude&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;**/out/**&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>    <span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="c-cpp-properties-json"><a href="#c-cpp-properties-json" class="headerlink" title="c_cpp_properties.json"></a>c_cpp_properties.json</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;configurations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Linux&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;includePath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;browse&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;limitSymbolsToIncludedHeaders&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;databaseFilename&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceRoot&#125;/.vscode/.browse.c_cpp.db&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;path&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                    <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span><br>                <span class="hljs-punctuation">]</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;defines&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;xxx&quot;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;compilerPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/usr/bin/gcc&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;cStandard&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;gnu17&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;cppStandard&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;gnu++14&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;intelliSenseMode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;linux-gcc-x64&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;configurationProvider&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ms-vscode.makefile-tools&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">4</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><h2 id="无法goto-define"><a href="#无法goto-define" class="headerlink" title="无法goto define"></a>无法goto define</h2><p>VSCode 不知道是什么设置问题，在使用跳转功能时，经常只能跳转到头文件，使用 <code>Go to References</code> 也找不到定义位置，搞得索引起来很麻烦。</p><p>切换成 <code>C++ Intellisense</code> 后，发现可以得到不错的效果。<br><img src="/2021/9be43835/watermark.png" alt="在这里插入图片描述"><br>在安装过程中，需要注意以下事项：<br>【1】 需要 <code>GNU Global</code>(&gt;&#x3D;6.5) 的依赖项并添加进路径中。可以通过以下方式安装：</p><blockquote><p>  sudo apt install global</p></blockquote><p>安装之后可使用以下命令确认是否成功：</p><blockquote><p>  global –version<br>  <img src="/2021/9be43835/11f3ab43797b44d9a9746b0676881339.png" alt="在这里插入图片描述"></p></blockquote><p>【2】在 C&#x2F;C++ 项目的工作空间文件夹，运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">gtags<br><span class="hljs-comment"># --statistics 显示统计数据</span><br></code></pre></td></tr></table></figure><blockquote><p>  忽略一些文件 在代码工程的一级目录下新建文件 <code>gtags.conf</code>，按照如下格式编辑其内容：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">default:\<br>common:\<br>:skip=/arch/m68k/: \<br>:skip=/tools/:<br></code></pre></td></tr></table></figure></blockquote><p>这将会产生下列三个文件：<code>GTAGS</code>, <code>GRTAGS</code>, <code>GPATHS</code>。 如果代码有修改，再次运行 <code>gtags</code> 来更新这些 tag 文件。</p>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vscode</tag>
      
      <tag>ide</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2021/69c3279c/"/>
    <url>/2021/69c3279c/</url>
    
    <content type="html"><![CDATA[<h1 id="Git-Bref"><a href="#Git-Bref" class="headerlink" title="Git Bref"></a>Git Bref</h1><p><img src="/2021/69c3279c/1352126739_7909.jpg" alt="img"></p><ul><li><p><strong>工作区：</strong>就是你在电脑里能看到的目录。</p></li><li><p><strong>暂存区：</strong>英文叫 stage 或 index。一般存放在 <strong>.git</strong> 目录下的 index 文件（.git&#x2F;index）中，所以我们把暂存区有时也叫作索引（index）。</p></li><li><p><strong>版本库：</strong>工作区有一个隐藏目录 <strong>.git</strong>，这个不算工作区，而是 Git 的版本库。</p></li></ul><p><img src="/2021/69c3279c/git-command.jpg" alt="img"></p><ul><li>workspace：工作区</li><li>staging area：暂存区&#x2F;缓存区</li><li>local repository：版本库或本地仓库</li><li>remote repository：远程仓库</li></ul><h2 id="Git-Workflows"><a href="#Git-Workflows" class="headerlink" title="Git Workflows"></a>Git Workflows</h2><p><a href="https://www.atlassian.com/git/tutorials/comparing-workflows">https://www.atlassian.com/git/tutorials/comparing-workflows</a></p><h3 id="Centralized-集中工作流"><a href="#Centralized-集中工作流" class="headerlink" title="Centralized 集中工作流"></a>Centralized 集中工作流</h3><p><img src="/2021/69c3279c/01.svg" alt="git workflow | Central and local repositories"></p><h3 id="Feature-Branch-功能分支"><a href="#Feature-Branch-功能分支" class="headerlink" title="Feature Branch 功能分支"></a>Feature Branch 功能分支</h3><p><a href="https://www.atlassian.com/git/tutorials/comparing-workflows/feature-branch-workflow">https://www.atlassian.com/git/tutorials/comparing-workflows/feature-branch-workflow</a></p><h3 id="Gitflow"><a href="#Gitflow" class="headerlink" title="Gitflow"></a>Gitflow</h3><p><a href="https://nvie.com/posts/a-successful-git-branching-model/">https://nvie.com/posts/a-successful-git-branching-model/</a></p><p><img src="/2021/69c3279c/git-model@2x.png" alt="img"></p><p><img src="/2021/69c3279c/04-Hotfix-branches.svg" alt="Git 流程工作流 - 修补程序分支"></p><h3 id="Forking-分叉"><a href="#Forking-分叉" class="headerlink" title="Forking 分叉"></a>Forking 分叉</h3><p><a href="https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow">Forking Workflow</a>通常遵循基于<a href="https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow">Gitflow Workflow</a>的分支模型。这意味着完整的功能分支将用于合并到原始项目维护者的存储库中。结果是一个分布式工作流，它为大型有机团队（包括不受信任的第三方）安全地协作提供了一种灵活的方式。这也使其成为开源项目的理想工作流程。</p><h2 id="Git-commit-规范"><a href="#Git-commit-规范" class="headerlink" title="Git commit 规范"></a>Git commit 规范</h2><p><a href="https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit#heading=h.uyo6cb12dt6w">参考链接</a><br><a href="https://gitmoji.dev/">参考gitmoji</a></p><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs git">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;<br>&lt;BLANK LINE&gt;<br>&lt;body&gt;<br>&lt;BLANK LINE&gt;<br>&lt;footer&gt;<br><br>&lt;类型&gt;(&lt;范围&gt;)：&lt;主题&gt;<br>&lt;空行&gt;<br>&lt;正文&gt;<br>&lt;空行&gt;<br>&lt;页脚&gt;<br></code></pre></td></tr></table></figure><p>subject、type是<strong>必须的</strong>，scope是<strong>可选的</strong>。<br>提交消息的任何一行都不能太多字符（72、100）！这是为了让消息更美观、容易阅读。</p><h4 id="Allowed-type-类型"><a href="#Allowed-type-类型" class="headerlink" title="Allowed [type] 类型"></a>Allowed [type] 类型</h4><h2 id="This-describes-the-kind-of-change-that-this-commit-is-providing-每个类型值都表示了不同的含义，类型值必须是以下的其中一个：-feat-feature-提交新功能-fix-bug-fix-修复了bug-docs-documentation-只修改了文档-style-formatting-missing-semi-colons-…-调整代码格式-refactor-Code-refactoring-no-new-or-deleted-functions-代码重构-perf-Performance-optimization-性能优化-test-when-adding-missing-tests-添加或修改代码测试-chore-maintain-对构建流程或辅助工具和依赖库（如文档生成等）的更改-revet-revert-change-恢复更改-wip-Work-In-Progress-开发中-release-release-version-版本发布"><a href="#This-describes-the-kind-of-change-that-this-commit-is-providing-每个类型值都表示了不同的含义，类型值必须是以下的其中一个：-feat-feature-提交新功能-fix-bug-fix-修复了bug-docs-documentation-只修改了文档-style-formatting-missing-semi-colons-…-调整代码格式-refactor-Code-refactoring-no-new-or-deleted-functions-代码重构-perf-Performance-optimization-性能优化-test-when-adding-missing-tests-添加或修改代码测试-chore-maintain-对构建流程或辅助工具和依赖库（如文档生成等）的更改-revet-revert-change-恢复更改-wip-Work-In-Progress-开发中-release-release-version-版本发布" class="headerlink" title="This describes the kind of change that this commit is providing.每个类型值都表示了不同的含义，类型值必须是以下的其中一个：- feat (feature) 提交新功能- fix (bug fix) 修复了bug- docs (documentation) 只修改了文档- style (formatting, missing semi colons, …) 调整代码格式- refactor (Code refactoring, no new or deleted functions.) 代码重构- perf (Performance optimization.) 性能优化- test (when adding missing tests) 添加或修改代码测试- chore (maintain) 对构建流程或辅助工具和依赖库（如文档生成等）的更改- revet (revert change) 恢复更改- wip (Work In Progress) 开发中- release (release version) 版本发布"></a>This describes the kind of change that this commit is providing.<br>每个类型值都表示了不同的含义，类型值必须是以下的其中一个：<br>- feat (feature) <code>提交新功能</code><br>- fix (bug fix) <code>修复了bug</code><br>- docs (documentation) <code>只修改了文档</code><br>- style (formatting, missing semi colons, …) <code>调整代码格式</code><br>- refactor (Code refactoring, no new or deleted functions.) <code>代码重构</code><br>- perf (Performance optimization.) <code>性能优化</code><br>- test (when adding missing tests) <code>添加或修改代码测试</code><br>- chore (maintain) <code>对构建流程或辅助工具和依赖库（如文档生成等）的更改</code><br>- revet (revert change) <code>恢复更改</code><br>- wip (Work In Progress) <code>开发中</code><br>- release (release version) <code>版本发布</code></h2><p><strong>Revert</strong><br>如果需要revert先前的提交，那提交消息应该以“revert:”开头，后跟要恢复到的那个提交的标题。然后在消息正文中，写上 <code>This reverts commit &lt;hash&gt;.</code>。</p><h4 id="Allowed-scope-影响范围"><a href="#Allowed-scope-影响范围" class="headerlink" title="Allowed [scope] 影响范围"></a>Allowed [scope] 影响范围</h4><p>Scope can be anything specifying place of the commit change. For example $location, $browser, $compile, $rootScope, ngHref, ngClick, ngView, etc…<br>You can use * if there isn’t a more fitting scope. <code>您可以使用*如果没有更合适的范围。</code></p><h4 id="subject-text-标题"><a href="#subject-text-标题" class="headerlink" title="[subject] text 标题"></a>[subject] text 标题</h4><p>This is a very short description of the change.</p><ul><li>use imperative, present tense: “change” not “changed” nor “changes”<code>使用命令式、现在时：“change”而不是“changed”或“changes”</code></li><li>don’t capitalize first letter <code>不要将第一个字母大写</code></li><li>no dot (.) at the end <code>末尾没有点 (.)</code></li></ul><h4 id="Message-body-内容-正文"><a href="#Message-body-内容-正文" class="headerlink" title="Message [body] 内容 正文"></a>Message [body] 内容 正文</h4><ul><li>just as in [subject] use imperative, present tense: “change” not “changed” nor “changes”<code>使用命令式、现在时：“change”而不是“changed”或“changes”</code></li><li>includes motivation for the change and contrasts with previous behavior <code>包括改变的动机以及与之前行为的对比</code></li></ul><h4 id="Message-footer-页脚"><a href="#Message-footer-页脚" class="headerlink" title="Message [footer] 页脚"></a>Message [footer] 页脚</h4><p><strong>Breaking changes 破坏性变更 不向下兼容</strong><br>All breaking changes have to be mentioned as a breaking change block in the footer, which should start with the word BREAKING CHANGE: with a space or two newlines. The rest of the commit message is then the description of the change, justification and migration notes.<br>所有Breaking changes都必须在页脚中提及，这应该以<code>BREAKING CHANGE</code>一词开头：带有一个空格或两个换行符。提交消息的其余部分是更改的描述、理由和修改说明。</p><p><strong>Referencing issues 参考文献</strong><br>已关闭的错误应在页脚中的单独行中列出，并以“Closes”关键字为前缀，如下所示：</p><blockquote><p>this:<br>Closes #234<br>or in case of multiple issues:<br>Closes #123, #245, #992</p></blockquote><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">docs(guide): updated fixed docs from Google Docs<br><br>Couple of typos fixed:<br>- indentation<br>- batchLogbatchLog -&gt; batchLog<br>- start periodic checking<br>- missing brace<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">feat($</span><span class="language-bash">browser): onUrlChange event (popstate/hashchange/polling)</span><br><br>Added new event to $browser:<br>- forward popstate event if available<br>- forward hashchange event if popstate not available<br>- do polling when neither popstate nor hashchange available<br><br>Breaks $browser.onHashChange, which was removed (use onUrlChange instead)<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">fix($</span><span class="language-bash">compile): couple of unit tests <span class="hljs-keyword">for</span> IE9</span><br><br>Older IEs serialize html uppercased, but IE9 does not...<br>Would be better to expect case insensitive, unfortunately jasmine does<br>not allow to user regexps for throw expectations.<br><br>Closes #392<br>Breaks foo.bar api, foo.baz should be used instead<br></code></pre></td></tr></table></figure><h2 id="基本命令list"><a href="#基本命令list" class="headerlink" title="基本命令list"></a>基本命令list</h2><h3 id="创建仓库命令"><a href="#创建仓库命令" class="headerlink" title="创建仓库命令"></a>创建仓库命令</h3><p>下表列出了 git 创建仓库的命令：</p><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git init</code></td><td align="left">初始化仓库</td></tr><tr><td align="left"><code>git clone</code></td><td align="left">拷贝一份远程仓库，也就是下载一个项目。</td></tr></tbody></table><hr><h3 id="提交与修改"><a href="#提交与修改" class="headerlink" title="提交与修改"></a>提交与修改</h3><p>Git 的工作就是创建和保存你的项目的快照及与之后的快照进行对比。</p><p>下表列出了有关创建与提交你的项目的快照的命令：</p><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git add</code></td><td align="left">添加文件到仓库</td></tr><tr><td align="left"><code>git status</code></td><td align="left">查看仓库当前的状态，显示有变更的文件。</td></tr><tr><td align="left"><code>git diff</code></td><td align="left">比较文件的不同，即暂存区和工作区的差异。</td></tr><tr><td align="left"><code>git commit</code></td><td align="left">提交暂存区到本地仓库。</td></tr><tr><td align="left"><code>git reset</code></td><td align="left">回退版本。</td></tr><tr><td align="left"><code>git rm</code></td><td align="left">删除工作区文件。</td></tr><tr><td align="left"><code>git mv</code></td><td align="left">移动或重命名工作区文件。</td></tr></tbody></table><h3 id="提交日志"><a href="#提交日志" class="headerlink" title="提交日志"></a>提交日志</h3><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git log</code></td><td align="left">查看历史提交记录</td></tr><tr><td align="left"><code>git blame &lt;file&gt;</code></td><td align="left">以列表形式查看指定文件的历史修改记录</td></tr></tbody></table><h3 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h3><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git remote</code></td><td align="left">远程仓库操作</td></tr><tr><td align="left"><code>git fetch</code></td><td align="left">从远程获取代码库</td></tr><tr><td align="left"><code>git pull</code></td><td align="left">下载远程代码并合并</td></tr><tr><td align="left"><code>git push</code></td><td align="left">上传远程代码并合并</td></tr></tbody></table><h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><p><img src="/2021/69c3279c/Honeyview_Ey7f6ftXIAEOd8M.jpg" alt="Honeyview_Ey7f6ftXIAEOd8M"></p><h2 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h2><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>-d</td><td>–delete：删除</td></tr><tr><td>-D</td><td>–delete –force的快捷键</td></tr><tr><td>-f</td><td>–force：强制</td></tr><tr><td>-m</td><td>–move：移动或重命名</td></tr><tr><td>-M</td><td>–move –force的快捷键</td></tr><tr><td>-r</td><td>–remote：远程</td></tr><tr><td>-a</td><td>–all：所有</td></tr></tbody></table><h2 id="Git-配置"><a href="#Git-配置" class="headerlink" title="Git 配置"></a>Git 配置</h2><h3 id="查看配置"><a href="#查看配置" class="headerlink" title="查看配置"></a>查看配置</h3><p>列出当前配置：<code>git config --list</code></p><p>列出repository配置：<code>git config --local --list</code></p><p>列出全局配置：<code>git config --global --list</code></p><p>列出系统配置：<code>git config --system --list</code></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>配置用户名：<code>git config --global user.name &quot;your name&quot;</code></p><p>配置用户邮箱：<code>git config --global user.email &quot;youremail@github.com&quot;</code></p><p>修改默认branch名: <code>git config --global init.defaultBranch main</code></p><p>git走代理: <code>git config --global http.proxy &#39;socks5://127.0.0.1:1080&#39;</code></p><h3 id="SSH-key-gen"><a href="#SSH-key-gen" class="headerlink" title="SSH key gen"></a>SSH key gen</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen -t rsa -C &quot;youremail@github.com&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">注意 RSA 现阶段不再建议使用了, 改成ed25519生成</span><br>ssh-keygen -t ed25519 -C &quot;your_email@example.com&quot;<br></code></pre></td></tr></table></figure><p>执行命令后需要进行3次或4次确认：</p><ol><li>确认秘钥的保存路径（如果不需要改路径则直接回车）；</li><li>如果上一步置顶的保存路径下已经有秘钥文件，则需要确认是否覆盖（如果之前的秘钥不再需要则直接回车覆盖，如需要则手动拷贝到其他目录后再覆盖）；</li><li>创建密码（如果不需要密码则直接回车）；</li><li>确认密码；</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> ~/.ssh/id_rsa.pub<br></code></pre></td></tr></table></figure><h2 id="Git命令"><a href="#Git命令" class="headerlink" title="Git命令"></a>Git命令</h2><h3 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h3><p>初始化版本库</p><h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone [--template=&lt;template_directory&gt;]<br>     [-l] [-s] [--no-hardlinks] [-q] [-n] [--bare] [--mirror]<br>     [-o &lt;name&gt;] [-b &lt;name&gt;] [-u &lt;upload-pack&gt;] [--reference &lt;repository&gt;]<br>     [--dissociate] [--separate-git-dir &lt;git dir&gt;]<br>     [--depth &lt;depth&gt;] [--[no-]single-branch] [--no-tags]<br>     [--recurse-submodules[=&lt;pathspec&gt;]] [--[no-]shallow-submodules]<br>     [--[no-]remote-submodules] [--jobs &lt;n&gt;] [--sparse] [--[no-]reject-shallow]<br>     [--filter=&lt;filter&gt;] [--] &lt;repository&gt;<br>     [&lt;directory&gt;]<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># git clone 后面接文件夹名可以修改clone到本地的文件夹名称</span><br>git <span class="hljs-built_in">clone</span> &lt;url&gt; directory<br><br>git <span class="hljs-built_in">clone</span> --single-branch --branch &lt;branch-name&gt; &lt;remote-repo-url&gt;<br></code></pre></td></tr></table></figure><h3 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h3><p><code>git log --graph --pretty=oneline --abbrev-commit</code>可以看到分支的合并情况，包括分支合并图(–graph)、一行显示(–pretty&#x3D;oneline)、提交校验码缩略(–abbrev-commit)显示：</p><table><thead><tr><th align="left">选项</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>-&lt;n&gt;</code></td><td align="left">仅显示最近的 n 条提交。</td></tr><tr><td align="left"><code>--since</code>, <code>--after</code></td><td align="left">仅显示指定时间之后的提交。</td></tr><tr><td align="left"><code>--until</code>, <code>--before</code></td><td align="left">仅显示指定时间之前的提交。</td></tr><tr><td align="left"><code>--author</code></td><td align="left">仅显示作者匹配指定字符串的提交。</td></tr><tr><td align="left"><code>--committer</code></td><td align="left">仅显示提交者匹配指定字符串的提交。</td></tr><tr><td align="left"><code>--grep</code></td><td align="left">仅显示提交说明中包含指定字符串的提交。</td></tr><tr><td align="left"><code>-S</code></td><td align="left">仅显示添加或删除内容匹配指定字符串的提交。</td></tr></tbody></table><h3 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h3><h3 id="git-blame"><a href="#git-blame" class="headerlink" title="git blame"></a>git blame</h3><p>如果要查看指定文件的修改记录可以使用 git blame 命令，格式如下：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">git blame &lt;<span class="hljs-built_in">file</span>&gt;<br></code></pre></td></tr></table></figure><p>git blame用来追溯一个指定文件的历史修改记录。它能显示任何文件中每行最后一次修改的提交记录。 所以，如果你在代码中看到一个有 bug 的方法，你可以使用 git blame 标注这个文件，查看哪一次提交引入了这行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">可以使用 -L 指定文件的行数范围：</span><br>git blame -L n1,n2 filename<br></code></pre></td></tr></table></figure><h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><p><strong>git pull</strong> 命令用于从远程获取代码并合并本地的版本。</p><p><strong>git pull</strong> 其实就是 <strong>git fetch</strong> 和 <strong>git merge FETCH_HEAD</strong> 的简写。 命令格式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">git pull <span class="hljs-tag">&lt;<span class="hljs-name">远程主机名</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">远程分支名</span>&gt;</span>:<span class="hljs-tag">&lt;<span class="hljs-name">本地分支名</span>&gt;</span><br></code></pre></td></tr></table></figure><p>更新操作：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git pull</span><br><span class="hljs-attribute">git pull origin</span><br></code></pre></td></tr></table></figure><p>将远程主机 origin 的 master 分支拉取过来，与本地的 brantest 分支合并。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git pull origin <span class="hljs-literal">master</span>:brantest<br></code></pre></td></tr></table></figure><h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><p><strong>git push</strong> 命用于从将本地的分支版本上传到远程并合并。</p><p>命令格式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">git push <span class="hljs-tag">&lt;<span class="hljs-name">远程主机名</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">本地分支名</span>&gt;</span>:<span class="hljs-tag">&lt;<span class="hljs-name">远程分支名</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果本地分支名与远程分支名相同，则可以省略冒号：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">git push <span class="hljs-tag">&lt;<span class="hljs-name">远程主机名</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">本地分支名</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果本地版本与远程版本有差异，但又要强制推送可以使用 –force 参数：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> --force <span class="hljs-built_in">origin</span> master<br></code></pre></td></tr></table></figure><p>删除主机的分支可以使用 –delete 参数，以下命令表示删除 origin 主机的 master 分支，(慎用)：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> --<span class="hljs-built_in">delete</span> master<br></code></pre></td></tr></table></figure><h3 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h3><table><thead><tr><th>参数</th><th></th></tr></thead><tbody><tr><td><code>-v</code></td><td><strong>verbose</strong>显示详细一些的内容</td></tr><tr><td></td><td></td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote add origin your_first_git_address //将第一个git address命名为origin<br></code></pre></td></tr></table></figure><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><table><thead><tr><th>参数</th><th></th></tr></thead><tbody><tr><td>\–-all</td><td>把所有文件添加到版本控制里面</td></tr><tr><td>.</td><td>--all 同</td></tr></tbody></table><h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><p>git commit </p><table><thead><tr><th>参数</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>-a</td><td>all</td><td>受版本控制的所有文件<br>注意，新加的文件（即没有被git系统管理的文件）是不能被提交到本地仓库的</td><td></td></tr><tr><td>-m</td><td>message</td><td>提交的注释</td><td>git commit -m “this first commit”</td></tr><tr><td>- - amend</td><td></td><td>修改上次提交的注释</td><td></td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -m <span class="hljs-string">&#x27;    // 在这里直接输入回车即可</span><br><span class="hljs-string">1、第一项改动      // 以下的这些真正的comment可以在其他文本编辑器中写好粘贴过来</span><br><span class="hljs-string">2、第二项</span><br><span class="hljs-string">&#x27;</span>                // 输入这个结尾单引号后，再输入回车即可完成本次commit的提交<br></code></pre></td></tr></table></figure><h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h3><table><thead><tr><th>argv</th><th></th><th></th></tr></thead><tbody><tr><td>-u</td><td>mode</td><td></td></tr><tr><td>-uno</td><td>- 不显示未跟踪的文件。</td><td></td></tr><tr><td>-unormal</td><td>- 显示未跟踪的文件和目录。</td><td></td></tr><tr><td>-uall</td><td>- 还显示未跟踪目录中的单个文件。</td><td></td></tr></tbody></table><p>查看那些被修改那些没被修改</p><h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><p>查看与版本差异</p><h3 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h3><table><thead><tr><th>参数</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>git checkout &lt;branch&gt;</td><td></td><td>切换分支</td><td></td></tr><tr><td>git checkou -b &lt;branch&gt;</td><td>build</td><td>创建并切换分支</td><td></td></tr><tr><td>git checkout –orphan &lt;branch&gt;</td><td></td><td>创建切换到孤立的分支</td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>git checkout – &lt;file&gt;</td><td></td><td>从Staged恢复文件<br>重置全部文件用<code>-- .</code></td><td></td></tr><tr><td>git checkout HEAD – &lt;file&gt;</td><td></td><td>从HEAD恢复文件<br>重置全部文件用<code>-- .</code></td><td></td></tr></tbody></table><h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h3><table><thead><tr><th>参数</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>git branch &lt;branch&gt;</td><td></td><td>创建分支</td><td></td></tr><tr><td>git branch -d &lt;branch&gt;</td><td>delete</td><td>删除分支</td><td></td></tr><tr><td>git branch -D &lt;branch&gt;</td><td></td><td>强制删除</td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>git branch (-m | -M) &lt;oldbranch&gt; &lt;newbranch&gt;</td><td></td><td>重命名分支</td><td></td></tr><tr><td>git branch</td><td></td><td>查看当前分支</td><td></td></tr></tbody></table><h3 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h3><table><thead><tr><th>参数</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>git tag</td><td></td><td>查看标签</td><td></td></tr><tr><td>git show</td><td></td><td>查看指定标签的信息</td><td></td></tr><tr><td>git tag &lt;tag name&gt; &lt;commit id&gt;</td><td></td><td>创建 tag</td><td></td></tr><tr><td>-a</td><td></td><td>指定标签名</td><td></td></tr><tr><td>-m</td><td></td><td>指定说明文字</td><td></td></tr><tr><td>-l</td><td></td><td>列出特定版本 git tag -l “v1.4.2.*”</td><td></td></tr><tr><td>-d</td><td></td><td>删除</td><td></td></tr><tr><td>git push origin &lt;tag name&gt;</td><td></td><td>推送某个标签到远程</td><td></td></tr><tr><td>git push origin –tags</td><td></td><td>推送全部尚未推送到远程的本地标签</td><td></td></tr></tbody></table><h3 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h3><p>变基 </p><p>注: 需要切换到分支的后面, 再完成变基</p><p>git checkout &lt;branch&gt;</p><p>git rebae -d &lt;master branch&gt;</p><h3 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h3><p><img src="/2021/69c3279c/1102222-20171213190644254-2099705216.png" alt="img"></p><table><thead><tr><th>参数</th><th></th></tr></thead><tbody><tr><td>git merge &lt;branch&gt;</td><td>将分支合并到当前分支</td></tr><tr><td>git merge –no-ff  &lt;branch&gt;</td><td>禁用 快速合并模式（Fast forward）</td></tr><tr><td>git merge –ff-only  &lt;branch&gt;</td><td>快速合并(快进)</td></tr><tr><td><code>git merge --abort</code></td><td>中止这一次提交的合并(当遇到冲突时)</td></tr><tr><td>-m</td><td>massage</td></tr></tbody></table><h3 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h3><table><thead><tr><th>参数</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>git stash</td><td></td><td>将当前未提交内容藏匿</td><td></td></tr><tr><td>git stash list</td><td></td><td>藏匿 list</td><td></td></tr><tr><td>git stash drop</td><td></td><td>删除 藏匿</td><td></td></tr><tr><td>git stash apply</td><td></td><td>恢复 藏匿</td><td></td></tr><tr><td>git stash pop</td><td></td><td>恢复并删除 藏匿</td><td></td></tr></tbody></table><h3 id="git-restore-重置文件"><a href="#git-restore-重置文件" class="headerlink" title="git restore 重置文件"></a>git restore 重置文件</h3><p>类似 git checkout – &lt;file&gt;     重置文件</p><p>git restore &lt;file&gt;撤销工作区的修改，从暂存区恢复至工作区，如果工作区没有则从版本库恢复至工作区。</p><p>git restore –staged &lt;file&gt;用作清除暂存区的文件，不影响工作区以及版本库中的文件</p><p><img src="/2021/69c3279c/542.png" alt="img"></p><h3 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h3><p><strong>原理：</strong> git revert是用于“反做”某一个版本，以达到撤销该版本的修改的目的。比如，我们 commit 了三个版本（版本一、版本二、 版本三），突然发现版本二不行（如：有bug），想要撤销版本二，但又不想影响撤销版本三的提交，就可以用 git revert 命令来反做版本二，生成新的版本四，这个版本四里会保留版本三的东西，但撤销了版本二的东西。如下图所示：</p><p><img src="/2021/69c3279c/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwNDE0MjA1ODE2MTg4.png" alt="这里写图片描述"></p><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><p><strong>原理：</strong> git reset的作用是修改HEAD的位置，即将HEAD指向的位置改变为之前存在的某个版本，如下图所示，假设我们要回退到版本一</p><p><img src="/2021/69c3279c/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwNDE0MjEyMjIxMDMz.png" alt="这里写图片描述"></p><p>在Git中，用<code>HEAD</code>表示当前版本</p><p>版本回退 HEAD往前回退一个版本(同理这里可以写对应的版本号) <code>git reset -–soft HEAD^</code></p><table><thead><tr><th>参数</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>–- hard</td><td></td><td>硬重置</td><td></td></tr><tr><td>–- soft</td><td></td><td></td><td></td></tr><tr><td>–- mixed</td><td></td><td></td><td></td></tr><tr><td>–- merge</td><td></td><td></td><td></td></tr><tr><td>–- keep</td><td></td><td></td><td></td></tr></tbody></table><h3 id="git-switch"><a href="#git-switch" class="headerlink" title="git switch"></a>git switch</h3><p>git switch 切换分支 远程有而本地没有的分支，而如果要从远程分支建一个同名的本地分支，并且关联远程分支</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xquery">git <span class="hljs-keyword">switch</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">branchName</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>git switch 创建一个新分支并切换到该新分支 </p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">git <span class="hljs-keyword">switch</span> -<span class="hljs-keyword">c</span> &lt;branchName&gt;<br></code></pre></td></tr></table></figure><p>git switch 以一个提交commit来创建一个分支</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">git <span class="hljs-keyword">switch</span> -<span class="hljs-keyword">c</span> test<span class="hljs-number">3</span> e<span class="hljs-number">053</span>cf<span class="hljs-number">128</span>d<span class="hljs-number">2</span>ad<span class="hljs-number">9</span>d<span class="hljs-number">35e2</span>f<span class="hljs-number">94878569596</span>fb<span class="hljs-number">32</span>f<span class="hljs-number">4306</span><br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">操作</th><th align="left">2.23-</th><th align="left">2.23+</th></tr></thead><tbody><tr><td align="left">管理分支</td><td align="left">git branch</td><td align="left">git branch</td></tr><tr><td align="left">切换分支</td><td align="left">git checkout</td><td align="left">git switch</td></tr><tr><td align="left">新建+切换分支</td><td align="left">git checkout -b</td><td align="left">git switch -c</td></tr><tr><td align="left">切换到commit id</td><td align="left">git checkout</td><td align="left">git checkout</td></tr></tbody></table><h3 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git rm [-f | --force] [-n] [-r] [--cached] [--ignore-unmatch]<br>  [--quiet] [--pathspec-from-file=&lt;file&gt; [--pathspec-file-nul]]<br>  [--] [&lt;pathspec&gt;…​]<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">--cached<br>使用命令可以将 Git 仓库中的某个文件从跟踪列表中删除<br>执行上述命令后，该文件将不再被 Git 跟踪，但仍会保留在本地文件系统中。<br>然后git commit -a提交更改。<br></code></pre></td></tr></table></figure><h1 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h1><p><code>.gitignore</code></p><p>可以参考Github的 <a href="https://github.com/github/gitignore">https://github.com/github/gitignore</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">project</span><br>.vscode/<br>/si/<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"></span><br><span class="language-bash">output/</span><br>Debug/<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">image chache</span><br>Thumbs.db<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">wps</span><br><span class="hljs-meta prompt_">~$</span><span class="language-bash">*.docx</span><br><span class="hljs-meta prompt_">~$</span><span class="language-bash">*.doc</span><br><span class="hljs-meta prompt_">~$</span><span class="language-bash">*.xlsx</span><br><span class="hljs-meta prompt_">~$</span><span class="language-bash">*.xls</span><br><span class="hljs-meta prompt_">~$</span><span class="language-bash">*.pptx</span><br><span class="hljs-meta prompt_">~$</span><span class="language-bash">*.ppt</span><br></code></pre></td></tr></table></figure><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><h2 id="修改分支指针"><a href="#修改分支指针" class="headerlink" title="修改分支指针"></a>修改分支指针</h2><p>git branch -f 分支名 commitID</p><p>作用是将其他分支上的本地代码硬重置到某个commitId下，不能重置本分支。比如我dev分支上某个节点的commitId叫 devID1</p><p>然后 git branch -f master devID1<br>那么master上的代码就会和dev一样，并且历史记录也会一样，只是dev分支上的代码可能会比master上的新一点，因为是重置的commitId</p><h2 id="git-status-显示不了汉字"><a href="#git-status-显示不了汉字" class="headerlink" title="git status 显示不了汉字"></a>git status 显示不了汉字</h2><p>git bash 终端输入命令：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">git config --global core.quotepath <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>在git仓库文件夹内打开git bash，在git branch的界面中右击空白处，弹出菜单，选择option，编码设定为 gb2312。</p><h2 id="git-ssh-非标端口"><a href="#git-ssh-非标端口" class="headerlink" title="git ssh 非标端口"></a>git ssh 非标端口</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone ssh://git@hostname:port/…/xxx.git<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">e.g.</span><br>git clone ssh://git@192.168.1.220:10022/frank/tools.git<br></code></pre></td></tr></table></figure><h2 id="验证ssh链接"><a href="#验证ssh链接" class="headerlink" title="验证ssh链接"></a>验证ssh链接</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh -T git@github.com<br>ssh -T ssh://git@192.168.1.220:10022<br></code></pre></td></tr></table></figure><h2 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push origin --delete branch_name<br></code></pre></td></tr></table></figure><h2 id="删除全部历史提交记录"><a href="#删除全部历史提交记录" class="headerlink" title="删除全部历史提交记录"></a>删除全部历史提交记录</h2><ol><li>尝试  运行 <code> git checkout --orphan latest_branch</code></li><li>添加所有文件<code>git add -A</code></li><li>提交更改<code>git commit -am &quot;commit message&quot;</code></li><li>删除分支<code>git branch -D main</code></li><li>将当前分支重命名<code>git branch -m main</code></li><li>最后，强制更新存储库。<code>git push -f origin main</code></li></ol><h2 id="清理仓库"><a href="#清理仓库" class="headerlink" title="!清理仓库!"></a>!清理仓库!</h2><p>!谨慎操作! !谨慎操作! !谨慎操作! !谨慎操作! !谨慎操作!</p><ol start="0"><li>可以先查看一下本地仓库的大小</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">du</span> -sh .git<br></code></pre></td></tr></table></figure><ol><li>移除本地仓库中指向旧提交的剩余refs，<code>git for-each-ref</code> 会打印仓库中匹配<code>refs/original</code>的所有refs，并使用<code>delete</code>作为前缀，此命令通过管道传送到 <code>git update-ref</code> 命令，该命令会移除所有指向旧commit的引用。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git for-each-ref --format=<span class="hljs-string">&#x27;delete %(refname)&#x27;</span> refs/original | git update-ref --stdin<br></code></pre></td></tr></table></figure><ol start="2"><li>以下命令会使reflog到期，因为它依然包含着对旧commit的引用。使用<code>--expire=now</code> 参数，确保它在目前为止到期了。如果没有该参数，只会移除超过90天的reflog。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reflog expire --expire=now --all<br></code></pre></td></tr></table></figure><ol start="3"><li>现在本地仓库依然包含着所有旧commit的对象，但已经没有引用指向它们了，这些对象需要被删除掉。此时可以使用 <code>git gc</code> 命令，Git的垃圾回收器会删除这些没有引用指向的对象。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git gc --prune=now<br></code></pre></td></tr></table></figure><p>​<code>gc</code>使用<code>--prune</code> 参数来清理特定时期的对象，默认情况下为2周，指定<code>now</code>将删除所有这些对象而没有时期限制。</p><ol start="4"><li><code>du -sh .git</code>此时，.git文件的大小只有104k了。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">du</span> -sh .git<br><span class="hljs-comment"># 104K    .git</span><br></code></pre></td></tr></table></figure><ol start="5"><li>如果确认所做的删除大文件操作没有问题，就可以提交到远程仓库了，一旦提交，再也没有办法恢复到原来的状态，一定要小心谨慎！一定要小心谨慎！一定要小心谨慎！</li><li>先进行备份工作，以免出现问题：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/Desktop/<br><span class="hljs-built_in">mkdir</span> gitthin_mirror &amp;&amp; <span class="hljs-built_in">cd</span> gitthin_mirror<br>git <span class="hljs-built_in">clone</span> --mirror git@gitee.com:coderhony/gitthin.git<br></code></pre></td></tr></table></figure><ol start="7"><li>再回到刚才做的已经瘦身的Git仓库</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/Desktop/gitthin/gitthin<br></code></pre></td></tr></table></figure><ol start="8"><li>把已瘦身的仓库同步到远程仓库，使用<code>—mirror</code>参数：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push --mirror &lt;url&gt;<br></code></pre></td></tr></table></figure><ol start="9"><li>为了确保都已同步，再执行以下命令：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push --all --force<br><span class="hljs-comment"># Everything up-to-date</span><br>git push --tags --force<br><span class="hljs-comment"># Everything up-to-date</span><br></code></pre></td></tr></table></figure><h2 id="一台电脑两个Github账号"><a href="#一台电脑两个Github账号" class="headerlink" title="一台电脑两个Github账号"></a>一台电脑两个Github账号</h2><ul><li><p>生成两个ssh key</p></li><li><p>编辑config文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Default GitHub</span><br>Host github.com<br>HostName github.com<br>User git<br>IdentityFile ~/.ssh/id_rsa<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"> Jack-InGitHub!</span> <br>Host pq.github.com<br>HostName github.com<br>User git<br>IdentityFile ~/.ssh/id_rsa_a<br></code></pre></td></tr></table></figure><ul><li>github.com 用id_rsa密钥</li><li>pq.github.com 用id_rsa_a密钥</li></ul></li></ul><ul><li><p>原来<code>git@github.com:Jack-InGitHub/test.git</code></p><p>现在<code>git@pq.github.com:Jack-InGitHub/test.git</code></p></li><li><p>记得再配置不同的邮箱名</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --<span class="hljs-built_in">local</span> user.name <span class="hljs-string">&quot;username&quot;</span><br>git config --<span class="hljs-built_in">local</span> user.email user@email.com<br></code></pre></td></tr></table></figure><h2 id="利用管道删除全部本地分支"><a href="#利用管道删除全部本地分支" class="headerlink" title="利用管道删除全部本地分支"></a>利用管道删除全部本地分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout master<br>git branch | grep -v <span class="hljs-string">&#x27;master&#x27;</span> | xargs git branch -D<br></code></pre></td></tr></table></figure><h2 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h2><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment"># 把旧仓库被分成本地git文件目录</span><br>git <span class="hljs-keyword">clone</span> <span class="hljs-title">--mirror</span> 旧的git地址<br><br><span class="hljs-comment"># 推动本地目录到新的地址</span><br>cd xxx.git<br>git push --mirror 新的git地址<br><br><span class="hljs-comment"># 以上就完成了单个仓库的迁移</span><br></code></pre></td></tr></table></figure><h2 id="删除未追踪的文件"><a href="#删除未追踪的文件" class="headerlink" title="删除未追踪的文件"></a>删除未追踪的文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">git clean -f -d<br><span class="hljs-comment"># -d 递归清理</span><br><span class="hljs-comment"># -f = --force 强制清理</span><br>-d<br>    Normally, when no &lt;path&gt; is specified, git clean will not recurse into untracked directories to avoid removing too much. Specify -d to have it recurse into such directories as well. If any paths are specified, -d is irrelevant; all untracked files matching the specified paths (with exceptions <span class="hljs-keyword">for</span> nested git directories mentioned under --force) will be removed.<br><br>-f<br>    --force<br>    If the Git configuration variable clean.requireForce is not <span class="hljs-built_in">set</span> to <span class="hljs-literal">false</span>, git clean will refuse to delete files or directories unless given -f or -i. Git will refuse to modify untracked nested git repositories (directories with a .git subdirectory) unless a second -f is given.<br></code></pre></td></tr></table></figure><h2 id="submodule-子模块-子仓库"><a href="#submodule-子模块-子仓库" class="headerlink" title="submodule 子模块 子仓库"></a>submodule 子模块 子仓库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git submodule <span class="hljs-built_in">help</span><br>usage: git submodule [--quiet] [--cached]<br>   or: git submodule [--quiet] add [-b &lt;branch&gt;] [-f|--force] [--name &lt;name&gt;] [--reference &lt;repository&gt;] [--] &lt;repository&gt; [&lt;path&gt;]<br>   or: git submodule [--quiet] status [--cached] [--recursive] [--] [&lt;path&gt;...]<br>   or: git submodule [--quiet] init [--] [&lt;path&gt;...]<br>   or: git submodule [--quiet] deinit [-f|--force] (--all| [--] &lt;path&gt;...)<br>   or: git submodule [--quiet] update [--init] [--remote] [-N|--no-fetch] [-f|--force] [--checkout|--merge|--rebase] [--[no-]recommend-shallow] [--reference &lt;repository&gt;] [--recursive] [--[no-]single-branch] [--] [&lt;path&gt;...]<br>   or: git submodule [--quiet] set-branch (--default|--branch &lt;branch&gt;) [--] &lt;path&gt;<br>   or: git submodule [--quiet] set-url [--] &lt;path&gt; &lt;newurl&gt;<br>   or: git submodule [--quiet] summary [--cached|--files] [--summary-limit &lt;n&gt;] [commit] [--] [&lt;path&gt;...]<br>   or: git submodule [--quiet] foreach [--recursive] &lt;<span class="hljs-built_in">command</span>&gt;<br>   or: git submodule [--quiet] <span class="hljs-built_in">sync</span> [--recursive] [--] [&lt;path&gt;...]<br>   or: git submodule [--quiet] absorbgitdirs [--] [&lt;path&gt;...]<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 子模块的添加</span><br>git submodule add [-b branch] &lt;url&gt; &lt;path&gt;<br><span class="hljs-comment"># 子模块的初始化&amp;更新下载</span><br>git submodule init<br>git submodule update<br><span class="hljs-comment"># 递归更新子模块</span><br>git submodule update --init --recursive<br></code></pre></td></tr></table></figure><ul><li>还有更简单一点的方式。 如果给 <code>git clone</code> 命令传递 <code>--recurse-submodules</code> 选项，它就会自动初始化并更新仓库中的每一个子模块， 包括可能存在的嵌套子模块。</li></ul><h3 id="删除-git-submodule"><a href="#删除-git-submodule" class="headerlink" title="删除 git submodule"></a>删除 git submodule</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1. 删除submodule缓存</span><br>git add .gitmodules<br>git rm --cached submodule_name<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. <span class="hljs-built_in">rm</span> -rf submodule_name 删除submodule目录</span><br>rm -rf submodule_name<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">3. vi .gitmodules 删除项目目录下.gitmodules中子模块相关条目</span><br>移除对应的submodule信息，只有1个submodule信息也可以删除该文件。<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">4. vi .git/config 删除配置项中子模块相关条目</span><br>移除对应的submodule信息<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">5. <span class="hljs-built_in">rm</span> .git/module/* 删除模块下的子模块目录，每个子模块对应一个目录，注意只删除对应的子模块目录即可</span><br></code></pre></td></tr></table></figure><h2 id="合并没有相关历史的提交"><a href="#合并没有相关历史的提交" class="headerlink" title="合并没有相关历史的提交"></a>合并没有相关历史的提交</h2><p>将test2分支合并到master分支中 <code>git merge test2 --allow-unrelated-histories </code></p><h4 id="合并两个没有相同历史的Git仓库"><a href="#合并两个没有相同历史的Git仓库" class="headerlink" title="合并两个没有相同历史的Git仓库"></a><a href="https://www.cnblogs.com/masahiro/p/12155758.html">合并两个没有相同历史的Git仓库</a></h4><p>首先在需要合并的仓库中增加另外一个远程仓库 <code>git remote add test2 http://git.xxx.xxx/test2 </code></p><p>然后将test2的仓库拉取到本地 <code>git fetch test2 </code></p><p>创建本地分支 <code>git checkout -b test2 test2/master </code></p><p>切换到目标分区 <code>git checkout master </code></p><p>将test2分支合并到master分支中<code>git merge test2 --allow-unrelated-histories</code></p><p>至此分支合并完成,只需将分支提交到服务器即可</p><h2 id="将init后默认branch设定成为main"><a href="#将init后默认branch设定成为main" class="headerlink" title="将init后默认branch设定成为main"></a>将init后默认branch设定成为main</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global init.defaultBranch main<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 把当前master分支改名为main 其中-M的意思是移动或者重命名当前分支</span><br>git branch -M main<br></code></pre></td></tr></table></figure><h2 id="让git流量走代理-SSH的代理"><a href="#让git流量走代理-SSH的代理" class="headerlink" title="让git流量走代理 SSH的代理"></a>让git流量走代理 SSH的代理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># socks代理</span><br>git config --global http.proxy <span class="hljs-string">&#x27;socks5://127.0.0.1:1080&#x27;</span><br>git config --global https.proxy <span class="hljs-string">&#x27;socks5://127.0.0.1:1080&#x27;</span><br><span class="hljs-comment"># http/https代理</span><br>git config --global http.proxy http://127.0.0.1:8080<br>git config --global https.proxy https://127.0.0.1:8080<br></code></pre></td></tr></table></figure><p>也可以直接修改~&#x2F;.gitconfig文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi ~/.gitconfig<br></code></pre></td></tr></table></figure><p>新建或修改这两项配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">[http]<br>proxy = socks5://127.0.0.1:1080<br><br>[https]<br>proxy = socks5://127.0.0.1:1080<br></code></pre></td></tr></table></figure><p>如果要取消代理：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global --<span class="hljs-built_in">unset</span> http.proxy<br>git config --global --<span class="hljs-built_in">unset</span> https.proxy<br></code></pre></td></tr></table></figure><p>带参数是临时的，修改配置文件是永久变更，修改后最好重启git 设置生效。</p><p>查看配置信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config -l --global<br></code></pre></td></tr></table></figure><p>执行查看代理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config -l<br></code></pre></td></tr></table></figure><h3 id="SSH流量"><a href="#SSH流量" class="headerlink" title="SSH流量"></a>SSH流量</h3><p>上面的方法只代理了http和https的流量, 我们用ssh协议的较多这就需要去代理ssh流量了</p><p>配置ssh走代理我们就需要去配置 ssh 程序(而不是git), 我们需要在 <code>~/.ssh/config</code> 文件中设置 <code>ProxyCommand</code> 选项。</p><ul><li><p>Linux 和 macOS 是通过 <code>nc</code> 来执行 <code>ProxyCommand</code> 的，</p></li><li><p>Windows 下则是通过 <code>connect</code>。</p></li></ul><h4 id="Linux-SSH-配置"><a href="#Linux-SSH-配置" class="headerlink" title="Linux SSH 配置"></a>Linux SSH 配置</h4><p>编辑 <code>~/.ssh/config</code> 文件,给文件加上如下对应内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Host 后面 接的 github.com 是指定要走代理的仓库域名。</span><br><span class="hljs-comment"># 在 ProxyCommand 中，Linux 和 macOS 用户用的是 nc。</span><br><span class="hljs-comment"># -X 选项后面接的是 connect. 意思是 HTTPS 代理。</span><br><span class="hljs-comment"># -x 选项后面加上代理地址和端口号。</span><br><span class="hljs-comment"># 在调用 ProxyCommand 时，%h 和 %p 将会被自动替换为目标主机名和 SSH 命令指定的端口（%h 和 %p 不要修改，保留原样即可）。</span><br>Host github.com<br>    User git<br>    ProxyCommand nc -X connect -x 127.0.0.1:7890 %h %p<br><span class="hljs-comment"># -X 选项后面接的是 5. 意思是 socks5 代理。</span><br>Host github.com<br>    User git<br>    ProxyCommand nc -X 5 -x 127.0.0.1:7891 %h %p<br></code></pre></td></tr></table></figure><h4 id="Windows-SSH-配置"><a href="#Windows-SSH-配置" class="headerlink" title="Windows SSH 配置"></a>Windows SSH 配置</h4><p>编辑 <code>~/.ssh/config</code> 文件，然后增加如下内容：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment"># Host 后面 接的 github.com 是指定要走代理的仓库域名。</span><br><span class="hljs-comment"># 在 ProxyCommand 中，Windows 用户用的是 connect。</span><br><span class="hljs-comment"># -S代表的是socks5 -H 选项的意思是 HTTP 代理 </span><br><span class="hljs-comment"># 在调用 ProxyCommand 时，%h 和 %p 将会被自动替换为目标主机名和 SSH 命令指定的端口（%h 和 %p 不要修改，保留原样即可）。</span><br>Host github.com<br>ProxyCommand <span class="hljs-keyword">connect</span> -S <span class="hljs-number">127.0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">1080</span> <span class="hljs-variable">%h</span> <span class="hljs-variable">%p</span><br>Host github.com<br>ProxyCommand <span class="hljs-keyword">connect</span> -H <span class="hljs-number">127.0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">1080</span> <span class="hljs-variable">%h</span> <span class="hljs-variable">%p</span><br></code></pre></td></tr></table></figure><h2 id="patch的使用"><a href="#patch的使用" class="headerlink" title="patch的使用"></a>patch的使用</h2><p>patch文件其实就是运行<code>git diff</code>控制台输出的信息并保存的文件.</p><p><strong>patch的创建</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git diff &gt; my_custom_patch_file.patch<br></code></pre></td></tr></table></figure><p><strong>patch的应用</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git apply patch_file.patch <br></code></pre></td></tr></table></figure><p><strong>patch出现一些提示, 这个提示的意思</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">patch:19: trailing whitespace.<br>warning: 1 line adds whitespace errors.<br><br><span class="hljs-comment"># 告警的含义是提示有空格在行尾出现。</span><br><span class="hljs-comment"># 不用太担心这个问题并不大</span><br><span class="hljs-comment"># 可以使用 --no-verify 开关绕过此问题</span><br></code></pre></td></tr></table></figure><h2 id="git-branch-不单独输出在控制台-而是像新开页面一样"><a href="#git-branch-不单独输出在控制台-而是像新开页面一样" class="headerlink" title="git branch 不单独输出在控制台 而是像新开页面一样"></a>git branch 不单独输出在控制台 而是像新开页面一样</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global pager.branch <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h2 id="一次推送多个远程仓库"><a href="#一次推送多个远程仓库" class="headerlink" title="一次推送多个远程仓库"></a>一次推送多个远程仓库</h2><hr><p><strong>使用 <code>git remote set-url</code> 命令</strong></p><p>2.1# 删除方法一的 <code>oschina</code> 远程仓库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote <span class="hljs-built_in">rm</span> oschina<br></code></pre></td></tr></table></figure><p>2.2# 使用如下命令添加远程仓库。</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">git</span> <span class="hljs-string">remote</span> <span class="hljs-built_in">set-url</span> <span class="hljs-built_in">--add</span> <span class="hljs-string">github</span> <span class="hljs-string">https</span>://<span class="hljs-string">git</span>.<span class="hljs-string">oschina</span>.<span class="hljs-string">net</span>/<span class="hljs-string">zxbetter</span>/<span class="hljs-string">test</span>.<span class="hljs-string">git</span><br></code></pre></td></tr></table></figure><p>2.3# 查看远程仓库情况。可以看到 <code>github</code> 远程仓库有两个 <code>push</code> 地址。<em>这种方法的好处是每次只需要 <code>push</code> 一次就行了。</em></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">git remote -v<br>github  https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/zxbetter/</span>test.git (fetch)<br>github  https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/zxbetter/</span>test.git (push)<br>github  https:<span class="hljs-regexp">//gi</span>t.oschina.net<span class="hljs-regexp">/zxbetter/</span>test.git (push)<br></code></pre></td></tr></table></figure><hr><p><strong>修改配置文件</strong></p><p>打开 <code>.git/config</code> 找到 <code>[remote &quot;github&quot;]</code>，添加对应的 <code>url</code> 即可，效果如下。这种方法其实和方法二是一样的。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">[remote <span class="hljs-string">&quot;github&quot;</span>]<br>    url = https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/zxbetter/</span>test.git<br>    fetch = +refs<span class="hljs-regexp">/heads/</span>*:refs<span class="hljs-regexp">/remotes/gi</span>thub/*<br>    url = https:<span class="hljs-regexp">//gi</span>t.oschina.net<span class="hljs-regexp">/zxbetter/</span>test.git<br></code></pre></td></tr></table></figure><h2 id="忽略已经受到版本管理的文件修改"><a href="#忽略已经受到版本管理的文件修改" class="headerlink" title="忽略已经受到版本管理的文件修改"></a>忽略已经受到版本管理的文件修改</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">隐藏</span><br>git update-index --assume-unchanged &lt;path&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">恢复可见</span><br>git update-index --no-assume-unchanged &lt;path&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看所有已经忽略的文件</span><br>! git ls-files -v | grep &#x27;^h&#x27; | cut -c3-<br><span class="hljs-meta prompt_"># </span><span class="language-bash">重置所有已经忽略的文件为可见</span><br>git ls-files -v | grep &#x27;^[a-z]&#x27; | cut -c3- | xargs git update-index --no-assume-unchanged --<br></code></pre></td></tr></table></figure><h2 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h2><p><code>.gitignore</code> 文件是一个配置文件，用于告诉 Git 版本控制系统哪些文件或目录不需要被跟踪或包含在版本控制中。这个文件通常位于项目的根目录下，并且它的存在对于避免将不必要的文件（比如编译生成的文件、日志文件、个人配置文件等）加入到版本库中非常重要。</p><p><strong>使用<code>git config</code>命令</strong>：<br>你可以通过设置Git的全局或仓库级别的配置来指定一个默认的<code>.gitignore</code>模板。例如，设置全局的<code>.gitignore</code>模板：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global core.excludesfile ~/.gitignore_global<br></code></pre></td></tr></table></figure><p>**使用<code>gitignore.io</code>**：<br><code>gitignore.io</code>是一个在线服务，可以根据你使用的操作系统、编程语言和IDE生成<code>.gitignore</code>文件。访问<a href="https://www.gitignore.io/">gitignore.io</a>，选择你需要的选项，然后下载生成的<code>.gitignore</code>文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">参数里面的 c windows 是两个参数，分别设定语言和环境</span><br>curl -sL &quot;https://www.toptal.com/developers/gitignore/api/c,windows&quot; &gt;&gt; .gitignore<br></code></pre></td></tr></table></figure><blockquote><p>  Tips: 如果你不慎<strong>在创建.gitignore文件之前就push了项目</strong>，那么即使你在.gitignore文件中写入新的过滤规则，这些规则也不会起作用，Git仍然会对所有文件进行版本管理。</p></blockquote><p><strong>语法</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">.gitignore 忽略规则的语法如下：</span><br><br>1、空格不匹配任意文件，可作为分隔符，可用反斜杠转义<br><br>2、以“＃”开头的行都会被 Git 忽略。即#开头的文件标识注释，可以使用反斜杠进行转义。<br><br>3、可以使用标准的glob模式匹配。所谓的glob模式是指shell所使用的简化了的正则表达式。<br><br>4、以斜杠&quot;/&quot;开头表示目录；&quot;/&quot;结束的模式只匹配文件夹以及在该文件夹路径下的内容，但是不匹配该文件；&quot;/&quot;开始的模式匹配项目跟目录；如果一个模式不包含斜杠，则它匹配相对于当前 .gitignore 文件路径的内容，如果该模式不在 .gitignore 文件中，则相对于项目根目录。<br><br>5、以星号&quot;*&quot;通配多个字符，即匹配多个任意字符；使用两个星号&quot;**&quot; 表示匹配任意中间目录，比如a/**/z可以匹配 a/z, a/b/z 或 a/b/c/z等。<br><br>6、以问号&quot;?&quot;通配单个字符，即匹配一个任意字符；<br><br>7、以方括号&quot;[]&quot;包含单个字符的匹配列表，即匹配任何一个列在方括号中的字符。比如[abc]表示要么匹配一个a，要么匹配一个b，要么匹配一个c；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配。比如[0-9]表示匹配所有0到9的数字，[a-z]表示匹配任意的小写字母）。<br><br>8、以叹号&quot;!&quot;表示不忽略(跟踪)匹配到的文件或目录，即要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。需要特别注意的是：如果文件的父目录已经被前面的规则排除掉了，那么对这个文件用&quot;!&quot;规则是不起作用的。也就是说&quot;!&quot;开头的模式表示否定，该文件将会再次被包含，如果排除了该文件的父级目录，则使用&quot;!&quot;也不会再次被包含。可以使用反斜杠进行转义。<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">此为注释 – 将被 Git 忽略</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">忽略所有 .a 结尾的文件</span><br>*.a<br><span class="hljs-meta prompt_"># </span><span class="language-bash">但 lib.a 除外</span><br>!lib.a<br><span class="hljs-meta prompt_"># </span><span class="language-bash">仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span><br>/TODO<br><span class="hljs-meta prompt_"># </span><span class="language-bash">表示仅仅忽略根目录下的bin文件</span><br>/bin:<br><span class="hljs-meta prompt_"># </span><span class="language-bash">忽略 所有 build/ 目录下的所有文件</span><br>build/<br><span class="hljs-meta prompt_"># </span><span class="language-bash">表示忽略 任意路径下 所有foo文件夹 /foo,a/foo,a/b/foo等</span><br>**/foo:<br><span class="hljs-meta prompt_"># </span><span class="language-bash">会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span><br>doc/*.txt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">忽略 doc/ 目录下所有扩展名为 txt 的文件</span><br>doc/**/*.txt<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">示例</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">忽略 mtk文件夹 下 除了ont.txt 的所有文件</span><br>!/mtk/one.txt<br>/mtk/*<br></code></pre></td></tr></table></figure><p>已经受到版本库管理的文件需要忽略查考Note章节。</p><h2 id="gitattributes"><a href="#gitattributes" class="headerlink" title=".gitattributes"></a>.gitattributes</h2><p><code>.gitattributes</code> 文件是一个配置文件，它允许你为 Git 仓库中的文件定义属性。这些属性可以影响 Git 的行为，例如如何合并文件、如何显示差异、文件的换行符处理等。<code>.gitattributes</code> 文件通常位于项目的根目录下，它与 <code>.gitignore</code> 文件不同，后者用于指定 Git 忽略的文件。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>下面是一个示例 <code>.gitattributes</code> 文件。 您可以将其用作仓库的模板：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs text"># Set the default behavior, in case people don&#x27;t have core.autocrlf set.<br>* text=auto<br><br># Explicitly declare text files you want to always be normalized and converted<br># to native line endings on checkout.<br>*.c text<br>*.h text<br><br># Declare files that will always have CRLF line endings on checkout.<br>*.sln text eol=crlf<br><br># Denote all files that are truly binary and should not be modified.<br>*.png binary<br>*.jpg binary<br></code></pre></td></tr></table></figure><p>你会注意到，文件是匹配的，即 <code>*.c</code>、<code>*.sln</code>、<code>*.png</code>（用空格分隔），然后给定一个设置，即 <code>text</code>、<code>text eol=crlf</code>、<code>binary</code>。 我们将在下面介绍一些可能的设置。</p><ul><li><code>text=auto</code> Git 将以其认为的最佳方式处理文件。 这是一个合适的默认选项。</li><li>在检出时 <code>text eol=crlf</code> Git 将始终把行结束符转换为 <code>CRLF</code>。 你应将其用于必须保持 <code>CRLF</code> 结束符的文件，即使在 OSX 或 Linux 上。</li><li>在检出时 <code>text eol=lf</code> Git 将始终把行结束符转换为 <code>LF</code>。 您应将其用于必须保持 LF 结束符的文件，即使在 Windows 上。</li><li><code>binary</code> Git 会理解指定文件不是文本，并且不应尝试更改这些文件。 该 <code>binary</code> 设置也是 <code>-text -diff</code> 的别名。</li></ul><p><a href="https://docs.github.com/en/get-started/getting-started-with-git/configuring-git-to-handle-line-endings">参考</a></p>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派4B GPIO库 Wiringpi Oops -  Unable to Determine Board Type</title>
    <link href="/2021/d8eac117/"/>
    <url>/2021/d8eac117/</url>
    
    <content type="html"><![CDATA[<p>关键词:<br>树莓派4B GPIO库 wiringpi Oops - unable to determine board type… model_ 17</p><h1 id="先说解决方案"><a href="#先说解决方案" class="headerlink" title="先说解决方案"></a>先说解决方案</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /tmp<br>wget https://project-downloads.drogon.net/wiringpi-latest.deb<br>sudo dpkg -i wiringpi-latest.deb<br></code></pre></td></tr></table></figure><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p><a href="http://wiringpi.com/wiringpi-updated-to-2-52-for-the-raspberry-pi-4b/">官网给的解释</a> <a href="http://wiringpi.com/wiringpi-updated-to-2-52-for-the-raspberry-pi-4b/">http://wiringpi.com/wiringpi-updated-to-2-52-for-the-raspberry-pi-4b/</a></p><p>树莓派4B 用wiringpi这个GPIO库的时候无法正常使用，我是在用作树莓派pwm风扇调速的时候发现一直输出不了pwm，示波器抓波形发现也不对，检查原因的时候发现 <code>gpio readall</code>输出报错，最后官方文档说到<strong>树莓派4B</strong>需要保证<strong>2.52版本</strong>及以上才能适配(<code>gpio -v</code>查看版本)，apt直接安装的似乎还没更新最新版本只到2.50，不太清楚为什么一年了这源都还没更新</p>]]></content>
    
    
    <categories>
      
      <category>raspberry</category>
      
    </categories>
    
    
    <tags>
      
      <tag>raspberry</tag>
      
      <tag>wiringpi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派4B PWM温控风扇 Wiringpi库 PWM调整频率 54M PWM频率不对</title>
    <link href="/2021/b0f7a103/"/>
    <url>/2021/b0f7a103/</url>
    
    <content type="html"><![CDATA[<p>关键词:<br>树莓派4B PWM温控风扇 wiringpi库 PWM调整频率 54M PWM频率不对</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>很多博客文章都是说树莓派PWM是按<strong>19.2M</strong>基频率来算的，今天用逻辑分析仪抓了一下波形后发现频率有问题，然后按测得的频率反推，算出来我这里好像是按<strong>54M</strong>的时钟频率来的，不清楚是什么情况。我这里的环境是<code>wiringpi=2.52</code> + <code>树莓派4B</code> + <code>Linux raspberrypi 5.10.52-v7l+ #1440 SMP Tue Jul 27 09:55:21 BST 2021 armv7l GNU/Linux</code></p><p><a href="https://www.cnblogs.com/miaoxiong/p/10556072.html">PWM 19.2M时钟的原文</a> <a href="https://www.cnblogs.com/miaoxiong/p/10556072.html">https://www.cnblogs.com/miaoxiong/p/10556072.html</a></p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>思路就是读取cpu温度的文件，根据不同温度来控制PWM控制风扇转停，这个编译下来跑起来<code>htop</code>看cpu占用一直等于0，对比原来python写的温控风扇2% 3%的cpu占用在跳，没想到差距这么大。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;wiringPi.h&gt;</span></span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FAN_PIN         1</span><br><span class="hljs-comment">// Hz</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PWM_FRQ         (200ul)</span><br><span class="hljs-comment">// frq = 54M / PWM_RANG / divisor</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PWM_RANG        (100ul)</span><br><span class="hljs-comment">// temperature</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TEMP_PATH <span class="hljs-string">&quot;/sys/class/thermal/thermal_zone0/temp&quot;</span></span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFF_MAX_SIZE   32u</span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DBG_LOG(format, ...)      do&#123; printf(format, ##__VA_ARGS__ ); &#125;while(0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DBG_LOG(format, ...)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">GetTemperature</span><span class="hljs-params">(<span class="hljs-type">int</span> *temp)</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">GetDuty</span><span class="hljs-params">(<span class="hljs-type">int</span> temp)</span>;<br><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> Duty = <span class="hljs-number">0</span>;<br>FILE *pFile = <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">char</span> buff[BUFF_MAX_SIZE] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">float</span> fTemperature = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> Temperature = <span class="hljs-number">0</span>;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    DBG_LOG(<span class="hljs-string">&quot;Raspberry Pi wiringPi PWM test program\n&quot;</span>);<br>    <span class="hljs-keyword">if</span> (wiringPiSetup() == <span class="hljs-number">-1</span>)<br>    &#123;<br>        DBG_LOG(<span class="hljs-string">&quot;GPIO setup error!\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">2</span>);<br>    &#125;<br>    pinMode(FAN_PIN, PWM_OUTPUT);<br>    pwmSetMode(PWM_MODE_MS);<br>    pwmSetRange(PWM_RANG);                       <span class="hljs-comment">//base frq 54M</span><br>    pwmSetClock(<span class="hljs-number">54000000</span>/PWM_RANG/PWM_FRQ);<br>    pwmWrite(FAN_PIN, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        GetTemperature(&amp;Temperature);<br>        Duty = GetDuty(Temperature);<br><br>        pwmWrite(FAN_PIN, Duty);<br>        DBG_LOG(<span class="hljs-string">&quot;Temp=%d Duty=%d\n&quot;</span>, Temperature, Duty);<br>        delay(<span class="hljs-number">1000</span>*<span class="hljs-number">10</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">GetTemperature</span><span class="hljs-params">(<span class="hljs-type">int</span> *temp)</span><br>&#123;<br>    pFile = fopen(TEMP_PATH, <span class="hljs-string">&quot;r&quot;</span>);<br>    <span class="hljs-keyword">if</span>(pFile == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        DBG_LOG(<span class="hljs-string">&quot;file can&#x27;t open PATH=%s p=%p\n&quot;</span>, TEMP_PATH, pFile);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    fgets(buff, BUFF_MAX_SIZE, pFile);<br>    *temp = (<span class="hljs-type">int</span>)(atoi(buff)/<span class="hljs-number">1000.0</span>+<span class="hljs-number">0.5</span>);<br>    fclose(pFile);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">GetDuty</span><span class="hljs-params">(<span class="hljs-type">int</span> temp)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(temp &gt;= <span class="hljs-number">60</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(temp &gt;= <span class="hljs-number">55</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">80</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(temp &gt;= <span class="hljs-number">53</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">70</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(temp &gt;= <span class="hljs-number">50</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">60</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(temp &gt;= <span class="hljs-number">49</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">50</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后编译一下<br><code>gcc -Wall -O -o fan fan.c   -lwiringPi </code></p><p>再加个开机启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo nano /etc/rc.local<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在文件<span class="hljs-built_in">exit</span>前加上 fan程序</span><br>sudo ./path/fan &amp;<br></code></pre></td></tr></table></figure><p>这个温度控制不是很好，转转停停的(<em>估计是PWM值太小风扇转的不好, 尝试加电容电感应该会好些</em>)</p>]]></content>
    
    
    <categories>
      
      <category>raspberry</category>
      
    </categories>
    
    
    <tags>
      
      <tag>raspberry</tag>
      
      <tag>wiringpi</tag>
      
      <tag>pwm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RT-Thread</title>
    <link href="/2021/42e53028/"/>
    <url>/2021/42e53028/</url>
    
    <content type="html"><![CDATA[<h1 id="RT-Thread-目录"><a href="#RT-Thread-目录" class="headerlink" title="RT-Thread 目录"></a>RT-Thread 目录</h1><p>[TOC]</p><h1 id="内核简介"><a href="#内核简介" class="headerlink" title="内核简介"></a>内核简介</h1><h2 id="自动初始化机制"><a href="#自动初始化机制" class="headerlink" title="自动初始化机制"></a>自动初始化机制</h2><table><thead><tr><th><strong>初始化顺序</strong></th><th><strong>宏接口</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>1</td><td>INIT_BOARD_EXPORT(fn)</td><td>非常早期的初始化，此时调度器还未启动</td></tr><tr><td>2</td><td>INIT_PREV_EXPORT(fn)</td><td>主要是用于纯软件的初始化、没有太多依赖的函数</td></tr><tr><td>3</td><td>INIT_DEVICE_EXPORT(fn)</td><td>外设驱动初始化相关，比如网卡设备</td></tr><tr><td>4</td><td>INIT_COMPONENT_EXPORT(fn)</td><td>组件初始化，比如文件系统或者 LWIP</td></tr><tr><td>5</td><td>INIT_ENV_EXPORT(fn)</td><td>系统环境初始化，比如挂载文件系统</td></tr><tr><td>6</td><td>INIT_APP_EXPORT(fn)</td><td>应用初始化，比如 GUI 应用</td></tr></tbody></table><h2 id="内核对象管理架构"><a href="#内核对象管理架构" class="headerlink" title="内核对象管理架构"></a>内核对象管理架构</h2><p>派生和继承</p><p><img src="/2021/42e53028/03kernel_object-1608970713169.png" alt="RT-Thread 的内核对象容器及链表"></p><p><img src="/2021/42e53028/03kernel_object2-1608970663476.png" alt="03kernel_object2"></p><h2 id="内核rtconfig-h配置"><a href="#内核rtconfig-h配置" class="headerlink" title="内核rtconfig.h配置"></a>内核rtconfig.h配置</h2><p>（1）RT-Thread 内核部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 表示内核对象的名称的最大长度，若代码中对象名称的最大长度大于宏定义的长度，</span><br><span class="hljs-comment"> * 多余的部分将被截掉。*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_NAME_MAX 8</span><br><br><span class="hljs-comment">/* 字节对齐时设定对齐的字节个数。常使用 ALIGN(RT_ALIGN_SIZE) 进行字节对齐。*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_ALIGN_SIZE 4</span><br><br><span class="hljs-comment">/* 定义系统线程优先级数；通常用 RT_THREAD_PRIORITY_MAX-1 定义空闲线程的优先级 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_THREAD_PRIORITY_MAX 32</span><br><br><span class="hljs-comment">/* 定义时钟节拍，为 100 时表示 100 个 tick 每秒，一个 tick 为 10ms */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_TICK_PER_SECOND 100</span><br><br><span class="hljs-comment">/* 检查栈是否溢出，未定义则关闭 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USING_OVERFLOW_CHECK</span><br><br><span class="hljs-comment">/* 定义该宏开启 debug 模式，未定义则关闭 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_DEBUG</span><br><span class="hljs-comment">/* 开启 debug 模式时：该宏定义为 0 时表示关闭打印组件初始化信息，定义为 1 时表示启用 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_DEBUG_INIT 0</span><br><span class="hljs-comment">/* 开启 debug 模式时：该宏定义为 0 时表示关闭打印线程切换信息，定义为 1 时表示启用 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_DEBUG_THREAD 0</span><br><br><span class="hljs-comment">/* 定义该宏表示开启钩子函数的使用，未定义则关闭 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USING_HOOK</span><br><br><span class="hljs-comment">/* 定义了空闲线程的栈大小 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IDLE_THREAD_STACK_SIZE 256</span><br></code></pre></td></tr></table></figure><p>（2）线程间同步与通信部分，该部分会使用到的对象有信号量、互斥量、事件、邮箱、消息队列、信号等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 定义该宏可开启信号量的使用，未定义则关闭 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USING_SEMAPHORE</span><br><br><span class="hljs-comment">/* 定义该宏可开启互斥量的使用，未定义则关闭 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USING_MUTEX</span><br><br><span class="hljs-comment">/* 定义该宏可开启事件集的使用，未定义则关闭 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USING_EVENT</span><br><br><span class="hljs-comment">/* 定义该宏可开启邮箱的使用，未定义则关闭 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USING_MAILBOX</span><br><br><span class="hljs-comment">/* 定义该宏可开启消息队列的使用，未定义则关闭 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USING_MESSAGEQUEUE</span><br><br><span class="hljs-comment">/* 定义该宏可开启信号的使用，未定义则关闭 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USING_SIGNALS</span><br></code></pre></td></tr></table></figure><p>（3）内存管理部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 开启静态内存池的使用 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USING_MEMPOOL</span><br><br><span class="hljs-comment">/* 定义该宏可开启两个或以上内存堆拼接的使用，未定义则关闭 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USING_MEMHEAP</span><br><br><span class="hljs-comment">/* 开启小内存管理算法 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USING_SMALL_MEM</span><br><br><span class="hljs-comment">/* 关闭 SLAB 内存管理算法 */</span><br><span class="hljs-comment">/* #define RT_USING_SLAB */</span><br><br><span class="hljs-comment">/* 开启堆的使用 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USING_HEAP</span><br></code></pre></td></tr></table></figure><p>（4）内核设备对象</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 表示开启了系统设备的使用 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USING_DEVICE</span><br><br><span class="hljs-comment">/* 定义该宏可开启系统控制台设备的使用，未定义则关闭 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USING_CONSOLE</span><br><span class="hljs-comment">/* 定义控制台设备的缓冲区大小 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_CONSOLEBUF_SIZE 128</span><br><span class="hljs-comment">/* 控制台设备的名称 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_CONSOLE_DEVICE_NAME <span class="hljs-string">&quot;uart1&quot;</span></span><br></code></pre></td></tr></table></figure><p>（5）自动初始化方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 定义该宏开启自动初始化机制，未定义则关闭 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USING_COMPONENTS_INIT</span><br><br><span class="hljs-comment">/* 定义该宏开启设置应用入口为 main 函数 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USING_USER_MAIN</span><br><span class="hljs-comment">/* 定义 main 线程的栈大小 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_MAIN_THREAD_STACK_SIZE 2048</span><br></code></pre></td></tr></table></figure><p>（6）FinSH</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 定义该宏可开启系统 FinSH 调试工具的使用，未定义则关闭 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USING_FINSH</span><br><br><span class="hljs-comment">/* 开启系统 FinSH 时：将该线程名称定义为 tshell */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FINSH_THREAD_NAME <span class="hljs-string">&quot;tshell&quot;</span></span><br><br><span class="hljs-comment">/* 开启系统 FinSH 时：使用历史命令 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FINSH_USING_HISTORY</span><br><span class="hljs-comment">/* 开启系统 FinSH 时：对历史命令行数的定义 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FINSH_HISTORY_LINES 5</span><br><br><span class="hljs-comment">/* 开启系统 FinSH 时：定义该宏开启使用 Tab 键，未定义则关闭 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FINSH_USING_SYMTAB</span><br><br><span class="hljs-comment">/* 开启系统 FinSH 时：定义该线程的优先级 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FINSH_THREAD_PRIORITY 20</span><br><span class="hljs-comment">/* 开启系统 FinSH 时：定义该线程的栈大小 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FINSH_THREAD_STACK_SIZE 4096</span><br><span class="hljs-comment">/* 开启系统 FinSH 时：定义命令字符长度 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FINSH_CMD_SIZE 80</span><br><br><span class="hljs-comment">/* 开启系统 FinSH 时：定义该宏开启 MSH 功能 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FINSH_USING_MSH</span><br><span class="hljs-comment">/* 开启系统 FinSH 时：开启 MSH 功能时，定义该宏默认使用 MSH 功能 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FINSH_USING_MSH_DEFAULT</span><br><span class="hljs-comment">/* 开启系统 FinSH 时：定义该宏，仅使用 MSH 功能 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FINSH_USING_MSH_ONLY</span><br></code></pre></td></tr></table></figure><p>（7）关于 MCU</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 定义该工程使用的 MCU 为 STM32F103ZE；系统通过对芯片类型的定义，来定义芯片的管脚 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STM32F103ZE</span><br><br><span class="hljs-comment">/* 定义时钟源频率 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_HSE_VALUE 8000000</span><br><br><span class="hljs-comment">/* 定义该宏开启 UART1 的使用 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USING_UART1</span><br></code></pre></td></tr></table></figure><h2 id="常见宏定义说明"><a href="#常见宏定义说明" class="headerlink" title="常见宏定义说明"></a>常见宏定义说明</h2><p>1）rt_inline，定义如下，static 关键字的作用是令函数只能在当前的文件中使用；inline 表示内联，用 static 修饰后在调用函数时会建议编译器进行内联展开。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> rt_inline                   static __inline</span><br></code></pre></td></tr></table></figure><p>2）RT_USED，定义如下，该宏的作用是向编译器说明这段代码有用，即使函数中没有调用也要保留编译。例如 RT-Thread 自动初始化功能使用了自定义的段，使用 RT_USED 会将自定义的代码段保留。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USED                     __attribute__((used))</span><br></code></pre></td></tr></table></figure><p>3）RT_UNUSED，定义如下，表示函数或变量可能不使用，这个属性可以避免编译器产生警告信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_UNUSED                   __attribute__((unused))</span><br></code></pre></td></tr></table></figure><p>4）RT_WEAK，定义如下，常用于定义函数，编译器在链接函数时会优先链接没有该关键字前缀的函数，如果找不到则再链接由 weak 修饰的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_WEAK                     __weak</span><br></code></pre></td></tr></table></figure><p>5）ALIGN(n)，定义如下，作用是在给某对象分配地址空间时，将其存放的地址按照 n 字节对齐，这里 n 可取 2 的幂次方。字节对齐的作用不仅是便于 CPU 快速访问，同时合理的利用字节对齐可以有效地节省存储空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ALIGN(n)                    __attribute__((aligned(n)))</span><br></code></pre></td></tr></table></figure><p>6）RT_ALIGN(size,align)，定义如下，作用是将 size 提升为 align 定义的整数的倍数，例如，RT_ALIGN(13,4) 将返回 16。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_ALIGN(size, align)      (((size) + (align) - 1) &amp; ~((align) - 1))</span><br></code></pre></td></tr></table></figure><h1 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h1><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><table><thead><tr><th><strong>状态</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>初始状态</td><td>当线程刚开始创建还没开始运行时就处于初始状态；<br/>在初始状态下，线程不参与调度。<br/>此状态在 RT-Thread 中的宏定义为 RT_THREAD_INIT</td></tr><tr><td>就绪状态</td><td>在就绪状态下，线程按照优先级排队，等待被执行；<br/>一旦当前线程运行完毕让出处理器，操作系统会马上寻找最高优先级的就绪态线程运行。<br/>此状态在 RT-Thread 中的宏定义为 RT_THREAD_READY</td></tr><tr><td>运行状态</td><td>线程当前正在运行。在单核系统中，只有 rt_thread_self() 函数返回的线程处于运行状态；<br/>在多核系统中，可能就不止这一个线程处于运行状态。<br/>此状态在 RT-Thread 中的宏定义为 RT_THREAD_RUNNING</td></tr><tr><td>挂起状态</td><td>也称阻塞态。它可能因为资源不可用而挂起等待，或线程主动延时一段时间而挂起。<br/>在挂起状态下，线程不参与调度。<br/>此状态在 RT-Thread 中的宏定义为 RT_THREAD_SUSPEND</td></tr><tr><td>关闭状态</td><td>当线程运行结束时将处于关闭状态。<br/>关闭状态的线程不参与线程的调度。<br/>此状态在 RT-Thread 中的宏定义为 RT_THREAD_CLOSE</td></tr></tbody></table><h2 id="线程状态的切换"><a href="#线程状态的切换" class="headerlink" title="线程状态的切换"></a>线程状态的切换</h2><p><img src="/2021/42e53028/04thread_sta.png" alt="线程状态转换图"></p><h2 id="线程的管理API"><a href="#线程的管理API" class="headerlink" title="线程的管理API"></a>线程的管理API</h2><p><img src="/2021/42e53028/04thread_ops.png" alt="线程相关操作"></p><h3 id="创建删除-create"><a href="#创建删除-create" class="headerlink" title="创建删除-create"></a>创建删除-create</h3><p>系统会从动态堆内存中分配一个线程句柄以及按照参数中指定的栈大小从动态堆内存中分配相应的空间。分配出来的栈空间是按照 rtconfig.h 中配置的 <strong>RT_ALIGN_SIZE</strong> 方式对齐</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_thread_t</span> <span class="hljs-title function_">rt_thread_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name,</span><br><span class="hljs-params">                            <span class="hljs-type">void</span> (*entry)(<span class="hljs-type">void</span>* parameter),</span><br><span class="hljs-params">                            <span class="hljs-type">void</span>* parameter,</span><br><span class="hljs-params">                            <span class="hljs-type">rt_uint32_t</span> stack_size,</span><br><span class="hljs-params">                            <span class="hljs-type">rt_uint8_t</span> priority,</span><br><span class="hljs-params">                            <span class="hljs-type">rt_uint32_t</span> tick)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>name</td><td>线程的名称；<br/>线程名称的最大长度由 rtconfig.h 中的宏 RT_NAME_MAX 指定，多余部分会被自动截掉</td></tr><tr><td>entry</td><td>线程入口函数</td></tr><tr><td>parameter</td><td>线程入口函数参数</td></tr><tr><td>stack_size</td><td>线程栈大小，单位是字节</td></tr><tr><td>priority</td><td>线程的优先级。<br/>优先级范围根据系统配置情况（rtconfig.h 中的 RT_THREAD_PRIORITY_MAX 宏定义），如果支持的是 256 级优先级，那么范围是从 0~255，数值越小优先级越高，0 代表最高优先级</td></tr><tr><td>tick</td><td>线程的时间片大小。<br/>时间片（tick）的单位是操作系统的时钟节拍。当系统中存在相同优先级线程时，这个参数指定线程一次调度能够运行的最大时间长度。这个时间片运行结束时，调度器自动选择下一个就绪态的同优先级线程进行运行</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>thread</td><td>线程创建成功，返回线程句柄</td></tr><tr><td>RT_NULL</td><td>线程创建失败</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_delete</span><span class="hljs-params">(<span class="hljs-type">rt_thread_t</span> thread)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>thread</td><td>要删除的线程句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>删除线程成功</td></tr><tr><td>-RT_ERROR</td><td>删除线程失败</td></tr></tbody></table><h3 id="初始化和脱离-init"><a href="#初始化和脱离-init" class="headerlink" title="初始化和脱离-init"></a>初始化和脱离-init</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_init</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> rt_thread* thread,</span><br><span class="hljs-params">                        <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name,</span><br><span class="hljs-params">                        <span class="hljs-type">void</span> (*entry)(<span class="hljs-type">void</span>* parameter), <span class="hljs-type">void</span>* parameter,</span><br><span class="hljs-params">                        <span class="hljs-type">void</span>* stack_start, <span class="hljs-type">rt_uint32_t</span> stack_size,</span><br><span class="hljs-params">                        <span class="hljs-type">rt_uint8_t</span> priority, <span class="hljs-type">rt_uint32_t</span> tick)</span>;<br></code></pre></td></tr></table></figure><p>静态线程的线程句柄（或者说线程控制块指针）、线程栈由用户提供。静态线程是指线程控制块、线程运行栈一般都设置为全局变量，在编译时就被确定、被分配处理，内核不负责动态分配内存空间。需要注意的是，用户提供的栈首地址需做<strong>系统对齐</strong>（例如 ARM 上需要做 4 字节对齐）。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>thread</td><td>线程句柄。线程句柄由用户提供出来，并指向对应的线程控制块内存地址</td></tr><tr><td>name</td><td>线程的名称；线程名称的最大长度由 rtconfig.h 中定义的 RT_NAME_MAX 宏指定，多余部分会被自动截掉</td></tr><tr><td>entry</td><td>线程入口函数</td></tr><tr><td>parameter</td><td>线程入口函数参数</td></tr><tr><td>stack_start</td><td>线程栈起始地址</td></tr><tr><td>stack_size</td><td>线程栈大小，单位是字节。在大多数系统中需要做栈空间地址对齐（例如 ARM 体系结构中需要向 4 字节地址对齐）</td></tr><tr><td>priority</td><td>线程的优先级。优先级范围根据系统配置情况（rtconfig.h 中的 RT_THREAD_PRIORITY_MAX 宏定义），如果支持的是 256 级优先级，那么范围是从 0 ～ 255，数值越小优先级越高，0 代表最高优先级</td></tr><tr><td>tick</td><td>线程的时间片大小。时间片（tick）的单位是操作系统的时钟节拍。当系统中存在相同优先级线程时，这个参数指定线程一次调度能够运行的最大时间长度。这个时间片运行结束时，调度器自动选择下一个就绪态的同优先级线程进行运行</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>线程创建成功</td></tr><tr><td>-RT_ERROR</td><td>线程创建失败</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_detach</span> <span class="hljs-params">(<span class="hljs-type">rt_thread_t</span> thread)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>thread</td><td>线程句柄，它应该是由 rt_thread_init 进行初始化的线程句柄。</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>线程脱离成功</td></tr><tr><td>-RT_ERROR</td><td>线程脱离失败</td></tr></tbody></table><h3 id="线程启动-startup"><a href="#线程启动-startup" class="headerlink" title="线程启动-startup"></a>线程启动-startup</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_startup</span><span class="hljs-params">(<span class="hljs-type">rt_thread_t</span> thread)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>thread</td><td>线程句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>线程启动成功</td></tr><tr><td>-RT_ERROR</td><td>线程起动失败</td></tr></tbody></table><h3 id="获取当前线程-self"><a href="#获取当前线程-self" class="headerlink" title="获取当前线程-self"></a>获取当前线程-self</h3><p>在程序的运行过程中，相同的一段代码可能会被多个线程执行，在执行的时候可以通过下面的函数接口获得当前执行的线程句柄：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_thread_t</span> <span class="hljs-title function_">rt_thread_self</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>返回</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>thread</td><td>当前运行的线程句柄</td></tr><tr><td>RT_NULL</td><td>失败，调度器还未启动</td></tr></tbody></table><h3 id="使线程让出处理器资源-yield"><a href="#使线程让出处理器资源-yield" class="headerlink" title="使线程让出处理器资源-yield"></a>使线程让出处理器资源-yield</h3><p>（如果当前优先级只有这一个线程，则这个线程继续执行，不进行上下文切换动作）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_yield</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><p>rt_thread_yield() 和 rt_schedule() 比较相像，有相同优先级的其他就绪态线程存在时其行为<strong>有所差异</strong>。</p><h3 id="使线程睡眠-延时-sleep"><a href="#使线程睡眠-延时-sleep" class="headerlink" title="使线程睡眠(延时)-sleep"></a>使线程睡眠(延时)-sleep</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_sleep</span><span class="hljs-params">(<span class="hljs-type">rt_tick_t</span> tick)</span>;<br><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_delay</span><span class="hljs-params">(<span class="hljs-type">rt_tick_t</span> tick)</span>;<br><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_mdelay</span><span class="hljs-params">(<span class="hljs-type">rt_int32_t</span> ms)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>tick&#x2F;ms</td><td>线程睡眠的时间： sleep&#x2F;delay 的传入参数 tick 以 1 个 OS Tick 为单位 ； mdelay 的传入参数 ms 以 1ms 为单位；</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>操作成功</td></tr></tbody></table><h3 id="挂起和恢复线程-suspend"><a href="#挂起和恢复线程-suspend" class="headerlink" title="挂起和恢复线程-suspend"></a>挂起和恢复线程-suspend</h3><blockquote><p>通常不应该使用这个函数来挂起线程本身，如果确实需要采用 rt_thread_suspend() 函数挂起当前任务，需要在调用 rt_thread_suspend() 函数后立刻调用 rt_schedule() 函数进行手动的线程上下文切换。用户只需要了解该接口的作用，不推荐使用该接口。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_suspend</span> <span class="hljs-params">(<span class="hljs-type">rt_thread_t</span> thread)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>thread</td><td>线程句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>线程挂起成功</td></tr><tr><td>-RT_ERROR</td><td>线程挂起失败，因为该线程的状态并不是就绪状态</td></tr></tbody></table><p>恢复线程就是让挂起的线程重新进入就绪状态，并将线程放入系统的就绪队列中；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_resume</span> <span class="hljs-params">(<span class="hljs-type">rt_thread_t</span> thread)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>thread</td><td>线程句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>线程恢复成功</td></tr><tr><td>-RT_ERROR</td><td>线程恢复失败，因为该个线程的状态并不是 RT_THREAD_SUSPEND 状态</td></tr></tbody></table><h3 id="控制线程-control"><a href="#控制线程-control" class="headerlink" title="控制线程-control"></a>控制线程-control</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_control</span><span class="hljs-params">(<span class="hljs-type">rt_thread_t</span> thread, <span class="hljs-type">rt_uint8_t</span> cmd, <span class="hljs-type">void</span>* arg)</span>;<br></code></pre></td></tr></table></figure><p>线程控制接口 rt_thread_control() 的参数和返回值见下表：</p><table><thead><tr><th><strong>函数参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>thread</td><td>线程句柄</td></tr><tr><td>cmd</td><td>指示控制命令</td></tr><tr><td>arg</td><td>控制参数</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>控制执行正确</td></tr><tr><td>-RT_ERROR</td><td>失败</td></tr></tbody></table><blockquote><p>指示控制命令 cmd 当前支持的命令包括：</p><p>RT_THREAD_CTRL_CHANGE_PRIORITY：动态更改线程的优先级；</p><p>RT_THREAD_CTRL_STARTUP：开始运行一个线程，等同于 rt_thread_startup() 函数调用；</p><p>RT_THREAD_CTRL_CLOSE：关闭一个线程，等同于 rt_thread_delete() 函数调用。</p></blockquote><h3 id="设置和删除空闲钩子-idle"><a href="#设置和删除空闲钩子-idle" class="headerlink" title="设置和删除空闲钩子-idle"></a>设置和删除空闲钩子-idle</h3><p>空闲钩子函数是空闲线程的钩子函数，如果设置了空闲钩子函数，就可以在系统执行空闲线程时，自动执行空闲钩子函数来做一些其他事情，比如系统指示灯。<strong>钩子函数必须保证空闲线程在任何时刻都不会处于挂起状态。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_idle_sethook</span><span class="hljs-params">(<span class="hljs-type">void</span> (*hook)(<span class="hljs-type">void</span>))</span>;<br><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_idle_delhook</span><span class="hljs-params">(<span class="hljs-type">void</span> (*hook)(<span class="hljs-type">void</span>))</span>;<br></code></pre></td></tr></table></figure><p>设置空闲钩子函数 rt_thread_idle_sethook() </p><table><thead><tr><th><strong>函数参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>hook</td><td>设置的钩子函数</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>设置成功</td></tr><tr><td>-RT_EFULL</td><td>设置失败</td></tr></tbody></table><p>删除空闲钩子函数 rt_thread_idle_delhook() </p><table><thead><tr><th><strong>函数参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>hook</td><td>删除的钩子函数</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>删除成功</td></tr><tr><td>-RT_ENOSYS</td><td>删除失败</td></tr></tbody></table><h3 id="设置调度器钩子-scheduler"><a href="#设置调度器钩子-scheduler" class="headerlink" title="设置调度器钩子-scheduler"></a>设置调度器钩子-scheduler</h3><p>有时用户可能会想知道在一个时刻发生了什么样的线程切换，可以通过调用下面的函数接口设置一个相应的钩子函数。在系统线程切换时，这个钩子函数将被调用：<strong>请仔细编写你的钩子函数，稍有不慎将很可能导致整个系统运行不正常（在这个钩子函数中，基本上不允许调用系统 API，更不应该导致当前运行的上下文挂起）。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">rt_scheduler_sethook</span><span class="hljs-params">(<span class="hljs-type">void</span> (*hook)(<span class="hljs-keyword">struct</span> rt_thread* from, <span class="hljs-keyword">struct</span> rt_thread* to))</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>函数参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>hook</td><td>表示用户定义的钩子函数指针</td></tr></tbody></table><p>钩子函数 hook() 的声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">hook</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> rt_thread* from, <span class="hljs-keyword">struct</span> rt_thread* to)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>函数参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>from</td><td>表示系统所要切换出的线程控制块指针</td></tr><tr><td>to</td><td>表示系统所要切换到的线程控制块指针</td></tr></tbody></table><h2 id="API应用示例"><a href="#API应用示例" class="headerlink" title="API应用示例"></a>API应用示例</h2><p>线程 2 计数到一定值会执行完毕，线程 2 被系统自动删除，计数停止。线程 1 一直打印计数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;rtthread.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_PRIORITY         25</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_STACK_SIZE       512</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_TIMESLICE        5</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">rt_thread_t</span> tid1 = RT_NULL;<br><br><span class="hljs-comment">/* 线程 1 的入口函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">thread1_entry</span><span class="hljs-params">(<span class="hljs-type">void</span> *parameter)</span><br>&#123;<br>    <span class="hljs-type">rt_uint32_t</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">/* 线程 1 采用低优先级运行，一直打印计数值 */</span><br>        rt_kprintf(<span class="hljs-string">&quot;thread1 count: %d\n&quot;</span>, count ++);<br>        rt_thread_mdelay(<span class="hljs-number">500</span>);<br>    &#125;<br>&#125;<br><br>ALIGN(RT_ALIGN_SIZE)<br><span class="hljs-type">static</span> <span class="hljs-type">char</span> thread2_stack[<span class="hljs-number">1024</span>];<br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_thread</span> <span class="hljs-title">thread2</span>;</span><br><span class="hljs-comment">/* 线程 2 入口 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">thread2_entry</span><span class="hljs-params">(<span class="hljs-type">void</span> *param)</span><br>&#123;<br>    <span class="hljs-type">rt_uint32_t</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* 线程 2 拥有较高的优先级，以抢占线程 1 而获得执行 */</span><br>    <span class="hljs-keyword">for</span> (count = <span class="hljs-number">0</span>; count &lt; <span class="hljs-number">10</span> ; count++)<br>    &#123;<br>        <span class="hljs-comment">/* 线程 2 打印计数值 */</span><br>        rt_kprintf(<span class="hljs-string">&quot;thread2 count: %d\n&quot;</span>, count);<br>    &#125;<br>    rt_kprintf(<span class="hljs-string">&quot;thread2 exit\n&quot;</span>);<br>    <span class="hljs-comment">/* 线程 2 运行结束后也将自动被系统脱离 */</span><br>&#125;<br><br><span class="hljs-comment">/* 线程示例 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">thread_sample</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/* 创建线程 1，名称是 thread1，入口是 thread1_entry*/</span><br>    tid1 = rt_thread_create(<span class="hljs-string">&quot;thread1&quot;</span>,<br>                            thread1_entry, RT_NULL,<br>                            THREAD_STACK_SIZE,<br>                            THREAD_PRIORITY, THREAD_TIMESLICE);<br><br>    <span class="hljs-comment">/* 如果获得线程控制块，启动这个线程 */</span><br>    <span class="hljs-keyword">if</span> (tid1 != RT_NULL)<br>        rt_thread_startup(tid1);<br><br>    <span class="hljs-comment">/* 初始化线程 2，名称是 thread2，入口是 thread2_entry */</span><br>    rt_thread_init(&amp;thread2,<br>                   <span class="hljs-string">&quot;thread2&quot;</span>,<br>                   thread2_entry,<br>                   RT_NULL,<br>                   &amp;thread2_stack[<span class="hljs-number">0</span>],<br>                   <span class="hljs-keyword">sizeof</span>(thread2_stack),<br>                   THREAD_PRIORITY - <span class="hljs-number">1</span>, THREAD_TIMESLICE);<br>    rt_thread_startup(&amp;thread2);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 导出到 msh 命令列表中 */</span><br>MSH_CMD_EXPORT(thread_sample, thread sample);<br></code></pre></td></tr></table></figure><p>仿真运行结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c">\ | /<br>- RT -     Thread Operating System<br> / | \     <span class="hljs-number">3.1</span><span class="hljs-number">.0</span> build Aug <span class="hljs-number">24</span> <span class="hljs-number">2018</span><br> <span class="hljs-number">2006</span> - <span class="hljs-number">2018</span> Copyright by rt-thread team<br>msh &gt;thread_sample<br>msh &gt;thread2 count: <span class="hljs-number">0</span><br>thread2 count: <span class="hljs-number">1</span><br>thread2 count: <span class="hljs-number">2</span><br>thread2 count: <span class="hljs-number">3</span><br>thread2 count: <span class="hljs-number">4</span><br>thread2 count: <span class="hljs-number">5</span><br>thread2 count: <span class="hljs-number">6</span><br>thread2 count: <span class="hljs-number">7</span><br>thread2 count: <span class="hljs-number">8</span><br>thread2 count: <span class="hljs-number">9</span><br>thread2 <span class="hljs-built_in">exit</span><br>thread1 count: <span class="hljs-number">0</span><br>thread1 count: <span class="hljs-number">1</span><br>thread1 count: <span class="hljs-number">2</span><br>thread1 count: <span class="hljs-number">3</span><br>…<br></code></pre></td></tr></table></figure><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><ul><li>若某线程运行完毕，系统将自动删除线程：自动执行 rt_thread_exit() 函数，先将该线程从系统就绪队列中删除，再将该线程的状态更改为关闭状态，不再参与系统调度，然后挂入 rt_thread_defunct 僵尸队列（资源未回收、处于关闭状态的线程队列）中，最后空闲线程会回收被删除线程的资源。</li><li></li></ul><h1 id="时钟管理"><a href="#时钟管理" class="headerlink" title="时钟管理"></a>时钟管理</h1><h2 id="获取时钟节拍API"><a href="#获取时钟节拍API" class="headerlink" title="获取时钟节拍API"></a>获取时钟节拍API</h2><p>由于全局变量 rt_tick 在每经过一个时钟节拍时，值就会加 1，通过调用 rt_tick_get 会返回当前 rt_tick 的值，即可以获取到当前的时钟节拍值。此接口可用于记录系统的运行时间长短，或者测量某任务运行的时间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_tick_t</span> <span class="hljs-title function_">rt_tick_get</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>返回</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>rt_tick</td><td>当前时钟节拍值</td></tr></tbody></table><h2 id="软件定时器管理"><a href="#软件定时器管理" class="headerlink" title="软件定时器管理"></a>软件定时器管理</h2><p>RT-Thread 操作系统提供软件实现的定时器，以时钟节拍（OS Tick）的时间长度为单位，即定时数值必须是 OS Tick 的整数倍。它构建在硬件定时器基础之上，使系统能够提供不受数目限制的定时器服务。</p><p>RT-Thread 的定时器提供两类定时器机制：</p><ul><li>第一类是单次触发定时器，这类定时器在启动后只会触发一次定时器事件，然后定时器自动停止。</li><li>第二类是周期触发定时器，这类定时器会周期性的触发定时器事件，直到用户手动的停止，否则将永远持续执行下去。</li></ul><p>另外，根据超时函数执行时所处的上下文环境，RT-Thread 的定时器可以分为 <strong>HARD_TIMER</strong> 模式与 <strong>SOFT_TIMER</strong> 模式，如下图。使用<strong>RT_TIMER_FLAG_HARD_TIMER</strong> 和 **RT_TIMER_FLAG_SOFT_TIMER ** 来决定使用的模式</p><p><img src="/2021/42e53028/05timer_env.png" alt="定时器上下文环境"></p><p>系统新创建并激活的定时器都会按照以超时时间排序的方式插入到 rt_timer_list 链表中。</p><p><img src="/2021/42e53028/05timer_linked_list.png" alt="定时器链表示意图"></p><p>rt_tick(当前系统tick) 从 20 增长到 70，与 Timer1 的 timeout 值相等，这时会触发与 Timer1 定时器相关联的超时函数，同时将 Timer1 从 rt_timer_list 链表上删除。</p><p>如果系统当前定时器状态在 10 个 tick 以后（rt_tick&#x3D;30）有一个任务新创建了一个 tick 值为 300 的 Timer4 定时器，由于 Timer4 定时器的 timeout&#x3D;rt_tick+300&#x3D;330, 因此它将被插入到 Timer2 和 Timer3 定时器中间如下图,所示：</p><p><img src="/2021/42e53028/05timer_linked_list2.png" alt="定时器链表插入示意图"></p><h2 id="定时器API"><a href="#定时器API" class="headerlink" title="定时器API"></a>定时器API</h2><p><img src="/2021/42e53028/05timer_ops.png" alt="定时器相关操作"></p><p>在系统启动时需要初始化定时器管理系统。可以通过下面的函数接口完成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">rt_system_timer_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><p>如果需要使用 SOFT_TIMER，则系统初始化时，应该调用下面这个函数接口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">rt_system_timer_thread_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><h3 id="创建和删除-create"><a href="#创建和删除-create" class="headerlink" title="创建和删除-create"></a>创建和删除-create</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_timer_t</span> <span class="hljs-title function_">rt_timer_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name,</span><br><span class="hljs-params">                           <span class="hljs-type">void</span> (*timeout)(<span class="hljs-type">void</span>* parameter),</span><br><span class="hljs-params">                           <span class="hljs-type">void</span>* parameter,</span><br><span class="hljs-params">                           <span class="hljs-type">rt_tick_t</span> time,</span><br><span class="hljs-params">                           <span class="hljs-type">rt_uint8_t</span> flag)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>name</td><td>定时器的名称</td></tr><tr><td>void (timeout) (void parameter)</td><td>定时器超时函数指针（当定时器超时时，系统会调用这个函数）</td></tr><tr><td>parameter</td><td>定时器超时函数的入口参数（当定时器超时时，调用超时回调函数会把这个参数做为入口参数传递给超时函数）</td></tr><tr><td>time</td><td>定时器的超时时间，单位是时钟节拍</td></tr><tr><td>flag</td><td>定时器创建时的参数，支持的值包括单次定时、周期定时、硬件定时器、软件定时器等（可以用 “或” 关系取多个值）</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_NULL</td><td>创建失败（通常会由于系统内存不够用而返回 RT_NULL）</td></tr><tr><td>定时器的句柄</td><td>定时器创建成功</td></tr></tbody></table><p>如下2 组值可以以 “或” 逻辑的方式赋给 flag。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_TIMER_FLAG_ONE_SHOT      0x0     <span class="hljs-comment">/* 单次定时     */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_TIMER_FLAG_PERIODIC      0x2     <span class="hljs-comment">/* 周期定时     */</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_TIMER_FLAG_HARD_TIMER    0x0     <span class="hljs-comment">/* 时钟中断的服务例程上下文中被调用 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_TIMER_FLAG_SOFT_TIMER    0x4     <span class="hljs-comment">/* timer 线程的上下文中被调用 */</span></span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_timer_delete</span><span class="hljs-params">(<span class="hljs-type">rt_timer_t</span> timer)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>timer</td><td>定时器句柄，指向要删除的定时器</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>删除成功（如果参数 timer 句柄是一个 RT_NULL，将会导致一个 ASSERT 断言）</td></tr></tbody></table><h3 id="初始化和脱离定时器-init"><a href="#初始化和脱离定时器-init" class="headerlink" title="初始化和脱离定时器-init"></a>初始化和脱离定时器-init</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">rt_timer_init</span><span class="hljs-params">(<span class="hljs-type">rt_timer_t</span> timer,</span><br><span class="hljs-params">                   <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name,</span><br><span class="hljs-params">                   <span class="hljs-type">void</span> (*timeout)(<span class="hljs-type">void</span>* parameter),</span><br><span class="hljs-params">                   <span class="hljs-type">void</span>* parameter,</span><br><span class="hljs-params">                   <span class="hljs-type">rt_tick_t</span> time, <span class="hljs-type">rt_uint8_t</span> flag)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>timer</td><td>定时器句柄，指向要初始化的定时器控制块</td></tr><tr><td>name</td><td>定时器的名称</td></tr><tr><td>void (timeout) (void parameter)</td><td>定时器超时函数指针（当定时器超时时，系统会调用这个函数）</td></tr><tr><td>parameter</td><td>定时器超时函数的入口参数（当定时器超时时，调用超时回调函数会把这个参数做为入口参数传递给超时函数）</td></tr><tr><td>time</td><td>定时器的超时时间，单位是时钟节拍</td></tr><tr><td>flag</td><td>定时器创建时的参数，支持的值包括单次定时、周期定时、硬件定时器、软件定时器（可以用 “或” 关系取多个值），详见上面 <strong>创建和删除</strong></td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_timer_detach</span><span class="hljs-params">(<span class="hljs-type">rt_timer_t</span> timer)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>timer</td><td>定时器句柄，指向要脱离的定时器控制块</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>脱离成功</td></tr></tbody></table><h3 id="启动和停止定时器-start"><a href="#启动和停止定时器-start" class="headerlink" title="启动和停止定时器-start"></a>启动和停止定时器-start</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_timer_start</span><span class="hljs-params">(<span class="hljs-type">rt_timer_t</span> timer)</span>;<br></code></pre></td></tr></table></figure><p>调用接口后，定时器的状态将更改为激活状态（RT_TIMER_FLAG_ACTIVATED），并按照超时顺序插入到 rt_timer_list 队列链表中。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>timer</td><td>定时器句柄，指向要启动的定时器控制块</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>启动成功</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_timer_stop</span><span class="hljs-params">(<span class="hljs-type">rt_timer_t</span> timer)</span>;<br></code></pre></td></tr></table></figure><p>当一个（周期性）定时器超时时，可以调用这个函数接口停止这个（周期性）定时器本身。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>timer</td><td>定时器句柄，指向要停止的定时器控制块</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功停止定时器</td></tr><tr><td>- RT_ERROR</td><td>timer 已经处于停止状态</td></tr></tbody></table><h3 id="控制定时器-control"><a href="#控制定时器-control" class="headerlink" title="控制定时器-control"></a>控制定时器-control</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_timer_control</span><span class="hljs-params">(<span class="hljs-type">rt_timer_t</span> timer, <span class="hljs-type">rt_uint8_t</span> cmd, <span class="hljs-type">void</span>* arg)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>timer</td><td>定时器句柄，指向要停止的定时器控制块</td></tr><tr><td>cmd</td><td>用于控制定时器的命令，当前支持四个命令，分别是设置定时时间，查看定时时间，设置单次触发，设置周期触发</td></tr><tr><td>arg</td><td>与 cmd 相对应的控制命令参数 比如，cmd 为设定超时时间时，就可以将超时时间参数通过 arg 进行设定</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr></tbody></table><p>函数参数 cmd 支持的命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_TIMER_CTRL_SET_TIME      0x0     <span class="hljs-comment">/* 设置定时器超时时间       */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_TIMER_CTRL_GET_TIME      0x1     <span class="hljs-comment">/* 获得定时器超时时间       */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_TIMER_CTRL_SET_ONESHOT   0x2     <span class="hljs-comment">/* 设置定时器为单次定时器   */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_TIMER_CTRL_SET_PERIODIC  0x3     <span class="hljs-comment">/* 设置定时器为周期型定时器 */</span></span><br></code></pre></td></tr></table></figure><h2 id="API应用示例-1"><a href="#API应用示例-1" class="headerlink" title="API应用示例"></a>API应用示例</h2><p>这是一个创建定时器的例子，这个例程会创建两个动态定时器，一个是单次定时，一个是周期性定时并让周期定时器运行一段时间后停止运行，如下所示：周期性定时器 1 的超时函数，每 10 个 OS Tick 运行 1 次，共运行 10 次（10 次后调用 rt_timer_stop 使定时器 1 停止运行）；单次定时器 2 的超时函数在第 30 个 OS Tick 时运行一次。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;rtthread.h&gt;</span></span><br><br><span class="hljs-comment">/* 定时器的控制块 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">rt_timer_t</span> timer1;<br><span class="hljs-type">static</span> <span class="hljs-type">rt_timer_t</span> timer2;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/* 定时器 1 超时函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">timeout1</span><span class="hljs-params">(<span class="hljs-type">void</span> *parameter)</span><br>&#123;<br>    rt_kprintf(<span class="hljs-string">&quot;periodic timer is timeout %d\n&quot;</span>, cnt);<br><br>    <span class="hljs-comment">/* 运行第 10 次，停止周期定时器 */</span><br>    <span class="hljs-keyword">if</span> (cnt++&gt;= <span class="hljs-number">9</span>)<br>    &#123;<br>        rt_timer_stop(timer1);<br>        rt_kprintf(<span class="hljs-string">&quot;periodic timer was stopped! \n&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* 定时器 2 超时函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">timeout2</span><span class="hljs-params">(<span class="hljs-type">void</span> *parameter)</span><br>&#123;<br>    rt_kprintf(<span class="hljs-string">&quot;one shot timer is timeout\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">timer_sample</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/* 创建定时器 1  周期定时器 */</span><br>    timer1 = rt_timer_create(<span class="hljs-string">&quot;timer1&quot;</span>, timeout1,<br>                             RT_NULL, <span class="hljs-number">10</span>,<br>                             RT_TIMER_FLAG_PERIODIC);<br><br>    <span class="hljs-comment">/* 启动定时器 1 */</span><br>    <span class="hljs-keyword">if</span> (timer1 != RT_NULL) rt_timer_start(timer1);<br><br>    <span class="hljs-comment">/* 创建定时器 2 单次定时器 */</span><br>    timer2 = rt_timer_create(<span class="hljs-string">&quot;timer2&quot;</span>, timeout2,<br>                             RT_NULL,  <span class="hljs-number">30</span>,<br>                             RT_TIMER_FLAG_ONE_SHOT);<br><br>    <span class="hljs-comment">/* 启动定时器 2 */</span><br>    <span class="hljs-keyword">if</span> (timer2 != RT_NULL) rt_timer_start(timer2);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 导出到 msh 命令列表中 */</span><br>MSH_CMD_EXPORT(timer_sample, timer sample);<br></code></pre></td></tr></table></figure><p>仿真运行结果如下：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs applescript"> \ | /<br>- RT -     Thread Operating System<br> / | \     <span class="hljs-number">3.1</span><span class="hljs-number">.0</span> build Aug <span class="hljs-number">24</span> <span class="hljs-number">2018</span><br> <span class="hljs-number">2006</span> - <span class="hljs-number">2018</span> Copyright <span class="hljs-keyword">by</span> rt-thread team<br>msh &gt;timer_sample<br>msh &gt;periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span> <span class="hljs-number">0</span><br>periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span> <span class="hljs-number">1</span><br>one shot timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span><br>periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span> <span class="hljs-number">2</span><br>periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span> <span class="hljs-number">3</span><br>periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span> <span class="hljs-number">4</span><br>periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span> <span class="hljs-number">5</span><br>periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span> <span class="hljs-number">6</span><br>periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span> <span class="hljs-number">7</span><br>periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span> <span class="hljs-number">8</span><br>periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span> <span class="hljs-number">9</span><br>periodic timer was stopped!<br></code></pre></td></tr></table></figure><p>初始化定时器的例子与创建定时器的例子类似，这个程序会初始化 2 个静态定时器，一个是单次定时，一个是周期性的定时，如下代码所示：周期性定时器 1 的超时函数，每 10 个 OS Tick 运行 1 次，共运行 10 次（10 次后调用 rt_timer_stop 使定时器 1 停止运行）；单次定时器 2 的超时函数在第 30 个 OS Tick 时运行一次。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;rtthread.h&gt;</span></span><br><br><span class="hljs-comment">/* 定时器的控制块 */</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_timer</span> <span class="hljs-title">timer1</span>;</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_timer</span> <span class="hljs-title">timer2</span>;</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/* 定时器 1 超时函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">timeout1</span><span class="hljs-params">(<span class="hljs-type">void</span>* parameter)</span><br>&#123;<br>    rt_kprintf(<span class="hljs-string">&quot;periodic timer is timeout\n&quot;</span>);<br>    <span class="hljs-comment">/* 运行 10 次 */</span><br>    <span class="hljs-keyword">if</span> (cnt++&gt;= <span class="hljs-number">9</span>)<br>    &#123;<br>        rt_timer_stop(&amp;timer1);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* 定时器 2 超时函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">timeout2</span><span class="hljs-params">(<span class="hljs-type">void</span>* parameter)</span><br>&#123;<br>    rt_kprintf(<span class="hljs-string">&quot;one shot timer is timeout\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">timer_static_sample</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/* 初始化定时器 */</span><br>    rt_timer_init(&amp;timer1, <span class="hljs-string">&quot;timer1&quot;</span>,  <span class="hljs-comment">/* 定时器名字是 timer1 */</span><br>                    timeout1, <span class="hljs-comment">/* 超时时回调的处理函数 */</span><br>                    RT_NULL, <span class="hljs-comment">/* 超时函数的入口参数 */</span><br>                    <span class="hljs-number">10</span>, <span class="hljs-comment">/* 定时长度，以 OS Tick 为单位，即 10 个 OS Tick */</span><br>                    RT_TIMER_FLAG_PERIODIC); <span class="hljs-comment">/* 周期性定时器 */</span><br>    rt_timer_init(&amp;timer2, <span class="hljs-string">&quot;timer2&quot;</span>,   <span class="hljs-comment">/* 定时器名字是 timer2 */</span><br>                    timeout2, <span class="hljs-comment">/* 超时时回调的处理函数 */</span><br>                      RT_NULL, <span class="hljs-comment">/* 超时函数的入口参数 */</span><br>                      <span class="hljs-number">30</span>, <span class="hljs-comment">/* 定时长度为 30 个 OS Tick */</span><br>                    RT_TIMER_FLAG_ONE_SHOT); <span class="hljs-comment">/* 单次定时器 */</span><br><br>    <span class="hljs-comment">/* 启动定时器 */</span><br>    rt_timer_start(&amp;timer1);<br>    rt_timer_start(&amp;timer2);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/* 导出到 msh 命令列表中 */</span><br>MSH_CMD_EXPORT(timer_static_sample, timer_static sample);<br></code></pre></td></tr></table></figure><p>仿真运行结果如下：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs applescript">\ | /<br>- RT -     Thread Operating System<br> / | \     <span class="hljs-number">3.1</span><span class="hljs-number">.0</span> build Aug <span class="hljs-number">24</span> <span class="hljs-number">2018</span><br> <span class="hljs-number">2006</span> - <span class="hljs-number">2018</span> Copyright <span class="hljs-keyword">by</span> rt-thread team<br>msh &gt;timer_static_sample<br>msh &gt;periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span><br>periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span><br>one shot timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span><br>periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span><br>periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span><br>periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span><br>periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span><br>periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span><br>periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span><br>periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span><br>periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span><br></code></pre></td></tr></table></figure><h2 id="低于一个Tick的延时"><a href="#低于一个Tick的延时" class="headerlink" title="低于一个Tick的延时"></a>低于一个Tick的延时</h2><p>入口参数 us 指示出需要延时的微秒数目，这个函数只能支持低于 1 OS Tick 的延时，否则 SysTick 会出现溢出而不能够获得指定的延时时间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;board.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">rt_hw_us_delay</span><span class="hljs-params">(<span class="hljs-type">rt_uint32_t</span> us)</span><br>&#123;<br>    <span class="hljs-type">rt_uint32_t</span> delta;<br>    <span class="hljs-comment">/* 获得延时经过的 tick 数 */</span><br>    us = us * (SysTick-&gt;LOAD/(<span class="hljs-number">1000000</span>/RT_TICK_PER_SECOND));<br>    <span class="hljs-comment">/* 获得当前时间 */</span><br>    delta = SysTick-&gt;VAL;<br>    <span class="hljs-comment">/* 循环获得当前时间，直到达到指定的时间后退出循环 */</span><br>    <span class="hljs-keyword">while</span> (delta - SysTick-&gt;VAL&lt; us);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="笔记-1"><a href="#笔记-1" class="headerlink" title="笔记"></a>笔记</h2><ul><li>时钟节拍是特定的周期性中断，这个中断可以看做是系统心跳，中断之间的时间间隔取决于不同的应用，一般是 1ms–100ms，时钟节拍率越快，系统的额外开销就越大，从系统启动开始计数的时钟节拍数称为系统时间。</li><li></li></ul><h1 id="线程间同步"><a href="#线程间同步" class="headerlink" title="线程间同步"></a>线程间同步</h1><p>线程的同步方式有很多种，其核心思想都是：<strong>在访问临界区的时候只允许一个 (或一类) 线程运行。</strong>进入 &#x2F; 退出临界区的方式有很多种：</p><p>1）调用 rt_hw_interrupt_disable() 进入临界区，调用 rt_hw_interrupt_enable() 退出临界区；详见《中断管理》的全局中断开关内容。</p><p>2）调用 rt_enter_critical() 进入临界区，调用 rt_exit_critical() 退出临界区。</p><h2 id="信号量Semaphore"><a href="#信号量Semaphore" class="headerlink" title="信号量Semaphore"></a>信号量Semaphore</h2><p>信号量的值对应了信号量对象的实例数目、资源数目，假如信号量值为 5，则表示共有 5 个信号量实例（资源）可以被使用，当信号量实例数目为零时，再申请该信号量的线程就会被挂起在该信号量的等待队列上，等待可用的信号量实例（资源）。</p><p>可以形成<strong>锁</strong>、<strong>同步</strong>、<strong>资源计数</strong>等关系，也能方便的用于<strong>线程与线程</strong>、<strong>中断与线程</strong>间的同步中。</p><p><img src="/2021/42e53028/06sem_work.png" alt="信号量工作示意图"></p><h3 id="Semaphore-API"><a href="#Semaphore-API" class="headerlink" title="Semaphore API"></a>Semaphore API</h3><p><img src="/2021/42e53028/06sem_ops.png" alt="信号量相关接口"></p><h3 id="创建和删除信号量-create"><a href="#创建和删除信号量-create" class="headerlink" title="创建和删除信号量-create"></a>创建和删除信号量-create</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_sem_t</span> <span class="hljs-title function_">rt_sem_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name,</span><br><span class="hljs-params">                       <span class="hljs-type">rt_uint32_t</span> value,</span><br><span class="hljs-params">                       <span class="hljs-type">rt_uint8_t</span> flag)</span>;<br></code></pre></td></tr></table></figure><p>当选择 RT_IPC_FLAG_FIFO（先进先出）方式时，那么等待线程队列将按照先进先出的方式排队，先进入的线程将先获得等待的信号量；</p><p>当选择 RT_IPC_FLAG_PRIO（优先级等待）方式时，等待线程队列将按照优先级进行排队，优先级高的等待线程将先获得等待的信号量。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>name</td><td>信号量名称</td></tr><tr><td>value</td><td>信号量初始值</td></tr><tr><td>flag</td><td>信号量标志，它可以取如下数值： RT_IPC_FLAG_FIFO 或 RT_IPC_FLAG_PRIO</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_NULL</td><td>创建失败</td></tr><tr><td>信号量的控制块指针</td><td>创建成功</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_sem_delete</span><span class="hljs-params">(<span class="hljs-type">rt_sem_t</span> sem)</span>;<br></code></pre></td></tr></table></figure><p>如果删除该信号量时，有线程正在等待该信号量，那么删除操作会先唤醒等待在该信号量上的线程（等待线程的返回值是 - RT_ERROR），然后再释放信号量的内存资源。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>sem</td><td>rt_sem_create() 创建的信号量对象</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>删除成功</td></tr></tbody></table><h3 id="初始化和脱离信号量-init"><a href="#初始化和脱离信号量-init" class="headerlink" title="初始化和脱离信号量-init"></a>初始化和脱离信号量-init</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_sem_init</span><span class="hljs-params">(<span class="hljs-type">rt_sem_t</span>       sem,</span><br><span class="hljs-params">                    <span class="hljs-type">const</span> <span class="hljs-type">char</span>     *name,</span><br><span class="hljs-params">                    <span class="hljs-type">rt_uint32_t</span>    value,</span><br><span class="hljs-params">                    <span class="hljs-type">rt_uint8_t</span>     flag)</span><br></code></pre></td></tr></table></figure><p>flag见上↑</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>sem</td><td>信号量对象的句柄</td></tr><tr><td>name</td><td>信号量名称</td></tr><tr><td>value</td><td>信号量初始值</td></tr><tr><td>flag</td><td>信号量标志，它可以取如下数值： RT_IPC_FLAG_FIFO 或 RT_IPC_FLAG_PRIO</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>初始化成功</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_sem_detach</span><span class="hljs-params">(<span class="hljs-type">rt_sem_t</span> sem)</span>;<br></code></pre></td></tr></table></figure><p>使用该函数后，内核先唤醒所有挂在该信号量等待队列上的线程，然后将该信号量从内核对象管理器中脱离。原来挂起在信号量上的等待线程将获得 - RT_ERROR 的返回值。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>sem</td><td>信号量对象的句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>脱离成功</td></tr></tbody></table><h3 id="获取信号量-take"><a href="#获取信号量-take" class="headerlink" title="获取信号量-take"></a>获取信号量-take</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_sem_take</span> <span class="hljs-params">(<span class="hljs-type">rt_sem_t</span> sem, <span class="hljs-type">rt_int32_t</span> time)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>sem</td><td>信号量对象的句柄</td></tr><tr><td>time</td><td>指定的等待时间，单位是操作系统时钟节拍（OS Tick），或者RT_WAITING_FOREVER永远等待</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功获得信号量</td></tr><tr><td>-RT_ETIMEOUT</td><td>超时依然未获得信号量</td></tr><tr><td>-RT_ERROR</td><td>其他错误</td></tr></tbody></table><h3 id="无等待获取信号量-trytake"><a href="#无等待获取信号量-trytake" class="headerlink" title="无等待获取信号量-trytake"></a>无等待获取信号量-trytake</h3><p>当用户不想在申请的信号量上挂起线程进行等待时，可以使用无等待方式获取信号量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_sem_trytake</span><span class="hljs-params">(<span class="hljs-type">rt_sem_t</span> sem)</span>;<br></code></pre></td></tr></table></figure><p>这个函数与 rt_sem_take(sem, 0) 的作用相同，即当线程申请的信号量资源实例不可用的时候，它不会等待在该信号量上，而是直接返回 - RT_ETIMEOUT。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>sem</td><td>信号量对象的句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功获得信号量</td></tr><tr><td>-RT_ETIMEOUT</td><td>获取失败</td></tr></tbody></table><h3 id="释放信号量-release"><a href="#释放信号量-release" class="headerlink" title="释放信号量-release"></a>释放信号量-release</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_sem_release</span><span class="hljs-params">(<span class="hljs-type">rt_sem_t</span> sem)</span>;<br></code></pre></td></tr></table></figure><p>例如当信号量的值等于零时，并且有线程等待这个信号量时，释放信号量将唤醒等待在该信号量线程队列中的第一个线程，由它获取信号量；否则将把信号量的值加 1。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>sem</td><td>信号量对象的句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功释放信号量</td></tr></tbody></table><h2 id="信号量应用示例"><a href="#信号量应用示例" class="headerlink" title="信号量应用示例"></a>信号量应用示例</h2><p><strong>动态信号量的使用</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;rtthread.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_PRIORITY         25</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_TIMESLICE        5</span><br><br><span class="hljs-comment">/* 指向信号量的指针 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">rt_sem_t</span> dynamic_sem = RT_NULL;<br><br>ALIGN(RT_ALIGN_SIZE)<br><span class="hljs-type">static</span> <span class="hljs-type">char</span> thread1_stack[<span class="hljs-number">1024</span>];<br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_thread</span> <span class="hljs-title">thread1</span>;</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">rt_thread1_entry</span><span class="hljs-params">(<span class="hljs-type">void</span> *parameter)</span><br>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">rt_uint8_t</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(count &lt;= <span class="hljs-number">100</span>)<br>        &#123;<br>            count++;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-comment">/* count 每计数 10 次，就释放一次信号量 */</span><br>         <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> == (count % <span class="hljs-number">10</span>))<br>        &#123;<br>            rt_kprintf(<span class="hljs-string">&quot;t1 release a dynamic semaphore.\n&quot;</span>);<br>            rt_sem_release(dynamic_sem);<br>        &#125;<br>    &#125;<br>&#125;<br><br>ALIGN(RT_ALIGN_SIZE)<br><span class="hljs-type">static</span> <span class="hljs-type">char</span> thread2_stack[<span class="hljs-number">1024</span>];<br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_thread</span> <span class="hljs-title">thread2</span>;</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">rt_thread2_entry</span><span class="hljs-params">(<span class="hljs-type">void</span> *parameter)</span><br>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">rt_err_t</span> result;<br>    <span class="hljs-type">static</span> <span class="hljs-type">rt_uint8_t</span> number = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">/* 永久方式等待信号量，获取到信号量，则执行 number 自加的操作 */</span><br>        result = rt_sem_take(dynamic_sem, RT_WAITING_FOREVER);<br>        <span class="hljs-keyword">if</span> (result != RT_EOK)<br>        &#123;<br>            rt_kprintf(<span class="hljs-string">&quot;t2 take a dynamic semaphore, failed.\n&quot;</span>);<br>            rt_sem_delete(dynamic_sem);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            number++;<br>            rt_kprintf(<span class="hljs-string">&quot;t2 take a dynamic semaphore. number = %d\n&quot;</span> ,number);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* 信号量示例的初始化 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">semaphore_sample</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/* 创建一个动态信号量，初始值是 0 */</span><br>    dynamic_sem = rt_sem_create(<span class="hljs-string">&quot;dsem&quot;</span>, <span class="hljs-number">0</span>, RT_IPC_FLAG_FIFO);<br>    <span class="hljs-keyword">if</span> (dynamic_sem == RT_NULL)<br>    &#123;<br>        rt_kprintf(<span class="hljs-string">&quot;create dynamic semaphore failed.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        rt_kprintf(<span class="hljs-string">&quot;create done. dynamic semaphore value = 0.\n&quot;</span>);<br>    &#125;<br><br>    rt_thread_init(&amp;thread1,<br>                   <span class="hljs-string">&quot;thread1&quot;</span>,<br>                   rt_thread1_entry,<br>                   RT_NULL,<br>                   &amp;thread1_stack[<span class="hljs-number">0</span>],<br>                   <span class="hljs-keyword">sizeof</span>(thread1_stack),<br>                   THREAD_PRIORITY, THREAD_TIMESLICE);<br>    rt_thread_startup(&amp;thread1);<br><br>    rt_thread_init(&amp;thread2,<br>                   <span class="hljs-string">&quot;thread2&quot;</span>,<br>                   rt_thread2_entry,<br>                   RT_NULL,<br>                   &amp;thread2_stack[<span class="hljs-number">0</span>],<br>                   <span class="hljs-keyword">sizeof</span>(thread2_stack),<br>                   THREAD_PRIORITY<span class="hljs-number">-1</span>, THREAD_TIMESLICE);<br>    rt_thread_startup(&amp;thread2);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/* 导出到 msh 命令列表中 */</span><br>MSH_CMD_EXPORT(semaphore_sample, semaphore sample);<br></code></pre></td></tr></table></figure><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"> \ | /<br>- RT -     Thread Operating System<br> / | \     <span class="hljs-number">3.1</span><span class="hljs-number">.0</span> build Aug <span class="hljs-number">27</span> <span class="hljs-number">2018</span><br> <span class="hljs-number">2006</span> - <span class="hljs-number">2018</span> Copyright <span class="hljs-keyword">by</span> rt-thread team<br>msh &gt;semaphore_sample<br><span class="hljs-built_in">create</span> done. dynamic semaphore <span class="hljs-built_in">value</span> = <span class="hljs-number">0.</span><br>msh &gt;t1 release <span class="hljs-keyword">a</span> dynamic semaphore.<br>t2 take <span class="hljs-keyword">a</span> dynamic semaphore. <span class="hljs-built_in">number</span> = <span class="hljs-number">1</span><br>t1 release <span class="hljs-keyword">a</span> dynamic semaphore.<br>t2 take <span class="hljs-keyword">a</span> dynamic semaphore. <span class="hljs-built_in">number</span> = <span class="hljs-number">2</span><br>t1 release <span class="hljs-keyword">a</span> dynamic semaphore.<br>t2 take <span class="hljs-keyword">a</span> dynamic semaphore. <span class="hljs-built_in">number</span> = <span class="hljs-number">3</span><br>t1 release <span class="hljs-keyword">a</span> dynamic semaphore.<br>t2 take <span class="hljs-keyword">a</span> dynamic semaphore. <span class="hljs-built_in">number</span> = <span class="hljs-number">4</span><br>t1 release <span class="hljs-keyword">a</span> dynamic semaphore.<br>t2 take <span class="hljs-keyword">a</span> dynamic semaphore. <span class="hljs-built_in">number</span> = <span class="hljs-number">5</span><br>t1 release <span class="hljs-keyword">a</span> dynamic semaphore.<br>t2 take <span class="hljs-keyword">a</span> dynamic semaphore. <span class="hljs-built_in">number</span> = <span class="hljs-number">6</span><br>t1 release <span class="hljs-keyword">a</span> dynamic semaphore.<br>t2 take <span class="hljs-keyword">a</span> dynamic semaphore. <span class="hljs-built_in">number</span> = <span class="hljs-number">7</span><br>t1 release <span class="hljs-keyword">a</span> dynamic semaphore.<br>t2 take <span class="hljs-keyword">a</span> dynamic semaphore. <span class="hljs-built_in">number</span> = <span class="hljs-number">8</span><br>t1 release <span class="hljs-keyword">a</span> dynamic semaphore.<br>t2 take <span class="hljs-keyword">a</span> dynamic semaphore. <span class="hljs-built_in">number</span> = <span class="hljs-number">9</span><br>t1 release <span class="hljs-keyword">a</span> dynamic semaphore.<br>t2 take <span class="hljs-keyword">a</span> dynamic semaphore. <span class="hljs-built_in">number</span> = <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p><strong>信号量锁的作用，生产者消费者例程</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;rtthread.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_PRIORITY       6</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_STACK_SIZE     512</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_TIMESLICE      5</span><br><br><span class="hljs-comment">/* 定义最大 5 个元素能够被产生 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSEM 5</span><br><br><span class="hljs-comment">/* 用于放置生产的整数数组 */</span><br><span class="hljs-type">rt_uint32_t</span> <span class="hljs-built_in">array</span>[MAXSEM];<br><br><span class="hljs-comment">/* 指向生产者、消费者在 array 数组中的读写位置 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">rt_uint32_t</span> <span class="hljs-built_in">set</span>, get;<br><br><span class="hljs-comment">/* 指向线程控制块的指针 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">rt_thread_t</span> producer_tid = RT_NULL;<br><span class="hljs-type">static</span> <span class="hljs-type">rt_thread_t</span> consumer_tid = RT_NULL;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_semaphore</span> <span class="hljs-title">sem_lock</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_semaphore</span> <span class="hljs-title">sem_empty</span>, <span class="hljs-title">sem_full</span>;</span><br><br><span class="hljs-comment">/* 生产者线程入口 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">producer_thread_entry</span><span class="hljs-params">(<span class="hljs-type">void</span> *parameter)</span><br>&#123;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* 运行 10 次 */</span><br>    <span class="hljs-keyword">while</span> (cnt &lt; <span class="hljs-number">10</span>)<br>    &#123;<br>        <span class="hljs-comment">/* 获取一个空位 */</span><br>        rt_sem_take(&amp;sem_empty, RT_WAITING_FOREVER);<br><br>        <span class="hljs-comment">/* 修改 array 内容，上锁 */</span><br>        rt_sem_take(&amp;sem_lock, RT_WAITING_FOREVER);<br>        <span class="hljs-built_in">array</span>[<span class="hljs-built_in">set</span> % MAXSEM] = cnt + <span class="hljs-number">1</span>;<br>        rt_kprintf(<span class="hljs-string">&quot;the producer generates a number: %d\n&quot;</span>, <span class="hljs-built_in">array</span>[<span class="hljs-built_in">set</span> % MAXSEM]);<br>        <span class="hljs-built_in">set</span>++;<br>        rt_sem_release(&amp;sem_lock);<br><br>        <span class="hljs-comment">/* 发布一个满位 */</span><br>        rt_sem_release(&amp;sem_full);<br>        cnt++;<br><br>        <span class="hljs-comment">/* 暂停一段时间 */</span><br>        rt_thread_mdelay(<span class="hljs-number">20</span>);<br>    &#125;<br><br>    rt_kprintf(<span class="hljs-string">&quot;the producer exit!\n&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">/* 消费者线程入口 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">consumer_thread_entry</span><span class="hljs-params">(<span class="hljs-type">void</span> *parameter)</span><br>&#123;<br>    <span class="hljs-type">rt_uint32_t</span> sum = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">/* 获取一个满位 */</span><br>        rt_sem_take(&amp;sem_full, RT_WAITING_FOREVER);<br><br>        <span class="hljs-comment">/* 临界区，上锁进行操作 */</span><br>        rt_sem_take(&amp;sem_lock, RT_WAITING_FOREVER);<br>        sum += <span class="hljs-built_in">array</span>[get % MAXSEM];<br>        rt_kprintf(<span class="hljs-string">&quot;the consumer[%d] get a number: %d\n&quot;</span>, (get % MAXSEM), <span class="hljs-built_in">array</span>[get % MAXSEM]);<br>        get++;<br>        rt_sem_release(&amp;sem_lock);<br><br>        <span class="hljs-comment">/* 释放一个空位 */</span><br>        rt_sem_release(&amp;sem_empty);<br><br>        <span class="hljs-comment">/* 生产者生产到 10 个数目，停止，消费者线程相应停止 */</span><br>        <span class="hljs-keyword">if</span> (get == <span class="hljs-number">10</span>) <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-comment">/* 暂停一小会时间 */</span><br>        rt_thread_mdelay(<span class="hljs-number">50</span>);<br>    &#125;<br><br>    rt_kprintf(<span class="hljs-string">&quot;the consumer sum is: %d\n&quot;</span>, sum);<br>    rt_kprintf(<span class="hljs-string">&quot;the consumer exit!\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">producer_consumer</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-built_in">set</span> = <span class="hljs-number">0</span>;<br>    get = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* 初始化 3 个信号量 */</span><br>    rt_sem_init(&amp;sem_lock, <span class="hljs-string">&quot;lock&quot;</span>,     <span class="hljs-number">1</span>,      RT_IPC_FLAG_FIFO);<br>    rt_sem_init(&amp;sem_empty, <span class="hljs-string">&quot;empty&quot;</span>,   MAXSEM, RT_IPC_FLAG_FIFO);<br>    rt_sem_init(&amp;sem_full, <span class="hljs-string">&quot;full&quot;</span>,     <span class="hljs-number">0</span>,      RT_IPC_FLAG_FIFO);<br><br>    <span class="hljs-comment">/* 创建生产者线程 */</span><br>    producer_tid = rt_thread_create(<span class="hljs-string">&quot;producer&quot;</span>,<br>                                    producer_thread_entry, RT_NULL,<br>                                    THREAD_STACK_SIZE,<br>                                    THREAD_PRIORITY - <span class="hljs-number">1</span>,<br>                                    THREAD_TIMESLICE);<br>    <span class="hljs-keyword">if</span> (producer_tid != RT_NULL)<br>    &#123;<br>        rt_thread_startup(producer_tid);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        rt_kprintf(<span class="hljs-string">&quot;create thread producer failed&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* 创建消费者线程 */</span><br>    consumer_tid = rt_thread_create(<span class="hljs-string">&quot;consumer&quot;</span>,<br>                                    consumer_thread_entry, RT_NULL,<br>                                    THREAD_STACK_SIZE,<br>                                    THREAD_PRIORITY + <span class="hljs-number">1</span>,<br>                                    THREAD_TIMESLICE);<br>    <span class="hljs-keyword">if</span> (consumer_tid != RT_NULL)<br>    &#123;<br>        rt_thread_startup(consumer_tid);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        rt_kprintf(<span class="hljs-string">&quot;create thread consumer failed&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 导出到 msh 命令列表中 */</span><br>MSH_CMD_EXPORT(producer_consumer, producer_consumer sample);<br></code></pre></td></tr></table></figure><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">\ | /<br>- RT -     Thread Operating System<br> / | \     <span class="hljs-number">3.1</span><span class="hljs-number">.0</span> build Aug <span class="hljs-number">27</span> <span class="hljs-number">2018</span><br> <span class="hljs-number">2006</span> - <span class="hljs-number">2018</span> Copyright <span class="hljs-keyword">by</span> rt-thread team<br>msh &gt;producer_consumer<br><span class="hljs-keyword">the</span> producer generates <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">1</span><br><span class="hljs-keyword">the</span> consumer[<span class="hljs-number">0</span>] <span class="hljs-built_in">get</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">1</span><br>msh &gt;<span class="hljs-keyword">the</span> producer generates <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">2</span><br><span class="hljs-keyword">the</span> producer generates <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">3</span><br><span class="hljs-keyword">the</span> consumer[<span class="hljs-number">1</span>] <span class="hljs-built_in">get</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">2</span><br><span class="hljs-keyword">the</span> producer generates <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">4</span><br><span class="hljs-keyword">the</span> producer generates <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">5</span><br><span class="hljs-keyword">the</span> producer generates <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">6</span><br><span class="hljs-keyword">the</span> consumer[<span class="hljs-number">2</span>] <span class="hljs-built_in">get</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">3</span><br><span class="hljs-keyword">the</span> producer generates <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">7</span><br><span class="hljs-keyword">the</span> producer generates <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">8</span><br><span class="hljs-keyword">the</span> consumer[<span class="hljs-number">3</span>] <span class="hljs-built_in">get</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">4</span><br><span class="hljs-keyword">the</span> producer generates <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">9</span><br><span class="hljs-keyword">the</span> consumer[<span class="hljs-number">4</span>] <span class="hljs-built_in">get</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">5</span><br><span class="hljs-keyword">the</span> producer generates <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">10</span><br><span class="hljs-keyword">the</span> producer exit!<br><span class="hljs-keyword">the</span> consumer[<span class="hljs-number">0</span>] <span class="hljs-built_in">get</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">6</span><br><span class="hljs-keyword">the</span> consumer[<span class="hljs-number">1</span>] <span class="hljs-built_in">get</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">7</span><br><span class="hljs-keyword">the</span> consumer[<span class="hljs-number">2</span>] <span class="hljs-built_in">get</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">8</span><br><span class="hljs-keyword">the</span> consumer[<span class="hljs-number">3</span>] <span class="hljs-built_in">get</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">9</span><br><span class="hljs-keyword">the</span> consumer[<span class="hljs-number">4</span>] <span class="hljs-built_in">get</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">10</span><br><span class="hljs-keyword">the</span> consumer <span class="hljs-built_in">sum</span> is: <span class="hljs-number">55</span><br><span class="hljs-keyword">the</span> consumer exit!<br></code></pre></td></tr></table></figure><h2 id="互斥量-Mutex"><a href="#互斥量-Mutex" class="headerlink" title="互斥量 Mutex"></a>互斥量 Mutex</h2><p>互斥量又叫相互排斥的信号量，是一种特殊的二值信号量。</p><p>互斥量和信号量不同的是：拥有互斥量的线程拥有互斥量的所有权，互斥量支持递归访问且能防止线程优先级翻转；并且互斥量只能由持有线程释放，而信号量则可以由任何线程释放。</p><p><img src="/2021/42e53028/06mutex_work.png" alt="互斥量工作示意图"></p><p>线程优先级翻转如下。</p><p><img src="/2021/42e53028/06priority_inversion.png" alt="优先级反转 (M 为信号量)"></p><p><img src="/2021/42e53028/06priority_inherit.png" alt="优先级继承 (M 为互斥量)"></p><h3 id="互斥量API"><a href="#互斥量API" class="headerlink" title="互斥量API"></a>互斥量API</h3><p><img src="/2021/42e53028/06mutex_ops.png" alt="互斥量相关接口"></p><h3 id="创建和删除互斥量-create"><a href="#创建和删除互斥量-create" class="headerlink" title="创建和删除互斥量-create"></a>创建和删除互斥量-create</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_mutex_t</span> <span class="hljs-title function_">rt_mutex_create</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">rt_uint8_t</span> flag)</span>;<br></code></pre></td></tr></table></figure><p>互斥量的 flag 标志设置为 RT_IPC_FLAG_PRIO，表示在多个线程等待资源时，将由优先级高的线程优先获得资源。flag 设置为 RT_IPC_FLAG_FIFO，表示在多个线程等待资源时，将按照先来先得的顺序获得资源。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>name</td><td>互斥量的名称</td></tr><tr><td>flag</td><td>互斥量标志，它可以取如下数值： RT_IPC_FLAG_FIFO 或 RT_IPC_FLAG_PRIO</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>互斥量句柄</td><td>创建成功</td></tr><tr><td>RT_NULL</td><td>创建失败</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mutex_delete</span> <span class="hljs-params">(<span class="hljs-type">rt_mutex_t</span> mutex)</span>;<br></code></pre></td></tr></table></figure><p>当删除一个互斥量时，所有等待此互斥量的线程都将被唤醒，等待线程获得的返回值是 - RT_ERROR。然后系统将该互斥量从内核对象管理器链表中删除并释放互斥量占用的内存空间。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mutex</td><td>互斥量对象的句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>删除成功</td></tr></tbody></table><h3 id="初始化和脱离互斥量-init"><a href="#初始化和脱离互斥量-init" class="headerlink" title="初始化和脱离互斥量-init"></a>初始化和脱离互斥量-init</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mutex_init</span> <span class="hljs-params">(<span class="hljs-type">rt_mutex_t</span> mutex, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">rt_uint8_t</span> flag)</span>;<br></code></pre></td></tr></table></figure><p>flag见上</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mutex</td><td>互斥量对象的句柄，它由用户提供，并指向互斥量对象的内存块</td></tr><tr><td>name</td><td>互斥量的名称</td></tr><tr><td>flag</td><td>互斥量标志，它可以取如下数值： RT_IPC_FLAG_FIFO 或 RT_IPC_FLAG_PRIO</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>初始化成功</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mutex_detach</span> <span class="hljs-params">(<span class="hljs-type">rt_mutex_t</span> mutex)</span>;<br></code></pre></td></tr></table></figure><p>使用该函数接口后，内核先唤醒所有挂在该互斥量上的线程（线程的返回值是 -RT_ERROR），然后系统将该互斥量从内核对象管理器中脱离。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mutex</td><td>互斥量对象的句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr></tbody></table><h3 id="获取互斥量-take"><a href="#获取互斥量-take" class="headerlink" title="获取互斥量-take"></a>获取互斥量-take</h3><p>线程获取了互斥量，那么线程就有了对该互斥量的所有权，即某一个时刻一个互斥量只能被一个线程持有。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mutex_take</span> <span class="hljs-params">(<span class="hljs-type">rt_mutex_t</span> mutex, <span class="hljs-type">rt_int32_t</span> time)</span>;<br></code></pre></td></tr></table></figure><ul><li><p>如果互斥量没有被其他线程控制，那么申请该互斥量的线程将成功获得该互斥量。</p></li><li><p>如果互斥量已经被当前线程线程控制，则该互斥量的持有计数加 1，当前线程也不会挂起等待。</p></li><li><p>如果互斥量已经被其他线程占有，则当前线程在该互斥量上挂起等待，直到其他线程释放它或者等待时间超过指定的超时时间。</p></li></ul><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mutex</td><td>互斥量对象的句柄</td></tr><tr><td>time</td><td>指定等待的时间</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功获得互斥量</td></tr><tr><td>-RT_ETIMEOUT</td><td>超时</td></tr><tr><td>-RT_ERROR</td><td>获取失败</td></tr></tbody></table><h3 id="释放互斥量-release"><a href="#释放互斥量-release" class="headerlink" title="释放互斥量-release"></a>释放互斥量-release</h3><p>当线程完成互斥资源的访问后，应尽快释放它占据的互斥量，使得其他线程能及时获取该互斥量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mutex_release</span><span class="hljs-params">(<span class="hljs-type">rt_mutex_t</span> mutex)</span>;<br></code></pre></td></tr></table></figure><ul><li>只有已经拥有互斥量控制权的线程才能释放它，每释放一次该互斥量，它的持有计数就减 1。</li><li>当该互斥量的持有计数为零时（即持有线程已经释放所有的持有操作），它变为可用，等待在该信号量上的线程将被唤醒。</li></ul><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mutex</td><td>互斥量对象的句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr></tbody></table><h2 id="互斥量应用示例"><a href="#互斥量应用示例" class="headerlink" title="互斥量应用示例"></a>互斥量应用示例</h2><p>这是一个互斥量的应用例程，互斥锁是一种保护共享资源的方法。当一个线程拥有互斥锁的时候，可以保护共享资源不被其他线程破坏。下面用一个例子来说明，有两个线程：线程 1 和线程 2，线程 1 对 2 个 number 分别进行加 1 操作；线程 2 也对 2 个 number 分别进行加 1 操作，使用互斥量保证线程改变 2 个 number 值的操作不被打断。如下代码所示：</p><p><strong>互斥量例程</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;rtthread.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_PRIORITY         8</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_TIMESLICE        5</span><br><br><span class="hljs-comment">/* 指向互斥量的指针 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">rt_mutex_t</span> dynamic_mutex = RT_NULL;<br><span class="hljs-type">static</span> <span class="hljs-type">rt_uint8_t</span> number1,number2 = <span class="hljs-number">0</span>;<br><br>ALIGN(RT_ALIGN_SIZE)<br><span class="hljs-type">static</span> <span class="hljs-type">char</span> thread1_stack[<span class="hljs-number">1024</span>];<br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_thread</span> <span class="hljs-title">thread1</span>;</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">rt_thread_entry1</span><span class="hljs-params">(<span class="hljs-type">void</span> *parameter)</span><br>&#123;<br>      <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>      &#123;<br>          <span class="hljs-comment">/* 线程 1 获取到互斥量后，先后对 number1、number2 进行加 1 操作，然后释放互斥量 */</span><br>          rt_mutex_take(dynamic_mutex, RT_WAITING_FOREVER);<br>          number1++;<br>          rt_thread_mdelay(<span class="hljs-number">10</span>);<br>          number2++;<br>          rt_mutex_release(dynamic_mutex);<br>       &#125;<br>&#125;<br><br>ALIGN(RT_ALIGN_SIZE)<br><span class="hljs-type">static</span> <span class="hljs-type">char</span> thread2_stack[<span class="hljs-number">1024</span>];<br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_thread</span> <span class="hljs-title">thread2</span>;</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">rt_thread_entry2</span><span class="hljs-params">(<span class="hljs-type">void</span> *parameter)</span><br>&#123;<br>      <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>      &#123;<br>          <span class="hljs-comment">/* 线程 2 获取到互斥量后，检查 number1、number2 的值是否相同，相同则表示 mutex 起到了锁的作用 */</span><br>          rt_mutex_take(dynamic_mutex, RT_WAITING_FOREVER);<br>          <span class="hljs-keyword">if</span>(number1 != number2)<br>          &#123;<br>            rt_kprintf(<span class="hljs-string">&quot;not protect.number1 = %d, mumber2 = %d \n&quot;</span>,number1 ,number2);<br>          &#125;<br>          <span class="hljs-keyword">else</span><br>          &#123;<br>            rt_kprintf(<span class="hljs-string">&quot;mutex protect ,number1 = mumber2 is %d\n&quot;</span>,number1);<br>          &#125;<br><br>           number1++;<br>           number2++;<br>           rt_mutex_release(dynamic_mutex);<br><br>          <span class="hljs-keyword">if</span>(number1&gt;=<span class="hljs-number">50</span>)<br>              <span class="hljs-keyword">return</span>;<br>      &#125;<br>&#125;<br><br><span class="hljs-comment">/* 互斥量示例的初始化 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">mutex_sample</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/* 创建一个动态互斥量 */</span><br>    dynamic_mutex = rt_mutex_create(<span class="hljs-string">&quot;dmutex&quot;</span>, RT_IPC_FLAG_FIFO);<br>    <span class="hljs-keyword">if</span> (dynamic_mutex == RT_NULL)<br>    &#123;<br>        rt_kprintf(<span class="hljs-string">&quot;create dynamic mutex failed.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    rt_thread_init(&amp;thread1,<br>                   <span class="hljs-string">&quot;thread1&quot;</span>,<br>                   rt_thread_entry1,<br>                   RT_NULL,<br>                   &amp;thread1_stack[<span class="hljs-number">0</span>],<br>                   <span class="hljs-keyword">sizeof</span>(thread1_stack),<br>                   THREAD_PRIORITY, THREAD_TIMESLICE);<br>    rt_thread_startup(&amp;thread1);<br><br>    rt_thread_init(&amp;thread2,<br>                   <span class="hljs-string">&quot;thread2&quot;</span>,<br>                   rt_thread_entry2,<br>                   RT_NULL,<br>                   &amp;thread2_stack[<span class="hljs-number">0</span>],<br>                   <span class="hljs-keyword">sizeof</span>(thread2_stack),<br>                   THREAD_PRIORITY<span class="hljs-number">-1</span>, THREAD_TIMESLICE);<br>    rt_thread_startup(&amp;thread2);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 导出到 MSH 命令列表中 */</span><br>MSH_CMD_EXPORT(mutex_sample, mutex sample);<br></code></pre></td></tr></table></figure><p>线程 1 与线程 2 中均使用互斥量保护对 2 个 number 的操作（倘若将线程 1 中的获取、释放互斥量语句注释掉，线程 1 将对 number 不再做保护），仿真运行结果如下：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\</span> | /<br>- RT -     Thread Operating System<br> / | <span class="hljs-string">\</span>     <span class="hljs-number">3.1</span>.<span class="hljs-number">0</span> build Aug <span class="hljs-number">24</span> <span class="hljs-number">2018</span><br> <span class="hljs-number">2006</span> - <span class="hljs-number">2018</span> Copyright <span class="hljs-keyword">by</span> rt-thread team<br>msh &gt;mutex_sample<br>msh &gt;mutex protect ,number1 = mumber2 <span class="hljs-keyword">is</span> <span class="hljs-number">1</span><br>mutex protect ,number1 = mumber2 <span class="hljs-keyword">is</span> <span class="hljs-number">2</span><br>mutex protect ,number1 = mumber2 <span class="hljs-keyword">is</span> <span class="hljs-number">3</span><br>mutex protect ,number1 = mumber2 <span class="hljs-keyword">is</span> <span class="hljs-number">4</span><br>…<br>mutex protect ,number1 = mumber2 <span class="hljs-keyword">is</span> <span class="hljs-number">48</span><br>mutex protect ,number1 = mumber2 <span class="hljs-keyword">is</span> <span class="hljs-number">49</span><br></code></pre></td></tr></table></figure><p>线程使用互斥量保护对两个 number 的操作，使 number 值保持一致。</p><p>互斥量的另一个例子见下面的代码，这个例子将创建 3 个动态线程以检查持有互斥量时，持有的线程优先级是否被调整到等待线程优先级中的最高优先级。</p><p><strong>防止优先级翻转特性例程</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;rtthread.h&gt;</span></span><br><br><span class="hljs-comment">/* 指向线程控制块的指针 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">rt_thread_t</span> tid1 = RT_NULL;<br><span class="hljs-type">static</span> <span class="hljs-type">rt_thread_t</span> tid2 = RT_NULL;<br><span class="hljs-type">static</span> <span class="hljs-type">rt_thread_t</span> tid3 = RT_NULL;<br><span class="hljs-type">static</span> <span class="hljs-type">rt_mutex_t</span> mutex = RT_NULL;<br><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_PRIORITY       10</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_STACK_SIZE     512</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_TIMESLICE    5</span><br><br><span class="hljs-comment">/* 线程 1 入口 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">thread1_entry</span><span class="hljs-params">(<span class="hljs-type">void</span> *parameter)</span><br>&#123;<br>    <span class="hljs-comment">/* 先让低优先级线程运行 */</span><br>    rt_thread_mdelay(<span class="hljs-number">100</span>);<br><br>    <span class="hljs-comment">/* 此时 thread3 持有 mutex，并且 thread2 等待持有 mutex */</span><br><br>    <span class="hljs-comment">/* 检查 thread2 与 thread3 的优先级情况 */</span><br>    <span class="hljs-keyword">if</span> (tid2-&gt;current_priority != tid3-&gt;current_priority)<br>    &#123;<br>        <span class="hljs-comment">/* 优先级不相同，测试失败 */</span><br>        rt_kprintf(<span class="hljs-string">&quot;the priority of thread2 is: %d\n&quot;</span>, tid2-&gt;current_priority);<br>        rt_kprintf(<span class="hljs-string">&quot;the priority of thread3 is: %d\n&quot;</span>, tid3-&gt;current_priority);<br>        rt_kprintf(<span class="hljs-string">&quot;test failed.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        rt_kprintf(<span class="hljs-string">&quot;the priority of thread2 is: %d\n&quot;</span>, tid2-&gt;current_priority);<br>        rt_kprintf(<span class="hljs-string">&quot;the priority of thread3 is: %d\n&quot;</span>, tid3-&gt;current_priority);<br>        rt_kprintf(<span class="hljs-string">&quot;test OK.\n&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* 线程 2 入口 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">thread2_entry</span><span class="hljs-params">(<span class="hljs-type">void</span> *parameter)</span><br>&#123;<br>    <span class="hljs-type">rt_err_t</span> result;<br><br>    rt_kprintf(<span class="hljs-string">&quot;the priority of thread2 is: %d\n&quot;</span>, tid2-&gt;current_priority);<br><br>    <span class="hljs-comment">/* 先让低优先级线程运行 */</span><br>    rt_thread_mdelay(<span class="hljs-number">50</span>);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 试图持有互斥锁，此时 thread3 持有，应把 thread3 的优先级提升</span><br><span class="hljs-comment">     * 到 thread2 相同的优先级</span><br><span class="hljs-comment">     */</span><br>    result = rt_mutex_take(mutex, RT_WAITING_FOREVER);<br><br>    <span class="hljs-keyword">if</span> (result == RT_EOK)<br>    &#123;<br>        <span class="hljs-comment">/* 释放互斥锁 */</span><br>        rt_mutex_release(mutex);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* 线程 3 入口 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">thread3_entry</span><span class="hljs-params">(<span class="hljs-type">void</span> *parameter)</span><br>&#123;<br>    <span class="hljs-type">rt_tick_t</span> tick;<br>    <span class="hljs-type">rt_err_t</span> result;<br><br>    rt_kprintf(<span class="hljs-string">&quot;the priority of thread3 is: %d\n&quot;</span>, tid3-&gt;current_priority);<br><br>    result = rt_mutex_take(mutex, RT_WAITING_FOREVER);<br>    <span class="hljs-keyword">if</span> (result != RT_EOK)<br>    &#123;<br>        rt_kprintf(<span class="hljs-string">&quot;thread3 take a mutex, failed.\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* 做一个长时间的循环，500ms */</span><br>    tick = rt_tick_get();<br>    <span class="hljs-keyword">while</span> (rt_tick_get() - tick &lt; (RT_TICK_PER_SECOND / <span class="hljs-number">2</span>)) ;<br><br>    rt_mutex_release(mutex);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">pri_inversion</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/* 创建互斥锁 */</span><br>    mutex = rt_mutex_create(<span class="hljs-string">&quot;mutex&quot;</span>, RT_IPC_FLAG_FIFO);<br>    <span class="hljs-keyword">if</span> (mutex == RT_NULL)<br>    &#123;<br>        rt_kprintf(<span class="hljs-string">&quot;create dynamic mutex failed.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* 创建线程 1 */</span><br>    tid1 = rt_thread_create(<span class="hljs-string">&quot;thread1&quot;</span>,<br>                            thread1_entry,<br>                            RT_NULL,<br>                            THREAD_STACK_SIZE,<br>                            THREAD_PRIORITY - <span class="hljs-number">1</span>, THREAD_TIMESLICE);<br>    <span class="hljs-keyword">if</span> (tid1 != RT_NULL)<br>         rt_thread_startup(tid1);<br><br>    <span class="hljs-comment">/* 创建线程 2 */</span><br>    tid2 = rt_thread_create(<span class="hljs-string">&quot;thread2&quot;</span>,<br>                            thread2_entry,<br>                            RT_NULL,<br>                            THREAD_STACK_SIZE,<br>                            THREAD_PRIORITY, THREAD_TIMESLICE);<br>    <span class="hljs-keyword">if</span> (tid2 != RT_NULL)<br>        rt_thread_startup(tid2);<br><br>    <span class="hljs-comment">/* 创建线程 3 */</span><br>    tid3 = rt_thread_create(<span class="hljs-string">&quot;thread3&quot;</span>,<br>                            thread3_entry,<br>                            RT_NULL,<br>                            THREAD_STACK_SIZE,<br>                            THREAD_PRIORITY + <span class="hljs-number">1</span>, THREAD_TIMESLICE);<br>    <span class="hljs-keyword">if</span> (tid3 != RT_NULL)<br>        rt_thread_startup(tid3);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 导出到 msh 命令列表中 */</span><br>MSH_CMD_EXPORT(pri_inversion, prio_inversion sample);<br></code></pre></td></tr></table></figure><p>仿真运行结果如下：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs subunit">\ | /<br>- RT -     Thread Operating System<br> / | \     3.1.0 build Aug 27 2018<br> 2006 - 2018 Copyright by rt-thread team<br>msh &gt;pri_inversion<br>the priority of thread2 is: 10<br>the priority of thread3 is: 11<br>the priority of thread2 is: 10<br>the priority of thread3 is: 10<br><span class="hljs-keyword">test </span>OK.<br></code></pre></td></tr></table></figure><h2 id="事件集Event"><a href="#事件集Event" class="headerlink" title="事件集Event"></a>事件集Event</h2><p>一个事件集可以包含多个事件，利用事件集可以完成<strong>一对多</strong>，<strong>多对多</strong>，<strong>多对一</strong>的线程间同步。</p><p>这种多个事件的集合可以用一个 32 位无符号整型变量来表示，变量的每一位代表一个事件，线程通过 “逻辑与” 或“逻辑或”将一个或多个事件关联起来，形成事件组合。</p><ul><li>事件的 “逻辑或” 也称为是独立型同步，指的是线程与任何事件之一发生同步；</li><li>事件 “逻辑与” 也称为是关联型同步，指的是线程与若干事件都发生同步。</li><li>事件只与线程相关，事件间相互独立：每个线程可拥有 32 个事件标志，采用一个 32 bit 无符号整型数进行记录，每一个 bit 代表一个事件；</li><li>事件仅用于同步，不提供数据传输功能；</li><li>事件无排队性，即多次向线程发送同一事件 (如果线程还未来得及读走)，其效果等同于只发送一次。</li></ul><p><img src="/2021/42e53028/06event_work.png" alt="事件集工作示意图"></p><p>线程 #1 的事件标志中第 1 位和第 30 位被置位，如果事件信息标记位设为逻辑与，则表示线程 #1 只有在事件 1 和事件 30 都发生以后才会被触发唤醒，如果事件信息标记位设为逻辑或，则事件 1 或事件 30 中的任意一个发生都会触发唤醒线程 #1。如果信息标记同时设置了清除标记位，则当线程 #1 唤醒后将主动把事件 1 和事件 30 清为零，否则事件标志将依然存在（即置 1）。</p><h3 id="事件集API"><a href="#事件集API" class="headerlink" title="事件集API"></a>事件集API</h3><p><img src="/2021/42e53028/06event_ops.png" alt="事件相关接口"></p><h3 id="创建和删除事件集-create"><a href="#创建和删除事件集-create" class="headerlink" title="创建和删除事件集-create"></a>创建和删除事件集-create</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_event_t</span> <span class="hljs-title function_">rt_event_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">rt_uint8_t</span> flag)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>name</td><td>事件集的名称</td></tr><tr><td>flag</td><td>事件集的标志，它可以取如下数值： RT_IPC_FLAG_FIFO 或 RT_IPC_FLAG_PRIO</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_NULL</td><td>创建失败</td></tr><tr><td>事件对象的句柄</td><td>创建成功</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_event_delete</span><span class="hljs-params">(<span class="hljs-type">rt_event_t</span> event)</span>;<br></code></pre></td></tr></table></figure><p>在删除前会唤醒所有挂起在该事件集上的线程（线程的返回值是 - RT_ERROR），然后释放事件集对象占用的内存块。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>event</td><td>事件集对象的句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr></tbody></table><h3 id="初始化和脱离事件集-init"><a href="#初始化和脱离事件集-init" class="headerlink" title="初始化和脱离事件集-init"></a>初始化和脱离事件集-init</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_event_init</span><span class="hljs-params">(<span class="hljs-type">rt_event_t</span> event, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">rt_uint8_t</span> flag)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>event</td><td>事件集对象的句柄</td></tr><tr><td>name</td><td>事件集的名称</td></tr><tr><td>flag</td><td>事件集的标志，它可以取如下数值： RT_IPC_FLAG_FIFO 或 RT_IPC_FLAG_PRIO</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_event_detach</span><span class="hljs-params">(<span class="hljs-type">rt_event_t</span> event)</span>;<br></code></pre></td></tr></table></figure><p>用户调用这个函数时，系统首先唤醒所有挂在该事件集等待队列上的线程（线程的返回值是 - RT_ERROR），然后将该事件集从内核对象管理器中脱离。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>event</td><td>事件集对象的句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr></tbody></table><h3 id="发送事件-send"><a href="#发送事件-send" class="headerlink" title="发送事件-send"></a>发送事件-send</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_event_send</span><span class="hljs-params">(<span class="hljs-type">rt_event_t</span> event, <span class="hljs-type">rt_uint32_t</span> <span class="hljs-built_in">set</span>)</span>;<br></code></pre></td></tr></table></figure><p>使用该函数接口时，通过参数 set 指定的事件标志来设定 event 事件集对象的事件标志值，然后遍历等待在 event 事件集对象上的等待线程链表，判断是否有线程的事件激活要求与当前 event 对象事件标志值匹配，如果有，则唤醒该线程。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>event</td><td>事件集对象的句柄</td></tr><tr><td>set</td><td>发送的一个或多个事件的标志值,它可以取如下数值： RT_IPC_FLAG_FIFO 或 RT_IPC_FLAG_PRIO</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr></tbody></table><h3 id="接收事件-recv"><a href="#接收事件-recv" class="headerlink" title="接收事件-recv"></a>接收事件-recv</h3><p>内核使用 32 位的无符号整数来标识事件集，它的每一位代表一个事件，因此一个事件集对象可同时等待接收 32 个事件.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_event_recv</span><span class="hljs-params">(<span class="hljs-type">rt_event_t</span> event,</span><br><span class="hljs-params">                           <span class="hljs-type">rt_uint32_t</span> <span class="hljs-built_in">set</span>,</span><br><span class="hljs-params">                           <span class="hljs-type">rt_uint8_t</span> option,</span><br><span class="hljs-params">                           <span class="hljs-type">rt_int32_t</span> timeout,</span><br><span class="hljs-params">                           <span class="hljs-type">rt_uint32_t</span>* recved)</span>;<br></code></pre></td></tr></table></figure><p>当用户调用这个接口时，系统首先根据 set 参数和接收选项 option 来判断它要接收的事件是否发生，如果已经发生，则根据参数 option 上是否设置有 RT_EVENT_FLAG_CLEAR 来决定是否重置事件的相应标志位，然后返回（其中 recved 参数返回接收到的事件）；如果没有发生，则把等待的 set 和 option 参数填入线程本身的结构中，然后把线程挂起在此事件上，直到其等待的事件满足条件或等待时间超过指定的超时时间。如果超时时间设置为零，则表示当线程要接受的事件没有满足其要求时就不等待，而直接返回 - RT_ETIMEOUT。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>event</td><td>事件集对象的句柄</td></tr><tr><td>set</td><td>接收线程感兴趣的事件</td></tr><tr><td>option</td><td>接收选项 <strong>可取值见下</strong></td></tr><tr><td>timeout</td><td>指定超时时间</td></tr><tr><td>recved</td><td>指向接收到的事件</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr><tr><td>-RT_ETIMEOUT</td><td>超时</td></tr><tr><td>-RT_ERROR</td><td>错误</td></tr></tbody></table><p>option 的值可取：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 选择 逻辑与 或 逻辑或 的方式接收事件 */</span><br>RT_EVENT_FLAG_OR<br>RT_EVENT_FLAG_AND<br><br><span class="hljs-comment">/* 选择清除重置事件标志位 */</span><br>RT_EVENT_FLAG_CLEAR<br></code></pre></td></tr></table></figure><h2 id="事件集应用示例"><a href="#事件集应用示例" class="headerlink" title="事件集应用示例"></a>事件集应用示例</h2><p>这是事件集的应用例程，例子中初始化了一个事件集，两个线程。一个线程等待自己关心的事件发生，另外一个线程发送事件，如代码清单 6-5 例所示：</p><p>事件集的使用例程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;rtthread.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_PRIORITY      9</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_TIMESLICE     5</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EVENT_FLAG3 (1 &lt;&lt; 3)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EVENT_FLAG5 (1 &lt;&lt; 5)</span><br><br><span class="hljs-comment">/* 事件控制块 */</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_event</span> <span class="hljs-title">event</span>;</span><br><br>ALIGN(RT_ALIGN_SIZE)<br><span class="hljs-type">static</span> <span class="hljs-type">char</span> thread1_stack[<span class="hljs-number">1024</span>];<br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_thread</span> <span class="hljs-title">thread1</span>;</span><br><br><span class="hljs-comment">/* 线程 1 入口函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">thread1_recv_event</span><span class="hljs-params">(<span class="hljs-type">void</span> *param)</span><br>&#123;<br>    <span class="hljs-type">rt_uint32_t</span> e;<br><br>    <span class="hljs-comment">/* 第一次接收事件，事件 3 或事件 5 任意一个可以触发线程 1，接收完后清除事件标志 */</span><br>    <span class="hljs-keyword">if</span> (rt_event_recv(&amp;event, (EVENT_FLAG3 | EVENT_FLAG5),<br>                      RT_EVENT_FLAG_OR | RT_EVENT_FLAG_CLEAR,<br>                      RT_WAITING_FOREVER, &amp;e) == RT_EOK)<br>    &#123;<br>        rt_kprintf(<span class="hljs-string">&quot;thread1: OR recv event 0x%x\n&quot;</span>, e);<br>    &#125;<br><br>    rt_kprintf(<span class="hljs-string">&quot;thread1: delay 1s to prepare the second event\n&quot;</span>);<br>    rt_thread_mdelay(<span class="hljs-number">1000</span>);<br><br>    <span class="hljs-comment">/* 第二次接收事件，事件 3 和事件 5 均发生时才可以触发线程 1，接收完后清除事件标志 */</span><br>    <span class="hljs-keyword">if</span> (rt_event_recv(&amp;event, (EVENT_FLAG3 | EVENT_FLAG5),<br>                      RT_EVENT_FLAG_AND | RT_EVENT_FLAG_CLEAR,<br>                      RT_WAITING_FOREVER, &amp;e) == RT_EOK)<br>    &#123;<br>        rt_kprintf(<span class="hljs-string">&quot;thread1: AND recv event 0x%x\n&quot;</span>, e);<br>    &#125;<br>    rt_kprintf(<span class="hljs-string">&quot;thread1 leave.\n&quot;</span>);<br>&#125;<br><br><br>ALIGN(RT_ALIGN_SIZE)<br><span class="hljs-type">static</span> <span class="hljs-type">char</span> thread2_stack[<span class="hljs-number">1024</span>];<br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_thread</span> <span class="hljs-title">thread2</span>;</span><br><br><span class="hljs-comment">/* 线程 2 入口 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">thread2_send_event</span><span class="hljs-params">(<span class="hljs-type">void</span> *param)</span><br>&#123;<br>    rt_kprintf(<span class="hljs-string">&quot;thread2: send event3\n&quot;</span>);<br>    rt_event_send(&amp;event, EVENT_FLAG3);<br>    rt_thread_mdelay(<span class="hljs-number">200</span>);<br><br>    rt_kprintf(<span class="hljs-string">&quot;thread2: send event5\n&quot;</span>);<br>    rt_event_send(&amp;event, EVENT_FLAG5);<br>    rt_thread_mdelay(<span class="hljs-number">200</span>);<br><br>    rt_kprintf(<span class="hljs-string">&quot;thread2: send event3\n&quot;</span>);<br>    rt_event_send(&amp;event, EVENT_FLAG3);<br>    rt_kprintf(<span class="hljs-string">&quot;thread2 leave.\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">event_sample</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">rt_err_t</span> result;<br><br>    <span class="hljs-comment">/* 初始化事件对象 */</span><br>    result = rt_event_init(&amp;event, <span class="hljs-string">&quot;event&quot;</span>, RT_IPC_FLAG_FIFO);<br>    <span class="hljs-keyword">if</span> (result != RT_EOK)<br>    &#123;<br>        rt_kprintf(<span class="hljs-string">&quot;init event failed.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    rt_thread_init(&amp;thread1,<br>                   <span class="hljs-string">&quot;thread1&quot;</span>,<br>                   thread1_recv_event,<br>                   RT_NULL,<br>                   &amp;thread1_stack[<span class="hljs-number">0</span>],<br>                   <span class="hljs-keyword">sizeof</span>(thread1_stack),<br>                   THREAD_PRIORITY - <span class="hljs-number">1</span>, THREAD_TIMESLICE);<br>    rt_thread_startup(&amp;thread1);<br><br>    rt_thread_init(&amp;thread2,<br>                   <span class="hljs-string">&quot;thread2&quot;</span>,<br>                   thread2_send_event,<br>                   RT_NULL,<br>                   &amp;thread2_stack[<span class="hljs-number">0</span>],<br>                   <span class="hljs-keyword">sizeof</span>(thread2_stack),<br>                   THREAD_PRIORITY, THREAD_TIMESLICE);<br>    rt_thread_startup(&amp;thread2);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 导出到 msh 命令列表中 */</span><br>MSH_CMD_EXPORT(event_sample, event sample);<br></code></pre></td></tr></table></figure><p>仿真运行结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"> \ | /<br>- RT -     Thread Operating System<br> / | \     <span class="hljs-number">3.1</span><span class="hljs-number">.0</span> build Aug <span class="hljs-number">24</span> <span class="hljs-number">2018</span><br> <span class="hljs-number">2006</span> - <span class="hljs-number">2018</span> Copyright by rt-thread team<br>msh &gt;event_sample<br>thread2: send event3<br>thread1: OR recv event <span class="hljs-number">0x8</span><br>thread1: delay <span class="hljs-number">1</span>s to prepare the second event<br>msh &gt;thread2: send event5<br>thread2: send event3<br>thread2 leave.<br>thread1: AND recv event <span class="hljs-number">0x28</span><br>thread1 leave.<br></code></pre></td></tr></table></figure><h2 id="笔记-2"><a href="#笔记-2" class="headerlink" title="笔记"></a>笔记</h2><p>Semaphore:值、数值</p><p>Mutex:二值性、只能持有进程释放</p><p>Event:32Bit、进行’’或’’和’’与’’操作</p><ul><li>在获得互斥量后，请尽快释放互斥量，并且在持有互斥量的过程中，不得再行更改持有互斥量线程的优先级。</li><li>互斥量不能在中断服务例程中使用。</li></ul><h1 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h1><h2 id="邮箱Mailbox"><a href="#邮箱Mailbox" class="headerlink" title="邮箱Mailbox"></a>邮箱Mailbox</h2><p>邮箱用于线程间通信，特点是开销比较低，效率较高。邮箱中的每一封邮件只能容纳固定的 4 字节内容（针对 32 位处理系统，指针的大小即为 4 个字节，所以一封邮件恰好能够容纳一个指针）。</p><p>如下图所示，线程或中断服务例程把一封 4 字节长度的邮件发送到邮箱中，而一个或多个线程可以从邮箱中接收这些邮件并进行处理。</p><p><img src="/2021/42e53028/07mb_work.png" alt="邮箱工作示意图"></p><h3 id="邮箱API"><a href="#邮箱API" class="headerlink" title="邮箱API"></a>邮箱API</h3><p><img src="/2021/42e53028/07mb_ops.png" alt="邮箱相关接口"></p><h3 id="创建和删除邮箱-create"><a href="#创建和删除邮箱-create" class="headerlink" title="创建和删除邮箱-create"></a>创建和删除邮箱-create</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_mailbox_t</span> <span class="hljs-title function_">rt_mb_create</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">rt_size_t</span> size, <span class="hljs-type">rt_uint8_t</span> flag)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>name</td><td>邮箱名称</td></tr><tr><td>size</td><td>邮箱容量</td></tr><tr><td>flag</td><td>邮箱标志，它可以取如下数值： RT_IPC_FLAG_FIFO 或 RT_IPC_FLAG_PRIO</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_NULL</td><td>创建失败</td></tr><tr><td>邮箱对象的句柄</td><td>创建成功</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mb_delete</span> <span class="hljs-params">(<span class="hljs-type">rt_mailbox_t</span> mb)</span>;<br></code></pre></td></tr></table></figure><p>删除邮箱时，如果有线程被挂起在该邮箱对象上，内核先唤醒挂起在该邮箱上的所有线程（线程返回值是 - RT_ERROR），然后再释放邮箱使用的内存，最后删除邮箱对象。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mb</td><td>邮箱对象的句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr></tbody></table><h3 id="初始化和脱离邮箱-init"><a href="#初始化和脱离邮箱-init" class="headerlink" title="初始化和脱离邮箱-init"></a>初始化和脱离邮箱-init</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mb_init</span><span class="hljs-params">(<span class="hljs-type">rt_mailbox_t</span> mb,</span><br><span class="hljs-params">                  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name,</span><br><span class="hljs-params">                  <span class="hljs-type">void</span>* msgpool,</span><br><span class="hljs-params">                  <span class="hljs-type">rt_size_t</span> size,</span><br><span class="hljs-params">                  <span class="hljs-type">rt_uint8_t</span> flag)</span><br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mb</td><td>邮箱对象的句柄</td></tr><tr><td>name</td><td>邮箱名称</td></tr><tr><td>msgpool</td><td>缓冲区指针</td></tr><tr><td>size</td><td>邮箱容量</td></tr><tr><td>flag</td><td>邮箱标志，它可以取如下数值： RT_IPC_FLAG_FIFO 或 RT_IPC_FLAG_PRIO</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr></tbody></table><p>即如果 msgpool 指向的缓冲区的字节数是 N，那么邮箱容量应该是 N&#x2F;4。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mb_detach</span><span class="hljs-params">(<span class="hljs-type">rt_mailbox_t</span> mb)</span>;<br></code></pre></td></tr></table></figure><p>使用该函数接口后，内核先唤醒所有挂在该邮箱上的线程（线程获得返回值是 - RT_ERROR），然后将该邮箱对象从内核对象管理器中脱离。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mb</td><td>邮箱对象的句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr></tbody></table><h3 id="发送邮件-send"><a href="#发送邮件-send" class="headerlink" title="发送邮件-send"></a>发送邮件-send</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mb_send</span> <span class="hljs-params">(<span class="hljs-type">rt_mailbox_t</span> mb, <span class="hljs-type">rt_uint32_t</span> value)</span>;<br></code></pre></td></tr></table></figure><p>发送的邮件可以是 32 位任意格式的数据，一个整型值或者一个指向缓冲区的指针。当邮箱中的邮件已经满时，发送邮件的线程或者中断程序会收到 -RT_EFULL 的返回值。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mb</td><td>邮箱对象的句柄</td></tr><tr><td>value</td><td>邮件内容</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>发送成功</td></tr><tr><td>-RT_EFULL</td><td>邮箱已经满了</td></tr></tbody></table><h3 id="等待方式发送邮件-wait-send"><a href="#等待方式发送邮件-wait-send" class="headerlink" title="等待方式发送邮件-wait send"></a>等待方式发送邮件-wait send</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mb_send_wait</span> <span class="hljs-params">(<span class="hljs-type">rt_mailbox_t</span> mb,</span><br><span class="hljs-params">                      <span class="hljs-type">rt_uint32_t</span> value,</span><br><span class="hljs-params">                      <span class="hljs-type">rt_int32_t</span> timeout)</span>;<br></code></pre></td></tr></table></figure><p>rt_mb_send_wait() 与 rt_mb_send() 的区别在于有等待时间，如果邮箱已经满了，那么发送线程将根据设定的 timeout 参数等待邮箱中因为收取邮件而空出空间。如果设置的超时时间到达依然没有空出空间，这时发送线程将被唤醒并返回错误码。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mb</td><td>邮箱对象的句柄</td></tr><tr><td>value</td><td>邮件内容</td></tr><tr><td>timeout</td><td>超时时间</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>发送成功</td></tr><tr><td>-RT_ETIMEOUT</td><td>超时</td></tr><tr><td>-RT_ERROR</td><td>失败，返回错误</td></tr></tbody></table><h3 id="接收邮件-recv"><a href="#接收邮件-recv" class="headerlink" title="接收邮件-recv"></a>接收邮件-recv</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mb_recv</span> <span class="hljs-params">(<span class="hljs-type">rt_mailbox_t</span> mb, <span class="hljs-type">rt_uint32_t</span>* value, <span class="hljs-type">rt_int32_t</span> timeout)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mb</td><td>邮箱对象的句柄</td></tr><tr><td>value</td><td>邮件内容</td></tr><tr><td>timeout</td><td>超时时间</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>发送成功</td></tr><tr><td>-RT_ETIMEOUT</td><td>超时</td></tr><tr><td>-RT_ERROR</td><td>失败，返回错误</td></tr></tbody></table><h2 id="邮箱应用示例"><a href="#邮箱应用示例" class="headerlink" title="邮箱应用示例"></a>邮箱应用示例</h2><p>这是一个邮箱的应用例程，初始化 2 个静态线程，一个静态的邮箱对象，其中一个线程往邮箱中发送邮件，一个线程往邮箱中收取邮件。如下代码所示：</p><p>邮箱的使用例程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;rtthread.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_PRIORITY      10</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_TIMESLICE     5</span><br><br><span class="hljs-comment">/* 邮箱控制块 */</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_mailbox</span> <span class="hljs-title">mb</span>;</span><br><span class="hljs-comment">/* 用于放邮件的内存池 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">char</span> mb_pool[<span class="hljs-number">128</span>];<br><br><span class="hljs-type">static</span> <span class="hljs-type">char</span> mb_str1[] = <span class="hljs-string">&quot;I&#x27;m a mail!&quot;</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">char</span> mb_str2[] = <span class="hljs-string">&quot;this is another mail!&quot;</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">char</span> mb_str3[] = <span class="hljs-string">&quot;over&quot;</span>;<br><br>ALIGN(RT_ALIGN_SIZE)<br><span class="hljs-type">static</span> <span class="hljs-type">char</span> thread1_stack[<span class="hljs-number">1024</span>];<br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_thread</span> <span class="hljs-title">thread1</span>;</span><br><br><span class="hljs-comment">/* 线程 1 入口 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">thread1_entry</span><span class="hljs-params">(<span class="hljs-type">void</span> *parameter)</span><br>&#123;<br>    <span class="hljs-type">char</span> *str;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        rt_kprintf(<span class="hljs-string">&quot;thread1: try to recv a mail\n&quot;</span>);<br><br>        <span class="hljs-comment">/* 从邮箱中收取邮件 */</span><br>        <span class="hljs-keyword">if</span> (rt_mb_recv(&amp;mb, (<span class="hljs-type">rt_uint32_t</span> *)&amp;str, RT_WAITING_FOREVER) == RT_EOK)<br>        &#123;<br>            rt_kprintf(<span class="hljs-string">&quot;thread1: get a mail from mailbox, the content:%s\n&quot;</span>, str);<br>            <span class="hljs-keyword">if</span> (str == mb_str3)<br>                <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-comment">/* 延时 100ms */</span><br>            rt_thread_mdelay(<span class="hljs-number">100</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/* 执行邮箱对象脱离 */</span><br>    rt_mb_detach(&amp;mb);<br>&#125;<br><br>ALIGN(RT_ALIGN_SIZE)<br><span class="hljs-type">static</span> <span class="hljs-type">char</span> thread2_stack[<span class="hljs-number">1024</span>];<br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_thread</span> <span class="hljs-title">thread2</span>;</span><br><br><span class="hljs-comment">/* 线程 2 入口 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">thread2_entry</span><span class="hljs-params">(<span class="hljs-type">void</span> *parameter)</span><br>&#123;<br>    <span class="hljs-type">rt_uint8_t</span> count;<br><br>    count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (count &lt; <span class="hljs-number">10</span>)<br>    &#123;<br>        count ++;<br>        <span class="hljs-keyword">if</span> (count &amp; <span class="hljs-number">0x1</span>)<br>        &#123;<br>            <span class="hljs-comment">/* 发送 mb_str1 地址到邮箱中 */</span><br>            rt_mb_send(&amp;mb, (<span class="hljs-type">rt_uint32_t</span>)&amp;mb_str1);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">/* 发送 mb_str2 地址到邮箱中 */</span><br>            rt_mb_send(&amp;mb, (<span class="hljs-type">rt_uint32_t</span>)&amp;mb_str2);<br>        &#125;<br><br>        <span class="hljs-comment">/* 延时 200ms */</span><br>        rt_thread_mdelay(<span class="hljs-number">200</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* 发送邮件告诉线程 1，线程 2 已经运行结束 */</span><br>    rt_mb_send(&amp;mb, (<span class="hljs-type">rt_uint32_t</span>)&amp;mb_str3);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">mailbox_sample</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">rt_err_t</span> result;<br><br>    <span class="hljs-comment">/* 初始化一个 mailbox */</span><br>    result = rt_mb_init(&amp;mb,<br>                        <span class="hljs-string">&quot;mbt&quot;</span>,                      <span class="hljs-comment">/* 名称是 mbt */</span><br>                        &amp;mb_pool[<span class="hljs-number">0</span>],                <span class="hljs-comment">/* 邮箱用到的内存池是 mb_pool */</span><br>                        <span class="hljs-keyword">sizeof</span>(mb_pool) / <span class="hljs-number">4</span>,        <span class="hljs-comment">/* 邮箱中的邮件数目，因为一封邮件占 4 字节 */</span><br>                        RT_IPC_FLAG_FIFO);          <span class="hljs-comment">/* 采用 FIFO 方式进行线程等待 */</span><br>    <span class="hljs-keyword">if</span> (result != RT_EOK)<br>    &#123;<br>        rt_kprintf(<span class="hljs-string">&quot;init mailbox failed.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    rt_thread_init(&amp;thread1,<br>                   <span class="hljs-string">&quot;thread1&quot;</span>,<br>                   thread1_entry,<br>                   RT_NULL,<br>                   &amp;thread1_stack[<span class="hljs-number">0</span>],<br>                   <span class="hljs-keyword">sizeof</span>(thread1_stack),<br>                   THREAD_PRIORITY, THREAD_TIMESLICE);<br>    rt_thread_startup(&amp;thread1);<br><br>    rt_thread_init(&amp;thread2,<br>                   <span class="hljs-string">&quot;thread2&quot;</span>,<br>                   thread2_entry,<br>                   RT_NULL,<br>                   &amp;thread2_stack[<span class="hljs-number">0</span>],<br>                   <span class="hljs-keyword">sizeof</span>(thread2_stack),<br>                   THREAD_PRIORITY, THREAD_TIMESLICE);<br>    rt_thread_startup(&amp;thread2);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 导出到 msh 命令列表中 */</span><br>MSH_CMD_EXPORT(mailbox_sample, mailbox sample);<br></code></pre></td></tr></table></figure><p>仿真运行结果如下：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"> \ | /<br>- RT -     Thread Operating System<br> / | \     <span class="hljs-number">3.1</span>.<span class="hljs-number">0</span> build Aug <span class="hljs-number">27</span> <span class="hljs-number">2018</span><br> <span class="hljs-number">2006</span> - <span class="hljs-number">2018</span> Copyright <span class="hljs-keyword">by</span> rt-thread team<br>msh &gt;mailbox_sample<br><span class="hljs-symbol">thread1:</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">to</span> recv a mail<br><span class="hljs-symbol">thread1:</span> <span class="hljs-keyword">get</span> a mail <span class="hljs-keyword">from</span> mailbox, the content:I<span class="hljs-comment">&#x27;m a mail!</span><br>msh &gt;thread1: <span class="hljs-keyword">try</span> <span class="hljs-keyword">to</span> recv a mail<br><span class="hljs-symbol">thread1:</span> <span class="hljs-keyword">get</span> a mail <span class="hljs-keyword">from</span> mailbox, the content:this <span class="hljs-built_in">is</span> another mail!<br>…<br><span class="hljs-symbol">thread1:</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">to</span> recv a mail<br><span class="hljs-symbol">thread1:</span> <span class="hljs-keyword">get</span> a mail <span class="hljs-keyword">from</span> mailbox, the content:this <span class="hljs-built_in">is</span> another mail!<br><span class="hljs-symbol">thread1:</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">to</span> recv a mail<br><span class="hljs-symbol">thread1:</span> <span class="hljs-keyword">get</span> a mail <span class="hljs-keyword">from</span> mailbox, the content:over<br></code></pre></td></tr></table></figure><h2 id="消息队列Messagequeue"><a href="#消息队列Messagequeue" class="headerlink" title="消息队列Messagequeue"></a>消息队列Messagequeue</h2><p>消息队列是另一种常用的线程间通讯方式，是邮箱的扩展(消息队列：不固定长度的消息)。可以应用在多种场合：线程间的消息交换、使用串口接收不定长数据等。</p><p>线程或中断服务例程可以将一条或多条消息放入消息队列中。同样，一个或多个线程也可以从消息队列中获得消息。当有多个消息发送到消息队列时，通常将先进入消息队列的消息先传给线程，也就是说，线程先得到的是最先进入消息队列的消息，即先进先出原则 (FIFO)。</p><ul><li>消息框含有消息头（用于链表连接）</li></ul><p><img src="/2021/42e53028/07msg_work.png" alt="消息队列工作示意图"></p><p>消息队列和邮箱的明显不同是消息的长度并不限定在 4 个字节以内；另外，消息队列也包括了一个发送紧急消息的函数接口。但是当创建的是一个所有消息的最大长度是 4 字节的消息队列时，消息队列对象将蜕化成邮箱。</p><h3 id="消息队列API"><a href="#消息队列API" class="headerlink" title="消息队列API"></a>消息队列API</h3><p><img src="/2021/42e53028/07msg_ops.png" alt="消息队列相关接口"></p><h3 id="创建和删除消息队列-create"><a href="#创建和删除消息队列-create" class="headerlink" title="创建和删除消息队列-create"></a>创建和删除消息队列-create</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_mq_t</span> <span class="hljs-title function_">rt_mq_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">rt_size_t</span> msg_size,</span><br><span class="hljs-params">            <span class="hljs-type">rt_size_t</span> max_msgs, <span class="hljs-type">rt_uint8_t</span> flag)</span>;<br></code></pre></td></tr></table></figure><p>消息队列内存的大小 &#x3D;[消息大小+消息头（用于链表连接）的大小]X消息队列最大个数</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>name</td><td>消息队列的名称</td></tr><tr><td>msg_size</td><td>消息队列中一条消息的最大长度，单位字节</td></tr><tr><td>max_msgs</td><td>消息队列的最大个数</td></tr><tr><td>flag</td><td>消息队列采用的等待方式，它可以取如下数值： RT_IPC_FLAG_FIFO 或 RT_IPC_FLAG_PRIO</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>发送成功</td></tr><tr><td>消息队列对象的句柄</td><td>成功</td></tr><tr><td>RT_NULL</td><td>失败</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mq_delete</span><span class="hljs-params">(<span class="hljs-type">rt_mq_t</span> mq)</span>;<br></code></pre></td></tr></table></figure><p>删除消息队列时，如果有线程被挂起在该消息队列等待队列上，则内核先唤醒挂起在该消息等待队列上的所有线程（线程返回值是 - RT_ERROR），然后再释放消息队列使用的内存，最后删除消息队列对象。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mq</td><td>消息队列对象的句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr></tbody></table><h3 id="初始化和脱离消息队列-init"><a href="#初始化和脱离消息队列-init" class="headerlink" title="初始化和脱离消息队列-init"></a>初始化和脱离消息队列-init</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mq_init</span><span class="hljs-params">(<span class="hljs-type">rt_mq_t</span> mq, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name,</span><br><span class="hljs-params">                        <span class="hljs-type">void</span> *msgpool, <span class="hljs-type">rt_size_t</span> msg_size,</span><br><span class="hljs-params">                        <span class="hljs-type">rt_size_t</span> pool_size, <span class="hljs-type">rt_uint8_t</span> flag)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mq</td><td>消息队列对象的句柄</td></tr><tr><td>name</td><td>消息队列的名称</td></tr><tr><td>msgpool</td><td>指向存放消息的缓冲区的指针</td></tr><tr><td>msg_size</td><td>消息队列中一条消息的最大长度，单位字节</td></tr><tr><td>pool_size</td><td>存放消息的缓冲区大小</td></tr><tr><td>flag</td><td>消息队列采用的等待方式，它可以取如下数值： RT_IPC_FLAG_FIFO 或 RT_IPC_FLAG_PRIO</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mq_detach</span><span class="hljs-params">(<span class="hljs-type">rt_mq_t</span> mq)</span>;<br></code></pre></td></tr></table></figure><p>使用该函数接口后，内核先唤醒所有挂在该消息等待队列对象上的线程（线程返回值是 -RT_ERROR），然后将该消息队列对象从内核对象管理器中脱离。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mq</td><td>消息队列对象的句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr></tbody></table><h3 id="发送消息-send"><a href="#发送消息-send" class="headerlink" title="发送消息-send"></a>发送消息-send</h3><p><strong>线程</strong>或者<strong>中断服务程序</strong>都可以给消息队列发送消息。当发送消息时，消息队列对象先从空闲消息链表上取下一个空闲消息块，把线程或者中断服务程序发送的消息内容复制到消息块上，然后把该消息块挂到消息队列的尾部。当且仅当空闲消息链表上有可用的空闲消息块时，发送者才能成功发送消息；当空闲消息链表上无可用消息块，说明消息队列已满，此时，发送消息的的线程或者中断程序会收到一个错误码（-RT_EFULL）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mq_send</span> <span class="hljs-params">(<span class="hljs-type">rt_mq_t</span> mq, <span class="hljs-type">void</span>* buffer, <span class="hljs-type">rt_size_t</span> size)</span>;<br></code></pre></td></tr></table></figure><p>发送消息时，发送者需指定发送的消息队列的对象句柄（即指向消息队列控制块的指针），并且指定发送的消息内容以及消息大小。如下图所示，在发送一个普通消息之后，空闲消息链表上的队首消息被转移到了消息队列尾。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mq</td><td>消息队列对象的句柄</td></tr><tr><td>buffer</td><td>消息内容</td></tr><tr><td>size</td><td>消息大小</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr><tr><td>-RT_EFULL</td><td>消息队列已满</td></tr><tr><td>-RT_ERROR</td><td>失败，表示发送的消息长度大于消息队列中消息的最大长度</td></tr></tbody></table><h3 id="等待方式发送消息-wait"><a href="#等待方式发送消息-wait" class="headerlink" title="等待方式发送消息-wait"></a>等待方式发送消息-wait</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mq_send_wait</span><span class="hljs-params">(<span class="hljs-type">rt_mq_t</span>     mq,</span><br><span class="hljs-params">                         <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buffer,</span><br><span class="hljs-params">                         <span class="hljs-type">rt_size_t</span>   size,</span><br><span class="hljs-params">                         <span class="hljs-type">rt_int32_t</span>  timeout)</span>;<br></code></pre></td></tr></table></figure><p>rt_mq_send_wait() 与 rt_mq_send() 的区别在于有等待时间，如果消息队列已经满了，那么发送线程将根据设定的 timeout 参数进行等待。如果设置的超时时间到达依然没有空出空间，这时发送线程将被唤醒并返回错误码。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mq</td><td>消息队列对象的句柄</td></tr><tr><td>buffer</td><td>消息内容</td></tr><tr><td>size</td><td>消息大小</td></tr><tr><td>timeout</td><td>超时时间</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr><tr><td>-RT_EFULL</td><td>消息队列已满</td></tr><tr><td>-RT_ERROR</td><td>失败，表示发送的消息长度大于消息队列中消息的最大长度</td></tr></tbody></table><h3 id="发送紧急消息-urgent"><a href="#发送紧急消息-urgent" class="headerlink" title="发送紧急消息-urgent"></a>发送紧急消息-urgent</h3><p>发送紧急消息的过程与发送消息几乎一样，唯一的不同是，当发送紧急消息时，从空闲消息链表上取下来的消息块不是挂到消息队列的队尾，而是挂到队首，这样，接收者就能够优先接收到紧急消息，从而及时进行消息处理。发送紧急消息的函数接口如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mq_urgent</span><span class="hljs-params">(<span class="hljs-type">rt_mq_t</span> mq, <span class="hljs-type">void</span>* buffer, <span class="hljs-type">rt_size_t</span> size)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mq</td><td>消息队列对象的句柄</td></tr><tr><td>buffer</td><td>消息内容</td></tr><tr><td>size</td><td>消息大小</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr><tr><td>-RT_EFULL</td><td>消息队列已满</td></tr><tr><td>-RT_ERROR</td><td>失败</td></tr></tbody></table><h3 id="接收消息-recv"><a href="#接收消息-recv" class="headerlink" title="接收消息-recv"></a>接收消息-recv</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mq_recv</span> <span class="hljs-params">(<span class="hljs-type">rt_mq_t</span> mq, <span class="hljs-type">void</span>* buffer,</span><br><span class="hljs-params">                    <span class="hljs-type">rt_size_t</span> size, <span class="hljs-type">rt_int32_t</span> timeout)</span>;<br></code></pre></td></tr></table></figure><p>接收消息时，接收者需指定存储消息的消息队列对象句柄，并且指定一个内存缓冲区，接收到的消息内容将被复制到该缓冲区里。此外，还需指定未能及时取到消息时的超时时间。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mq</td><td>消息队列对象的句柄</td></tr><tr><td>buffer</td><td>消息内容</td></tr><tr><td>size</td><td>消息大小</td></tr><tr><td>timeout</td><td>指定的超时时间</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功收到</td></tr><tr><td>-RT_ETIMEOUT</td><td>超时</td></tr><tr><td>-RT_ERROR</td><td>失败，返回错误</td></tr></tbody></table><h2 id="消息队列应用示例"><a href="#消息队列应用示例" class="headerlink" title="消息队列应用示例"></a>消息队列应用示例</h2><p>这是一个消息队列的应用例程，例程中初始化了 2 个静态线程，一个线程会从消息队列中收取消息；另一个线程会定时给消息队列发送普通消息和紧急消息，如下代码所示：</p><p>消息队列的使用例程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;rtthread.h&gt;</span></span><br><br><span class="hljs-comment">/* 消息队列控制块 */</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_messagequeue</span> <span class="hljs-title">mq</span>;</span><br><span class="hljs-comment">/* 消息队列中用到的放置消息的内存池 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">rt_uint8_t</span> msg_pool[<span class="hljs-number">2048</span>];<br><br>ALIGN(RT_ALIGN_SIZE)<br><span class="hljs-type">static</span> <span class="hljs-type">char</span> thread1_stack[<span class="hljs-number">1024</span>];<br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_thread</span> <span class="hljs-title">thread1</span>;</span><br><span class="hljs-comment">/* 线程 1 入口函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">thread1_entry</span><span class="hljs-params">(<span class="hljs-type">void</span> *parameter)</span><br>&#123;<br>    <span class="hljs-type">char</span> buf = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">rt_uint8_t</span> cnt = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">/* 从消息队列中接收消息 */</span><br>        <span class="hljs-keyword">if</span> (rt_mq_recv(&amp;mq, &amp;buf, <span class="hljs-keyword">sizeof</span>(buf), RT_WAITING_FOREVER) == RT_EOK)<br>        &#123;<br>            rt_kprintf(<span class="hljs-string">&quot;thread1: recv msg from msg queue, the content:%c\n&quot;</span>, buf);<br>            <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">19</span>)<br>            &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">/* 延时 50ms */</span><br>        cnt++;<br>        rt_thread_mdelay(<span class="hljs-number">50</span>);<br>    &#125;<br>    rt_kprintf(<span class="hljs-string">&quot;thread1: detach mq \n&quot;</span>);<br>    rt_mq_detach(&amp;mq);<br>&#125;<br><br>ALIGN(RT_ALIGN_SIZE)<br><span class="hljs-type">static</span> <span class="hljs-type">char</span> thread2_stack[<span class="hljs-number">1024</span>];<br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_thread</span> <span class="hljs-title">thread2</span>;</span><br><span class="hljs-comment">/* 线程 2 入口 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">thread2_entry</span><span class="hljs-params">(<span class="hljs-type">void</span> *parameter)</span><br>&#123;<br>    <span class="hljs-type">int</span> result;<br>    <span class="hljs-type">char</span> buf = <span class="hljs-string">&#x27;A&#x27;</span>;<br>    <span class="hljs-type">rt_uint8_t</span> cnt = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">8</span>)<br>        &#123;<br>            <span class="hljs-comment">/* 发送紧急消息到消息队列中 */</span><br>            result = rt_mq_urgent(&amp;mq, &amp;buf, <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (result != RT_EOK)<br>            &#123;<br>                rt_kprintf(<span class="hljs-string">&quot;rt_mq_urgent ERR\n&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                rt_kprintf(<span class="hljs-string">&quot;thread2: send urgent message - %c\n&quot;</span>, buf);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cnt&gt;= <span class="hljs-number">20</span>)<span class="hljs-comment">/* 发送 20 次消息之后退出 */</span><br>        &#123;<br>            rt_kprintf(<span class="hljs-string">&quot;message queue stop send, thread2 quit\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">/* 发送消息到消息队列中 */</span><br>            result = rt_mq_send(&amp;mq, &amp;buf, <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (result != RT_EOK)<br>            &#123;<br>                rt_kprintf(<span class="hljs-string">&quot;rt_mq_send ERR\n&quot;</span>);<br>            &#125;<br><br>            rt_kprintf(<span class="hljs-string">&quot;thread2: send message - %c\n&quot;</span>, buf);<br>        &#125;<br>        buf++;<br>        cnt++;<br>        <span class="hljs-comment">/* 延时 5ms */</span><br>        rt_thread_mdelay(<span class="hljs-number">5</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* 消息队列示例的初始化 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">msgq_sample</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">rt_err_t</span> result;<br><br>    <span class="hljs-comment">/* 初始化消息队列 */</span><br>    result = rt_mq_init(&amp;mq,<br>                        <span class="hljs-string">&quot;mqt&quot;</span>,<br>                        &amp;msg_pool[<span class="hljs-number">0</span>],             <span class="hljs-comment">/* 内存池指向 msg_pool */</span><br>                        <span class="hljs-number">1</span>,                          <span class="hljs-comment">/* 每个消息的大小是 1 字节 */</span><br>                        <span class="hljs-keyword">sizeof</span>(msg_pool),        <span class="hljs-comment">/* 内存池的大小是 msg_pool 的大小 */</span><br>                        RT_IPC_FLAG_FIFO);       <span class="hljs-comment">/* 如果有多个线程等待，按照先来先得到的方法分配消息 */</span><br><br>    <span class="hljs-keyword">if</span> (result != RT_EOK)<br>    &#123;<br>        rt_kprintf(<span class="hljs-string">&quot;init message queue failed.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    rt_thread_init(&amp;thread1,<br>                   <span class="hljs-string">&quot;thread1&quot;</span>,<br>                   thread1_entry,<br>                   RT_NULL,<br>                   &amp;thread1_stack[<span class="hljs-number">0</span>],<br>                   <span class="hljs-keyword">sizeof</span>(thread1_stack), <span class="hljs-number">25</span>, <span class="hljs-number">5</span>);<br>    rt_thread_startup(&amp;thread1);<br><br>    rt_thread_init(&amp;thread2,<br>                   <span class="hljs-string">&quot;thread2&quot;</span>,<br>                   thread2_entry,<br>                   RT_NULL,<br>                   &amp;thread2_stack[<span class="hljs-number">0</span>],<br>                   <span class="hljs-keyword">sizeof</span>(thread2_stack), <span class="hljs-number">25</span>, <span class="hljs-number">5</span>);<br>    rt_thread_startup(&amp;thread2);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 导出到 msh 命令列表中 */</span><br>MSH_CMD_EXPORT(msgq_sample, msgq sample);<br></code></pre></td></tr></table></figure><p>仿真运行结果如下：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">\ | /<br>- RT -     Thread Operating System<br> / | \     <span class="hljs-number">3.1</span>.<span class="hljs-number">0</span> build Aug <span class="hljs-number">24</span> <span class="hljs-number">2018</span><br> <span class="hljs-number">2006</span> - <span class="hljs-number">2018</span> Copyright <span class="hljs-keyword">by</span> rt-thread team<br>msh &gt; msgq_sample<br>msh &gt;thread2: send message - A<br><span class="hljs-symbol">thread1:</span> recv msg <span class="hljs-keyword">from</span> msg queue, the content:A<br><span class="hljs-symbol">thread2:</span> send message - B<br><span class="hljs-symbol">thread2:</span> send message - C<br><span class="hljs-symbol">thread2:</span> send message - D<br><span class="hljs-symbol">thread2:</span> send message - E<br><span class="hljs-symbol">thread1:</span> recv msg <span class="hljs-keyword">from</span> msg queue, the content:B<br><span class="hljs-symbol">thread2:</span> send message - F<br><span class="hljs-symbol">thread2:</span> send message - G<br><span class="hljs-symbol">thread2:</span> send message - H<br><span class="hljs-symbol">thread2:</span> send urgent message - I<br><span class="hljs-symbol">thread2:</span> send message - J<br><span class="hljs-symbol">thread1:</span> recv msg <span class="hljs-keyword">from</span> msg queue, the content:I<br><span class="hljs-symbol">thread2:</span> send message - K<br><span class="hljs-symbol">thread2:</span> send message - L<br><span class="hljs-symbol">thread2:</span> send message - M<br><span class="hljs-symbol">thread2:</span> send message - N<br><span class="hljs-symbol">thread2:</span> send message - O<br><span class="hljs-symbol">thread1:</span> recv msg <span class="hljs-keyword">from</span> msg queue, the content:C<br><span class="hljs-symbol">thread2:</span> send message - P<br><span class="hljs-symbol">thread2:</span> send message - Q<br><span class="hljs-symbol">thread2:</span> send message - R<br><span class="hljs-symbol">thread2:</span> send message - S<br><span class="hljs-symbol">thread2:</span> send message - T<br><span class="hljs-symbol">thread1:</span> recv msg <span class="hljs-keyword">from</span> msg queue, the content:D<br>message queue <span class="hljs-keyword">stop</span> send, thread2 quit<br><span class="hljs-symbol">thread1:</span> recv msg <span class="hljs-keyword">from</span> msg queue, the content:E<br><span class="hljs-symbol">thread1:</span> recv msg <span class="hljs-keyword">from</span> msg queue, the content:F<br><span class="hljs-symbol">thread1:</span> recv msg <span class="hljs-keyword">from</span> msg queue, the content:G<br>…<br><span class="hljs-symbol">thread1:</span> recv msg <span class="hljs-keyword">from</span> msg queue, the content:T<br><span class="hljs-symbol">thread1:</span> detach mq<br></code></pre></td></tr></table></figure><h2 id="信号Signal"><a href="#信号Signal" class="headerlink" title="信号Signal"></a>信号Signal</h2><p>信号（又称为软中断信号），在软件层次上是对中断机制的一种模拟，在原理上，一个线程收到一个信号与处理器收到一个中断请求可以说是类似的。</p><p>应用程序(用户)能够使用的信号为 SIGUSR1（10）和 SIGUSR2（12）。</p><p>信号本质是<strong>软中断</strong>，用来通知线程发生了异步事件，用做线程之间的异常通知、应急处理。一个线程不必通过任何操作来等待信号的到达，事实上，线程也不知道信号到底什么时候到达，线程之间可以互相通过调用 rt_thread_kill() 发送软中断信号。</p><p>收到信号的线程对各种信号有不同的处理方法，在信号安装时设定 handler 参数，处理方法可以分为三类：</p><ul><li><p>第一种是类似中断的处理程序，对于需要处理的信号，线程可以指定处理函数，由该函数来处理。</p></li><li><p>第二种方法是，参数设为 SIG_IGN，忽略某个信号，对该信号不做任何处理，就像未发生过一样。 </p></li><li><p>第三种方法是，参数设为 SIG_DFL，系统会调用默认的处理函数_signal_default_handler()。</p></li></ul><p>如下图所示，假设线程 1 需要对信号进行处理，首先线程 1 安装一个信号并解除阻塞，并在安装的同时设定了对信号的异常处理方式；然后其他线程可以给线程 1 发送信号，触发线程 1 对该信号的处理。</p><p>当信号被传递给线程 1 时，如果它正处于挂起状态，那会把状态改为就绪状态去处理对应的信号。如果它正处于运行状态，那么会在它当前的线程栈基础上建立新栈帧空间去处理对应的信号，需要注意的是使用的线程栈大小也会相应增加。</p><p><img src="/2021/42e53028/07signal_work.png" alt="信号工作机制"></p><h3 id="信号API"><a href="#信号API" class="headerlink" title="信号API"></a>信号API</h3><p><img src="/2021/42e53028/07signal_ops.png" alt="信号相关接口"></p><h3 id="安装信号-install"><a href="#安装信号-install" class="headerlink" title="安装信号-install"></a>安装信号-install</h3><p>如果线程要处理某一信号，那么就要在线程中安装该信号。安装信号主要用来确定信号值及线程针对该信号值的动作之间的映射关系，即线程将要处理哪个信号，该信号被传递给线程时，将执行何种操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_sighandler_t</span> <span class="hljs-title function_">rt_signal_install</span><span class="hljs-params">(<span class="hljs-type">int</span> signo, <span class="hljs-type">rt_sighandler_t</span>[] handler)</span>;<br></code></pre></td></tr></table></figure><p>其中 rt_sighandler_t 是定义信号处理函数的函数指针类型。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>signo</td><td>信号值（只有 SIGUSR1 和 SIGUSR2 是开放给用户使用的，下同）</td></tr><tr><td>handler</td><td>设置对信号值的处理方式 （函数指针）</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>SIG_ERR</td><td>错误的信号</td></tr><tr><td>安装信号前的 handler 值</td><td>成功</td></tr></tbody></table><h3 id="屏蔽信号-mask"><a href="#屏蔽信号-mask" class="headerlink" title="屏蔽信号-mask"></a>屏蔽信号-mask</h3><p>信号阻塞，也可以理解为屏蔽信号。如果该信号被阻塞，则该信号将不会递达给安装此信号的线程，也不会引发软中断处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">rt_signal_mask</span><span class="hljs-params">(<span class="hljs-type">int</span> signo)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>signo</td><td>信号值</td></tr></tbody></table><h3 id="解除信号屏蔽-unmask"><a href="#解除信号屏蔽-unmask" class="headerlink" title="解除信号屏蔽-unmask"></a>解除信号屏蔽-unmask</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">rt_signal_unmask</span><span class="hljs-params">(<span class="hljs-type">int</span> signo)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>signo</td><td>信号值</td></tr></tbody></table><h3 id="发送信号-kill"><a href="#发送信号-kill" class="headerlink" title="发送信号-kill"></a>发送信号-kill</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">rt_thread_kill</span><span class="hljs-params">(<span class="hljs-type">rt_thread_t</span> tid, <span class="hljs-type">int</span> sig)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>tid</td><td>接收信号的线程</td></tr><tr><td>sig</td><td>信号值</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>发送成功</td></tr><tr><td>-RT_EINVAL</td><td>参数错误</td></tr></tbody></table><h3 id="等待信号-wait"><a href="#等待信号-wait" class="headerlink" title="等待信号-wait"></a>等待信号-wait</h3><p>等待 set 信号的到来，如果没有等到这个信号，则将线程挂起，直到等到这个信号或者等待时间超过指定的超时时间 timeout。如果等到了该信号，则将指向该信号体的指针存入 si，如下是等待信号的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">rt_signal_wait</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">rt_sigset_t</span> *<span class="hljs-built_in">set</span>,</span><br><span class="hljs-params">                        <span class="hljs-type">rt_siginfo_t</span>[] *si, <span class="hljs-type">rt_int32_t</span> timeout)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>set</td><td>指定等待的信号</td></tr><tr><td>si</td><td>指向存储等到信号信息的指针</td></tr><tr><td>timeout</td><td>指定的等待时间</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>等到信号</td></tr><tr><td>-RT_ETIMEOUT</td><td>超时</td></tr><tr><td>-RT_EINVAL</td><td>参数错误</td></tr></tbody></table><h2 id="信号应用示例"><a href="#信号应用示例" class="headerlink" title="信号应用示例"></a>信号应用示例</h2><p>这是一个信号的应用例程，如下代码所示。此例程创建了 1 个线程，在安装信号时，信号处理方式设为自定义处理，定义的信号的处理函数为 thread1_signal_handler()。待此线程运行起来安装好信号之后，给此线程发送信号。此线程将接收到信号，并打印信息。</p><p>信号使用例程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;rtthread.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_PRIORITY         25</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_STACK_SIZE       512</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_TIMESLICE        5</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">rt_thread_t</span> tid1 = RT_NULL;<br><br><span class="hljs-comment">/* 线程 1 的信号处理函数 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">thread1_signal_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span><br>&#123;<br>    rt_kprintf(<span class="hljs-string">&quot;thread1 received signal %d\n&quot;</span>, sig);<br>&#125;<br><br><span class="hljs-comment">/* 线程 1 的入口函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">thread1_entry</span><span class="hljs-params">(<span class="hljs-type">void</span> *parameter)</span><br>&#123;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* 安装信号 */</span><br>    rt_signal_install(SIGUSR1, thread1_signal_handler);<br>    rt_signal_unmask(SIGUSR1);<br><br>    <span class="hljs-comment">/* 运行 10 次 */</span><br>    <span class="hljs-keyword">while</span> (cnt &lt; <span class="hljs-number">10</span>)<br>    &#123;<br>        <span class="hljs-comment">/* 线程 1 采用低优先级运行，一直打印计数值 */</span><br>        rt_kprintf(<span class="hljs-string">&quot;thread1 count : %d\n&quot;</span>, cnt);<br><br>        cnt++;<br>        rt_thread_mdelay(<span class="hljs-number">100</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* 信号示例的初始化 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">signal_sample</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/* 创建线程 1 */</span><br>    tid1 = rt_thread_create(<span class="hljs-string">&quot;thread1&quot;</span>,<br>                            thread1_entry, RT_NULL,<br>                            THREAD_STACK_SIZE,<br>                            THREAD_PRIORITY, THREAD_TIMESLICE);<br><br>    <span class="hljs-keyword">if</span> (tid1 != RT_NULL)<br>        rt_thread_startup(tid1);<br><br>    rt_thread_mdelay(<span class="hljs-number">300</span>);<br><br>    <span class="hljs-comment">/* 发送信号 SIGUSR1 给线程 1 */</span><br>    rt_thread_kill(tid1, SIGUSR1);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 导出到 msh 命令列表中 */</span><br>MSH_CMD_EXPORT(signal_sample, signal sample);<br></code></pre></td></tr></table></figure><p>仿真运行结果如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"> <span class="hljs-string">\</span> <span class="hljs-string">|</span> <span class="hljs-string">/</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">RT</span> <span class="hljs-bullet">-</span>     <span class="hljs-string">Thread</span> <span class="hljs-string">Operating</span> <span class="hljs-string">System</span><br> <span class="hljs-string">/</span> <span class="hljs-string">|</span> <span class="hljs-string">\</span>     <span class="hljs-number">3.1</span><span class="hljs-number">.0</span> <span class="hljs-string">build</span> <span class="hljs-string">Aug</span> <span class="hljs-number">24</span> <span class="hljs-number">2018</span><br> <span class="hljs-number">2006</span> <span class="hljs-bullet">-</span> <span class="hljs-number">2018 </span><span class="hljs-string">Copyright</span> <span class="hljs-string">by</span> <span class="hljs-string">rt-thread</span> <span class="hljs-string">team</span><br><span class="hljs-string">msh</span> <span class="hljs-string">&gt;signal_sample</span><br><span class="hljs-attr">thread1 count :</span> <span class="hljs-number">0</span><br><span class="hljs-attr">thread1 count :</span> <span class="hljs-number">1</span><br><span class="hljs-attr">thread1 count :</span> <span class="hljs-number">2</span><br><span class="hljs-string">msh</span> <span class="hljs-string">&gt;thread1</span> <span class="hljs-string">received</span> <span class="hljs-string">signal</span> <span class="hljs-number">10</span><br><span class="hljs-attr">thread1 count :</span> <span class="hljs-number">3</span><br><span class="hljs-attr">thread1 count :</span> <span class="hljs-number">4</span><br><span class="hljs-attr">thread1 count :</span> <span class="hljs-number">5</span><br><span class="hljs-attr">thread1 count :</span> <span class="hljs-number">6</span><br><span class="hljs-attr">thread1 count :</span> <span class="hljs-number">7</span><br><span class="hljs-attr">thread1 count :</span> <span class="hljs-number">8</span><br><span class="hljs-attr">thread1 count :</span> <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><h2 id="笔记-3"><a href="#笔记-3" class="headerlink" title="笔记"></a>笔记</h2><p>Mailbox:开销较小，4字节内容，</p><p>Message Queue:长度不固定、需要进行内存分配、</p><p>Signal:软件中断</p><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>RT-Thread 操作系统在内存管理上，根据上层应用及系统资源的不同，有针对性地提供了不同的内存分配管理算法。总体上可分为两类：内存堆管理与内存池管理，而内存堆管理又根据具体内存设备划分为三种情况：</p><ul><li><p>第一种是针对小内存块的分配管理（小内存管理算法）；</p></li><li><p>第二种是针对大内存块的分配管理（slab 管理算法）；</p></li><li><p>第三种是针对多内存堆的分配情况（memheap 管理算法）</p></li></ul><h2 id="内存堆Heap"><a href="#内存堆Heap" class="headerlink" title="内存堆Heap"></a>内存堆Heap</h2><p>RT-Thread 将 “ZI 段结尾处” 到内存尾部的空间用作内存堆。</p><p><img src="/2021/42e53028/08Memory_distribution.png" alt="RT-Thread 内存分布"></p><p>内存堆可以在当前资源满足的情况下，根据用户的需求分配任意大小的内存块。而当用户不需要再使用这些内存块时，又可以释放回堆中供其他应用分配使用。RT-Thread 系统为了满足不同的需求，提供了不同的内存管理算法，分别是<strong>小内存管理算法</strong>、<strong>Slab</strong> 管理算法和 <strong>memheap 管理算法</strong>。</p><p><strong>小内存管理算法</strong>主要针对系统资源比较少，一般用于小于 2MB 内存空间的系统；</p><p><strong>slab 内存管理算法</strong>则主要是在系统资源比较丰富时，提供了一种近似多内存池管理算法的快速算法。</p><p> <strong>memheap 管理算法</strong>。memheap 方法适用于系统存在多个内存堆的情况，它可以将多个内存 “粘贴” 在一起，形成一个大的内存堆，用户使用起来会非常方便。</p><h3 id="小内存管理算法"><a href="#小内存管理算法" class="headerlink" title="小内存管理算法"></a>小内存管理算法</h3><p><img src="/2021/42e53028/08smem_work.png" alt="小内存管理工作机制图"></p><p>每个内存块（不管是已分配的内存块还是空闲的内存块）都包含一个数据头，其中包括：</p><p><strong>1）magic</strong>：变数（或称为幻数），它会被初始化成 0x1ea0（即英文单词 heap），用于标记这个内存块是一个内存管理用的内存数据块；变数不仅仅用于标识这个数据块是一个内存管理用的内存数据块，实质也是一个内存保护字：如果这个区域被改写，那么也就意味着这块内存块被非法改写（正常情况下只有内存管理器才会去碰这块内存）。</p><p><strong>2）used</strong>：指示出当前内存块是否已经分配。</p><p><strong>内存管理的表现主要体现在内存的分配与释放上，小型内存管理算法可以用以下例子体现出来。</strong></p><p><strong>如下图所示的内存分配情况，空闲链表指针 lfree 初始指向 32 字节的内存块。当用户线程要再分配一个 64 字节的内存块时，但此 lfree 指针指向的内存块只有 32 字节并不能满足要求，内存管理器会继续寻找下一内存块，当找到再下一块内存块，128 字节时，它满足分配的要求。因为这个内存块比较大，分配器将把此内存块进行拆分，余下的内存块（52 字节）继续留在 lfree 链表中，如下图分配 64 字节后的链表结构所示。</strong></p><p><img src="/2021/42e53028/08smem_work3.png" alt="小内存管理算法链表结构示意图 2"></p><p>另外，在每次分配内存块前，都会留出 12 字节数据头用于 magic、used 信息及链表节点使用。返回给应用的地址实际上是这块内存块 12 字节以后的地址，前面的 12 字节数据头是用户永远不应该碰的部分（注：12 字节数据头长度会与系统对齐差异而有所不同）。</p><p>释放时则是相反的过程，但分配器会查看前后相邻的内存块是否空闲，如果空闲则合并成一个大的空闲内存块。</p><h3 id="Slab管理算法"><a href="#Slab管理算法" class="headerlink" title="Slab管理算法"></a>Slab管理算法</h3><p>slab 分配器会根据对象的大小分成多个区（zone），也可以看成每类对象有一个内存池，如下图所示：</p><p><img src="/2021/42e53028/08slab.png" alt="slab 内存分配结构图"></p><p>一个 zone 的大小在 32K 到 128K 字节之间，分配器会在堆初始化时根据堆的大小自动调整。系统中的 zone 最多包括 72 种对象，一次最大能够分配 16K 的内存空间，如果超出了 16K 那么直接从页分配器中分配。每个 zone 上分配的内存块大小是固定的，能够分配相同大小内存块的 zone 会链接在一个链表中，而 72 种对象的 zone 链表则放在一个数组（zone_array[]）中统一管理。</p><p><strong>（1）内存分配</strong></p><p>假设分配一个 32 字节的内存，slab 内存分配器会先按照 32 字节的值，从 zone array 链表表头数组中找到相应的 zone 链表。如果这个链表是空的，则向页分配器分配一个新的 zone，然后从 zone 中返回第一个空闲内存块。如果链表非空，则这个 zone 链表中的第一个 zone 节点必然有空闲块存在（否则它就不应该放在这个链表中），那么就取相应的空闲块。如果分配完成后，zone 中所有空闲内存块都使用完毕，那么分配器需要把这个 zone 节点从链表中删除。</p><p><strong>（2）内存释放</strong></p><p>分配器需要找到内存块所在的 zone 节点，然后把内存块链接到 zone 的空闲内存块链表中。如果此时 zone 的空闲链表指示出 zone 的所有内存块都已经释放，即 zone 是完全空闲的，那么当 zone 链表中全空闲 zone 达到一定数目后，系统就会把这个全空闲的 zone 释放到页面分配器中去。</p><h3 id="Memheap管理算法"><a href="#Memheap管理算法" class="headerlink" title="Memheap管理算法"></a>Memheap管理算法</h3><p> memheap 功能就可以很方便地把多个 memheap（地址可不连续）粘合起来用于系统的 heap 分配。</p><p>memheap 工作机制如下图所示，首先将多块内存加入 memheap_item 链表进行粘合。当分配内存块时，会先从默认内存堆去分配内存，当分配不到时会查找 memheap_item 链表，尝试从其他的内存堆上分配内存块。应用程序不用关心当前分配的内存块位于哪个内存堆上，就像是在操作一个内存堆。</p><p><img src="/2021/42e53028/08memheap.png" alt="memheap 处理多内存堆"></p><h2 id="内存池Pool"><a href="#内存池Pool" class="headerlink" title="内存池Pool"></a>内存池Pool</h2><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>创建&#x2F;初始化</td><td>rt_mp_create()&#x2F;rt_mp_init()</td></tr><tr><td>分配内存块</td><td>rt_mp_alloc()</td></tr><tr><td>释放内存块</td><td>rt_mp_free()</td></tr><tr><td>删除&#x2F;脱离</td><td>rt_mp_delete()&#x2F;rt_mp_detach()</td></tr></tbody></table><h3 id="创建-删除-create"><a href="#创建-删除-create" class="headerlink" title="创建&#x2F;删除-create"></a>创建&#x2F;删除-create</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_mp_t</span> <span class="hljs-title function_">rt_mp_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name,</span><br><span class="hljs-params">                         <span class="hljs-type">rt_size_t</span> block_count,</span><br><span class="hljs-params">                         <span class="hljs-type">rt_size_t</span> block_size)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>name</td><td>内存池名</td></tr><tr><td>block_count</td><td>内存块数量</td></tr><tr><td>block_size</td><td>内存块容量</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>内存池的句柄</td><td>创建内存池对象成功</td></tr><tr><td>RT_NULL</td><td>创建失败</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mp_delete</span><span class="hljs-params">(<span class="hljs-type">rt_mp_t</span> mp)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mp</td><td>rt_mp_create 返回的内存池对象句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>删除成功</td></tr></tbody></table><h3 id="初始化-剥离-init"><a href="#初始化-剥离-init" class="headerlink" title="初始化&#x2F;剥离-init"></a>初始化&#x2F;剥离-init</h3><p>内存池块个数 &#x3D; size &#x2F; (block_size + 4 链表指针大小)，计算结果取整数。</p><p>例如：内存池数据区总大小 size 设为 4096 字节，内存块大小 block_size 设为 80 字节；则申请的内存块个数为 4096&#x2F; (80+4)&#x3D; 48 个。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mp_init</span><span class="hljs-params">(<span class="hljs-type">rt_mp_t</span> mp,</span><br><span class="hljs-params">                        <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name,</span><br><span class="hljs-params">                        <span class="hljs-type">void</span> *start, <span class="hljs-type">rt_size_t</span> size,</span><br><span class="hljs-params">                        <span class="hljs-type">rt_size_t</span> block size)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mp</td><td>内存池对象</td></tr><tr><td>name</td><td>内存池名</td></tr><tr><td>start</td><td>内存池的起始位置</td></tr><tr><td>size</td><td>内存池数据区域大小</td></tr><tr><td>block_size</td><td>内存块容量</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>初始化成功</td></tr><tr><td>- RT_ERROR</td><td>失败</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mp_detach</span><span class="hljs-params">(<span class="hljs-type">rt_mp_t</span> mp)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mp</td><td>内存池对象</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr></tbody></table><h3 id="分配-alloc"><a href="#分配-alloc" class="headerlink" title="分配-alloc"></a>分配-alloc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">rt_mp_alloc</span> <span class="hljs-params">(<span class="hljs-type">rt_mp_t</span> mp, <span class="hljs-type">rt_int32_t</span> time)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mp</td><td>内存池对象</td></tr><tr><td>time</td><td>超时时间</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>分配的内存块地址</td><td>成功</td></tr><tr><td>RT_NULL</td><td>失败</td></tr></tbody></table><h3 id="释放-free"><a href="#释放-free" class="headerlink" title="释放-free"></a>释放-free</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">rt_mp_free</span> <span class="hljs-params">(<span class="hljs-type">void</span> *block)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>block</td><td>内存块指针</td></tr></tbody></table><h2 id="笔记-4"><a href="#笔记-4" class="headerlink" title="笔记"></a>笔记</h2><ul><li>因为内存堆管理器要满足多线程情况下的安全分配，会考虑多线程间的互斥问题，所以请不要在中断服务例程中分配或释放动态内存块。因为它可能会引起当前上下文被挂起等待。</li></ul><h1 id="RT-Thread的中断管理"><a href="#RT-Thread的中断管理" class="headerlink" title="RT-Thread的中断管理"></a>RT-Thread的中断管理</h1><h2 id="中断工作机制"><a href="#中断工作机制" class="headerlink" title="中断工作机制"></a>中断工作机制</h2><h3 id="中断处理过程"><a href="#中断处理过程" class="headerlink" title="中断处理过程"></a>中断处理过程</h3><p>RT-Thread 中断管理中，将中断处理程序分为中断前导程序、用户中断服务程序、中断后续程序三部分<br><img src="/2021/42e53028/09interrupt_work_process.png" alt="中断处理程序的 3 部分"></p><h4 id="中断前导"><a href="#中断前导" class="headerlink" title="中断前导"></a>中断前导</h4><ol><li><p>保存 CPU 中断现场，这部分跟 CPU 架构相关，不同 CPU 架构的实现方式有差异。</p><p>对于 Cortex-M 来说，该工作由硬件自动完成。当一个中断触发并且系统进行响应时，处理器硬件会将当前运行部分的上下文寄存器自动压入中断栈中，这部分的寄存器包括 PSR、PC、LR、R12、R3-R0 寄存器。</p></li><li><p>通知内核进入中断状态，调用 rt_interrupt_enter() 函数，作用是把全局变量 rt_interrupt_nest 加 1，用它来记录中断嵌套的层数，代码如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">rt_interrupt_enter</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">rt_base_t</span> level;<br><br>    level = rt_hw_interrupt_disable();<br>    rt_interrupt_nest ++;<br>    rt_hw_interrupt_enable(level);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h4><ol><li><p>中断完后<strong>不进行</strong>线程切换，这种情况下用户中断服务程序和中断后续程序运行完毕后退出中断模式，返回被中断的线程。</p></li><li><p>中断完后<strong>进行</strong>线程切换，这种情况会调用 rt_hw_context_switch_interrupt() 函数进行上下文切换，该函数跟 CPU 架构相关，不同 CPU 架构的实现方式有差异。</p><p>rt_hw_context_switch_interrupt() 函数会触发PendSV异常，PendSV 异常被触发后，不会立即进行 PendSV 异常中断处理程序，因为此时还在中断处理中，只有当中断后续程序运行完毕，真正退出中断处理后，才进入 PendSV 异常中断处理程序。</p></li></ol><h4 id="中断后续"><a href="#中断后续" class="headerlink" title="中断后续"></a>中断后续</h4><ol><li><p>通知内核离开中断状态，通过调用 rt_interrupt_leave() 函数，将全局变量 rt_interrupt_nest 减 1，代码如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">rt_interrupt_leave</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">rt_base_t</span> level;<br><br>    level = rt_hw_interrupt_disable();<br>    rt_interrupt_nest --;<br>    rt_hw_interrupt_enable(level);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>恢复中断前的 CPU 上下文，中断过程<strong>发生了线程切换</strong>和<strong>没发生线程切换</strong>的CPU上下文是不一样的。</p></li></ol><h3 id="中断嵌套"><a href="#中断嵌套" class="headerlink" title="中断嵌套"></a>中断嵌套</h3><p>如果需要进行线程调度，线程的上下文切换将在所有中断处理程序都运行结束时才发生，如下图所示。</p><p><img src="/2021/42e53028/09ths_switch.png" alt="中断中的线程切换"></p><h3 id="中断栈"><a href="#中断栈" class="headerlink" title="中断栈"></a>中断栈</h3><ol><li>中断栈可以保存在打断线程的栈中，当从中断中退出时，返回相应的线程继续执行。</li><li>中断栈也可以与线程栈完全分离开来，即每次进入中断时，在保存完打断线程上下文后，切换到新的中断栈中独立运行。在中断退出时，再做相应的上下文恢复。</li></ol><p>使用独立中断栈相对来说更容易实现，并且对于线程栈使用情况也比较容易了解和掌握（否则必须要为中断栈预留空间，如果系统支持中断嵌套，还需要考虑应该为嵌套中断预留多大的空间）。</p><h3 id="中断的底半处理"><a href="#中断的底半处理" class="headerlink" title="中断的底半处理"></a>中断的底半处理</h3><p>发生中断后，中断一般读取硬件状态或者数据，然后发送一个通知（信号量、事件、邮箱、消息队列等），接下来的相关线程收到通知对着数据进行进一步处理，这个处理的过程就叫<strong>底半处理</strong>。</p><blockquote><p>当一个中断发生时，中断服务程序需要取得相应的硬件状态或者数据。如果中断服务程序接下来要对状态或者数据进行简单处理，比如 CPU 时钟中断，中断服务程序只需对一个系统时钟变量进行加一操作，然后就结束中断服务程序。这类中断需要的运行时间往往都比较短。但对于另外一些中断，中断服务程序在取得硬件状态或数据以后，还需要进行一系列更耗时的处理过程，通常需要将该中断分割为两部分，即<strong>上半部分</strong>（Top Half）和<strong>底半部分</strong>（Bottom Half）。在上半部分中，取得硬件状态和数据后，打开被屏蔽的中断，给相关线程发送一条通知（可以是 RT-Thread 所提供的信号量、事件、邮箱或消息队列等方式），然后结束中断服务程序；而接下来，相关的线程在接收到通知后，接着对状态或数据进行进一步的处理，这一过程称之为<strong>底半处理</strong>。</p></blockquote><h2 id="中断管理API"><a href="#中断管理API" class="headerlink" title="中断管理API"></a>中断管理API</h2><p><img src="/2021/42e53028/09interrupt_ops.png" alt="中断相关接口"></p><p><strong>请注意！！！装载中断服务例程、中断源管理——的API 并不会出现在每一个移植分支中，例如通常 Cortex-M0&#x2F;M3&#x2F;M4 的移植分支中就没有这些 API。</strong></p><h3 id="装载中断服务例程"><a href="#装载中断服务例程" class="headerlink" title="装载中断服务例程"></a>装载中断服务例程</h3><p>系统把用户的中断服务程序 (handler) 和指定的中断号关联起来，可调用如下的接口挂载一个新的中断服务程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_isr_handler_t</span> <span class="hljs-title function_">rt_hw_interrupt_install</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-built_in">vector</span>,</span><br><span class="hljs-params">                                        <span class="hljs-type">rt_isr_handler_t</span>  handler,</span><br><span class="hljs-params">                                        <span class="hljs-type">void</span> *param,</span><br><span class="hljs-params">                                        <span class="hljs-type">char</span> *name)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>vector</td><td>vector 是挂载的中断号</td></tr><tr><td>handler</td><td>新挂载的中断服务程序</td></tr><tr><td>param</td><td>param 会作为参数传递给中断服务程序</td></tr><tr><td>name</td><td>中断的名称</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>return</td><td>挂载这个中断服务程序之前挂载的中断服务程序的句柄</td></tr></tbody></table><h3 id="中断源管理"><a href="#中断源管理" class="headerlink" title="中断源管理"></a>中断源管理</h3><ol><li>屏蔽中断源</li></ol><p>通常在 ISR 准备处理某个中断信号之前，我们需要先屏蔽该中断源，在 ISR 处理完状态或数据以后，及时的打开之前被屏蔽的中断源。</p><p>屏蔽中断源可以保证在接下来的处理过程中硬件状态或者数据不会受到干扰，可调用下面这个函数接口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">rt_hw_interrupt_mask</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-built_in">vector</span>)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>vector</td><td>要屏蔽的中断号</td></tr></tbody></table><ol start="2"><li>打开被屏蔽的中断源</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">rt_hw_interrupt_umask</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-built_in">vector</span>)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>vector</td><td>要打开屏蔽的中断号</td></tr></tbody></table><h3 id="全局中断开关"><a href="#全局中断开关" class="headerlink" title="全局中断开关"></a>全局中断开关</h3><p><strong>全局中断开关也称为</strong>中断锁，是禁止多线程访问临界区最简单的一种方式，即通过关闭中断的方式，来保证当前线程不会被其他事件打断（因为整个系统已经不再响应那些可以触发线程重新调度的外部事件），也就是当前线程不会被抢占，除非这个线程主动放弃了处理器控制权。</p><ol><li>失能全局中断</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_base_t</span> <span class="hljs-title function_">rt_hw_interrupt_disable</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>返回</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>中断状态</td><td>rt_hw_interrupt_disable 函数运行前的中断状态</td></tr><tr><td>2. 使能全局中断</td><td></td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">rt_hw_interrupt_enable</span><span class="hljs-params">(<span class="hljs-type">rt_base_t</span> level)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>level</td><td>前一次 rt_hw_interrupt_disable 返回的中断状态</td></tr></tbody></table><h3 id="中断通知"><a href="#中断通知" class="headerlink" title="中断通知"></a>中断通知</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">rt_interrupt_enter</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">rt_interrupt_leave</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><p>这两个接口分别用在中断前导程序和中断后续程序中，均会对 rt_interrupt_nest（中断嵌套深度）的值进行修改。</p><p>使用 rt_interrupt_enter&#x2F;leave() 的作用是，在中断中释放了一个信号量，唤醒了某线程，但通过判断发现当前系统处于中断上下文环境中，那么在进行线程切换时应该采取中断中线程切换的策略（等中断结束再切换），而不是立即进行切换（正常情况下立即进行切换）。</p><p><del>（不建议）但如果中断服务程序不会调用内核相关的函数（释放信号量等操作），这个时候，也可以不调用 rt_interrupt_enter&#x2F;leave() 函数。</del></p><p>在上层应用中，在内核需要知道当前已经进入到中断状态或当前<strong>嵌套的中断深度</strong>时，可调用 rt_interrupt_get_nest() 接口，它会返回 rt_interrupt_nest。如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_uint8_t</span> <span class="hljs-title function_">rt_interrupt_get_nest</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>返回</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>0</td><td>当前系统不处于中断上下文环境中</td></tr><tr><td>1</td><td>当前系统处于中断上下文环境中</td></tr><tr><td>大于 1</td><td>当前中断嵌套层次</td></tr></tbody></table><h2 id="中断与轮询"><a href="#中断与轮询" class="headerlink" title="中断与轮询"></a>中断与轮询</h2><p>当驱动外设工作时，其编程模式到底采用中断模式触发还是轮询模式触发往往是驱动开发人员首先要考虑的问题，并且这个问题在实时操作系统与分时操作系统中差异还非常大。</p><p>在实时系统中轮询模式可能会出现非常大问题，因为在实时操作系统中，当一个程序持续地执行时（轮询时），它所在的线程会一直运行，比它优先级低的线程都不会得到运行。而分时系统中，这点恰恰相反，几乎没有优先级之分，可以在一个时间片运行这个程序，然后在另外一段时间片上运行另外一段程序。</p><p>所以通常情况下，实时系统中更多采用的是中断模式来驱动外设。当数据达到时，由中断唤醒相关的处理线程，再继续进行后续的动作。例如一些携带 FIFO（包含一定数据量的先进先出队列）的串口外设，其写入过程可以是这样的，如下图所示：</p><p><img src="/2021/42e53028/09interrupt_reque.png" alt="中断模式驱动外设"></p><p><strong>对于低速设备来说，运用这种模式非常好，而对于高速设备，数据量又小的情况下，线程的切换时间（几个us）会很明显的影响数据吞吐量和带宽利用率。</strong></p><blockquote><p>发送数据量越小，发送速度越快，对于数据吞吐量的影响也将越大。归根结底，取决于系统中产生中断的频度如何。当一个实时系统想要提升数据吞吐量时，可以考虑的几种方式：</p><p>1）增加每次数据量发送的长度，每次尽量让外设尽量多地发送数据；</p><p>2）必要情况下更改中断模式为轮询模式。同时为了解决轮询方式一直抢占处理机，其他低优先级线程得不到运行的情况，可以把轮询线程的优先级适当降低。</p></blockquote><h1 id="内核移植"><a href="#内核移植" class="headerlink" title="内核移植"></a>内核移植</h1><p>参考官方文档</p><h2 id="CPU架构移植"><a href="#CPU架构移植" class="headerlink" title="CPU架构移植"></a>CPU架构移植</h2><h2 id="BSP移植"><a href="#BSP移植" class="headerlink" title="BSP移植"></a>BSP移植</h2><h1 id="线程切换"><a href="#线程切换" class="headerlink" title="线程切换"></a>线程切换</h1><p>cortex-m3中上下文切换统一是使用PendSV来实现的。</p>]]></content>
    
    
    <categories>
      
      <category>RTOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rtos</tag>
      
      <tag>rt-thread</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LinuxAlphaMini</title>
    <link href="/2021/9b4105ad/"/>
    <url>/2021/9b4105ad/</url>
    
    <content type="html"><![CDATA[<h1 id="Cortex-A7-MPCore架构"><a href="#Cortex-A7-MPCore架构" class="headerlink" title="Cortex-A7 MPCore架构"></a>Cortex-A7 MPCore架构</h1><h1 id="汇编基础"><a href="#汇编基础" class="headerlink" title="汇编基础"></a>汇编基础</h1><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">label： instruction @ comment <br></code></pre></td></tr></table></figure><p><strong>label 即标号</strong>，表示地址位置，有些指令前面可能会有标号，这样就可以通过这个标号得到指令的地址，标号也可以用来表示数据地址。注意 label 后面的“：”，任何以“：”结尾的标识符都会被识别为一个标号。<br><strong>instruction 即指令</strong>，也就是汇编指令或伪指令。<br><strong>@符号</strong>，表示后面的是注释<br><strong>comment</strong> 就是注释内容。</p><p>例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">add:<br>MOVS R0, #0X12 @设置 R0=0X12<br></code></pre></td></tr></table></figure><p><strong>注意！ ARM 中的指令、伪指令、伪操作、寄存器名等可以全部使用大写，也可以全部使用小写，但是不能大小写混用。</strong>  </p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">.section .testsection @定义一个 testsetcion 段 <br></code></pre></td></tr></table></figure><ul><li>.text 表示代码段。  </li><li>.data 初始化的数据段。</li><li>.bss 未初始化的数据段。</li><li>.rodata 只读数据段。</li></ul><p><strong>伪操作:</strong></p><ul><li>.byte 定义单字节数据，比如.byte 0x12。</li><li>.short 定义双字节数据，比如.short 0x1234。</li><li>.long 定义一个 4 字节数据，比如.long 0x12345678。</li><li>.equ 赋值语句，格式为： .equ 变量名，表达式，比如.equ num, 0x12，表示 num&#x3D;0x12。</li><li>.align 数据字节对齐，比如： .align 4 表示 4 字节对齐。</li><li>.end 表示源文件结束。</li><li>.global 定义一个全局符号，格式为： .global symbol，比如： .global _start(汇编程序的默认入口标号是_start  )。</li></ul><p><strong>函数:</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">函数名:<br> 函数体<br> 返回语句<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">/* SVC 中断 */<br>SVC_Handler:<br>    ldr r0, =SVC_Handler<br>    bx r0     @跳转<br></code></pre></td></tr></table></figure><h2 id="常用汇编指令"><a href="#常用汇编指令" class="headerlink" title="常用汇编指令"></a>常用汇编指令</h2><h3 id="处理器内部数据传输指令-mov-mrs-msr"><a href="#处理器内部数据传输指令-mov-mrs-msr" class="headerlink" title="处理器内部数据传输指令 mov mrs msr"></a>处理器内部数据传输指令 mov mrs msr</h3><table><thead><tr><th>指令</th><th>目的</th><th>源</th><th></th></tr></thead><tbody><tr><td>MOV</td><td>R0</td><td>R1</td><td>将 R1 里面的数据复制到 R0 中。</td></tr><tr><td>MRS</td><td>R0</td><td>CPSR</td><td>将特殊寄存器 CPSR 里面的数据复制到 R0 中。<br/><strong>(特殊寄存器只能由这个指令 读 )</strong></td></tr><tr><td>MSR</td><td>CPSR</td><td>R1</td><td>将 R1 里面的数据复制到特殊寄存器 CPSR 里中。<br/><strong>(特殊寄存器只能由这个指令 写 )</strong></td></tr></tbody></table><h3 id="存储器访问指令-ldr-str"><a href="#存储器访问指令-ldr-str" class="headerlink" title="存储器访问指令 ldr str"></a>存储器访问指令 ldr str</h3><p>I.MX6UL中的RAM,寄存器都需要这个指令访问。</p><p>LDR和STR是按照字进行读取和写入的，LDRB和STRB是按字节，LDRH和STRH是按半字操作。</p><table><thead><tr><th>指令</th><th></th></tr></thead><tbody><tr><td>LDR Rd, [Rn , #offset]</td><td>从存储器 Rn+offset 的位置读取数据存放到 Rd 中。</td></tr><tr><td>STR Rd, [Rn, #offset]</td><td>将 Rd 中的数据写入到存储器中的 Rn+offset 位置。</td></tr></tbody></table><h4 id="LDR"><a href="#LDR" class="headerlink" title="LDR"></a>LDR</h4><ul><li><p>读取寄存器值</p></li><li><p>加载立即数到寄存器</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">@加载立即数<br>LDR R0, =0X0209C004 @将寄存器地址 0X0209C004 加载到 R0 中，即 R0=0X0209C004<br>@读取寄存器值<br>LDR R1, [R0] @读取地址 0X0209C004 中的数据到 R1 寄存器中<br></code></pre></td></tr></table></figure><h4 id="STR"><a href="#STR" class="headerlink" title="STR"></a>STR</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">LDR R0, =0X0209C004 @将寄存器地址 0X0209C004 加载到 R0 中，即 R0=0X0209C004<br>LDR R1, =0X12345678 @R1 保存要写入到寄存器的值，即 R1=0X12345678<br>STR R1, [R0] @将 R1 中的值写入到 R0 中的地址上<br></code></pre></td></tr></table></figure><h3 id="压栈出栈指令-push-pop"><a href="#压栈出栈指令-push-pop" class="headerlink" title="压栈出栈指令 push pop"></a>压栈出栈指令 push pop</h3><table><thead><tr><th>指令</th><th></th></tr></thead><tbody><tr><td>PUSH &lt;reg list&gt;</td><td>将寄存器列表存入栈中。</td></tr><tr><td>POP &lt;reg list&gt;</td><td>从栈中恢复寄存器列表。</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asm">@处理器的堆栈是向下增长的 见下图<br>PUSH &#123;R0~R3, R12&#125; @将 R0~R3 和 R12 压栈<br>PUSH &#123;LR&#125; @将 LR 进行压栈<br><br>POP &#123;LR&#125; @先恢复 LR<br>POP &#123;R0~R3,R12&#125; @在恢复 R0~R3,R12<br></code></pre></td></tr></table></figure><p><img src="/2021/9b4105ad/image-20210707144653945.png" alt="image-20210707144653945"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs asm">@这个和上面的是等同的<br>STMFD SP!,&#123;R0~R3, R12&#125; @R0~R3,R12 入栈<br>STMFD SP!,&#123;LR&#125; @LR 入栈<br><br>LDMFD SP!, &#123;LR&#125; @先恢复 LR<br>LDMFD SP!, &#123;R0~R3, R12&#125; @再恢复 R0~R3, R12<br><br><br>LDMFD = LDM + FD<br>STMFD = STM + FD<br>LDM(多个) -&gt; LDR(单个)<br>STM(多个) -&gt; STR(单个)<br>FD = Full Descending 即满递减的意思(根据 ATPCS 规则,ARM 使用的 FD 类型的堆栈， SP 指向最后一个入栈的数值，堆栈是由高地址向下增长的，也就是前面说的向下增长的堆栈，)<br></code></pre></td></tr></table></figure><h3 id="跳转指令-b-bx-bl-blx"><a href="#跳转指令-b-bx-bl-blx" class="headerlink" title="跳转指令 b bx bl blx"></a>跳转指令 b bx bl blx</h3><p>跳转操作的方法  </p><ol><li>直接使用跳转指令 B、 BL、 BX 等</li><li>直接向 PC 寄存器里面写入数据。</li></ol><table><thead><tr><th>指令</th><th></th></tr></thead><tbody><tr><td>B &lt;label&gt;</td><td>跳转到 label，如果跳转范围超过了+&#x2F;-2KB，<br/>可以指定 B.W &lt;label&gt;使用 32 位版本的跳转指令， 这样可以得到较大范围的 跳转</td></tr><tr><td>BX &lt;Rm&gt;</td><td>间接跳转，跳转到存放于 Rm 中的地址处，并且切换指令集</td></tr><tr><td>BL &lt;label&gt;</td><td>跳转到标号地址，并将返回地址保存在 LR 中。</td></tr><tr><td>BLX &lt;Rm&gt;</td><td>结合 BX 和 BL 的特点，跳转到 Rm 指定的地址，并将返回地 址保存在 LR 中，切换指令集。</td></tr></tbody></table><h4 id="B指令"><a href="#B指令" class="headerlink" title="B指令"></a>B指令</h4><p>这是最简单的跳转指令， B 指令会将 PC 寄存器的值设置为跳转目标地址， 一旦执行 B 指令， ARM 处理器就会立即跳转到指定的目标地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">_start:<br>    ldr sp,=0X80200000 @设置栈指针<br>    b main @跳转到 main 函数<br></code></pre></td></tr></table></figure><p>上述代码就是典型的在汇编中初始化 C 运行环境，然后跳转到 C 文件的 main 函数中运行 ，上述代码只是初始化了 SP 指针，有些处理器还需要做其他的初始化，比如初始化 DDR 等等。因为跳转到 C 文件以后再也不会回到汇编了，所以在第 4 行使用了 B 指令来完成跳转  。</p><h4 id="BL指令"><a href="#BL指令" class="headerlink" title="BL指令"></a>BL指令</h4><p>BL 指令相比 B 指令，在跳转之前会在寄存器 LR(R14)中保存当前 PC 寄存器值，所以可以通过将 LR 寄存器中的值重新加载到 PC 中来继续从跳转之前的代码处运行，这是子程序调用一个基本但常用的手段。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asm">push &#123;r0, r1&#125; @保存 r0,r1<br>cps #0x13 @进入 SVC 模式，允许其他中断再次进去<br><br>bl system_irqhandler@加载 C 语言中断处理函数到 r2 寄存器中<br><br>cps #0x12 @进入 IRQ 模式<br>pop &#123;r0, r1&#125;<br>str r0, [r1, #0X10] @中断执行完成，写 EOIR<br></code></pre></td></tr></table></figure><p>上述代码中第 5 行就是执行 C 语言版的中断处理函数，当处理完成以后是需要返回来继续执行下面的程序，所以使用了 BL 指令。  </p><h3 id="算术运算指令"><a href="#算术运算指令" class="headerlink" title="算术运算指令"></a>算术运算指令</h3><p>汇编中也可以进行算术运算， 比如加减乘除，常用的运算指令用法如表 7.2.5.1 所示：</p><table><thead><tr><th>指令</th><th>计算公式</th><th></th></tr></thead><tbody><tr><td>ADD Rd, Rn, Rm</td><td>Rd &#x3D; Rn + Rm</td><td>加法运算，指令为 ADD</td></tr><tr><td>ADD Rd, Rn, #immed</td><td>Rd &#x3D; Rn + #immed</td><td>加法运算，指令为 ADD</td></tr><tr><td>ADC Rd, Rn, Rm</td><td>Rd &#x3D; Rn + Rm + 进位</td><td>带进位的加法运算，指令为 ADC</td></tr><tr><td>ADC Rd, Rn, #immed</td><td>Rd &#x3D; Rn + #immed +进位</td><td>带进位的加法运算，指令为 ADC</td></tr><tr><td>SUB Rd, Rn, Rm</td><td>Rd &#x3D; Rn – Rm</td><td>减法</td></tr><tr><td>SUB Rd, #immed</td><td>Rd &#x3D; Rd - #immed</td><td>减法</td></tr><tr><td>SUB Rd, Rn, #immed</td><td>Rd &#x3D; Rn - #immed</td><td>减法</td></tr><tr><td>SBC Rd, Rn, #immed</td><td>Rd &#x3D; Rn - #immed – 借位</td><td>带借位的减法</td></tr><tr><td>SBC Rd, Rn ,Rm</td><td>Rd &#x3D; Rn – Rm – 借位</td><td>带借位的减法</td></tr><tr><td>MUL Rd, Rn, Rm</td><td>Rd &#x3D; Rn * Rm</td><td>乘法(32 位)</td></tr><tr><td>UDIV Rd, Rn, Rm</td><td>Rd &#x3D; Rn &#x2F; Rm</td><td>无符号除法</td></tr><tr><td>SDIV Rd, Rn, Rm</td><td>Rd &#x3D; Rn &#x2F; Rm</td><td>有符号除法</td></tr></tbody></table><h3 id="逻辑运算指令"><a href="#逻辑运算指令" class="headerlink" title="逻辑运算指令"></a>逻辑运算指令</h3><table><thead><tr><th>指令</th><th>计算公式</th><th></th></tr></thead><tbody><tr><td>AND Rd, Rn</td><td>Rd &#x3D; Rd &amp;Rn</td><td>按位与</td></tr><tr><td>AND Rd, Rn, #immed</td><td>Rd &#x3D; Rn &amp;#immed</td><td>按位与</td></tr><tr><td>AND Rd, Rn, Rm</td><td>Rd &#x3D; Rn &amp; Rm</td><td>按位与</td></tr><tr><td>ORR Rd, Rn</td><td>Rd &#x3D; Rd | Rn</td><td>按位或</td></tr><tr><td>ORR Rd, Rn, #immed</td><td>Rd &#x3D; Rn | #immed</td><td>按位或</td></tr><tr><td>ORR Rd, Rn, Rm</td><td>Rd &#x3D; Rn | Rm</td><td>按位或</td></tr><tr><td>BIC Rd, Rn</td><td>Rd &#x3D; Rd &amp; (~Rn)</td><td>位清除</td></tr><tr><td>BIC Rd, Rn, #immed</td><td>Rd &#x3D; Rn &amp; (~#immed)</td><td>位清除</td></tr><tr><td>BIC Rd, Rn , Rm</td><td>Rd &#x3D; Rn &amp; (~Rm)</td><td>位清除</td></tr><tr><td>ORN Rd, Rn, #immed</td><td>Rd &#x3D; Rn | (#immed)</td><td>按位或非</td></tr><tr><td>ORN Rd, Rn, Rm</td><td>Rd &#x3D; Rn | (Rm)</td><td>按位或非</td></tr><tr><td>EOR Rd, Rn</td><td>Rd &#x3D; Rd ^ Rn</td><td>按位异或</td></tr><tr><td>EOR Rd, Rn, #immed</td><td>Rd &#x3D; Rn ^ #immed</td><td>按位异或</td></tr><tr><td>EOR Rd, Rn, Rm</td><td>Rd &#x3D; Rn ^ Rm</td><td>按位异或</td></tr></tbody></table><h1 id="启动方式"><a href="#启动方式" class="headerlink" title="启动方式"></a>启动方式</h1><h2 id="BOOT"><a href="#BOOT" class="headerlink" title="BOOT"></a>BOOT</h2><p>OOT_MODE[1:0]的值是可以改变的，有两种方式，一种是改写 eFUSE(熔丝)，一种是修改相应的 GPIO 高低电平。  </p><ul><li>BOOT_MODE1 和 BOOT_MODE0 在芯片内部是有 100KΩ下拉电阻的 ，所以默认是0。</li></ul><table><thead><tr><th>BOOT_MODE[1:0]</th><th>BOOT 类型</th></tr></thead><tbody><tr><td>00</td><td>从 FUSE 启动</td></tr><tr><td>01</td><td>串行下载</td></tr><tr><td>10</td><td>内部 BOOT 模式</td></tr><tr><td>11</td><td>保留</td></tr></tbody></table><h3 id="串行下载"><a href="#串行下载" class="headerlink" title="串行下载"></a>串行下载</h3><p>串行下载的意思就是可以通过 USB 或者 UART 将代码下载到板子上的外置存储设备中，我们可以使用 OTG1 这个 USB口向开发板上的 SD&#x2F;EMMC、 NAND 等存储设备下载代码。  </p><h3 id="内部-BOOT-模式"><a href="#内部-BOOT-模式" class="headerlink" title="内部 BOOT 模式"></a>内部 BOOT 模式</h3><p>芯片会执行内部的 boot ROM 代码，代码会进行硬件初始化(一部分外设)，然后从 boot 设备(就是存放代码的设备、比如 SD&#x2F;EMMC、 NAND)中<strong>将代码拷贝出来复制到指定的 RAM 中，一般是 DDR。</strong>  </p><h2 id="BOOT模式-启动设备"><a href="#BOOT模式-启动设备" class="headerlink" title="BOOT模式 启动设备"></a>BOOT模式 启动设备</h2><p>当 BOOT_MODE 设置为内部 BOOT 模式以后，可以从以下设备中启动：<br>①、接到 EIM 接口的 CS0 上的 16 位 NOR Flash。<br>②、接到 EIM 接口的 CS0 上的 OneNAND Flash。<br>③、接到 GPMI 接口上的 MLC&#x2F;SLC NAND Flash， NAND Flash 页大小支持 2KByte、 4KByte和 8KByte， 8 位宽。<br>④、 Quad SPI Flash。<br>⑤、接到 USDHC 接口上的 SD&#x2F;MMC&#x2F;eSD&#x2F;SDXC&#x2F;eMMC 等设备。<br>⑥、 SPI 接口的 EEPROM。  </p><p>启动设备是通过  BOOT_CFG1[7:0]、 BOOT_CFG2[7:0]和 BOOT_CFG4[7:0]这 24 个配置 IO配置，这 24 个配置 IO 刚好对应着 LCD 的 24 根数据线 LCD_DATA0~LCDDATA23，<strong>当启动完成以后这 24 个 IO 就可以作为 LCD 的数据线使用。</strong>  </p><table><thead><tr><th>boot1</th><th>boot0</th><th></th><th></th><th></th><th></th><th></th><th></th><th>启动设备</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>x</td><td>x</td><td>x</td><td>x</td><td>x</td><td>x</td><td>串行下载，可以通过 USB 烧写镜像文件。</td></tr><tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>SD 卡启动。</td></tr><tr><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>EMMC 启动。</td></tr><tr><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>NAND FLASH 启动。</td></tr></tbody></table><h2 id="烧写镜像"><a href="#烧写镜像" class="headerlink" title="烧写镜像"></a>烧写镜像</h2><p><strong>imxdownload 会在 led.bin前面添加一些头信息，重新生成一个叫做 load.imx 的文件，头部信息包含以下</strong>  </p><ul><li><p>Image vector table，简称 IVT， IVT 里面包含了一系列的地址信息，这些地址信息在ROM 中按照固定的地址存放着。</p></li><li><p>Boot data，启动数据，包含了镜像要拷贝到哪个地址，拷贝的大小是多少等等。</p></li><li><p>Device configuration data，简称 DCD，设备配置信息，重点是 DDR3 的初始化配置。</p></li><li><p>用户代码可执行文件，比如 led.bin。</p></li></ul><p>最终烧写到 I.MX6U 中的程序其组成为： IVT+Boot data+DCD+.bin 。(3KByte 的 IVT+Boot Data+DCD)</p><p>.bin是从0x87800000这个地方开始，往前推load.imx就是从0x877FF400开始的。</p><h1 id="点灯Makefile"><a href="#点灯Makefile" class="headerlink" title="点灯Makefile"></a>点灯Makefile</h1><p><strong>Makefile</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 定义了一个变量 objs， objs 包含着要生成 ledc.bin 所需的材料： start.o 和 main.o</span><br><span class="hljs-comment"># 这里要注意 start.o 一定要放到最前面！因为在后面链接的时候 start.o 要在最前面，因为 start.o 是最先要执行的文件！</span><br>objs := start.o main.o<br><br><span class="hljs-comment"># 使用依赖文件(objs:=start.o main.o),生成目标可执行文件ledc.bin</span><br><span class="hljs-section">ledc.bin:<span class="hljs-variable">$(objs)</span></span><br><span class="hljs-comment"># 使用编译器 arm-linux-gnueabihf-ld 进行连接,-Ttext指定起始地址是0X87800000</span><br><span class="hljs-comment"># $^ 是所有依赖文件的集合,也就是变量objs的值(start.o main.o)</span><br><span class="hljs-comment"># 展开等价 arm-linux-gnueabihf-ld -Ttext 0X87800000 -o ledc.elf start.o main.o</span><br>arm-linux-gnueabihf-ld -Ttext 0X87800000 -o ledc.elf <span class="hljs-variable">$^</span><br><span class="hljs-comment"># 将ledc.elf转换成ledc.bin文件</span><br><span class="hljs-comment"># $@ 的意思是目标集合，在这里就是 ledc.bin</span><br><span class="hljs-comment"># 展开等价 arm-linux-gnueabihf-objcopy -O binary -S ledc.elf ledc.bin</span><br>arm-linux-gnueabihf-objcopy -O binary -S ledc.elf <span class="hljs-variable">$@</span><br><span class="hljs-comment"># 反汇编，生成 ledc.dis 文件</span><br>arm-linux-gnueabihf-objdump -D -m arm ledc.elf &gt; ledc.dis<br><br><span class="hljs-comment"># 下面规则展开等价 </span><br><span class="hljs-comment"># start.o:start.s</span><br><span class="hljs-comment">#arm-linux-gnueabihf-gcc -Wall -nostdlib -c -O2 -o start.o start.s</span><br><span class="hljs-comment"># %匹配任意字符</span><br><span class="hljs-section">%.o:%.s</span><br><span class="hljs-comment"># $@ 的意思是目标集合，在这里就是 %.o</span><br><span class="hljs-comment"># $&lt; 所有依赖文件的集合，在这就是 %.s</span><br>arm-linux-gnueabihf-gcc -Wall -nostdlib -c -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br><span class="hljs-section">%.o:%.S</span><br>arm-linux-gnueabihf-gcc -Wall -nostdlib -c -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br><span class="hljs-section">%.o:%.c</span><br>arm-linux-gnueabihf-gcc -Wall -nostdlib -c -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br><br><span class="hljs-section">clean:</span><br>rm -rf *.o ledc.bin ledc.elf ledc.dis<br></code></pre></td></tr></table></figure><p><strong>Makefile</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 类似于上面的只是用到了变量</span><br>CROSS_COMPILE?= arm-linux-gnueabihf-<br>NAME ?= ledc<br><br>CC := <span class="hljs-variable">$(CROSS_COMPILE)</span>gcc<br>LD := <span class="hljs-variable">$(CROSS_COMPILE)</span>ld<br>OBJCOPY := <span class="hljs-variable">$(CROSS_COMPILE)</span>objcopy<br>OBJDUMP := <span class="hljs-variable">$(CROSS_COMPILE)</span>objdump<br>OBJS := start.o main.o<br><br><span class="hljs-variable">$(NAME)</span>.bin:<span class="hljs-variable">$(OBJS)</span><br><span class="hljs-variable">$(LD)</span> -Timx6ul.lds -o <span class="hljs-variable">$(NAME)</span>.elf <span class="hljs-variable">$^</span><br><span class="hljs-variable">$(OBJCOPY)</span> -O binary -S <span class="hljs-variable">$(NAME)</span>.elf <span class="hljs-variable">$@</span><br><span class="hljs-variable">$(OBJDUMP)</span> -D -m arm <span class="hljs-variable">$(NAME)</span>.elf &gt; <span class="hljs-variable">$(NAME)</span>.dis<br>    <br><span class="hljs-section">%.o:%.s</span><br><span class="hljs-variable">$(CC)</span> -Wall -nostdlib -c -O2 -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br><span class="hljs-section">%.o:%.S</span><br><span class="hljs-variable">$(CC)</span> -Wall -nostdlib -c -O2 -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br><span class="hljs-section">%.o:%.c</span><br><span class="hljs-variable">$(CC)</span> -Wall -nostdlib -c -O2 -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br><br><span class="hljs-section">clean:</span><br>rm -rf *.o <span class="hljs-variable">$(NAME)</span>.bin <span class="hljs-variable">$(NAME)</span>.elf <span class="hljs-variable">$(NAME)</span>.dis<br></code></pre></td></tr></table></figure><p><strong>Makefile</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs makefile">CROSS_COMPILE?= arm-linux-gnueabihf-<br><span class="hljs-comment"># 编译后 目标名</span><br>TARGET?= bsp<br><br><span class="hljs-comment"># 编译器相关</span><br>CC:= <span class="hljs-variable">$(CROSS_COMPILE)</span>gcc<br>LD:= <span class="hljs-variable">$(CROSS_COMPILE)</span>ld<br>OBJCOPY:= <span class="hljs-variable">$(CROSS_COMPILE)</span>objcopy<br>OBJDUMP:= <span class="hljs-variable">$(CROSS_COMPILE)</span>objdump<br><br><span class="hljs-comment"># include dir</span><br>INCDIRS:=  imx6ul  \<br>bsp/clk \<br>bsp/led \<br>bsp/delay<br><br><span class="hljs-comment"># sourc dir</span><br>SRCDIRS :=  project \<br>bsp/clk \<br>bsp/led \<br>bsp/delay<br><br><span class="hljs-comment"># 这里用到了 patsubst 函数 通过这个函数给 INCDIRS 前面加了一个 -I</span><br><span class="hljs-comment"># 展开 INCLUDE := -I imx6ul -I bsp/clk -I bsp/led -I bsp/delay</span><br>INCLUDE := <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %, -I %, <span class="hljs-variable">$(INCDIRS)</span>)</span><br><br><span class="hljs-comment"># 这里用到了 foreach 和 wildcard 函数</span><br><span class="hljs-comment"># 展开 SFILES := project/start.S</span><br><span class="hljs-comment"># 展开 CFILES := project/main.c bsp/clk/bsp_clk.c bsp/led/bsp_led.c bsp/delay/bsp_delay.c</span><br>SFILES := <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> <span class="hljs-built_in">dir</span>, <span class="hljs-variable">$(SRCDIRS)</span>, $(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(dir)</span>/*.S)</span>)<br>CFILES := <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> <span class="hljs-built_in">dir</span>, <span class="hljs-variable">$(SRCDIRS)</span>, $(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(dir)</span>/*.c)</span>)<br><br><span class="hljs-comment"># 这里用到了 notdir 函数 除去路径函数</span><br><span class="hljs-comment"># 展开 SFILENDIR := start.S</span><br><span class="hljs-comment"># 展开 CFILENDIR := main.c bsp_clk.c bsp_led.c bsp_delay.c</span><br>SFILENDIR := <span class="hljs-variable">$(<span class="hljs-built_in">notdir</span> <span class="hljs-variable">$(SFILES)</span>)</span><br>CFILENDIR := <span class="hljs-variable">$(<span class="hljs-built_in">notdir</span> <span class="hljs-variable">$(CFILES)</span>)</span><br><br><span class="hljs-comment"># 展开 SOBJS := obj/start.o</span><br><span class="hljs-comment"># 展开 COBJS := obj/main.o obj/bsp_clk.o obj/bsp_led.o obj/bsp_delay.o</span><br><span class="hljs-comment"># 展开 OBJS  := obj/start.o obj/main.o obj/bsp_clk.o obj/bsp_led.o obj/bsp_delay.o</span><br>SOBJS := <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %, obj/%, $(SFILENDIR:.S=.o)</span>)<br>COBJS := <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %, obj/%, $(CFILENDIR:.c=.o)</span>)<br>OBJS := <span class="hljs-variable">$(SOBJS)</span> <span class="hljs-variable">$(COBJS)</span><br><br>VPATH := <span class="hljs-variable">$(SRCDIRS)</span><br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: clean</span><br><br><span class="hljs-variable">$(TARGET)</span>.bin : <span class="hljs-variable">$(OBJS)</span><br><span class="hljs-variable">$(LD)</span> -Timx6ul.lds -o <span class="hljs-variable">$(TARGET)</span>.elf <span class="hljs-variable">$^</span><br><span class="hljs-variable">$(OBJCOPY)</span> -O binary -S <span class="hljs-variable">$(TARGET)</span>.elf <span class="hljs-variable">$@</span><br><span class="hljs-variable">$(OBJDUMP)</span> -D -m arm <span class="hljs-variable">$(TARGET)</span>.elf &gt; <span class="hljs-variable">$(TARGET)</span>.dis<br><br><span class="hljs-variable">$(SOBJS)</span> : obj/%.o : %.S<br><span class="hljs-variable">$(CC)</span> -Wall -nostdlib -c -O2 <span class="hljs-variable">$(INCLUDE)</span> -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br><span class="hljs-variable">$(COBJS)</span> : obj/%.o : %.c<br><span class="hljs-variable">$(CC)</span> -Wall -nostdlib -c -O2 <span class="hljs-variable">$(INCLUDE)</span> -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br><br><span class="hljs-section">clean:</span><br>rm -rf <span class="hljs-variable">$(TARGET)</span>.elf <span class="hljs-variable">$(TARGET)</span>.dis <span class="hljs-variable">$(TARGET)</span>.bin <span class="hljs-variable">$(COBJS)</span> <span class="hljs-variable">$(SOBJS)</span><br></code></pre></td></tr></table></figure><h1 id="Board-Support"><a href="#Board-Support" class="headerlink" title="Board Support"></a>Board Support</h1><ul><li>正点原子的 I.MX6ULL EMMC 核心板上 FSL_SDHC(0)接的 SD(TF)卡，FSL_SDHC(1)接的 EMMC。</li></ul><h1 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h1><h2 id="Ubuntu-交叉编译工具链安装"><a href="#Ubuntu-交叉编译工具链安装" class="headerlink" title="Ubuntu 交叉编译工具链安装"></a>Ubuntu 交叉编译工具链安装</h2><blockquote><p>交叉编译器有很多种，我们使用 Linaro 出品的交叉编译器，Linaro 是一间非营利性质的开放源代码软件工程公司，Linaro 开发了很多软件，最著名的就是 Linaro GCC 编译工具链(编译器)</p></blockquote><p>Linaro 编译器7.5.0下载<a href="https://releases.linaro.org/components/toolchain/binaries/latest-7/arm-linux-gnueabihf/">链接</a></p><ol><li><p>有很多种 GCC 交叉编译工具链，因为我们所使用的 I.MX6U-ALPHA 开发板是一个 Cortex-A7 内核的开发板，因此选择 arm-linux-gnueabihf</p><blockquote><p>aarch64-elf<br>aarch64-linux-gnu<br>aarch64_be-elf<br>aarch64_be-linux-gnu<br>arm-eabi<br>arm-linux-gnueabi<br><strong>arm-linux-gnueabihf</strong><br>armeb-eabi<br>armeb-linux-gnueabihf<br>armv8l-linux-gnueabihf</p></blockquote></li><li><p><code>gcc-linaro-7.5.0-2019.12-x86_64_arm-linux-gnueabihf.tar.xz</code> 这个文件就是7.5.0版本的GCC交叉编译器，用于X86——64位的linux上运行</p><ol><li><strong>需要注意的是</strong>，这个开发板用的是4.9.4版本的编译器，过高版本的编译器会有一些问题。</li><li><a href="https://releases.linaro.org/components/toolchain/binaries/4.9-2017.01/arm-linux-gnueabihf/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf.tar.xz">Linaro 4.9.4 下载链接</a></li></ol></li><li><p>下载好编译器之后需要做的就是将编译器添加到环境变量，使得可以在任何目录下调用编译器。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo mkdir /usr/local/arm<br><br>sudo cp gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf.tar.xz /usr/local/arm/ -f<br><br>sudo tar -vxf gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf.tar.xz<br><br>sudo vi /etc/profile<br><br>export PATH=$PATH:/usr/local/arm/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin<br></code></pre></td></tr></table></figure></li><li><p>搞定环境变量之后需要安装一些其他的编译库</p><ol><li><code>sudo apt-get install lsb-core lib32stdc++6</code></li></ol></li><li><p>验证编译器</p><ol><li>任意目录输入<code>arm-linux-gnueabihf-gcc -v</code> 即可查看编译器版本号</li><li>arm 表示这是编译 arm 架构代码的编译器。<br> linux 表示运行在 linux 环境下。<br> gnueabihf 表示嵌入式二进制接口。<br> gcc 表示是 gcc 工具</li></ol></li></ol><h1 id="烧写程序"><a href="#烧写程序" class="headerlink" title="烧写程序"></a>烧写程序</h1><h2 id="烧写Uboot"><a href="#烧写Uboot" class="headerlink" title="烧写Uboot"></a>烧写Uboot</h2><h3 id="烧写到SD卡，通过ta启动uboot"><a href="#烧写到SD卡，通过ta启动uboot" class="headerlink" title="烧写到SD卡，通过ta启动uboot"></a>烧写到SD卡，通过ta启动uboot</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod 777 imxdownload<br><span class="hljs-meta prompt_"># </span><span class="language-bash">烧写到 SD 卡，注意区别设备号 不能烧写到/dev/sda 或 sda1 设备里面！</span><br>./imxdownload u-boot.bin /dev/sdd<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">烧写uboot之后就可以通过网络的方式加载 linux kernel 和 rootfs 参考boot章节</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者通过mfg工具将准备好的固件打包下载到特定存储介质上</span><br></code></pre></td></tr></table></figure><h3 id="烧写到EMMC-NAND，通过ta启动uboot"><a href="#烧写到EMMC-NAND，通过ta启动uboot" class="headerlink" title="烧写到EMMC&#x2F;NAND，通过ta启动uboot"></a>烧写到EMMC&#x2F;NAND，通过ta启动uboot</h3><h1 id="U-Boot"><a href="#U-Boot" class="headerlink" title="U-Boot"></a>U-Boot</h1><p>uboot 的全称是 Universal Boot Loader。</p><p>Linux 系统要启动就必须需要一个 bootloader 程序，也就说芯片上电以后先运行一段bootloader 程序。这段 bootloader程序会先初始化 DDR等外设，然后将Linux 内核从flash(NAND，NOR FLASH，SD，MMC 等)拷贝到 DDR 中，最后启动 Linux 内核。当然了，bootloader 的实际工作要复杂的多，但是它最主要的工作就是启动 Linux 内核，bootloader 和 Linux 内核的关系就跟 PC 上的 BIOS 和 Windows 的关系一样，bootloader 就相当于 BIOS。所以我们要先搞定bootloader，很庆幸，有很多现成的 bootloader 软件可以使用，比如 U-Boot、vivi、RedBoot 等等，其中以 U-Boot 使用最为广泛。</p><p>U-Boot分为以下几种</p><ul><li>第一种，uboot官方维护的uboot代码，更新最快，包含所有常用芯片。</li><li>第二种，半导体厂商维护的uboot代码，例如NXP的uboot，针对性更强，对自己家芯片的支持性更好</li><li>第三种，产品开发公司维护的uboot代码，使用芯片的公司自己添加了一些支持，boot移植就是讲的这个</li></ul><p><a href="https://github.com/nxp-imx/uboot-imx">NXP uboot-imx 链接</a></p><blockquote><p><span style="color:red"><strong>！注意！</strong></span></p><ul><li>只能在 uboot 中 ping 其他的机器，其他机器不能 ping uboot，因为 uboot 没有对 ping命令做处理，如果用其他的机器 ping uboot 的话会失败！</li><li>uboot 命令中的数字都是十六进制的！不是十进制的！</li><li>EMMC 核心板 uboot 环境变量的存储起始地址就是第1536(0x600)block。1536*512&#x3D;786432</li><li><code>u-boot.imx</code>是从第0个分区的第2个block开始的。</li><li>千万不要写 SD 卡或者 EMMC 的前两个块(扇区)，里面保存着分区表！</li></ul></blockquote><h2 id="Uboot的编译"><a href="#Uboot的编译" class="headerlink" title="Uboot的编译"></a>Uboot的编译</h2><ol><li><p>安装库 <code>sudo apt-get install libncurses5-dev</code></p></li><li><p>解压对应的uboot代码 <code>tar -vxjf uboot-imx-2016.03-2.1.0-g8b546e4.tar.bz2</code></p></li><li><p>使用脚本编译uboot代码</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用了 make 命令，用于清理工程，也就是每次在编译 uboot 之前都清理一下工程。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这里的 make 命令带有三个参数，第一个是 ARCH，也就是指定架构，这里肯定是 arm；</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">第二个参数 CROSS_COMPILE 用于指定编译器，只需要指明编译器前缀就行了，比如 arm-linux-gnueabihf-gcc 编译器的前缀就是“arm-linux-gnueabihf-”</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">最后一个参数 distclean 就是清除工程</span><br>make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- distclean<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设定配置文件为 mx6ull_14x14_ddr512_emmc_defconfig</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这个配置文件在 uboot 源码的 configs 目录中</span><br>make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- mx6ull_alientek_emmc_defconfig<br>make V=1 ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j16<br></code></pre></td></tr></table></figure><blockquote><p>　uboot 是 bootloader 的一种，可以用来引导Linux，但是 uboot 除了引导 Linux 以外还可以引导其它的系统，而且 uboot 还支持其它的架构和外设，比如 USB、网络、SD 卡等。这些都是可以配置的，需要什么功能就使能什么功能。所以在编译 uboot 之前，一定要根据自己的需求配置 uboot。而这个配置文件在上面的例子中就是<code>mx6ull_alientek_emmc_defconfig</code></p></blockquote></li></ol><h2 id="Uboot的启动"><a href="#Uboot的启动" class="headerlink" title="Uboot的启动"></a>Uboot的启动</h2><p>通过前面介绍过的烧写程序的方法将uboot烧写到设备，修改启动方式，启动对应设备内的uboot程序。</p><p>接上串口，不出意外就会出现下面的提示。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">指示了uboot版本 和 编译时间</span><br>U-Boot 2016.03-g0ae7e33 (Aug 14 2022 - 19:42:45 +0800)<br><span class="hljs-meta prompt_"># </span><span class="language-bash">指示cpu型号 和 运行频率</span><br>CPU:   Freescale i.MX6ULL rev1.1 792 MHz (running at 396 MHz)<br><span class="hljs-meta prompt_"># </span><span class="language-bash">CPU温度范围 和 当前温度</span><br>CPU:   Industrial temperature grade (-40C to 105C) at 47C<br><span class="hljs-meta prompt_"># </span><span class="language-bash">复位原因 当前的复位原因是 POR。I.MX6ULL 芯片上有个 POR_B 引脚，将这个引脚拉低即可复位。</span><br>Reset cause: POR<br><span class="hljs-meta prompt_"># </span><span class="language-bash">board name</span><br>Board: I.MX6U ALPHA|MINI<br>I2C:   ready<br>DRAM:  512 MiB<br><span class="hljs-meta prompt_"># </span><span class="language-bash">当前有两个 MMC/SD 卡控制器：FSL_SDHC(0)和 FSL_SDHC(1)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">正点原子的 I.MX6ULL EMMC 核心板上 FSL_SDHC(0)接的 SD(TF)卡 FSL_SDHC(1)接的 EMMC。</span><br>MMC:   FSL_SDHC: 0, FSL_SDHC: 1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">标准输入、标准输出和标准错误所使用的终端，这里都使用串口(serial)作为终端。</span><br>In:    serial<br>Out:   serial<br>Err:   serial<br><span class="hljs-meta prompt_"># </span><span class="language-bash">切换到 emmc 的第 0 个分区上，因为当前的 uboot 是 emmc 版本的，也就是从 emmc 启动的。</span><br>switch to partitions #0, OK<br>mmc1(part 0) is current device<br><span class="hljs-meta prompt_"># </span><span class="language-bash">网口信息，提示我们当前使用的 FEC1 这个网口，I.MX6ULL 支持两个网口。</span><br>Net:   FEC1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">提示正常启动，也就是说 uboot 要从 emmc 里面读取环境变量和参数信息启动 Linux内核了。</span><br>Normal Boot<br><span class="hljs-meta prompt_"># </span><span class="language-bash">倒计时结束之前按下任意键就会进入Linux命令行模式。如果在倒计时结束以后没有按下，那么Linux内核就会启动，Linux内核一旦启动，uboot就会寿终正寝。</span><br>Hit any key to stop autoboot: 2<br></code></pre></td></tr></table></figure><p>如果在 3 秒倒计时结束之前按下任意键，那么就会进入 uboot 的命令行模式。</p><h2 id="Uboot的命令及相关操作"><a href="#Uboot的命令及相关操作" class="headerlink" title="Uboot的命令及相关操作"></a>Uboot的命令及相关操作</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">输入 <span class="hljs-built_in">help</span> 或者 ? 即可查看当前uboot支持的命令</span><br>==&gt; help<br><span class="hljs-meta prompt_"># </span><span class="language-bash">输入 ? <span class="hljs-built_in">env</span> 或者 <span class="hljs-built_in">env</span> <span class="hljs-built_in">help</span> 即可查看 <span class="hljs-built_in">env</span> 命令的使用方法</span><br>==&gt; env help<br></code></pre></td></tr></table></figure><h4 id="bdinfo"><a href="#bdinfo" class="headerlink" title="bdinfo"></a>bdinfo</h4><p>DRAM 的起始地址和大小、启动参数保存起始地址、波特率、sp(堆栈指针)起始地址等信息。</p><h4 id="△-env"><a href="#△-env" class="headerlink" title="△ env"></a>△ env</h4><ul><li><code>env print</code> 输出环境变量</li><li><strong><code>env set</code> 设置环境变量，设置为空就是删除环境变量</strong><ul><li>示例 设置serverip <code>env set serverip 192.168.192.100</code></li><li>示例 带空格的环境变量 <code>env set teest_args &#39;xxx xxx xxx&#39;</code></li></ul></li><li><code>env save</code> 用set设定的环境变量只是临时的，使用save命令将环境变量固化到非易失存储器内。</li></ul><table><thead><tr><th>环境变量名</th><th></th></tr></thead><tbody><tr><td>bootdelay</td><td>boot的延迟等待时间</td></tr><tr><td></td><td></td></tr><tr><td>bootcmd</td><td>前面说过 uboot 倒计时结束以后就会启动 Linux 系统，其实就是执行的 bootcmd 中的启动命令。</td></tr><tr><td></td><td></td></tr><tr><td>ipaddr</td><td>开发板 ip 地址，可以不设置，使用 dhcp 命令来从路由器获取 IP 地址。</td></tr><tr><td>ethaddr</td><td>开发板的 MAC 地址，一定要设置。</td></tr><tr><td>gatewayip</td><td>网关地址。</td></tr><tr><td>netmask</td><td>子网掩码。</td></tr><tr><td>serverip</td><td>服务器 IP 地址，也就是 Ubuntu 主机 IP 地址，用于调试代码。</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">setenv ipaddr 192.168.192.120<br>setenv ethaddr b8:ae:1d:01:00:00<br>setenv gatewayip 192.168.192.1<br>setenv netmask 255.255.255.0<br>setenv serverip 192.168.192.100<br>saveenv<br></code></pre></td></tr></table></figure><h4 id="md-DRAM查看"><a href="#md-DRAM查看" class="headerlink" title="md DRAM查看"></a>md DRAM查看</h4><p>md 命令用于显示内存值。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">md[.b, .w, .l] address [# of objects]<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">[.b .w .l]对应 byte、word 和 long</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">address 就是要查看的内存起始地址</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">[# of objects]表示要查看的数据长度 16进制 单位是前面的bwl</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">示例</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">从0x80000000 查看 0x10 个 long 的数据</span><br>md.l 80000000 10<br></code></pre></td></tr></table></figure><h4 id="nm-DRAM修改"><a href="#nm-DRAM修改" class="headerlink" title="nm DRAM修改"></a>nm DRAM修改</h4><p>地址不自增</p><h4 id="mm-DRAM修改"><a href="#mm-DRAM修改" class="headerlink" title="mm DRAM修改"></a>mm DRAM修改</h4><p>mm 命令用于修改指定地址的内存值，地址自增。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">mm[.b, .w, .l] address<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">示例</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改 0x80000000 的数据</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">输入 q 即可退出修改</span><br>=&gt; mm.l 80000010<br>80000010: 00000000 ? _<br><br></code></pre></td></tr></table></figure><h4 id="mw-填充DRAM"><a href="#mw-填充DRAM" class="headerlink" title="mw 填充DRAM"></a>mw 填充DRAM</h4><p>命令 mw 用于使用一个指定的数据填充一段内存</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">mw[.b, .w, .l] address value [count]<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">示例</span><br>=&gt; mw.l 80000010 faaffaaf 4<br></code></pre></td></tr></table></figure><h4 id="cp-copy"><a href="#cp-copy" class="headerlink" title="cp copy"></a>cp copy</h4><p>cp 是数据拷贝命令，用于将 DRAM 中的数据从一段内存拷贝到另一段内存中，或者把 NorFlash 中的数据拷贝到 DRAM 中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp[.b, .w, .l] source target count<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">source</span> 为源地址</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">target 为目的地址</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">count 为拷贝的数量 单位是前面的bwl</span><br></code></pre></td></tr></table></figure><h4 id="dhcp"><a href="#dhcp" class="headerlink" title="dhcp"></a>dhcp</h4><p>dhcp 用于从路由器获取 IP 地址</p><h4 id="△-nfs"><a href="#△-nfs" class="headerlink" title="△ nfs"></a>△ nfs</h4><p>nfs - boot image via network using NFS protocol</p><p>Usage:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">nfs [loadAddress] [[hostIPaddr:]bootfilename]<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">loadAddress 是要保存的 DRAM 地址</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">[[hostIPaddr:]bootfilename]是要下载的文件地址</span><br><br>nfs 80800000 192.168.192.100:/home/frank/linuxMini/nfs_dir/u-boot.imx<br>nfs 80800000 192.168.192.100:/home/frank/linuxMini/nfs_dir/zImage<br>nfs 83000000 192.168.192.100:/home/frank/linuxMini/nfs_dir/imx6ull-14x14-emmc-4.3-480x272-c.dtb<br></code></pre></td></tr></table></figure><h4 id="△-tftp-tftpboot"><a href="#△-tftp-tftpboot" class="headerlink" title="△ tftp &amp; tftpboot"></a>△ tftp &amp; tftpboot</h4><p>tftpboot - boot image via network using TFTP protocol</p><p>Usage:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">tftpboot [loadAddress] [[hostIPaddr:]bootfilename]<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">loadAddress 是要保存的 DRAM 地址</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">[[hostIPaddr:]bootfilename]是要下载的文件地址</span><br></code></pre></td></tr></table></figure><h4 id="△-mmc"><a href="#△-mmc" class="headerlink" title="△ mmc"></a>△ mmc</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs shell">mmc info<br><span class="hljs-meta prompt_"># </span><span class="language-bash">△ 显示当前mmc的信息</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">- display info of the current MMC device</span><br><br>mmc read addr blk# cnt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">addr 是数据读取到 DRAM 中的地址</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">blk 是要读取的块起始地址(十六进制)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">cnt 是块计数</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">示例</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">=&gt; mmc <span class="hljs-built_in">read</span> 80800000 600 10</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">从mmc的第0x600个block开始，读取0x10个block，到DRAM的0x80800000处</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">注意从mmc info可以看到一个block的大小是512Byte</span><br><br>mmc write addr blk# cnt<br>mmc erase blk# cnt<br>mmc rescan<br><br>mmc part<br><span class="hljs-meta prompt_"># </span><span class="language-bash">△ 显示分区</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">- lists available partition on current mmc device</span><br><br>mmc dev [dev] [part]<br><span class="hljs-meta prompt_"># </span><span class="language-bash">△ 显示或者切换当前的设备</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">[dev] 设备号，mmc list可以查看</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">[part] 分区号，mmc part可以查看</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">- show or <span class="hljs-built_in">set</span> current mmc device [partition]</span><br><br>mmc list <br><span class="hljs-meta prompt_"># </span><span class="language-bash">- lists available devices</span><br><br>mmc hwpartition [args...] <br><span class="hljs-meta prompt_"># </span><span class="language-bash">- does hardware partitioning</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"> arguments (sizes <span class="hljs-keyword">in</span> 512-byte blocks):</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">   [user [enh start cnt] [wrrel &#123;on|off&#125;]] - sets user data area attributes</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">   [gp1|gp2|gp3|gp4 cnt [enh] [wrrel &#123;on|off&#125;]] - general purpose partition</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">   [check|<span class="hljs-built_in">set</span>|complete] - mode, complete <span class="hljs-built_in">set</span> partitioning completed</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"> WARNING: Partitioning is a write-once setting once it is <span class="hljs-built_in">set</span> to complete.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"> Power cycling is required to initialize partitions after <span class="hljs-built_in">set</span> to complete.</span><br><br>mmc bootbus dev boot_bus_width reset_boot_bus_width boot_mode<br><span class="hljs-meta prompt_"># </span><span class="language-bash">- Set the BOOT_BUS_WIDTH field of the specified device</span><br><br>mmc bootpart-resize &lt;dev&gt; &lt;boot part size MB&gt; &lt;RPMB part size MB&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">- Change sizes of boot and RPMB partitions of specified device</span><br><br>mmc partconf dev boot_ack boot_partition partition_access<br><span class="hljs-meta prompt_"># </span><span class="language-bash">- Change the bits of the PARTITION_CONFIG field of the specified device</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">说明：设置启动分区</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">dev：mmc设备编号</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">boot_ack：是否应答</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">boot_partition：用户选择发送到主机的引导数据</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">partition_access：用户选择要访问的分区</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">示例</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">=&gt; mmc partconf 1 1 0 0</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将mmc dev 1 设置为启动分区</span><br><br>mmc rst-function dev value<br><span class="hljs-meta prompt_"># </span><span class="language-bash">- Change the RST_n_FUNCTION field of the specified device</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  WARNING: This is a write-once field and 0 / 1 / 2 are the only valid values.</span><br><br>mmc setdsr &lt;value&gt; <br><span class="hljs-meta prompt_"># </span><span class="language-bash">- <span class="hljs-built_in">set</span> DSR register value</span><br></code></pre></td></tr></table></figure><p><strong>在Uboot中更新uboot程序</strong></p><blockquote><p>思路就是先通过网络把文件存在DRAM中（nfs、tftp），再将文件写入到特定位置（mmc write）。</p><p>如果 EMMC 里面烧写了 Linux 系统的话，EMMC 是有 3 个分区的</p><ul><li>第 0 个分区存放 uboot，</li><li>第 1 个分区存放Linux 镜像文件和设备树，</li><li>第 2 个分区存放根文件系统。</li></ul></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">mmc dev 1 0              # 切换到 EMMC 分区 0<br>tftp 80800000 u-boot.imx # 下载 u-boot.imx 到 DRAM<br><span class="hljs-meta prompt_"># </span><span class="language-bash">或 nfs 80800000 192.168.192.100:/home/frank/linuxMini/nfs_dir/u-boot.imx</span><br>mmc write 80800000 2 32E # 烧写 u-boot.imx 到 EMMC 中 (注意这里是block的数量，xxx Byte/512Byte)<br>mmc partconf 1 1 0 0     # 分区配置，EMMC 需要这一步！ SD卡不需要。<br></code></pre></td></tr></table></figure><h4 id="fatinfo"><a href="#fatinfo" class="headerlink" title="fatinfo"></a>fatinfo</h4><p>fatinfo 命令用于查询指定 MMC 设备分区的文件系统信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">fatinfo &lt;interface&gt; [&lt;dev[:part]&gt;]<br><span class="hljs-meta prompt_"># </span><span class="language-bash">interface 表示接口，比如 mmc，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">dev 是查询的设备号，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">part 是要查询的分区。</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查询 EMMC 分区 1 的文件系统信息，命令如下：</span><br>=&gt; fatinfo mmc 1:1<br>Interface:  MMC<br>  Device 1: Vendor: Man 000015 Snr 3ee65248 Rev: 0.6 Prod: 8GTF4R<br>            Type: Removable Hard Disk<br>            Capacity: 7456.0 MB = 7.2 GB (15269888 x 512)<br>Filesystem: FAT32 &quot;NO NAME    &quot;<br></code></pre></td></tr></table></figure><h4 id="fstype-查看文件系统格式"><a href="#fstype-查看文件系统格式" class="headerlink" title="fstype 查看文件系统格式"></a>fstype 查看文件系统格式</h4><p>fstype 用于查看 MMC 设备某个分区的文件系统格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">fstype &lt;interface&gt; &lt;dev&gt;:&lt;part&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">正点原子 EMMC 核心板上的 EMMC 默认有 3 个分区，我们来查看一下这三个分区的文件系统格式</span><br>=&gt; fstype mmc 1:0<br>Failed to mount ext2 filesystem...<br>** Unrecognized filesystem type **<br>=&gt; fstype mmc 1:1<br>fat<br>=&gt; fstype mmc 1:2<br>ext4<br><span class="hljs-meta prompt_"># </span><span class="language-bash">从上可以看出，分区 0 格式未知，因为分区 0 存放的 uboot，并且分区 0 没有格式化，所以文件系统格式未知。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">分区 1 的格式为 fat，分区 1 用于存放 linux 镜像和设备树。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">分区 2 的格式为 ext4，用于存放 Linux 的根文件系统(rootfs)。</span><br></code></pre></td></tr></table></figure><h4 id="fatls-fat列出文件"><a href="#fatls-fat列出文件" class="headerlink" title="fatls fat列出文件"></a>fatls fat列出文件</h4><p>fatls 命令用于查询 FAT 格式设备的目录和文件信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">fatls &lt;interface&gt; [&lt;dev[:part]&gt;] [directory]<br><span class="hljs-meta prompt_"># </span><span class="language-bash">interface 是要查询的接口，比如 mmc，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">dev 是要查询的设备号，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">part 是要查询的分区，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">directory是要查询的目录。</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查询 EMMC 分区 1 中的所有的目录和文件，输入命令：</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">分区1中存放着dts文件，通过这个命令可以查看到</span><br>=&gt; fatls mmc 1:1 /<br>  6785480   zimage<br>    39459   imx6ull-14x14-emmc-4.3-480x272-c.dtb<br>    39459   imx6ull-14x14-emmc-4.3-800x480-c.dtb<br>    39459   imx6ull-14x14-emmc-7-800x480-c.dtb<br>    39459   imx6ull-14x14-emmc-7-1024x600-c.dtb<br>    39459   imx6ull-14x14-emmc-10.1-1280x800-c.dtb<br>    40295   imx6ull-14x14-emmc-hdmi.dtb<br>    40203   imx6ull-14x14-emmc-vga.dtb<br><br>8 file(s), 0 dir(s)<br></code></pre></td></tr></table></figure><h4 id="fatload-设备文件load到DRAM"><a href="#fatload-设备文件load到DRAM" class="headerlink" title="fatload 设备文件load到DRAM"></a>fatload 设备文件load到DRAM</h4><p>fatload 命令用于将指定的文件读取到 DRAM 中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">fatload &lt;interface&gt; [&lt;dev[:part]&gt; [&lt;addr&gt; [&lt;filename&gt; [bytes [pos]]]]]<br><span class="hljs-meta prompt_"># </span><span class="language-bash">interface 为接口，比如 mmc，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">dev 是设备号，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">part 是分区，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">addr 是保存在 DRAM 中的起始地址，filename 是要读取的文件名字。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">bytes 表示读取多少字节的数据，如果 bytes 为 0 或者省略的话表示读取整个文件。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">pos 是要读的文件相对于文件首地址的偏移，如果为 0 或者省略的话表示从文件首地址开始读取。</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">我们将 EMMC 分区 1 中的 zImage 文件读取到 DRAM 中的 0X80800000 地址处，命令如下：</span><br>fatload mmc 1:1 80800000 zImage<br></code></pre></td></tr></table></figure><h4 id="fatwrite-文件写入设备"><a href="#fatwrite-文件写入设备" class="headerlink" title="fatwrite 文件写入设备"></a>fatwrite 文件写入设备</h4><p>fatwirte 命令用于将 DRAM 中的数据写入到 MMC 设备中</p><ul><li>我们可以通过 fatwrite 命令在 uboot 中更新 linux 镜像文件和设备树。</li><li>注意！uboot 默认没有使能 fatwrite 命令，需要修改板子配置头文件。找到自己开发板对应的配置头文件然后添加如下一行宏定义来使能 fatwrite 命令：<br>  <code>#define CONFIG_FAT_WRITE /* 使能 fatwrite 命令 */</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">fatwrite &lt;interface&gt; &lt;dev[:part]&gt; &lt;addr&gt; &lt;filename&gt; &lt;bytes&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">interface 为接口，比如 mmc，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">dev 是设备号，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">part 是分区，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">addr 是要写入的数据在 DRAM 中的起始地址，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">filename 是写入的数据文件名字，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">bytes 表示要写入多少字节的数据。</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">把位于 0x80800000 的 0x6788f8 字节的 zimage 文件 写入到 mmc 1:1 中</span><br>fatwrite mmc 1:1 80800000 zImage 6788f8<br></code></pre></td></tr></table></figure><h4 id="ext4ls-ext4列出文件"><a href="#ext4ls-ext4列出文件" class="headerlink" title="ext4ls ext4列出文件"></a>ext4ls ext4列出文件</h4><h4 id="ext4load"><a href="#ext4load" class="headerlink" title="ext4load"></a>ext4load</h4><h4 id="ext4write"><a href="#ext4write" class="headerlink" title="ext4write"></a>ext4write</h4><h4 id="reset-重启"><a href="#reset-重启" class="headerlink" title="reset 重启"></a>reset 重启</h4><h4 id="go-执行指定地址的程序"><a href="#go-执行指定地址的程序" class="headerlink" title="go 执行指定地址的程序"></a>go 执行指定地址的程序</h4><h4 id="△-run-运行环境变量中的脚本"><a href="#△-run-运行环境变量中的脚本" class="headerlink" title="△ run 运行环境变量中的脚本"></a>△ run 运行环境变量中的脚本</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">run bootcmd<br><br><br>setenv boot2nfs &#x27;nfs 80800000 192.168.192.100:/home/frank/linuxMini/nfs_dir/zImage; nfs 83000000 192.168.192.100:/home/frank/linuxMini/nfs_dir/imx6ull-14x14-emmc-4.3-480x272-c.dtb; bootz 80800000 - 83000000&#x27;<br>setenv boot2nfs &#x27;nfs 80800000 192.168.192.100:/home/frank/linuxMini/nfs_dir/zImage; nfs 83000000 192.168.192.100:/home/frank/linuxMini/nfs_dir/imx6ull-14x14-emmc-4.3-480x272-c.dtb; bootz 80800000 - 83000000&#x27;<br>run boot2nfs<br></code></pre></td></tr></table></figure><h4 id="mtest-DRAM-test"><a href="#mtest-DRAM-test" class="headerlink" title="mtest DRAM test"></a>mtest DRAM test</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mtest [start [end [pattern [iterations]]]]<br><br>=&gt; mtest 80000000 80001000<br></code></pre></td></tr></table></figure><h2 id="Uboot的BOOT操作"><a href="#Uboot的BOOT操作" class="headerlink" title="Uboot的BOOT操作"></a>Uboot的BOOT操作</h2><p>uboot 的本质工作是引导 Linux，所以 uboot 肯定有相关的 boot(引导)命令来启动 Linux。常用的跟 boot 有关的命令有：bootz、bootm 和 boot。</p><blockquote><p>我们也可以通过设置环境变量，通过run指令来执行环境变量的方式来启动预定义的linux系统</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">run bootcmd<br><br><br>setenv boot2nfs &#x27;nfs 80800000 192.168.192.100:/home/frank/linuxMini/nfs_dir/zImage; nfs 83000000 192.168.192.100:/home/frank/linuxMini/nfs_dir/imx6ull-14x14-emmc-4.3-480x272-c.dtb; bootz 80800000 - 83000000&#x27;<br>run boot2nfs<br><br><br><br>setenv serverip &quot;192.168.3.5’<br>setenv ipaddr &#x27;192.168.3.135&#x27;<br>setenv gatewayip &#x27;192.168.3.1&#x27;<br>setenv netmask &#x27;255.255.255.0&#x27;<br>setenv oikiou_zImage &#x27;/home/frank/linuxMini/nfs_dir/oikiou_zImage&#x27;<br>setenv oikiou_dtbp &#x27;/home/frank/linuxMini/nfs_dir/imx6ull-14x14-emmc-4.3-480x272-c.dtb&#x27;<br>setenv oikiou_rootfs &#x27;/home/frank/linuxMini/nfs_dir/rootfs_oikiou_buildroot&#x27;<br>setenv oikiou_netargs &#x27;setenv bootargs console=ttymxc0,115200 root=/dev/nfs nfsroot=$&#123;serverip&#125;:$&#123;oikiou_rootfs&#125;,proto=tcp rw ip=$&#123;ipaddr&#125;:$&#123;serverip&#125;:$&#123;gatewayip&#125;:$&#123;netmask&#125;::eth0:off&#x27;<br>setenv onetboot &#x27;echo Booting from net ...; run oikiou_netargs; nfs $&#123;loadaddr&#125; $&#123;serverip&#125;:$&#123;oikiou_zImage&#125;; nfs $&#123;fdt_addr&#125; $&#123;serverip&#125;:$&#123;oikiou_dtbp&#125;; bootz $&#123;loadaddr&#125; - $&#123;fdt_addr&#125;;&#x27;<br>run onetboot<br></code></pre></td></tr></table></figure></blockquote><h4 id="bootz"><a href="#bootz" class="headerlink" title="bootz"></a>bootz</h4><p>要启动 Linux，需要先将 Linux 镜像文件拷贝到 DRAM 中，如果使用到设备树的话也需要将设备树拷贝到 DRAM 中。</p><p>可以从 EMMC 或者 NAND 等存储设备中将 Linux 镜像和设备树文件拷贝到 DRAM，也可以通过 nfs 或者 tftp 将 Linux 镜像文件和设备树文件下载到 DRAM 中。<br>不管用那种方法，只要能将 Linux 镜像和设备树文件存到 DRAM 中就行，然后使用 bootz 命令来启动linux</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">bootz [addr [initrd[:size]] [fdt]]<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">addr 是 Linux 镜像文件在 DRAM 中的位置，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">initrd 是 initrd 文件在DRAM 中的地址，如果不使用 initrd 的话使用‘-’代替即可，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">fdt 就是设备树文件在 DRAM 中的地址。</span><br></code></pre></td></tr></table></figure><p>网络方式通过bootz启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">nfs 80800000 192.168.192.100:/home/frank/linuxMini/nfs_dir/zImage<br>nfs 83000000 192.168.192.100:/home/frank/linuxMini/nfs_dir/imx6ull-14x14-emmc-4.3-480x272-c.dtb<br>bootz 80800000 - 83000000<br></code></pre></td></tr></table></figure><h4 id="bootm"><a href="#bootm" class="headerlink" title="bootm"></a>bootm</h4><p>bootm 和 bootz 功能类似，但是 bootm 用于启动 uImage 镜像文件。</p><h4 id="boot"><a href="#boot" class="headerlink" title="boot"></a>boot</h4><p>boot 命令也是用来启动 Linux 系统的，只是 boot 是通过读取环境变量 bootcmd 来启动 Linux 系统。</p><p>原始的<code>bootcmd</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">run findfdt;<br>mmc dev $&#123;mmcdev&#125;;<br>mmc dev $&#123;mmcdev&#125;;<br>if mmc rescan;<br>then if run loadbootscript;<br>then run bootscript;<br>else if run loadimage;<br>then run mmcboot;<br>else run netboot;<br>fi; <br>fi; <br>else run netboot; <br>fi<br><br>&#x27;run findfdt;mmc dev $&#123;mmcdev&#125;;mmc dev $&#123;mmcdev&#125;;if mmc rescan;then if run loadbootscript;then run bootscript;else if run loadimage;then run mmcboot;else run netboot;fi;fi;else run netboot;fi&#x27;<br></code></pre></td></tr></table></figure><h1 id="Linux-Kernel-内核"><a href="#Linux-Kernel-内核" class="headerlink" title="Linux Kernel 内核"></a>Linux Kernel 内核</h1><p>Linux 由 Linux 基金会管理与发布，Linux 官网为 <a href="https://www.kernel.org/">https://www.kernel.org</a></p><p>Linux内核和Uboot也是类似，有linux原生代码，和NXP维护测试ok的代码。</p><h2 id="Kernel的编译"><a href="#Kernel的编译" class="headerlink" title="Kernel的编译"></a>Kernel的编译</h2><p>编译内核之前需要先在 ubuntu 上安装 <code>lzop</code> 库，否则内核编译会失败！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install lzop<br></code></pre></td></tr></table></figure><h2 id="Kernel文件解析"><a href="#Kernel文件解析" class="headerlink" title="Kernel文件解析"></a>Kernel文件解析</h2><h3 id="arch"><a href="#arch" class="headerlink" title="arch"></a>arch</h3><p><code>arch/arm/configs</code> 中就包含有 I.MX6U-ALPHA 开发板的默认配置文件。</p><p><code>arch/arm/boot/dts</code> 目录里面是对应开发平台的设备树文件(.dtb文件)。</p><p><strong><code>arch/arm/boot</code> 目录下会保存编译出来的 Im age 和 zImage 镜像文件，而 zImage 就是我们要用的 linux 镜像文件。</strong><br><code>arch/arm/mach-xxx</code> 目录分别为相应平台的驱动和初始化文件，比如 mach-imx 目录里面就是 I.MX 系列 CPU 的驱动和初始化文件。</p><h3 id="drivers"><a href="#drivers" class="headerlink" title="drivers"></a>drivers</h3><p>驱动目录文件，此目录根据驱动类型的不同，分门别类进行整理，比如 drivers&#x2F;i2c 就是 I2C相关驱动目录，<code>drivers/gpio</code> 就是 GPIO 相关的驱动目录，这是我们学习的重点。</p><h1 id="Rootfs-根文件系统"><a href="#Rootfs-根文件系统" class="headerlink" title="Rootfs 根文件系统"></a>Rootfs 根文件系统</h1><p>Linux 中的根文件系统更像是一个文件夹或者叫做目录，在这个目录里面会有很多的子目录。根目录下和子目录中会有很多的文<br>件，这些文件是 Linux 运行所必须的，比如库、常用的软件和命令、设备文件、配置文件等等。</p><p>根文件系统是内核启动时所mount的第一个文件系统，内核代码映像文件保存在根文件系统中，而系统引导启动程序会在根文件系统挂载之后从中把一些基本的初始化脚本和服务等加载到内存中去运行。</p><h2 id="rootfs的构建-busybox"><a href="#rootfs的构建-busybox" class="headerlink" title="rootfs的构建 (busybox)"></a>rootfs的构建 (busybox)</h2><p>usyBox 是一个集成了大量的 Linux 命令和工具的软件，像 ls、mv、ifconfig 等命令 BusyBox 都会提供。BusyBox 就是一<br>个大的工具箱，这个工具箱里面集成了 Linux 的许多工具和命令。一般下载 BusyBox 的源码，然后配置 BusyBox，选择自己想要的功能，最后编译即可。</p><p>BusyBox 官网：<a href="https://busybox.net/">https://busybox.net/</a></p><ol><li><p>我们自己下载对应版本的busybox，这里示例版本是<code>busybox-1.35.0</code>。<br> 对于现在2023年7月25日来说<code>busybox-1.36.1</code>这个版本太新了容易有一些问题，暂时不用。</p></li><li><p>下载对应版本的源码后我们先编辑顶层<code>Makefile</code>，编辑<code>CROSS_COMPILE ?= arm-linux-gnueabihf-</code>，指定编译器。</p></li><li><p><code>busybox</code>的官方不支持中文，所以需要修改一些代码来完成对中文的支持。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c">diff -Nura a/libbb/printable_string.c b/libbb/printable_string.c<br>--- a/libbb/printable_string.c <span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-12</span> <span class="hljs-number">06</span>:<span class="hljs-number">27</span>:<span class="hljs-number">20.785120436</span> <span class="hljs-number">-0500</span><br>+++ b/libbb/printable_string.c <span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-12</span> <span class="hljs-number">06</span>:<span class="hljs-number">40</span>:<span class="hljs-number">37.481954486</span> <span class="hljs-number">-0500</span><br>@@ <span class="hljs-number">-28</span>,<span class="hljs-number">8</span> +<span class="hljs-number">28</span>,<span class="hljs-number">10</span> @@<br>&#125;<br><span class="hljs-keyword">if</span> (c &lt; <span class="hljs-string">&#x27; &#x27;</span>)<br>    <span class="hljs-keyword">break</span>;<br>-  <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-number">0x7f</span>)<br>+  <span class="hljs-comment">/*support chinese display*/</span><br>+  <span class="hljs-comment">/*if (c &gt;= 0x7f)</span><br><span class="hljs-comment">    break;</span><br><span class="hljs-comment">+  */</span><br>s++;<br>&#125;<br><br>@@ <span class="hljs-number">-42</span>,<span class="hljs-number">7</span> +<span class="hljs-number">44</span>,<span class="hljs-number">9</span> @@<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c = *d;<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;\0&#x27;</span>)<br>    <span class="hljs-keyword">break</span>;<br>-   <span class="hljs-keyword">if</span> (c &lt; <span class="hljs-string">&#x27; &#x27;</span> || c &gt;= <span class="hljs-number">0x7f</span>)<br>+   <span class="hljs-comment">/*support chinese display*/</span><br>+   <span class="hljs-comment">/*if (c &lt; &#x27; &#x27; || c &gt;= 0x7f)*/</span><br>+   <span class="hljs-keyword">if</span> (c &lt; <span class="hljs-string">&#x27; &#x27;</span> )<br>    *d = <span class="hljs-string">&#x27;?&#x27;</span>;<br>    d++;<br>&#125;<br>diff -Nura a/libbb/unicode.c b/libbb/unicode.c<br>--- a/libbb/unicode.c <span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-12</span> <span class="hljs-number">06</span>:<span class="hljs-number">28</span>:<span class="hljs-number">37.601117822</span> <span class="hljs-number">-0500</span><br>+++ b/libbb/unicode.c <span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-12</span> <span class="hljs-number">06</span>:<span class="hljs-number">44</span>:<span class="hljs-number">05.502420078</span> <span class="hljs-number">-0500</span><br>@@ <span class="hljs-number">-1019</span>,<span class="hljs-number">7</span> +<span class="hljs-number">1019</span>,<span class="hljs-number">9</span> @@<br>    <span class="hljs-keyword">while</span> ((<span class="hljs-type">int</span>)--width &gt;= <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">break</span>;<br>    &#125;<br>-    *d++ = (c &gt;= <span class="hljs-string">&#x27; &#x27;</span> &amp;&amp; c &lt; <span class="hljs-number">0x7f</span>) ? c : <span class="hljs-string">&#x27;?&#x27;</span>;<br>+    <span class="hljs-comment">/*support chinese display*/</span><br>+    <span class="hljs-comment">/**d++ = (c &gt;= &#x27; &#x27; &amp;&amp; c &lt; 0x7f) ? c : &#x27;?&#x27;;*/</span><br>+    *d++ = (c &gt;= <span class="hljs-string">&#x27; &#x27;</span>) ? c : <span class="hljs-string">&#x27;?&#x27;</span>;<br>    src++;<br>    &#125;<br>    *d = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>@@ <span class="hljs-number">-1027</span>,<span class="hljs-number">7</span> +<span class="hljs-number">1029</span>,<span class="hljs-number">9</span> @@<br>    d = dst = xstrndup(src, width);<br>    <span class="hljs-keyword">while</span> (*d) &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c = *d;<br>-    <span class="hljs-keyword">if</span> (c &lt; <span class="hljs-string">&#x27; &#x27;</span> || c &gt;= <span class="hljs-number">0x7f</span>)<br>+    <span class="hljs-comment">/* support chinese display*/</span><br>+    <span class="hljs-comment">/*if (c &lt; &#x27; &#x27; || c &gt;= 0x7f)*/</span><br>+    <span class="hljs-keyword">if</span> (c &lt; <span class="hljs-string">&#x27; &#x27;</span>)<br>    *d = <span class="hljs-string">&#x27;?&#x27;</span>;<br>    d++;<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p><code>busybox</code>的配置。</p><ol><li><p>先对busybox进行默认选项配置，再在这个基础上进行微调。</p></li><li><p>运行<code>make defconfig</code>，进行默认选项配置。<br> busybox有以下几种配置选项。</p><ol><li>defconfig，缺省配置，也就是默认配置选项。</li><li>allyesconfig，全选配置，也就是选中 busybox 的所有功能。</li><li>allnoconfig，最小配置。</li></ol></li><li><p>打开图像界面进行微调，<code>make menuconfig</code>。</p><ol><li><p>选中 这些选项</p> <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">Settings-&gt; [*] vi-style line editing commands<br>Settings-&gt; [*] Support Unicode<br>Settings-&gt; [*] Check $LC_ALL, $LC_CTYPE and $LANG environment variables<br></code></pre></td></tr></table></figure></li></ol></li><li><p>配置结束</p></li></ol></li><li><p><code>busybox</code>的编译安装</p><ol><li><p>配置好 busybox 以后就可以编译了，我们要将编译结果存储到前面创建的 rootfs 目录中，之后将这个目录作为nfs的server文件夹，用于开发板的rootfs挂载。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">make<br>make install CONFIG_PREFIX=/home/frank/linuxMini/nfs_dir/rootfs<br></code></pre></td></tr></table></figure></li><li><p>我们查看rootfs的输出文件夹 <code>/home/frank/linuxMini/nfs_dir/rootfs</code>。</p>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span></span><br>bin  linuxrc  sbin  usr<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">rootfs 目录下有 bin、sbin 和 usr 这三个目录，以及 linuxrc 这个文件。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">前面说过 Linux 内核 init 进程最后会查找用户空间的 init 程序，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">找到以后就会运行这个用户空间的 init 程序，从而切换到用户态。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果 bootargs 设置 init=/linuxrc，那么 linuxrc 就是可以作为用户空间的 init 程序，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">所以用户态空间的 init 程序是 busybox 来生成的</span><br></code></pre></td></tr></table></figure></li></ol></li><li><p><code>busybox</code>完善</p><ol><li><p>可以看出来这个rootfs缺失很多文件，lib，ev、proc、mnt、sys、tmp 和 root 等</p></li><li><p>创建缺失的文件夹</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir dev proc mnt sys tmp root lib usr/lib -p<br></code></pre></td></tr></table></figure></li><li><p>先添加lib文件，为了方便直接将所有的库文件都拷贝进去，这块后续可以根据用到的库文件做优化。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">拷贝 /lib</span><br>cd /usr/local/arm/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/arm-linux-<br>gnueabihf/libc/lib<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">“-d”表示拷贝符号链接</span><br>cp *so* *.a /home/frank/linuxMini/nfs_dir/rootfs/lib/ -d<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">ld-linux-armhf.so.3 会链接到 ld-2.19-2014.08-1-git.so 上我们将这个符号链接删掉，<span class="hljs-built_in">cp</span>一份原来的文件代替</span><br>cd /home/frank/linuxMini/nfs_dir/rootfs/lib/<br>rm ld-linux-armhf.so.3<br>cp ld-2.19-2014.08-1-git.so ld-linux-armhf.so.3<br><br>cd /usr/local/arm/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/arm-linux-gnueabihf/lib<br>cp *so* *.a /home/frank/linuxMini/nfs_dir/rootfs/lib/ -d<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">拷贝 /usr/lib</span><br>cd /usr/local/arm/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/arm-linux-gnueabihf/libc/usr/lib<br>cp *so* *.a /home/frank/linuxMini/nfs_dir/rootfs/usr/lib/ -d<br></code></pre></td></tr></table></figure></li><li><p>给rootfs添加<code>/etc/init.d/rcS</code>文件</p><ol><li><p>创建<code>/etc/init.d/rcS</code>文件</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/sh</span><br><br>PATH=/sbin:/bin:/usr/sbin:/usr/bin:$PATH<br>LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/lib:/usr/lib<br>export PATH LD_LIBRARY_PATH<br>mount -a<br>mkdir /dev/pts<br>mount -t devpts devpts /dev/pts<br><br>echo /sbin/mdev &gt; /proc/sys/kernel/hotplug<br>mdev -s<br></code></pre></td></tr></table></figure><blockquote><p>rcS 是个 shell 脚本，Linux 内核启动以后需要启动一些服务，而 rcS 就是规定启动哪些文件的脚本文件。</p><p>第 1 行，表示这是一个 shell 脚本。<br>第 3 行，PATH 环境变量保存着可执行文件可能存在的目录，这样我们在执行一些命令或 者可执行文件的时候就不会提示找不到文件这样的错误。<br>第 4 行，LD_LIBRARY_PATH 环境变量保存着库文件所在的目录。<br>第 5 行，使用 export 来导出上面这些环境变量，相当于声明一些“全局变量”。<br>第 7 行，使用 mount 命令来挂载所有的文件系统，这些文件系统由文件&#x2F;etc&#x2F;fstab 来指定， 所以我们一会还要创建&#x2F;etc&#x2F;fstab 文件。<br>第 8 和 9 行，创建目录&#x2F;dev&#x2F;pts，然后将 devpts 挂载到&#x2F;dev&#x2F;pts 目录中。<br>第 11 和 12 行，使用 mdev 来管理热插拔设备，通过这两行，Linux 内核就可以在&#x2F;dev 目录下自动创建设备节点。</p></blockquote></li><li><p>将上面文件存储到<code>/etc/init.d/rcS</code>文件中，并给它加上可执行权限。</p></li></ol></li><li><p>给rootfs添加<code>/etc/fstab</code>文件</p><ul><li>fstab 在 Linux 开机以后自动配置哪些需要自动挂载的分区，格式如下：</li></ul> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">&lt;file system&gt; &lt;mount point&gt; &lt;<span class="hljs-built_in">type</span>&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt;</span><br>proc            /proc        proc    defaults   0      0<br>tmpfs           /tmp         tmpfs   defaults   0      0<br>sysfs           /sys         sysfs   defaults   0      0<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;file system&gt; &lt;mount point&gt; &lt;<span class="hljs-built_in">type</span>&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment"># &lt;file system&gt;：要挂载的特殊的设备，也可以是块设备，比如/dev/sda 等等。</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;mount point&gt;：挂载点。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;<span class="hljs-built_in">type</span>&gt;：文件系统类型，比如 ext2、ext3、proc、romfs、tmpfs 等等。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;options&gt;：挂载选项，在 Ubuntu 中输入“man mount”命令可以查看具体的选项。一般使用 defaults，也就是默认选项，defaults 包含了 rw、suid、 dev、 <span class="hljs-built_in">exec</span>、 auto、 nouser 和 async。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;dump&gt;：为 1 的话表示允许备份，为 0 不备份，一般不备份，因此设置为 0。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;pass&gt;：磁盘检查设置，为 0 表示不检查。根目录‘/’设置为 1，其他的都不能设置为 1，其他的分区从 2 开始。一般不在 fstab 中挂载根目录，因此这里一般设置为 0。</span><br></code></pre></td></tr></table></figure></li><li><p>给rootfs添加<code>/etc/inittab</code>文件</p><ul><li>init 程序会读取&#x2F;etc&#x2F;inittab这个文件，inittab 由若干条指令组成。每条指令的结构都是一样的，由以“:”分隔的 4 个段组成</li></ul> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">etc/inittab</span><br>::sysinit:/etc/init.d/rcS<br>console::askfirst:-/bin/sh<br>::restart:/sbin/init<br>::ctrlaltdel:/sbin/reboot<br>::shutdown:/bin/umount -a -r<br>::shutdown:/sbin/swapoff -a<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;<span class="hljs-built_in">id</span>&gt;:&lt;runlevels&gt;:&lt;action&gt;:&lt;process&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;<span class="hljs-built_in">id</span>&gt;：每个指令的标识符，不能重复。但是对于 busybox 的 init 来说，&lt;<span class="hljs-built_in">id</span>&gt;有着特殊意义。对于 busybox 而言&lt;<span class="hljs-built_in">id</span>&gt;用来指定启动进程的控制 <span class="hljs-built_in">tty</span>，一般我们将串口或者 LCD 屏幕设置为控制 <span class="hljs-built_in">tty</span>。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;runlevels&gt;：对 busybox 来说此项完全没用，所以空着。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;action&gt;：动作，用于指定&lt;process&gt;可能用到的动作。</span><br>    sysinit<br>        在系统初始化的时候 process 才会执行一次。<br>    respawn<br>        当 process 终止以后马上启动一个新的。<br>    askfirst<br>        和 respawn 类似，在运行 process 之前在控制台上显示“Please press Enter to activate this console.”。只要用户按下“Enter”键以后才会执行 process。<br>    wait<br>        告诉 init，要等待相应的进程执行完以后才能继续执行。<br>    once<br>        仅执行一次，而且不会等待 process 执行完成。<br>    restart<br>        当 init 重启的时候才会执行 procee。<br>    ctrlaltdel<br>        当按下 ctrl+alt+del 组合键才会执行 process。<br>    shutdown<br>        关机的时候执行 process。<br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;process&gt;：具体的动作，比如程序、脚本或命令等。</span><br></code></pre></td></tr></table></figure></li></ol></li><li><p><code>busybox</code>搭建完成。</p></li></ol><h2 id="buildroot-配置-rootfs"><a href="#buildroot-配置-rootfs" class="headerlink" title="buildroot 配置 rootfs"></a>buildroot 配置 rootfs</h2><blockquote><p>《第三篇 系统移植篇》我们最后讲解了如何使用 busybox 构建文件系统，busybox 仅仅只是帮我们构建好了一些常用的命令和文件，像 lib 库、&#x2F;etc 目录下的一些文件都需要我们自己手动创建，而且 busybox 构建的根文件系统默认没有用户名和密码设置。在后续的实验中，我们还要自己去移植一些第三方软件和库，比如 alsa、iperf、mplayer 等等。那么有没有一种傻瓜式的方法或软件，它不仅包含了 busybox 的功能，而且里面还集成了各种软件，需要什么软件就选择什么软件，不需要我们去移植。答案肯定是有的，buildroot 就是这样一种工具，buildroot 比 busybox 更上一层楼，buildroot 不仅集成了 busybox，而且还集成了各种常见的第三方库和软件，需要什么就选择什么，就跟我们去吃自助餐一样，想吃什么就拿什么。buildroot 极大的方便了我们嵌入式 Linux 开发人员构建实用的根文件系统。</p></blockquote><ol><li><p>下载buildroot <a href="https://buildroot.org/">https://buildroot.org/</a></p><ol><li>解压</li></ol></li><li><p><code>make menuconfig</code> 执行配置</p><p> 1. </p><pre><code class="hljs"> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">这里主要是配置架构相关的内容</span><br>Target options<br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">Target Architecture = ARM (little endian)</span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">Target Binary Format = ELF</span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">Target Architecture Variant = cortex-A7</span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">Target ABI = EABIhf</span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">Floating point strategy = NEON/VFPv4</span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">ARM instruction <span class="hljs-built_in">set</span> = ARM</span><br></code></pre></td></tr></table></figure></code></pre><p> 2. </p><pre><code class="hljs"> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Toolchain 这里主要是配置交叉编译链</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这里设置为我们自己所使用的交叉编译器即可。buildroot 其实是可以自动下载交叉编译器的，但是都是从国外服务器下载的，鉴于国内的网络环境，强烈推荐大家设置成自己所使用的交叉编译器。</span><br><br>Toolchain<br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">Toolchain <span class="hljs-built_in">type</span> = External toolchain</span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">Toolchain = Custom toolchain <span class="hljs-comment">#用户自己的交叉编译器</span></span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">Toolchain origin = Pre-installed toolchain <span class="hljs-comment">#预装的编译器</span></span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">Toolchain path =/usr/local/arm/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf  <span class="hljs-comment"># 绝对路径</span></span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">Toolchain prefix = $(ARCH)-linux-gnueabihf <span class="hljs-comment">#置交叉编译器前缀，要根据自己实际所使用的交叉编译器来设置，比如我们使用的是 arm-linux-gnueabihf-gcc，因此前缀就是$(ARCH)-linux-gnueabihf，其中 ARCH我们前面已经设置为了 arm。</span></span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">External toolchain gcc version = 4.9.x</span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">External toolchain kernel headers series = 4.1.x</span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">External toolchain C library = glibc/eglibc</span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">[*] Toolchain has SSP support? (NEW) <span class="hljs-comment">#选中</span></span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">[*] Toolchain has RPC support? (NEW) <span class="hljs-comment">#选中</span></span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">[*] Toolchain has C++ support? <span class="hljs-comment">#选中</span></span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">[*] Enable MMU support (NEW) <span class="hljs-comment">#选中</span></span><br></code></pre></td></tr></table></figure></code></pre><p> 3. </p><pre><code class="hljs"> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">系统配置</span><br>System configuration<br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">System hostname = alpha_imx6ull <span class="hljs-comment">#平台名字，自行设置</span></span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">System banner = Welcome to alpha i.mx6ull <span class="hljs-comment">#欢迎语</span></span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">Init system = BusyBox <span class="hljs-comment">#使用 busybox</span></span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">/dev management = Dynamic using devtmpfs + mdev <span class="hljs-comment">#使用 mdev</span></span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">[*] Enable root login with password (NEW) <span class="hljs-comment">#使能登录密码</span></span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">Root password = 123456 <span class="hljs-comment">#登录密码为 123456</span></span><br></code></pre></td></tr></table></figure></code></pre><p>  4. </p><pre><code class="hljs"> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">此选项配置我们最终制作的根文件系统为什么格式的</span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">Filesystem images</span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">[*] ext2/3/4 root filesystem <span class="hljs-comment">#如果是 EMMC 或 SD 卡的话就用 ext3/ext4</span></span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">ext2/3/4 variant = ext4 <span class="hljs-comment">#选择 ext4 格式</span></span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">[*] ubi image containing an ubifs root filesystem <span class="hljs-comment">#如果使用 NAND 的话就用 ubifs</span></span><br></code></pre></td></tr></table></figure></code></pre><p>  5. </p><pre><code class="hljs"> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">buildroot 不仅仅能构建根文件系统，也可以编译 linux 内核和 uboot。当配置 buildroot，使能 linux 内核和 uboot 以后 buildroot 就会自动下载最新的 linux 内核和 uboot 源码并编译。但是我们一般都不会使用 buildroot 下载的 linux 内核和 uboot，因为 buildroot 下载的 linux 和 uboot官方源码，里面会缺少很多驱动文件，而且最新的 linux 内核和 uboot 会对编译器版本号有要求，可能导致编译失败。因此我们需要配置 buildroot，关闭 linux 内核和 uboot 的编译，只使用 buildroot 来构建根文件系统</span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">Kernel</span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">[ ] Linux Kernel <span class="hljs-comment">#不要选择编译 Linux Kernel 选项！</span></span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">Bootloaders</span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">[ ] U-Boot <span class="hljs-comment">#不要选择编译 U-Boot 选项！</span></span><br></code></pre></td></tr></table></figure></code></pre><ol start="6"><li><p>接下来就是 Target packages 用来配置第三方库和软件</p></li><li><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">iperf3<br>netools<br>Target packages-&gt;Networking applications-&gt;openssh<br></code></pre></td></tr></table></figure></li></ol></li><li><p>编译 buildroot</p><ol><li><code>sudo make</code> 注意，一定要加 sudo，而且不能通过-jx 来指定多核编译<ol><li>编译过程可能会下载很多组件，可以考虑给wget添加代理</li></ol></li><li>编译完成后会在<code>output/images</code>生成根文件系统<ol><li>其中 rootfs.tar 就是打包好的根文件系统</li></ol></li></ol></li></ol><h2 id="Yocto-构建-rootfs"><a href="#Yocto-构建-rootfs" class="headerlink" title="Yocto 构建 rootfs"></a>Yocto 构建 rootfs</h2><h2 id="Yocto-和-buildroot-构建-rootfs-的差异"><a href="#Yocto-和-buildroot-构建-rootfs-的差异" class="headerlink" title="Yocto 和 buildroot 构建 rootfs 的差异"></a>Yocto 和 buildroot 构建 rootfs 的差异</h2><p>值得注意的是，Yocto 和 Buildroot 本身并不是 Linux 发行版，它们只是帮助开发人员构建基于 Linux 的嵌入式系统（选择 Yocto，您可以构建 Linux 发行版；选择 Buildroot，您可以开发用于构建发行版的根文件系统）。</p><blockquote><p><strong>为什么应该选择 Yocto</strong></p><p>尽管 Yocto 操作更复杂，但它也有很明显的优势。或许其中最大的优势就是 Yocto 拥有广泛的用户群体和支持，开发社区非常活跃，为其创建了各种新的工具、层级和特性。此外，它由 Linux 基金会出资扶持，因而也更得人心。</p><p>Yocto 的另一大好处则是它可以实现层级，用于各种任务，从功能添加，到项目版本中不可用平台的定位等，都可以实现。此外，还可以添加特殊功能，例如自定义浏览器，以便实现 Yocto 本身进一步的功能定制化。</p><p>Yocto 获得了多家半导体和电路板生产商的支持，在同类项目中，可以兼容的设备最多。也就是说，除了充满活力的 Yocto 生态系统之外，自定义 Yocto 构建还可以添加大量的 SDK、工具和功能。</p><p>正是有了这些要素，Yocto 实现了高度可定制，同时还拥有强劲的支持，可供计划构建嵌入式系统的开发人员使用。</p><p><strong>Yocto 的缺点</strong></p><p>即便如此，Yocto 也有一些缺点。一方面，入门时的学习曲线稍微有点陡峭。对于时间有限的小型单个项目或小型团队来说，使用这个工具可能根本没有意义。另一方面，众所周知，Yocto 的构建时间很长。这就降低了迭代频率，如用在时间紧迫的项目中，效果可能会不太理想。</p><p><strong>为什么应该选择 Buildroot</strong></p><p>Buildroot 的构建很简单——从运行方式到输出，都非常简便快捷。它的核心构建系统采用 Make 语言编写而成，语言十分简短，开发人员不需要学习，就能轻松理解。正如上文所述，Buildroot 使用标准的 Makefiles 和 kconfig 进行配置。Makefiles 和 kconfig 是 Linux 内核社区制作的两个工具，它们获得了广泛应用和支持。</p><p>Buildroot 要求的“企业”参与度较低，因此它也是开源社区的“宠儿”。这样就会实现更高的可定制性以及更多的能力，从而尽可能开发具有针对性的系统，满足开发团队的需求。</p><p>最后，Buildroot 还有一项极其有用的功能——它禁用了可选的构建时间设置，选择以即开即用的方式，创建尽可能小的镜像。这样大幅缩短了构建时间，减少了所需的必要计算资源（不过无法实现更灵活的构建）。对于小型团队或资源有限的团队而言，这可能是一种理想的解决方案。</p><p><strong>Buildroot 的缺点</strong></p><p>首先必须要讨论的就是它最明显的缺点——缺乏公司支持。尽管对于许多开发人员来说，这可能是一个好处，但其实它也有一些明显的不足。即，社区较小，且生态系统不太活跃。也就是说，它没有那么多的支持。由于许多开发人员更愿意专注研究应用更广泛的工具，因此，如果您遇到问题，您可能必须自己处理或学习如何解决。</p><p>Buildroot 的另一个主要缺点是它不支持增量构建。每当您需要进行更新，即使是很小的更新，您都必须从头开始重新制作镜像。这样必定会使开发周期延长，增加不必要的时间。</p><p>此外，Buildroot 最大的亮点就是其注重简约，但这也意味着，相比 Yocto，Buildroot 定制和特殊系统搭建会困难得多。<br><strong>Buildroot 和 yocto的对比</strong></p><p><strong>对比内容：</strong><br>（1） 嵌入式构建系统<br>目标是构建一个完整的，客制化的嵌入式Linux系统<br>包括root filesystem， toolchain， kernel， bootloader<br>（2） 从源代码开始<br>（3） 使用交叉编译工具链<br>（4） 非常活跃的维护和开发工程<br>（5） 工业界广泛使用<br>（6） 有文档和培训课程<br>（7） 自由软件</p><p><strong>buildroot的通用信条</strong><br>（1） 专注于简单化<br>（2） 使用简单，理解简单，扩展简单<br>（3） 通过扩展脚本而不是buildroot本身来处理特殊情况<br>（4） 使用现存的技术&#x2F;语言：kconfig， make. (值得投入时间去学习)<br>（5） 默认小<br>（6） 目的无关的（Purpose-agnostic）<br>（7） 开放社区，没有供应商、官僚&#x2F;公司的管理</p><p><strong>yocto的通用信条</strong><br>（1） 支持主要的CPU架构<br>OpenEmbedded：仅qemu<br>Yocto Project：为一小部分机器增加支持<br>（2） 只提供核心方法，使用layers来支持更多的package和机器<br>（3） 客户的改动应该在一个单独的layer<br>（4） 多用途的构建系统：尽可能灵活的处理更多的使用情况<br>（5） 开放社区，但是该工程被公司赞助商发起的Yocto Project Advisory Board监管<br>（6） OpenEmbedded 是一个独立社区驱动的工程。</p><p><strong>buildroot 输出</strong><br>（1） 主要是根文件系统镜像<br>同时包含：工具链， 内核镜像， bootloader等<br>（2） 支持多种格式：ext2&#x2F;3&#x2F;4， ubifs， iso9600等<br>（3） 没有二进制包， 没有包管理系统<br>一些人称之为一个firmware generator<br>通过包不可能更新<br>更新需要一个完整的系统更新，像Andorid一样<br>认为部分更新是有害的</p><p><strong>Yocto 输出</strong><br>（1） 构建distribution，主要的输出是一个package feed<br>包管理系统是可选的<br>装载和更新系统的一部分是可能的<br>（2） 通过安装一些包，也可以产生根文件系统镜像。支持ext2&#x2F;3&#x2F;4， ubifs， iso9600等，也支持VM镜像：vmdk，vdi，qcow2<br>（3） 最终，镜像类或者工具，wic可用来构建磁盘镜像<br>（4） 生成image时也可以生成SDK，可以让应用开发者编译和测试他们的应用（不用集成到build中）。但是SDK必须要和image匹配。</p><p><strong>Buildroot 配置</strong><br>（1） 和Linux kernel一样使用kconfig<br>（2） 简单的{menu，x，n，g}配置接口<br>（3） 整个配置保存在一个文件 .config&#x2F;defconfig<br>（4） 定义系统的各个方面：架构，内核版本&#x2F;内核配置，bootloader，用户空间package等等。<br>（5） make menuconfig， make<br>（6） 为不同的机器构建通用的系统：单独处理<br>一个可以从fragment中构建出defconfig的工具<br>可行的，但是并非超级简单<br>每台机器完全独立的构建</p><p><strong>Yocto 配置</strong><br>（1） 配置分成几个部分：<br>Distribution 配置 （package配置，toolchain和libc选择…）<br>Machine Configuration （定义架构， CPU功能， BSP）<br>Image recipe （target安装什么package）<br>Local配置 （Distribution和默认machine选择， 编译时使用多少个线程， 是否删除build artifact）<br>（2） 有必要收集将要被使用的layers，并宣布它们。<br>（3） 允许为不同的机器构建相同的镜像，或者为同一个机器构建不同的distribution或镜像。</p><p><strong>Buildroot layers</strong><br>（1） 没有layer的概念<br>（2） 所有的包在官方repository中维护<br>（3） 添加BR2_EXTERNAL<br>允许存储包定义、配置和其他人工文件<br>一个BR2_EXTERNAL<br>通常用作专有的&#x2F;客制化的包和配置<br>仅增加包，不覆盖buildroot中的包</p><p><strong>yocto layers</strong><br>（1） layer机制允许修改和增加新package或image<br>（2） core build system， BSP和custome modifications之间明确分离<br>（3） 第三方提供为它们layers提供BSP，或者一套处理专用应用程序的方法<br>（4） Layers需要兼容和使用相同的OE branch base<br>（5） 谨防layer quality， 检查不是系统性的<br>（6） OpenEmbedded Metadata Index 列出了可用的layers，recipes，machines：<a href="https://link.zhihu.com/?target=http://layers.openembedded.org/layerindex/">http://layers.openembedded.org/layerindex/</a><br>（7） 此外，有一个强大的override机制，可以基于machine或者distribution调整recipe variables</p><p><strong>buildroot&#x2F;yocto toolchain</strong><br>相同的功能：<br>（1） 构建自己的toolchain，基于gcc、C库（glibc， uClibc， musl）<br>（2） 使用external toolchain， 对于buildroot更简单，因为内置有这个功能，对于yocto，只有在additional vendor layers正真完全支持。</p><p><strong>buildroot new package</strong><br>涉及三个文件 Config.in xxx.mk xxx.hash</p><p><strong>yocto new package</strong><br>涉及一个文件×××.bb</p><p><strong>buildroot: complexity</strong><br>（1） 设计成简单使用<br>（2） 对于core，每个建议的功能以有用性&#x2F;复杂度比来分析<br>（3） core逻辑完全使用make编写，少于1000行的code包含了230行注释：确实容易理解what、why、how；几乎和一个shell脚本一个接一个地下载、提取、构建、安装软件那样简单。<br>（4） 文档很充分，有很多资源可用<br>（5） 一个小时的talk足以描述所有内部实现（ELCE 2014）<br>（6） IRC上典型的反馈：来自Yocto，非常惊喜，使用起来这么简单。这是让我为难的第一件事。</p><p><strong>Yocto Project: complexity</strong><br>（1） 有点陡峭的学习曲线<br>（2） 核心是bitbake， 一个用python编写的单独项目（60千行代码）<br>（3） 一套class定义common task<br>（4） recipe 使用 bitbake specific language， python 和 shell 混合编写<br>（5） 日志和调试可帮助理解每个task具体做了什么<br>（6） 详细的文档，但是有很多不同的配置变量<br>（7） 并不总是容易理解最佳实践（比如， Poky 不能用于 production， distro&#x2F;image 修改不能在local.conf中做， 删除tmp&#x2F;）<br>（8） 人们依然对一些术语感到疑惑（Yocto Project， Poky， OpenEmbedded， bitbake）</p><p><strong>Buildroot packages</strong><br>（1） 1800+ packages<br>（2） Graphics: X.org, Wayland, Qt4&#x2F;Qt5, Gtk2&#x2F;Gtk3, EFL<br>（3） Multimedia: Gstreamer 0.10&#x2F;1.x, ffmpeg, Kodi, OpenGL<br>（4） Languages: Python2&#x2F;3, PHP, Lua, Perl, Erlang, Mono, Ruby, Node.js<br>（5） Networking: Apache, Samba, Dovecot, Exim, CUPS, lots of servers&#x2F;tools<br>（6） Init systems: Busybox(default), initsysv, systemd<br>（7） No support for a toolchain on the target</p><p><strong>Yocto Project packages</strong><br>（1） 几千个recipes: 对于oe-core， meta-openembedded， meta-qt5大约2200个。通过Metadata Index知道多余8400<br>（2） 大部分和buildroot一样<br>（3） 更多的语言: Java, Go, Rust, smalltalk<br>（4） 对于Qt3仍有一个起作用的layer<br>（5） meta-virtualization（Docker， KVM， LXC， Xen）和 meta-openstack layers</p><p><strong>Buildroot 依赖方法</strong><br>（1） 极简依赖， 如果一个功能可以关闭，那么默认关闭<br>（2） 很多自动依赖，比如，如果你开启OpenSSL，将自动从其他可提供SSL支持的enabled的包中获得SSL支持<br>（3） 默认毫不费力的的得到小的根文件系统</p><p><strong>Yocto Project 依赖方法</strong><br>（1） 在distribution级进行package 配置<br>开启OpenSSL将对所有package打开，但是可以对一些package关闭，相反，也可以对选定的pacakge开启一些功能。<br>（2） 可以在machine级进行修改，但是应该避免这样做<br>（3） 每个recipe可以定义自己的默认功能集，一个稳健的默认配置。</p><p><strong>Buildroot 更新&#x2F;安全</strong><br>（1） 每三个月release，两个月开发，一个月稳定<br>（2） release包含package版本更新：security 更新和major 更新<br>（3） 核心架构也可能潜在性的发生改变<br>（4） 没有LTS版本，用于需要自己处理<br>（5） 正在提供一个脚本来评估给定buildroot配置中未解决的CVE （Common Vulnerabilities &amp; Exposures）</p><p><strong>Yocto Project 更新&#x2F;安全</strong><br>（1） 每6个月release，一次在4月，一次在10月<br>（2） 可通过wiki: <a href="https://link.zhihu.com/?target=https://wiki.yoctoproject.org/wiki/Yocto_Project_v2.1_Status">https://wiki.yoctoproject.org/wiki/Yocto_Project_v2.1_Status</a>了解planning和roadmap<br>（3） 在M1和最终release之间的三个月内包含4个milestone<br>（4） 至少先前和当前release的版本有指定维护者，他们获取安全和重要的解决方法，但是没有recipe更新<br>（5） 旧版本由社区维护</p><p><strong>Buildroot 检测配置修改</strong><br>（1） Buildroot不很智能<br>（2） 当修改配置是，它不尝试检测哪些需要rebuild<br>（3） 一旦build一个package，buildroot将不rebuild它，除非你强制<br>（4） 大的配置修改需要full rebuild<br>（5） 小的配置修改可以不需要full rebuild<br>（6） 一个配置，一个build，不能配置间不能分享</p><p><strong>Yocto Project 检测配置修改</strong><br>（1） bitbake 维护一个shared State Cache允许增加的builds<br>（2） 它通过创建inputs的checksum检测task的input修改<br>（3） 该cache可在所有的builds间共享， 对于类似的machines，build很快<br>（4） 可以跨主机分享该cache，比如一个夜间服务器和一个开发机，大大加快full build</p><p><strong>Buildroot: architecture support</strong><br>（1） 支持很多架构<br>（2） ARM（64）， MIPS， PowerPC（64）， x86&#x2F;x86-64<br>（3） 也支持很多更专用的架构：Xtensa, Blackfin, ARC, m68k, SPARC, Microblaze, NIOSII; ARM noMMU, especially ARMv7-M<br>（4） 架构供应商提供援助: Imagination Technologies的MIPS, IBM的PowerPC64， Synopsys的ARC， Analog Devices的Blackfin</p><p><strong>Yocto Project: architecture support</strong><br>（1） core中， ARM， MIPS， PowerPC， X86，以及它们64bit 系列<br>（2） separate layers：Microblaze， NIOSII<br>（3） 通常芯片厂商维护他们自己的BSP layer：meta-intell， meta-altera （ARM &amp; NIOSII）， meta-atmel， meta-fsl， meta-ti， mtea-xilinx …<br>（4） 社区提供：meta-rockchip， meta-sunxi</p><p><strong>Buildroot: minimal build</strong><br>最小的build花费15分25秒，image size 2.2MB</p><p><strong>yocto project: minimal build</strong><br>最小build花费50分47秒， image size为4.9MB。如果有存在的sstate-cache，花费1分21秒</p><p><strong>License</strong><br>（1） 都可以创建一个使用许可证的列表<br>（2） 都能够检测到许可证更改<br>（3） Yocto项目可以剔除GPLv3</p><p><strong>Buildroot &amp; Yocto 选择</strong><br><strong>Buildroot</strong><br>（1） 非常专用的CPU架构<br>（2） 非常小的rootfs &lt; 8M<br>（3） 对工程师没有很大的要求<br>（4） 不支持各种mechines或者类似的系统<br>（5） 不需要包&#x2F;部分系统的更新<br>（6） 小系统</p><p><strong>yocto</strong><br>（1） 不是非常特殊的CPU架构，不是非常小的rootfs，需要有经验的工程师。<br>（2） 不是非常特殊的CPU架构，不是非常小的rootfs，需要有经验的工程师。支持几种类似的系统<br>（3） 不是非常特殊的CPU架构，不是非常小的rootfs，需要有经验的工程师。需要更新包和部分系统<br>（4） 不是非常特殊的CPU架构，不是非常小的rootfs，需要有经验的工程师。非常大的系统</p></blockquote><h2 id="Ubuntu-Base-rootfs构建"><a href="#Ubuntu-Base-rootfs构建" class="headerlink" title="Ubuntu-Base rootfs构建"></a>Ubuntu-Base rootfs构建</h2><blockquote><p>Ubuntu是 Linux 系统的一种，可以简单的将 Ubuntu 理解为一个根文件系统，和我们用 busybox、buildroot制作的根文件系统一样。</p><p>根文件系统下载地址 <a href="http://cdimage.ubuntu.com/">http://cdimage.ubuntu.com/</a> (ubuntu-base)</p><p>Ubuntu 针对不同的 CPU 架构提供相应的 ubuntu base 根文件系统，有 amd64(64 位 X86)、armhf、i386(32 位 X86)、powerpc、ppc64el 等系统的。I.MX6ULL 是 Cortex-A7 内核的 CPU，并且有硬件浮点运算单元，因此选择 <strong>armhf</strong> 版本。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">解压</span><br>tar -vxf ubuntu-base-16.04.6-base-armhf.tar.gz -C rootfs_ubuntu_1604<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装qemu虚拟机</span><br>sudo apt-get install qemu-user-static<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将 qemu-user-static 拷贝到ubuntu base目录下</span><br>cd rootfs_ubuntu_1604<br>sudo cp /usr/bin/qemu-arm-static ./usr/bin/<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">配置开发板用的rootfs</span><br>cd rootfs_ubuntu_1604<br><span class="hljs-meta prompt_"># </span><span class="language-bash">从主机复制 DNS配置文件</span><br>sudo cp /etc/resolv.conf ./etc/resolv.conf<br><span class="hljs-meta prompt_"># </span><span class="language-bash">换源 修改开发板 rootfs 的源</span><br>./etc/apt/sources.list<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在主机(虚拟机(当前执行指令的设备))中挂载根文件系统(刚刚下载的，给开发板用的根文件系统)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">相当于把主机的根文件系统改成了开发板用的根文件系统</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">把下面的脚本保存下来并添加运行权限</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">挂载脚本 例如保存为 mount.sh</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>sudo mount -t proc /proc /home/frank/linuxMini/nfs_dir/rootfs_ubuntu_1604/proc<br>sudo mount -t sysfs /sys /home/frank/linuxMini/nfs_dir/rootfs_ubuntu_1604/sys<br>sudo mount -o bind /dev /home/frank/linuxMini/nfs_dir/rootfs_ubuntu_1604/dev<br>sudo mount -o bind /dev/pts /home/frank/linuxMini/nfs_dir/rootfs_ubuntu_1604/dev/pts<br>sudo chroot /home/frank/linuxMini/nfs_dir/rootfs_ubuntu_1604<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">卸载脚本 unmount.sh</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>sudo umount /home/frank/linuxMini/nfs_dir/rootfs_ubuntu_1604/proc<br>sudo umount /home/frank/linuxMini/nfs_dir/rootfs_ubuntu_1604/sys<br>sudo umount /home/frank/linuxMini/nfs_dir/rootfs_ubuntu_1604/dev/pts<br>sudo umount /home/frank/linuxMini/nfs_dir/rootfs_ubuntu_1604/dev<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">挂载</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">执行脚本之后发现shell变了</span><br>./mount.sh<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装软件</span><br>apt update<br>apt install sudo<br>apt install vim<br>apt install net-tools<br>apt install ethtool<br>apt install net-tools<br>apt install openssh-server openssh-client<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置root密码</span><br>passwd root<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置 hostname</span><br>echo &quot;ubuntu1604&quot; &gt; /etc/hostname<br>echo &quot;127.0.0.1 localhost&quot; &gt;&gt; /etc/hosts<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">配置串口终端</span><br>ln -s /lib/systemd/system/getty@.service /etc/systemd/system/getty.target.wants/getty@ttymxc0.service<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">配置ssh</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">注意一下这些配置项</span><br>PermitRootLogin yes<br>PubkeyAuthentication yes<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">退出</span><br>exit<br>./unmount.sh<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">至此 ubuntu 配置完成 在uboot内更改启动参数就可以对这个根文件系统进行测试了</span><br><br></code></pre></td></tr></table></figure><h2 id="使用NFS挂载rootfs"><a href="#使用NFS挂载rootfs" class="headerlink" title="使用NFS挂载rootfs"></a>使用NFS挂载rootfs</h2><p>uboot 里面的 bootargs 环境变量会设置“root”的值，所以我们将 root 的值改为 NFS 挂载即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">root=/dev/nfs nfsroot=[&lt;server-ip&gt;:]&lt;root-dir&gt;[,&lt;nfs-options&gt;] ip=&lt;client-ip&gt;:&lt;server-ip&gt;:&lt;gw-ip&gt;:&lt;netmask&gt;:&lt;hostname&gt;:&lt;device&gt;:&lt;autoconf&gt;:&lt;dns0-ip&gt;:&lt;dns1-ip&gt;<br><br>&lt;server-ip&gt;：服务器 IP 地址，也就是存放根文件系统主机的 IP 地址，那就是 Ubuntu 的 IP地址，比如我的 Ubuntu 主机 IP 地址为 192.168.1.250。<br>&lt;root-dir&gt;：根文件系统的存放路径，比如我的就是/home/zuozhongkai/linux/nfs/rootfs。<br>&lt;nfs-options&gt;：NFS 的其他可选选项，一般不设置。<br>&lt;client-ip&gt;：客户端 IP 地址，也就是我们开发板的 IP 地址，Linux 内核启动以后就会使用此 IP 地址来配置开发板。此地址一定要和 Ubuntu 主机在同一个网段内，并且没有被其他的设备使用，在 Ubuntu 中使用 ping 命令 ping 一下就知道要设置的 IP 地址有没有被使用，如果不能ping 通就说明没有被使用，那么就可以设置为开发板的 IP 地址，比如我就可以设置为192.168.1.251。<br>&lt;server-ip&gt;：服务器 IP 地址，前面已经说了。<br>&lt;gw-ip&gt;：网关地址，我的就是 192.168.1.1。<br>&lt;netmask&gt;：子网掩码，我的就是 255.255.255.0。<br>&lt;hostname&gt;：客户机的名字，一般不设置，此值可以空着。<br>&lt;device&gt;：设备名，也就是网卡名，一般是 eth0，eth1….，正点原子的 I.MX6U-ALPHA 开发板的 ENET2 为 eth0，ENET1 为 eth1。如果你的电脑只有一个网卡，那么基本只能是 eth0。这里我们使用 ENET2，所以网卡名就是 eth0。<br>&lt;autoconf&gt;：自动配置，一般不使用，所以设置为 off。<br>&lt;dns0-ip&gt;：DNS0 服务器 IP 地址，不使用。<br>&lt;dns1-ip&gt;：DNS1 服务器 IP 地址，不使用。<br></code></pre></td></tr></table></figure><p>根据上面的格式 bootargs 环境变量的值如下：</p><p>“proto&#x3D;tcp”表示使用 TCP 协议，“rw”表示 nfs 挂载的根文件系统为可读可写。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">设定 bootargs 环境变量</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">linux kernel是通过读取这个环境变量来启动rootfs的</span><br>=&gt; env set bootargs &#x27;console=ttymxc0,115200 root=/dev/nfs nfsroot=192.168.192.100:/home/frank/linuxMini/nfs_dir/rootfs,proto=tcp rw ip=192.168.192.80:192.168.192.100:192.168.192.100:255.255.255.0::eth0:off&#x27;<br><br><br>=&gt; env print boot2nfs<br>boot2nfs=nfs 80800000 192.168.192.100:/home/frank/linuxMini/nfs_dir/zImage; nfs 83000000 192.168.192.100:/home/frank/linuxMini/nfs_dir/imx6ull-14x14-emmc-4.3-480x272-c.dtb; bootz 80800000 - 83000000<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">运行boot2nfs</span><br>=&gt; run boot2nfs<br></code></pre></td></tr></table></figure><h1 id="Drive-驱动"><a href="#Drive-驱动" class="headerlink" title="Drive 驱动"></a>Drive 驱动</h1><blockquote><p>Linux 中的驱动分为三大类：<strong>字符设备驱动、块设备驱动、网络设备驱动</strong>。</p><p><strong>一个设备有可能属于多种设备类型</strong>，比如 USB WIFI，其使用 USB 接口，所以属于字符设备，但是其又能上网，所以也属于网络设备驱动。</p><h3 id="字符设备驱动"><a href="#字符设备驱动" class="headerlink" title="字符设备驱动"></a>字符设备驱动</h3><p>是占用篇幅最大的一类驱动，因为字符设备最多，从最简单的点灯到 I2C、SPI、音频等都属于字符设备驱动的类型。</p><h3 id="块设备驱动"><a href="#块设备驱动" class="headerlink" title="块设备驱动"></a>块设备驱动</h3><p>所谓的块设备驱动就是存储器设备的驱动，比如 EMMC、NAND、SD 卡和 U 盘等存储设备，因为这些存储设备的特点是以<strong>存储块为基础</strong>，因此叫做块设备</p><h3 id="网络设备驱动"><a href="#网络设备驱动" class="headerlink" title="网络设备驱动"></a>网络设备驱动</h3><p>网络设备驱动，不管是有线的还是无线的，都属于网络设备驱动的范畴</p></blockquote><h2 id="字符设备驱动-1"><a href="#字符设备驱动-1" class="headerlink" title="字符设备驱动"></a>字符设备驱动</h2><h3 id="驱动调用流程"><a href="#驱动调用流程" class="headerlink" title="驱动调用流程"></a>驱动调用流程</h3><p><img src="/2021/9b4105ad/image-20231107151921777.png" alt="字符设备的函数调用"></p><p>在 Linux 中一切皆为文件，<strong>驱动加载成功以后</strong>会在“&#x2F;dev”目录下生成一个相应的文件，应用程序通过对这个名为“&#x2F;dev&#x2F;xxx”(xxx 是具体的驱动文件名字)的文件进行相应的操作即可实现对硬件的操作。</p><p>应用程序运行在用户空间，而 Linux 驱动属于内核的一部分，驱动运行于内核空间。</p><p>当我们在用户空间想要实现对内核的操作，比如使用 open 函数打开&#x2F;dev&#x2F;led 这个驱动，因为<strong>用户空间不能直接对内核进行操作</strong>，因此必须使用一个叫做“<strong>系统调用</strong>”的方法来实现从用户空间“陷入”到内核空间，这样才能实现对底层驱动的操作。</p><p>open 函数调用流程:</p><p><img src="/2021/9b4105ad/image-20231107162628528.png" alt="open 函数调用流程"></p><h3 id="驱动API函数"><a href="#驱动API函数" class="headerlink" title="驱动API函数"></a>驱动API函数</h3><p>每一个系统调用，在驱动中都有与之对应的一个驱动函数，在 Linux 内核文件 <code>include/linux/fs.h</code> 中有个叫做 <strong><code>file_operations</code></strong> 的结构体，此结构体就是 Linux 内核驱动操作函数集合，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> &#123;</span><br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span> *<span class="hljs-title">owner</span>;</span><br> <span class="hljs-type">loff_t</span> (*llseek) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span>, <span class="hljs-type">int</span>);<br> <span class="hljs-type">ssize_t</span> (*read) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">char</span> __user *, <span class="hljs-type">size_t</span>, <span class="hljs-type">loff_t</span> *);<br> <span class="hljs-type">ssize_t</span> (*write) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *, <span class="hljs-type">size_t</span>, <span class="hljs-type">loff_t</span> *);<br> <span class="hljs-type">ssize_t</span> (*read_iter) (<span class="hljs-keyword">struct</span> kiocb *, <span class="hljs-keyword">struct</span> iov_iter *);<br> <span class="hljs-type">ssize_t</span> (*write_iter) (<span class="hljs-keyword">struct</span> kiocb *, <span class="hljs-keyword">struct</span> iov_iter *);<br> <span class="hljs-type">int</span> (*iterate) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> dir_context *);<br> <span class="hljs-type">unsigned</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(*poll)</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> poll_table_struct *)</span>;<br> <span class="hljs-type">long</span> (*unlocked_ioctl) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>);<br> <span class="hljs-type">long</span> (*compat_ioctl) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>);<br> <span class="hljs-type">int</span> (*mmap) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> vm_area_struct *);<br> <span class="hljs-type">int</span> (*mremap)(<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> vm_area_struct *);<br> <span class="hljs-type">int</span> (*open) (<span class="hljs-keyword">struct</span> inode *, <span class="hljs-keyword">struct</span> file *);<br> <span class="hljs-type">int</span> (*flush) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">fl_owner_t</span> id);<br> <span class="hljs-type">int</span> (*release) (<span class="hljs-keyword">struct</span> inode *, <span class="hljs-keyword">struct</span> file *);<br> <span class="hljs-type">int</span> (*fsync) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span>, <span class="hljs-type">loff_t</span>, <span class="hljs-type">int</span> datasync);<br> <span class="hljs-type">int</span> (*aio_fsync) (<span class="hljs-keyword">struct</span> kiocb *, <span class="hljs-type">int</span> datasync);<br> <span class="hljs-type">int</span> (*fasync) (<span class="hljs-type">int</span>, <span class="hljs-keyword">struct</span> file *, <span class="hljs-type">int</span>);<br> <span class="hljs-type">int</span> (*lock) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">int</span>, <span class="hljs-keyword">struct</span> file_lock *);<br> <span class="hljs-type">ssize_t</span> (*sendpage) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> page *, <span class="hljs-type">int</span>, <span class="hljs-type">size_t</span>, <span class="hljs-type">loff_t</span> *, <span class="hljs-type">int</span>);<br> <span class="hljs-type">unsigned</span> <span class="hljs-title function_">long</span> <span class="hljs-params">(*get_unmapped_area)</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)</span>;<br> <span class="hljs-type">int</span> (*check_flags)(<span class="hljs-type">int</span>);<br> <span class="hljs-type">int</span> (*flock) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">int</span>, <span class="hljs-keyword">struct</span> file_lock *);<br> <span class="hljs-type">ssize_t</span> (*splice_write)(<span class="hljs-keyword">struct</span> pipe_inode_info *, <span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span> *, <span class="hljs-type">size_t</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>);<br> <span class="hljs-type">ssize_t</span> (*splice_read)(<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span> *, <span class="hljs-keyword">struct</span> pipe_inode_info *, <span class="hljs-type">size_t</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>);<br> <span class="hljs-type">int</span> (*setlease)(<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">long</span>, <span class="hljs-keyword">struct</span> file_lock **, <span class="hljs-type">void</span> **);<br> <span class="hljs-type">long</span> (*fallocate)(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-type">int</span> mode, <span class="hljs-type">loff_t</span> offset, <span class="hljs-type">loff_t</span> len);<br> <span class="hljs-type">void</span> (*show_fdinfo)(<span class="hljs-keyword">struct</span> seq_file *m, <span class="hljs-keyword">struct</span> file *f);<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_MMU</span><br> <span class="hljs-type">unsigned</span> (*mmap_capabilities)(<span class="hljs-keyword">struct</span> file *);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>简单介绍一下 file_operation 结构体中比较重要的、常用的函数：<br><strong>owner 拥有该结构体的模块的指针，一般设置为 THIS_MODULE。</strong><br><strong>llseek 函数</strong>用于修改文件当前的读写位置。<br><strong>read 函数用于读取设备文件。</strong><br><strong>write 函数用于向设备文件写入(发送)数据。</strong><br><strong>poll 函数</strong>是个轮询函数，用于查询设备是否可以进行非阻塞的读写。<br><strong>unlocked_ioctl 函数</strong>提供对于设备的控制功能，与应用程序中的 ioctl 函数对应。<br><strong>compat_ioctl 函数</strong>与 unlocked_ioctl 函数功能一样，区别在于在 64 位系统上，32 位的应用程序调用将会使用此函数。在 32 位的系统上运行 32 位的应用程序调用的是unlocked_ioctl。<br><strong>mmap 函数</strong>用于将设备的内存映射到进程空间中(也就是用户空间)，一般帧缓冲设备会使用此函数，比如 LCD 驱动的显存，将帧缓冲(LCD 显存)映射到用户空间中以后应用程序就可以直接操作显存了，这样就不用在用户空间和内核空间之间来回复制。<br><strong>open 函数用于打开设备文件。</strong><br><strong>release 函数</strong>用于释放(关闭)设备文件，与应用程序中的 close 函数对应。<br><strong>fasync 函数</strong>用于刷新待处理的数据，用于将缓冲区中的数据刷新到磁盘中。<br><strong>aio_fsync 函数</strong>与 fasync 函数的功能类似，只是 aio_fsync 是异步刷新待处理的数据。</p><p>这些函数并不是全部都需要实现的，可以只实现需要的部分函数。</p></blockquote><h3 id="驱动的加载卸载"><a href="#驱动的加载卸载" class="headerlink" title="驱动的加载卸载"></a>驱动的加载卸载</h3><p><strong>驱动的加载和卸载</strong></p><p>Linux 驱动有两种运行方式</p><ul><li><p>第一种是将驱动编译进 Linux 内核中</p><ul><li>当 Linux 内核启动的时候就会自动运行驱动程序</li></ul></li><li><p>第二种就是将驱动编译成模块(Linux 下模块扩展名为.ko)</p><ul><li><p>在Linux 内核启动以后使“insmod”命令加载驱动模块。</p></li><li><blockquote><p>在调试驱动的时候一般都选择将其编译为模块，这样我们修改驱动以后只需要编译一下驱动代码即可，不需要编译整个 Linux 代码。</p><p>而且在调试的时候只需要加载或者卸载驱动模块即可，不需要重启整个系统。</p></blockquote></li></ul></li></ul><p>将驱动编译为模块最大的好处就是方便开发，当驱动开发完成，确定没有问题以后就可以将驱动编译进 Linux 内核中，当然也可以不编译进 Linux 内核中，具体看自己的需求。</p><p>模块有加载和卸载两种操作，我们在编写驱动的时候需要注册这两种操作函数，模块的加载和卸载注册函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">module_init(xxx_init);   <span class="hljs-comment">//注册模块加载函数</span><br>module_exit(xxx_exit);   <span class="hljs-comment">//注册模块卸载函数</span><br></code></pre></td></tr></table></figure><p>module_init() 函数用来向 Linux 内核注册一个模块<strong>加载函数</strong>，参数 xxx_init 就是需要注册的具体函数，当使用<code>insmod</code>命令加载驱动的时候，xxx_init 这个函数就会被调用。</p><p>module_exit()函数用来向 Linux 内核注册一个模块<strong>卸载函数</strong>，参数 xxx_exit 就是需要注册的具体函数，当使用<code>rmmod</code>命令卸载具体驱动的时候 xxx_exit 函数就会被调用。</p><p>驱动加载函数和卸载函数的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 驱动入口函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">xxx_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br> <span class="hljs-comment">/* 入口函数具体内容 */</span><br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/* 驱动出口函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">xxx_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br> <span class="hljs-comment">/* 出口函数具体内容 */</span><br>&#125;<br><span class="hljs-comment">/* 将上面两个函数指定为驱动的入口和出口函数 */</span><br>module_init(xxx_init);<br>module_exit(xxx_exit);<br></code></pre></td></tr></table></figure><p>驱动编译完成后，编译出来的文件名为<code>.ko</code>我们可以通过命令去将这个文件加载、卸载。</p><p><strong>驱动加载命令</strong></p><p>驱动的加载有两个命令：</p><ul><li><p>insmod</p><ul><li><pre><code class="shell">     insmod drv.ko <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><br>  - insmod 命令不能解决模块的依赖关系，比如 drv<span class="hljs-selector-class">.ko</span> 依赖 first<span class="hljs-selector-class">.ko</span> 这个模块，就必须先使用insmod 命令加载 first<span class="hljs-selector-class">.ko</span> 这个模块，然后再加载 drv<span class="hljs-selector-class">.ko</span> 这个模块。<br><br>- modprobe<br><br>  - ```shell<br>        modprobe drv.ko<br></code></pre></td></tr></table></figure></code></pre></li><li><p>modprobe 会分析模块的依赖关系，然后会将所有的依赖模块都加载到内核中。</p></li><li><p>modprobe 命令主要智能在提供了模块的依赖性分析、错误检查、错误报告等功能</p></li></ul></li></ul><p><strong>驱动的卸载</strong></p><p>对应的驱动的卸载有两个命令：</p><ul><li><p>rmmod</p><ul><li><pre><code class="shell">    rmmod drv.ko<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">  -</span> 对应的 rmmod 也是卸载单一的驱动。<br><br><span class="hljs-bullet">-</span> modprobe -r<br><br><span class="hljs-bullet">  -</span> <span class="hljs-code">```shell</span><br><span class="hljs-code">        modprobe -r drv.ko</span><br></code></pre></td></tr></table></figure></code></pre></li><li><p>使用 modprobe 命令可以卸载掉驱动模块所依赖的其他模块。</p></li><li><p>需要注意的是这些被依赖的模块需要确保已经没有被其他模块所使用，否则就不能使用 modprobe 来卸载驱动模块。</p></li></ul></li></ul><h3 id="驱动-字符设备-的注册和注销"><a href="#驱动-字符设备-的注册和注销" class="headerlink" title="驱动(字符设备)的注册和注销"></a>驱动(字符设备)的注册和注销</h3><p>对于字符设备驱动而言，当驱动模块加载成功以后需要注册字符设备，同样，卸载驱动模块的时候也需要注销掉字符设备。</p><p>驱动注册函数和注销函数的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 原型</span><br><span class="hljs-comment">// major：主设备号，Linux 下每个设备都有一个设备号，设备号分为主设备号和次设备号两部分，这里是主设备号</span><br><span class="hljs-comment">// name：设备名字，指向一串字符串</span><br><span class="hljs-comment">// fops：结构体 file_operations 类型指针，指向设备的操作函数集合变量</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">register_chrdev</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> major, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> file_operations *fops)</span>;<br><br><span class="hljs-comment">// major：要注销的设备对应的主设备号</span><br><span class="hljs-comment">// name：要注销的设备对应的设备名</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">unregister_chrdev</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> major, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span>;<br><br><span class="hljs-comment">// 定义 file_operations 结构的变量。这个就是操作函数集合。定义在linux内核的include/linux/fs.h中</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">test_fops</span>;</span><br><span class="hljs-comment">/* 驱动入口函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">xxx_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/* 入口函数具体内容 */</span><br>    <span class="hljs-type">int</span> retvalue = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">/* 注册字符设备驱动 */</span><br>    <span class="hljs-comment">// 注册设备号为 200 名为 &quot;chrtest&quot;</span><br>    retvalue = register_chrdev(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;chrtest&quot;</span>, &amp;test_fops);<br> <span class="hljs-keyword">if</span>(retvalue &lt; <span class="hljs-number">0</span>) &#123;<br>  <span class="hljs-comment">/* 字符设备注册失败,自行处理 */</span><br> &#125;<br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 驱动出口函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">xxx_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/* 注销字符设备驱动 */</span><br>    unregister_chrdev(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;chrtest&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">/* 将上面两个函数指定为驱动的入口和出口函数 */</span><br>module_init(xxx_init);<br>module_exit(xxx_exit);<br></code></pre></td></tr></table></figure><p><strong>设备号的动态分配</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 申请设备号</span><br><span class="hljs-comment">// dev：保存申请到的设备号</span><br><span class="hljs-comment">// baseminor：次设备号起始地址，alloc_chrdev_region 可以申请一段连续的多个设备号，这些设备号的主设备号一样，但是次设备号不同，次设备号以 baseminor 为起始地址地址开始递增。一般 baseminor 为 0，也就是说次设备号从 0 开始。</span><br><span class="hljs-comment">// count：要申请的设备号数量（次设备号的差别）</span><br><span class="hljs-comment">// name：设备名字。</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">alloc_chrdev_region</span><span class="hljs-params">(<span class="hljs-type">dev_t</span> *dev, <span class="hljs-type">unsigned</span> baseminor, <span class="hljs-type">unsigned</span> count, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span><br><br><span class="hljs-comment">// 释放掉设备</span><br><span class="hljs-comment">// from：要释放的设备号</span><br><span class="hljs-comment">// count：表示从 from 开始，要释放的设备号数量</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">unregister_chrdev_region</span><span class="hljs-params">(<span class="hljs-type">dev_t</span> from, <span class="hljs-type">unsigned</span> count)</span><br></code></pre></td></tr></table></figure><h3 id="驱动文件的整体实现"><a href="#驱动文件的整体实现" class="headerlink" title="驱动文件的整体实现"></a>驱动文件的整体实现</h3><p>参考代码仓库</p><h3 id="驱动测试"><a href="#驱动测试" class="headerlink" title="驱动测试"></a>驱动测试</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">输入如下命令加载 chrdev_demo.ko 驱动文件：</span><br>insmod chrdev_demo.ko<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果使用 modprobe 加载驱动</span> <br>modprobe chrdev_demo.ko<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看当前系统中存在的模块</span><br>lsmod<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看系统中的设备 可以看到 chrdev_demo.ko 的主设备号和设备名</span><br>cat /proc/devices<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建设备节点文件</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">驱动加载成功需要在/dev 目录下创建一个与之对应的设备节点文件，应用程序就是通过操作这个设备节点文件来完成对具体设备的操作。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">其中 <span class="hljs-built_in">mknod</span> 是创建节点命令，/dev/chrdev_demo 是要创建的节点文件，c 表示这是个字符设备，237 是设备的主设备号，0 是设备的次设备号</span><br>mknod /dev/chrdev_demo c 237 0<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">卸载驱动模块</span><br>rmmod chrdev_demo.ko<br></code></pre></td></tr></table></figure><h3 id="Q-A"><a href="#Q-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><p><strong>什么是设备号？</strong></p><blockquote><p>设备号是Linux系统用来管理设备的一种方式，它由**主设备号(Major Device Number)<strong>和</strong>次设备号(Minor Device Number)**组成。</p><p>主设备号用来区分不同种类的设备，如<strong>字符设备</strong>、<strong>块设备</strong>、<strong>网络设备</strong>等，它用来表示一个特定的驱动程序。</p><p>次设备号用来区分同一类型的多个设备，如不同的硬盘、串口、网卡等，它用来表示使用该驱动程序的特定设备。</p><blockquote><p>以磁盘为例：在同一个系统中，磁盘设备的主设备号是唯一的。比如：scsi设备。次设备号只是在提供给scsi驱动程序内部使用，系统内核直接把次设备号传递给应用程序，scsi设备由驱动程序管理，我们可能有多个scsi设备，每个scsi设备都会分配一个次设备号。</p><blockquote><p>注：</p><p>主设备对应一个特定的驱动程序，所以一个系统里面所有的scsi硬盘使用的都是scsi驱动，所以他们的主设备号是一致的。</p><p>而不同的硬盘通过次设备号来做区分，保证它们的唯一性。</p><p>主设备号用来区分不同种类的设备，而次设备号用来区分同一类型的多个设备。</p></blockquote></blockquote><p>设备号可以用一个<strong>32位</strong>的无符号整数表示，其中<strong>高12位</strong>是主设备号，<strong>低20位</strong>是次设备号。</p><p>设备号可以通过<code>/dev</code>目录下的设备文件来访问，也可以通过<code>/proc/devices</code>文件来查看当前配置的设备号。<code>/proc/devices</code>类似一个类别，而<code>/dev/</code>下是某个类别下的项，由他们两个最终确定了一对多关系。</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看主设备号</span><br>cat /proc/devices<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看次设备号</span><br>ll /dev/<br><span class="hljs-meta prompt_"># </span><span class="language-bash">c 代表 char 设备  89 主设备 0 次设备</span><br>crw------- 1 root root   89,   0 Nov  7 08:23 i2c-0<br><span class="hljs-meta prompt_"># </span><span class="language-bash">b 代表 block 设备  179 主设备 1 次设备</span><br>brw-rw---- 1 root disk  179,   1 Nov  7 08:23 mmcblk1p1<br></code></pre></td></tr></table></figure></blockquote><p>设备号的分配和使用有一定的规则和约定，以保证设备的唯一性和通用性。</p><ul><li>静态设备号：有一些常用的设备号已经被 Linux 内核开发者给分配掉了，具体分配的内容可以查看文档 Documentation&#x2F;devices.txt。</li><li>动态设备号：Linux 社区推荐使用动态分配设备号，在注册字符设备之前先申请一个设备号，系统会自动给你一个没有被使用的设备号，这样就避免了冲突。</li></ul><p><strong>常见设备名称：</strong></p><blockquote><p>fb::frame缓冲<br>fd:—–:软驱<br>hd:—–:IDE 硬盘&#x2F;光驱<br>md:—–:RAID设备(Metadisk)<br>dm:—–:LVM设备(DeviceMapper)<br>xd:—–:虚拟机中的硬盘驱动器<br>tty:—–:终端设备<br>psaux:—–:PS&#x2F;2 鼠标设备<br>lp:—–:打印机<br>par:—–:并口<br>pt:—–:伪终端</p><p>s:—–:SCSI设备<br>scd:—–:SCSI音频光驱<br>sd:—–:SCSI硬盘<br>sg:—–:SCSI通用设备<br>sr:—–:SCSI数据光驱<br>st:—–:SCSI磁带<br>cdrom:—–:光驱的符号链接<br>mouse:—–:鼠标设备的符号链接<br>gpmdata:—–:伪设备<br>null:—–:写入消失<br>zero:—–:一直产生零</p></blockquote><p><strong>参考：</strong></p><p><a href="https://www.cnblogs.com/aozhejin/p/15874504.html">linux设备管理之主设备号与次设备号 - jinzi - 博客园 (cnblogs.com)</a></p></blockquote><h1 id="外设"><a href="#外设" class="headerlink" title="外设"></a>外设</h1><h2 id="LCD"><a href="#LCD" class="headerlink" title="LCD"></a>LCD</h2><p><strong>VSYNC 垂直同步脉冲（Vertical synchronization, Vsync</strong>）是加在两帧之间。跟水平同步脉冲类似，但它指示着前一帧的结束，和新一帧的开始。 垂直同步脉冲是一个持续时间比较长的脉冲。</p><p><strong>HSYNC 水平同步脉冲（Horizontal synchronization pulse, Hsync）</strong>加在两个扫描行之间。它是一个短小的脉冲，在一行扫描完成之后，它就会出现，指示着这一行扫描完成，同时它也指示着下一行将要开始。</p><h3 id="LCD屏幕的数据总线接口类型"><a href="#LCD屏幕的数据总线接口类型" class="headerlink" title="LCD屏幕的数据总线接口类型"></a>LCD屏幕的数据总线接口类型</h3><p><strong>MCU-LCD和RGB-LCD的主要差别</strong></p><blockquote><ol><li>RGB-LCD的显存(GRAM)由系统RAM充当。而MCU-LCD的显存由驱动IC决定。</li><li>显存的不一致直接导致了他们更新速率上的差异，MCU-LCD需要发送画点指令来修改驱动IC的显存，而RGB-LCD直接操作系统RAM，由DMA搬运到驱动IC。</li></ol></blockquote><h4 id="串口屏-UART-接口"><a href="#串口屏-UART-接口" class="headerlink" title="串口屏 UART 接口"></a>串口屏 UART 接口</h4><h4 id="SPI-接口"><a href="#SPI-接口" class="headerlink" title="SPI 接口"></a>SPI 接口</h4><h4 id="MCU-MPU接口"><a href="#MCU-MPU接口" class="headerlink" title="MCU MPU接口"></a>MCU MPU接口</h4><p>LCD液晶屏的MCU接口主要针对单片机的领域。</p><p>MCU接口的标准是因特尔提出的8080总线标准，因此在很多文档中用<strong>I80</strong>来指MCU接口屏。</p><p>MCU接口模式分为<strong>I(intel) 8080模式</strong>和<strong>M(Motorola) 6800</strong>模式，主要是时序的区别。数据位传输有8位，16位，18位，24位。</p><p>连线分为：CS&#x2F;RS&#x2F;RD&#x2F;WR&#x2F;。</p><p>优点是控制简单方便，无需时钟和同步信号。</p><p>缺点是要<strong>耗费GRAM</strong>，所以难以做到大屏，一般都用在4寸以下。</p><blockquote><p>i80</p><ul><li>CS 片选信号</li><li>RS (D&#x2F;I 数据&#x2F;指令选择线, 置1为写数据, 置0为写命令)</li><li>&#x2F;WR (为0表示写数据)</li><li>&#x2F;RD (为0表示读数据)</li><li>RESET 复位LCD(用固定命令系列 0 1 0来复位)</li></ul><p>m6800</p><ul><li>CS 片选信号</li><li>RS (D&#x2F;I 数据&#x2F;指令选择线, 置1为写数据, 置0为写命令)</li><li>&#x2F;WR (读写信号)</li><li>E (锁存信号)</li><li>RESET 复位LCD(用固定命令系列来复位)</li></ul><p>m6800其实际设计思想是与 I80 的思想是一样的，主要区别就是该模式的总线控制读写信号组合在一个引脚上（&#x2F;WR），而增加了一个锁存信号(E)</p></blockquote><p><img src="/2021/9b4105ad/c8e0872247ff49de99539712b5b6237f.png" alt="img"></p><h4 id="RGB接口"><a href="#RGB接口" class="headerlink" title="RGB接口"></a>RGB接口</h4><p>LCD液晶屏的RGB接口通过对红(R)、绿(G)、蓝(B)三个颜色通道的变化以及三者组合来得到丰富多彩的颜色。</p><p><strong>RGB-LCD的显存“GRAM”是由系统内存充当的，因此其大小只受限于系统内存的大小</strong>，这样RGB-LCD可以做出较大尺寸</p><p>所以LCD液晶屏的RGB接口就是分三原色输入的视频接口 。</p><p>通常一个颜色通道由8bit表示, 即每个颜色通道值得范围是0~255, 通常称<strong>RGB888&#x2F;RGB24</strong>。三个颜色通道总共能组合出约1678(256×256×256)万种色彩, 简称为1600万色或千万色, 也称为24位色。</p><p>在实际的使用中, 除了<strong>RGB888&#x2F;RGB24</strong>, 还有**RGB555、RGB565、RGB32、RGB666、RGB16、RGB24、RGB32、ARGB32(A就是alpha，透明度通道)**等等。</p><p><img src="/2021/9b4105ad/f5acc963e742489185cd4cf5d1bc774f.png" alt="img"></p><h4 id="LVDS接口"><a href="#LVDS接口" class="headerlink" title="LVDS接口"></a>LVDS接口</h4><p>LCD液晶屏的LVDS接口即Low Voltage Differential Signaling，是一种低压差分信号技术接口。</p><p>克服以TTL电平方式传输宽带高码率数据时功耗大、EMI电磁干扰大等缺点而研制的一种数字视频信号传输方式。</p><p>LVDS输出接口利用非常低的电压摆幅（约350mV）在两条PCB走线或一对平衡电缆上通过差分进行数据的传输，即低压差分信号传输。</p><p>采用LVDS输出接口，可以使得信号在差分PCB线或平衡电缆上以几百Mbit／s的速率传输，由于采用低压和低电流驱动方式，因此，实现了低噪声和低功耗。</p><h4 id="MIPI接口"><a href="#MIPI接口" class="headerlink" title="MIPI接口"></a>MIPI接口</h4><p>LCD液晶屏的MIPI接口是Mobile Industry Processor Interface的缩写。</p><p>MIPI（移动行业处理器接口）是MIPI联盟发起的为移动应用处理器制定的开放标准。</p><p>MIPI是一个比较新的标准，其规范也在不断修改和改进，目前比较成熟的接口应用有DSI(显示接口)和CSI（摄像头接口）。CSI&#x2F;DSI分别是指其承载的是针对Camera或Display应用，都有复杂的协议结构。</p><h3 id="RGB-驱动原理"><a href="#RGB-驱动原理" class="headerlink" title="RGB 驱动原理"></a>RGB 驱动原理</h3><p>主要信号线：</p><table><thead><tr><th>信号线</th><th>描述</th></tr></thead><tbody><tr><td>R[7:0]</td><td>8 根红色数据线</td></tr><tr><td>G[7:0]</td><td></td></tr><tr><td>B[7:0]</td><td></td></tr><tr><td>DE</td><td>数据使能线 Data Enable</td></tr><tr><td>VSYNC</td><td>垂直同步信号线 Vertical synchronization, Vsync</td></tr><tr><td>HSYNC</td><td>水平同步信号线 Horizontal synchronization pulse, Hsync</td></tr><tr><td>PCLK</td><td>像素时钟信号线</td></tr><tr><td></td><td></td></tr><tr><td>RESET</td><td></td></tr></tbody></table><p>同步信号示意图：</p><p><img src="/2021/9b4105ad/image-20230821122002797.png" alt="image-20230821122002797"></p><p>Timing 示意图(摘录于GC9503V)：</p><blockquote><p>在很多情况下PCLK时钟是不停歇 持续产生的。</p><p>The Pixel clock (PCLK) is running all the time without stopping, it is used for entering VS, HS, DE and DB [23:0] states when there is a rising edge of the PCLK.The PCLK can not be used as the internal clock for other functions of the display module.</p></blockquote><p><img src="/2021/9b4105ad/image-20230818180021537.png" alt="image-20230818180021537"><img src="/2021/9b4105ad/image-20230818180129919.png" alt="image-20230818180129919"></p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td><strong>HSYNC</strong></td><td><strong>Horizontal synchronization pulse, Hsync</strong></td><td><strong>水平同步信号线</strong></td></tr><tr><td>HLW&#x2F;HSPW&#x2F;THP</td><td>Horizontal Low Pulse width</td><td>HSYNC 信号宽度，也就是 HSYNC 信号持续时间。</td></tr><tr><td>HBP&#x2F;THB</td><td>Horizontal Back Porch</td><td>行同步信号后肩</td></tr><tr><td>HACT&#x2F;HOZVAL&#x2F;THD</td><td>Horizontal</td><td>显示一行数据所需的时间</td></tr><tr><td>HFP&#x2F;THF</td><td>Horizontal Front Porch</td><td>行同步信号前肩</td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><strong>VSYNC</strong></td><td><strong>Vertical synchronization, Vsync</strong></td><td><strong>垂直同步信号线</strong></td></tr><tr><td>VLW&#x2F;VSPW&#x2F;TVP</td><td>Vertical Low Pulse width</td><td></td></tr><tr><td>VBP&#x2F;TVB</td><td>Vertical Back Porch</td><td>帧同步信号后肩</td></tr><tr><td>VACT&#x2F;LINE</td><td>Vertical</td><td>显示一帧有效数据所需的时间</td></tr><tr><td>VFP&#x2F;TVF</td><td>Vertical Front Porch</td><td>帧同步信号前肩</td></tr><tr><td></td><td></td><td></td></tr><tr><td>DCLK</td><td>Data Clock</td><td>像素时钟</td></tr></tbody></table><p><strong>显示一行所需要的时间就是：</strong></p><p><code>HLW + HBP + HACT + HFP</code></p><p><strong>显示一帧所需要的时间就是：</strong></p><p><code>(HLW + HBP+ HACT + HFP)*(VLW + VBP + VACT + VFP)</code></p><p><strong>DCLK时钟的计算：</strong></p><p>根据上面的公式计算出一帧数据的时钟数假定未Vclock，帧数为Vfps。</p><p><code>DCLK = Vclock * Vfps</code></p><p>例如一帧需要<code>853440</code>个CLOCK，帧数设定为<code>60</code>，那么PCLK时钟就要设置成为<code>853440*60=51206400=51.2064M</code></p><p><strong>最小显存的计算：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">853*480 分辨率   RGB888 模式</span><br>853*480*3 = 1,228,320 Byte = 1.1714 MByte<br><span class="hljs-meta prompt_"># </span><span class="language-bash">1024*600 分辨率  ARGB8888 模式</span><br>1024*600*4 = 2457600Byte = 2.4 MByte<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>alpha_mini</tag>
      
      <tag>正点原子</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cortex-A7 基础</title>
    <link href="/2021/da01e608/"/>
    <url>/2021/da01e608/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Cortex-A7 MPCore </p><ul><li><p>1-4core</p></li><li><p>Cortex-A15(big)+Cortex-A7(LITTLE)</p></li><li><p>L1 Cache 8,16,32,64KB</p></li><li><p>L2 Choice</p></li></ul><p>Cortex-A7 MPCore 基于 ARMv7-A</p><ul><li>SIMDv2 扩展整形和浮点向量</li><li>VFPv4 高性能单双精度浮点指令</li><li>LPAE 40bit寻址 最大1TB内存</li><li>硬件虚拟化</li><li>NEON 多媒体、信号处理加速</li></ul><h1 id="运行模式"><a href="#运行模式" class="headerlink" title="运行模式"></a>运行模式</h1><p>Cortex-A7处理器有 9种处理模式，除了 User(USR)用户模式以外，其它 8 种运行模式都是特权模式。  </p><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>User(USR)</td><td>用户模式，非特权大部分程序运行的时候就处于此。</td></tr><tr><td>FIQ</td><td>快速中断模式，进入 FIQ 中断异常</td></tr><tr><td>IRQ</td><td>一般中断模式。</td></tr><tr><td>Supervisor(SVC)</td><td>超级管理员模式，特权模式，供操作系统使用。</td></tr><tr><td>Monitor(MON)</td><td>这个模式用于安全扩展模式。</td></tr><tr><td>Abort(ABT)</td><td>数据访问终止模式，用于虚拟存储以及存储保护。</td></tr><tr><td>Hyp(HYP)</td><td>用于虚拟化扩展。</td></tr><tr><td>Undef(UND)</td><td>未定义指令终止模式。</td></tr><tr><td>System(SYS)</td><td>系统模式，用于运行特权级的操作系统任务</td></tr></tbody></table><h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><p><img src="/2021/da01e608/image-20210702163336723.png" alt="image-20210702163336723"></p><ul><li>暗色代表没有物理寄存器</li></ul><p><img src="/2021/da01e608/image-20210702163355713.png" alt="image-20210702163355713"></p><h2 id="CPSR"><a href="#CPSR" class="headerlink" title="CPSR"></a>CPSR</h2><p>CPSR 是当前程序状态寄存器，该寄存器包含了条件标志位、中断禁止位、当前处理器模式标志<br>等一些状态位以及一些控制位。  </p><p>SPSR(备份程序状态寄存器)  备份CPSR的</p><p><img src="/2021/da01e608/image-20210702164501790.png" alt="image-20210702164501790"></p><ul><li><p>N(bit31)：当两个补码表示的 有符号整数运算的时候， N&#x3D;1 表示运算对的结果为负数， N&#x3D;0表示结果为正数。</p></li><li><p>Z(bit30)： Z&#x3D;1 表示运算结果为零， Z&#x3D;0 表示运算结果不为零，对于 CMP 指令， Z&#x3D;1 表示进行比较的两个数大小相等。</p></li><li><p>C(bit29)：在加法指令中，当结果产生了进位，则 C&#x3D;1，表示无符号数运算发生上溢，其它情况下 C&#x3D;0。在减法指令中，当运算中发生借位，则 C&#x3D;0，表示无符号数运算发生下溢，其它情况下 C&#x3D;1。对于包含移位操作的非加&#x2F;减法运算指令， C 中包含最后一次溢出的位的数值，对于其它非加&#x2F;减运算指令， C 位的值通常不受影响。</p></li><li><p>V(bit28)： 对于加&#x2F;减法运算指令，当操作数和运算结果表示为二进制的补码表示的带符号数时， V&#x3D;1 表示符号位溢出，通常其他位不影响 V 位。</p></li><li><p>Q(bit27)： 仅 ARM v5TE_J 架构支持，表示饱和状态， Q&#x3D;1 表示累积饱和， Q&#x3D;0 表示累积不饱和。</p></li><li><p>IT[1:0].(bit26:25)： 和 IT[7:2].(bit15:bit10)一起组成 IT[7:0]，作为 IF-THEN 指令执行状态。</p></li><li><p>J(bit24)： 仅 ARM_v5TE-J 架构支持， J&#x3D;1 表示处于 Jazelle 状态，此位通常和 T(bit5)位一起表示当前所使用的指令集：</p></li></ul><table><thead><tr><th>J</th><th>T</th><th>bref</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>ARM</td></tr><tr><td>0</td><td>1</td><td>Thumb</td></tr><tr><td>1</td><td>1</td><td>ThumbEE</td></tr><tr><td>1</td><td>0</td><td>Jazelle</td></tr></tbody></table><ul><li><p>GE[3:0].(bit19:16)： SIMD 指令有效，大于或等于。</p></li><li><p>IT[7:2].(bit15:10)： 参考 IT[1:0]。</p></li><li><p>E(bit9)： 大小端控制位， E&#x3D;1 表示大端模式， E&#x3D;0 表示小端模式。</p></li><li><p>A(bit8)： 禁止异步中断位， A&#x3D;1 表示禁止异步中断。</p></li><li><p>I(bit7)： I&#x3D;1 禁止 IRQ， I&#x3D;0 使能 IRQ。</p></li><li><p>F(bit6)： F&#x3D;1 禁止 FIQ， F&#x3D;0 使能 FIQ。</p></li><li><p>T(bit5)： 控制指令执行状态，表明本指令是 ARM 指令还是 Thumb 指令，通常和 J(bit24)一起表明指令类型，参考 J(bit24)位。</p></li><li><p>M[4:0]： 处理器模式控制位：</p><table><thead><tr><th>M[4:0]</th><th>CPU Mode</th></tr></thead><tbody><tr><td>10000</td><td>User 模式</td></tr><tr><td>10001</td><td>FIQ 模式</td></tr><tr><td>10010</td><td>IRQ 模式</td></tr><tr><td>10011</td><td>Supervisor(SVC)模式</td></tr><tr><td>10110</td><td>Monitor(MON)模式</td></tr><tr><td>10111</td><td>Abort(ABT)模式</td></tr><tr><td>11010</td><td>Hyp(HYP)模式</td></tr><tr><td>11011</td><td>Undef(UND)模式</td></tr><tr><td>11111</td><td>System(SYS)模式</td></tr></tbody></table></li></ul><p>​    </p>]]></content>
    
    
    <categories>
      
      <category>cortex_core</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cortex-a7</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WS2812驱动 SPI+DMA 无需降频 一个灯占用9Byte的RAM</title>
    <link href="/2021/aaef73f3/"/>
    <url>/2021/aaef73f3/</url>
    
    <content type="html"><![CDATA[<h1 id="WS2812驱动-STM32F103-SPI-DMA-无需降频-一个灯占用9Byte的RAM"><a href="#WS2812驱动-STM32F103-SPI-DMA-无需降频-一个灯占用9Byte的RAM" class="headerlink" title="WS2812驱动 STM32F103 SPI+DMA 无需降频 一个灯占用9Byte的RAM"></a>WS2812驱动 STM32F103 SPI+DMA 无需降频 一个灯占用9Byte的RAM</h1><p>对于WS2812不了解的朋友可以先看一下这些<br>​<a href="https://www.cnblogs.com/PureHeart/p/11349495.html">【STM32】WS2812介绍、使用SPI+DMA发送数据</a><br><img src="/2021/aaef73f3/pic_center.png" alt="ws812"></p><p>WS2812的驱动我想到的主要有三种</p><ul><li>延时</li><li>SPI</li><li>UART<br><strong>三者区分：</strong></li></ul><ol><li>延时，占用资源，需要用到ASM nop不然容易被优化，需要用示波器抓时间。</li><li>UART 起始位低，结束位高，如果要强行实现也是可以但是实现起来过于复杂，不够优美。</li><li>没有片选的功能，会占用一整个硬件SPI，觉得较为优美。</li></ol><p>在网上看了很多SPI例子都是使用 SPI的8bit数据来模拟WS2812的一个bit颜色的数据，但是由于STM32F103主频72M，要凑出来这个SPI的频率我看某些做法是进行降频，吾不喜，要么还有就是和协议时序差异挺大但是有些WS2812能运行，但是考虑到可能有些ws2812会不能兼容，吾不喜。</p><p>STM32F103 设主频72M，SPI分频数设置为32，则SPI的通信频率为2.25M，传输一位数据的时间约为444纳秒（ns）444ns 888ns 符合WS281X芯片的通信时序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//  __</span><br><span class="hljs-comment">// |  |_|   0b110  high level</span><br><span class="hljs-comment">//  _   </span><br><span class="hljs-comment">// | |__|   0b100  low level</span><br></code></pre></td></tr></table></figure><p><strong>这个方式和协议时序更加接近，占用RAM应该是笔者认为最小的了</strong><br>一个灯24bit颜色，只需要24*3&#x2F;8 &#x3D; 9Byte的Buff。</p><p><strong>写代码的时候需要注意一下大小端的问题，尽量保持大小端的兼容性</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 设置某一个WS2812</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param num </span><br><span class="hljs-comment"> * @param RGB </span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">WS2812_OneSet</span><span class="hljs-params">( <span class="hljs-type">uint8_t</span> num, <span class="hljs-type">uint32_t</span> RGB )</span><br>&#123;<br>    <span class="hljs-type">uint8_t</span> i;<br>    <span class="hljs-type">uint32_t</span> TempR = <span class="hljs-number">0</span>, TempG = <span class="hljs-number">0</span>, TempB = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//MSB First</span><br>    <span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; ++i,RGB&gt;&gt;=<span class="hljs-number">1</span> )<br>    &#123;<br>        (RGB &amp; <span class="hljs-number">0x00010000</span>) != <span class="hljs-number">0</span> ? (TempR |= (WS2812_HIG&lt;&lt;(i*<span class="hljs-number">3</span>))) : (TempR |= (WS2812_LOW&lt;&lt;(i*<span class="hljs-number">3</span>)));<br>        (RGB &amp; <span class="hljs-number">0x00000100</span>) != <span class="hljs-number">0</span> ? (TempG |= (WS2812_HIG&lt;&lt;(i*<span class="hljs-number">3</span>))) : (TempG |= (WS2812_LOW&lt;&lt;(i*<span class="hljs-number">3</span>)));<br>        (RGB &amp; <span class="hljs-number">0x00000001</span>) != <span class="hljs-number">0</span> ? (TempB |= (WS2812_HIG&lt;&lt;(i*<span class="hljs-number">3</span>))) : (TempB |= (WS2812_LOW&lt;&lt;(i*<span class="hljs-number">3</span>)));<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i )<br>    &#123;<br>        g_ws2812.Col[num].RGB.R[i] = TempR &gt;&gt; (<span class="hljs-number">16</span><span class="hljs-number">-8</span>*i);<br>        g_ws2812.Col[num].RGB.G[i] = TempG &gt;&gt; (<span class="hljs-number">16</span><span class="hljs-number">-8</span>*i);<br>        g_ws2812.Col[num].RGB.B[i] = TempB &gt;&gt; (<span class="hljs-number">16</span><span class="hljs-number">-8</span>*i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有参考的代码，有积分的给点积分用吧，没积分的可以去Github下。<br><a href="https://github.com/Jack-InGitHub/WS2812">Github</a><br><a href="https://download.csdn.net/download/weixin_42078116/14975868">CSDN下载</a></p><p>参考资料<br><a href="https://www.amobbs.com/thread-5697122-1-1.html?_dsign=01c8809d">stm32和ws2812B相对较好的方案。SPI和UART </a></p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ws2812</tag>
      
      <tag>spi</tag>
      
      <tag>dma</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机智云通信</title>
    <link href="/2021/60aa39b4/"/>
    <url>/2021/60aa39b4/</url>
    
    <content type="html"><![CDATA[<table><thead><tr><th>包头(2B)</th><th>包长度(2B)</th><th>命令(1B)</th><th>包序号(1B)</th></tr></thead><tbody><tr><td>0xFFFF</td><td>(包长度)后面的数据长度</td><td></td><td></td></tr></tbody></table><table><thead><tr><th>Flag(2B)</th><th>xxx</th><th>校验和(1B)</th></tr></thead><tbody><tr><td></td><td></td><td>和校验</td></tr></tbody></table><p>因为包头为固定 0xFFFF，对于发送方，如检测到有出现 0xFF 的数据内容，需要在 0xFF 后添加 0x55。对于接收方，如检测到非包头部分出现 0xFF，需要把紧跟其后的 0x55 移除。</p><table><thead><tr><th>命令</th><th>内容</th></tr></thead><tbody><tr><td>0x01</td><td>设备向MCU请求信息</td></tr><tr><td>0x02</td><td>MCU回复设备</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>embedded</tag>
      
      <tag>机智云</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cortex-M3基础</title>
    <link href="/2020/2651f4ca/"/>
    <url>/2020/2651f4ca/</url>
    
    <content type="html"><![CDATA[<h1 id="Cortex-M3基础"><a href="#Cortex-M3基础" class="headerlink" title="Cortex-M3基础"></a>Cortex-M3基础</h1><h2 id="寄存器组"><a href="#寄存器组" class="headerlink" title="寄存器组"></a>寄存器组</h2><p><img src="/2020/2651f4ca/image-20201030190843098.png" alt="image-20201030190843098"></p><h3 id="堆栈指针"><a href="#堆栈指针" class="headerlink" title="堆栈指针"></a>堆栈指针</h3><ul><li><p>R13在同一时间只有一个可见，这就是所谓的“banked”寄存器。R13 作为堆栈指针寄存器 (Stack Pointer，SP)。</p></li><li><p>主堆栈指针（MSP）：复位后缺省使用的堆栈指针，用于操作系统内核以及异常处理例程（包<br>括中断服务例程）</p></li><li><p>进程堆栈指针（PSP）：由用户的应用程序代码使用。</p></li></ul><h3 id="连接寄存器"><a href="#连接寄存器" class="headerlink" title="连接寄存器"></a>连接寄存器</h3><p>R14 作为连接寄存器 (Link Register，LR)，当呼叫(调用)一个子程序时，由R14 存储返回地址。</p><h3 id="程序计数寄存器"><a href="#程序计数寄存器" class="headerlink" title="程序计数寄存器"></a>程序计数寄存器</h3><p>R15 作为程序计数器 (Program Counter，PC)，指向当前的程序地址。如果修改它的值，就能改变程序的执行流。</p><h2 id="特殊功能寄存器"><a href="#特殊功能寄存器" class="headerlink" title="特殊功能寄存器"></a>特殊功能寄存器</h2><p><img src="/2020/2651f4ca/image-20201030192111032.png" alt="image-20201030192111032"></p><table><thead><tr><th>寄存器</th><th>功能</th></tr></thead><tbody><tr><td>xPSR</td><td>记录ALU 标志（0 标志，进位标志，负数标志，溢出标志），执行状态，<strong>以及当前正服务的中断号</strong>。(保存算术与逻辑标志，例如负数标志，零结果标志，溢出标志等等)</td></tr><tr><td>PRIMASK</td><td>除能所有的中断，不可屏蔽中断（NMI）不受影响。</td></tr><tr><td>FAULTMASK</td><td>除能所有的fault——NMI 依然不受影响，而且被除能的faults 会“上访”，见后续章节的叙述。</td></tr><tr><td>BASEPRI</td><td>除能所有优先级不高于某个具体数值的中断。</td></tr><tr><td>CONTROL</td><td>定义特权状态（见后续章节对特权的叙述），并且决定使用哪一个堆栈指针。(如果是具有浮点单元的 Cortex-M4 或者 Cortex-M7，控制寄存器也用来指示浮点单元当前是否在使用)</td></tr></tbody></table><h3 id="xPSR"><a href="#xPSR" class="headerlink" title="xPSR"></a>xPSR</h3><p>程序状态寄存器在其内部又被分为三个子状态寄存器：</p><ul><li>应用程序 PSR（APSR）</li><li>中断号 PSR（IPSR）</li><li>执行 PSR（EPSR）<br><img src="/2020/2651f4ca/image-20201217154557648.png" alt="image-20201217154557648"></li></ul><h3 id="PRIMASK，FAULTMASK-，BASEPRI"><a href="#PRIMASK，FAULTMASK-，BASEPRI" class="headerlink" title="PRIMASK，FAULTMASK ，BASEPRI"></a>PRIMASK，FAULTMASK ，BASEPRI</h3><p>CM3 page.41</p><h3 id="CONTROL-控制寄存器"><a href="#CONTROL-控制寄存器" class="headerlink" title="CONTROL 控制寄存器"></a>CONTROL 控制寄存器</h3><table><thead><tr><th>位</th><th>功能</th></tr></thead><tbody><tr><td>CONTROL[1]</td><td>堆栈指针选择<br/>0&#x3D;选择主堆栈指针MSP（复位后缺省值）<br/>1&#x3D;选择进程堆栈指针PSP<br/>在线程或基础级（没有在响应异常——译注），可以使用PSP。在handler 模式下，<br/>只允许使用MSP，所以此时不得往该位写1。</td></tr><tr><td>CONTROL[0]</td><td>0&#x3D;特权级的线程模式<br/>1&#x3D;用户级的线程模式<br/>Handler 模式永远都是特权级的。</td></tr></tbody></table><h2 id="操作模式和特权模式"><a href="#操作模式和特权模式" class="headerlink" title="操作模式和特权模式"></a>操作模式和特权模式</h2><p>Cortex-M 引入了操作模式(handler mode、thread mode)和特权级别(特权级和用户级)的概念，如果进入异常或中断处理则进入handler mode，其他情况则为thread mode。</p><p><img src="/2020/2651f4ca/image-20201030193232853.png" alt="image-20201030193232853"></p><p><strong>handler mode总是使用 MSP 作为堆栈</strong>，<strong>thread mode可以选择使用 MSP 或 PSP 作为堆栈</strong>，同样通过CONTROL 特殊寄存器控制。复位后，Cortex-M 默认进入线程模式、特权级、使用 MSP 堆栈。</p><p><img src="/2020/2651f4ca/image-20201030193654568.png" alt="image-20201030193654568"></p><p>这可以提供一种存储器访问的保护机制，使得普通的用户程序代码不能意外地，甚至是恶意地执行涉及到要害的操作。处理器支持两种特权级，这也是一个基本的安全模型。</p><p>举例来说，操作系统的内核通常都在特权级下执行，所有没有被MPU 禁掉的存储器都可以访问。在操作系统开启了一个用户程序后，通常都会让它在用户级下执行，从而使系统不会因某个程序的崩溃或恶意破坏而受损。</p><h2 id="内建的嵌套向量中断控制器-NVIC"><a href="#内建的嵌套向量中断控制器-NVIC" class="headerlink" title="内建的嵌套向量中断控制器(NVIC)"></a>内建的嵌套向量中断控制器(NVIC)</h2><h2 id="SVC和PendSV"><a href="#SVC和PendSV" class="headerlink" title="SVC和PendSV"></a>SVC和PendSV</h2><h3 id="SVC（系统服务调用，系统调用）"><a href="#SVC（系统服务调用，系统调用）" class="headerlink" title="SVC（系统服务调用，系统调用）"></a>SVC（系统服务调用，系统调用）</h3><p>例如，操作系统不让用户程序直接访问硬件，而是通过提供一些系统服务函数，用户程序使用SVC 发出对系统服务函数的呼叫请求，以这种方法调用它们来间接访问硬件。因此，当用户程序想要控制特定的硬件时，它就会产生一个SVC 异常，然后操作系统提供的SVC 异常服务例程得到执行，它再调用相关的操作系统函数，后者完成用户程序请求的服务。</p><p>优势：</p><ul><li>第一，它使用户程序从控制硬件的繁文缛节中解脱出来，而是由OS 负责控制具体的硬件。</li><li>第二，OS 的代码可以经过充分的测试，从而能使系统更加健壮和可靠。</li><li>第三，它使用户程序无需在特权级下执行，用户程序无需承担因误操作而瘫痪整个系统的风险。</li><li>第四，通过SVC 的机制，还让用户程序变得与硬件无关，因此在开发应用程序时无需了解硬件的操作细节，从而简化了开发的难度和繁琐度，并且使应用程序跨硬件平台移植成为可能。</li></ul><h3 id="PendSV（可悬起系统调用）"><a href="#PendSV（可悬起系统调用）" class="headerlink" title="PendSV（可悬起系统调用）"></a>PendSV（可悬起系统调用）</h3><p>PendSV ，它是可以像普通的中断一样被悬起的（不像SVC 那样会上访）。OS 可以利用它“缓期执行”一个异常——直到其它重要的任务完成后才执行动作。悬起PendSV 的方法是：手工往NVIC 的PendSV 悬起寄存器中写1。悬起后，如果优先级不够高，则将缓期等待执行。</p><p>PendSV 的典型使用场合是在上下文切换时（在不同任务之间切换）。例如发生中断时产生线程唤醒，中断会引发一个PendSV，在中断运行结束后，会进入PendSV在里面进行线程唤醒（线程切换）。</p><h1 id="一些总结和个人笔记"><a href="#一些总结和个人笔记" class="headerlink" title="一些总结和个人笔记"></a>一些总结和个人笔记</h1><h2 id="中断的入栈出栈"><a href="#中断的入栈出栈" class="headerlink" title="中断的入栈出栈"></a>中断的入栈出栈</h2><ol><li>进入异常服务例程时，自动压栈R0‐R3, R12, LR, PSR 和PC。</li><li>进入异常服务程序后，LR的值被自动更新为特殊的EXC_RETURN。</li></ol><table><thead><tr><th>数值</th><th>功能</th></tr></thead><tbody><tr><td>0xFFFF_FFF1</td><td>返回handler模式</td></tr><tr><td>0xFFFF_FFF9</td><td>返回线程模式，并使用主堆栈(SP&#x3D;MSP)</td></tr><tr><td>0xFFFF_FFFD</td><td>返回线程模式，并使用线程堆栈(SP&#x3D;PSP)</td></tr></tbody></table><ul><li><p>如果主程序在线程模式下运行， 并且在使用MSP 时被中断， 则在服务例程中LR&#x3D;0xFFFF_FFF9（主程序被打断前的LR已被自动入栈）。</p></li><li><p>如果主程序在线程模式下运行， 并且在使用PSP 时被中断， 则在服务例程中LR&#x3D;0xFFFF_FFFD（主程序被打断前的LR已被自动入栈）。</p></li></ul><ol start="3"><li>进入函数调用时也会压栈Rxxx寄存器作为传入参数。</li><li>R0作为函数的返回值。</li></ol>]]></content>
    
    
    <categories>
      
      <category>cortex_core</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cortex-m3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 杂乱学习笔记</title>
    <link href="/2020/d4436089/"/>
    <url>/2020/d4436089/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>Uboot、根文件系统、Linux</li><li>Linux驱动分为三大类，字符设备驱动、块设备驱动、网络设备驱动</li></ul><h1 id="linux-入门"><a href="#linux-入门" class="headerlink" title="linux 入门"></a>linux 入门</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p><code>user@machine: ~$</code></p><ul><li>$ 代表当前用户是普通用户</li><li># 代表当前用户是root</li></ul><h2 id="rootfs-根文件系统"><a href="#rootfs-根文件系统" class="headerlink" title="rootfs 根文件系统"></a>rootfs 根文件系统</h2><blockquote><p>  <strong>&#x2F;bin</strong><br>  存储一些二进制可执行命令文件，<code>/usr/bin</code>也存放了一些基于用户的命令文件。</p><p>  在这里，我们可以找到准备执行的 Linux 命令，如ls、cp和echo ，以及bash和csh等 shell 。</p><p>  <strong>&#x2F;sbin</strong><br>  此目录页用户存放一些可执行文件，但是此目录下的文件或者说命令只有管理员才能使用。 <code>/usr/sbin</code>也存储了许多系统命令。</p><p>  <strong>&#x2F;root</strong><br>  超级用户 root的根目录文件。 </p><p>  <strong>&#x2F;home</strong><br>  普通用户默认目录，在该目录下，每个用户都有一以本名命的文件夹。 </p><p>  <strong>&#x2F;boot</strong><br>  存放 Ubuntu系统<strong>内核镜像和引导加载文件</strong>。 </p><p>  <strong>&#x2F;media</strong><br>  <em>&#x2F;media</em>目录包含当我们将<strong>任何可移动媒体设备连接到系统时用作安装点的子目录。</strong></p><p>  <strong>&#x2F;mnt</strong><br>  通常包括系统引导后被挂载的文件点。 通常包括系统引导后被挂载的文件点。</p><p>  与&#x2F;media不同，系统会<strong>自动挂载</strong>可移动媒体，而&#x2F;mnt下我们需要<strong>手动挂载</strong>。</p><p>  <strong>&#x2F;dev</strong><br>  dev 是 device 的缩写，所以此目录下的文件都是和设备有关的，此目录下的文件都是设备文件。在 Linux 下一切皆文件，即使是硬件设备，也是以文件的形式存在的。</p><p>  <strong>&#x2F;etc</strong><br>  保存系统管理所需的<strong>配置文件</strong>和目录。 </p><p>  <strong>&#x2F;lib</strong><br>  lib 是 library 的简称，保存系统程序运行所需的库文件， <code>/usr/lib</code>下存放了一些用于普通用户的库文件。<strong>这些</strong><br>  <strong>库文件是共享库</strong>，命令和用户编写的应用程序要使用这些库文件。</p><p>  <strong>&#x2F;lost+found</strong><br>  一般为空，当系统非正常关机以后此文件夹会保存些零散文件。</p><p>  <strong>&#x2F;var</strong> (variable 可变动的)<br>  存储一些不断变化的文件 ，比如日志文件 。</p><p>  <strong>&#x2F;usr</strong>  (Unix Software Resource)<br>   Unix 操作系统软件资源目录。包括与系统用户直接有关的文件和目录，比如应程序所需库。 </p><p>  <strong>&#x2F;proc</strong><br>  虚拟目录，不实际存储在磁盘上通常用来保系统信息和进程。此目录一般是空的，当 Linux 系统启动以后会将此目录作为 proc 文件系统的挂载点，proc 是个虚拟文件系统，没有实际的存储设备。</p><p>  <strong>&#x2F;tmp</strong><br>  存储系统和用户的临时文件，该夹对所有都提供读写权限。 </p><p>  <strong>&#x2F;opt</strong><br>  可选第三方程序的存放目录。 </p><p>  <strong>&#x2F;sys</strong><br>  系统启动以后此目录作为 <strong><code>sysfs</code></strong> 文件系统的挂载点，sysfs 是一个类似于 proc 文件系统的特殊文件系统，sysfs 也是基于 ram 的文件系统，也就是说它也没有实际的存储设备。此目录是系统设备管理的重要目录，此目录通过一定的组织结构向用户提供详细的内核数据结构信息。</p></blockquote><h2 id="Shell-基本操作"><a href="#Shell-基本操作" class="headerlink" title="Shell 基本操作"></a>Shell 基本操作</h2><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p>^x(Ctrl+x)</p><p>^C终止前面运行程序</p><p>^D退出exit</p><p>^L清屏</p><p>^A光标移到到最前面</p><p>^E光标移到到最后面</p><p>^U删除光标前面所有字符</p><p>^K删除光标前面所有字符</p><p>Alt+Backspace 删除一个单词</p><p>^R搜索历史命令</p><p>Alt+.引用最后一个命令的参数等价于!$</p><p>Esc  . 同上</p><h3 id="历史命令"><a href="#历史命令" class="headerlink" title="历史命令"></a>历史命令</h3><ul><li># history </li><li>光标上下</li><li>^R搜索历史命令</li><li>!200     特定序号</li><li>!字符串     以某字符串开头的</li><li>!$     引用最后一个命令的参数</li></ul><blockquote><p>  按<code>Ctrl+R</code>可以调出 bash中曾经的历史命令,</p><p>  再次按<code>Ctrl+R</code>可以切换匹配的内容</p><p>  光标会停留在 第一次被匹配的字符上, (即使后面你再输入被匹配的字符, 光标也不移动)</p><p>  然后, 根据你的需要 来进行任何一次的操作, 都表示接受: (也就是说, 这个时候, 你就可以当作 你已经输入了这样的命令, 你就可以直接对该命令进行操作&#x2F;编辑&#x2F;修改了….)</p><p>  如:<br>  向前, 向后进行编辑: <code>ctrl+F</code>, <code>ctrl+B</code><br>  删除前面,后面的字符: <code>ctrl+D</code>,<code> ctrl+H</code><br>  移动到命令结尾,开头:<code>ctrl+E</code>,  <code>ctrl+A</code></p></blockquote><h2 id="初窥文件系统"><a href="#初窥文件系统" class="headerlink" title="初窥文件系统"></a>初窥文件系统</h2><p>在 Windows 下有 FAT、NTFS 和 exFAT 这样的文件系统，在 Linux 下的文件系统主要有 ext2、ext3、ext4 等文件系统。</p><p>Linux 还支持其他的 UNIX 文件系统，比如 XFS、JFS、UFS 等，也支持 Windows 的 FAT 文件系统和网络文件系统 NFS 等。</p><blockquote><p>  格式化：在windows 下的<strong>格式化</strong>其实我们应该理解成<strong>更换（或者说更新）文件系统</strong>，而<strong>格式化</strong>就是理解成把<strong>磁盘等等硬件设备</strong>按照<strong>文件系统的要求的格式</strong>进行划分。每个文件系统的规则都是不一样的，这也是为什么格式化之后文件都没了，因为新的文件系统规则是无法兼容旧的文件系统规则的，所以自然也就无法读取旧的文件系统的数据。</p></blockquote><p>在windows下磁盘的分区是根据盘符来加以区分，而在linux下是根据磁盘分区的挂载点（<code>mount</code>命令）来确定位置。</p><h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><blockquote><p>  linux下磁盘的操作主要是通过 fdisk 命令</p><p>  通过 fdisk 建立的磁盘 我们需要给他创建(构建)一个文件系统 创建文件系统后就能存放文件，这里用的就是 mkfs 命令去构建文件系统</p><p>  在linux下和windows下不一样的是，windows会自动分配盘符给你，但是linux需要“手动分配盘符”，linux下是没有盘符的概念，linux是基于根目录<code>/</code>的根概念，所以我们可以认为linux只有一个盘符，我们只能把磁盘挂在“树的枝叶”上，也就是某个目录，这就涉及到了mount和unmount挂载和卸载的命令。</p></blockquote><p><a href="#fdisk">点击转到 fdisk 命令</a></p><p><a href="#mkfs">点击转到 mkfs 命令</a></p><p><a href="#mount">点击转到 mount 命令</a></p><h2 id="文件类型-权限"><a href="#文件类型-权限" class="headerlink" title="文件类型&amp;权限"></a>文件类型&amp;权限</h2><h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">ls</span> -l</span><br>drwxr-xr-x 1 root root    4096 May 21  2019 vmware-tools<br>lrwxrwxrwx 1 root root      23 May 21  2019 vtrgb -&gt; /etc/alternatives/vtrgb<br>-rw-r--r-- 1 root root    4942 Apr  9  2019 wgetrc <br></code></pre></td></tr></table></figure><table><thead><tr><th>第一个字母</th><th></th></tr></thead><tbody><tr><td>-</td><td>普通文件</td></tr><tr><td>d</td><td>目录文件</td></tr><tr><td>c</td><td>字符设备文件，串口，音频等</td></tr><tr><td>b</td><td>块设备文件，U盘，硬盘等</td></tr><tr><td>l</td><td>符号链接</td></tr><tr><td>s</td><td>套接字文件</td></tr><tr><td>p</td><td>管道文件 FIFO</td></tr></tbody></table><h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><p>其后九个字母，每三个为一组。</p><ul><li>第一组表示用户的权限</li><li>第二组表示用户组的权限</li><li>第三组表示其他用户的权限</li></ul><p>列如<code>-rw-r--r-- 1 root root    4942 Apr  9  2019 wgetrc</code></p><ul><li>root用户权限是<code>rw-</code></li><li>root组的权限是<code>r--</code></li><li>其他用户权限是<code>r--</code></li></ul><table><thead><tr><th>字母</th><th>二进制</th><th>值</th><th></th></tr></thead><tbody><tr><td>r</td><td>100</td><td>4</td><td>可读权限: 如果目录没有可读权限,则无法用 ls 等命令查看目录中的文件内容.</td></tr><tr><td>w</td><td>010</td><td>2</td><td>可写权限: 如果目录没有可写权限,则无法在目录中创建文件, 也无法在目录中删除文件.</td></tr><tr><td>x</td><td>001</td><td>1</td><td>可执行权限：如果没有目录可执行权限，则无法 cd 到目录中</td></tr></tbody></table><table><thead><tr><th>字母</th><th>归属</th></tr></thead><tbody><tr><td>a</td><td>all user</td></tr><tr><td>u</td><td>user</td></tr><tr><td>g</td><td>group user</td></tr><tr><td>o</td><td>other user</td></tr></tbody></table><table><thead><tr><th>字母</th><th>操作</th></tr></thead><tbody><tr><td>&#x3D;</td><td>拥有权限</td></tr><tr><td>+</td><td>增加权限</td></tr><tr><td>-</td><td>删除权限</td></tr></tbody></table><h4 id="chmod-文件权限修改"><a href="#chmod-文件权限修改" class="headerlink" title="chmod 文件权限修改"></a>chmod 文件权限修改</h4><p>chmod [参数 ] [文件名 &#x2F;目录名]</p><table><thead><tr><th></th><th>参数</th></tr></thead><tbody><tr><td>-c</td><td>类似-v，回显更改的部分</td></tr><tr><td>-f</td><td>不显示错误信息</td></tr><tr><td>-R</td><td>递归</td></tr><tr><td>-v</td><td>显示执行过程</td></tr><tr><td>-t</td><td>粘滞位</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">修改权限</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">test_dir文件夹权限更改为 rwxrwxrwx</span><br>chmod 777 test_dir<br><span class="hljs-meta prompt_"># </span><span class="language-bash">向组用户添加rwx权限</span> <br>chmod g+rwx<br><span class="hljs-meta prompt_"># </span><span class="language-bash">递归更改为rwx权限</span><br>chmod -R 777 test_dir<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">755</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">drwxr-xr-x</span><br></code></pre></td></tr></table></figure><blockquote><p>  <strong>粘滞位</strong></p><p>  other用户可以在特定的目录下创建文件并写入，但是不想让任何人删除掉自己的文件</p></blockquote><h4 id="chown-文件夹归属修改"><a href="#chown-文件夹归属修改" class="headerlink" title="chown 文件夹归属修改"></a>chown 文件夹归属修改</h4><p>chown [参数 ] [用户名 .&lt;组名 &gt;] [文件名 &#x2F;目录 ]</p><table><thead><tr><th></th><th>参数</th></tr></thead><tbody><tr><td>-c</td><td>类似-v，回显更改的部分</td></tr><tr><td>-f</td><td>不显示错误信息</td></tr><tr><td>-h</td><td>只对符号链接修改</td></tr><tr><td>-R</td><td>递归</td></tr><tr><td>-v</td><td>显示执行过程</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">递归修改<span class="hljs-built_in">dir</span>文件夹归属者为 frank</span><br>sudo chown -Rv frank.frank dir/<br></code></pre></td></tr></table></figure><h3 id="文件夹权限"><a href="#文件夹权限" class="headerlink" title="文件夹权限"></a>文件夹权限</h3><ul><li>目录的可执行权限是表示你可否在目录下执行命令。</li><li>如果目录没有 - x 权限，则无法对目录执行任何命令，甚至无法 cd 进入目, 即使目录仍然有 - r 读权限（这个地方很容易犯错，认为有读权限就可以进入目录读取目录下的文件）</li><li>而如果目录具有 - x 权限，但没有 - r 权限，则用户可以执行命令，可以 cd 进入目录。但由于没有目录的读权限</li><li>所以在目录下，即使可以执行 ls 命令，但仍然没有权限读出目录下的文档。</li></ul><h2 id="压缩命令"><a href="#压缩命令" class="headerlink" title="压缩命令"></a>压缩命令</h2><p>zip [参数 ] [压缩文件名.zip] [被压缩的文件]</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>-r</td><td>递归压缩，将指定目录下的所有文件和子一起压缩。</td></tr><tr><td>-v</td><td>显示指令执行过程。</td></tr><tr><td>-num</td><td>压缩率，为 1~9的数值。</td></tr><tr><td>-m</td><td>压缩完成以后删除源文件。</td></tr><tr><td>-g</td><td>将文件压缩入现有压缩文件中，不需要新建。</td></tr><tr><td>-n&lt;字尾符号&gt;</td><td>不压缩特定拓展名文件</td></tr><tr><td>-P</td><td>密码</td></tr></tbody></table><p>unzip [参数 ] [压缩文件名 .zip]</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>-d</td><td>解压到指定目录</td></tr><tr><td>-P</td><td>密码</td></tr><tr><td>-v</td><td>显示指令执行过程。</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">压缩</span><br>zip -rv -9 a.zip *.jpg<br><span class="hljs-meta prompt_"># </span><span class="language-bash">解压</span><br>unzip -d a a.zip<br></code></pre></td></tr></table></figure><p><strong>.bz2 .gz .xz文件</strong></p><p>一般来说<code>bz2</code>的压缩率最高, 但是速度太慢了, <code>gz</code>压缩率比较均衡速度也比较快, <code>tar</code>只会打包不会压缩.</p><p>tar [参数 ] [压缩文件名] [被压缩文件名]</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>-c</td><td><strong>打包(将所有文件变成一个文件 Create  a new archive)</strong></td></tr><tr><td>-x</td><td><strong>解压缩, 解包</strong></td></tr><tr><td>-j</td><td>tar生成压缩文件 ，bzip2压缩</td></tr><tr><td>-z</td><td>tar生成压缩文件，gzip压缩</td></tr><tr><td>-f&lt;文件名&gt;</td><td>指定压缩文件</td></tr><tr><td>-v</td><td>显示执行过程</td></tr><tr><td>-C,–directory&#x3D;DIR</td><td>执行任何操作前请先更改为DIR。 该选项是顺序敏感的，即它影响后面的所有选项。</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">压缩 bzip2</span><br>tar -cjvf 1.tar.bz2 *.*<br><span class="hljs-meta prompt_">#</span><span class="language-bash">☆压缩 gzip</span><br>tar -czvf 1.tar.gz *.*<br><span class="hljs-meta prompt_"># </span><span class="language-bash">压缩 = c</span><br>tar -cvf a.tar /etc<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">解压 = x</span><br>tar -jxvf 1.tar.bz2<br>tar -zxvf 1.tar.gz<br><span class="hljs-meta prompt_">#</span><span class="language-bash">tar会自动检测压缩类型，并且解压缩包文件。同样的命令可以用来解压缩使用其他算法，例如：.tar.gz 或者.tar.bz2 压缩的文件。</span><br>tar -v -x -f archive.tar.xz<br>tar -v -x -f archive.tar.xz -C ./dir1<br></code></pre></td></tr></table></figure><h2 id="用户和组-管理"><a href="#用户和组-管理" class="headerlink" title="用户和组 管理"></a>用户和组 管理</h2><h3 id="etc-passwd文件"><a href="#etc-passwd文件" class="headerlink" title="/etc/passwd文件"></a><code>/etc/passwd</code>文件</h3><p>Linux 系统中的 <code>/etc/passwd</code> 文件，是系统用户配置文件，存储了系统中所有用户的基本信息，并且所有用户都可以对此文件执行读操作。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看用户和用户组</span><br>sudo cat /etc/passwd<br></code></pre></td></tr></table></figure><p>每行用户信息都以 “：” 作为分隔符，划分为 7 个字段，每个字段所表示的含义如下：</p><blockquote><p>  <strong>用户名：密码：UID（用户ID）：GID（组ID）：描述性信息：主目录：默认Shell</strong></p></blockquote><p><img src="/2020/d4436089/63d0f703918fa0ece0691081209759ee3c6ddb94.jpg"></p><blockquote><p>  读者可能会问，Linux 系统中默认怎么会有这么多的用户？这些用户中的绝大多数是系统或服务正常运行所必需的用户，这种用户通常称为系统用户或伪用户。系统用户无法用来登录系统，但也不能删除，因为一旦删除，依赖这些用户运行的服务或程序就不能正常执行，会导致系统问题。</p></blockquote><h4 id="UID-用户ID"><a href="#UID-用户ID" class="headerlink" title="UID 用户ID"></a>UID 用户ID</h4><p>UID，也就是用户 ID。每个用户都有唯一的一个 UID，Linux 系统通过 UID 来识别不同的用户。</p><p>实际上，UID 就是一个 0~65535 之间的数，不同范围的数字表示不同的用户身份，具体如表 1 所示。</p><table><thead><tr><th>UID 范围</th><th>用户身份</th></tr></thead><tbody><tr><td>0</td><td>超级用户。UID 为 0 就代表这个账号是管理员账号。在 Linux 中，如何把普通用户升级成管理员呢？只需把其他用户的 UID 修改为 0 就可以了，这一点和 Windows 是不同的。不过不建议建立多个管理员账号。</td></tr><tr><td>1~499</td><td>系统用户（伪用户）。也就是说，此范围的 UID 保留给系统使用。其中，1<del>99 用于系统自行创建的账号；100</del>499 分配给有系统账号需求的用户。  其实，除了 0 之外，其他的 UID 并无不同，这里只是默认 500 以下的数字给系统作为保留账户，只是一个公认的习惯而已。</td></tr><tr><td>500~65535</td><td>普通用户。通常这些 UID 已经足够用户使用了。但不够用也没关系，2.6.x 内核之后的 Linux 系统已经可以支持 232 个 UID 了。</td></tr></tbody></table><h4 id="GID-组ID"><a href="#GID-组ID" class="headerlink" title="GID 组ID"></a>GID 组ID</h4><p>全称“Group ID”，简称“组ID”，表示用户初始组的组 ID 号。这里需要解释一下初始组和附加组的概念。</p><p>初始组，指用户登陆时就拥有这个用户组的相关权限。每个用户的初始组只能有一个，通常就是将和此用户的用户名相同的组名作为该用户的初始组。比如说，我们手工添加用户 lamp，在建立用户 lamp 的同时，就会建立 lamp 组作为 lamp 用户的初始组。</p><p>附加组，指用户可以加入多个其他的用户组，并拥有这些组的权限。每个用户只能有一个初始组，除初始组外，用户再加入其他的用户组，这些用户组就是这个用户的附加组。附加组可以有多个，而且用户可以有这些附加组的权限。</p><p>举例来说，刚刚的 lamp 用户除属于初始组 lamp 外，我又把它加入了 users 组，那么 lamp 用户同时属于 lamp 组和 users 组，其中 lamp 是初始组，users 是附加组。</p><p>当然，初始组和附加组的身份是可以修改的，但是我们在工作中不修改初始组，只修改附加组，因为修改了初始组有时会让管理员逻辑混乱。</p><p>需要注意的是，在 &#x2F;etc&#x2F;passwd 文件的第四个字段中看到的 ID 是这个用户的初始组。</p><h3 id="etc-shadow-文件"><a href="#etc-shadow-文件" class="headerlink" title="/etc/shadow 文件"></a><code>/etc/shadow</code> 文件</h3><p><code>/etc/shadow</code> 文件，用于存储 Linux 系统中用户的密码信息，又称为“影子文件”。</p><p><a href="http://c.biancheng.net/view/840.html">参考</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看密码文件</span> <br>sudo cat /etc/shadow<br></code></pre></td></tr></table></figure><p>每行用户信息被划分为 9 个字段。每个字段的含义如下(时间的单位是天)：</p><blockquote><p>  <strong>用户名：加密密码：最后一次修改时间：最小修改时间间隔：密码有效期：密码需要变更前的警告天数：密码过期后的宽限时间：账号失效时间：保留字段</strong></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">frank@ubuntu-hyper:~$ sudo cat /etc/shadow<br>root:!:19361:0:99999:7:::<br>daemon:*:19235:0:99999:7:::<br>...<br>frank:$strstrstrssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss/:19361:0:99999:7:::<br>...<br></code></pre></td></tr></table></figure><h4 id="最后一次修改时间"><a href="#最后一次修改时间" class="headerlink" title="最后一次修改时间"></a>最后一次修改时间</h4><p>此字段表示最后一次修改密码的时间，可是，为什么 root 用户显示的是15775 呢？</p><p>这是因为，Linux 计算日期的时间是以1970 年1 月1 日（UTC&#x2F;GMT的午夜）作为1 不断累加得到的时间，到1971 年1 月1 日，则为366 天。这里显示15775 天，也就是说，此 root 账号在1970 年1 月1 日之后的第15775 天修改的 root 用户密码。</p><p>那么，到底15775 代表的是哪一天呢？可以使用如下命令进行换算：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">frank@ubuntu-hyper:~$ date -d &quot;1970-01-01 19361 days&quot;<br>2023年 01月 04日 星期三 00:00:00 CST<br></code></pre></td></tr></table></figure><p>可以看到，通过以上命令，即可将其换算为我们习惯的系统日期。</p><h3 id="etc-group文件"><a href="#etc-group文件" class="headerlink" title="/etc/group文件"></a><code>/etc/group</code>文件</h3><p>&#x2F;ect&#x2F;group 文件是用户组配置文件，即用户组的所有信息都存放在此文件中。</p><p>此文件是记录组 ID（GID）和组名相对应的文件。前面讲过，etc&#x2F;passwd 文件中每行用户信息的第四个字段记录的是用户的初始组 ID，那么，此 GID 的组名到底是什么呢？就要从 &#x2F;etc&#x2F;group 文件中查找。</p><p>各用户组中，还是以 “：” 作为字段之间的分隔符，分为 4 个字段，每个字段对应的含义为：</p><blockquote><p>  <strong>组名：密码：GID：该用户组中的用户列表</strong></p></blockquote><h3 id="user用户管理"><a href="#user用户管理" class="headerlink" title="user用户管理"></a>user用户管理</h3><h4 id="su-切换root"><a href="#su-切换root" class="headerlink" title="su 切换root"></a>su 切换root</h4><p>切换成root用户</p><p>“sudo su 用户名 ”即可切换回去</p><p>第一次运行root没有密码需要先设置一个密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs linux">sudo passwd root #输入密码就行了<br></code></pre></td></tr></table></figure><h4 id="查看用户"><a href="#查看用户" class="headerlink" title="查看用户"></a>查看用户</h4><ul><li>cat &#x2F;etc&#x2F;passwd文件就行了</li><li>看第三个参数:1000以上的,就是后面建的用户了.其它则为系统的用户</li></ul><h4 id="adduser添加用户-优"><a href="#adduser添加用户-优" class="headerlink" title="adduser添加用户(优)"></a>adduser添加用户(优)</h4><p>添加用户（需要Root权限）</p><p>会自动为创建的用户指定主目录、系统shell版本，会在创建时输入用户密码。</p><h4 id="useradd-添加用户"><a href="#useradd-添加用户" class="headerlink" title="useradd 添加用户"></a>useradd 添加用户</h4><p>需要使用参数选项指定上述基本设置，如果不使用任何参数，则创建的用户无密码、无主目录、没有指定shell版本。</p><h4 id="deluser删除用户"><a href="#deluser删除用户" class="headerlink" title="deluser删除用户"></a>deluser删除用户</h4><p>删除用户（需要Root权限）</p><h4 id="userdel-删除用户"><a href="#userdel-删除用户" class="headerlink" title="userdel  删除用户"></a>userdel  删除用户</h4><h4 id="◬-usermod-修改账号设定"><a href="#◬-usermod-修改账号设定" class="headerlink" title="◬ usermod 修改账号设定"></a><strong>◬ usermod 修改账号设定</strong></h4><p><strong>参数说明</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell">  -b, --badnames                allow bad names<br>  -c, --comment 注释            GECOS 字段的新值<br>  -d, --home HOME_DIR           用户的新主目录<br>  -e, --expiredate EXPIRE_DATE  设定帐户过期的日期为 EXPIRE_DATE<br>  -f, --inactive INACTIVE       过期 INACTIVE 天数后，设定密码为失效状态<br>  -g, --gid GROUP               强制使用 GROUP 为新主组<br>◬ -G, --groups GROUPS           新的附加组列表 GROUPS<br>  -a, --append GROUP            将用户追加至上边 -G 中提到的附加组中，<br>                                并不从其它组中删除此用户<br>  -h, --help                    显示此帮助信息并推出<br>  -l, --login LOGIN             新的登录名称<br>  -L, --lock                    锁定用户帐号<br>  -m, --move-home               将家目录内容移至新位置 (仅于 -d 一起使用)<br>  -o, --non-unique              允许使用重复的(非唯一的) UID<br>  -p, --password PASSWORD       将加密过的密码 (PASSWORD) 设为新密码<br>  -R, --root CHROOT_DIR         chroot 到的目录<br>  -P, --prefix PREFIX_DIR       prefix directory where are located the /etc/* files<br>  -s, --shell SHELL             该用户帐号的新登录 shell<br>  -u, --uid UID                 用户帐号的新 UID<br>  -U, --unlock                  解锁用户帐号<br>  -v, --add-subuids FIRST-LAST  添加子 UID 范围<br>  -V, --del-subuids FIRST-LAST  移除子 UID 范围<br>  -w, --add-subgids FIRST-LAST  添加子 GID 范围<br>  -W, --del-subgids FIRST-LAST  移除子 GID 范围<br>  -Z, --selinux-user  SEUSER       用户账户的新 SELinux 用户映射<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">示例</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将 userA 加入到 groupB 中</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Note 当时这个权限修改了但是没有生效 可能是要重开 ssh 我当时是重启主机解决的</span><br>usermod -aG userA groupB<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">修改用户说明</span><br>usermod -c &quot;test user&quot; lamp <br></code></pre></td></tr></table></figure><h4 id="passwd-设置修改密码"><a href="#passwd-设置修改密码" class="headerlink" title="passwd 设置修改密码"></a>passwd 设置修改密码</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> passwd root<br></code></pre></td></tr></table></figure><h4 id="id查看用户UID-GID-归属-组"><a href="#id查看用户UID-GID-归属-组" class="headerlink" title="id查看用户UID GID 归属 组"></a>id查看用户UID GID 归属 组</h4><h4 id="groupadd-添加用户组"><a href="#groupadd-添加用户组" class="headerlink" title="groupadd 添加用户组"></a>groupadd 添加用户组</h4><h4 id="groupdel-删除用户组"><a href="#groupdel-删除用户组" class="headerlink" title="groupdel 删除用户组"></a>groupdel 删除用户组</h4><h4 id="groupmod修改用户组信息"><a href="#groupmod修改用户组信息" class="headerlink" title="groupmod修改用户组信息"></a>groupmod修改用户组信息</h4><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><h4 id="给用户添加sudo权限-以及免除密码"><a href="#给用户添加sudo权限-以及免除密码" class="headerlink" title="给用户添加sudo权限 以及免除密码"></a>给用户添加sudo权限 以及免除密码</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">将用户添加一个附加<span class="hljs-built_in">sudo</span>群组就好</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">下面有两种方法</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1 修改group</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看<span class="hljs-built_in">sudo</span>群组的<span class="hljs-built_in">id</span></span><br>cat /etc/group | grep &#x27;sudo&#x27;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">给new_username增加一个<span class="hljs-built_in">sudo</span>群组</span><br>usermod -G 27 new_username<br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">id</span>可以看到new_username多了一个群组</span><br>id new_username<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2 修改sudoers</span><br>vim /etc/sudoers<br><span class="hljs-meta prompt_"># </span><span class="language-bash">然后在root ALL=(ALL:ALL) ALL下面添加上：</span> <br>new_username ALL=(ALL:ALL) ALL<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">免除全部密码</span><br>your_user_name ALL=(ALL) NOPASSWD: ALL<br><span class="hljs-meta prompt_"># </span><span class="language-bash">免除部分命令的密码</span><br>your_user_name   ALL= (root) NOPASSWD: /sbin/mount, (root) NOPASSWD: /bin/umount, (root) NOPASSWD: /mnt/mount, (root) NOPASSWD: /bin/rm, (root) NOPASSWD: /usr/bin/make, (root) NOPASSWD: /bin/ln, (root) NOPASSWD: /bin/sh, (root) NOPASSWD: /bin/mv, (root) NOPASSWD: /bin/chown, (root) NOPASSWD: /bin/chgrp, (root) NOPASSWD: /bin/cp, (root) NOPASSWD: /bin/chmod<br></code></pre></td></tr></table></figure><h2 id="ubuntu-apt包管理"><a href="#ubuntu-apt包管理" class="headerlink" title="ubuntu apt包管理"></a>ubuntu apt包管理</h2><h3 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 一键更换国内软件源脚本</span><br><span class="hljs-comment"># https://github.com/SuperManito/LinuxMirrors</span><br>bash &lt;(curl -sSL https:<span class="hljs-regexp">//gi</span>tee.com<span class="hljs-regexp">/SuperManito/</span>LinuxMirrors<span class="hljs-regexp">/raw/m</span>ain/ChangeMirrors.sh)<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">源网站list</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">https://www.raspbian.org/RaspbianMirrors</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">examp</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">mirrors.shu.edu.cn/raspbian/raspbian/</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">http://mirrors.aliyun.com/raspbian/raspbian/</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"></span><br><span class="language-bash"></span><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">先备份</span><br>sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak<br><span class="hljs-meta prompt_"># </span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-built_in">sudo</span> vim /etc/apt/sources.list</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">改成如下 32bit OS</span><br>deb http://mirrors.aliyun.com/raspbian/raspbian/ buster main non-free contrib rpi<br>deb-src http://mirrors.aliyun.com/raspbian/raspbian/ buster main non-free contrib rpi<br><span class="hljs-meta prompt_"># </span><span class="language-bash">64bit OS</span><br>deb https://mirrors.tuna.tsinghua.edu.cn/debian buster main contrib non-free<br>deb https://mirrors.tuna.tsinghua.edu.cn/debian-security/ buster/updates main contrib non-free<br>deb https://mirrors.tuna.tsinghua.edu.cn/debian buster-updates main contrib non-free<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">先备份</span><br>sudo cp /etc/apt/sources.list.d/raspi.list  /etc/apt/sources.list.d/raspi.list.bak<br><span class="hljs-meta prompt_"># </span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-built_in">sudo</span> nano /etc/apt/sources.list.d/raspi.list</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">改成如下</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">debian 10.x (buster)</span><br>deb http://mirrors.aliyun.com/raspbian/raspbian/ buster main ui<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">or</span> <br>deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main ui<br><span class="hljs-meta prompt_"># </span><span class="language-bash">debian 11.x (bullseye)</span><br>deb http://mirrors.aliyun.com/raspbian/raspbian/ bullseye main<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">ubuntu 20.04</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">添加阿里源</span><br>deb https://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse<br>deb-src https://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse<br>deb https://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse<br>deb-src https://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse<br>deb https://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse<br>deb-src https://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse<br>deb https://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse<br>deb-src https://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse<br>deb https://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse<br>deb-src https://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span><br>deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse<br><span class="hljs-meta prompt_"># </span><span class="language-bash">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse</span><br>deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse<br><span class="hljs-meta prompt_"># </span><span class="language-bash">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse</span><br>deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse<br><span class="hljs-meta prompt_"># </span><span class="language-bash">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse</span><br>deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse<br><span class="hljs-meta prompt_"># </span><span class="language-bash">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse</span><br></code></pre></td></tr></table></figure><h4 id="换源后出现证书问题"><a href="#换源后出现证书问题" class="headerlink" title="换源后出现证书问题"></a>换源后出现证书问题</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Err:<span class="hljs-number">22</span> https://mirrors.tuna.tsinghua.edu.cn/ubuntu focal <span class="hljs-keyword">Release</span><br>  Certificate verification failed: The certificate <span class="hljs-keyword">is</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">trusted</span>. The certificate chain uses expired certificate.  Could <span class="hljs-keyword">not</span> handshake: Error <span class="hljs-keyword">in</span> the certificate verification. [IP: <span class="hljs-number">101.6</span><span class="hljs-number">.15</span><span class="hljs-number">.130</span> <span class="hljs-number">443</span>]<br># 证书验证失败:证书不受信任。证书链使用过期的证书。无法握手:证书验证中出现错误。<br></code></pre></td></tr></table></figure><p>原因为未安装<code>ca-certificates</code></p><p>可以先使用http代替掉https，然后安装<code>ca-certificates</code>。</p><p>安装 ca-certificates.</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install ca-certificates<br></code></pre></td></tr></table></figure><p>再次 <code>sudo apt-get update</code> 发现问题已经消失.</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">sudo gpg <span class="hljs-params">--keyserver</span> keyserver.ubuntu.com <span class="hljs-params">--recv</span> 5523BAEEB01FA116 <span class="hljs-string">//</span><span class="hljs-params">(这个公钥根据提示来写的)</span><br><span class="hljs-comment"># eg.</span><br><span class="hljs-comment"># sudo gpg --keyserver keyserver.ubuntu.com --recv 648ACFD622F3D138 0E98404D386FA1D9 DCC9EFBF77E11517 112695A0E562B32A  54404762BBB6E853</span><br> <br>sudo gpg <span class="hljs-params">--export</span> <span class="hljs-params">--armor</span> 5523BAEEB01FA116 | sudo apt-key add -<br><span class="hljs-comment"># eg.</span><br><span class="hljs-comment"># sudo gpg --export --armor 648ACFD622F3D138 0E98404D386FA1D9 DCC9EFBF77E11517 112695A0E562B32A  54404762BBB6E853 | sudo apt-key add -</span><br></code></pre></td></tr></table></figure><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装指定版本的包</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">sudo</span> apt-get install package=version</span><br>sudo apt-get install python3=3.7.3-1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">列出所有包 apt-cache madison package</span><br>apt-cache madison python3<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">搜索相关r</span><br>apt-cache search &lt;keyword&gt;<br></code></pre></td></tr></table></figure><h3 id="更新源-包"><a href="#更新源-包" class="headerlink" title="更新源&amp;包"></a>更新源&amp;包</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">更新源</span><br>sudo apt-get update<br><span class="hljs-meta prompt_"># </span><span class="language-bash">更新软件包</span><br>sudo apt-get upgrade<br></code></pre></td></tr></table></figure><h3 id="卸载包"><a href="#卸载包" class="headerlink" title="卸载包"></a>卸载包</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">删除包</span><br>sudo apt-get remove nginx<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查找 xx 相关软件</span><br>dpkg --get-selections|grep nginx<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除包及其配置</span><br>sudo apt-get --purge remove nginx<br>sudo apt-get purge --auto-remove nginx<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除不使用的包</span><br>sudo apt-get autoremove<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">清除缓存</span><br>sudo apt-get clean<br></code></pre></td></tr></table></figure><h1 id="linux-进阶"><a href="#linux-进阶" class="headerlink" title="linux 进阶"></a>linux 进阶</h1><h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><p><a href="https://zhuanlan.zhihu.com/p/139381645">https://zhuanlan.zhihu.com/p/139381645</a></p><p><a href="https://wiki.ubuntu.org.cn/Ufw%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97">https://wiki.ubuntu.org.cn/Ufw%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装</span><br><span class="hljs-built_in">sudo</span> apt-get install ufw<br><span class="hljs-comment"># 启动</span><br><span class="hljs-built_in">sudo</span> ufw <span class="hljs-built_in">enable</span><br><span class="hljs-comment"># 以下这条命令 我们设置默认的规则为allow， 这样除非指明打开的端口， 否则所有端口默认都是关闭的。</span><br><span class="hljs-built_in">sudo</span> ufw default deny <br><span class="hljs-comment"># 查看状态</span><br><span class="hljs-built_in">sudo</span> ufw status<br><span class="hljs-comment"># 查看状态和规则编号</span><br><span class="hljs-built_in">sudo</span> ufw status numbered<br><br> ufw  [--dry-run]  route [delete] [insert NUM] allow|deny|reject|<span class="hljs-built_in">limit</span> [<span class="hljs-keyword">in</span>|out on  INTERFACE] [<span class="hljs-built_in">log</span>|log-all] [proto PROTOCOL] [from ADDRESS [port PORT]] [to ADDRESS [port PORT]]<br><br><span class="hljs-built_in">sudo</span> ufw allow 80 允许外部访问80端口<br><span class="hljs-comment"># 这个好像最大一次性只能开一百个</span><br><span class="hljs-built_in">sudo</span> ufw allow 50000:50100/tcp 允许外部访问端口范围<br><br><span class="hljs-comment"># 允许eth0的所有流量</span><br><span class="hljs-built_in">sudo</span> ufw allow <span class="hljs-keyword">in</span> on eth0<br><br><span class="hljs-comment"># 删除允许访问 80 端口的规则</span><br><span class="hljs-built_in">sudo</span> ufw delete allow 80 <br><span class="hljs-comment"># 删除编号为 66 的规则</span><br><span class="hljs-built_in">sudo</span> ufw delete 66<br><br><span class="hljs-built_in">sudo</span> ufw allow from 192.168.1.1 允许此IP访问所有的本机端口<br><br><span class="hljs-built_in">sudo</span> ufw deny smtp 禁止外部访问smtp服务<br><br><span class="hljs-comment"># 想要允许连接通过指定网络接口，使用allow in on 和 网络接口的名字：</span><br><span class="hljs-built_in">sudo</span> ufw allow <span class="hljs-keyword">in</span> on eth2 to any port 3306<br><br><span class="hljs-built_in">sudo</span> ufw delete allow smtp 删除上面建立的某条规则<br><br><span class="hljs-comment"># 要拒绝所有的TCP流量从10.0.0.0/8 到192.168.0.1地址的22端口</span><br><span class="hljs-built_in">sudo</span> ufw deny proto tcp from 10.0.0.0/8 to 192.168.0.1 port 22 <br> <br><span class="hljs-comment"># 可以允许所有RFC1918网络（局域网/无线局域网的）访问这个主机（/8,/16,/12是一种网络分级）：</span><br><span class="hljs-built_in">sudo</span> ufw allow from 10.0.0.0/8<br><br><span class="hljs-built_in">sudo</span> ufw allow from 172.16.0.0/12<br><br><span class="hljs-built_in">sudo</span> ufw allow from 192.168.0.0/16<br></code></pre></td></tr></table></figure><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><ol><li>echo 查看单个环境变量</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$HOME</span><br></code></pre></td></tr></table></figure><ol start="2"><li>env 查看全部环境变量</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">env</span><br><span class="hljs-built_in">env</span> | grep SSH<br><br><span class="hljs-comment"># export 也可以查看</span><br><span class="hljs-built_in">export</span><br></code></pre></td></tr></table></figure><ol start="3"><li>set 查看本地定义的环境变量</li></ol><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">set</span><br></code></pre></td></tr></table></figure><ol start="4"><li>export 设置一个新的环境变量(临时的，重启后消失)</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">HELLO</span>=<span class="hljs-string">&quot;hello&quot;</span><br></code></pre></td></tr></table></figure><ol start="5"><li>unset 清除环境变量</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">unset</span> HELLO<br></code></pre></td></tr></table></figure><ol start="6"><li>readonly 设定只读环境变量</li></ol><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">readonly HELLO<span class="hljs-operator">=</span><span class="hljs-string">&quot;hello&quot;</span><br></code></pre></td></tr></table></figure><ol start="7"><li>添加环境变量</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 将/usr/local/nginx/sbin/目录临时添加到环境变量中</span><br><span class="hljs-built_in">export</span> PATH=/usr/local/nginx/sbin/:<span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure><ol start="8"><li>设定永久环境变量（其实就是<strong>开机</strong>&#x2F;<strong>启动bash</strong>等等这些操作之前会运行一个脚本，我们的思路就是在这个脚本）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">编辑后面的特定位置的文件  示例是当前用户的bash的启动执行的脚本  如果是其他终端则修改的是对应的脚本  比如zsh 修改的是.zshrc</span><br>vim ~/.bashrc<br><span class="hljs-meta prompt_"># </span><span class="language-bash">加上环境变量</span><br>export DONT_PROMPT_WSL_INSTALL=1<br></code></pre></td></tr></table></figure><h3 id="一些常见环境变量"><a href="#一些常见环境变量" class="headerlink" title="一些常见环境变量"></a>一些常见环境变量</h3><ol><li>PATH：决定了shell将到哪些目录中寻找命令或程序</li><li>HOME：指定用户的主目录（即用户登录到Linux系统时的默认目录）</li><li>HISTSIZE：保存历史命令记录的条数</li><li>LOGNAME：显示当前用户的登录名   （同 指令logname）</li><li>HOSTNAME：显示主机的名字 （同 指令hostname）</li><li>SHELL：指当前用户使用的shell类型</li><li>LANG&#x2F;LANGUGE：语言相关的环境变量，多语言可以修改此环境变量</li></ol><h3 id="环境变量存放的位置"><a href="#环境变量存放的位置" class="headerlink" title="环境变量存放的位置"></a>环境变量存放的位置</h3><ol><li><code>etc/profile</code> （所有用户）</li></ol><p>这个文件是<strong>每个用户登录时都会运行的环境变量设置</strong>，当用户第一次登陆时该文件被执行*(这就是用户启动执行特定程序的原理了)*，并从<code>/etc/profile.d</code>目录的配置文件中搜索shell的设置。这个文件的作用就是当用户登录的时候用于获取系统的环境变量，只在登录的时候获取一次。</p><p>所以说，在<code>/etc/profile</code>文件中添加的变量，<strong>对所有用户永久的生效</strong>。</p><ol start="2"><li><code>~/.bash_profile </code>（单个用户）</li></ol><p><strong>每个用户都可以使用该文件输入自己专用的shell信息，当用户登录时，该文件仅仅执行一次</strong>。默认情况下，它设置一些环境变量，执行用户的.bashrc文件。单个用户对此文件的修改只会影响到它以后的每一次登录。</p><p>也就是说，在用户目录下的.bash_profile文件中增加变量，<strong>仅对当前用户永久生效，</strong> <strong>操作同 &#x2F;etc&#x2F;profile</strong></p><ol start="3"><li><code>/etc/bashrc </code>（所有用户）</li></ol><p>在执行完 &#x2F;etc&#x2F;profile 内容后，如果用户运行 bash shell 的话，则就执行这个文件，当**每次一个新的bash shell 被打开时，该文件被读取**。****所以，如果每打开一个bash都执行某些操作，就可以在这个文件里面设置。</p><ol start="4"><li><code>~/.bashrc</code>  （单个用户）</li></ol><p>该文件只包含专用于你的bash信息，<strong>当你登录时以及每次打开新的shell时，该文件就会自动被读取</strong>。</p><ol start="5"><li><code>~/.bash_logout</code><strong>每次在退出shell的时候会执行该文件</strong></li></ol><p><strong>每次在退出shell的时候会执行该文件</strong>，它提供了定制用户环境的功能，比如删除账号内的临时文件等命令就可以放在bash_logout 文件内，如果这个文件不存在的话则就执行其他的命令。</p><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><h3 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h3><p><a href="https://www.runoob.com/linux/linux-comm-xargs.html">https://www.runoob.com/linux/linux-comm-xargs.html</a></p><p>xargs 可以将管道或标准输入（stdin）数据转换成命令行参数，也能够从文件的输出中读取数据。</p><p><strong>命令格式：</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">somecommand |xargs -<span class="hljs-keyword">item</span>  <span class="hljs-keyword">command</span><br></code></pre></td></tr></table></figure><ul><li>-a file 从文件中读入作为 stdin</li><li>-e flag ，注意有的时候可能会是-E，flag必须是一个以空格分隔的标志，当xargs分析到含有flag这个标志的时候就停止。</li><li>-p 当每次执行一个argument的时候询问一次用户。</li><li>-n num 后面加次数，表示命令在执行的时候一次用的argument的个数，默认是用所有的。</li><li>-t 表示先打印命令，然后再执行。</li><li>-i 或者是-I，这得看linux支持了，将xargs的每项名称，一般是一行一行赋值给 {}，可以用 {} 代替。</li><li>-r no-run-if-empty 当xargs的输入为空的时候则停止xargs，不用再去执行了。</li><li>-s num 命令行的最大字符数，指的是 xargs 后面那个命令的最大命令行字符数。</li><li>-L num 从标准输入一次读取 num 行送给 command 命令。</li><li>-l 同 -L。</li><li>-d delim 分隔符，默认的xargs分隔符是回车，argument的分隔符是空格，这里修改的是xargs的分隔符。</li><li>-x exit的意思，主要是配合-s使用。。</li><li>-P 修改最大的进程数，默认是1，为0时候为as many as it can ，这个例子我没有想到，应该平时都用不到的吧。</li></ul><p><strong>Example</strong></p><p>复制所有图片文件到 <code>/data/images</code> 目录下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> *.jpg | xargs -n1 -I &#123;&#125; <span class="hljs-built_in">cp</span> &#123;&#125; /data/images<br></code></pre></td></tr></table></figure><h2 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h2><p>参考: </p><ul><li><p>&lt;鸟哥的linux私房菜&gt; -&gt; 第七章、Linux 磁盘与文件系统管理 -&gt; 7.1.3 Linux 的 EXT2 文件系统（inode）</p></li><li><p><a href="https://ty-chen.github.io/linux-kernel-fs/">Linux操作系统学习笔记（十一）文件系统</a></p></li></ul><blockquote><p>  <em>inode(index node)</em> 是 UNIX 操作系统中的一种数据结构，其本质是[<strong>结构体</strong>]，它包含了与文件系统中各个文件相关的一些重要信息。在 UNIX 中创建文件系统时，同时将会创建大量的 inode 。通常，文件系统磁盘空间中大约百分之一空间分配给了 inode 表。</p></blockquote><p><strong>inode主要是记录文件的元信息，比如文件权限信息、文件的大小、文件修改信息、文件位置信息(data block id)等等，我们可以理解为是文件的索引(index)。</strong></p><blockquote><p>  如何通过inode找到文件数据的位置?</p><p>  ext2文件系统中，inode存在<strong>12个直接指针</strong>，<strong>1个间接指针</strong>(可以理解为指针)，<strong>1个双重间接块指针</strong>(可以理解为指向指针的指针 两重指针)，<strong>1个三重间接块指针</strong>(可以理解为 三重指针)，通过这几个指针的索引我们就能找到对应的文件存放的位置。</p><p>  <strong>我们假定每个指针占用4Byte的空间，每个Blocks大小为4KB(SSD的4K对齐应该也是指的这个)。</strong></p><ul><li>直接块指针：<ul><li>前12个直接指针，直接指向存储数据的区域。blocks大小为4KB，前12个直接指针就可以保存<strong>48KB</strong>的文件</li></ul></li><li>间接块指针(一级间接快指针)：<ul><li>每个指针占用4Byte，则间接快指针指向的Blocks可以保存(4*1024)&#x2F;4&#x3D;1024个记录(或者称为直接指针)，也就是对应1024个Blocks，那么间接块指针可存储文件数据大小为1024*4KB&#x3D;<strong>4MB</strong></li></ul></li><li>双重间接块指针(二级间接快指针)：<ul><li>同理，双重间接块指针可以储存文件数据大小为1024*1024*4KB&#x3D;<strong>4GB</strong></li></ul></li><li>三重间接块指针(三级间接快指针)：<ul><li>同理，三重间接块指针可以储存文件数据大小为1024*1024*1024*4KB&#x3D;<strong>4TB</strong></li></ul></li></ul></blockquote><p><img src="/2020/d4436089/123.png" alt="操作系统：文件系统- 掘金"></p><blockquote><p>  <strong>弊端</strong></p><p>  该存储结构带来的问题是对于大型文件，我们需要多次调用才可以访问对应块的内容，因此访问速度较慢。为此，<strong>ext4</strong>提出了新的解决方案：<a href="https://en.wikipedia.org/wiki/Extent_(file_systems)">Extents</a>。简单的说，<strong>Extents以一个树形结构来连续存储文件块，从而提高访问速度，大致结构如下图所示。</strong></p><p>  <img src="/2020/d4436089/1-s2.0-S1742287617300270-gr2.jpg" alt="AFEIC: Advanced forensic Ext4 inode carving - ScienceDirect"></p></blockquote><blockquote><p>  <strong>冷知识:</strong></p><p>  同一个文件在磁盘上的物理位置可能不会是连续的, 大概率都是分散开的, 散落在磁盘的各个位置.</p><p>  <img src="/2020/d4436089/image-20230107231700676.png" alt="image-20230107231700676"></p></blockquote><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="df"><a href="#df" class="headerlink" title="df"></a>df</h4><p>我们可以通过<code>df</code>命令查看所有已挂载的文件系统中已使用的 inode 的数目，以及文件系统中总体使用情况的百分比。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">❯ df -i<br>Filesystem       Inodes   IUsed    IFree IUse% Mounted on<br>/dev/sdc       67108864  556871 66551993    1% /<br></code></pre></td></tr></table></figure><h4 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h4><p>我们可以通过stat命令查看文件(包括目录)的inode信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">❯ stat use_proxy.sh<br>  File: use_proxy.sh<br>  Size: 720             Blocks: 8          IO Block: 4096   regular file<br>Device: 820h/2080d      Inode: 552923      Links: 1<br>Access: (0644/-rw-r--r--)  Uid: ( 1000/   frank)   Gid: ( 1000/   frank)<br>Access: 2022-12-11 22:29:33.000000000 +0800<br>Modify: 2022-10-31 17:10:16.000000000 +0800<br>Change: 2022-12-11 22:31:28.141006225 +0800<br> Birth: -<br></code></pre></td></tr></table></figure><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p>我们可以通过find命令找特定inode号的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">根目录的inode号为2</span><br>❯ find / -inum 2<br>/<br><br>❯ ll -li ~<br>total 16K<br>552923 -rw-r--r-- 1 frank frank  720 10月 31 17:10 xxx.sh<br>❯ find ~ -inum 552923<br>/home/frank/xxx.sh<br></code></pre></td></tr></table></figure><h2 id="硬链接-和-软连接-符号链接"><a href="#硬链接-和-软连接-符号链接" class="headerlink" title="硬链接 和 软连接(符号链接)"></a>硬链接 和 软连接(符号链接)</h2><p>参考:<a href="https://www.cnblogs.com/Peter2014/p/7594504.html">Linux硬链接和软连接的区别与总结</a>,<a href="https://www.cnblogs.com/sanjun/p/9971993.html">硬链接和软连接（符号链接）的区别</a>,<a href="https://www.zhihu.com/question/443459832/answer/1723706381">linux中软链接和硬链接是什么意思？</a></p><p>硬链接（Hard Link） 和软链接（Symbolic Link）</p><p><img src="/2020/d4436089/1192583-20170925225909964-1496152149.png" alt="img"></p><h3 id="硬链接（Hard-Link）"><a href="#硬链接（Hard-Link）" class="headerlink" title="硬链接（Hard Link）"></a>硬链接（Hard Link）</h3><p>硬链接是多个目录项中的「索引节点」指向一个文件，也就是<strong>指向同一个 inode</strong>，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以硬链接是不可用于跨文件系统的。由于多个目录项都是指向一个 inode，那么只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。 </p><p><img src="/2020/d4436089/v2-7cf8cec396a66dca2dd1fcd6dadab537_720w.webp" alt="img"></p><blockquote><h3 id="有关硬链接的总结"><a href="#有关硬链接的总结" class="headerlink" title="有关硬链接的总结"></a>有关硬链接的总结</h3><ol><li><strong>不可以在不同文件系统的文件间建立链接</strong>(Inode范围问题)</li><li>只有超级用户才可以为目录创建硬链接。</li><li>具有相同inode节点号的多个文件互为硬链接文件；</li><li>删除硬链接文件或者删除源文件任意之一，文件实体并未被删除；<strong>只有删除了源文件和所有对应的硬链接文件，文件实体才会被删除；</strong></li><li>硬链接文件是文件的另一个入口；</li><li>可以通过给文件设置硬链接文件来防止重要文件被误删；</li><li>创建硬链接命令 ln 源文件 硬链接文件；</li><li>硬链接文件是普通文件，可以用rm删除；</li><li>对于静态文件（没有进程正在调用），当硬链接数为0时文件就被删除。<em>注意：如果有进程正在调用，则无法删除或者即使文件名被删除但空间不会释放。</em></li></ol></blockquote><h3 id="软链接（Symbolic-Link）"><a href="#软链接（Symbolic-Link）" class="headerlink" title="软链接（Symbolic Link）"></a>软链接（Symbolic Link）</h3><p>软链接相当于重新创建一个文件，这个文件<strong>有独立的 inode</strong>，但是这个<strong>文件的内容是另外一个文件的路径</strong>，所以访问软链接的时候，<strong>实际上相当于访问到了另外一个文件</strong>，所以软链接是可以跨文件系统的，甚至目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。 </p><p><img src="/2020/d4436089/v2-5606413e1b5d2c727399711d347617a2_720w.webp" alt="img"></p><blockquote><h3 id="有关软链接的总结"><a href="#有关软链接的总结" class="headerlink" title="有关软链接的总结"></a>有关软链接的总结</h3><ol><li>软链接类似windows系统的快捷方式；</li><li><strong>软连接的目标文件建议使用绝对路径，否则软连接被移动后将会失效。</strong></li><li><strong>软链接里面存放的是源文件的<em>路径</em>，指向源文件；</strong></li><li>删除源文件，软链接依然存在，但无法访问源文件内容；</li><li>软链接失效时一般是白字红底闪烁；</li><li>软链接和源文件是不同的文件，文件类型也不同，inode号也不同 <strong>是两个不同的文件</strong>；</li><li>软链接的文件类型是“l”，可以用rm删除。</li></ol></blockquote><h3 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h3><blockquote><h3 id="硬链接和软链接的区别"><a href="#硬链接和软链接的区别" class="headerlink" title="硬链接和软链接的区别"></a>硬链接和软链接的区别</h3><p>  原理上，硬链接和源文件的inode节点号相同，两者互为硬链接。软连接和源文件的inode节点号不同，进而指向的block也不同，软连接block中存放了源文件的路径名。</p><p>  实际上，硬链接和源文件是同一份文件，而软连接是独立的文件，类似于快捷方式，存储着源文件的位置信息便于指向。</p><p>  使用限制上，不能对目录创建硬链接，不能对不同文件系统创建硬链接，不能对不存在的文件创建硬链接；可以对目录创建软连接，可以跨文件系统创建软连接，可以对不存在的文件创建软连接。</p></blockquote><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p><strong>硬链接</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> -lhi</span><br>1180598 -rw-rw-r-- 3 frank frank    5 2月  12 22:31 123.txt<br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">stat</span> *.txt</span><br>  文件：123.txt<br>  大小：5               块：8          IO 块：4096   普通文件<br>设备：805h/2053d        Inode：1180598     硬链接：1<br>...<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用 <span class="hljs-built_in">ln</span> 命令创建链接 先看看语法</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ln</span> --<span class="hljs-built_in">help</span></span><br>用法：ln [选项]... 目标... 目录<br>在指定&lt;目录&gt;中创建指向指定&lt;目标&gt;的链接。<br>默认创建硬链接，当使用--symbolic 时创建符号链接。<br>默认情况下，创建每个目标时不应存在与新链接的名称相同的文件。<br>创建硬链接时，每个指定的&lt;目标&gt;都必须存在。符号链接可以指向任意的位置；<br>当链接解析正常时，将其解析为一个相对于其父目录的相对链接。<br>...<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在当前目录下创建一个 硬链接 <span class="hljs-string">&#x27;123.ln.txt&#x27;</span>指向<span class="hljs-string">&#x27;123.txt&#x27;</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ln</span> 123.txt ./123.ln.txt</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> -lhi</span><br>1180598 -rw-rw-r-- 3 frank frank    5 2月  12 22:31 123.ln.txt<br>1180598 -rw-rw-r-- 3 frank frank    5 2月  12 22:31 123.txt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">我们可以看到 <span class="hljs-string">&#x27;123.txt&#x27;</span> 和 <span class="hljs-string">&#x27;123.ln.txt&#x27;</span> 的Inode指向同一个位置 自然他们的大小也是一致的</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">并且 <span class="hljs-string">&#x27;硬链接&#x27;</span> 的数目由1变成了2</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果 <span class="hljs-built_in">rm</span> 其中一个文件, 只是删除了文件指针文件内容并不会删除, 也就是说只有等到 硬链接 数目变成0了内核才会将文件内容删除</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">stat</span> *.txt</span><br>  文件：123.ln.txt<br>  大小：5               块：8          IO 块：4096   普通文件<br>设备：805h/2053d        Inode：1180598     硬链接：2<br>...<br>  文件：123.txt<br>  大小：5               块：8          IO 块：4096   普通文件<br>设备：805h/2053d        Inode：1180598     硬链接：2<br>...<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">加 -s 参数 创建一个 软链接</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在当前目录下创建一个 软链接 <span class="hljs-string">&#x27;123.soft.txt&#x27;</span>指向<span class="hljs-string">&#x27;123.txt&#x27;</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ln</span> -s 123.txt ./123.soft.txt</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">注意看 软件链接 的类型是 l</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> -hli</span><br>1180598 -rw-rw-r-- 3 frank frank    5 2月  12 22:31 123.ln.txt<br>1181799 lrwxrwxrwx 1 frank frank    7 2月  12 22:41 123.soft.txt -&gt; 123.txt<br>1180598 -rw-rw-r-- 3 frank frank    5 2月  12 22:31 123.txt<br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">stat</span> *.txt</span><br>  文件：123.ln.txt<br>  大小：5               块：8          IO 块：4096   普通文件<br>设备：805h/2053d        Inode：1180598     硬链接：3<br>...<br>  文件：123.soft.txt -&gt; 123.txt<br>  大小：7               块：0          IO 块：4096   符号链接<br>设备：805h/2053d        Inode：1181799     硬链接：1<br>...<br>  文件：123.txt<br>  大小：5               块：8          IO 块：4096   普通文件<br>设备：805h/2053d        Inode：1180598     硬链接：3<br>...<br></code></pre></td></tr></table></figure><h1 id="linux-常用命令"><a href="#linux-常用命令" class="headerlink" title="linux 常用命令"></a>linux 常用命令</h1><blockquote><p>  <span style="color:red">TODO 将这些命令进行分类！</span></p></blockquote><p>查看支持的shell</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/shells<br></code></pre></td></tr></table></figure><p>查看当前使用哪个shell</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$SHELL</span><br></code></pre></td></tr></table></figure><p>更改用户的默认shell</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">chsh -s /bin/zsh  [用户名:模认当前用户]<br></code></pre></td></tr></table></figure><h3 id="alias-起别名"><a href="#alias-起别名" class="headerlink" title="alias 起别名"></a>alias 起别名</h3><p><strong>命名别名</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">起别名</span><br>alias 别名=“路径” <br><span class="hljs-meta prompt_"># </span><span class="language-bash">取消别名</span><br>unalias 别名  <br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看命令类型</span><br>type -a ls  <br></code></pre></td></tr></table></figure><p><strong>别名优先级最高</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">别名优先</span><br>ls<br><span class="hljs-meta prompt_"># </span><span class="language-bash">跳过别名</span><br>\ls<br>&quot;ls&quot;<br>&#x27;ls&#x27;<br></code></pre></td></tr></table></figure><h3 id="ls-list-file"><a href="#ls-list-file" class="headerlink" title="ls list file"></a>ls list file</h3><ul><li><p>ls -l 显示文件的详细信息，文件目录具有的权限，当前权限文件的数量，拥有者，所属的群组，文件目录的大小，创建或者修改时间，文件目录的名字。可以使用ls -la</p></li><li><p>ls -R 递归列出目录所有文件</p></li><li><p>ls -a 显示所有文件以及子目录，包括“.”开头的隐藏文件</p></li><li></li></ul><h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><ul><li>cd &#x2F; 进入根目录</li><li>cd .. 返回上一级</li><li>cd ~ 返回当前用户主目录</li></ul><h3 id="pwd显示路径"><a href="#pwd显示路径" class="headerlink" title="pwd显示路径"></a>pwd显示路径</h3><p>显示当前文件目录的绝对路径</p><h3 id="uname系统信息查看"><a href="#uname系统信息查看" class="headerlink" title="uname系统信息查看"></a>uname系统信息查看</h3><ul><li>-r 列出当前系统的具体内核版本号。 </li><li>-s 列出系统内核名称。 </li><li>-o 列出系统信息。</li></ul><ul><li><strong>ubuntu版本查看</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/lsb-release<br>lsb_release -a<br></code></pre></td></tr></table></figure><h3 id="clear清屏"><a href="#clear清屏" class="headerlink" title="clear清屏"></a>clear清屏</h3><p>快捷键 <strong>Ctrl+l(小写的L)</strong>  同clear</p><h3 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h3><p>暂时提升到root权限</p><p>su可以直接变成管理员</p><ul><li>-h help</li><li>-p 改变询问密码的提示符（不知道是啥）</li></ul><h3 id="wc-WordCount"><a href="#wc-WordCount" class="headerlink" title="wc WordCount"></a>wc WordCount</h3><blockquote><p>  用法</p><ul><li><code>wc -l &lt;文件名&gt;</code> 输出行数统计</li><li><code>wc -c &lt;文件名&gt;</code> 输出字节数统计</li><li><code>wc -m &lt;文件名&gt;</code> 输出字符数统计</li><li><code>wc -L &lt;文件名&gt;</code> 输出文件中最长一行的长度</li><li><code>wc -w &lt;file name&gt;</code> 显示一个文件的字数</li></ul></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash"><span class="hljs-built_in">wc</span> 123.txt</span><br>   7   11   117  123.txt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">依次是</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">行数 单词数 字节数 文件名称。</span><br></code></pre></td></tr></table></figure><h3 id="cat-文本输出命令"><a href="#cat-文本输出命令" class="headerlink" title="cat  文本输出命令"></a>cat  文本输出命令</h3><p>-n 由1开始对所有行进行编号</p><p>-b 类似-n不对空行编号</p><p>-s 遇到两行空行以上时合并成一个空行</p><h3 id="ifconfig-显示网络配置"><a href="#ifconfig-显示网络配置" class="headerlink" title="ifconfig  显示网络配置"></a>ifconfig  显示网络配置</h3><ul><li>sudo ifconfig ens33 192.168.128.128     修改ip</li></ul><h3 id="man-系统帮助-查命令"><a href="#man-系统帮助-查命令" class="headerlink" title="man 系统帮助-查命令"></a>man 系统帮助-查命令</h3><h3 id="reboot-重启"><a href="#reboot-重启" class="headerlink" title="reboot  重启"></a>reboot  重启</h3><h3 id="poweroff-关机"><a href="#poweroff-关机" class="headerlink" title="poweroff 关机"></a>poweroff 关机</h3><h3 id="install-安装软件命令"><a href="#install-安装软件命令" class="headerlink" title="install 安装软件命令"></a>install 安装软件命令</h3><h3 id="apt-get"><a href="#apt-get" class="headerlink" title="apt-get"></a>apt-get</h3><p>APT工具可以实现软件的自动下载、配置、安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查找有哪些版本</span><br>apt-cache madison &lt;&lt;package name&gt;&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装指定版本</span><br>apt-get install &lt;&lt;package name&gt;&gt;=&lt;&lt;version&gt;&gt;<br></code></pre></td></tr></table></figure><h3 id="fdisk-磁盘工具"><a href="#fdisk-磁盘工具" class="headerlink" title="fdisk 磁盘工具"></a>fdisk 磁盘工具</h3><p><a id="fdisk">linux  磁盘管理 fdisk</a></p><blockquote><p>  Linux fdisk 是一个创建和维护分区表的程序，它兼容 DOS 类型的分区表、BSD 或者 SUN 类型的磁盘列表。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">fdisk <span class="hljs-selector-attr">[必要参数]</span><span class="hljs-selector-attr">[选择参数]</span><br></code></pre></td></tr></table></figure><p>  <strong>必要参数：</strong></p><ul><li>-l 列出素所有分区表</li><li>-u 与 <strong>-l</strong> 搭配使用，显示分区数目</li></ul><p>  <strong>选择参数：</strong></p><ul><li>-s&lt;分区编号&gt; 指定分区</li><li>-v 版本信息</li></ul><p>  <strong>菜单操作说明</strong></p><ul><li>m ：显示菜单和帮助信息</li><li>a ：活动分区标记&#x2F;引导分区</li><li>d ：删除分区</li><li>l ：显示分区类型</li><li>n ：新建分区</li><li>p ：显示分区信息</li><li>q ：退出不保存</li><li>t ：设置分区号</li><li>v ：进行分区检查</li><li>w ：保存修改</li><li>x ：扩展应用，高级功能</li></ul>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-built_in">sudo</span> fdisk /dev/sdb</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看帮助</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">m</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除分区</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">d</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">新建分区</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">n</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">写入分区表</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">w</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这个时候虽然分区分好了但是还不能使用, 因为没有分配文件系统</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">mkfs</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="mkfs-格式化-建立文件系统"><a href="#mkfs-格式化-建立文件系统" class="headerlink" title="mkfs 格式化(建立文件系统)"></a>mkfs 格式化(建立文件系统)</h3><p><a id="mkfs">linux 构造文件系统 mkfs</a></p><p>Linux mkfs（英文全拼：make file system）命令用于在特定的分区上建立 linux 文件系统。</p><blockquote><p>  <strong>使用方式</strong> :</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkfs [-V] [-t fstype] [fs-options] filesys [blocks]<br></code></pre></td></tr></table></figure><p>  <strong>参数</strong> ：</p><ul><li>选项：</li><li>-t, –type&#x3D;&lt;类型&gt;  文件系统类型；若不指定，将使用 ext2<br> fs-options     实际文件系统构建程序的参数<br> &lt;设备&gt;         要使用设备的路径<br> &lt;大小&gt;         要使用设备上的块数</li><li>-V, –verbose      解释正在进行的操作；<br>                  多次指定 -V 将导致空运行(dry-run)</li><li>-h, –help         display this help</li><li>-V, –version      display version</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>  将sda6分区格式化为ext3格式</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkfs -t ext3 /dev/sda6  <br></code></pre></td></tr></table></figure><p>  <strong>注意</strong>：这里的文件系统是要指定的，比如 ext3 ；reiserfs ；ext2 ；fat32 ；msdos 等。</p></blockquote><h3 id="df-磁盘信息"><a href="#df-磁盘信息" class="headerlink" title="df 磁盘信息"></a>df 磁盘信息</h3><p>disk free</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">df -h<br></code></pre></td></tr></table></figure><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>-h</td><td>可读显示</td></tr><tr><td>-a</td><td>all</td></tr><tr><td>-l</td><td>本地文件系统</td></tr><tr><td>-T</td><td>Type 文件系统类型</td></tr></tbody></table><h3 id="du-磁盘使用分析"><a href="#du-磁盘使用分析" class="headerlink" title="du 磁盘使用分析"></a>du 磁盘使用分析</h3><p>disk usaged</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">du</span> --max-depth=1 -BM | <span class="hljs-built_in">sort</span> -rn<br></code></pre></td></tr></table></figure><blockquote><p>  -h：以人类可读的方式显示。<br>  -a：显示目录占用的磁盘空间大小，还要显示其下目录和文件占用磁盘空间的大小。<br>  -s：只显示<strong>目录占用的磁盘空间</strong>大小，<strong>不显示其子目录和文件</strong>占用的磁盘空间大小。<br>  -c：显示几个<strong>目录或文件占用的磁盘</strong>空间大小，还要统计它们的总和。<br>  –apparent-size：显示<strong>目录或文件自身的大小</strong>。<br>  -l ：统计硬链接占用磁盘空间的大小。<br>  -L：统计符号链接所指向的文件占用的磁盘空间大小。</p><p>  -B: 单位修改 -BM &#x3D; 用MB   -BG&#x3D;用GB</p><p>  –max-depth: –max-depth&#x3D;1列出目录的深度为1</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># ** du命令还可以对结果进行排序，以方便快速找出占用空间最多目录。 **</span><br><br><span class="hljs-built_in">du</span> -s 目录 | <span class="hljs-built_in">sort</span> -rn        <span class="hljs-comment">#这是按字节排序</span><br><span class="hljs-built_in">du</span> -sh 目录 | <span class="hljs-built_in">sort</span> -rn        <span class="hljs-comment">#这是按兆（M）来排序</span><br><span class="hljs-comment">#由于-sh大小显示看起来是乱的，因此建议使用du -s|sort -nr</span><br><span class="hljs-built_in">du</span> -s 目录 | <span class="hljs-built_in">sort</span> -rn | <span class="hljs-built_in">head</span>        <span class="hljs-comment">#选出排在前面的10个</span><br><span class="hljs-built_in">du</span> -s 目录 | <span class="hljs-built_in">sort</span> -rn | <span class="hljs-built_in">tail</span>        <span class="hljs-comment">#选出排在后面的10个</span><br><br><span class="hljs-comment"># ** 统计总数大小 **</span><br><span class="hljs-built_in">du</span> -sh xmldb/<br><span class="hljs-built_in">du</span> -sm * | <span class="hljs-built_in">sort</span> -n //统计当前目录大小 并安大小 排序<br><span class="hljs-built_in">du</span> -sk * | <span class="hljs-built_in">sort</span> -n<br><span class="hljs-built_in">du</span> -sk * | grep guojf //看一个人的大小<br><span class="hljs-built_in">du</span> -m | <span class="hljs-built_in">cut</span> -d <span class="hljs-string">&quot;/&quot;</span> -f 2 //看第二个/ 字符前的文字<br><br><span class="hljs-comment"># ** 查看此文件夹有多少文件 /*/*/* 有多少文件 **</span><br><span class="hljs-built_in">du</span> xmldb/<br><span class="hljs-built_in">du</span> xmldb/*/*/* |<span class="hljs-built_in">wc</span> -l<br><span class="hljs-comment"># wc [-lmw]说明</span><br><span class="hljs-comment"># 参数说明：-l :多少行;  -m:多少字符;　-w:多少字</span><br></code></pre></td></tr></table></figure><h3 id="touch-创建新文件"><a href="#touch-创建新文件" class="headerlink" title="touch 创建新文件"></a>touch 创建新文件</h3><h3 id="mkdir-创建文件夹"><a href="#mkdir-创建文件夹" class="headerlink" title="mkdir 创建文件夹"></a>mkdir 创建文件夹</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>-p</td><td>递归创建, 前面的不存在, 就会创建</td></tr></tbody></table><h3 id="rmdir-删除文件夹"><a href="#rmdir-删除文件夹" class="headerlink" title="rmdir 删除文件夹"></a>rmdir 删除文件夹</h3><h3 id="rm-删除"><a href="#rm-删除" class="headerlink" title="rm 删除"></a>rm 删除</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 删除folder文件之外的所有文件</span><br><span class="hljs-built_in">rm</span> -rf !(folder)<br><span class="hljs-comment">#删除folder1和folder2文件之外的所有文件</span><br><span class="hljs-built_in">rm</span> -rf !(folder1 | folder2) <br><span class="hljs-comment">#删除keep文件之外的所有文件</span><br><span class="hljs-built_in">ls</span> | grep -v keep | xargs <span class="hljs-built_in">rm</span> <br><span class="hljs-comment"># 说明： ls先得到当前的所有文件和文件夹的名字， grep -v keep，进行grep正则匹配查找keep，-v参数决定了结果为匹配之外的结果，也就是的到了keep之外的所有文件名，然后 xargs用于从 标准输入获得参数 并且传递给后面的命令，这里使用的命令是 rm，然后由rm删除前面选择的文件。</span><br><br></code></pre></td></tr></table></figure><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>-d</td><td>直接把要删除的目录硬连数据成 0 ，删除该目录。</td></tr><tr><td>-f</td><td>直接把要删除的目录硬连数据成 0 ，删除该目录。</td></tr><tr><td>-i</td><td>删除文件或者夹 (目录 )之前先询问用户。</td></tr><tr><td>-r</td><td>递归删除，指定文件夹 (目录 )下的所有文件和子夹全部删除掉。</td></tr><tr><td>-v</td><td>显示删除过程。</td></tr></tbody></table><h3 id="cp-复制"><a href="#cp-复制" class="headerlink" title="cp 复制"></a>cp 复制</h3><p>cp [参数 ] [源地址 ] [目的地址 ]</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>-r</td><td>递归处理，指定目录下一并处理</td></tr><tr><td>-f</td><td>强行复制文件，不管要的是否已经存在于目标录。</td></tr></tbody></table><h3 id="mv-文件移动-重命名"><a href="#mv-文件移动-重命名" class="headerlink" title="mv 文件移动 重命名"></a>mv 文件移动 重命名</h3><p>mv [参数 ] [源地址 ] [目的地址 ]</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>-b</td><td>如果要覆盖文件的话前先进行备份。</td></tr><tr><td>-f</td><td>若目标文件或录与现在的重复，直接覆盖。</td></tr><tr><td>-I</td><td>在覆盖之前询问用户。</td></tr></tbody></table><h3 id="find-查找"><a href="#find-查找" class="headerlink" title="find 查找"></a>find 查找</h3><p>find [路径 ] [参数 ] [关键字 ]</p><ul><li>-name&lt;filename&gt;  按照文件名称查找，与 filename匹配的文件，可使用通符。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find /etc -name *.config<br></code></pre></td></tr></table></figure><h3 id="grep-文件中搜内容"><a href="#grep-文件中搜内容" class="headerlink" title="grep 文件中搜内容"></a>grep 文件中搜内容</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -r -i code<br></code></pre></td></tr></table></figure><p>Linux grep 命令用于查找文件里符合条件的字符串。</p><p>grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 **-**，则 grep 指令会从标准输入设备读取数据。</p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul><li><strong>-B&lt;显示行数&gt; 或 –before-context&#x3D;&lt;显示行数&gt;</strong> : 除了显示符合样式的那一行之外，并显示该行之前的内容。</li><li><strong>-C&lt;显示行数&gt; 或 –context&#x3D;&lt;显示行数&gt;或-&lt;显示行数&gt;</strong> : 除了显示符合样式的那一行之外，并显示该行之前后的内容。</li><li><strong>-d &lt;动作&gt; 或 –directories&#x3D;&lt;动作&gt;</strong> : 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。</li><li><strong>-n 或 –line-number</strong> : 在显示符合样式的那一行之前，标示出该行的列数编号。</li><li><strong>-r 或 –recursive</strong> : 此参数的效果和指定”-d recurse”参数相同。</li><li><strong>-i 或 –ignore-case</strong> : 忽略字符大小写的差别。</li><li><strong>-v 或 –invert-match</strong> : 显示不包含匹配文本的所有行。</li></ul><p>我们可以通过管道操作来让grep变得更强大，管道操作就是把前面一条命令的输出作为后面一条命令的输入，从而把很多简单的命令组合起来完成复杂的功能。例如，如果我们想查找包含apple的行，但又想过滤掉pineapple，可以用下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep apple fruitlist.txt | grep -v pineapple<br></code></pre></td></tr></table></figure><p>如果我们想把搜索结果保存起来，那么可以把命令的标准输出重定向到文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep apple fruitlist.txt | grep -v pineapple &gt; apples.txt<br></code></pre></td></tr></table></figure><p>重定向符号&gt;和管道操作符号|的区别是，重定向后面接的是一个文件，它后面不能再接任何文件或命令了；而管道操作后面接的是命令，可以无限地接下去。如果想以追加方式写到文件，可以用&gt;&gt;。管道操作是Linux命令行的一种哲学，它是计算机技术中少有的能沿用几十年的技术之一。通过管道操作，一行命令可以完成Windows下上千行程序也不能完成的文本处理功能。</p><p>grep [参数 ] 关键字 文件列表</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>-i</td><td>无视大小写</td></tr><tr><td>-r</td><td>递归查找</td></tr><tr><td>-v</td><td>反转，只显示不匹配</td></tr><tr><td>-w</td><td>全匹配 match whole word</td></tr><tr><td>–exclude-dir</td><td>排除文件夹</td></tr><tr><td>–exclude</td><td>排除文件</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">grep -ir &quot;ubuntu&quot; /etc<br><span class="hljs-meta prompt_"># </span><span class="language-bash">注意 如果 <span class="hljs-string">&quot;双引号内带有--&quot;</span> 可能会有不可预知的情况</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">grep -ir <span class="hljs-string">&quot;--ubuntu&quot;</span> /etc 这种写法会出问题</span><br><br>grep -ir &quot;Application_Initialize&quot; /a_usr/rosemaryCR/mikan/ --exclude-dir=out<br>grep -ir &quot;CARRIER_HOME_REVERSAL&quot; ./ --exclude=GRTAGS --exclude=mechapi.c<br></code></pre></td></tr></table></figure><h3 id="grep-搜索正则表达式并列出"><a href="#grep-搜索正则表达式并列出" class="headerlink" title="grep 搜索正则表达式并列出"></a>grep 搜索正则表达式并列出</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">| grep 22</span><br>sudo netstat -ntlp | grep 22<br>sudo apt list | grep php<br></code></pre></td></tr></table></figure><h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><p>print work directory 输出当前目录</p><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>在当前命令窗口输出文件</p><h3 id="nano"><a href="#nano" class="headerlink" title="nano"></a>nano</h3><p>文本编辑器</p><h3 id="mount-unmount-挂载卸载"><a href="#mount-unmount-挂载卸载" class="headerlink" title="mount unmount 挂载卸载"></a>mount unmount 挂载卸载</h3><p><a id="mount">linux 挂载 mount</a></p><h4 id="mount-挂载"><a href="#mount-挂载" class="headerlink" title="mount 挂载"></a>mount 挂载</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">需要先创建一个挂载点</span><br>sudo mkdir /mnt/usb<br><span class="hljs-meta prompt_"># </span><span class="language-bash">挂载</span><br>sudo mount /dev/sda1 /mnt/usb<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">mount 中文乱码</span><br>sudo mount -o iocharset=utf8 /dev/sda1 /mnt/usb<br></code></pre></td></tr></table></figure><h4 id="umount-卸载"><a href="#umount-卸载" class="headerlink" title="umount 卸载"></a>umount 卸载</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">卸载</span><br>sudo umount /mnt/usb<br><span class="hljs-meta prompt_"># </span><span class="language-bash">卸载的时候出错注意是不是文件夹正在使用中</span><br></code></pre></td></tr></table></figure><h4 id="树莓派自动挂载"><a href="#树莓派自动挂载" class="headerlink" title="树莓派自动挂载"></a>树莓派自动挂载</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">打开文件 添加以下 这个带有超时,可以避免拔掉U盘开不了机</span><br>sudo nano /etc/fstab<br><span class="hljs-meta prompt_"># </span><span class="language-bash">/dev/sda1 /mnt/usb    auto     defaults,nofail,x-systemd.device-timeout=1,noatime  0   0</span><br></code></pre></td></tr></table></figure><h3 id="mkdir-创建文件夹-1"><a href="#mkdir-创建文件夹-1" class="headerlink" title="mkdir 创建文件夹"></a>mkdir 创建文件夹</h3><h3 id="rmdir-删除文件夹-1"><a href="#rmdir-删除文件夹-1" class="headerlink" title="rmdir 删除文件夹"></a>rmdir 删除文件夹</h3><h3 id="rm-rf"><a href="#rm-rf" class="headerlink" title="rm -rf"></a>rm -rf</h3><p><strong>功能说明：删除文件或目录。</strong></p><p>语法：rm [-dfirv][–help][–version][文件或目录]</p><p>补充说明：执行rm指令可删除文件或目录，如欲删除目录必须加上参数”-r”，否则预设仅会删除文件。</p><p>参数：</p><ul><li><p>-d 或 –directory 　直接把欲删除的目录的硬连接数据删成0，删除该目录。</p></li><li><p>-f 或 –force 　强制删除文件或目录。</p></li><li><p>-i 或 –interactive 　删除既有文件或目录之前先询问用户。</p></li><li><p>-r 或 -R 或 –recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。</p></li><li><p>-v 或 –verbose 　显示指令执行过程。</p></li></ul><h3 id="netstat-列出网络"><a href="#netstat-列出网络" class="headerlink" title="netstat 列出网络"></a>netstat 列出网络</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">列出所有</span><br>sudo netstat -ntlp<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查找</span><br>netstat -ntlp | grep 80<br></code></pre></td></tr></table></figure><h3 id="ln-文件夹链接"><a href="#ln-文件夹链接" class="headerlink" title="ln 文件夹链接"></a>ln 文件夹链接</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">软链接 现有a 链接到b(没有的,目标的)</span><br>ln -s a b<br></code></pre></td></tr></table></figure><h3 id="dd-读取、转换并输出数据"><a href="#dd-读取、转换并输出数据" class="headerlink" title="dd 读取、转换并输出数据"></a>dd 读取、转换并输出数据</h3><p>dd 可从标准输入或文件中读取数据，根据指定的格式来转换数据，再输出到文件、设备或标准输出。</p><p><strong>参数说明:</strong></p><ul><li>if&#x3D;文件名：输入文件名，默认为标准输入。即指定源文件。</li><li>of&#x3D;文件名：输出文件名，默认为标准输出。即指定目的文件。</li><li>ibs&#x3D;bytes：一次读入bytes个字节，即指定一个块大小为bytes个字节。<br>obs&#x3D;bytes：一次输出bytes个字节，即指定一个块大小为bytes个字节。<br>bs&#x3D;bytes：同时设置读入&#x2F;输出的块大小为bytes个字节。</li><li>cbs&#x3D;bytes：一次转换bytes个字节，即指定转换缓冲区大小。</li><li>skip&#x3D;blocks：从输入文件开头跳过blocks个块后再开始复制。</li><li>seek&#x3D;blocks：从输出文件开头跳过blocks个块后再开始复制。</li><li>count&#x3D;blocks：仅拷贝blocks个块，块大小等于ibs指定的字节数。</li><li>conv&#x3D;&lt;关键字&gt;，关键字可以有以下11种：<ul><li>conversion：用指定的参数转换文件。</li><li>ascii：转换ebcdic为ascii</li><li>ebcdic：转换ascii为ebcdic</li><li>ibm：转换ascii为alternate ebcdic</li><li>block：把每一行转换为长度为cbs，不足部分用空格填充</li><li>unblock：使每一行的长度都为cbs，不足部分用空格填充</li><li>lcase：把大写字符转换为小写字符</li><li>ucase：把小写字符转换为大写字符</li><li>swap：交换输入的每对字节</li><li>noerror：出错时不停止</li><li>notrunc：不截短输出文件</li><li>sync：将每个输入块填充到ibs个字节，不足部分用空（NUL）字符补齐。</li></ul></li><li>–help：显示帮助信息</li><li>–version：显示版本信息</li></ul><h4 id="dd-进行测速"><a href="#dd-进行测速" class="headerlink" title="dd 进行测速"></a>dd 进行测速</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">以下两条Shell分别测试写入和读取1G的文件从/mnt/usb/目录，就是U盘的挂载点（硬盘测试也可以这样）：</span><br><br>time dd if=/dev/zero of=/mnt/usb/1g bs=1024 count=1000000<br>time dd if=/mnt/usb/1g bs=128k | dd of=/dev/null<br></code></pre></td></tr></table></figure><h3 id="source-刷新环境变量"><a href="#source-刷新环境变量" class="headerlink" title="source 刷新环境变量"></a>source 刷新环境变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 刷新环境变量</span><br><span class="hljs-built_in">source</span> ~/.profile<br><span class="hljs-built_in">source</span> 后面接文件<br></code></pre></td></tr></table></figure><h3 id="tail-循环读取log"><a href="#tail-循环读取log" class="headerlink" title="tail 循环读取log"></a>tail 循环读取log</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">tail</span> -f filename<br></code></pre></td></tr></table></figure><h3 id="file-辨识文件类型"><a href="#file-辨识文件类型" class="headerlink" title="file 辨识文件类型"></a>file 辨识文件类型</h3><blockquote><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">file <span class="hljs-selector-attr">[-bcLvz]</span><span class="hljs-selector-attr">[-f &lt;名称文件&gt;]</span><span class="hljs-selector-attr">[-m &lt;魔法数字文件&gt;...]</span><span class="hljs-selector-attr">[文件或目录...]</span><br></code></pre></td></tr></table></figure><p>  <strong>参数</strong>：</p><ul><li>-b 　列出辨识结果时，不显示文件名称。</li><li>-c 　详细显示指令执行过程，便于排错或分析程序执行的情形。</li><li>-f&lt;名称文件&gt; 　指定名称文件，其内容有一个或多个文件名称时，让file依序辨识这些文件，格式为每列一个文件名称。</li><li>-L 　直接显示符号连接所指向的文件的类别。</li><li>-m&lt;魔法数字文件&gt; 　指定魔法数字文件。</li><li>-v 　显示版本信息。</li><li>-z 　尝试去解读压缩文件的内容。</li><li>[文件或目录…] 要确定类型的文件列表，多个文件之间使用空格分开，可以使用shell通配符匹配多个文件。</li></ul></blockquote><h3 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h3><p><strong>-x</strong></p><p>每次访问时都需要写代理参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -x socks5://127.0.0.1:1024 http://www.google.com <span class="hljs-comment"># -x 参数等同于 --proxy</span><br></code></pre></td></tr></table></figure><p><strong>-v</strong></p><p><code>curl -v</code>参数会输出请求中访问的路由信息，方便确定是否设置成功，请求有没有代理</p><p><strong>-w</strong></p><p>[使用 curl 测试网站加载速度](##使用 curl 测试网站加载速度)</p><p>该选项在请求结束之后打印本次请求的统计数据到标准输出。</p><blockquote><p>  首先，我们定义控制打印行为的格式化字符串。新建文本文件 <code>fmt.txt</code>，并填入下面的内容：</p>  <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ruby">\n<br><span class="hljs-title class_">Response</span> <span class="hljs-title class_">Time</span> <span class="hljs-symbol">for:</span> <span class="hljs-string">%&#123;url_effective&#125;</span>\n\n<br><span class="hljs-variable constant_">DNS</span> <span class="hljs-title class_">Lookup</span> <span class="hljs-title class_">Time</span><span class="hljs-symbol">:</span>\t\t<span class="hljs-string">%&#123;time_namelookup&#125;</span>s\n<br><span class="hljs-title class_">Redirection</span> <span class="hljs-title class_">Time</span><span class="hljs-symbol">:</span>\t\t<span class="hljs-string">%&#123;time_redirect&#125;</span>s\n<br><span class="hljs-title class_">Connection</span> <span class="hljs-title class_">Time</span><span class="hljs-symbol">:</span>\t\t<span class="hljs-string">%&#123;time_connect&#125;</span>s\n<br><span class="hljs-title class_">App</span> <span class="hljs-title class_">Connection</span> <span class="hljs-title class_">Time</span><span class="hljs-symbol">:</span>\t\t<span class="hljs-string">%&#123;time_appconnect&#125;</span>s\n<br><span class="hljs-title class_">Pre</span>-transfer <span class="hljs-title class_">Time</span><span class="hljs-symbol">:</span>\t\t<span class="hljs-string">%&#123;time_pretransfer&#125;</span>s\n<br><span class="hljs-title class_">Start</span>-transfer <span class="hljs-title class_">Time</span><span class="hljs-symbol">:</span>\t\t<span class="hljs-string">%&#123;time_starttransfer&#125;</span>s\n\n<br><span class="hljs-title class_">Total</span> <span class="hljs-title class_">Time</span><span class="hljs-symbol">:</span>\t\t\t<span class="hljs-string">%&#123;time_total&#125;</span>s\n<br></code></pre></td></tr></table></figure><p>  curl 提供了很多置换变量，可以在格式化字符串中通过 <code>%&#123;var&#125;</code> 的形式使用。完整的变量列表可以在 curl 的 manpage 中查看。简单介绍一下我们使用的这几个变量：</p><ul><li><code>url_effective</code>: 执行完地址重定向之后的最终 URL；</li><li><code>time_namelookup</code>: 从请求开始至完成名称解析所花的时间，单位为秒，下同；</li><li><code>time_redirect</code>: 执行所有重定向所花的时间；</li><li><code>time_connect</code>: 从请求开始至建立 TCP 连接所花的时间；</li><li><code>time_appconnect</code>: 从请求开始至完成 SSL&#x2F;SSH 握手所花的时间；</li><li><code>time_pretransfer</code>: 从请求开始至服务器准备传送文件所花的时间，包含了传送协商时间；</li><li><code>time_starttransfer</code>: 从请求开始至服务器准备传送第一个字节所花的时间；</li><li><code>time_total</code>: 完整耗时。</li></ul><p>  然后执行请求，通过 <code>@filename</code> 指定保存了格式化字符串的文件：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl -L -s -w @fmt.txt -o /dev/null http://www.google.com</span><br></code></pre></td></tr></table></figure><p>  输出：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Response Time <span class="hljs-keyword">for</span>: http:<span class="hljs-comment">//www.google.co.jp/?gfe_rd=cr&amp;dcr=0&amp;ei=cjIaWpTkHeiQ8QfnxYzoBA</span><br><br>DNS Lookup Time:        <span class="hljs-number">0.000038</span>s<br>Redirection Time:       <span class="hljs-number">0.207271</span>s<br>Connection Time:        <span class="hljs-number">0.000039</span>s<br>App Connection Time:    <span class="hljs-number">0.000039</span>s<br>Pre-transfer Time:      <span class="hljs-number">0.000067</span>s<br>Start-transfer Time:    <span class="hljs-number">0.260115</span>s<br><br>Total Time:             <span class="hljs-number">0.467691</span>s<br></code></pre></td></tr></table></figure></blockquote><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>通过type 命令可以查看命令类型：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim">$ <span class="hljs-built_in">type</span> <span class="hljs-keyword">echo</span><br><span class="hljs-keyword">echo</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">a</span> <span class="hljs-keyword">shell</span> builtin<br></code></pre></td></tr></table></figure><h3 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h3><blockquote><h1 id="Linux-whereis命令"><a href="#Linux-whereis命令" class="headerlink" title="Linux whereis命令"></a>Linux whereis命令</h1><p>  Linux whereis命令用于查找文件。</p><p>  该指令会在特定目录中查找符合条件的文件。这些文件应属于原始代码、二进制文件，或是帮助文件。</p><p>  该指令只能用于查找二进制文件、源代码文件和man手册页，一般文件的定位需使用locate命令。</p><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">whereis <span class="hljs-selector-attr">[-bfmsu]</span><span class="hljs-selector-attr">[-B &lt;目录&gt;...]</span><span class="hljs-selector-attr">[-M &lt;目录&gt;...]</span><span class="hljs-selector-attr">[-S &lt;目录&gt;...]</span><span class="hljs-selector-attr">[文件...]</span><br></code></pre></td></tr></table></figure><p>  <strong>参数</strong>：</p><p>  -b 　只查找二进制文件。</p><p>  -B&lt;目录&gt; 　只在设置的目录下查找二进制文件。</p><p>  -f 　不显示文件名前的路径名称。</p><p>  -m 　只查找说明文件。</p><p>  -M&lt;目录&gt; 　只在设置的目录下查找说明文件。</p><p>  -s 　只查找原始代码文件。</p><p>  -S&lt;目录&gt; 　只在设置的目录下查找原始代码文件。</p><p>  -u 　查找不包含指定类型的文件。</p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>  使用指令”whereis”查看指令”bash”的位置，输入如下命令：</p>  <figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>whereis bash <br></code></pre></td></tr></table></figure><p>  上面的指令执行后，输出信息如下所示：</p>  <figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">bash:</span><span class="hljs-keyword">/bin/</span>bash<span class="hljs-keyword">/etc/</span>bash.bashrc<span class="hljs-keyword">/usr/</span>share<span class="hljs-keyword">/man/</span>man1/bash<span class="hljs-number">.1</span>.gz <br></code></pre></td></tr></table></figure><p>  注意：以上输出信息从左至右分别为查询的程序名、bash路径、bash的man 手册页路径。</p><p>  如果用户需要单独查询二进制文件或帮助文件，可使用如下命令：</p>  <figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">$ whereis -<span class="hljs-keyword">b </span><span class="hljs-keyword">bash </span><br>$ whereis -m <span class="hljs-keyword">bash </span><br></code></pre></td></tr></table></figure><p>  输出信息如下：</p>  <figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts">$ whereis -b bash               <span class="hljs-meta">#显示bash 命令的二进制程序  </span><br><span class="hljs-symbol">bash:</span> <span class="hljs-keyword">/bin/</span>bash <span class="hljs-keyword">/etc/</span>bash.bashrc <span class="hljs-keyword">/usr/</span>share/bash    <span class="hljs-meta"># bash命令的二进制程序的地址  </span><br>$ whereis -m bash               <span class="hljs-meta">#显示bash 命令的帮助文件  </span><br><span class="hljs-symbol">bash:</span> <span class="hljs-keyword">/usr/</span>share<span class="hljs-keyword">/man/</span>man1/bash<span class="hljs-number">.1</span>.gz  <span class="hljs-meta">#bash命令的帮助文件地址  </span><br></code></pre></td></tr></table></figure></blockquote><h3 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h3><ul><li>设置开机自启动 <code>systemctl enable</code> </li><li>停止开机自启动 <code>systemctl disable</code></li><li>验证一下是否为开机启动 <code>systemctl is-enabled</code></li><li>启动服务 <code>systemctl start xxxxx.service</code></li><li>停止服务 <code>systemctl stop xxxxx.service</code></li><li>重启服务 <code>systemctl restart xxxxx.service</code></li><li>查看服务状态 <code>systemctl status xxxxx.service</code></li><li>查看所有已启动的服务 <code>systemctl list-units --type=service</code></li></ul><h3 id="sed-流编辑器"><a href="#sed-流编辑器" class="headerlink" title="sed 流编辑器"></a>sed 流编辑器</h3><p>UNIX 中的 SED 命令代表流编辑器，它可以对文件执行许多功能，如搜索、查找和替换、插入或删除。尽管 UNIX 中 SED 命令的最常见用途是用于替换或查找和替换。通过使用 SED，您甚至可以在不打开文件的情况下编辑文件，这是一种在文件中查找和替换某些内容的方法，比先在 VI 编辑器中打开该文件然后进行更改要快得多。</p><ul><li>SED 是一个强大的文本流编辑器。可以进行插入、删除、搜索和替换（替换）。</li><li>unix 中的 SED 命令支持正则表达式，允许它执行复杂的模式匹配。</li></ul><p><strong>Syntax:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sed OPTIONS... [SCRIPT] [INPUTFILE...] <br></code></pre></td></tr></table></figure><table><thead><tr><th>OPTIONS</th><th></th></tr></thead><tbody><tr><td><strong><code>-b</code></strong>,<strong><code>--binary</code></strong></td><td>以二进制模式打开输入文件以考虑以换行符结束的行。</td></tr><tr><td><strong><code>--debug</code></strong></td><td>切换到调试模式以规范形式打印输入并注释程序执行。</td></tr><tr><td><strong><code>--follow-symlinks</code></strong></td><td>如果指定文件是符号链接，则编辑最终目标。它仅在与**<code>-i</code>**选项结合使用时才有效。</td></tr><tr><td><strong><code>--help</code></strong></td><td>显示使用信息。</td></tr><tr><td><strong><code>--i</code></strong>,<strong><code>--in-place [=SUFFIX]</code></strong></td><td>通过覆盖原始文件就地执行编辑。</td></tr><tr><td><strong><code>--posix</code></strong></td><td>禁用对 POSIX 的所有扩展**<code>sed</code>** 以简化编写可移植脚本。</td></tr><tr><td><strong><code>--version</code></strong></td><td>**<code>sed</code>**显示系统运行的版本。</td></tr><tr><td><strong><code>-E</code></strong>, <strong><code>-r</code></strong>,<strong><code>--regexp-extended</code></strong></td><td>使用扩展的正则表达式。</td></tr><tr><td><strong><code>-e script</code></strong>,<strong><code>--expression=script</code></strong></td><td>添加指定的脚本以与命令一起运行。</td></tr><tr><td><strong><code>-f script-file</code></strong></td><td>添加指定脚本文件的内容以与命令一起运行。</td></tr><tr><td><strong><code>-l N</code></strong>,<strong><code>--line-length=N</code></strong></td><td>为命令定义所需的换行长度**<code>l</code>**（默认值为 70）。</td></tr><tr><td><strong><code>-n</code></strong>, <strong><code>--quiet</code></strong>,<strong><code>--silent</code></strong></td><td>禁用输出打印。</td></tr><tr><td><strong><code>-s</code></strong>,<strong><code>--separate</code></strong></td><td>将指定的文件视为单独的文件，而不是作为单个连续的长流。</td></tr><tr><td><strong><code>--sandbox</code></strong></td><td>禁用运行外部程序并仅在命令行上对输入文件进行操作。</td></tr><tr><td><strong><code>-u</code></strong>,<strong><code>--unbuffered</code></strong></td><td>最小化输入和输出缓冲区。</td></tr><tr><td><strong><code>-z</code></strong>, <strong><code> --null-data</code></strong>,<strong><code> --zero-terminated</code></strong></td><td>将输入视为一组行，每行都以零字节结尾。</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">---------------------------- 替换 ----------------------------</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用 sed 命令替换字符串</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">语法</span><br>sed &#x27;s/old_string/new_string/&#x27; filename.txt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">将box 替换成bin</span><br>sed &#x27;s/box/bin/&#x27; foxinbox.txt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">将box 全部 替换成bin</span><br>sed &#x27;s/box/bin/g&#x27; foxinbox.txt<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">sed 命令替换字符串并忽略大小写</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用 i 指示忽略大小写</span><br>sed &#x27;s/fox/cow/i&#x27; foxinbox.txt<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用 sed 命令替换一行中的特定某次匹配</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">语法 “#”代表数字例如1、2、</span><br>sed &#x27;s/old_string/new_string/#&#x27; filename.txt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">将在每行第2次出现的 box 替换成 bin</span><br>sed &#x27;s/box/bin/2&#x27; foxinbox.txt<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用 sed 命令替换特定行中的字符串</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">该sed命令允许您通过将行号作为前缀添加到子命令来替换特定行中的字符串：</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">语法</span><br>sed &#x27;# s/old_string/new_string/&#x27; filename.txt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">以下命令将文本第四行 中的socks替换为sandals</span><br>sed &#x27;4 s/socks/sandals/&#x27; foxinbox.txt<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">sed 命令仅替换特定行范围内的字符串</span><br>sed &#x27;#,# s/old_string/new_string/&#x27; filename.txt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">将 4-6 行的 socks 替换成 sandals</span> <br>sed &#x27;4,6 s/socks/sandals/&#x27; foxinbox.txt<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">---------------------------- 删除 ----------------------------</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除特定行</span><br>sed &#x27;#,#d&#x27; filename.txt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除第二行</span><br>sed &#x27;2d&#x27; foxinbox.txt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除 2-4行</span><br>sed &#x27;2,4d&#x27; foxinbox.txt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">从特定行删除到最后一行</span><br>sed &#x27;#,$d&#x27; filename.txt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">从第3行删除到末尾</span><br>sed &#x27;3,$d&#x27; foxinbox.txt<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">---------------------------- Misc ----------------------------</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">仅打印带有替换文本的行</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-n选项禁用自动打印，而命令p指示sed打印发生替换的行。</span><br>sed -n &#x27;s/old_string/new_string/p&#x27; filename.txt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">实例</span><br>sed -n &#x27;s/box/bin/p&#x27; foxinbox.txt<br></code></pre></td></tr></table></figure><h1 id="linux-内核原理入土"><a href="#linux-内核原理入土" class="headerlink" title="linux 内核原理入土"></a>linux 内核原理入土</h1><h2 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h2><h2 id="cgroup"><a href="#cgroup" class="headerlink" title="cgroup"></a>cgroup</h2><h1 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h1><h2 id="通过-shell-使用-uart"><a href="#通过-shell-使用-uart" class="headerlink" title="通过 shell 使用 uart"></a>通过 shell 使用 uart</h2><ol><li>获取串口号 <code>ls -lha /dev/tty* </code> 一版串口名为 串口5 <code>ttyS5</code> 串口3 <code>ttyS3</code>  也有部分是 <code>ttyAS3</code>。</li><li><code>cat /dev/ttyS3</code> 接收串口3的数据。</li><li><code>echo helloword &gt; /dev/ttyS3</code> 向串口3发送数据。</li></ol><h2 id="通过-shell-使用-tcp"><a href="#通过-shell-使用-tcp" class="headerlink" title="通过 shell 使用 tcp"></a>通过 shell 使用 tcp</h2><blockquote><p>  linux 设备里面有个比较特殊的文件:</p><p>  <code>/dev/[tcp|upd]/host/port</code> 只要读取或者写入这个文件，相当于系统会尝试连接 host 这台机器，对应port端口。如果主机以及端口存在，就建立一个socket 连接。</p><p>  将在，<code>/proc/self/fd</code>目录下面，有对应的 fd 文件序号出现。</p></blockquote><ol><li><p><strong>请使用 bash</strong> <em>zsh似乎不支持此操作</em> </p></li><li><p><code>cat &lt; /dev/tcp/127.0.0.1/22</code>  </p><ol><li>接收从127.0.0.1:22 端口发送来的数据。<code>&lt;</code> 代表只读通道。</li></ol></li><li><p><code>exec 64&lt;&gt; /dev/tcp/127.0.0.1/22</code> </p><ol><li><p>使用指定的文件描述符 <code>64</code> 建立可读写通道<code>&lt;&gt;</code> 连接 127.0.0.1:22 </p></li><li><p><code>ls /proc/self/fd -lh </code> 可以看到文件描述符 <code>64</code> 的文件</p></li><li><p>发送数据 <code>echo hello &gt;&amp;64</code>  将数据重定向输出到 <code>&amp;64</code> 文件描述符</p><ol><li><blockquote><p>  其实 2&gt;&amp;1 的原理和这个是一致的   文件描述符2是stderr 文件描述符1是stdout</p></blockquote></li></ol></li><li><p>接收数据 <code>cat &lt;&amp;64</code> 将数据重定向输入到<code>&amp;64</code>文件描述符</p></li><li><p>关闭通道 <code>exec 64&gt;&amp;-</code>   使用<code>&gt;&amp;-</code>来关闭指定文件描述符</p><ol><li><code>exec 64&lt;&amp;-</code> 也可以用来关闭</li></ol></li></ol></li></ol><blockquote><p>  <strong>从时间服务器读取时间：</strong></p><p>  <code>cat&lt;/dev/tcp/time.nist.gov/13</code></p><p>  <strong>获取网页：</strong></p><ul><li><p>创建tcp连接 </p><ul><li><code>exec 64&lt;&gt; /dev/tcp/www.baidu.com/80</code></li></ul></li><li><p>发送http请求头</p><ul><li><code>echo -e &quot;HEAD / HTTP/1.1\n\n\n\n\n&quot;&gt;&amp;64</code></li></ul></li><li><p>获取返回信息</p><ul><li><p><code> cat &lt;&amp;64</code></p></li><li><p>返回值示例</p></li><li><pre><code class="shell">HTTP/1.1 302 FoundConnection: keep-aliveContent-Length: 17931Content-Type: text/htmlDate: Wed, 27 Dec 2023 10:13:53 GMTEtag: &quot;54d9748e-460b&quot;Server: bfe/1.0.8.18        HTTP/1.1 400 Bad Request<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br><br><br><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># `&gt;&gt;`、`&gt;`、`&lt;`、`2&gt;&amp;1`</span></span><br><br>```shell<br><span class="hljs-meta prompt_"># </span><span class="language-bash">&gt; 和 &gt;&gt; 是将一条命令执行结果（标准输出，或者错误输出，本来都要打印到屏幕上面的）重定向其它输出设备（文件，打开文件操作符，或打印机等等）</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;<span class="hljs-comment">#追加内容（原有内容保留）</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">覆盖内容</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt; 命令默认从键盘获得的输入，改成从文件，或者其它打开文件以及设备输入</span><br>&lt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将产生的所有信息丢弃</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">/dev/null</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将错误输出 重定向到 标准输出</span><br><span class="hljs-meta prompt_">2&gt;</span><span class="language-bash">&amp;1</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">0 表示stdin标准输入</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1 表示stdout标准输出</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2 表示stderr标准错误</span><br></code></pre></td></tr></table></figure></code></pre></li></ul></li></ul></blockquote><h1 id="Editor"><a href="#Editor" class="headerlink" title="Editor"></a>Editor</h1><h2 id="VIM"><a href="#VIM" class="headerlink" title="VIM"></a>VIM</h2><ul><li>命令模式（Command mode）</li><li>插入模式（Insert mode）</li><li>底线命令模式（Last line mode）</li></ul><h3 id="指令模式"><a href="#指令模式" class="headerlink" title="指令模式"></a>指令模式</h3><p>(n)&#x3D;数字</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td></td><td>i</td><td>前面插入</td></tr><tr><td></td><td>I</td><td>行首插入</td></tr><tr><td></td><td>a</td><td>后面插入</td></tr><tr><td></td><td>A</td><td>行尾插入</td></tr><tr><td></td><td>o</td><td>下方新建一行</td></tr><tr><td></td><td>O</td><td>上面新建一行</td></tr><tr><td></td><td>s</td><td>删除字符</td></tr><tr><td></td><td>r</td><td>替换字符</td></tr><tr><td>∆</td><td>hjkl</td><td>光标移动</td></tr><tr><td>∆</td><td>(n)G</td><td>光标移动到第n行 跳转到行</td></tr><tr><td></td><td>(n)+</td><td>下移n行</td></tr><tr><td></td><td>(n)-</td><td>上移n行</td></tr><tr><td></td><td>Ctrl+f</td><td>上一页</td></tr><tr><td></td><td>Ctrl+b</td><td>下一页</td></tr><tr><td></td><td>cc</td><td>删除整行，并修改</td></tr><tr><td>∆</td><td>dd</td><td>删除整行</td></tr><tr><td></td><td>(n)dd</td><td>删除n行</td></tr><tr><td></td><td>x</td><td>删除光标所在字符</td></tr><tr><td></td><td>X</td><td>删除光标前一个字符</td></tr><tr><td>∆</td><td>yy</td><td>复制整行</td></tr><tr><td></td><td>(n)yy</td><td>复制n行</td></tr><tr><td>∆</td><td>v</td><td>选择 开始<br>按下 <code>v</code> 来选择字符。<br>（也可以用 <code>V</code> 来选择整行，<code>Ctrl-v</code> 来选择矩形块）</td></tr><tr><td>∆</td><td>d</td><td>剪切 结束<br/>光标移动到结束剪切的位置。 <br>按下 <code>d</code> 来剪切。</td></tr><tr><td>∆</td><td>y</td><td>复制 结束<br/>光标移动到结束复制的位置。 <br/>按下 <code>y</code> 来复制。</td></tr><tr><td>∆</td><td>p</td><td>粘贴</td></tr><tr><td>∆</td><td>u</td><td>撤销</td></tr><tr><td></td><td>^r</td><td>重做</td></tr></tbody></table><h3 id="底行模式"><a href="#底行模式" class="headerlink" title="底行模式"></a>底行模式</h3><h4 id="指令"><a href="#指令" class="headerlink" title=": 指令"></a>: 指令</h4><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>x</td><td>保存退出</td></tr><tr><td>q!</td><td>不保存强制退出</td></tr><tr><td>(n)</td><td>跳转到行<code>:n 需要回车</code></td></tr></tbody></table><h4 id="搜索"><a href="#搜索" class="headerlink" title="&#x2F; 搜索"></a>&#x2F; 搜索</h4><ul><li>查看下一个匹配，按下n(小写n)</li><li>跳转到上一个匹配，按下N（大写N）</li><li>noh或者set noh 高亮</li></ul><h2 id="VIM-Note"><a href="#VIM-Note" class="headerlink" title="VIM Note"></a>VIM Note</h2><h3 id="跳转到行"><a href="#跳转到行" class="headerlink" title="跳转到行"></a>跳转到行</h3><ul><li>指令模式 <code>(n)G</code>  光标移动到第n行 跳转到行</li><li>底行模式 <code>:n</code> （跳转到文件第n行，需要回车）</li><li><code>vim +n filename</code> （在打开文件后，跳转到文件的第n行）</li></ul><h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><blockquote><p>  :[range]s&#x2F;from&#x2F;to&#x2F;[flags]</p><p>  range:搜索范围，如果没有指定范围，则作用于但前行。</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">:1,10s/<span class="hljs-keyword">from</span>/<span class="hljs-keyword">to</span>/ 表示在第1到第10行（包含第1，第10行）之间搜索替换；<br>:10s/<span class="hljs-keyword">from</span>/<span class="hljs-keyword">to</span>/ 表示只在第10行搜索替换；<br>:%s/<span class="hljs-keyword">from</span>/<span class="hljs-keyword">to</span>/ 表示在所有行中搜索替换；<br>:1,<span class="hljs-variable">$s</span>/<span class="hljs-keyword">from</span>/<span class="hljs-keyword">to</span>/ 同上。<br></code></pre></td></tr></table></figure><p>  flags 有如下四个选项：</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">c confirm，每次替换前询问；<br>e error， 不显示错误；<br><span class="hljs-selector-tag">g</span> globle，不询问，整行替换。如果不加<span class="hljs-selector-tag">g</span>选项，则只替换每行的第一个匹配到的字符串；<br><span class="hljs-selector-tag">i</span> ignore，忽略大小写。<br></code></pre></td></tr></table></figure></blockquote><ol><li><p>vim 中可用 :s 命令来替换字符串，具体如下：</p><ul><li><code>:s/str1/str2/</code> 替换当前行第一个 str1 为 str2</li><li><code>:s/str1/str2/g</code> 替换当前行中所有 str1 为 str2</li><li><code>:m,ns/str1/str2/</code> 替换第 n 行开始到最后一行中每一行的第一个 str1 为 str2</li><li><code>:m,ns/str1/str2/g</code> 替换第 n 行开始到最后一行中所有的 str1 为 str2<br>(注：m和n 为数字，若m为 .，表示为当前行开始；若n为$，则表示到最后一行结束)<br>如果使用 # 作为分隔符，则中间出现的 &#x2F; 不会作为分隔符，比如：<br><code>:s#str1/#str2/#</code> 替换当前行第一个 str1&#x2F; 为 str2&#x2F;<br><code>:%s+/oradata/apras/+/user01/apras1+</code> (使用+ 来 替换 &#x2F; )： &#x2F;oradata&#x2F;apras&#x2F;替换成&#x2F;user01&#x2F;apras1&#x2F;</li></ul></li><li><p>其他:</p></li></ol><ul><li><code>%s/str1/str2/</code>（等同于 :g&#x2F;str1&#x2F;s&#x2F;&#x2F;str2&#x2F;） 替换每一行的第一个 str1 为 str2</li><li><code>:%s/str1/str2/g</code>（等同于 :g&#x2F;str1&#x2F;s&#x2F;&#x2F;str2&#x2F;g 和 :1,$ s&#x2F;str1&#x2F;str2&#x2F;g ） 替换文中所有 str1 为 str2<br>从替换命令可以看到，g 放在命令末尾，表示对搜索字符串的每次出现进行替换；不加 g，表示只对搜索</li></ul><h4 id="正则表达式替换"><a href="#正则表达式替换" class="headerlink" title="正则表达式替换"></a>正则表达式替换</h4><h5 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h5><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>.</td><td>匹配任意字符</td></tr><tr><td>[abc]</td><td>匹配方括号中的任意一个字符，可用-表示字符范围。如[a-z0-9]匹配小写字母和数字</td></tr><tr><td><code>[^abc]</code></td><td>匹配除方括号中字符之外的任意字符</td></tr><tr><td>\d</td><td>匹配阿拉伯数字，等同于[0-9]</td></tr><tr><td>\D</td><td><code>匹配阿拉伯数字之外的任意字符，等同于[^0-9]</code></td></tr><tr><td>\x</td><td>匹配十六进制数字，等同于[0-9A-Fa-f]</td></tr><tr><td>\X</td><td><code>匹配十六进制数字之外的任意字符，等同于[^0-9A-Fa-f]</code></td></tr><tr><td>\l</td><td>匹配[a-z]</td></tr><tr><td>\L</td><td><code>匹配[^a-z]</code></td></tr><tr><td>\u</td><td>匹配[A-Z]</td></tr><tr><td>\U</td><td><code>匹配[^A-Z]</code></td></tr><tr><td>\w</td><td>匹配单词字母，等同于[0-9A-Za-z_]</td></tr><tr><td>\W</td><td><code>匹配单词字母之外的任意字符，等同于[^0-9A-Za-z_]</code></td></tr><tr><td>\t</td><td>匹配字符</td></tr><tr><td>\s</td><td>匹配空白字符，等同于[\t]</td></tr><tr><td>\S</td><td><code>匹配非空白字符，等同于[^\t]</code></td></tr></tbody></table><h5 id="需转义的普通字符"><a href="#需转义的普通字符" class="headerlink" title="需转义的普通字符"></a>需转义的普通字符</h5><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>*</td><td>匹配 * 字符</td></tr><tr><td>.</td><td>匹配 . 字符</td></tr><tr><td>&#x2F;</td><td>匹配 &#x2F; 字符</td></tr><tr><td>\</td><td>匹配 \ 字符</td></tr><tr><td>[</td><td>匹配 [ 字符</td></tr><tr><td>]</td><td>匹配 ] 字符</td></tr></tbody></table><h5 id="表示数量的元字符"><a href="#表示数量的元字符" class="headerlink" title="表示数量的元字符"></a>表示数量的元字符</h5><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>*</td><td>匹配0-任意个</td></tr><tr><td>+</td><td>匹配1-任意个</td></tr><tr><td>?</td><td>匹配0-1个</td></tr><tr><td>{n,m}</td><td>匹配n-m个</td></tr><tr><td>{n}</td><td>匹配n个</td></tr><tr><td>{n,}</td><td>匹配n-任意个</td></tr><tr><td>{,m}</td><td>匹配0-m个</td></tr></tbody></table><h5 id="表示位置的元字符"><a href="#表示位置的元字符" class="headerlink" title="表示位置的元字符"></a>表示位置的元字符</h5><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>$</td><td>匹配行尾</td></tr><tr><td>^</td><td>匹配行首</td></tr><tr><td>&lt;</td><td>匹配单词词首</td></tr><tr><td>&gt;</td><td>匹配单词词尾</td></tr></tbody></table><hr><h5 id="替换变量"><a href="#替换变量" class="headerlink" title="替换变量"></a>替换变量</h5><p>在正则式中以“”以及“”以及“”括起来的正则表达式，在后面使用的时候可以用“\1”、“\2”等变量来访问“”以及“”以及“”中的内容。</p><p>例子</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">删除行尾空格：                         :%s/\s+$//g<br>删除行首多余空格：                      :%s/^\s*// 或者 %s/^ *//<br>删除沒有內容的空行：                    :%s/^$// 或者 g/^$/d<br>删除包含有空格组成的空行                 :%s/^\s*$// 或者 g/^\s*$/d<br>删除以空格或TAB开头到结尾的空行：         :%s/^[ |\t]*$// 或者 g/^[ |\t]*$/d<br><br>把文中的所有字符串“abc……xyz”替换为“xyz……abc”可以有下列写法<br>:%s/abc\(.*\)xyz/xyz\1abc/g<br>:%s/\(abc\)\(.*\)\(xyz\)/\3\2\1/g<br></code></pre></td></tr></table></figure><h3 id="vim-编辑二进制"><a href="#vim-编辑二进制" class="headerlink" title="vim 编辑二进制"></a>vim 编辑二进制</h3><ol><li><code>vim -b binary_file</code> <code>-b</code> 这个参数设定了 ‘binary’ 选项。</li><li>输入<code>:%!xxd</code>把文件内容以常见的字节偏移 十六进制 ASCII码的版面显示</li><li>然后输入<code>R</code>进入改写模式，即可按照版面格式进行编辑。<br>注意：只有十六进制部分的修改才会被采用。右边ASCII文本部分的修改无效。</li><li>编辑完成以后<code>:%!xxd -r</code>把刚才的编辑格式转换会原始文本格式。</li><li>输入<code>:wq</code>保存退出。</li></ol><h3 id="vim-复制-剪切-粘贴"><a href="#vim-复制-剪切-粘贴" class="headerlink" title="vim 复制 剪切 粘贴"></a>vim 复制 剪切 粘贴</h3><p><a href="https://harttle.land/2022/03/19/vim-copy-paste.html">https://harttle.land/2022/03/19/vim-copy-paste.html</a></p><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">设置 tab = 4 空格</span><br>set ts=4<br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示行号</span><br>set nu<br></code></pre></td></tr></table></figure><h2 id="Nano"><a href="#Nano" class="headerlink" title="Nano"></a>Nano</h2><p>alt+6 复制</p><p>ctrl+u 粘贴</p><h2 id="gedit"><a href="#gedit" class="headerlink" title="gedit"></a>gedit</h2><h1 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h1><table><thead><tr><th>参数</th><th></th><th></th></tr></thead><tbody><tr><td>-o</td><td><code>gcc main.c -o main</code></td><td>指定输出文件名</td></tr><tr><td>-c</td><td><code>gcc main.c -c</code></td><td>只编译输出.o不生成.out可执行文件</td></tr><tr><td>-g</td><td></td><td>生成调试所需的符号信息</td></tr><tr><td>-O&amp;-O2</td><td></td><td>优化&amp;更优化</td></tr><tr><td>-Wall</td><td></td><td><strong>显示警告</strong></td></tr><tr><td>-std&#x3D;<standard></td><td><code>-std=c99</code></td><td>使用C99标准</td></tr></tbody></table><h1 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h1><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 依赖main.o input.o calcu.o生成 main ,如果依赖文件不存在就会根据规则生成相应的 *.o 文件</span><br><span class="hljs-section">main: main.o input.o calcu.o</span><br>gcc -o main main.o input.o calcu.o<br><br><span class="hljs-section">main.o: main.c</span><br>gcc -c main.c<br><span class="hljs-section">input.o: input.c</span><br>gcc -c input.c<br><span class="hljs-section">calcu.o: calcu.c</span><br>gcc -c calcu.c<br><br><span class="hljs-section">clean:</span><br>rm *.o<br>rm main<br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title="&#x3D;"></a>&#x3D;</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile">name = sss<br>cur = <span class="hljs-variable">$(name)</span><br>name = ppp<br><br><span class="hljs-section">print:</span><br>@echo cur: <span class="hljs-variable">$(cur)</span><br><br><span class="hljs-comment"># 这里会输出 ppp</span><br></code></pre></td></tr></table></figure><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>&#x3D;</td><td>类似指针,值等于其真实值</td></tr><tr><td>:&#x3D;</td><td>类似赋值,等于其赋值时的值</td></tr><tr><td>?&#x3D;</td><td>如果变量没有赋值,就赋后面的值</td></tr><tr><td>+&#x3D;</td><td>类似字符串后面追加一个字符串</td></tr><tr><td>%</td><td>代表非空字符串,可用于匹配文件名</td></tr></tbody></table><h2 id="自动化变量"><a href="#自动化变量" class="headerlink" title="自动化变量"></a>自动化变量</h2><table><thead><tr><th></th><th>自动化变量</th></tr></thead><tbody><tr><td>$@</td><td>规则中的目标集合，在模式规则中，如果有多个目标的话，“ $@”表示匹配模式中定义的目标集合。</td></tr><tr><td>$&lt;</td><td>所有依赖文件的集合， 使用空格分开， 如果在依赖文件中有多个重复的文件，“$^”会去除重复的依赖文件，值保留一份。</td></tr><tr><td>$^</td><td>依赖文件集合中的第一个，如果依赖文件是以模式 (即“ %”)定义的，那么 “$&lt;”就是符合模式的一系列文件集。</td></tr><tr><td>$?</td><td>所有比目标新的依赖集合，以空格分开。</td></tr><tr><td>$%</td><td>当目标是函数库的时候表示规则中成员名， 如果目标不是函数库文件，那么其值为空。</td></tr><tr><td>$+</td><td>和“ $^”类似，但是当依赖文件存在重复的话不会去除重复的依赖文件。</td></tr><tr><td>$*</td><td>这个变量表示目标模式中”%”及其之前的部分，如果目标是 test&#x2F;a.test.c，目标模 ，目标模为 a.%.c，那么“ $*”就是test&#x2F;a.test。</td></tr><tr><td>$(XX)</td><td>类似替换成XX的值</td></tr></tbody></table><h2 id="伪目标"><a href="#伪目标" class="headerlink" title="伪目标"></a>伪目标</h2><p>例如，目录内存在clean文件运行 make clean 则运行的是clean文件的规则，如果将Makefile文件内的clean定义为伪目标则不管如何都是执行Makefile内的指令。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs makefile">objects = main.o input.o calcu.o<br><span class="hljs-section">main: <span class="hljs-variable">$(objects)</span></span><br>gcc -o main <span class="hljs-variable">$(objects)</span> <br><span class="hljs-comment"># 声明伪目标</span><br>.PHONY : clean<br><br>%.o : %.c<br>gcc -c <span class="hljs-variable">$&lt;</span><br><br><span class="hljs-section">clean:</span><br>rm *.o<br>rm main<br></code></pre></td></tr></table></figure><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><ul><li>ifeq 比较参数是否相等</li><li>ifneq</li><li>ifdef 判断变量是否为真</li><li>ifndef</li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="subst-字符串替换"><a href="#subst-字符串替换" class="headerlink" title="subst 字符串替换"></a>subst 字符串替换</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile">$(subst&lt;from&gt;,&lt;to&gt;,&lt;text&gt;)<br><span class="hljs-comment"># 字符串替换</span><br><span class="hljs-comment"># 将text中的from替换成to,函数返回替换以后的字符串</span><br><br><span class="hljs-comment">#例</span><br><span class="hljs-variable">$(<span class="hljs-built_in">subst</span> ppp,lll,my name is ppp)</span><br><span class="hljs-comment"># my name is lll</span><br></code></pre></td></tr></table></figure><h3 id="patsubst-模式字符串替换"><a href="#patsubst-模式字符串替换" class="headerlink" title="patsubst 模式字符串替换"></a>patsubst 模式字符串替换</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)</span><br><span class="hljs-comment"># 查找text单词是否符合模式pattern,符合就用replacement替换</span><br><br><span class="hljs-comment"># 例</span><br><span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %.c,%.o,a.c b.c c.c)</span><br><span class="hljs-comment"># “a.o b.o c.o”</span><br></code></pre></td></tr></table></figure><h3 id="dir-获取目录"><a href="#dir-获取目录" class="headerlink" title="dir 获取目录"></a>dir 获取目录</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">dir</span> &lt;names…&gt;)</span><br><span class="hljs-comment"># 此函数用来从文件名序列&lt;names&gt;中提取出目录部分</span><br><br><span class="hljs-comment"># 例</span><br><span class="hljs-variable">$(<span class="hljs-built_in">dir</span> &lt;/src/a.c&gt;)</span><br><span class="hljs-comment"># /src</span><br></code></pre></td></tr></table></figure><h3 id="notdir-去除文件中目录部分"><a href="#notdir-去除文件中目录部分" class="headerlink" title="notdir 去除文件中目录部分"></a>notdir 去除文件中目录部分</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">notdir</span> &lt;names…&gt;)</span><br><span class="hljs-comment"># 此函数用与从文件名序列&lt;names&gt;中提取出文件名非目录部分</span><br><br><span class="hljs-comment"># 例</span><br><span class="hljs-variable">$(<span class="hljs-built_in">notdir</span> &lt;/src/a.c&gt;)</span><br><span class="hljs-comment"># a.c</span><br></code></pre></td></tr></table></figure><h3 id="freach-循环"><a href="#freach-循环" class="headerlink" title="freach 循环"></a>freach 循环</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> &lt;var&gt;, &lt;list&gt;,&lt;text&gt;)</span><br><span class="hljs-comment"># foreach函数用来完成循环，用法如下</span><br><span class="hljs-comment"># 此函数的意思就是把参数&lt;list&gt;中的单词逐一取出来放到参数&lt;var&gt;中，然后再执行&lt;text&gt;所包含的表达式。每次&lt;text&gt;都会返回一个字符串，循环的过程中，&lt;text&gt;中所包含的每个字符串会以空格隔开,最后但整个循环结束时,&lt;text&gt;所返回的每个字符串所组成的整个字符串将会是函数foreach函数的返回值。</span><br></code></pre></td></tr></table></figure><h3 id="wildcard-函数"><a href="#wildcard-函数" class="headerlink" title="wildcard 函数"></a>wildcard 函数</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> PATTERN…)</span><br><span class="hljs-comment">#通配符“ 通配符“ %”只能用在规则中， 只有在规则中它才会展开，如果在变量定义和函数使用时通配符不会自动展开，这个时候就要用到函数wildcard</span><br><br><span class="hljs-comment"># 例</span><br><span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> *.c)</span><br><span class="hljs-comment">#上面的代码是用来获取当前目录下所有.c文件，类似“%”</span><br></code></pre></td></tr></table></figure><h1 id="一些包"><a href="#一些包" class="headerlink" title="一些包"></a>一些包</h1><h2 id="iperf-网络流量测试"><a href="#iperf-网络流量测试" class="headerlink" title="iperf 网络流量测试"></a>iperf 网络流量测试</h2><p><a href="https://blog.csdn.net/bingyu9875/article/details/105700655/">https://blog.csdn.net/bingyu9875/article/details/105700655/</a></p><p><strong>官方网站：</strong><a href="https://iperf.fr/">https://iperf.fr/</a> </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs shell">Usage: iperf [-s|-c host] [options]<br>       iperf [-h|--help] [-v|--version]<br><br>Server or Client:<br>  -p, --port      #         server port to listen on/connect to<br>  -f, --format    [kmgKMG]  format to report: Kbits, Mbits, KBytes, MBytes<br>  -i, --interval  #         seconds between periodic bandwidth reports<br>  -F, --file name           xmit/recv the specified file<br>  -A, --affinity n/n,m      set CPU affinity<br>  -B, --bind      &lt;host&gt;    bind to a specific interface<br>  -V, --verbose             more detailed output<br>  -J, --json                output in JSON format<br>  -d, --debug               emit debugging output<br>  -v, --version             show version information and quit<br>  -h, --help                show this message and quit<br>Server specific:<br>  -s, --server              run in server mode<br>  -D, --daemon              run the server as a daemon<br>  -1, --one-off             handle one client connection then exit<br>Client specific:<br>  -c, --client    &lt;host&gt;    run in client mode, connecting to &lt;host&gt;<br>  -u, --udp                 use UDP rather than TCP<br>  -b, --bandwidth #[KMG][/#] target bandwidth in bits/sec (0 for unlimited)<br>                            (default 1 Mbit/sec for UDP, unlimited for TCP)<br>                            (optional slash and packet count for burst mode)<br>  -t, --time      #         time in seconds to transmit for (default 10 secs)<br>  -n, --bytes     #[KMG]    number of bytes to transmit (instead of -t)<br>  -k, --blockcount #[KMG]   number of blocks (packets) to transmit (instead of -t or -n)<br>  -l, --len       #[KMG]    length of buffer to read or write<br>                            (default 128 KB for TCP, 8 KB for UDP)<br>  -P, --parallel  #         number of parallel client streams to run<br>  -R, --reverse             run in reverse mode (server sends, client receives)<br>  -w, --window    #[KMG]    set window size / socket buffer size<br>  -C, --linux-congestion &lt;algo&gt;  set TCP congestion control algorithm (Linux only)<br>  -M, --set-mss   #         set TCP maximum segment size (MTU - 40 bytes)<br>  -N, --nodelay             set TCP no delay, disabling Nagle&#x27;s Algorithm<br>  -4, --version4            only use IPv4<br>  -6, --version6            only use IPv6<br>  -S, --tos N               set the IP &#x27;type of service&#x27;<br>  -L, --flowlabel N         set the IPv6 flow label (only supported on Linux)<br>  -Z, --zerocopy            use a &#x27;zero copy&#x27; method of sending data<br>  -O, --omit N              omit the first n seconds<br>  -T, --title str           prefix every output line with this string<br>  --get-server-output       get results from server<br><br>[KMG] indicates options that support a K/M/G suffix for kilo-, mega-, or giga-<br><br>iperf3 homepage at: http://software.es.net/iperf/<br>Report bugs to:     https://github.com/esnet/iperf<br></code></pre></td></tr></table></figure><p>​</p><h2 id="speedometer-网络监控工具"><a href="#speedometer-网络监控工具" class="headerlink" title="speedometer 网络监控工具"></a>speedometer 网络监控工具</h2><h2 id="s-tui-cpu温度使用监测"><a href="#s-tui-cpu温度使用监测" class="headerlink" title="s-tui cpu温度使用监测"></a>s-tui cpu温度使用监测</h2><h2 id="htop-进程查看器"><a href="#htop-进程查看器" class="headerlink" title="htop 进程查看器"></a>htop 进程查看器</h2><h2 id="sysbench-性能测试工具"><a href="#sysbench-性能测试工具" class="headerlink" title="sysbench 性能测试工具"></a>sysbench 性能测试工具</h2><p>Sysbench的测试主要包括以下几个方面：</p><p>1、磁盘io性能</p><p>2、cpu性能</p><p>3、内存分配及传输速度</p><p>4、POSIX线程性能</p><p>5、调度程序性能</p><p>6、数据库性能(OLTP基准测试).</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">4线程 测试cpu 找20000前的所有素数</span><br>sysbench --test=cpu --num-threads=4 --cpu-max-prime=20000 run<br></code></pre></td></tr></table></figure><h2 id="crontab-定期执行程序"><a href="#crontab-定期执行程序" class="headerlink" title="crontab 定期执行程序"></a>crontab 定期执行程序</h2><p><a href="https://www.runoob.com/linux/linux-comm-crontab.html">https://www.runoob.com/linux/linux-comm-crontab.html</a></p><p><strong>注意：</strong>新创建的 cron 任务，不会马上执行，至少要过 2 分钟后才可以，当然你可以重启 cron 来马上执行。</p><h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">crontab [ -u user ] file<br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">crontab [ -u user ] &#123; -l | -r | -e &#125;<br></code></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>crontab 是用来让使用者在固定时间或固定间隔执行程序之用，换句话说，也就是类似使用者的时程表。</p><p>-u user 是指设定指定 user 的时程表，这个前提是你必须要有其权限(比如说是 root)才能够指定他人的时程表。如果不使用 -u user 的话，就是表示设定自己的时程表。</p><p><strong>参数说明</strong>：</p><ul><li>-e : 执行文字编辑器来设定时程表，内定的文字编辑器是 VI，如果你想用别的文字编辑器，则请先设定 VISUAL 环境变数来指定使用那个文字编辑器(比如说 setenv VISUAL joe)</li><li>-r : 删除目前的时程表</li><li>-l : 列出目前的时程表</li></ul><p>时间格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">f1 f2 f3 f4 f5 program<br></code></pre></td></tr></table></figure><ul><li>其中 f1 是表示分钟，f2 表示小时，f3 表示一个月份中的第几日，f4 表示月份，f5 表示一个星期中的第几天。program 表示要执行的程序。</li><li>当 f1 为 * 时表示每分钟都要执行 program，f2 为 * 时表示每小时都要执行程序，其馀类推</li><li>当 f1 为 a-b 时表示从第 a 分钟到第 b 分钟这段时间内要执行，f2 为 a-b 时表示从第 a 到第 b 小时都要执行，其馀类推</li><li>当 f1 为 *&#x2F;n 时表示每 n 分钟个时间间隔执行一次，f2 为 *&#x2F;n 表示每 n 小时个时间间隔执行一次，其馀类推</li><li>当 f1 为 a, b, c,… 时表示第 a, b, c,… 分钟要执行，f2 为 a, b, c,… 时表示第 a, b, c…个小时要执行，其馀类推</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">*    *    *    *    *<br>-    -    -    -    -<br>|    |    |    |    |<br>|    |    |    |    +----- 星期中星期几 (0 - 6) (星期天 为0)<br>|    |    |    +---------- 月份 (1 - 12) <br>|    |    +--------------- 一个月中的第几天 (1 - 31)<br>|    +-------------------- 小时 (0 - 23)<br>+------------------------- 分钟 (0 - 59)<br></code></pre></td></tr></table></figure><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>每一分钟执行一次 &#x2F;bin&#x2F;ls：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">* * * * * /bin/ls<br></code></pre></td></tr></table></figure><p>在 12 月内, 每天的早上 6 点到 12 点，每隔 3 个小时 0 分钟执行一次 &#x2F;usr&#x2F;bin&#x2F;backup：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">0 6-12/3 * 12 * /usr/bin/backup<br></code></pre></td></tr></table></figure><p>周一到周五每天下午 5:00 寄一封信给 <a href="mailto:&#97;&#x6c;&#101;&#120;&#x40;&#100;&#111;&#x6d;&#x61;&#105;&#x6e;&#x2e;&#x6e;&#97;&#x6d;&#x65;">&#97;&#x6c;&#101;&#120;&#x40;&#100;&#111;&#x6d;&#x61;&#105;&#x6e;&#x2e;&#x6e;&#97;&#x6d;&#x65;</a>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">0 17 * * 1-5 mail -s &quot;hi&quot; alex@domain.name &lt; /tmp/maildata<br></code></pre></td></tr></table></figure><p>每月每天的午夜 0 点 20 分, 2 点 20 分, 4 点 20 分….执行 echo “haha”：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">20 0-23/2 * * * echo &quot;haha&quot;<br></code></pre></td></tr></table></figure><p>下面再看看几个具体的例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">0 */2 * * * /sbin/service httpd restart  意思是每两个小时重启一次apache <br><br>50 7 * * * /sbin/service sshd start  意思是每天7：50开启ssh服务 <br><br>50 22 * * * /sbin/service sshd stop  意思是每天22：50关闭ssh服务 <br></code></pre></td></tr></table></figure><h1 id="Note-1"><a href="#Note-1" class="headerlink" title="Note"></a>Note</h1><h2 id="增加开机启动项"><a href="#增加开机启动项" class="headerlink" title="增加开机启动项"></a>增加开机启动项</h2><h3 id="raspberry"><a href="#raspberry" class="headerlink" title="raspberry"></a>raspberry</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo nano /etc/rc.local<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在打开的rc.local找到<span class="hljs-built_in">exit</span> 0，在<span class="hljs-built_in">exit</span> 0 之前添加即可</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">执行这段代码时是使用root用户权限的，注意当前的用户权限，以免因权限问题导致脚本执行失败。</span><br><br></code></pre></td></tr></table></figure><h3 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h3><h4 id="service-方式"><a href="#service-方式" class="headerlink" title="service 方式"></a>service 方式</h4><p>Ubuntu 20.04的服务管理是基于systemd的，因此设置服务自启动最推荐的方法是创建一个systemd服务文件，配置好要执行的服务。</p><ol><li>创建我们需要开机自启动的脚本，例如<code>start.sh</code>，其内容如下：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br><br><span class="hljs-built_in">cd</span> /tmp<br><span class="hljs-built_in">touch</span> 11111111111.txt<br><br></code></pre></td></tr></table></figure><ol start="2"><li>在<code>/etc/systemd/system</code>目录下创建一个systemd服务文件, 命名为<code>xxxxxx.service</code>, 内容如下：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">[Unit]<br>Description=frank rc Service<br>After=network.service nss-lookup.target<br><br>[Service]<br>User=frank<br>ExecStart=/home/hqc/test.sh<br><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure><ul><li><p>After表示服务何时启动，After&#x3D;network.service 表示网络连接完成后，启动我们的服务；</p></li><li><p>User 表示使用哪个用户去执行，这里最好去设定特定的用户防止使用root执行</p></li><li><p>ExecStart表示我们的脚本（步骤1中的test.sh)的路径；注意要填绝对路径</p></li><li><p>WantedBy默认填default.target。</p></li><li><p><strong>xxxxxx.service 内容释义</strong></p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">[Unit]:服务的说明<br>Description:描述服务<br>After:描述服务类别<br><br>[Service]服务运行参数的设置<br>Type=forking            是后台运行的形式<br>ExecStart               为服务的具体运行命令<br>ExecReload              为服务的重启命令<br>ExecStop                为服务的停止命令<br>PrivateTmp=True         表示给服务分配独立的临时空间<br>注意：启动、重启、停止命令全部要求使用绝对路径<br><br>[Install]               服务安装的相关设置，可设置为多用户<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure></li></ul><ol start="3"><li>给脚本增加运行权限</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> +x start.sh<br></code></pre></td></tr></table></figure><ol start="4"><li>重新加载系统的systemd服务文件，并启用我们自己写的<code>xxxxxx.service</code>文件。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> systemctl daemon-reload<br><span class="hljs-comment"># /etc/systemd/user 目录创建用这个命令</span><br>systemctl --user <span class="hljs-built_in">enable</span> xxxxxx.service <br><span class="hljs-comment"># /etc/systemd/system 目录创建用这个命令</span><br><span class="hljs-built_in">sudo</span> systemctl <span class="hljs-built_in">enable</span> xxxxxx.service <br></code></pre></td></tr></table></figure><blockquote><p>  <em>用systemd启动的服务默认是root权限，放脚本很不安全，如果只需要登录用户的权限，改成user service (systemctl –user)更好，如果有桌面环境，还可以用XDG Autostart</em></p><p>  改成 (systemctl –user) 似乎这个用户不登陆这个脚本就没法执行了</p><p>  用脚本执行多个程序，如果脚本退出了，程序也就退出了</p></blockquote><h4 id="profile-d"><a href="#profile-d" class="headerlink" title="profile.d"></a>profile.d</h4><p>将写好的脚本（.sh文件）放到目录 &#x2F;etc&#x2F;profile.d&#x2F; 下，系统启动后就会自动执行该目录下的所有shell脚本。</p><blockquote><p>  Ubuntu 20.04.4 LTS service </p><p>  放在这个目录里面似乎要在用户登录了之后才会启动服务</p></blockquote><h2 id="zerotier"><a href="#zerotier" class="headerlink" title="zerotier"></a>zerotier</h2><p><strong>官方定义的名词</strong></p><ul><li>PLANET 行星服务器，Zerotier 根服务器 </li><li>MOON 卫星服务器，用户自建的私有根服务器，起到代理加速的作用 </li><li>LEAF  叶子节点，网络客户端，就是每台连接到网络节点。</li></ul><p><strong>下载安装</strong></p><p><a href="https://www.zerotier.com/download/">https://www.zerotier.com/download/</a></p><p>查看安装zerotier版本<br><code>sudo zerotier-cli status</code></p><p>加入一个netWork<br><code>sudo zerotier-cli join ################（networkid）</code></p><p>查看加入的网络的信息，比如network<br><code>sudo zerotier-cli listnetworks</code></p><p>退出加入的network网段<br><code>sudo zerotier-cli leave ################（networkid）</code></p><h3 id="搭建moon节点"><a href="#搭建moon节点" class="headerlink" title="搭建moon节点"></a>搭建moon节点</h3><p><strong>搭建moon节点的需求</strong></p><ul><li>需要一台公网服务器</li><li>公网服务器需要加入网络</li></ul><p><strong>搭建步骤</strong></p><ol><li><p>生成moon模板</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /var/lib/zerotier-one<br>zerotier-idtool initmoon identity.public &gt; moon.json<br></code></pre></td></tr></table></figure></li><li><p>修改moon配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vi moon.json<br></code></pre></td></tr></table></figure><ul><li>修改”stableEndpoints”为 vps 的公网的 IP,例如”stableEndpoints”: [“1.1.1.1&#x2F;9993”]</li></ul></li><li><p>生成签名文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">zerotier-idtool genmoon moon.json<br></code></pre></td></tr></table></figure><ul><li>执行之后会生产一个000000xxxx.moon的文件，将这个文件用Winscp等工具从vps上下载下来。</li></ul></li><li><p>将moon节点加入网络, 这一步公网服务器和其他所有的主机都需要操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">zerotier-one目录下操作</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Windows:</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">C:\ProgramData\ZeroTier\One</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Linux:</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">/var/lib/zerotier-one</span><br>mkdir moons.d<br>mv ./*.moon ./moons.d/<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">重启服务</span><br>service zerotier-one restart<br></code></pre></td></tr></table></figure></li><li><p>检查是否成功连上节点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">zerotier-cli listpeers<br></code></pre></td></tr></table></figure><ul><li><strong>&lt;role&gt;<strong>里面有出现</strong>MOON</strong>那就是<strong>成功加入了</strong></li></ul></li></ol><p><strong>OpenWrt加moon节点有所不同</strong></p><p>OpenWrt需要修改一个脚本，因为其var目录时一个内存虚拟的临时目录，重启后原有配置不会保留。通过ssh连接OpenWrt（ssh功能可在系统-&gt;管理权中开启）。</p><p>执行命令：<code>vi /etc/init.d/zerotier</code>，在“add_join() {”上方插入两行代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p <span class="hljs-variable">$CONFIG_PATH</span>/moons.d<br><span class="hljs-built_in">cp</span> /home/moons.d/* <span class="hljs-variable">$CONFIG_PATH</span>/moons.d/<br></code></pre></td></tr></table></figure><p><img src="/2020/d4436089/5e3e5278d08a31313.png_e1080.jpg" alt="修改OpenWrt中ZeroTier的启动脚本"></p><p>脚本修改完成后，在&#x2F;home目录下新建一个moons.d文件夹，将000000xxxx.moon文件上传到该文件夹，在Web页面上重启ZeroTier即可。</p><h2 id="添加sudo管理员权限"><a href="#添加sudo管理员权限" class="headerlink" title="添加sudo管理员权限"></a>添加sudo管理员权限</h2><p>1.切换到root用户下<br>2.添加sudo文件的写权限,命令是:</p><p>sudo chmod u+w &#x2F;etc&#x2F;sudoers<br>3.编辑sudoers文件</p><p>sudo nano &#x2F;etc&#x2F;sudoers<br>找到这行 root ALL&#x3D;(ALL) ALL,在他下面添加</p><p>xxx ALL&#x3D;(ALL) ALL (这里的xxx是你的用户名)<br>4.撤销sudoers文件写权限,命令:</p><p>sudo chmod u-w &#x2F;etc&#x2F;sudoers</p><h2 id="允许root账号登录-并修改root密码"><a href="#允许root账号登录-并修改root密码" class="headerlink" title="允许root账号登录 并修改root密码"></a>允许root账号登录 并修改root密码</h2><ol><li>允许root登录</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/ssh/sshd_config<br></code></pre></td></tr></table></figure><p>将 <code>#PermitRootLogin prohibit password</code> 修改为 <code>PermitRootLogin yes</code></p><ol start="2"><li>修改root密码</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">synouser --setpw root password<br><br>reboot<br></code></pre></td></tr></table></figure><h2 id="查看端口被占用情况"><a href="#查看端口被占用情况" class="headerlink" title="查看端口被占用情况"></a>查看端口被占用情况</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">lsof is a <span class="hljs-built_in">command</span> listing open files.</span><br>lsof -i<br>lsof -i:80<br><br>netstat -tunlp<br>netstat -tunlp|grep 80<br></code></pre></td></tr></table></figure><h2 id="windows远程"><a href="#windows远程" class="headerlink" title="windows远程"></a>windows远程</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install xrdp<br></code></pre></td></tr></table></figure><h2 id="route-路由"><a href="#route-路由" class="headerlink" title="route 路由"></a>route 路由</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Note:</span><br>直接可达, 用 dev 配置路由, 标识符 U<br>间接可达, 用 gw 配置网关路由, 标识符 UG<br></code></pre></td></tr></table></figure><p><strong>route 输出结果解析：</strong></p><ul><li>Destination：目标网络或目标主机</li><li>Gateway：网关地址或 ‘*’ （如未设置）</li><li>Genmask：目标网络的子网掩码；’255.255.255.255’为主机，’0.0.0.0’为缺省路由</li><li>Flags：路由标志<ul><li>U (route is up) ：路由正常</li><li>H (target is a host) ：主机路由</li><li>G (use gateway) ：使用网关的间接路由</li><li>R (reinstate route for dynamic routing) ：为动态选路恢复路由</li><li>D (dynamically installed by daemon or redirect) ：该路由由选路进程或重定向动态创建</li><li>M (modified from routing daemon or rederict) ：该路由已由选路进程或重定向修改</li><li>! (reject route) ：阻塞路由</li></ul></li><li>Metric：通向目标的距离(通常以跳来计算)</li><li>Ref：使用此路由的活动进程个数(Linux内核并不使用)</li><li>Use：查找此路由的次数。根据-F 和 -C的使用，此数值是路由缓存的损失数或采样数</li><li>Iface：使用此路由发送分组的接口（网卡名字）</li><li>MSS：基于此路由的TCP连接的缺省最大报文段长度</li><li>Window：基于此路由的TCP连接的缺省窗口长度</li><li>irtt：初始往返时间。内核用它来猜测最佳TCP协议参数而无须等待(可能很慢的)应答</li><li>HH (cached only)：为缓存过的路由而访问硬件报头缓存的ARP记录和缓存路由的数量。如果缓存过路由的接口(如lo)无须硬件地址则值为-1</li><li>Arp (cached only)：无论缓存路由所用的硬件地址情况如何都进行更新</li></ul><p>route命令从<code>/proc/net/route</code>文件中取数据，设备名不变、目的地址从右到左每两位十六进制显示，标志位有1、3两种，分别是U和UG，掩码和目的地</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">frank@OIKIOU-PQ:~$ <span class="hljs-built_in">cat</span> /proc/net/route<br>Iface   Destination     Gateway         Flags   RefCnt  Use     Metric  Mask            MTU     Window  IRTT                                       <br>eth0    00000000        011015AC        0003    0       0       0       00000000        0       0       0                                          <br>docker0 000011AC        00000000        0001    0       0       0       0000FFFF        0       0       0                                          <br>eth0    001015AC        00000000        0001    0       0       0       00F0FFFF        0       0       0                                          <br>frank@OIKIOU-PQ:~$ route<br>Kernel IP routing table<br>Destination     Gateway         Genmask         Flags Metric Ref    Use Iface<br>default         OIKIOU-PQ.mshom 0.0.0.0         UG    0      0        0 eth0<br>172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0<br>172.21.16.0     0.0.0.0         255.255.240.0   U     0      0        0 eth0<br><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">删除默认路由</span><br>route del default<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">linux静态路由查看</span><br>route -n<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置指定网段路由</span><br>route add -net 192.168.3.0 netmask 255.255.255.0 gw 192.168.6.66<br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者</span><br>route add -net 192.168.3.0/24 gw 192.168.6.66<br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者 添加特定接口的路由</span><br>route add -net 10.1.1.0/24 dev ztrfyiymyx<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除指定网段路由</span><br>route del -net 192.168.3.0 netmask 255.255.255.0<br></code></pre></td></tr></table></figure><p>用电脑代替路由器，必须要启用电脑的IP转发功能，改&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward里的内容为1（默认为0），用下面的命令完成<code>echo 1 &gt; /proc/sys/net/ipv4/ip_forward</code><br>网络重启后，上面的文件自动改为0</p><p><strong>永久修改路由：</strong><br>直接执行route命令来添加路由，是不会永久保存的，当网卡重启或者机器重启之后，该路由就失效了。要想永久保存，可以保存到配置文件。linux 默认只支持一条默认路由，当重新启动网口时，会把其他默认路由去掉，只剩下一条该网口生成的默认路由。</p><ol><li><code>/etc/sysconfig/static-routes</code>文件为路由固化文件，但是linux系统一般不会自动生成，需要手动创建。</li><li>在文件内编辑路由，路由格式是固定的：<ul><li>添加默认路由：<code>any net 0.0.0.0 netmask 0.0.0.0 gw 10.60.60.1</code></li><li>添加网络路由：<code>any net 1.1.1.0 netmask 255.255.255.0 gw 10.60.60.1</code></li></ul></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">添加到主机的路由：<br>any host 192.168.101.200 gw 192.168.101.1<br>添加到网络的路由：<br>any net 192.168.101.0/24 gw 192.168.101.1<br>any net 1.1.1.0 netmask 255.255.255.0 gw 10.60.60.1<br></code></pre></td></tr></table></figure><h2 id="samba-文件共享"><a href="#samba-文件共享" class="headerlink" title="samba 文件共享"></a>samba 文件共享</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装</span><br>sudo apt-get install samba<br><span class="hljs-meta prompt_"># </span><span class="language-bash">配置</span><br>sudo nano /etc/samba/smb.conf<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在末尾加入如下内容</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">分享名称</span><br>[Pi]<br>    # 说明信息<br>    comment = PiStorage<br>    # 可以访问的用户<br>    valid users = pi,root<br>    # 共享文件的路径,raspberry pi 会自动将连接到其上的外接存储设备挂载到/media/pi/目录下。<br>    path = /media/pi/<br>    # 可被其他人看到资源名称（非内容）<br>    browseable = yes<br>    # 可写<br>    writable = yes<br>    # 新建文件的权限为 664<br>    create mask = 0664<br>    # 新建目录的权限为 775<br>    directory mask = 0775<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">测试配置文件是否有错误，根据提示做相应修改</span><br>testparm<br><span class="hljs-meta prompt_"># </span><span class="language-bash">添加登陆账户并创建密码，必须是 linux 已存在的用户</span><br>sudo smbpasswd -a pi<br><span class="hljs-meta prompt_"># </span><span class="language-bash">重启 samba 服务</span><br>sudo service smbd restart<br><br>sudo /etc/init.d/samba restart<br>sudo /etc/init.d/smbd restart<br>sudo /etc/init.d/nmbd restart<br></code></pre></td></tr></table></figure><h3 id="attention"><a href="#attention" class="headerlink" title="attention"></a>attention</h3><p>出现过win10无法访问，</p><p>“gpedit.msc” “计算机配置”“管理模板”“网络”“Lanman工作站”“启用不安全的来宾登录”&#x3D;“已启用”</p><h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><p>在客户端Linux系统上，使用<code>mount</code>命令临时挂载Samba共享。基本语法如下：</p><p><code>sudo mount -t cifs //&lt;server&gt;/&lt;share&gt; &lt;mount-point&gt; -o &lt;options&gt;</code></p><p>例如，要将位于<code>192.168.0.100/shared</code>的Samba共享挂载到<code>/mnt/samba</code>目录，可以使用：</p><p><code>sudo mount -t cifs //192.168.0.100/shared /mnt/samba -o username=&lt;username&gt;,password=&lt;password&gt;</code></p><p>在Ubuntu 22.04上，您需要安装<code>cifs-utils</code>包来挂载SMB共享，并创建一个凭证文件以安全地存储用户名和密码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install cifs-utils -y<br><span class="hljs-meta prompt_"># </span><span class="language-bash">为了安全地存储访问 Samba 共享所需的用户名和密码 创建一个凭证文件。</span><br>sudo nano /root/.smbcredentials<br><span class="hljs-meta prompt_"># </span><span class="language-bash">添加以下内容</span><br>username=&lt;username&gt;<br>password=&lt;password&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">确保只有 root 用户可以读取</span><br>sudo chmod 600 /root/.smbcredentials<br><br></code></pre></td></tr></table></figure><p><strong>手动挂载</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo mount -t cifs //server/share /mnt/samba_share -o uid=1000,gid=1000,credentials=/root/.smbcredentials,vers=3.0<br></code></pre></td></tr></table></figure><p>其中 <code>//server/share</code> 是 Samba 服务器的共享路径，<code>/mnt/samba_share</code> 是挂载点。<code>credentials</code> 选项指定了凭证文件的位置，<code>vers=3.0</code> 指定了使用的 SMB 版本</p><p><strong>自动挂载</strong><br>在<code>/etc/fstab</code>文件中添加挂载信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">//server/share /mnt/samba_share cifs uid=1000,gid=1000,vers=3.0,credentials=/root/.smbcredentials<br><span class="hljs-meta prompt_"># </span><span class="language-bash">这里制定了用户名和用户组</span><br></code></pre></td></tr></table></figure><p>测试挂载是否成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo mount -a<br></code></pre></td></tr></table></figure><h2 id="NFS-网络文件系统"><a href="#NFS-网络文件系统" class="headerlink" title="NFS 网络文件系统"></a>NFS 网络文件系统</h2><p>网络文件系统 (Network File System)</p><h2 id="TFTP-文件传输"><a href="#TFTP-文件传输" class="headerlink" title="TFTP 文件传输"></a>TFTP 文件传输</h2><p><em>TFTP</em>（Trivial File Transfer Protocol,简单文件传输协议）</p><h2 id="固定ip"><a href="#固定ip" class="headerlink" title="固定ip"></a>固定ip</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">ens33 是网卡名</span><br>vi /etc/sysconfig/network-scripts/ifcfg-eth0<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将 BOOTPROTO=dhcp</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">改成</span><br>BOOTPROTO=static3<br><span class="hljs-meta prompt_"># </span><span class="language-bash">增加</span><br>IPADDR=192.168.2.2<br>NETMASK=255.255.255.0<br>GATEWAY=192.168.2.1<br>DNS1=223.5.5.5<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Raspberry</span><br><span class="hljs-built_in">sudo</span> nano /etc/dhcpcd.conf<br><br><span class="hljs-comment"># 找到如下内容 对应修改即可</span><br><span class="hljs-comment"># Example static IP configuration:</span><br><span class="hljs-comment">#interface eth0</span><br><span class="hljs-comment">#static ip_address=192.168.0.10/24</span><br><span class="hljs-comment">#static ip6_address=fd51:42f8:caae:d92e::ff/64</span><br><span class="hljs-comment">#static routers=192.168.0.1</span><br><span class="hljs-comment">#static domain_name_servers=192.168.0.1 8.8.8.8 fd51:42f8:caae:d92e::1</span><br><br><span class="hljs-comment"># eg.</span><br>interface wlan0<br>static ip_address=192.168.31.222/24<br>static routers=192.168.31.254<br>static domain_name_servers=223.5.5.5 192.168.31.254<br></code></pre></td></tr></table></figure><h2 id="后台执行程序"><a href="#后台执行程序" class="headerlink" title="后台执行程序"></a>后台执行程序</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">基本形式</span><br>nohup command &amp;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">eg.</span><br>nohup ping 1.1.1.1 &amp;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">重定向输出</span><br>nohup command &gt; myout.file 2&gt;&amp;1 &amp;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">eg.</span><br>nohup ping 1.1.1.1 &gt; \myout.file 2&gt;&amp;1 &amp;<br></code></pre></td></tr></table></figure><h2 id="开启路由转发"><a href="#开启路由转发" class="headerlink" title="开启路由转发"></a>开启路由转发</h2><p>临时生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">方法1</span><br>echo &quot;1&quot; &gt; /proc/sys/net/ipv4/ip_forward<br><span class="hljs-meta prompt_"># </span><span class="language-bash">方法2</span><br>sudo sh -c &#x27;echo &quot;1&quot; &gt; /proc/sys/net/ipv4/ip_forward&#x27;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">马上生效</span><br>sysctl -p<br></code></pre></td></tr></table></figure><p>永久生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/sysctl.conf<br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改设置</span><br>net.ipv4.ip_forward = 1<br></code></pre></td></tr></table></figure><h2 id="aria2-安装"><a href="#aria2-安装" class="headerlink" title="aria2 安装"></a>aria2 安装</h2><h3 id="aria2"><a href="#aria2" class="headerlink" title="aria2"></a>aria2</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">首先，安装：</span><br>sudo apt-get install aria2<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建 Aria2 的配置文件夹：</span><br>sudo mkdir /etc/aria2<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建 session 和配置文件：</span><br>sudo touch /etc/aria2/aria2.session<br>sudo touch /etc/aria2/aria2.conf<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">编辑 /etc/aria2/aria2.conf：</span><br>sudo nano /etc/aria2/aria2.conf<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 文件保存相关 ##</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 文件保存相关 ##</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 文件保存相关 ##</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">文件保存目录 此处文件保存目录自行设定</span><br>dir=/mnt/usb/aria2<br><span class="hljs-meta prompt_"># </span><span class="language-bash">启用磁盘缓存, 0为禁用缓存, 需1.16以上版本, 默认:16M</span><br>disk-cache=32M<br><span class="hljs-meta prompt_"># </span><span class="language-bash">断点续传</span><br>continue=true<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">文件预分配方式, 能有效降低磁盘碎片, 默认:prealloc</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">预分配所需时间: none &lt; falloc ? trunc &lt; prealloc</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">falloc和trunc则需要文件系统和内核支持</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">NTFS建议使用falloc, EXT3/4建议trunc, MAC 下需要注释此项</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">file-allocation=falloc</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 下载连接相关 ##</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 下载连接相关 ##</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 下载连接相关 ##</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">最大同时下载任务数, 运行时可修改, 默认:5</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">max-concurrent-downloads=5</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">同一服务器连接数, 添加时可指定, 默认:1</span><br>max-connection-per-server=15<br><span class="hljs-meta prompt_"># </span><span class="language-bash">整体下载速度限制, 运行时可修改, 默认:0（不限制）</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">max-overall-download-limit=0</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">单个任务下载速度限制, 默认:0（不限制）</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">max-download-limit=0</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">整体上传速度限制, 运行时可修改, 默认:0（不限制）</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">max-overall-upload-limit=0</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">单个任务上传速度限制, 默认:0（不限制）</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">max-upload-limit=0</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">禁用IPv6, 默认:<span class="hljs-literal">false</span></span><br>disable-ipv6=true<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">最小文件分片大小, 添加时可指定, 取值范围1M -1024M, 默认:20M</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">假定size=10M, 文件为20MiB 则使用两个来源下载; 文件为15MiB 则使用一个来源下载</span><br>min-split-size=10M<br><span class="hljs-meta prompt_"># </span><span class="language-bash">单个任务最大线程数, 添加时可指定, 默认:5</span><br>split=10<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 进度保存相关 ##</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 进度保存相关 ##</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 进度保存相关 ##</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">从会话文件中读取下载任务</span><br>input-file=/etc/aria2/aria2.session<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在Aria2退出时保存错误的、未完成的下载任务到会话文件</span><br>save-session=/etc/aria2/aria2.session<br><span class="hljs-meta prompt_"># </span><span class="language-bash">定时保存会话, 0为退出时才保存, 需1.16.1以上版本, 默认:0</span><br>save-session-interval=60<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># RPC相关设置 ##</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># RPC相关设置 ##</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># RPC相关设置 ##</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">启用RPC, 默认:<span class="hljs-literal">false</span></span><br>enable-rpc=true<br><span class="hljs-meta prompt_"># </span><span class="language-bash">允许所有来源, 默认:<span class="hljs-literal">false</span></span><br>rpc-allow-origin-all=true<br><span class="hljs-meta prompt_"># </span><span class="language-bash">允许外部访问, 默认:<span class="hljs-literal">false</span></span><br>rpc-listen-all=true<br><span class="hljs-meta prompt_"># </span><span class="language-bash">RPC端口, 仅当默认端口被占用时修改</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">rpc-listen-port=6800</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置的RPC授权令牌, v1.18.4新增功能, 取代 --rpc-user 和 --rpc-passwd 选项</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">rpc-secret=&lt;TOKEN&gt;</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># BT/PT下载相关 ##</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># BT/PT下载相关 ##</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># BT/PT下载相关 ##</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">当下载的是一个种子(以.torrent结尾)时, 自动开始BT任务, 默认:<span class="hljs-literal">true</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">follow-torrent=<span class="hljs-literal">true</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">客户端伪装, PT需要</span><br>peer-id-prefix=-TR2770-<br>user-agent=Transmission/2.77<br><span class="hljs-meta prompt_"># </span><span class="language-bash">强制保存会话, 即使任务已经完成, 默认:<span class="hljs-literal">false</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">较新的版本开启后会在任务完成后依然保留.aria2文件</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">force-save=<span class="hljs-literal">false</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">继续之前的BT任务时, 无需再次校验, 默认:<span class="hljs-literal">false</span></span><br>bt-seed-unverified=true<br><span class="hljs-meta prompt_"># </span><span class="language-bash">保存磁力链接元数据为种子文件(.torrent文件), 默认:<span class="hljs-literal">false</span></span><br>bt-save-metadata=true<br></code></pre></td></tr></table></figure><p>然后执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo aria2c --conf-path=/etc/aria2/aria2.conf -D<br></code></pre></td></tr></table></figure><p>没有任何提示则表示成功。接下来添加开机自启：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo touch /etc/init.d/aria2c<br>sudo nano /etc/init.d/aria2c<br></code></pre></td></tr></table></figure><p>添加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br><span class="hljs-comment">### BEGIN INIT INFO</span><br><span class="hljs-comment"># Provides:          aria2</span><br><span class="hljs-comment"># Required-Start:    remotefsnetwork</span><br><span class="hljs-comment"># Required-Stop:     remotefsnetwork</span><br><span class="hljs-comment"># Default-Start:     2 3 4 5</span><br><span class="hljs-comment"># Default-Stop:      0 1 6</span><br><span class="hljs-comment"># Short-Description: Aria2 Downloader</span><br><span class="hljs-comment">### END INIT INFO</span><br> <br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> <span class="hljs-keyword">in</span><br>start)<br>    <span class="hljs-built_in">echo</span> -n <span class="hljs-string">&quot;Starting aria2c&quot;</span><br>    <span class="hljs-built_in">sudo</span> aria2c --conf-path=/etc/aria2/aria2.conf -D<br><br>;;<br>stop)<br>    <span class="hljs-built_in">echo</span> -n <span class="hljs-string">&quot;Shutting down aria2c &quot;</span><br>    killall aria2c<br>;;<br>restart)<br>    <span class="hljs-comment"># killall aria2c</span><br>    <span class="hljs-built_in">sudo</span> aria2c --conf-path=/etc/aria2/aria2.conf -D<br><br>;;<br><span class="hljs-keyword">esac</span><br><span class="hljs-built_in">exit</span><br></code></pre></td></tr></table></figure><p>执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo chmod +x /etc/init.d/aria2c<br></code></pre></td></tr></table></figure><h3 id="安装aria2的web管理界面（AriaNg）"><a href="#安装aria2的web管理界面（AriaNg）" class="headerlink" title="安装aria2的web管理界面（AriaNg）"></a>安装aria2的web管理界面（AriaNg）</h3><p>这里需要用到一个第三方的工具，这个是通过rpc接口来管理aria2下载的工具。</p><p>安装git和nginx</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install -y git nginx<br></code></pre></td></tr></table></figure><p>下载aira-ng</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://github.com/mayswind/AriaNg/releases/download/1.1.4/aria-ng-1.1.4.zip -O aira-ng.zip<br></code></pre></td></tr></table></figure><p>解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">unzip aira-ng.zip -d aira-ng<br></code></pre></td></tr></table></figure><p>将aira-ng放到nginx的&#x2F;var&#x2F;www&#x2F;html&#x2F;目录下，然后设置开机启动nginx</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo mv aira-ng /var/www/html/<br>sudo systemctl enable nginx<br></code></pre></td></tr></table></figure><p>用浏览器访问树莓派IP下的aira-ng，即：<a href="https://links.jianshu.com/go?to=http://ip/aira-ng">http://ip/aira-ng</a></p><p>然后在系统设置点击AriaNg设置 –&gt; 全局 –&gt; 设置语言为中文 –&gt; 点击RPC–&gt;修改为 rpc 密钥：secret</p><h3 id="aria2-自动更新tracker"><a href="#aria2-自动更新tracker" class="headerlink" title="aria2 自动更新tracker"></a>aria2 自动更新tracker</h3><p><a href="https://www.moerats.com/archives/374/">https://www.moerats.com/archives/374/</a></p><h2 id="安装SSH服务端"><a href="#安装SSH服务端" class="headerlink" title="安装SSH服务端"></a>安装SSH服务端</h2><h3 id="WSL-Ubuntu"><a href="#WSL-Ubuntu" class="headerlink" title="WSL Ubuntu"></a>WSL Ubuntu</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">设置root的口令（密码），用作后续登陆使用</span><br>sudo passwd root<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">安装openssh-server（ubuntu自带已安装，但是我使用有问题，没找到原因）</span><br>sudo apt remove openssh-server<br>sudo apt install openssh-client openssh-server<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">备份原始的sshd_config</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">ssh_config是针对客户端的配置文件</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">sshd_config是针对服务端的配置文件</span><br>sudo cp /etc/ssh/sshd_config /etc/ssh/sshd_config.bak<br>sudo cp /etc/ssh/ssh_config /etc/ssh/ssh_config.bak<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">使用vim进行编辑，按i进入insert模式</span><br>sudo vim /etc/ssh/sshd_config<br><br>在vim中找到对应项并修改，ESC，输入`wq`保存退出：<br>Port 2222<br>ListenAddress 0.0.0.0        # 如果需要指定监听的IP则去除最左侧的井号，并配置对应IP，默认即监听PC所有IP<br>PermitRootLogin no           # 如果你需要用 root 直接登录系统则此处改为 yes<br>PasswordAuthentication yes    # 将 no 改为 yes 表示使用帐号密码方式登录<br>TCPKeepAlive yes             # <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">启动ssh，查看status</span><br>sudo service ssh start             #启动SSH服务<br>sudo service ssh status            #检查状态<br>sudo systemctl enable ssh          #开机自动启动ssh命令，WSL下无效<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果出错了可以用下面的命令查看错误信息</span><br>sshd -T<br></code></pre></td></tr></table></figure><h2 id="SSH主动断开连接"><a href="#SSH主动断开连接" class="headerlink" title="SSH主动断开连接"></a>SSH主动断开连接</h2><blockquote><p>  network error: software caused connection abort</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-built_in">sudo</span> vim /etc/ssh/sshd_config</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">找到TCPKeepAlive将其配置为<span class="hljs-built_in">yes</span> 保持TCP的连接</span><br>TCPKeepAlive yes<br><span class="hljs-meta prompt_"># </span><span class="language-bash">将 ‘ClientAliveInterval’ 设定成 60s</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">ClientAliveInterval指定了服务器端向客户端请求消息的时间间隔, 默认是0，不发送。而ClientAliveInterval 60表示每分钟发送一次，然后客户端响应，这样就保持长连接了。</span><br>ClientAliveInterval 60<br><span class="hljs-meta prompt_"># </span><span class="language-bash">ClientAliveCountMax，使用默认值3即可。ClientAliveCountMax表示服务器发出请求后客户端没有响应的次数达到一定值，就自动断开</span><br>ClientAliveCountMax 3<br></code></pre></td></tr></table></figure><h2 id="SSH连接Linux时自动启动某个脚本"><a href="#SSH连接Linux时自动启动某个脚本" class="headerlink" title="SSH连接Linux时自动启动某个脚本"></a>SSH连接Linux时自动启动某个脚本</h2><p>etc目录下有一个profile文件，在文件末尾加上脚本命令，或者脚本目录地址。(切换root用户)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> vim /etc/profile<br></code></pre></td></tr></table></figure><p>在 <code>/etc/ssh/</code> 目录下面创建一个 <code>sshrc</code> 的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br></code></pre></td></tr></table></figure><h2 id="配置-SSH-密钥登录-免密码"><a href="#配置-SSH-密钥登录-免密码" class="headerlink" title="配置 SSH 密钥登录(免密码)"></a>配置 SSH 密钥登录(免密码)</h2><blockquote><p>  <strong>一、第一次登录远程主机流程</strong></p><p>  第一次ssh到远程主机时远程主机会发送它的公钥到客户端主机，客户机确认继续连接后会把远程主机的公钥保存到.ssh&#x2F;known_hosts文件，下次再连接此远程主机时会去.ssh&#x2F;known_hosts查看，如果是已经保存的公钥证明是信任主机，即不会告警并直接提示输入用户名密码登录。</p><ul><li>如果中途SSH提示你对方的密钥指纹发生了变化那这个时候你就要担心了, 可能存在MITM(Man-In-The-Middle-Attack 中间人攻击)<ul><li>远程主机的这些操作会导致密钥指纹发生变化</li><li>重新安装了操作系统</li><li>重新安装了openssh或者手动更新了&#x2F;etc&#x2F;ssh下的密钥对</li></ul></li></ul><blockquote><p>   虽然有著名的DH密钥交换算法，但SSH<strong>原理上</strong>不能抵御中间人攻击。然而实际上，SSH使用<a href="https://en.wikipedia.org/wiki/Trust_on_first_use">TOFU</a>安全模型等同于做到了防中间人攻击。SSH的首次连接会下载服务端的公钥，用户确认后公钥将被保存并信任。下次访问时客户端将会核对服务端发来的公钥和本地保存的是否相同，不同就发出中间人攻击的警告拒绝连接，除非用户手动清除已保存的公钥。所以，<strong>如果首次连接没有中间人，之后的连接就无需担心中间人</strong>，因为中间人给出的公钥和服务端给出的公钥相同的可能性可以忽略。如果首次连接就有中间人攻击，那么恭喜你中奖了。</p></blockquote><p>  <strong>二、密码登录流程</strong></p><p>  远程主机收到客户端请求后会把自己的公钥发送给客户端，客户端通过公钥加密之后将密码发送给远程主机，远程主机用密钥解密，密码如果正确则登录成功。</p><p>  <strong>三、公钥登录（免密登录）流程</strong></p><p>  公钥登录原理就是客户端将自己的公钥存储到远程主机的.ssh&#x2F;authorized_keys中，客户端发起登录时，远程主机会发送一段随机字符串给客户端，客户端用自己的私钥加密后重新发回远程主机，远程主机用存储的客户端公钥解密之后对比之前发送给客户端的字符串，相同的话即认为客户机认证，不在需要输入密码直接登录系统。</p></blockquote><ol><li><p>client机器生成密钥</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen<br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者</span><br>ssh-keygen -t rsa<br><span class="hljs-meta prompt_"># </span><span class="language-bash">注意 RSA 现阶段不再建议使用了, 改成ed25519生成</span><br>ssh-keygen -t ed25519 -C &quot;your_email@example.com&quot;<br></code></pre></td></tr></table></figure><p> <a href="https://confluence.atlassian.com/bitbucketserverkb/ssh-rsa-key-rejected-with-message-no-mutual-signature-algorithm-1026057701.html">RSA 现阶段不再建议使用了</a></p></li><li><p>client查看<code>~/.ssh/id_rsa.pub</code>文件内容, 并复制</p></li><li><p>server编辑SSH的配置<code>vim /etc/ssh/sshd_config</code></p><ol><li>将<code>PubkeyAuthentication</code> 配置成<code>yes</code>, 允许密钥登录</li><li>重启ssh服务 <code>systemctl restart sshd</code></li></ol></li><li><p>server生成密钥</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ssh-keygen</span><br></code></pre></td></tr></table></figure></li><li><p>server创建<code>~/.ssh/authorized_keys</code>文件, 并将client的公钥(<code>~/.ssh/id_rsa.pub</code>)内容粘贴进去</p><ul><li>需要注意的是<code>.ssh文件夹的权限应当为700，authorized_keys文件的权限应该为600</code></li><li>可以直接使用命令<code>cat .ssh/id_rsa.pub | ssh user_name@xxx.xxx.xxx.xx &#39;cat &gt;&gt; .ssh/authorized_keys&#39;</code></li></ul></li><li><p>client使用指定私钥登录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh -i /root/.ssh/id_rsa user@ip_or_domain<br></code></pre></td></tr></table></figure></li><li><p>测试登录OK后建议关闭密码登录(不安全), 同时Root用户也建议禁止登录</p><p><code>PasswordAuthentication no</code>, <code>PermitRootLogin no</code></p></li></ol><h2 id="SSH-config"><a href="#SSH-config" class="headerlink" title="SSH config"></a>SSH config</h2><p>SSH 的配置文件有两个：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">~/.ssh/config            <span class="hljs-comment"># 用户配置文件</span><br>/etc/ssh/ssh_config      <span class="hljs-comment"># 系统配置文件</span><br></code></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment"># comment! </span><br>Host pq.github.com<br>  HostName github.com           <span class="hljs-comment"># 目标服务器地址</span><br>  <span class="hljs-keyword">User</span> <span class="hljs-title">git</span>                      <span class="hljs-comment"># 用户名</span><br>  Port <span class="hljs-number">22</span>                       <span class="hljs-comment"># 端口</span><br>  IdentityFile ~/.ssh/id_rsa    <span class="hljs-comment"># 密钥-&gt;私钥</span><br></code></pre></td></tr></table></figure><blockquote><h3 id="配置项说明"><a href="#配置项说明" class="headerlink" title="配置项说明"></a>配置项说明</h3><p>  SSH 的配置文件有两个：</p>  <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$ </span>~<span class="hljs-regexp">/.ssh/config</span>            <span class="hljs-comment"># 用户配置文件</span><br><span class="hljs-variable">$ </span>/etc/ssh/ssh_config      <span class="hljs-comment"># 系统配置文件</span><br></code></pre></td></tr></table></figure><p>  下面来看看常用的配置参数。</p><p>  <strong>Host</strong><br>  用于我们执行 SSH 命令的时候如何匹配到该配置。</p><ul><li><code>*</code>，匹配所有主机名。</li><li><code>*.example.com</code>，匹配以 .example.com 结尾。</li><li><code>!*.dialup.example.com,*.example.com</code>，以 ! 开头是排除的意思。</li><li><code>192.168.0.?</code>，匹配 192.168.0.[0-9] 的 IP。</li></ul><p>  <strong>AddKeysToAgent</strong><br>  是否自动将 key 加入到 <code>ssh-agent</code>，值可以为 no(default)&#x2F;confirm&#x2F;ask&#x2F;yes。</p><p>  如果是 yes，key 和密码都将读取文件并以加入到 agent ，就像 <code>ssh-add</code>。其他分别是询问、确认、不加入的意思。添加到 ssh-agent 意味着将私钥和密码交给它管理，让它来进行身份认证。</p><p>  <strong>AddressFamily</strong><br>  指定连接的时候使用的地址族，值可以为 any(default)&#x2F;inet(IPv4)&#x2F;inet6(IPv6)。</p><p>  <strong>BindAddress</strong><br>  指定连接的时候使用的本地主机地址，只在系统有多个地址的时候有用。在 UsePrivilegedPort 值为 yes 的时候无效。</p><p>  <strong>ChallengeResponseAuthentication</strong><br>  是否响应支持的身份验证 chanllenge，yes(default)&#x2F;no。</p><p>  <strong>Compression</strong><br>  是否压缩，值可以为 no(default)&#x2F;yes。</p><p>  <strong>CompressionLevel</strong><br>  压缩等级，值可以为 1(fast)-9(slow)。6(default)，相当于 gzip。</p><p>  <strong>ConnectionAttempts</strong><br>  退出前尝试连接的次数，值必须为整数，1(default)。</p><p>  <strong>ConnectTimeout</strong><br>  连接 SSH 服务器超时时间，单位 s，默认系统 TCP 超时时间。</p><p>  <strong>ControlMaster</strong><br>  是否开启单一网络共享多个 session，值可以为 no(default)&#x2F;yes&#x2F;ask&#x2F;auto。需要和 ControlPath 配合使用，当值为 yes 时，ssh 会监听该路径下的 control socket，多个 session 会去连接该 socket，它们会尽可能的复用该网络连接而不是重新建立新的。</p><p>  <strong>ControlPath</strong><br>  指定 control socket 的路径，值可以直接指定也可以用一下参数代替：</p><ul><li>%L 本地主机名的第一个组件</li><li>%l 本地主机名（包括域名）</li><li>%h 远程主机名（命令行输入）</li><li>%n 远程原始主机名</li><li>%p 远程主机端口</li><li>%r 远程登录用户名</li><li>%u 本地 ssh 正在使用的用户名</li><li>%i 本地 ssh 正在使用 uid</li><li>%C 值为 %l%h%p%r 的 hash</li></ul><p>  请最大限度的保持 ControlPath 的唯一。至少包含 %h，%p，%r（或者 %C）。</p><p>  <strong>ControlPersist</strong><br>  结合 ControlMaster 使用，指定连接打开后后台保持的时间。值可以为 no&#x2F;yes&#x2F;整数，单位 s。如果为 no，最初的客户端关闭就关闭。如果 yes&#x2F;0，无限期的，直到杀死或通过其它机制，如：ssh -O exit。</p><p>  <strong>GatewayPorts</strong><br>  指定是否允许远程主机连接到本地转发端口，值可以为 no(default)&#x2F;yes。默认情况，ssh 为本地回环地址绑定了端口转发器。</p><p>  <strong>HostName</strong><br>  真实的主机名，默认值为命令行输入的值（允许 IP）。你也可以使用 %h，它将自动替换，只要替换后的地址是完整的就 ok。</p><p>  <strong>IdentitiesOnly</strong><br>  指定 ssh 只能使用配置文件指定的 identity 和 certificate 文件或通过 ssh 命令行通过身份验证，即使 ssh-agent 或 PKCS11Provider 提供了多个 identities。值可以为 no(default)&#x2F;yes。</p><p>  <strong>IdentityFile</strong><br>  指定读取的认证文件路径，允许 DSA，ECDSA，Ed25519 或 RSA。值可以直接指定也可以用一下参数代替：</p><ul><li>%d，本地用户目录 ~</li><li>%u，本地用户</li><li>%l，本地主机名</li><li>%h，远程主机名</li><li>%r，远程用户名</li></ul><p>  <strong>LocalCommand</strong><br>  指定在连接成功后，本地主机执行的命令（单纯的本地命令）。可使用 %d，%h，%l，%n，%p，%r，%u，%C 替换部分参数。只在 PermitLocalCommand 开启的情况下有效。</p><p>  <strong>LocalForward</strong><br>  指定本地主机的端口通过 ssh 转发到指定远程主机。格式：LocalForward [bind_address:]post host:hostport，支持 IPv6。</p><p>  <strong>PasswordAuthentication</strong><br>  是否使用密码进行身份验证，yes(default)&#x2F;no。</p><p>  <strong>PermitLocalCommand</strong><br>  是否允许指定 LocalCommand，值可以为 no(default)&#x2F;yes。</p><p>  <strong>Port</strong><br>  指定连接远程主机的哪个端口，22(default)。</p><p>  <strong>ProxyCommand</strong><br>  指定连接的服务器需要执行的命令。%h，%p，%r</p><p>  如：ProxyCommand &#x2F;usr&#x2F;bin&#x2F;nc -X connect -x 192.0.2.0:8080 %h %p</p><p>  <strong>User</strong><br>  登录用户名</p></blockquote><h2 id="查看ssh登录失败记录"><a href="#查看ssh登录失败记录" class="headerlink" title="查看ssh登录失败记录"></a>查看ssh登录失败记录</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看并筛选 失败次数大于3次的 ip</span><br>sudo lastb |awk &#x27;&#123;print $3&#125;&#x27;|sort |uniq -c|awk &#x27;&#123;if ($1 &gt; 3) print $2&#125;&#x27;<br>sudo lastb |awk &#x27;&#123;print $3&#125;&#x27;|sort |uniq -c|sort -bn|awk &#x27;&#123;if ($1 &gt; 3) print&#125;&#x27;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">写一个脚本 统计一下ip 将这些ip禁止</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-------------------------------</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>list=$( sudo lastb |awk &#x27;&#123;print $3&#125;&#x27;|sort |uniq -c|awk &#x27;&#123;if ($1 &gt; 3) print $2&#125;&#x27; )<br>for ip in $&#123;list&#125;<br>do<br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;ip&#125;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">下面这个是加入黑名单</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">echo</span> ALL: <span class="hljs-variable">$&#123;ip&#125;</span> &gt;&gt; /etc/hosts.deny <span class="hljs-comment">#加入黑名单</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这个是加入防火墙的禁止规则</span><br>ufw deny from $&#123;ip&#125;<br>done<br>echo &gt; /var/log/btmp    #清空失败记录，防止脚本下次执行重复统计IP<br><span class="hljs-meta prompt_"># </span><span class="language-bash">-------------------------------</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">定时执行 ssh密码错误没找到回调函数, 这里要是有回调函数处理起来就很及时了</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">crontab -e</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">内容为每天12:12执行一次脚本</span><br>12 12 * * * /bin/bash /home/xx/xx.sh<br></code></pre></td></tr></table></figure><h2 id="hosts文件"><a href="#hosts文件" class="headerlink" title="hosts文件"></a>hosts文件</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/ets/</span>hosts<br></code></pre></td></tr></table></figure><h2 id="服务器测试工具"><a href="#服务器测试工具" class="headerlink" title="服务器测试工具"></a>服务器测试工具</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget -qO- --no-check-certificate https://raw.githubusercontent.com/oooldking/script/master/superbench.sh | bash<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -Lso- -no-check-certificate https://raw.githubusercontent.com/oooldking/script/master/superbench.sh | bash<br></code></pre></td></tr></table></figure><h2 id="搭建简易文件服务器http-server-wget下载"><a href="#搭建简易文件服务器http-server-wget下载" class="headerlink" title="搭建简易文件服务器http server wget下载"></a>搭建简易文件服务器http server wget下载</h2><p>两台服务器之间传递文件，可以使用http server，参考文章：<a href="https://www.jianshu.com/p/f61151abb7a5">python开启http服务传输文件</a>.<br>在需要提供服务的主机中运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Python &lt;= 2.3</span><br>python -c <span class="hljs-string">&quot;import SimpleHTTPServer as s; s.test();&quot;</span> 8000<br><br><span class="hljs-comment"># Python &gt;= 2.4</span><br>python -m SimpleHTTPServer 8000<br><br><span class="hljs-comment"># Python 3.x</span><br>python -m http.server 8000<br></code></pre></td></tr></table></figure><blockquote><p>  如果目录有一个名为index.html的文件，该文件将作为初始文件。如果没有index.html，则将列出目录中的文件。</p></blockquote><p>访问：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget ip:8080/filename<br></code></pre></td></tr></table></figure><h2 id="查看支持的shell"><a href="#查看支持的shell" class="headerlink" title="查看支持的shell"></a>查看支持的shell</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/shells<br></code></pre></td></tr></table></figure><h2 id="uninx-资源管理器"><a href="#uninx-资源管理器" class="headerlink" title="uninx 资源管理器"></a>uninx 资源管理器</h2><h3 id="Glances"><a href="#Glances" class="headerlink" title="Glances"></a>Glances</h3><p>适合运维、云端开发人员或命令行爱好者</p><p><img src="/2020/d4436089/webp.webp" alt="img"></p><p>安装：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$ </span>sudo pip3 install glances<br></code></pre></td></tr></table></figure><p>启动：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$ </span>sudo glances<br></code></pre></td></tr></table></figure><h3 id="Sysmontask"><a href="#Sysmontask" class="headerlink" title="Sysmontask"></a>Sysmontask</h3><p>适合桌面端用户，界面仿照 <code>Win10</code> 资源管理器，提供更多信息更直观</p><p><img src="/2020/d4436089/webp-16552860429952.webp" alt="img"></p><p>安装：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$ </span>sudo pip3 install sysmontask<br></code></pre></td></tr></table></figure><p>启动:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$ </span>sudo sysmontask<br></code></pre></td></tr></table></figure><h3 id="bpytop"><a href="#bpytop" class="headerlink" title="bpytop"></a>bpytop</h3><p>github: <a href="https://github.com/aristocratos/bpytop">https://github.com/aristocratos/bpytop</a></p><p><img src="/2020/d4436089/main-16552870928465.png" alt="main"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装</span><br>git <span class="hljs-built_in">clone</span> https://github.com/aristocratos/bpytop.git<br><span class="hljs-built_in">cd</span> bpytop<br><span class="hljs-built_in">sudo</span> make install<br></code></pre></td></tr></table></figure><h2 id="清理RAM-Cache"><a href="#清理RAM-Cache" class="headerlink" title="清理RAM Cache"></a>清理RAM Cache</h2><hr><p><em><strong>Sync</strong></em></p><blockquote><p>  操作系统在运行过程中,会把访问到的文件放到buffer中。为了避免断电,等故障造成数据丢失,我们需要把buffer中的缓存数据写入到磁盘</p></blockquote><hr><p><em><strong>手动释放内存的命令</strong></em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> 3 &gt; /proc/sys/vm/drop_caches<br></code></pre></td></tr></table></figure><blockquote><p>  drop_caches的值可以是0-3之间的数字，代表不同的含义：</p></blockquote><ul><li>0：不释放（系统默认值）</li><li>1：释放页缓存</li><li>2：释放dentries和inodes</li></ul><hr><h2 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h2><p>编辑文件&#x2F;etc&#x2F;profile，增加如下两行, 临时使用直接export即可</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">http_proxy</span>=http://proxy.com:8080/<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">https_proxy</span>=http://proxy.com:8080/<br></code></pre></td></tr></table></figure><p>然后更新一下环境文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> /etc/profile<br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">环境变量</th><th align="left">描述</th><th align="left">值示例</th></tr></thead><tbody><tr><td align="left">http_proxy</td><td align="left">为http变量设置代理；默认不填开头以http协议传输</td><td align="left">10.0.0.51:8080 user:<a href="mailto:&#112;&#97;&#x73;&#115;&#64;&#x31;&#x30;&#46;&#x30;&#46;&#48;&#x2e;&#49;&#48;">&#112;&#97;&#x73;&#115;&#64;&#x31;&#x30;&#46;&#x30;&#46;&#48;&#x2e;&#49;&#48;</a>:8080 socks4:&#x2F;&#x2F;10.0.0.51:1080 socks5:&#x2F;&#x2F;192.168.1.1:1080</td></tr><tr><td align="left">https_proxy</td><td align="left">为https变量设置代理；</td><td align="left">同上</td></tr><tr><td align="left">ftp_proxy</td><td align="left">为ftp变量设置代理；</td><td align="left">同上</td></tr><tr><td align="left">all_proxy</td><td align="left">全部变量设置代理，设置了这个时候上面的不用设置</td><td align="left">同上</td></tr><tr><td align="left">no_proxy</td><td align="left">无需代理的主机或域名； 可以使用通配符； 多个时使用“,”号分隔；</td><td align="left"><em>.aiezu.com,10.</em>.<em>.</em>,192.168.<em>.</em>, *.local,localhost,127.0.0.1</td></tr></tbody></table><h3 id="脚本为WSL设置代理"><a href="#脚本为WSL设置代理" class="headerlink" title="脚本为WSL设置代理"></a>脚本为WSL设置代理</h3><p><strong>WSL 中获取宿主机 IP</strong></p><p>WSL 每次启动的时候都会有不同的 IP 地址，所以并不能直接用静态的方式来设置代理。WSL2 会把 IP 写在 <code>/etc/resolv.conf</code>中，因此可以用 <code>cat /etc/resolv.conf | grep nameserver | awk &#39;&#123; print $2 &#125;&#39;</code> 这条指令获得宿主机 IP 。</p><p><strong>设置代理</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br>hostip=$(<span class="hljs-built_in">cat</span> /etc/resolv.conf | grep nameserver | awk <span class="hljs-string">&#x27;&#123; print $2 &#125;&#x27;</span>)<br>wslip=$(hostname -I | awk <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span>)<br>http_port=&lt;PORT&gt;<br>socks5_port=&lt;PORT&gt;<br><br>PROXY_HTTP=<span class="hljs-string">&quot;http://<span class="hljs-variable">$&#123;hostip&#125;</span>:<span class="hljs-variable">$&#123;http_port&#125;</span>&quot;</span><br>PROXY_SOCKS5=<span class="hljs-string">&quot;socks5://<span class="hljs-variable">$&#123;hostip&#125;</span>:<span class="hljs-variable">$&#123;socks5_port&#125;</span>&quot;</span><br><br><span class="hljs-function"><span class="hljs-title">set_proxy</span></span>()&#123;<br>    <span class="hljs-built_in">export</span> http_proxy=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;PROXY_HTTP&#125;</span>&quot;</span><br>    <span class="hljs-built_in">export</span> HTTP_PROXY=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;PROXY_HTTP&#125;</span>&quot;</span><br><br>    <span class="hljs-built_in">export</span> https_proxy=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;PROXY_HTTP&#125;</span>&quot;</span><br>    <span class="hljs-built_in">export</span> HTTPS_PROXY=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;PROXY_HTTP&#125;</span>&quot;</span><br><br>    <span class="hljs-built_in">export</span> all_proxy=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;PROXY_SOCKS5&#125;</span>&quot;</span><br>    <span class="hljs-built_in">export</span> ALL_PROXY=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;PROXY_SOCKS5&#125;</span>&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">unset_proxy</span></span>()&#123;<br>    <span class="hljs-built_in">unset</span> http_proxy<br>    <span class="hljs-built_in">unset</span> HTTP_PROXY<br>    <span class="hljs-built_in">unset</span> https_proxy<br>    <span class="hljs-built_in">unset</span> HTTPS_PROXY<br>    <span class="hljs-built_in">unset</span> all_proxy<br>    <span class="hljs-built_in">unset</span> ALL_PROXY<br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">test_setting</span></span>()&#123;<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Host ip:&quot;</span> <span class="hljs-variable">$&#123;hostip&#125;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;WSL ip:&quot;</span> <span class="hljs-variable">$&#123;wslip&#125;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Current https_proxy:&quot;</span> <span class="hljs-variable">$https_proxy</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Current all_proxy:&quot;</span> <span class="hljs-variable">$all_proxy</span><br>&#125;<br><br><span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> = <span class="hljs-string">&quot;set&quot;</span> ]<br><span class="hljs-keyword">then</span><br>    set_proxy<br><br><span class="hljs-keyword">elif</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> = <span class="hljs-string">&quot;unset&quot;</span> ]<br><span class="hljs-keyword">then</span><br>    unset_proxy<br><br><span class="hljs-keyword">elif</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> = <span class="hljs-string">&quot;test&quot;</span> ]<br><span class="hljs-keyword">then</span><br>    test_setting<br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Unsupported arguments.&quot;</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><p><strong>!!注意!!</strong></p><p>之后运行 <code>. ./proxy.sh set</code> 就可以自动设置代理了。<code>unset</code> 可以取消代理，test 可以查看代理状态，能够用来检查环境变量是否被正确修改。</p><p>运行的时候不要忘记之前的 <code>.</code>，或者使用 <code>source ./proxy.sh set</code>，只有这样才能够修改环境变量</p><p>直接运行例如 <code>./proxy.sh set</code> 或者 <code>sh proxy.sh set</code>，这样会是运行在一个子 shell 中，对当前 shell 没有效果</p><p>另外可以在 <code>~/.bashrc</code> 中选择性的加上下面两句话，记得将里面的路径修改成你放这个脚本的路径。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">alias proxy=&quot;source /path/to/proxy.sh&quot;<br>. /path/to/proxy.sh set<br></code></pre></td></tr></table></figure><p>第一句话可以为这个脚本设置别名 proxy，这样在任何路径下都可以通过 proxy 命令使用这个脚本了，之后在任何路径下，都可以随时都可以通过输入<code>proxy unset</code> 来暂时取消代理。</p><p>第二句话就是在每次 shell 启动的时候运行该脚本实现自动设置代理，这样以后不用额外操作就默认设置好代理啦~</p><h2 id="获取IP归属地"><a href="#获取IP归属地" class="headerlink" title="获取IP归属地"></a>获取IP归属地</h2><blockquote><p>  <a href="http://ip-[api](https://so.csdn.net/so/search?q=api&spm=1001.2101.3001.7020).com/json/">http://ip-[api](https://so.csdn.net/so/search?q=api&amp;spm=1001.2101.3001.7020).com/json/</a>         # 国际化英文显示</p><p>  <a href="http://ip-api.com/json/?lang=zh-CN">http://ip-api.com/json/?lang=zh-CN</a>　　# 中文显示</p><p>  <a href="http://ip-api.com/json/8.8.8.8?lang=zh-CN">http://ip-api.com/json/8.8.8.8?lang=zh-CN</a>    #查询某个ip的信息</p></blockquote><h2 id="使用-curl-测试网站加载速度"><a href="#使用-curl-测试网站加载速度" class="headerlink" title="使用 curl 测试网站加载速度"></a>使用 curl 测试网站加载速度</h2><p> <a href="###curl">参考Curl章节-w参数</a></p><h2 id="rsync-同步工具"><a href="#rsync-同步工具" class="headerlink" title="rsync 同步工具"></a>rsync 同步工具</h2><p><a href="https://wiki.archlinux.org/title/Rsync#Full_system_backup">Full system backup</a></p><p><a href="https://www.ruanyifeng.com/blog/2020/08/rsync.html">rsync 用法教程_阮一峰</a></p><p>备份远程主机 <code>192.168.1.1</code> 的 <code>/</code>目录, 到本地<code>./xx_backup/</code> , 并排除一些文件, 生成日志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">rsync -a -e &quot;ssh -p 22&quot; --exclude=&#123;&quot;/dev/*&quot;,&quot;/proc/*&quot;,&quot;/sys/*&quot;,&quot;/tmp/*&quot;,&quot;/run/*&quot;,&quot;/mnt/*&quot;,&quot;/media/*&quot;,&quot;/lost+found&quot;&#125; user@192.168.1.1:/ ./xx_backup | tee ./xx_backup.log<br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">&quot;ssh -p 22&quot;</span>         22 = port = 端口号</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">user@192.168.1.1  user = user = 用户名</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">192.168.1.1       = ip</span><br></code></pre></td></tr></table></figure><h3 id="r-参数"><a href="#r-参数" class="headerlink" title="-r 参数"></a><code>-r</code> 参数</h3><p>本机使用 rsync 命令时，可以作为<code>cp</code>和<code>mv</code>命令的替代方法，将源目录同步到目标目录。</p><blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ rsync -r <span class="hljs-built_in">source</span> destination<br></code></pre></td></tr></table></figure></blockquote><p>上面命令中，<code>-r</code>表示递归，即包含子目录。注意，<code>-r</code>是必须的，否则 rsync 运行不会成功。<code>source</code>目录表示源目录，<code>destination</code>表示目标目录。</p><p>如果有多个文件或目录需要同步，可以写成下面这样。</p><blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ rsync -r source1 source2 destination<br></code></pre></td></tr></table></figure></blockquote><p>上面命令中，<code>source1</code>、<code>source2</code>都会被同步到<code>destination</code>目录。</p><h3 id="a-参数"><a href="#a-参数" class="headerlink" title="-a 参数"></a><code>-a</code> 参数</h3><p><code>-a</code>参数可以替代<code>-r</code>，除了可以递归同步以外，还可以同步元信息（比如修改时间、权限等）。由于 rsync 默认使用文件大小和修改时间决定文件是否需要更新，所以<code>-a</code>比<code>-r</code>更有用。下面的用法才是常见的写法。</p><blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ rsync -a <span class="hljs-built_in">source</span> destination<br></code></pre></td></tr></table></figure></blockquote><p>目标目录<code>destination</code>如果不存在，rsync 会自动创建。执行上面的命令后，源目录<code>source</code>被完整地复制到了目标目录<code>destination</code>下面，即形成了<code>destination/source</code>的目录结构。</p><p>如果只想同步源目录<code>source</code>里面的内容到目标目录<code>destination</code>，则需要在源目录后面加上斜杠。</p><blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ rsync -a <span class="hljs-built_in">source</span>/ destination<br></code></pre></td></tr></table></figure></blockquote><p>上面命令执行后，<code>source</code>目录里面的内容，就都被复制到了<code>destination</code>目录里面，并不会在<code>destination</code>下面创建一个<code>source</code>子目录。</p><h3 id="n-参数"><a href="#n-参数" class="headerlink" title="-n 参数"></a><code>-n</code> 参数</h3><p>对比两个目录下文件，想知道目标目录下哪些文件被修改或增加删除了，rsync提供了一个只校验文件但不实际同步目录内容的参数 <code>--dry-run</code>或<code>-n</code>.</p><p>如果不确定 rsync 执行后会产生什么结果，可以先用<code>-n</code>或<code>--dry-run</code>参数模拟执行的结果。</p><blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ rsync -anv <span class="hljs-built_in">source</span>/ destination<br></code></pre></td></tr></table></figure></blockquote><p>上面命令中，<code>-n</code>参数模拟命令执行的结果，并不真的执行命令。<code>-v</code>参数则是将结果输出到终端，这样就可以看到哪些内容会被同步。</p><h3 id="delete-参数"><a href="#delete-参数" class="headerlink" title="--delete 参数"></a><code>--delete</code> 参数</h3><p>默认情况下，rsync 只确保源目录的所有内容（明确排除的文件除外）都复制到目标目录。它不会使两个目录保持相同，并且不会删除文件。如果要使得目标目录成为源目录的镜像副本，则必须使用<code>--delete</code>参数，这将删除只存在于目标目录、不存在于源目录的文件。</p><blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ rsync -av --delete <span class="hljs-built_in">source</span>/ destination<br></code></pre></td></tr></table></figure></blockquote><p>上面命令中，<code>--delete</code>参数会使得<code>destination</code>成为<code>source</code>的一个镜像。</p><h2 id="ufw-ubuntu防火墙"><a href="#ufw-ubuntu防火墙" class="headerlink" title="ufw ubuntu防火墙"></a>ufw ubuntu防火墙</h2><p>UFW 只是 iptables 的前端，因此这些日志条目实际上来自 iptables。</p><p>第 1 行：<code>Feb  6 16:27:08 jonasgroenbek kernel: [71910.873115]</code></p><p>日期和时间、您的计算机名称和自引导以来的内核时间。</p><p>第 2 行：<code>[UFW BLOCK] IN=eth0 OUT=</code></p><p>每当 iptables 执行日志条目时，都会有一个可选的<code>--log-prefix</code>，在这种情况下<code>[UFW BLOCK]</code>。UFW 最烦人的一点是，它对每种类型的日志条目都使用相同的前缀，因此很难关联回 iptables 规则集。<code>IN</code>是数据包到达的网络接口名称。是空白的<code>OUT</code>，因为数据包没有被重新传输，如果这是一个路由器应用程序可能就是这种情况。</p><p>第 3 行：<code>MAC=a6:8d:e2:51:62:4c:f0:4b:3a:4f:80:30:08:00</code></p><p>这些是本地目标 (a6:8d:e2:51:62:4c (eth0)) 和源 (f0:4b:3a:4f:80:30) 网络接口卡的机器地址代码。在您的情况下，源可能是您的 ISP 网关 NIC 的 MAC。每个 6 个字节。末尾额外的 2 个字节（08:00）是帧类型，在这种情况下，它表示“以太网帧携带 IPv4 数据报”。</p><p>第 4 行：<code>SRC=77.72.85.26 DST=157.230.26.180</code></p><p>这些是数据包来自哪里的IP地址，SRC，它应该去哪里，DST，应该是你的IP地址。</p><p>第 5 行：<code>LEN=40 TOS=0x00 PREC=0x00 TTL=251 ID=62215 PROTO=TCP</code></p><p>原始数据包的有效载荷部分的长度；服务类型、存在时间、生存时间（在数据包因跳数过多而死亡之前还剩下多少跳）；鉴别; 协议（在本例中为 TCP）。</p><p>第 6 行：<code>SPT=42772 DPT=3194 WINDOW=1024</code></p><p>源端口；探测端口；TCP 窗口大小</p><p>第 7 行：<code>RES=0x00 SYN URGP=0</code></p><p>TCP 标志，这里重要的是“SYN”，意思是它试图建立一个新的连接。此日志条目表示尝试已被阻止。</p><h2 id="linux-和-的区别"><a href="#linux-和-的区别" class="headerlink" title="linux &gt;和&gt;&gt;的区别,&lt;号使用"></a>linux &gt;和&gt;&gt;的区别,&lt;号使用</h2><p><code>&gt;</code>：将一条命令执行结果（标准输出，或者错误输出，本来都要打印到屏幕上面的）重定向其它输出设备（文件，打开文件操作符，或打印机等等）</p><ul><li><p><code>&gt;&gt;</code>：追加内容（原有内容保留）</p></li><li><p><code>&gt;</code>：覆盖内容</p></li></ul><p><code>&lt;</code>：命令默认从键盘获得的输入，改成从文件，或者其它打开文件以及设备输入</p><h2 id="访问samba"><a href="#访问samba" class="headerlink" title="访问samba"></a>访问samba</h2><blockquote><p>  Linux用户可以从命令行访问samba共享，使用文件管理器或挂载samba共享。</p><p>  <code>smbclient</code>是一个允许您从命令行访问Samba共享资源的工具。大绝大部分的Linux发行版中，<code>smbclient</code>软件包并不是预先安装的，所以需要在您的发行版软件包管理器中安装它。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install smbclient<br></code></pre></td></tr></table></figure><p>访问Samba共享资源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">smbclient //samba_hostname_or_server_ip/share_name -U username<br></code></pre></td></tr></table></figure><p>看到这个提示符就表示成功登录了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">Try &quot;help&quot; to get a list of possible commands.<br>smb: \&gt;<br></code></pre></td></tr></table></figure><p>还有一种用的比较多的方法就是直接将<strong>Samba文件夹挂载到系统文件夹</strong>下.</p><h3 id="挂载-1"><a href="#挂载-1" class="headerlink" title="挂载"></a>挂载</h3><p>我们需要先安装包<code>cifs-utils</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install cifs-utils<br></code></pre></td></tr></table></figure><p>创建挂载点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">mkdir</span> /mnt/smbmount<br></code></pre></td></tr></table></figure><p>挂载远程共享目录到本地目录&#x2F;mnt&#x2F;smbmount</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> mount -t cifs -o username=my_username //samba_hostname_or_server_ip/sharePath /mnt/smbmount<br></code></pre></td></tr></table></figure><p>把远程服务器192.168.20.245上的共享目录<code>share</code>，用户名为<code>frank</code>，挂载到本地目录<code>/mnt/smbmount</code>上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> mount -t cifs -o username=frank //192.168.20.245/share /mnt/smbmount<br></code></pre></td></tr></table></figure><p>系统将提示需要输入密码验证：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">Password <span class="hljs-keyword">for</span> <span class="hljs-symbol">frank@</span><span class="hljs-comment">//192.168.20.245/share:  ********</span><br></code></pre></td></tr></table></figure><p>查看挂载情况 可以看到已经成功挂载了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">df -h<br></code></pre></td></tr></table></figure><blockquote><p>  Note:如果提示文件系统错误, 或者远程文件只读错误可以看看是不是没安装<code>cifs-utils</code></p></blockquote><h3 id="开机挂载"><a href="#开机挂载" class="headerlink" title="开机挂载"></a>开机挂载</h3><p>先卸载刚刚挂载的目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">umount /mnt/smbmount<br></code></pre></td></tr></table></figure><p>我们要实现开机自动挂载，需要修改配置文件<code>/etc/fstab</code>，假设服务器IP地址为192.168.20.245，共享目录名为share，本地目录为<code>/mnt/smbmount</code>，用户名为<code>frank</code>，密码为123，在配置文件的最后一行添加以下内容：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">20.245</span><span class="hljs-regexp">/share /m</span>nt/smbmount  cifs  username=frank,password=<span class="hljs-number">123</span>,soft,rw  <span class="hljs-number">0</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>测试挂载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mount -a<br></code></pre></td></tr></table></figure><p>验证：看看挂载情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">df</span> -h<br></code></pre></td></tr></table></figure><p>接下来查看文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ll /mnt/smbmount<br></code></pre></td></tr></table></figure><h2 id="查看文件占用"><a href="#查看文件占用" class="headerlink" title="查看文件占用"></a>查看文件占用</h2><p>ADD ME</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install ncdu<br><br>ncdu<br><span class="hljs-meta prompt_"># </span><span class="language-bash">排除/mnt</span><br>ncdu --exclude /mnt <br><br><br><br>du -h -d 1<br></code></pre></td></tr></table></figure><h2 id="修改语言"><a href="#修改语言" class="headerlink" title="修改语言"></a>修改语言</h2><h3 id="CentOS-更改系统语言"><a href="#CentOS-更改系统语言" class="headerlink" title="CentOS 更改系统语言"></a>CentOS 更改系统语言</h3><p>使用 <code>localectl list-locales</code> 查看已有语言环境。例如切换简中只需运行下面命令，重启系统生效。</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">localectl</span> <span class="hljs-built_in">set-locale</span> <span class="hljs-string">LANG</span>=<span class="hljs-string">zh_CN</span>.<span class="hljs-string">UTF-8</span><br></code></pre></td></tr></table></figure><p>也可以手动修改语言配置文件 <code>/etc/locale.conf</code> 设置，效果是一样的。</p><p>某些场景可能只要临时切换语言，仅对当前登录会话生效，这时可用 <code>LANG=zh_CN.UTF-8</code> 命令设置。</p><h3 id="Ubuntu-更改系统语言"><a href="#Ubuntu-更改系统语言" class="headerlink" title="Ubuntu 更改系统语言"></a>Ubuntu 更改系统语言</h3><p>先用 <code>locale -a</code> 查看系统语言环境。按下面命令格式更改语言，注销重新登录生效。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">update-locale <span class="hljs-attribute">LANG</span>=zh_CN.UTF-8<br></code></pre></td></tr></table></figure><p>如果系统没有所需语言，先使用下面命令添加，以添加简中语言为例。</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">locale-gen zh_CN.UTF-8 <span class="hljs-variable">&amp;&amp;</span> <span class="hljs-keyword">update</span>-locale<br></code></pre></td></tr></table></figure><h3 id="Debian-更改系统语言"><a href="#Debian-更改系统语言" class="headerlink" title="Debian 更改系统语言"></a>Debian 更改系统语言</h3><p>用要添加语言的国家地区代码，相应修改如下命令运行，以简中为例。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">LANG</span>=zh_CN.UTF-8<br></code></pre></td></tr></table></figure><p>再执行 <code>dpkg-reconfigure locales</code> 命令重新配置语言，用空格键选择，之后重启系统生效。</p><h3 id="Docker-内-ubuntu"><a href="#Docker-内-ubuntu" class="headerlink" title="Docker 内 ubuntu"></a>Docker 内 ubuntu</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">apt-get install language-pack-zh-hans<br>locale-gen zh_CN.UTF-8<br>locale -a<br>echo &quot;export LC_ALL=zh_CN.UTF-8&quot;&gt;&gt; /etc/profile<br>source /etc/profile<br>locale<br></code></pre></td></tr></table></figure><h2 id="date日期时间和Unix时间戳互转"><a href="#date日期时间和Unix时间戳互转" class="headerlink" title="date日期时间和Unix时间戳互转"></a>date日期时间和Unix时间戳互转</h2><h3 id="将日期转换为Unix时间戳"><a href="#将日期转换为Unix时间戳" class="headerlink" title="将日期转换为Unix时间戳"></a>将日期转换为Unix时间戳</h3><p>将当前时间以Unix时间戳表示：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-keyword">date</span> +%s<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">1361542433</span><br></code></pre></td></tr></table></figure><p>转换指定日期为Unix时间戳：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">date</span> -d &#x27;<span class="hljs-number">2013</span>-<span class="hljs-number">2</span>-<span class="hljs-number">22</span> <span class="hljs-number">22</span>:<span class="hljs-number">14</span>&#x27; +%s<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">1361542440</span><br></code></pre></td></tr></table></figure><h3 id="将Unix时间戳转换为日期时间"><a href="#将Unix时间戳转换为日期时间" class="headerlink" title="将Unix时间戳转换为日期时间"></a>将Unix时间戳转换为日期时间</h3><p>不指定日期时间的格式：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-keyword">date</span> -d @1361542596<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Fri</span> Feb <span class="hljs-number">22</span> <span class="hljs-number">22</span>:<span class="hljs-number">16</span>:<span class="hljs-number">36</span> CST <span class="hljs-number">2013</span><br></code></pre></td></tr></table></figure><p>指定日期格式的转换：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">date -d <span class="hljs-variable">@1361542596</span> +<span class="hljs-string">&quot;<span class="hljs-variable">%Y</span>-<span class="hljs-variable">%m</span>-<span class="hljs-variable">%d</span> <span class="hljs-variable">%H</span>:<span class="hljs-variable">%M</span>:<span class="hljs-variable">%S</span>&quot;</span><br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2013</span>-<span class="hljs-number">02</span>-<span class="hljs-number">22</span> <span class="hljs-number">22</span>:<span class="hljs-number">16</span>:<span class="hljs-number">36</span><br></code></pre></td></tr></table></figure><h2 id="固定IP"><a href="#固定IP" class="headerlink" title="固定IP"></a>固定IP</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">临时 固定ip 重启后失效</span><br>ifconfig eth0 192.168.2.20 netmask 255.255.255.0 up<br><span class="hljs-meta prompt_"># </span><span class="language-bash">添加 路由表</span><br>route add gw 192.168.2.254<br></code></pre></td></tr></table></figure><h2 id="Swap-分区大小调整"><a href="#Swap-分区大小调整" class="headerlink" title="Swap 分区大小调整"></a>Swap 分区大小调整</h2><p>vps磁盘空间比较小，<code>var/swapfile</code>占用空间比较大，调整swap的大小，减小这个文件占用的空间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">检查 swap 大小<br>free -m<br>关闭swap<br>swapoff -a<br>1.创建交换分区的文件:增加2G大小的交换分区<br>dd if=/dev/zero of=/var/swapfile bs=1M count=2048<br>2.设置交换文件<br>mkswap /var/swapfile<br>3.启用交换分区文件<br>swapon /var/swapfile<br>4.在/etc/fstab添加<br>echo &#x27;/var/swapfile swap swap defaults 0 0&#x27;&gt;&gt;/etc/fstab<br>5.检查<br>free -m<br></code></pre></td></tr></table></figure><h2 id="CPU调频"><a href="#CPU调频" class="headerlink" title="CPU调频"></a>CPU调频</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看当前CPU使用什么 驱动</span><br>cpufreq-info<br>cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_driver<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">常见的有 intel_cpufreq acpu_freq</span><br><br>analyzing CPU 0:<br>  driver: intel_cpufreq<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看可以使用的模式</span><br>cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_governors<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看当前运行的模式</span><br>cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor<br><br></code></pre></td></tr></table></figure><table><thead><tr><th>模式</th><th>介绍</th></tr></thead><tbody><tr><td>Performance</td><td>性能模式 保持以最大频率运行</td></tr><tr><td>powersave</td><td>只会保持最低频率，节能省电</td></tr><tr><td>userspace</td><td>自定义频率</td></tr><tr><td>ondemand</td><td>一有cpu计算量的任务，就会立即达到最大频率运行，等执行完毕就立即回到最低频率</td></tr><tr><td>conservative</td><td>根据负载状态自动在频率上下限调整 对比于ondemand 他的调整更滞后，更加柔和</td></tr><tr><td>Schedutil</td><td>…</td></tr><tr><td></td><td></td></tr><tr><td></td><td>参考<a href="https://www.kernel.org/doc/Documentation/cpu-freq/governors.txt">https://www.kernel.org/doc/Documentation/cpu-freq/governors.txt</a></td></tr></tbody></table><h3 id="CPU-Driver的修改"><a href="#CPU-Driver的修改" class="headerlink" title="CPU Driver的修改"></a>CPU Driver的修改</h3><p>修改 <code>/etc/default/grub</code> 可以修改Driver的类型</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">vi /etc/default/grub<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">找到quiet那个位置，后面加空格，再加 intel_pstate=<span class="hljs-built_in">disable</span> ，就可以改成 acpu_freq 类型</span><br>GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet&quot;<br><span class="hljs-meta prompt_">-&gt;</span><span class="language-bash"></span><br><span class="language-bash">GRUB_CMDLINE_LINUX_DEFAULT=<span class="hljs-string">&quot;quiet intel_pstate=disable&quot;</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">更新</span><br>update-grub<br><span class="hljs-meta prompt_"># </span><span class="language-bash">reboot 生效</span><br>reboot<br></code></pre></td></tr></table></figure><h3 id="intel-cpufreq-TYPE"><a href="#intel-cpufreq-TYPE" class="headerlink" title="intel_cpufreq TYPE"></a>intel_cpufreq TYPE</h3><p>在这个模式下可以通过修改<code>/etc/default/cpufrequtils</code>文件来修改cpu运行模式和最大最小频率</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vi /etc/default/cpufrequtils<br></code></pre></td></tr></table></figure><h3 id="acpu-freq-TYPE"><a href="#acpu-freq-TYPE" class="headerlink" title="acpu_freq TYPE"></a>acpu_freq TYPE</h3><p>在这个模式下可以通过修改<code>/etc/init.d/cpufrequtils</code>文件来修改cpu运行模式和最大最小频率</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">vi /etc/init.d/cpufrequtils<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">重启服务</span><br>systemctl daemon-reload<br>/etc/init.d/cpufrequtils restart<br></code></pre></td></tr></table></figure><h2 id="wget-代理"><a href="#wget-代理" class="headerlink" title="wget 代理"></a>wget 代理</h2><p><strong>方法一、在环境变量中设置代理</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">http_proxy</span>=http://127.0.0.1:8087<br></code></pre></td></tr></table></figure><p><strong>方法二、使用配置文件</strong></p><p>为wget使用代理，可以直接修改&#x2F;etc&#x2F;wgetrc，也可以在主文件夹下新建.wgetrc，并编辑相应内容，本文采用后者。</p><p>将&#x2F;etc&#x2F;wgetrc中与proxy有关的几行复制到~&#x2F;.wgetrc，并做如下修改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">You can <span class="hljs-built_in">set</span> the default proxies <span class="hljs-keyword">for</span> Wget to use <span class="hljs-keyword">for</span> http, https, and ftp.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">They will override the value <span class="hljs-keyword">in</span> the environment.</span><br>https_proxy = http://127.0.0.1:8087/<br>http_proxy = http://127.0.0.1:8087/<br>ftp_proxy = http://127.0.0.1:8087/<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">If you <span class="hljs-keyword">do</span> not want to use proxy at all, <span class="hljs-built_in">set</span> this to off.</span><br>use_proxy = on<br></code></pre></td></tr></table></figure><p> 这里 use_proxy &#x3D; on 开启了代理，如果不想使用代理，每次都修改此文件未免麻烦，我们可以在命令中使用-Y参数来临时设置：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">-Y, --proxy=<span class="hljs-keyword">on</span>/<span class="hljs-keyword">off</span>           打开或关闭代理<br></code></pre></td></tr></table></figure><p><strong>方法三、使用-e参数</strong></p><p>wget本身没有专门设置代理的命令行参数，但是有一个”-e”参数，可以在命令行上指定一个原本出现在”.wgetrc”中的设置。于是可以变相在命令行上指定代理：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">-e, <span class="hljs-params">--execute=COMMAND</span>   执行`<span class="hljs-string">.wgetrc</span>&#x27;格式的命令<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">wget</span> -c -r -np -k -L -p -e <span class="hljs-string">&quot;http_proxy=http://127.0.0.1:8087&quot;</span> http://www.subversion.org.cn/svnbook/<span class="hljs-number">1</span>.<span class="hljs-number">4</span>/<br></code></pre></td></tr></table></figure><p> 这种方式对于使用一个临时代理尤为方便。</p><h2 id="sudo-复杂语句"><a href="#sudo-复杂语句" class="headerlink" title="sudo 复杂语句"></a>sudo 复杂语句</h2><p>使用管道执行语句</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &quot;echo 12000 &gt; /dev/null&quot; | sudo sh<br><br></code></pre></td></tr></table></figure><h2 id="串口终端-显示不全-stty设置终端宽度"><a href="#串口终端-显示不全-stty设置终端宽度" class="headerlink" title="串口终端 显示不全 stty设置终端宽度"></a>串口终端 显示不全 stty设置终端宽度</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">使用<span class="hljs-built_in">stty</span> size可以查看行和列数</span><br>stty size<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用<span class="hljs-built_in">stty</span>设置列宽</span><br>stty cols 200<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置 行数</span><br>stty columns 80<br></code></pre></td></tr></table></figure><p><a href="https://www.mkssoftware.com/docs/man1/stty.1.asp">参考 tty 手册</a></p><h2 id="pigz-多线程压缩解压缩"><a href="#pigz-多线程压缩解压缩" class="headerlink" title="pigz 多线程压缩解压缩"></a>pigz 多线程压缩解压缩</h2><blockquote><p>  Pigz 的功能与 gzip 的功能相同，但在压缩时将工作分散到多个处理器和内核上。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pigz -p 16 --fast<br></code></pre></td></tr></table></figure><h2 id="linux-备份"><a href="#linux-备份" class="headerlink" title="linux 备份"></a>linux 备份</h2><p><strong>dd 指令备份</strong></p><blockquote><p>  用 dd 指令全卡备份 有数据无数据的位置都会备份</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看块设备</span><br>sudo lsblk<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看disk</span><br>sudo fdisk -l <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将文件备份</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">status=progress 是显示进度条</span><br>sudo dd if=/dev/sd&lt;x&gt; status=progress | gzip&gt;./sd_card_backup.gz<br><span class="hljs-meta prompt_"># </span><span class="language-bash">调用多核压缩</span><br>sudo dd if=/dev/sd&lt;x&gt; status=progress | pigz -p 16 --fast &gt;./sd_card_backup.gz<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">linux 下还原</span><br>sudo gzip -dc ./sd_card_backup.gz | sudo dd of=/dev/sd&lt;x&gt; bs=1M status=progress<br></code></pre></td></tr></table></figure><blockquote><p>  在找资料的途中发现，<a href="https://doc.embedfire.com/linux/imx6/base/zh/latest/building_image/image_backup.html">野火的linux教程</a>里面有一个骚操作。</p><p>  通过<code>df -h</code> 计算出来 boot 分区和 rootfs两个分区占用的大小。</p><p>  在使用dd指令的时候仅复制特定大小的区块。</p><p>  <code>sudo dd if=/dev/sdc of=./imx6ull_backup.img count=1024 bs=1M conv=sync</code>，比如这里就是复制1G大小。</p><blockquote><p>  文件系统可能会把文件存在存储设备块的后面地址吗？如果会这种方式岂不是会丢文件？</p></blockquote></blockquote><p><strong>备份文件系统</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /<br><span class="hljs-meta prompt_">#</span><span class="language-bash">tar.gz格式</span><br>tar cvpzf system_backup.tar.gz / --exclude=/proc --exclude=/lost+found --exclude=/system_backup.tar.gz --exclude=/mnt --exclude=/sys<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">tar.bz2格式</span><br>tar cvpjf system_backup.tar.bz2 / --exclude=/proc --exclude=/lost+found --exclude=/system_backup.tar.bz2 --exclude=/mnt --exclude=/sys<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">恢复系统</span><br>cd /<br><span class="hljs-meta prompt_">#</span><span class="language-bash">上传文件到根目录下</span><br>tar xvpfz system_backup.tar.gz -C /<br>或<br>tar xvpfj system_backup.tar.bz2 -C /<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">创建备份时排除的目录</span><br>mkdir proc<br>mkdir lost+found<br>mkdir mnt<br>mkdir sys<br></code></pre></td></tr></table></figure><h2 id="bash-显示-git-分支名"><a href="#bash-显示-git-分支名" class="headerlink" title="bash 显示 git 分支名"></a>bash 显示 git 分支名</h2><p>在<code>~/.bashrc</code>文件末尾添加如下代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">function git_branch &#123;<br>    branch=&quot;`git branch 2&gt;/dev/null | grep &quot;^\*&quot; | sed -e &quot;s/^\*\ //&quot;`&quot;<br>    if [ &quot;$&#123;branch&#125;&quot; != &quot;&quot; ];then<br>        if [ &quot;$&#123;branch&#125;&quot; = &quot;(no branch)&quot; ];then<br>            branch=&quot;(`git rev-parse --short HEAD`...)&quot;<br>        fi<br>        echo &quot; ($branch)&quot;<br>    fi<br>&#125;<br>export PS1=&#x27;\u@\h \[\033[01;36m\]\W\[\033[01;32m\]$(git_branch)\[\033[00m\] \$ &#x27;<br></code></pre></td></tr></table></figure><h2 id="SCP-文件传输"><a href="#SCP-文件传输" class="headerlink" title="SCP 文件传输"></a>SCP 文件传输</h2><p>目录加<code>-r</code>参数即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">从服务器上下载文件</span><br>scp username@servername:/path/filename /path/filename<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">上传本地文件到服务器</span><br>scp /path/filename username@servername:/path/filename<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">下载整个目录</span><br>scp -r username@servername:/path/ /path<br></code></pre></td></tr></table></figure><h2 id="系统信息查看"><a href="#系统信息查看" class="headerlink" title="系统信息查看"></a>系统信息查看</h2><ol><li>◆<strong>uname</strong> - 显示内核信息：<ul><li><code>uname -a</code>：显示所有信息，包括内核版本、主机名、处理器类型等。</li></ul></li><li>◆<strong>lsb_release</strong> - 显示Linux标准基础（LSB）版本信息：<ul><li><code>lsb_release -a</code>：显示LSB和发行版信息。</li></ul></li><li><strong>hostnamectl</strong> - 显示系统主机名和系统信息：<ul><li><code>hostnamectl</code>：显示当前的主机名、操作系统名称、内核版本等。</li></ul></li><li><strong>cat &#x2F;etc&#x2F;release</strong> - 显示发行版信息：<ul><li><code>cat /etc/release</code>：显示类似于lsb_release的信息，但直接从文件中读取。</li></ul></li><li>◆<strong>df</strong> - 显示磁盘空间使用情况：<ul><li><code>df -h</code>：以人类可读的格式显示磁盘空间。</li></ul></li><li>◆<strong>free</strong> - 显示内存使用情况：<ul><li><code>free -m</code>：以MB为单位显示内存使用情况。</li></ul></li><li>◆<strong>top</strong> 或 <strong>htop</strong> - 实时显示系统进程和资源使用情况。</li><li><strong>vmstat</strong> - 显示虚拟内存统计信息。</li><li><strong>iostat</strong> - 显示CPU和输入&#x2F;输出统计信息。</li><li><strong>dmesg</strong> - 显示或控制内核环形缓冲区。</li><li><strong>ifconfig</strong> 或 <strong>ip addr</strong> - 显示网络接口配置。</li><li>◆<strong>lscpu</strong> - 显示CPU信息。</li><li>◆<strong>lsblk</strong> - 列出所有可用的块设备。</li><li>◆<strong>lspci</strong> - 列出所有PCI设备，网卡、硬盘、显示器…。</li><li>◆<strong>lsusb</strong> - 列出所有USB设备。</li><li>◆<strong>lsmod</strong> - 显示已加载的内核模块。</li><li>◆<strong>uptime</strong> - 查询平均负载</li></ol><h2 id="sysbench"><a href="#sysbench" class="headerlink" title="sysbench"></a>sysbench</h2><p><code>sysbench</code> 是一款开源的多用途基准测试实用程序，它可以评估包括 CPU、内存、I&#x2F;O 和数据库（如 MySQL）在内的多个系统组件的性能。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">对cpu进行测试 使用8个线程 测试时间60s</span> <br>sysbench cpu --threads=8 --time=60  run<br><br></code></pre></td></tr></table></figure><h1 id="RaspberryPI"><a href="#RaspberryPI" class="headerlink" title="RaspberryPI"></a>RaspberryPI</h1><h2 id="密码"><a href="#密码" class="headerlink" title="密码"></a>密码</h2><h3 id="树莓派OS-默认"><a href="#树莓派OS-默认" class="headerlink" title="树莓派OS 默认"></a>树莓派OS 默认</h3><blockquote><p>   pi<br>  raspberry</p></blockquote><p>注意！！</p><blockquote><p>  新版树莓派的镜像将没有默认密码</p><p>  <a href="https://www.raspberrypi.com/news/raspberry-pi-bullseye-update-april-2022/">参考</a></p><p>  我们只需要将存储卡插入到PC在<code>boot</code>盘下新建文件<code>userconf</code>或者<code>userconf.txt</code></p><p>  文件内容是<code>username:encrypted-password</code></p><p>  <code>encrypted-password</code>是通过这个命令运算来的</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &#x27;mypassword&#x27; | openssl passwd -6 -stdin<br></code></pre></td></tr></table></figure><p>  用户名是<code>pi</code>密码是<code>raspberry</code> 那么文件内容形如下面这样</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pi:$6$LXbLeu63.T9FIeWq$rdm2RMzZQLjs1nDI7wiPEx8UKrVWpcEuhSvjFTR4smGXqO9bMow5Imkdgzk.PKdxf.sjxy.dKYDIXneJ0INst/<br></code></pre></td></tr></table></figure></blockquote><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="WiFi-网络配置"><a href="#WiFi-网络配置" class="headerlink" title="WiFi 网络配置"></a>WiFi 网络配置</h3><p>用户可以在未启动树莓派的状态下单独修改 &#x2F;boot&#x2F;wpa_supplicant.conf 文件配置 WiFi 的 SSID 和密码，这样树莓派启动后会自行读取 wpa_supplicant.conf 配置文件连接 WiFi 设备。</p><p>操作方法简单：将刷好 Raspbian 系统的 SD 卡用电脑读取。在 boot 分区，也就是树莓派的 &#x2F;boot 目录下新建 wpa_supplicant.conf 文件，按照下面的参考格式填入内容并保存 <code>wpa_supplicant.conf</code> 文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs shell">country=CN<br>ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev<br>update_config=1<br> <br>network=&#123;<br>ssid=&quot;WiFi-A&quot;#ssid:网络的ssid<br>psk=&quot;12345678&quot;#psk:密码<br>key_mgmt=WPA-PSK<br>priority=1#priority:连接优先级，数字越大优先级越高（不可以是负数）<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">隐藏WiFi</span><br>network=&#123;<br>ssid=&quot;WiFi-B&quot;<br>psk=&quot;12345678&quot;<br>key_mgmt=WPA-PSK<br>priority=2<br>scan_ssid=1#scan_ssid:连接隐藏WiFi时需要指定该值为1<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">WiFi 没有密码</span><br>network=&#123;<br>ssid=&quot;你的无线网络名称（ssid）&quot;<br>key_mgmt=NONE<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果你的 WiFi 使用WEP加密</span><br>network=&#123;<br>ssid=&quot;你的无线网络名称（ssid）&quot;<br>key_mgmt=NONE<br>wep_key0=&quot;你的wifi密码&quot;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="开启-SSH-服务"><a href="#开启-SSH-服务" class="headerlink" title="开启 SSH 服务"></a>开启 SSH 服务</h3><ul><li>在boot盘下新建<code>ssh</code>文件即可开启ssh</li></ul><h3 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 树莓派相关配置</span><br><span class="hljs-built_in">sudo</span> raspi-config<br></code></pre></td></tr></table></figure><h2 id="开关机"><a href="#开关机" class="headerlink" title="开关机"></a>开关机</h2><h3 id="安全关机："><a href="#安全关机：" class="headerlink" title="安全关机："></a>安全关机：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo shutdown -h now<br>sudo halt<br>sudo poweroff<br>sudo init 0<br></code></pre></td></tr></table></figure><h3 id="安全重启："><a href="#安全重启：" class="headerlink" title="安全重启："></a>安全重启：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo reboot<br>shutdown -r now<br></code></pre></td></tr></table></figure><h2 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h2><p><img src="/2020/d4436089/GPIO1.png" alt="GPIO1"></p><p><img src="/2020/d4436089/image-20210801204738591.png" alt="image-20210801204738591"></p><h1 id="RaspberryPI-Note"><a href="#RaspberryPI-Note" class="headerlink" title="RaspberryPI Note"></a>RaspberryPI Note</h1><h2 id="wiringPi-GPIO库"><a href="#wiringPi-GPIO库" class="headerlink" title="wiringPi GPIO库"></a>wiringPi GPIO库</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /tmp<br>wget https://project-downloads.drogon.net/wiringpi-latest.deb<br>sudo dpkg -i wiringpi-latest.deb<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看GPIO编码</span><br>gpio readall<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">树莓派4b 需要版本大于2.52</span><br>gpio -v<br><br></code></pre></td></tr></table></figure><h3 id="shell操作"><a href="#shell操作" class="headerlink" title="shell操作"></a>shell操作</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>进入<code>/sys/class/gpio/</code>目录并查看文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /sys/class/gpio/<br>ls<br></code></pre></td></tr></table></figure><p><img src="/2020/d4436089/1889022-20200410121643886-1233996502.png" alt="img"></p><p>目录<code>export</code>为创建，<code>unexport</code>为删除</p><p>将gpio18重定向用户定义设备，生成gpio18目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo echo 18 &gt; export<br></code></pre></td></tr></table></figure><p><img src="/2020/d4436089/1889022-20200410132825370-786913267.png" alt="img"></p><p>进入<code>gpio18</code>目录并查看文件</p><p><img src="/2020/d4436089/1889022-20200410134354086-537662427.png" alt="img"></p><p><code>direction</code>设置引脚方向，输入还是输出</p><p><code>value</code>设置引脚状态，高电平还是低电平</p><h4 id="输入状态"><a href="#输入状态" class="headerlink" title="输入状态"></a>输入状态</h4><p>设置引脚状态为输入状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo echo in &gt; direction<br></code></pre></td></tr></table></figure><p><img src="/2020/d4436089/1889022-20200410134655161-2081521744.png" alt="img"></p><p>查看引脚高低电平</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat value <br></code></pre></td></tr></table></figure><h4 id="输出状态"><a href="#输出状态" class="headerlink" title="输出状态"></a>输出状态</h4><p>设置引脚状态为输出状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo echo out &gt; direction<br></code></pre></td></tr></table></figure><p><img src="/2020/d4436089/1889022-20200410134856417-744239525.png" alt="img"></p><p>设置输出高电平</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo echo 1 &gt; value<br></code></pre></td></tr></table></figure><p>设置输出低电平</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo echo 0 &gt; value<br></code></pre></td></tr></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>测试完毕之后返回<code>/sys/class/gpio/</code>目录，并将gpio注销</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /sys/class/gpio/<br>sudo echo 18 &gt; /sys/class/gpio/unexport<br></code></pre></td></tr></table></figure><h2 id="增加开机启动项-1"><a href="#增加开机启动项-1" class="headerlink" title="增加开机启动项"></a>增加开机启动项</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo nano /etc/rc.local<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在打开的rc.local找到<span class="hljs-built_in">exit</span> 0，在<span class="hljs-built_in">exit</span> 0 之前添加即可</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">执行这段代码时是使用root用户权限的，注意当前的用户权限，以免因权限问题导致脚本执行失败。</span><br><br></code></pre></td></tr></table></figure><h2 id="树莓派自动挂载U盘"><a href="#树莓派自动挂载U盘" class="headerlink" title="树莓派自动挂载U盘"></a>树莓派自动挂载U盘</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">打开文件 添加以下 这个带有超时,可以避免拔掉U盘开不了机</span><br>sudo nano /etc/fstab<br><span class="hljs-meta prompt_"># </span><span class="language-bash">/dev/sda1 /mnt/usb    auto     defaults,nofail,x-systemd.device-timeout=1,noatime  0   0</span><br></code></pre></td></tr></table></figure><h2 id="查看温度"><a href="#查看温度" class="headerlink" title="查看温度"></a>查看温度</h2><p>使用watch命令每秒打印一次cpu温度信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">watch -n 1 cat /sys/class/thermal/thermal_zone0/temp<br></code></pre></td></tr></table></figure><p>由于 Raspberry Pi 系列上使用的 SoC 的架构，以及在 Raspberry Pi OS 发行版中使用上游温度监控代码，基于 Linux 的温度测量可能不准确。但是，该<code>vcgencmd</code>命令在直接与 GPU 通信时提供了当前 SoC 温度的准确和即时读数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vcgencmd measure_temp<br></code></pre></td></tr></table></figure><h2 id="远程桌面"><a href="#远程桌面" class="headerlink" title="远程桌面"></a>远程桌面</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install xrdp<br></code></pre></td></tr></table></figure><h2 id="固定IP-1"><a href="#固定IP-1" class="headerlink" title="固定IP"></a>固定IP</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> nano /etc/dhcpcd.conf<br><br><span class="hljs-comment"># 找到如下内容 对应修改即可</span><br><span class="hljs-comment"># Example static IP configuration:</span><br><span class="hljs-comment">#interface eth0</span><br><span class="hljs-comment">#static ip_address=192.168.0.10/24</span><br><span class="hljs-comment">#static ip6_address=fd51:42f8:caae:d92e::ff/64</span><br><span class="hljs-comment">#static routers=192.168.0.1</span><br><span class="hljs-comment">#static domain_name_servers=192.168.0.1 8.8.8.8 fd51:42f8:caae:d92e::1</span><br><br><span class="hljs-comment"># eg.</span><br>interface wlan0<br>static ip_address=192.168.31.222/24<br>static routers=192.168.31.254<br>static domain_name_servers=223.5.5.5 192.168.31.254<br></code></pre></td></tr></table></figure><h2 id="I2C相关"><a href="#I2C相关" class="headerlink" title="I2C相关"></a>I2C相关</h2><h3 id="修改I2C总线速度"><a href="#修改I2C总线速度" class="headerlink" title="修改I2C总线速度"></a>修改I2C总线速度</h3><p><strong>启用I2C接口</strong></p><p><code>sudo raspi-config</code></p><p>命令将启动raspi-config实用程序。选择“Interfacing Options”:</p><p>将光标移动到“P5 I2C”，选中，然后“select”。</p><p><strong>编辑Config.txt文件设置I2C总线速度</strong></p><p><code>sudo nano /boot/config.txt</code></p><p>查找包含“<code>dtparam=i2c_arm=on</code>”的行，添加“<code>i2c_arm_baudrate=400000</code>”，其中<code>400000</code>是新设置的速度(400kbit &#x2F;s)，注意i2c前面的逗号。完整代码如下：</p><p><code>dtparam=i2c_arm=on,i2c_arm_baudrate=400000</code></p><p>这样可以启用I2C总线的同时，也完成了新波特率的设置。编辑完成后，使用CTRL-X，然后选择Y，保存文件并退出，<strong>并重新启动</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">Get-AppxPackage *WindowsStore* | Select Name, PackageFullName<br><br>https://aka.ms/Microsoft.VCLibs.x64.14.00.Desktop.appx<br>https://aka.ms/Microsoft.VCLibs.x86.14.00.Desktop.appx<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RTX</title>
    <link href="/2020/2b1e625a/"/>
    <url>/2020/2b1e625a/</url>
    
    <content type="html"><![CDATA[<h1 id="创建一个RTX项目"><a href="#创建一个RTX项目" class="headerlink" title="创建一个RTX项目"></a>创建一个RTX项目</h1><p><strong>Create an RTX5 Project</strong></p><ol><li><p>创建一个新的项目,并选择单片机设备。</p><p>Create a new project and select a microcontroller device.</p></li><li><p>设置 <strong>CMSIS::CORE</strong> 和 <strong>CMSIS::RTOS2 (API)::Keil RTX5</strong>，在下拉框中你可以选择添加RTX库或者添加完整源代码。</p><p>In the Manage Run-Time Environment window, select <strong>CMSIS::CORE</strong> and <strong>CMSIS::RTOS2 (API)::Keil RTX5</strong>. You can choose to either add RTX as a library (Variant: <strong>Library</strong>) or to add the full source code (Variant: <strong>Source</strong> - required if using the <a href="http://www.keil.com/pack/doc/compiler/EventRecorder/html/index.html"><strong>Event Recorder</strong></a>):</p></li><li><p>添加启动文件 <strong>Device::Startup</strong></p></li><li><p>一个示例代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">osKernelInitialize();/ /初始化RTX<br><span class="hljs-title function_">NVIC_SetPriorityGrouping</span> <span class="hljs-params">(<span class="hljs-number">3</span>)</span>;/ /设置优先级分组<br>tread_id =osThreadNew(tread_func,空,空);/ /创建一些线程<br>osKernelStart();/ /开始RTX内核<br></code></pre></td></tr></table></figure><p>注：</p><ol><li><p>添加RTX特定功能的支持</p><p>如果你需要一些的<a href="group__rtx5__specific.html">RTX特定功能</a>在您的应用程序代码中,# include<a href="theory_of_operation.html#rtx_os_h">头文件rtx_os.h</a>。 如使能<a href="theory_of_operation.html#lowPower">低功耗</a>和<a href="theory_of_operation.html#TickLess">tick-less</a>操作模式。</p></li><li><p>添加事件记录器</p><ul><li><p>打开MRTE(Manage Run-Time Environment)窗口</p></li><li><p>确保RTX5使用的是源代码(Source)模式</p></li><li><p>打开 <strong>Compiler::Event Recorder</strong></p></li></ul></li></ol></li></ol><h1 id="中断-Cortex-M"><a href="#中断-Cortex-M" class="headerlink" title="中断 (Cortex-M)"></a>中断 (Cortex-M)</h1><p>Cortex-M处理器,RTX5内核使用以下异常中断。 下面的表格还列出了必须分配给这些中断的优先级。</p><table><thead><tr><th>处理程序</th><th>优先级</th><th>中断&#x2F;异常</th></tr></thead><tbody><tr><td>SysTick</td><td>最低</td><td>内核系统定时器中断产生周期性的计时器滴答声</td></tr><tr><td>PendSV</td><td>最低</td><td>PendSV(系统级服务请求)当调用某些RTX功能<strong>处理程序</strong>模式</td></tr><tr><td>SVC</td><td>最低+ 1</td><td>主管叫用来输入RTOS内核<strong>线程</strong>模式</td></tr></tbody></table><p>可以使用其他设备中断没有限制。 ARM Cortex-M3 &#x2F; M4 &#x2F; M7 &#x2F; M23 &#x2F; M33 &#x2F; M35P处理器,从未被RTX禁用中断内核。</p><p><strong>使用中断的优先级分组</strong></p><ul><li>在调用函数<a href="group__CMSIS__RTOS__KernelCtrl.html#ga9ae2cc00f0d89d7b6a307bba942b5221">osKernelStart（）</a>之前，应使用CMSIS-Core函数NVIC_SetPriorityGrouping配置中断优先级分组。RTX内核使用优先级组值来设置SysTick和PendSV中断的优先级。</li><li>RTX内核为上表中列出的中断&#x2F;异常设置优先级，并使用最低的两个优先级。</li><li>不要更改RTX内核使用的优先级。如果无法避免，请确保SysTick &#x2F; PendSV的抢占优先级低于SVC。</li><li>允许的优先级组值为0到6.优先级组值7将导致RTX失败，因为只有一个可用优先级。</li><li>的<strong>main函数堆叠</strong>被用于运行RTX功能。因此，需要为RTX内核执行配置足够的堆栈。</li></ul>]]></content>
    
    
    <categories>
      
      <category>RTOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rtx</tag>
      
      <tag>rtos</tag>
      
      <tag>keil</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UCOS</title>
    <link href="/2020/2ac84091/"/>
    <url>/2020/2ac84091/</url>
    
    <content type="html"><![CDATA[<h2 id="序章"><a href="#序章" class="headerlink" title="序章"></a>序章</h2><h3 id="延时函数"><a href="#延时函数" class="headerlink" title="延时函数"></a>延时函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>  <span class="hljs-title function_">OSTimeDlyHMSM</span> <span class="hljs-params">(CPU_INT16U   hours,</span><br><span class="hljs-params">                     CPU_INT16U   minutes,</span><br><span class="hljs-params">                     CPU_INT16U   seconds,</span><br><span class="hljs-params">                     CPU_INT32U   milli,</span><br><span class="hljs-params">                     OS_OPT       opt,</span><br><span class="hljs-params">                     OS_ERR      *p_err)</span><br><br><span class="hljs-title function_">OSTimeDlyHMSM</span><span class="hljs-params">(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,OS_OPT_TIME_HMSM_STRICT,&amp;err)</span>; <span class="hljs-comment">//延时1s</span><br><span class="hljs-comment">//strick   adj. 严格的；绝对的；精确的；详细的</span><br></code></pre></td></tr></table></figure><h2 id="任务管理"><a href="#任务管理" class="headerlink" title="任务管理"></a>任务管理</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//创建开始任务</span><br>OSTaskCreate((OS_TCB * )&amp;StartTaskTCB,<span class="hljs-comment">//任务控制块</span><br> (CPU_CHAR* )<span class="hljs-string">&quot;start task&quot;</span>, <span class="hljs-comment">//任务名字</span><br>                 (OS_TASK_PTR )start_task, <span class="hljs-comment">//任务函数</span><br>                 (<span class="hljs-type">void</span>* )<span class="hljs-number">0</span>,<span class="hljs-comment">//传递给任务函数的参数</span><br>                 (OS_PRIO  )START_TASK_PRIO,     <span class="hljs-comment">//任务优先级</span><br>                 (CPU_STK   * )&amp;START_TASK_STK[<span class="hljs-number">0</span>],<span class="hljs-comment">//任务堆栈基地址</span><br>                 (CPU_STK_SIZE)START_STK_SIZE/<span class="hljs-number">10</span>,<span class="hljs-comment">//任务堆栈深度限位</span><br>                 (CPU_STK_SIZE)START_STK_SIZE,<span class="hljs-comment">//任务堆栈大小</span><br>                 (OS_MSG_QTY  )<span class="hljs-number">0</span>,<span class="hljs-comment">//任务内部消息队列能够接收的最大消息数目,为0时禁止接收消息</span><br>                 (OS_TICK  )<span class="hljs-number">0</span>,<span class="hljs-comment">//当使能时间片轮转时的时间片长度，为0时为默认长度，</span><br>                 (<span class="hljs-type">void</span>   * )<span class="hljs-number">0</span>,<span class="hljs-comment">//用户补充的存储区</span><br>                 (OS_OPT      )OS_OPT_TASK_STK_CHK|OS_OPT_TASK_STK_CLR, <span class="hljs-comment">//任务选项</span><br>                 (OS_ERR * )&amp;err);<span class="hljs-comment">//存放该函数错误时的返回值</span><br><br><br></code></pre></td></tr></table></figure><ol><li><p><code>(CPU_STK_SIZE)START_STK_SIZE/10,//任务堆栈深度限位</code>    一般设定小于10%即可</p></li><li><p><code>(OS_TCB * )&amp;StartTaskTCB,//任务控制块</code>   <strong>不要访问和更改其中的成员变量</strong></p></li></ol><h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><ul><li><p>数值越小优先级越高</p></li><li><p>os_cfg.h line48   <strong>OS_CFG_PRIO_MAX</strong>  最大优先级数</p></li></ul><h4 id="就绪表"><a href="#就绪表" class="headerlink" title="就绪表"></a>就绪表</h4><ul><li>优先级位映射表**OSPrioTbl[]**：用来记录哪个优先级下有任务就绪</li><li>就绪任务列表**OSRdyList[]**：用来记录每一个优先级下所有就绪的任务</li></ul><h4 id="前导零"><a href="#前导零" class="headerlink" title="前导零"></a>前导零</h4><ul><li>硬件计算  能计算一个值前面有多少零</li></ul><h2 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h2><h4 id="任务调度-1"><a href="#任务调度-1" class="headerlink" title="任务调度"></a>任务调度</h4><ul><li>任务调度器 进入中断   OSIntEnter();  </li><li>任务调度器 退出中断   OSIntExit();</li></ul><h4 id="发生任务调度的调度点"><a href="#发生任务调度的调度点" class="headerlink" title="发生任务调度的调度点"></a>发生任务调度的调度点</h4><ul><li>延时函数OSTimeDly()（按时间延时）或者OSTimeDlyHMSM()（按节拍延时）</li><li>创建、删除任务</li><li>改变优先级</li><li>通过调用OSTaskSuspend()将自身挂起、或解除某个挂起的任务</li><li>OSSched() 用户自行请求调度</li></ul><h4 id="调度器上锁解锁"><a href="#调度器上锁解锁" class="headerlink" title="调度器上锁解锁"></a>调度器上锁解锁</h4><ul><li>OSSchedLock()加锁</li><li>OSSchedUnlock()解锁</li></ul><h4 id="时间片轮转调度"><a href="#时间片轮转调度" class="headerlink" title="时间片轮转调度"></a>时间片轮转调度</h4><ul><li>待补充</li></ul><h2 id="UCOS系统初始化"><a href="#UCOS系统初始化" class="headerlink" title="UCOS系统初始化"></a>UCOS系统初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>   OS_ERR err;<br>   ……<br>   <span class="hljs-comment">//其他函数，一般为外设初始化函数</span><br>   ……<br>   OSInit(&amp;err);<br>   ……<br>   <span class="hljs-comment">//其他函数，一般为创建任务函数</span><br>   ……<br>   OSStart(&amp;err);<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>OSInit()必须先于其他的UCOS函数调用包括OSStart()</li></ul><h2 id="任务创建与管理"><a href="#任务创建与管理" class="headerlink" title="任务创建与管理"></a>任务创建与管理</h2><h4 id="任务的创建"><a href="#任务的创建" class="headerlink" title="任务的创建"></a>任务的创建</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">OSTaskCreate((OS_TCB * )&amp;StartTaskTCB,<span class="hljs-comment">//任务控制块</span><br>             (CPU_CHAR* )<span class="hljs-string">&quot;start task&quot;</span>, <span class="hljs-comment">//任务名字</span><br>             (OS_TASK_PTR )start_task, <span class="hljs-comment">//任务函数</span><br>             (<span class="hljs-type">void</span>* )<span class="hljs-number">0</span>,<span class="hljs-comment">//传递给任务函数的参数</span><br>             (OS_PRIO  )START_TASK_PRIO,     <span class="hljs-comment">//任务优先级</span><br>             (CPU_STK   * )&amp;START_TASK_STK[<span class="hljs-number">0</span>],<span class="hljs-comment">//任务堆栈基地址</span><br>             (CPU_STK_SIZE)START_STK_SIZE/<span class="hljs-number">10</span>,<span class="hljs-comment">//任务堆栈深度限位</span><br>             (CPU_STK_SIZE)START_STK_SIZE,<span class="hljs-comment">//任务堆栈大小</span><br>             (OS_MSG_QTY  )<span class="hljs-number">0</span>,<span class="hljs-comment">//任务内部消息队列能够接收的最大消息数目,为0时禁止接收消息</span><br>             (OS_TICK  )<span class="hljs-number">0</span>,<span class="hljs-comment">//当使能时间片轮转时的时间片长度，为0时为默认长度，</span><br>             (<span class="hljs-type">void</span>   * )<span class="hljs-number">0</span>,<span class="hljs-comment">//用户补充的存储区</span><br>             (OS_OPT      )OS_OPT_TASK_STK_CHK|OS_OPT_TASK_STK_CLR, <span class="hljs-comment">//任务选项</span><br>             (OS_ERR * )&amp;err);<span class="hljs-comment">//存放该函数错误时的返回值</span><br></code></pre></td></tr></table></figure><p>OS_ERR 错误代码</p><h4 id="任务的删除"><a href="#任务的删除" class="headerlink" title="任务的删除"></a>任务的删除</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>  <span class="hljs-title function_">OSTaskDel</span> <span class="hljs-params">(OS_TCB  *p_tcb,</span><br><span class="hljs-params">                 OS_ERR  *p_err)</span>;<br>    <br>OSTaskDel((OS_TCB*)&amp;Task2_TaskTCB,&amp;err);<br></code></pre></td></tr></table></figure><p>不建议在系统运行时删除任务</p><blockquote><p>尽管UCOSIII允许在系统运行中删除任务，但是应该尽量避免这种操作，如果这个任务可能占有与其他任务共享的资源，在删除此任务之前这个被占有的资源没有被释放就有可能导致奇怪的结果。</p></blockquote><h2 id="任务的挂起与恢复"><a href="#任务的挂起与恢复" class="headerlink" title="任务的挂起与恢复"></a>任务的挂起与恢复</h2><h3 id="挂起"><a href="#挂起" class="headerlink" title="挂起"></a>挂起</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>   <span class="hljs-title function_">OSTaskSuspend</span> <span class="hljs-params">(OS_TCB  *p_tcb,</span><br><span class="hljs-params">                      OS_ERR  *p_err)</span>;<br><br>OSTaskSuspend((OS_TCB*)&amp;Task2_TaskTCB,&amp;err);<span class="hljs-comment">//挂起任务2</span><br></code></pre></td></tr></table></figure><p>挂起错误</p><ul><li>任务被加锁</li><li>任务空闲</li></ul><h3 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>  <span class="hljs-title function_">OSTaskResume</span> <span class="hljs-params">(OS_TCB  *p_tcb,</span><br><span class="hljs-params">                    OS_ERR  *p_err)</span><br><br><span class="hljs-title function_">OSTaskResume</span><span class="hljs-params">((OS_TCB*)&amp;Task2_TaskTCB,&amp;err)</span>;<span class="hljs-comment">//恢复任务2</span><br></code></pre></td></tr></table></figure><p>恢复错误</p><ul><li>任务状态无效（错误的状态）、任务不是已经挂起的</li><li>不能恢复自己</li></ul><h2 id="时间片轮转调度-1"><a href="#时间片轮转调度-1" class="headerlink" title="时间片轮转调度"></a>时间片轮转调度</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>  <span class="hljs-title function_">OSSchedRoundRobinCfg</span> <span class="hljs-params">(CPU_BOOLEAN   en,</span><br><span class="hljs-params">                            OS_TICK       dflt_time_quanta,</span><br><span class="hljs-params">                            OS_ERR       *p_err)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span>OS_CFG_SCHED_ROUND_ROBIN_EN  <span class="hljs-comment">//当使用时间片轮转的时候</span></span><br> <span class="hljs-comment">//使能时间片轮转调度功能,时间片长度为1个系统时钟节拍，既1*5=5ms</span><br><span class="hljs-title function_">OSSchedRoundRobinCfg</span><span class="hljs-params">(DEF_ENABLED,<span class="hljs-number">1</span>,&amp;err)</span>;  <br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul><li>设置宏  <strong>OS_CFG_SCHED_ROUND_ROBIN_EN</strong>  为1</li><li>调用函数  <strong>OSSchedRoundRobinCfg()</strong>  开启时间片轮转调度功能</li></ul><h3 id="时间片的放弃"><a href="#时间片的放弃" class="headerlink" title="时间片的放弃"></a>时间片的放弃</h3><p><code>OSSchedRoundRobinYield(&amp;err);</code></p><h3 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h3><p>时间片如果不够执行可能会产生奇怪的效果请注意</p><h2 id="系统内部任务"><a href="#系统内部任务" class="headerlink" title="系统内部任务"></a>系统内部任务</h2><ol><li><p>中断服务管理任务</p></li><li><p>时钟节拍任务</p></li><li><p>定时任务（可选）</p></li><li><p>统计任务（可选）</p></li><li><p>空闲任务</p></li></ol><h3 id="中断服务管理任务"><a href="#中断服务管理任务" class="headerlink" title="中断服务管理任务"></a>中断服务管理任务</h3><ul><li>默认优先级最高，第一，不可更改。</li></ul><h3 id="时钟节拍任务"><a href="#时钟节拍任务" class="headerlink" title="时钟节拍任务"></a>时钟节拍任务</h3><ul><li>优先级较高，第二。</li></ul><h3 id="定时任务（可选）"><a href="#定时任务（可选）" class="headerlink" title="定时任务（可选）"></a>定时任务（可选）</h3><ul><li><p>默认优先级，第三。</p></li><li><p>提供软件定时功能</p></li><li><p>将宏OS_CFG_TMR_EN设置为1就会使能定时任务，在OSInit()中将会调用函数OS_TmrInit()来创建定时任务。</p></li></ul><h3 id="统计任务（可选）"><a href="#统计任务（可选）" class="headerlink" title="统计任务（可选）"></a>统计任务（可选）</h3><ul><li>一般优先级，倒数第二。</li><li>统计CPU使用率，堆栈使用率</li><li>可选创建（将宏<strong>OS_CFG_STAT_TASK_EN</strong>置1）</li><li>必须在main函数创建的以一个任务也是唯一的一个应用任务里面调用函数**OSStatTaskCPUUsageInit()**查询使用情况</li></ul><h3 id="空闲任务"><a href="#空闲任务" class="headerlink" title="空闲任务"></a>空闲任务</h3><ul><li>优先级最低，倒数第一。</li><li>不能调用会使空闲任务进入等待态的函数。</li><li><span style="color:red">可统计CPU使用率</span>（用处）</li></ul><h2 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h2><p>共有8个</p><ol><li>OSIdleTaskHook()，<strong>空闲任务</strong>调用这个函数，可以用来让CPU进入低功耗模式</li><li>OSInitHook()，<strong>系统初始化</strong>函数OSInit()调用此函数</li><li>OSStatTaskHook(), <strong>统计任务每秒</strong>中都会调用这个函数，此函数允许你向统计任务中添加自己的应用函数。</li><li>OSTaskCreateHook(),<strong>任务创建</strong>的钩子函数。</li><li>OSTaskDelHook(),<strong>任务删除</strong>的钩子函数。</li><li>OSTaskReturnHook(),<strong>任务意外返回</strong>时调用的钩子函数，比如删除某个任务</li><li>OSTaskSwHook(),<strong>任务切换</strong>时候调用的钩子函数。</li><li>OSTimeTickHook()，<strong>滴答定时器</strong>调用的钩子函数。</li></ol><h2 id="中断时间管理"><a href="#中断时间管理" class="headerlink" title="中断时间管理"></a>中断时间管理</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">USART1_IRQHandler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>       OSIntEnter();<br>      <span class="hljs-comment">//中断服务程序</span><br>      OSIntExit();<br>&#125;  <br><br><br><br></code></pre></td></tr></table></figure><ul><li>最大250级中断嵌套</li></ul><h2 id="临界区代码保护"><a href="#临界区代码保护" class="headerlink" title="临界区代码保护"></a>临界区代码保护</h2><blockquote><p>临界区：不可被打断的代码段</p></blockquote><p>OS_CFG_ISR_POST_DEFERRED_EN   的值与临界段代码保护方式</p><table><thead><tr><th>0</th><th>关中断</th></tr></thead><tbody><tr><td>1</td><td>调度器上锁（可能会被其它中断打断）</td></tr></tbody></table><ol><li><p>进入临界段</p><ul><li>一个进入函数</li></ul></li><li><p>退出临界段</p><ul><li><p>退出后产生调度——-OS_CRITICAL_EXIT()</p></li><li><p>退出后不产生调度—-OS_CRITICAL_EXIT_NO_SCHED()</p></li><li></li></ul></li></ol><h3 id="CPU-SR-ALLOC"><a href="#CPU-SR-ALLOC" class="headerlink" title="CPU_SR_ALLOC()"></a>CPU_SR_ALLOC()</h3><ol><li>函数CPU_SR_ALLOC()是为CPU_CRITICAL_ENTER()和CPU_CRITICAL_EXIT()申请一个变量：</li></ol><p><code>#define  CPU_SR_ALLOC()           CPU_SR  cpu_sr = (CPU_SR)0</code></p><p>这个是临界代码段，在下面一个小节有详细讲解。</p><ol start="2"><li>这样做是为了防止编译器警告。</li></ol><h2 id="任务延时"><a href="#任务延时" class="headerlink" title="任务延时"></a>任务延时</h2><ul><li>开始延时</li></ul><table><thead><tr><th>OSTimeDly()</th><th>相对延时</th><th>基于时钟节拍</th></tr></thead><tbody><tr><td></td><td>绝对延时</td><td></td></tr><tr><td></td><td>周期延时</td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td>OSTimeDlyHMSM()</td><td>相对延时</td><td>基于时间</td></tr></tbody></table><ul><li><p>取消延时</p><p>延时任务任务可通过在其他任务中调用函数OSTimeDlyResume()取消延时而进入就绪状态，此函数最后会引发一次任务调度。</p></li></ul><h2 id="获取系统时间"><a href="#获取系统时间" class="headerlink" title="获取系统时间"></a>获取系统时间</h2><p>​UCOSIII定义了一个 CPU_INT32U 类型的全局变量 OSTickCtr 来记录系统时钟节拍数，在调用 <strong>OSInit()</strong> 时被初始化为 0，以后每发生1个时钟节拍，OSTickCtr加1。</p><ul><li>OSTimeSet()允许用户改变当前时钟节拍计数器的值</li><li>OSTimeGet()用来获取动迁时钟节拍计数器的值</li></ul><h2 id="软件定时器"><a href="#软件定时器" class="headerlink" title="软件定时器"></a>软件定时器</h2><p>​定时器本质是递减计数器，当计数器减到零时可以执行回调函数。应用程序可以有任意数量的定时器，UCOSIII中定时器的时间分辨率由一个宏 <strong>OS_CFG_TMR_TASK_RATE_HZ</strong> 确定，单位为HZ，默认为100Hz。</p><ul><li>避免在回调函数使用   <strong>阻塞</strong>，<strong>删除</strong>   定时器任务的函数。</li></ul><h3 id="软件定时器的API"><a href="#软件定时器的API" class="headerlink" title="软件定时器的API"></a>软件定时器的API</h3><table><thead><tr><th><strong>OSTmrCreate()</strong></th><th><strong>创建定时器并制定运行模式</strong></th></tr></thead><tbody><tr><td>OSTmrDel()</td><td>删除定时器</td></tr><tr><td>OSTmrRemainGet()</td><td>获取定时器的剩余时间</td></tr><tr><td><strong>OSTmrStart()</strong></td><td><strong>启动定时器计数</strong></td></tr><tr><td>OSTmrStateGet()</td><td>获取当前定时器状态</td></tr><tr><td><strong>OSTmrStop()</strong></td><td><strong>停止计数器倒计时</strong></td></tr></tbody></table><p><strong>OSTmrCreate()有三种模式</strong></p><ul><li>单次模式（通过OSTmrStart()触发）</li><li>周期无延迟模式</li><li>周期有延迟模式</li></ul><h2 id="信号量、互斥信号量、内嵌信号量"><a href="#信号量、互斥信号量、内嵌信号量" class="headerlink" title="信号量、互斥信号量、内嵌信号量"></a>信号量、互斥信号量、内嵌信号量</h2><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量像是一种上锁机制，代码必须获得对应的钥匙才能继续执行，一旦获得了钥匙，也就意味着该任务具有进入被锁部分代码的权限。一旦执行至被锁代码段，则任务一直等待，直到对应被锁部分代码的钥匙被再次释放才能继续执行。</p><ul><li>信号量用于控制对共享资源的保护，但是现在基本用来做任务同步用。</li></ul><h4 id="信号量API"><a href="#信号量API" class="headerlink" title="信号量API"></a>信号量API</h4><table><thead><tr><th>OSSemCreate()</th><th>建立一个信号量</th></tr></thead><tbody><tr><td>OSSemDel()</td><td>删除一个信号量</td></tr><tr><td><strong>OSSemPend()</strong></td><td><strong>等待一个信号量</strong></td></tr><tr><td>OSSemPendAbrot()</td><td>取消等待</td></tr><tr><td><strong>OSSemPost()</strong></td><td><strong>释放或者发出一个信号量</strong></td></tr><tr><td>OSSemSet()</td><td>强制设置一个信号量的值</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>  <span class="hljs-title function_">OSSemCreate</span> <span class="hljs-params">(OS_SEM      *p_sem,<span class="hljs-comment">//OS_SEMMY_SEM;定义一个信号量，用于访问共享资源</span></span><br><span class="hljs-params">                   CPU_CHAR    *p_name,<span class="hljs-comment">//&quot;MY_SEM&quot;名称</span></span><br><span class="hljs-params">                   OS_SEM_CTR   cnt,<span class="hljs-comment">//如果设置成计数型信号量 此处设置成对应数字即可   如果设置成二进制信号量   此处设置成0即可</span></span><br><span class="hljs-params">                   OS_ERR      *p_err)</span><span class="hljs-comment">//</span><br>    <br><span class="hljs-title function_">OSSemCreate</span> <span class="hljs-params">((OS_SEM*)&amp;MY_SEM,</span><br><span class="hljs-params">             (CPU_CHAR*)<span class="hljs-string">&quot;MY_SEM&quot;</span>,</span><br><span class="hljs-params">             (OS_SEM_CTR)<span class="hljs-number">1</span>,</span><br><span class="hljs-params">             (OS_ERR*)&amp;err)</span>;<br></code></pre></td></tr></table></figure><ul><li>OS_SEM_CTR   cnt,<ul><li>如果设置成计数型信号量   此处设置成对应数字即可   </li><li>如果设置成二进制信号量   此处设置成0，指示事件的发生（同步）</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">OS_SEM_CTR  <span class="hljs-title function_">OSSemPend</span> <span class="hljs-params">(OS_SEM   *p_sem,</span><br><span class="hljs-params">                       OS_TICK   timeout,</span><br><span class="hljs-params">                       OS_OPT    opt,</span><br><span class="hljs-params">                       CPU_TS   *p_ts,</span><br><span class="hljs-params">                       OS_ERR   *p_err)</span><br><br><span class="hljs-title function_">OSSemPend</span><span class="hljs-params">(&amp;MY_SEM,<span class="hljs-number">0</span>,OS_OPT_PEND_BLOCKING,<span class="hljs-number">0</span>,&amp;err)</span>; <span class="hljs-comment">//请求信号量</span><br></code></pre></td></tr></table></figure><ul><li>OS_OPT    opt,<ul><li>OS_OPT_PEND_BLOCKING —————-&gt;  阻塞式</li><li>OS_OPT_PEND_NON_BLOCKING ——-&gt; 非阻塞式</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">OS_SEM_CTR  <span class="hljs-title function_">OSSemPost</span> <span class="hljs-params">(OS_SEM  *p_sem,</span><br><span class="hljs-params">                       OS_OPT   opt,</span><br><span class="hljs-params">                       OS_ERR  *p_err)</span><br>    <br><span class="hljs-title function_">OSSemPost</span> <span class="hljs-params">(&amp;MY_SEM,OS_OPT_POST_1,&amp;err)</span>;<span class="hljs-comment">//发送 释放 信号量</span><br></code></pre></td></tr></table></figure><ul><li>OS_OPT    opt，<ul><li>OS_OPT_POST_1 —–&gt;只使能等待信号量的最高优先级任务   (如果任务正在等待)。</li><li>OS_OPT_POST_ALL  ——&gt;发送到所有等待信号量的任务</li><li>OS_OPT_POST_NO_SCHED  ———&gt;不调用调度程序  可以与其他选项之一一起添加。</li></ul></li></ul><h3 id="互斥信号量"><a href="#互斥信号量" class="headerlink" title="互斥信号量"></a>互斥信号量</h3><h4 id="互斥信号量API"><a href="#互斥信号量API" class="headerlink" title="互斥信号量API"></a>互斥信号量API</h4><table><thead><tr><th>OSMutexCreate()</th><th>建立一个互斥信号量</th></tr></thead><tbody><tr><td>OSMutexDel()</td><td>删除一个互斥信号量</td></tr><tr><td><strong>OSMutexPend()</strong></td><td><strong>等待一个互斥信号量</strong></td></tr><tr><td>OSMutexPendAbrot()</td><td>取消等待</td></tr><tr><td><strong>OSMutexPost()</strong></td><td><strong>释放或者发布一个互斥信号量</strong></td></tr></tbody></table><h3 id="内嵌信号量"><a href="#内嵌信号量" class="headerlink" title="内嵌信号量"></a>内嵌信号量</h3><table><thead><tr><th>OSTaskSemPend()</th><th>等待一个任务信号量</th></tr></thead><tbody><tr><td>OSTaskSemPendAbort()</td><td>取消等待任务信号量</td></tr><tr><td><strong>OSTaskSemPost()</strong></td><td><strong>发布任务信号量</strong></td></tr><tr><td>OSTaskSemSet()</td><td>强行设置任务信号量计数</td></tr></tbody></table><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><h3 id="消息队列-1"><a href="#消息队列-1" class="headerlink" title="消息队列"></a>消息队列</h3><table><thead><tr><th><strong>函数名</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><strong>OSQCreate()</strong></td><td><strong>创建一个消息   队列</strong></td></tr><tr><td>OSQDel()</td><td>删除一个消息队列</td></tr><tr><td>OSQFlush()</td><td>清空消息队列</td></tr><tr><td><strong>OSQPend()</strong></td><td><strong>等待消息</strong></td></tr><tr><td>OSQPendAbort()</td><td>取消等待消息</td></tr><tr><td><strong>OSQPost()</strong></td><td><strong>向消息队列发布一则消息</strong></td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>  <span class="hljs-title function_">OSQCreate</span> <span class="hljs-params">(OS_Q        *p_q,</span><br><span class="hljs-params">                 CPU_CHAR    *p_name,</span><br><span class="hljs-params">                 OS_MSG_QTY   max_qty,</span><br><span class="hljs-params">                 OS_ERR      *p_err)</span><br>    <br><span class="hljs-title function_">OSQCreate</span> <span class="hljs-params">((OS_Q*)&amp;KEY_Msg,<span class="hljs-comment">//消息队列</span></span><br><span class="hljs-params">           (CPU_CHAR*)<span class="hljs-string">&quot;KEY Msg&quot;</span>,<span class="hljs-comment">//消息队列名称</span></span><br><span class="hljs-params">           (OS_MSG_QTY)KEYMSG_Q_NUM,<span class="hljs-comment">//消息队列长度，这里设置为1</span></span><br><span class="hljs-params">           (OS_ERR*)&amp;err)</span>;<span class="hljs-comment">//错误码</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//发送消息</span><br>OSQPost((OS_Q*)&amp;DATA_Msg,<br>        (<span class="hljs-type">void</span>*)pbuf,<br>        (OS_MSG_SIZE)<span class="hljs-number">10</span>,<br>        (OS_OPT)OS_OPT_POST_FIFO,<br>        (OS_ERR*)&amp;err);<br><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//请求消息</span><br>p=OSQPend((OS_Q*)&amp;DATA_Msg,   <br>          (OS_TICK)<span class="hljs-number">0</span>,<br>          (OS_OPT)OS_OPT_PEND_BLOCKING,<br>          (OS_MSG_SIZE*)&amp;size,<br>          (CPU_TS*)<span class="hljs-number">0</span>,<br>          (OS_ERR*)&amp;err);<br></code></pre></td></tr></table></figure><h3 id="任务内建消息队列"><a href="#任务内建消息队列" class="headerlink" title="任务内建消息队列"></a>任务内建消息队列</h3><table><thead><tr><th><strong>函数名</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><strong>OSTaskQPend()</strong></td><td><strong>等待消息</strong></td></tr><tr><td>OSTaskQPendAbort()</td><td>取消等待消息</td></tr><tr><td><strong>OSTaskQPost()</strong></td><td><strong>向任务发布一则消息</strong></td></tr><tr><td>OSTaskQFlush()</td><td>清空任务的消息队列</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//创建MSGDIS任务</span><br>OSTaskCreate((OS_TCB * )&amp;Msgdis_TaskTCB,<br>             (CPU_CHAR* )<span class="hljs-string">&quot;Msgdis task&quot;</span>, <br>             (OS_TASK_PTR )msgdis_task, <br>             (<span class="hljs-type">void</span>* )<span class="hljs-number">0</span>,<br>             (OS_PRIO  )MSGDIS_TASK_PRIO,     <br>             (CPU_STK   * )&amp;MSGDIS_TASK_STK[<span class="hljs-number">0</span>],<br>             (CPU_STK_SIZE)MSGDIS_STK_SIZE/<span class="hljs-number">10</span>,<br>             (CPU_STK_SIZE)MSGDIS_STK_SIZE,<br>             (OS_MSG_QTY  )TASK_Q_NUM,<span class="hljs-comment">//任务Msgdis_task需要使用内建消息队列，消息队列长度为4</span><br>             (OS_TICK  )<span class="hljs-number">0</span>,  <br>             (<span class="hljs-type">void</span>   * )<span class="hljs-number">0</span>,<br>             (OS_OPT      )OS_OPT_TASK_STK_CHK|OS_OPT_TASK_STK_CLR,<br>             (OS_ERR * )&amp;err);<br><br></code></pre></td></tr></table></figure><ul><li>注意看 OS_MSG_QTY 正常时其设置为0  使用内建消息队列将之设置成对应的数量即可</li></ul><h2 id="事件标志组"><a href="#事件标志组" class="headerlink" title="事件标志组"></a>事件标志组</h2><p>​       在UCOSIII中事件标志组为OS_FLAG_GRP，如果需要使用事件标志组的时候需要将宏OS_CFG_FLAG_EN置1，</p><table><thead><tr><th><strong>函数名</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><strong>OSFlagCreate()</strong></td><td><strong>创建事件标志组</strong></td></tr><tr><td>OSFlagDel()</td><td>删除事件标志组</td></tr><tr><td><strong>OSFlagPend()</strong></td><td><strong>等待事件标志组</strong></td></tr><tr><td>OSFlagPendAbort()</td><td>取消等待事件标志</td></tr><tr><td>OSFlagPendGetFlagsRdy()</td><td>获取使任务就绪的事件标志</td></tr><tr><td><strong>OSFlagPost()</strong></td><td><strong>向事件标志组发布标志</strong></td></tr></tbody></table><h2 id="同时等待多个内核对象"><a href="#同时等待多个内核对象" class="headerlink" title="同时等待多个内核对象"></a>同时等待多个内核对象</h2><p>​在UCOSIII中允许任务同时等待多个<strong>信号量</strong>和多个<strong>消息队列</strong>，也就是说，UCOSIII不支持同时等待多个事件标志组或互斥信号量。</p><p>​    一个任务可以等待任意数量的信号量和消息队列，第一个信号量或消息队列的发布会导致该任务进入就绪态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">OS_OBJ_QTY  <span class="hljs-title function_">OSPendMulti</span> <span class="hljs-params">(OS_PEND_DATA  *p_pend_data_tbl,</span><br><span class="hljs-params">                         OS_OBJ_QTY     tbl_size,</span><br><span class="hljs-params">                         OS_TICK        timeout,</span><br><span class="hljs-params">                         OS_OPT         opt,</span><br><span class="hljs-params">                         OS_ERR        *p_err)</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">OS_SEMTest_Sem1;<span class="hljs-comment">//信号量1</span><br>OS_SEMTest_Sem2;<span class="hljs-comment">//信号量2</span><br>OS_QTest_Q;<span class="hljs-comment">//消息队列</span><br><br>OS_PEND_DATA pend_multi_tbl[CORE_OBJ_NUM];<br><br>pend_multi_tbl[<span class="hljs-number">0</span>].PendObjPtr=(OS_PEND_OBJ*)&amp;Test_Sem1;<br>pend_multi_tbl[<span class="hljs-number">1</span>].PendObjPtr=(OS_PEND_OBJ*)&amp;Test_Sem2;<br>pend_multi_tbl[<span class="hljs-number">2</span>].PendObjPtr=(OS_PEND_OBJ*)&amp;Test_Q;<br></code></pre></td></tr></table></figure><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2>]]></content>
    
    
    <categories>
      
      <category>RTOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rtos</tag>
      
      <tag>ucos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Modbus</title>
    <link href="/2020/7d358aa2/"/>
    <url>/2020/7d358aa2/</url>
    
    <content type="html"><![CDATA[<h1 id="Modbus"><a href="#Modbus" class="headerlink" title="Modbus"></a>Modbus</h1><p><a href="https://wenku.baidu.com/view/ef2f8bfe81eb6294dd88d0d233d4b14e85243e3a.html">百度文库 MODBUS协议最简单又是最直白的解释</a></p><ul><li><p>分为RTU（发Hex）模式和ASCII（发字符）模式</p></li><li><p>从机地址 0-247 （其中0为广播地址）</p></li><li><p>通信格式</p></li><li><p><strong>ASCII</strong></p><p>起始符+<strong>设备地址(1Byte)+功能码(1Byte)+数据(nByte n&lt;253)+校验(2Byte LRC)</strong>+结束符</p><ul><li>起始符——ASCII的起始符为‘:’一个冒号</li><li>设备地址——0-247</li><li>功能码——见下文</li><li>数据——略</li><li>校验——<strong>起始符 和 校验符</strong>  之间的所有数据        一般用LRC校验</li><li>结束符——Chr$（13）+Chr（10）</li><li>例—— : (起)    02(地址) 03(功能) 0a00(数据) 0004(校验)    Chr$(13)Chr(10)(终)</li><li>设备地址、功能码、数据、校验 都是用的十六进制的字符形式 例如发送0x16就发送“16”</li></ul></li><li><p><strong>RTU</strong></p><p>起始符+<strong>设备地址(1Byte)+功能码(1Byte)+数据(nByte n&lt;253)+校验(2Byte CRC16)</strong>+结束符</p><ul><li>起始符——3.5个字符的时间间隔</li><li>设备地址——0-247</li><li>功能码——见下文</li><li>数据——略</li><li>校验——<strong>起始符 和 校验符</strong>  之间的所有数据        一般用CRC16校验</li><li>结束符——3.5个字符的时间间隔</li></ul></li></ul><h1 id="功能表"><a href="#功能表" class="headerlink" title="功能表"></a>功能表</h1><table><thead><tr><th align="center">功能码</th><th>名称</th><th>作用</th></tr></thead><tbody><tr><td align="center">1</td><td>读取线圈状态</td><td>取得一组逻辑线圈的当前状态（ON&#x2F;OFF)</td></tr><tr><td align="center">2</td><td>读取输入状态</td><td>取得一组开关输入的当前状态（ON&#x2F;OFF)</td></tr><tr><td align="center">3</td><td>读取保持寄存器</td><td>在一个或多个保持寄存器中取得当前的二进制值</td></tr><tr><td align="center">4</td><td>读取输入寄存器</td><td>在一个或多个输入寄存器中取得当前的二进制值</td></tr><tr><td align="center">5</td><td>强置单线圈</td><td>强置一个逻辑线圈的通断状态</td></tr><tr><td align="center">6</td><td>预置单寄存器</td><td>把具体二进值装入一个保持寄存器</td></tr><tr><td align="center">7</td><td>读取异常状态</td><td>取得8个内部线圈的通断状态，这8个线圈的地址由控制器决定</td></tr><tr><td align="center">8</td><td>回送诊断校验</td><td>把诊断校验报文送从机，以对通信处理进行评鉴</td></tr><tr><td align="center">9</td><td>编程（只用于484）</td><td>使主机模拟编程器作用，修改PC从机逻辑</td></tr><tr><td align="center">10</td><td>控询（只用于484）</td><td>可使主机与一台正在执行长程序任务从机通信，探询该从机是否已完成其操作任务，仅在含有功能码9的报文发送后，本功能码才发送</td></tr><tr><td align="center">11</td><td>读取事件计数</td><td>可使主机发出单询问，并随即判定操作是否成功，尤其是该命令或其他应答产生通信错误时</td></tr><tr><td align="center">12</td><td>读取通信事件记录</td><td>可是主机检索每台从机的ModBus事务处理通信事件记录。如果某项事务处理完成，记录会给出有关错误</td></tr><tr><td align="center">13</td><td>编程（184&#x2F;384 484 584）</td><td>可使主机模拟编程器功能修改PC从机逻辑</td></tr><tr><td align="center">14</td><td>探询（184&#x2F;384 484 584）</td><td>可使主机与正在执行任务的从机通信，定期控询该从机是否已完成其程序操作，仅在含有功能13的报文发送后，本功能码才得发送</td></tr><tr><td align="center">15</td><td>强置多线圈</td><td>强置一串连续逻辑线圈的通断</td></tr><tr><td align="center">16</td><td>预置多寄存器</td><td>把具体的二进制值装入一串连续的保持寄存器</td></tr><tr><td align="center">17</td><td>报告从机标识</td><td>可使主机判断编址从机的类型及该从机运行指示灯的状态</td></tr><tr><td align="center">18</td><td>（884和MICRO 84）</td><td>可使主机模拟编程功能，修改PC状态逻辑</td></tr><tr><td align="center">19</td><td>重置通信链路</td><td>发生非可修改错误后，是从机复位于已知状态，可重置顺序字节</td></tr><tr><td align="center">20</td><td>读取通用参数（584L）</td><td>显示扩展存储器文件中的数据信息</td></tr><tr><td align="center">21</td><td>写入通用参数（584L）</td><td>把通用参数写入扩展存储文件，或修改之</td></tr><tr><td align="center">22～64</td><td>保留作扩展功能备用</td><td></td></tr><tr><td align="center">65～72</td><td>保留以备用户功能所用</td><td>留作用户功能的扩展编码</td></tr><tr><td align="center">73～119</td><td>非法功能</td><td></td></tr><tr><td align="center">120～127</td><td>保留</td><td>留作内部作用</td></tr><tr><td align="center">128～255</td><td>保留</td><td>用于异常应答</td></tr></tbody></table><h2 id="0x01-读取线圈状态（数字量）"><a href="#0x01-读取线圈状态（数字量）" class="headerlink" title="0x01 读取线圈状态（数字量）"></a>0x01 读取线圈状态（数字量）</h2><p><strong>0x01号命令，读取一个或多个    可读写数字量寄存器    （读取线圈状态）：</strong></p><table><thead><tr><th>设备地址+功能码</th><th>起始地址高八位+低八位</th><th>读取寄存器数量高八位+低八位</th><th>CRC16</th></tr></thead><tbody><tr><td>0x11+0x01</td><td>0x00+0x13</td><td>0x00+0x25</td><td>高8+低8</td></tr></tbody></table><p><strong>意义如下：</strong></p><ol><li>设备地址与功能码：在一个485总线上可以挂接多个设备，此处的设备地址表示想和哪一个设备通讯。例子中为想和0x11通讯。读取数字量的命令号固定为0x01。</li><li>起始地址高8位、低8位：表示想读取的开关量的起始地址(起始地址为0)。比如例子中的起始地址为0x0013。</li><li>寄存器数高8位、低8位：表示从起始地址开始读多少个开关量。例子中为37(0x0025)个开关量。</li><li>CRC校验：是从开头一直校验到此之前。</li></ol><p><strong>设备响应</strong>：</p><table><thead><tr><th>设备地址+功能码</th><th>返回的字节个数</th><th>返回的数据1+数据2+….+数据n</th><th>CRC16</th></tr></thead><tbody><tr><td>0x11+0x01</td><td>0x05</td><td>0xcd+0x6b+0xb2+0x0e+0x1b</td><td>高8+低8</td></tr></tbody></table><p><strong>意义如下：</strong></p><ol><li><p>设备地址与功能码：上同，0x01。</p></li><li><p>返回的字节个数：表示数据的字节个数，也就是数据的n的值。</p></li><li><p>数据1…n：由于每一个数据是一个8位的数，所以每一个数据表示8个开关量的值，每一位为0表示对应的开关断开，为1表示闭合。</p><p><strong>如果询问的开关量不是8的整倍数，那么最后一个字节的高位部分无意义，置为0。</strong></p></li><li><p>CRC校验同上。</p></li></ol><h2 id="0x05强制单线圈（写一个开关数字量）"><a href="#0x05强制单线圈（写一个开关数字量）" class="headerlink" title="0x05强制单线圈（写一个开关数字量）"></a>0x05强制单线圈（写一个开关数字量）</h2><p><strong>0x05号命令，写一个数字量（强制单线圈） 可广播：</strong></p><table><thead><tr><th>设备地址+功能码</th><th>需操作的寄存器地址高8位+低8位</th><th>需操作的寄存器数据高8位+低8位</th><th>CRC16</th></tr></thead><tbody><tr><td>0x11+0x05</td><td>0x00+0xac</td><td>0xff+0x00</td><td>高8+低8</td></tr></tbody></table><p><strong>意义如下：</strong></p><ol><li><p>设备地址与功能码：上同，0x05。</p></li><li><p>需下置的寄存器地址高8位，低8位：表明了需要置位（操作）的开关的地址。</p></li><li><p>置位（操作）的数据高8位，低8位：表明需要置位的开关量的状态。例子中为把该开关闭合。</p><p><strong>注意，此处只可以是[FF][00]表示ON状态 闭合      [00][00]表示OFF状态 断开，其他数值非法。</strong></p></li><li><p>注意此命令一条只能下置一个开关量的状态。</p></li></ol><p><strong>设备响应：</strong></p><ol><li>如果成功把计算机发送的命令原样返回，否则不响应。</li></ol><h2 id="0x03读取保持寄存器（模拟量）"><a href="#0x03读取保持寄存器（模拟量）" class="headerlink" title="0x03读取保持寄存器（模拟量）"></a>0x03读取保持寄存器（模拟量）</h2><p><strong>0x03号命令，读可读写模拟量寄存器（保持寄存器）：</strong></p><table><thead><tr><th>设备地址+功能码</th><th>起始寄存器地址高8位+低8位</th><th>读取的寄存器数量高8位+低8位</th><th>CRC16</th></tr></thead><tbody><tr><td>0x11+0x03</td><td>0x00+0x6b</td><td>0x00+0x03</td><td>高8+低8</td></tr></tbody></table><p><strong>意义如下：</strong></p><ol><li>设备地址与功能码：上同，0x03。</li><li>起始地址高8位、低8位：表示想读取的模拟量的起始地址(起始地址为0)。比如例子中的起始地址为0x006b。</li><li>寄存器数高8位、低8位：表示从起始地址开始读多少个模拟量。例子中为3个模拟量。注意，在返回的信息中一个模拟量需要返回两个字节。</li></ol><p><strong>设备响应：</strong></p><table><thead><tr><th>设备地址+功能码</th><th>返回的字节个数</th><th>返回的数据1+数据2+….+数据n</th><th>CRC16</th></tr></thead><tbody><tr><td>0x11+0x03</td><td>0x06</td><td>0x02+0x2b+0x00+0x00+0x00+0x64</td><td>高8+低8</td></tr></tbody></table><p><strong>意义如下：</strong></p><ol><li>设备地址与功能码：上同，0x03。</li><li>返回的字节个数：表示数据的字节个数，也就是数据1，2…n中的n的值。例子中返回了3个模拟量的数据，因为一个模拟量需要2个字节所以共6个字节。</li><li>数据1…n：[数据1][数据2]分别是第1个模拟量的高8位和低8位，[数据3][数据4]是第2个模拟量的高8位和低8位，以此类推。例子中返回的值分别是555，0，100。</li></ol><h2 id="0x06预置单寄存器（写一个模拟量）"><a href="#0x06预置单寄存器（写一个模拟量）" class="headerlink" title="0x06预置单寄存器（写一个模拟量）"></a>0x06预置单寄存器（写一个模拟量）</h2><p><strong>0x06号命令，写单个模拟量寄存器（保持寄存器）：</strong></p><table><thead><tr><th>设备地址+功能码</th><th>需操作的寄存器地址高8位+低8位</th><th>需操作的寄存器数据高8位+低8位</th><th>CRC16</th></tr></thead><tbody><tr><td>0x11+0x06</td><td>0x00+0x01</td><td>0x00+0x03</td><td>高8+低8</td></tr></tbody></table><p><strong>意义如下：</strong></p><ol><li>设备地址与功能码：上同，0x06。</li><li>需下置的寄存器地址高8位，低8位：表明了需要下置的模拟量寄存器的地址。</li><li>下置的数据高8位，低8位：表明需要下置的模拟量数据。比如例子中就把1号寄存器的值设为3。</li><li>注意此命令一条只能下置一个模拟量的状态。</li></ol><p><strong>设备响应：</strong></p><p>如果成功把计算机发送的命令原样返回，否则不响应。</p><h2 id="0x16-预置多寄存器（写多个模拟量）"><a href="#0x16-预置多寄存器（写多个模拟量）" class="headerlink" title="0x16 预置多寄存器（写多个模拟量）"></a>0x16 预置多寄存器（写多个模拟量）</h2><p><strong>0x16号命令，写多个模拟量寄存器（保持寄存器）：</strong></p><table><thead><tr><th>设备地址+功能码</th><th>需操作的地址高8位+低8位</th><th>需操作数据的数量高8位+低8位</th><th>操作的数据1 高8位+低8位</th></tr></thead><tbody><tr><td>0x11+0x16</td><td>0x00+0x01</td><td>0x00+0x01</td><td>0x00+0x05</td></tr><tr><td>操作的数据2 高8位+低8位</td><td>………</td><td>操作的数据n 高8位+低8位</td><td>CRC16</td></tr><tr><td></td><td></td><td></td><td>高8+低8</td></tr></tbody></table><p><strong>意义如下：</strong></p><ol><li>设备地址与功能码：上同，0x16。</li><li>需下置的寄存器地址高8位，低8位：表明了需要下置的模拟量寄存器的地址。</li><li>需下置的数据数量高8位，低8位：表明了需要下置的数据数量，这里为1。</li><li>下置的数据高8位，低8位：表明需要下置的模拟量数据。比如例子中就把1号寄存器的值设为5。</li></ol><p><strong>设备响应：</strong></p><p>如果成功把计算机返回的如下命令，否则不响应。</p><table><thead><tr><th>设备地址+功能码</th><th>需操作的寄存器地址高8位+低8位</th><th>需操作的寄存器数量高8位+低8位</th><th>CRC16</th></tr></thead><tbody><tr><td>0x11+0x16</td><td>0x00+0x01</td><td>0x00+0x01</td><td>高8+低8</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Communication</category>
      
    </categories>
    
    
    <tags>
      
      <tag>embedded</tag>
      
      <tag>modbus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MarkDown学习笔记</title>
    <link href="/2020/da7ed36c/"/>
    <url>/2020/da7ed36c/</url>
    
    <content type="html"><![CDATA[<blockquote><p>  参考官方的示例</p><p>  <a href="https://www.markdownguide.org/basic-syntax/">https://www.markdownguide.org/basic-syntax/</a></p></blockquote><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><p>asdasdasdasdassdasdas</p><h2 id="这是一段引用"><a href="#这是一段引用" class="headerlink" title="这是一段引用"></a>这是一段引用</h2><blockquote><p>这是一段引用</p></blockquote><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>* + 都可以作为无序列表的前缀，但是需要注意不要把他们混用。<br>建议使用 - 作为无序列表前缀。<br></code></pre></td></tr></table></figure><ul><li>阿斯大声</li><li>阿斯大声打</li><li>阿斯大声问请问恶</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> 阿斯大声<br><span class="hljs-bullet">-</span> 阿斯大声打<br><span class="hljs-bullet">-</span> 阿斯大声问请问恶<br></code></pre></td></tr></table></figure><ul><li>阿斯大声</li><li>阿斯大声打</li><li>阿斯大声问请问恶</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> 阿斯大声<br><span class="hljs-bullet">*</span> 阿斯大声打<br><span class="hljs-bullet">*</span> 阿斯大声问请问恶<br></code></pre></td></tr></table></figure><h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><ol><li><p>阿斯大声打</p></li><li><p>阿斯大声阿斯大声</p></li><li><p>dasd阿斯dasdaaa</p></li></ol><h2 id="斜体-加粗-强调"><a href="#斜体-加粗-强调" class="headerlink" title="斜体  加粗 (强调)"></a>斜体  加粗 (强调)</h2><p>这是<em>斜体</em>      这是<strong>加粗</strong>   这是_什么呢_  好像也__是一样的__</p><h2 id="这段是横线"><a href="#这段是横线" class="headerlink" title="这段是横线"></a>这段是横线</h2><hr><hr><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p><a href="./assets/00.jpg">这是超链接</a></p><p><a href=".%5Cassets%5C00.jpg">www.Baidu.com</a></p><p><a href="https://sigrok.org/wiki/Protocol_decoder_API">这是一个超链接 （注意链接前后不要留空格）</a></p><p>This is <a href="http://example.com/" title="Optional Title Here">an example</a> reference-style link.</p><h2 id="文章内的超链接"><a href="#文章内的超链接" class="headerlink" title="文章内的超链接"></a><a id="文章内的超链接">文章内的超链接</a></h2><p> <a href="##%E8%A1%A8%E6%A0%BC">这是一个文章内部的超链接</a> </p><p> Ctrl+左键  </p><p><a href="#HTML跳转">回到-&gt;HTML 跳转</a> </p><h2 id="Email-链接"><a href="#Email-链接" class="headerlink" title="Email 链接"></a>Email 链接</h2><p>作者的 Emal <a href="mailto:&#120;&#x78;&#x40;&#x78;&#x78;&#46;&#x63;&#111;&#x6d;">&#120;&#x78;&#x40;&#x78;&#x78;&#46;&#x63;&#111;&#x6d;</a> 链接</p><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><ul><li>内联风格</li></ul><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1557132849466&di=61258032fff80f7d4bfff0ad0b325b12&imgtype=0&src=http://s6.sinaimg.cn/middle/6dca756dhad5c3293f515&690" alt="iPhone"></p><ul><li>引用风格</li></ul><p><strong>一直没弄出来</strong></p><p>xxx<img src="/photo_id" alt="photo_id"></p><h2 id="代码块-与-代码行"><a href="#代码块-与-代码行" class="headerlink" title="代码块 与 代码行"></a>代码块 与 代码行</h2><p><code>  delay_init();     //延时函数初始化</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>delay_init();     <span class="hljs-comment">//延时函数初始化</span><br>TIM_ALL_Init();<br> LED_Init();     <span class="hljs-comment">//LED端口初始化</span><br>LCD_Init();<br>POINT_COLOR=WHITE;<br>BACK_COLOR = BLACK;<br>LCD_Clear(BLACK);<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><table><thead><tr><th>name</th><th>age</th><th>sex</th></tr></thead><tbody><tr><td>Done</td><td>20</td><td>0</td></tr><tr><td>Jack</td><td>21</td><td>0</td></tr><tr><td>Done<br/>这里换行了</td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><p><del>这是一条删除             线线线线线线线线线线线线线线线</del></p><h2 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h2><p><u>xiahuaxian</u></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">u</span>&gt;</span></span>xiahuaxian<span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">u</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="这是一个注释"><a href="#这是一个注释" class="headerlink" title="这是一个注释"></a>这是一个注释</h2><p>[注释] <a href="%E8%BF%99%E6%98%AF%E6%B3%A8%E9%87%8A%E7%9A%84%E8%A7%A3%E9%87%8A">^注释</a>:Somebody that I used to know.</p><h2 id="数学表达式"><a href="#数学表达式" class="headerlink" title="数学表达式"></a>数学表达式</h2><p>$ (h&#x2F;2)<em>(a+9)&#x2F;(b</em>9))*L $</p><p>$lim_{x \to \infty} \ exp(-x)&#x3D;0$</p><h2 id="修改文字颜色-HTLML"><a href="#修改文字颜色-HTLML" class="headerlink" title="修改文字颜色 HTLML"></a>修改文字颜色 HTLML</h2><p>You can use HTML to style content what pure Markdown does not support.</p><p><span style="color:red"><strong>TEXT Style</strong></span></p><p><span style="color:#29b6f6"> <strong>TEXT Style</strong> </span></p><p><span style="color:rgb(255, 255, 255)"><strong>TEXT Style</strong></span></p><p><span style="color:LightPink"> <strong>TEXT Style</strong> </span></p><p><span style="color:Thistle"> <strong>TEXT Style</strong> </span></p><p><span style="color:Gold"> <strong>TEXT Style</strong> </span></p><p><span style="color:Tomato"> <strong>TEXT Style</strong> </span></p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:red&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:#29b6f6&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:rgb(255, 255, 255)&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><br>https://www.5tu.cn/colors/yansezhongwenming.html<br></code></pre></td></tr></table></figure><p>For example, use <code>&lt;span style=&quot;color:red&quot;&gt;this text is red&lt;/span&gt;</code> to add text with red color.</p><h2 id="表情-Emoji-smile"><a href="#表情-Emoji-smile" class="headerlink" title="表情 Emoji :smile:"></a>表情 Emoji :smile:</h2><p>Input emoji with syntax <code>:smile:</code>.</p><p>User can trigger auto-complete suggestions for emoji by pressing <code>ESC</code> key, or trigger it automatically after enabling it on preference panel. Also, inputting UTF-8 emoji characters directly is also supported by going to <code>Edit</code> -&gt; <code>Emoji &amp; Symbols</code> in the menu bar (macOS).</p><h2 id="Task-List-带勾的计划任务-勾选框"><a href="#Task-List-带勾的计划任务-勾选框" class="headerlink" title="Task List 带勾的计划任务 勾选框"></a>Task List 带勾的计划任务 勾选框</h2><ul><li><input disabled="" type="checkbox"> a task list item</li><li><input disabled="" type="checkbox"> list syntax required </li><li><input checked="" disabled="" type="checkbox"> completed</li></ul><p>注意    [内有一个空格] </p><h2 id="Video"><a href="#Video" class="headerlink" title="Video"></a>Video</h2><p>You can use the <code>&lt;video&gt;</code> HTML tag to embed videos. For example:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Markdown"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;xxx.mp4&quot;</span> /&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">文字[^脚注1]文字.<br>[<span class="hljs-symbol">^脚注1</span>]:<span class="hljs-link">这是脚注1的内容</span><br></code></pre></td></tr></table></figure><p>文字<a href="%E8%BF%99%E6%98%AF%E8%84%9A%E6%B3%A81%E7%9A%84%E5%86%85%E5%AE%B9">^脚注1</a>文字.</p><h2 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h2><p><strong>1.实现下标与上标的三种方法：</strong></p><ul><li><p>方法1（符号）：(这是Markdown的拓展语法)</p><figure class="highlight parser3"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs parser3"><span class="language-xml">下标 ：θ~</span><span class="hljs-number">1</span><span class="language-xml">~ </span><br><span class="language-xml">上标 ：θ</span><span class="hljs-keyword">^2</span><span class="language-xml">^</span><br><span class="language-xml"></span><span class="hljs-number">12</span><br></code></pre></td></tr></table></figure></li><li><p>结果如下：<br>下标 ：θ<del>1</del><br>上标 ：θ^2^</p></li><li><p>方法2（HTML标签）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml">下标 ：θ<span class="hljs-tag">&lt;<span class="hljs-name">sub</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">sub</span>&gt;</span><br>上标 ：θ<span class="hljs-tag">&lt;<span class="hljs-name">sup</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">sup</span>&gt;</span><br>12<br></code></pre></td></tr></table></figure></li><li><p>结果如下：<br>下标 ：θ<sub>1</sub><br>上标 ：θ<sup>2</sup></p></li><li><p>方法3（公式块）：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br>下标 ：θ_1 ，上标 ：θ^<span class="hljs-number">2</span><br><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure></li><li><p>结果如下：</p></li><li><p>$$<br>下标 ：θ_1 ，上标 ：θ^2<br>$$</p></li></ul><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><h2 id="HTML-跳转"><a href="#HTML-跳转" class="headerlink" title="HTML 跳转"></a><a id="HTML跳转">HTML 跳转</a></h2><p><a href="#文章内的超链接">点击到达-&gt;文章内的超链接</a> </p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">&lt;<span class="hljs-keyword">a</span> href=<span class="hljs-string">&quot;#demo&quot;</span>&gt;点击到达跳转位置演示&lt;/<span class="hljs-keyword">a</span>&gt; <span class="hljs-comment"># 在需要跳转的地方添加此代码。</span><br>&lt;<span class="hljs-keyword">a</span> id=<span class="hljs-string">&quot;demo&quot;</span>&gt;跳转位置演示（跳转位置设置点）&lt;/<span class="hljs-keyword">a</span>&gt; <span class="hljs-comment"># 在跳转位置添加次代码。</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>markdown</tag>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OSI</title>
    <link href="/2020/1a11e44c/"/>
    <url>/2020/1a11e44c/</url>
    
    <content type="html"><![CDATA[<h1 id="OSI"><a href="#OSI" class="headerlink" title="OSI"></a>OSI</h1><p>开放系统互联参考模型(Open System Interconnection Reference Model)，即我们通常所说的网络互联的七层框架，它是国际标准组织(International Organization for Standization)于1977年提出的标准，又称为ISO&#x2F;IEC 7498或X.200建议。值得注意的是，OSI并没有提供一个可以实现的方法，它不是一个标准而只是一个制定标准时使用的<strong>概念性的框架</strong>，更不是一个网络协议。</p><ol><li>物理层(Physical Layer)：主要功能为定义了网络的物理结构，传输的电磁标准，Bit流的编码及网络的时间原则，如分时复用及分频复用。决定了网络连接类型(端到端或多端连接)及物理拓扑结构。说的通俗一些，这一层主要负责实际的<a href="https://product.pconline.com.cn/itbk/sjtx/sj/1203/2699254.html">信号</a>传输。</li><li>数据链路层(D<a href="https://product.pconline.com.cn/itbk/diy/mb/1107/2474080.html">ata</a> Link eview)：在两个主机上建立数据链路连接，向物理层传输数据信号，并对信号进行处理使之无差错并合理的传输</li><li>网络层(Network Layer)：主要负责路由，选择合适的路径，进行阻塞控制等功能。</li><li>传输层(Transfer Layer)：最关键的一层，向拥护提供可靠的端到端(End-to-End)服务，它屏蔽了下层的数据通信细节，让用户及应用程序不需要考虑实际的通信方法。</li><li>会话层(Session Layer)：主要负责两个会话进程之间的通信，即两个会话层实体之间的信息交换，管理数据的交换。</li><li>表示层(Presentation Layer)：处理通信信号的表示方法，进行不同的格式之间的翻译，并负责数据的加密解密，数据的压缩与恢复</li><li>应用层(Application Layer)：保持应用程序之间建立连接所需要的数据记录，为用户服务。 三大协议NetBEUI和 IPX&#x2F;SPX TCP&#x2F;IP</li></ol><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td></td><td></td><td></td></tr><tr><td>应用层(Application Layer)</td><td>消息</td><td></td></tr><tr><td>表示层(Presentation Layer)</td><td></td><td>编码解码(文件类型)，加密解密，压缩解压缩</td></tr><tr><td>会话层(Session Layer)</td><td></td><td>管理控制登录状态，实现同步服务</td></tr><tr><td>传输层(Transfer Layer)</td><td>数据段(segment)</td><td>段数据的生成，通过端口号定位进程，负责TCP&#x2F;UDP传输 QUIC<br>流量控制(确保传输速度)，错误控制(数据完整接收)<br></td></tr><tr><td>网络层(Network Layer)</td><td>分组、数据包（packet）</td><td>段数据封装成包，通过IP地址转发，核心是地址管理和路由管理，<br/>端到端传输<br><strong>由路由器</strong>实现端到端传输</td></tr><tr><td>链路层(Data Link eview)</td><td>帧（frame）</td><td>包封装成帧，通过MAC地址传输，指定数据的方向<br/>差错纠正，流控制<br/><strong>由二层交换机</strong>实现跳到跳传输</td></tr><tr><td>物理层(Physical Layer)</td><td>P-PDU（bit）</td><td>帧数据的比特流传输，通过不同的介质传输</td></tr></tbody></table><blockquote><p>  OSI七层模型和实际模型的对比。</p></blockquote><p><img src="/2020/1a11e44c/image-20230301230822078.png" alt="image-20230301230822078"></p><blockquote><p>  数据 段 包 帧 之间的关系。</p></blockquote><p><img src="/2020/1a11e44c/image-20230301231548203.png" alt="image-20230301231548203"></p><blockquote><p>  不同类型的归类方法。</p></blockquote><p><img src="/2020/1a11e44c/image-20230301233137428.png" alt="image-20230301233137428"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>【互联网数据传输原理 ｜OSI七层网络参考模型】 <a href="https://www.bilibili.com/video/BV1EU4y1v7ju/?share_source=copy_web&vd_source=d601b4c192e3ada70b5ef4d27f972720">https://www.bilibili.com/video/BV1EU4y1v7ju/?share_source=copy_web&amp;vd_source=d601b4c192e3ada70b5ef4d27f972720</a></p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>osi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>USART硬件流控制</title>
    <link href="/2020/3b631eba/"/>
    <url>/2020/3b631eba/</url>
    
    <content type="html"><![CDATA[<h1 id="USART硬件流控制"><a href="#USART硬件流控制" class="headerlink" title="USART硬件流控制"></a>USART硬件流控制</h1><p><img src="/2020/3b631eba/SouthEast.jpeg"></p><p>RS232 DB9定义</p><p>1 CD ← Carrier Detect 载波检测</p><p>2 RXD ← Receive Data 接收数据</p><p>3 TXD → Transmit Data 发送数据</p><p>4 <strong>DTR → Data Terminal Ready数据终端就绪</strong></p><p>5 GND — System Ground 系统接地</p><p>6 DSR ← Data Set Ready 数据设备就绪</p><p>7 <strong>RTS → Request To Send 请求发送</strong></p><p>8 CTS ← Clear To Send 清除发送(允许发送)</p><p>9 RI → 振铃指示</p><h2 id="RTS-CTS"><a href="#RTS-CTS" class="headerlink" title="RTS CTS"></a>RTS CTS</h2><ul><li>RTS （Require ToSend，发送请求）为输出信号，用于指示本设备准备好可接收数据，低电平有效，低电平说明本设备可以接收数据。</li><li>CTS （Clear ToSend，发送允许）为输入信号，用于判断是否可以向对方发送数据，低电平有效，低电平说明本设备可以向对方发送数据。</li></ul><h2 id="DTR-DSR"><a href="#DTR-DSR" class="headerlink" title="DTR DSR"></a>DTR DSR</h2>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>usart</tag>
      
      <tag>rts</tag>
      
      <tag>cts</tag>
      
      <tag>dtr</tag>
      
      <tag>dsr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>摄影</title>
    <link href="/2020/bda63754/"/>
    <url>/2020/bda63754/</url>
    
    <content type="html"><![CDATA[<p><img src="/2020/bda63754/1e3bb3da2c76d5c2ed546428edc1cd4e_720w.jpg" alt="1e3bb3da2c76d5c2ed546428edc1cd4e_720w"></p><p><img src="/2020/bda63754/%E8%89%B2%E7%8E%AF3.png" alt="色环3"></p><h1 id="调色"><a href="#调色" class="headerlink" title="调色"></a>调色</h1><h2 id="马卡龙糖果色"><a href="#马卡龙糖果色" class="headerlink" title="马卡龙糖果色"></a>马卡龙糖果色</h2><h3 id="形式"><a href="#形式" class="headerlink" title="形式"></a>形式</h3><p>高明度、低对比、高饱和、高明度</p><ul><li><p>暖色—橙色、黄色、粉色</p></li><li><p>冷色—绿色、蓝色、青色、建议青蓝色为主色调</p></li></ul><h3 id="适合场景"><a href="#适合场景" class="headerlink" title="适合场景"></a>适合场景</h3><ul><li>建议晴天的白天、避免大光比、复杂的色彩组成、</li><li>建议有蓝色元素(天空)、橙色黄色粉色等暖色系元素、</li></ul><h2 id="青橙色调色"><a href="#青橙色调色" class="headerlink" title="青橙色调色"></a>青橙色调色</h2><h3 id="形式-1"><a href="#形式-1" class="headerlink" title="形式"></a>形式</h3><p>青色橙色作为主色调</p><p>拉高白色、降低黑色增强对比</p><ul><li>降低高光、提升阴影恢复细节</li><li>拉高白色、降低黑色增强对比</li></ul><h3 id="适合场景-1"><a href="#适合场景-1" class="headerlink" title="适合场景"></a>适合场景</h3><p>天空、大海等蓝色元素 和 肤色、灯光等的橙色元素。</p><p><img src="/2020/bda63754/%E9%9D%92%E6%A9%99%E6%A1%88%E4%BE%8B-1.jpg" alt="青橙案例-1"></p><h2 id="日系蓝黄色调"><a href="#日系蓝黄色调" class="headerlink" title="日系蓝黄色调"></a>日系蓝黄色调</h2><p>画面本身有蓝、黄橙绿元素、</p><p>白天的街景、建筑最佳</p><ul><li>降低对比度（降低高光和白色、提升阴影），操作后照片会偏灰，降低黑色压实影调</li><li>曲线压缩最亮部分（右顶点向下偏），使得白色更加柔和</li><li>主色调为蓝黄色及相邻色（），基本不含其他色</li></ul><p><img src="/2020/bda63754/%E6%97%A5%E7%B3%BB%E8%93%9D%E9%BB%84%E8%89%B2%E8%B0%83-Frank.jpg" alt="日系蓝黄色调-Frank"></p><h2 id="黑金色调"><a href="#黑金色调" class="headerlink" title="黑金色调"></a>黑金色调</h2>]]></content>
    
    
    <categories>
      
      <category>more_interest</category>
      
    </categories>
    
    
    <tags>
      
      <tag>摄影</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C</title>
    <link href="/2020/3dd7ffa7/"/>
    <url>/2020/3dd7ffa7/</url>
    
    <content type="html"><![CDATA[<h1 id="标准库函数"><a href="#标准库函数" class="headerlink" title="标准库函数"></a>标准库函数</h1><h2 id="fprintf-输出到流中"><a href="#fprintf-输出到流中" class="headerlink" title="fprintf 输出到流中"></a>fprintf 输出到流中</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>C 库函数 <strong>int fprintf(FILE *stream, const char *format, …)</strong> 发送格式化输出到流 stream 中。</p><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>下面是 fprintf() 函数的声明。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fprintf</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span><br></code></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。</li><li><strong>format</strong> – 这是 C 字符串，包含了要被写入到流 stream 中的文本。它可以包含嵌入的 format 标签，format 标签可被随后的附加参数中指定的值替换，并按需求进行格式化。format 标签属性是 <strong>%[flags][width][.precision][length]specifier</strong>，具体讲解如下：</li></ul><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>如果成功，则返回写入的字符总数，否则返回一个负数。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>下面的实例演示了 fprintf() 函数的用法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>   FILE * fp;<br><br>   fp = fopen (<span class="hljs-string">&quot;file.txt&quot;</span>, <span class="hljs-string">&quot;w+&quot;</span>);<br>   <span class="hljs-built_in">fprintf</span>(fp, <span class="hljs-string">&quot;%s %s %s %d&quot;</span>, <span class="hljs-string">&quot;We&quot;</span>, <span class="hljs-string">&quot;are&quot;</span>, <span class="hljs-string">&quot;in&quot;</span>, <span class="hljs-number">2014</span>);<br>   <br>   fclose(fp);<br>   <br>   <span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>让我们编译并运行上面的程序，这将创建文件 <strong>file.txt</strong>，它的内容如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">We</span> are in <span class="hljs-number">2014</span><br></code></pre></td></tr></table></figure><h2 id="atoi-字符串转换成整数"><a href="#atoi-字符串转换成整数" class="headerlink" title="atoi 字符串转换成整数"></a>atoi 字符串转换成整数</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>C 库函数 <strong>int atoi(const char *str)</strong> 把参数 <strong>str</strong> 所指向的字符串转换为一个整数（类型为 int 型）。</p><h3 id="声明-1"><a href="#声明-1" class="headerlink" title="声明"></a>声明</h3><p>下面是 atoi() 函数的声明。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">atoi</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str)</span><br></code></pre></td></tr></table></figure><h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><ul><li><strong>str</strong> – 要转换为整数的字符串。</li></ul><h3 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h3><p>该函数返回转换后的长整数，如果没有执行有效的转换，则返回零。</p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>下面的实例演示了 atoi() 函数的用法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>   <span class="hljs-type">int</span> val;<br>   <span class="hljs-type">char</span> str[<span class="hljs-number">20</span>];<br>   <br>   <span class="hljs-built_in">strcpy</span>(str, <span class="hljs-string">&quot;98993489&quot;</span>);<br>   val = atoi(str);<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;字符串值 = %s, 整型值 = %d\n&quot;</span>, str, val);<br><br>   <span class="hljs-built_in">strcpy</span>(str, <span class="hljs-string">&quot;runoob.com&quot;</span>);<br>   val = atoi(str);<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;字符串值 = %s, 整型值 = %d\n&quot;</span>, str, val);<br><br>   <span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>让我们编译并运行上面的程序，这将产生以下结果：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">字符串值 = <span class="hljs-number">98993489</span>, 整型值 = <span class="hljs-number">98993489</span><br>字符串值 = runoob.com, 整型值 = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">printf</span> <span class="hljs-params">( <span class="hljs-type">const</span> <span class="hljs-type">char</span> * format, ... )</span>;<br></code></pre></td></tr></table></figure><p>将format 指向的 C 字符串写入标准输出 ( stdout )。如果format包含格式说明符（以%开头的子序列），则format后面的附加参数将被格式化并插入到结果字符串中，替换它们各自的说明符。</p><h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">%[flags][width][.precision][length]specifier<br></code></pre></td></tr></table></figure><h4 id="specifier"><a href="#specifier" class="headerlink" title="specifier"></a>specifier</h4><table><thead><tr><th align="left"><em>specifier</em></th><th align="left">Output</th><th align="left">Example</th></tr></thead><tbody><tr><td align="left"><code>d</code> <em>or</em> <code>i</code></td><td align="left">Signed decimal integer(有符号十进制整数)</td><td align="left"><code>392</code></td></tr><tr><td align="left"><code>u</code></td><td align="left">Unsigned decimal integer</td><td align="left"><code>7235</code></td></tr><tr><td align="left"><code>o</code></td><td align="left">Unsigned octal (无符号八进制)</td><td align="left"><code>610</code></td></tr><tr><td align="left"><code>x</code></td><td align="left">Unsigned hexadecimal integer (无符号十六进制整数)</td><td align="left"><code>7fa</code></td></tr><tr><td align="left"><code>X</code></td><td align="left">Unsigned hexadecimal integer (uppercase)</td><td align="left"><code>7FA</code></td></tr><tr><td align="left"><code>f</code></td><td align="left">Decimal floating point, lowercase (十进制浮点数，小写)</td><td align="left"><code>392.65</code></td></tr><tr><td align="left"><code>F</code></td><td align="left">Decimal floating point, uppercase</td><td align="left"><code>392.65</code></td></tr><tr><td align="left"><code>e</code></td><td align="left">Scientific notation (mantissa&#x2F;exponent), lowercase (科学记数法（尾数&#x2F;指数），小写)</td><td align="left"><code>3.9265e+2</code></td></tr><tr><td align="left"><code>E</code></td><td align="left">Scientific notation (mantissa&#x2F;exponent), uppercase</td><td align="left"><code>3.9265E+2</code></td></tr><tr><td align="left"><code>g</code></td><td align="left">Use the shortest representation: <code>%e</code> or <code>%f</code> (使用最短的表示：<code>%e</code>或<code>%f</code>)</td><td align="left"><code>392.65</code></td></tr><tr><td align="left"><code>G</code></td><td align="left">Use the shortest representation: <code>%E</code> or <code>%F</code></td><td align="left"><code>392.65</code></td></tr><tr><td align="left"><code>a</code></td><td align="left">Hexadecimal floating point, lowercase (十六进制浮点数，小写)</td><td align="left"><code>-0xc.90fep-2</code></td></tr><tr><td align="left"><code>A</code></td><td align="left">Hexadecimal floating point, uppercase</td><td align="left"><code>-0XC.90FEP-2</code></td></tr><tr><td align="left"><code>c</code></td><td align="left">Character</td><td align="left"><code>a</code></td></tr><tr><td align="left"><code>s</code></td><td align="left">String of characters</td><td align="left"><code>sample</code></td></tr><tr><td align="left"><code>p</code></td><td align="left">Pointer address</td><td align="left"><code>b8000000</code></td></tr><tr><td align="left"><code>n</code></td><td align="left">Nothing printed. <br/>The corresponding argument must be a pointer to a <code>signed int</code>.<br>The number of characters written so far is stored in the pointed location.</td><td align="left"></td></tr><tr><td align="left"><code>%</code></td><td align="left">A <code>%</code> followed by another <code>%</code> character will write a single <code>%</code> to the stream.</td><td align="left"><code>%</code></td></tr></tbody></table><h4 id="flags"><a href="#flags" class="headerlink" title="flags"></a>flags</h4><p>格式说明符 还可以按顺序包含子说明符：<code>flags</code>、<code>width</code>、<code>.precision</code>和<code>modifiers </code>（这个是什么?），它们是可选的并遵循以下规范：</p><table><thead><tr><th align="left"><em>flags</em></th><th align="left">description</th></tr></thead><tbody><tr><td align="left"><code>-</code></td><td align="left">Left-justify within the given field width; Right justification is the default (see <em>width</em> sub-specifier).<br/>(在给定的字段宽度内左对齐；右对齐是默认设置（请参阅<em>宽度</em>子说明符）。)</td></tr><tr><td align="left"><code>+</code></td><td align="left">Forces to preceed the result with a plus or minus sign (<code>+</code> or <code>-</code>) even for positive numbers. By default, only negative numbers are preceded with a <code>-</code> sign.<br/>(即使对于正数，也强制在结果前面加上加号或减号（<code>+</code>或<code>-</code>)。默认情况下，只有负数前面带有<code>-</code>号。)</td></tr><tr><td align="left"><em>(space)</em></td><td align="left">If no sign is going to be written, a blank space is inserted before the value.<br/>(如果不写入符号，则在值之前插入一个空格。)</td></tr><tr><td align="left"><code>#</code></td><td align="left">Used with <code>o</code>, <code>x</code> or <code>X</code> specifiers the value is preceeded with <code>0</code>, <code>0x</code> or <code>0X</code> respectively for values different than zero. <br/>Used with <code>a</code>, <code>A</code>, <code>e</code>, <code>E</code>, <code>f</code>, <code>F</code>, <code>g</code> or <code>G</code> it forces the written output to contain a decimal point even if no more digits follow. By default, if no digits follow, no decimal point is written.<br/>(与<code>o</code>、<code>x</code>或<code>X</code>说明符一起使用时，该值前面分别带有<code>0</code>、<code>0x</code>或<code>0X</code>，用于表示不同于零的值。<br/>与<code>a</code>、<code>A</code>、<code>e</code>、<code>E</code>、<code>f</code>、<code>F</code>、<code>g</code>或<code>G</code>一起使用，即使后面没有数字，它也会强制书面输出包含小数点。默认情况下，如果后面没有数字，则不写入小数点。)</td></tr><tr><td align="left"><code>0</code></td><td align="left">Left-pads the number with zeroes (<code>0</code>) instead of spaces when padding is specified (see <em>width</em> sub-specifier).<br/>指定填充时，用零（<code>0</code>）而不是空格填充数字（请参阅<em>宽度</em>子说明符）。</td></tr></tbody></table><h4 id="width"><a href="#width" class="headerlink" title="width"></a>width</h4><table><thead><tr><th align="left"><em>width</em></th><th align="left">description</th></tr></thead><tbody><tr><td align="left"><em>(number)</em></td><td align="left">Minimum number of characters to be printed. If the value to be printed is shorter than this number, the result is padded with blank spaces. The value is not truncated even if the result is larger.<br/>(要打印的最小字符数。如果要打印的值比这个数字短，结果用空格填充。即使结果较大，该值也不会被截断。)</td></tr><tr><td align="left"><code>*</code></td><td align="left">The <em>width</em> is not specified in the <em>format</em> string, but as an additional integer value argument preceding the argument that has to be formatted.<br/>(宽度未在格式字符串中指定，而是作为必须格式化的参数之前的附加整数值参数。)</td></tr></tbody></table><h4 id="precision"><a href="#precision" class="headerlink" title=".precision"></a>.precision</h4><table><thead><tr><th align="left"><em>.precision</em></th><th align="left">description</th></tr></thead><tbody><tr><td align="left"><code>.</code><em>number</em></td><td align="left">For integer specifiers (<code>d</code>, <code>i</code>, <code>o</code>, <code>u</code>, <code>x</code>, <code>X</code>): <em>precision</em> specifies the minimum number of digits to be written. If the value to be written is shorter than this number, the result is padded with leading zeros. The value is not truncated even if the result is longer. A <em>precision</em> of <code>0</code> means that no character is written for the value <code>0</code>. For <code>a</code>, <code>A</code>, <code>e</code>, <code>E</code>, <code>f</code> and <code>F</code> specifiers: this is the number of digits to be printed <strong>after</strong> the decimal point (by default, this is 6). For <code>g</code> and <code>G</code> specifiers: This is the maximum number of significant digits to be printed. For <code>s</code>: this is the maximum number of characters to be printed. By default all characters are printed until the ending null character is encountered. If the period is specified without an explicit value for <em>precision</em>, <code>0</code> is assumed.<br/>对于整数说明符（<code>d</code>、<code>i</code>、<code>o</code>、<code>u</code>、<code>x</code>、<code>X</code>）：<em>精度</em>指定要写入的最小位数。如果要写入的值小于此数字，则结果用前导零填充。即使结果更长，该值也不会被截断。<em>精度</em>为<code>0</code>意味着不为值<code>0</code>写入任何字符。<br/>对于<code>a</code>、<code>A</code>、<code>e</code>、<code>E</code>、<code>f</code>和<code>F</code>说明符：这是要打印的位数小数点<strong>后（默认为 6）。</strong><br/>对于<code>g</code>和<code>G</code>说明符：这是要打印的最大有效位数。<br/>对于<code>s</code>：这是要打印的最大字符数。默认情况下，所有字符都会打印，直到遇到结束的空字符。<br/>如果指定了周期而没有明确的<em>精度</em>值，则假定为<code>0 。</code></td></tr><tr><td align="left"><code>.*</code></td><td align="left">The <em>precision</em> is not specified in the <em>format</em> string, but as an additional integer value argument preceding the argument that has to be formatted.<br/><em>精度</em>未在格式字符串中指定，<em>而是</em>作为必须格式化的参数之前的附加整数值参数。</td></tr></tbody></table><p><em>长度</em>子说明符修改数据类型的长度 。这是一个图表，显示了用于解释有和没有<em>长度</em>说明符的相应参数的类型（如果使用不同的类型，则执行适当的类型提升或转换，如果允许）：</p><table><thead><tr><th align="left"></th><th align="left">specifiers</th><th align="left"></th><th align="left"></th><th align="left"></th><th align="left"></th><th align="left"></th><th align="left"></th></tr></thead><tbody><tr><td align="left"><em>length</em></td><td align="left"><code>d i</code></td><td align="left"><code>u o x X</code></td><td align="left"><code>f F e E g G a A</code></td><td align="left"><code>c</code></td><td align="left"><code>s</code></td><td align="left"><code>p</code></td><td align="left"><code>n</code></td></tr><tr><td align="left"><em>(none)</em></td><td align="left"><code>int</code></td><td align="left"><code>unsigned int</code></td><td align="left"><code>double</code></td><td align="left"><code>int</code></td><td align="left"><code>char*</code></td><td align="left"><code>void*</code></td><td align="left"><code>int*</code></td></tr><tr><td align="left"><code>h</code></td><td align="left"><code>short int</code></td><td align="left"><code>unsigned short int</code></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"><code>short int*</code></td></tr><tr><td align="left"><code>l</code></td><td align="left"><code>long int</code></td><td align="left"><code>unsigned long int</code></td><td align="left"></td><td align="left"><code>wint_t</code></td><td align="left"><code>wchar_t*</code></td><td align="left"></td><td align="left"><code>long int*</code></td></tr><tr><td align="left"><code>L</code></td><td align="left"></td><td align="left"></td><td align="left"><code>long double</code></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">↓C99↓</td><td align="left">↓C99↓</td><td align="left">↓C99↓</td><td align="left">↓C99↓</td><td align="left">↓C99↓</td><td align="left">↓C99↓</td><td align="left">↓C99↓</td><td align="left">↓C99↓</td></tr><tr><td align="left"><code>hh</code></td><td align="left"><code>signed char</code></td><td align="left"><code>unsigned char</code></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"><code>signed char*</code></td></tr><tr><td align="left"><code>ll</code></td><td align="left"><code>long long int</code></td><td align="left"><code>unsigned long long int</code></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"><code>long long int*</code></td></tr><tr><td align="left"><code>j</code></td><td align="left"><code>intmax_t</code></td><td align="left"><code>uintmax_t</code></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"><code>intmax_t*</code></td></tr><tr><td align="left"><code>z</code></td><td align="left"><code>size_t</code></td><td align="left"><code>size_t</code></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"><code>size_t*</code></td></tr><tr><td align="left"><code>t</code></td><td align="left"><code>ptrdiff_t</code></td><td align="left"><code>ptrdiff_t</code></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"><code>ptrdiff_t*</code></td></tr></tbody></table><h1 id="杂乱"><a href="#杂乱" class="headerlink" title="杂乱"></a>杂乱</h1><h2 id="stderr-stdout"><a href="#stderr-stdout" class="headerlink" title="stderr stdout"></a>stderr stdout</h2><ul><li><p>stdout – 标准输出设备 stdout。 </p></li><li><p>stderr – 标准错误输出设备</p></li></ul><p>两者默认向屏幕输出。 但如果用转向标准输出到磁盘文件，则可看出两者区别。stdout输出到磁盘文件，stderr在屏幕。 </p><blockquote><p>转向标准输出到磁盘文件tmp.txt<br>my.exe &gt; tmp.txt</p></blockquote><p>在默认情况下，stdout是行缓冲的，他的输出会放在一个buffer里面，只有到换行的时候，才会输出到屏幕。而stderr是无缓冲的，会直接输出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stdout</span>,<span class="hljs-string">&quot;Group&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<span class="hljs-string">&quot;XiyouLinux&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">linux下，第一次会输出XiYouLinuxGroup,是因为stdout将输出的Group放到了缓冲区当中直到程序结束在将缓冲区中的数据刷新出来。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h1 id="Show-me-you-code"><a href="#Show-me-you-code" class="headerlink" title="Show me you code"></a>Show me you code</h1><h2 id="全局变量会默认被设置成0"><a href="#全局变量会默认被设置成0" class="headerlink" title="全局变量会默认被设置成0"></a>全局变量会默认被设置成0</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">include &lt;stdio.h&gt;</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">include &lt;stdlib.h&gt;</span><br><br>int ga=0;<br>int gb;<br><br>void testFun(void) &#123;<br>    int a=0;<br>    int b;<br><br>    printf(&quot;%d %d %d %d \r\n&quot;, a, b, ga, gb);<br>&#125;<br><br>int main()<br>&#123;<br>    printf(&quot;Hello world!\n&quot;);<br>    <br>    for (int i = 0; i &lt; 10; i++)<br>    &#123;<br>        testFun();<br>    &#125;<br><br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">Hello world!<br>0 16 0 0<br>0 16 0 0<br>0 16 0 0<br>0 16 0 0<br>0 16 0 0<br>0 16 0 0<br>0 16 0 0<br>0 16 0 0<br>0 16 0 0<br>0 16 0 0<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c/c++</tag>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MicroPython</title>
    <link href="/2020/bf76c113/"/>
    <url>/2020/bf76c113/</url>
    
    <content type="html"><![CDATA[<h1 id="MicroPython"><a href="#MicroPython" class="headerlink" title="MicroPython"></a>MicroPython</h1><p><a href="https://www.cirmall.com/articles/301308/p1">简单、方便、快速开发嵌入式实时系统——MicroPytho</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pyb <span class="hljs-keyword">import</span> uart<br><br><span class="hljs-keyword">from</span> pyb <span class="hljs-keyword">import</span> I2C <span class="hljs-comment">#工程师将从pyb库导入I2C</span><br><span class="hljs-comment">#这里的PYB库提供了接入到微控制器外围功能，如SPI，I2C以及UART</span><br><span class="hljs-comment">#在使用任何外设之前，工程师必须实例化外设类以创建可用于控制外设的对象。一旦外设类被初始化，工程师可以执行任何其他操作，例如在进入主应用程序循环之前验证设备是否存在，主要应用程序代码将会每秒采样一次传感器。</span><br><br>GlobalTemp = <span class="hljs-number">0.0</span><br><br>GlobalBarometer = <span class="hljs-number">0.0</span><br><br>＃初始化和实例化I2C外设<span class="hljs-number">2</span><br><br>I2C2 = I2C（<span class="hljs-number">2</span>，I2C.MASTER，波特率= <span class="hljs-number">100000</span>）<br><br>＃配置Uart1进行通信<br><br>Uart1 = pyb.UART（<span class="hljs-number">1</span>,<span class="hljs-number">115200</span>）<br><br>Uart1.init（<span class="hljs-number">115200</span>，bits = <span class="hljs-number">8</span>，parity = <span class="hljs-literal">None</span>，stop = <span class="hljs-number">1</span>）<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br><br>SampleSensor（）<br><br>pyb.delay（<span class="hljs-number">1000</span>）<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">SensorSample</span>（）：<br><br>＃读取温度数据<br><br>TempSample = I2C2.readfrom_mem（<span class="hljs-number">119</span>，<span class="hljs-number">0xFA</span>，<span class="hljs-number">3</span>）<br><br>＃读取压力数据<br><br>PressureSample = I2C2.readfrom_mem（<span class="hljs-number">119</span>，<span class="hljs-number">0xF7</span>,<span class="hljs-number">3</span>）<br><br>将样本数据转换为字符串<br><br>data =“＃，temperature =”<span class="hljs-built_in">str</span>（TempSample）+“，pressure”+ <span class="hljs-built_in">str</span>（PressureSample）+“，＃，\ n \ r”<br><br>＃将数据写入蓝牙<br><br>Uart1.write（data）<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>embedded</tag>
      
      <tag>micropython</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PyQT</title>
    <link href="/2020/7ecf7a99/"/>
    <url>/2020/7ecf7a99/</url>
    
    <content type="html"><![CDATA[<h1 id="PyQt"><a href="#PyQt" class="headerlink" title="PyQt"></a>PyQt</h1><h2 id="添加图标"><a href="#添加图标" class="headerlink" title="添加图标"></a>添加图标</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WindowGUI</span>(QMainWindow, Ui_MainWindow):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(WindowGUI, <span class="hljs-variable language_">self</span>).__init__()<br>        <span class="hljs-variable language_">self</span>.setupUi(<span class="hljs-variable language_">self</span>)<br>        <span class="hljs-comment">#这里添加了一个图标</span><br>        <span class="hljs-variable language_">self</span>.setWindowIcon(QIcon(<span class="hljs-string">&#x27;./Data/SerialBlack.ico&#x27;</span>))<br>        <span class="hljs-variable language_">self</span>.pushButton.clicked.connect(<span class="hljs-variable language_">self</span>.Butt)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 每一pyqt5应用程序必须创建一个应用程序对象。sys.argv参数是一个列表，从命令行输入参数。</span><br>    app = QApplication(sys.argv)<br>    window = WindowGUI()<br>    window.show()<br>    sys.exit(app.exec_())<br></code></pre></td></tr></table></figure><h2 id="退出确认"><a href="#退出确认" class="headerlink" title="退出确认"></a>退出确认</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WindowGUI</span>(QMainWindow, Ui_MainWindow):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(WindowGUI, <span class="hljs-variable language_">self</span>).__init__()<br>        <span class="hljs-variable language_">self</span>.setupUi(<span class="hljs-variable language_">self</span>)<br>    <span class="hljs-comment">#关闭窗口产生 QCloseEvent</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">closeEvent</span>(<span class="hljs-params">self, event</span>):<br>        reply = QMessageBox.question(<span class="hljs-variable language_">self</span>, <span class="hljs-string">&#x27;Message&#x27;</span>,<br>                                     <span class="hljs-string">&quot;Are you sure to quit?&quot;</span>, QMessageBox.Yes |<br>                                     QMessageBox.No, QMessageBox.No)<br>        <span class="hljs-keyword">if</span> reply == QMessageBox.Yes:<br>            event.accept()<br>        <span class="hljs-keyword">else</span>:<br>            event.ignore()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 每一pyqt5应用程序必须创建一个应用程序对象。sys.argv参数是一个列表，从命令行输入参数。</span><br>    app = QApplication(sys.argv)<br>    window = WindowGUI()<br>    window.show()<br>    sys.exit(app.exec_())<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>qt</tag>
      
      <tag>pyqt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python学习笔记</title>
    <link href="/2020/297a89d9/"/>
    <url>/2020/297a89d9/</url>
    
    <content type="html"><![CDATA[<h1 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h1><p>Python学习笔记</p><h1 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;第一行\n第二行&#x27;</span>)<br><br><br><span class="hljs-built_in">print</span>(a + <span class="hljs-string">&#x27; &#x27;</span> + b + <span class="hljs-string">&#x27; %d %d&#x27;</span>%(c,d))//连字符<br></code></pre></td></tr></table></figure><h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><h3 id="基本格式化"><a href="#基本格式化" class="headerlink" title="基本格式化"></a>基本格式化</h3><p>在Python中，采用的格式化方式和C语言是一致的，用%实现，举例如下</p><ul><li>单个</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;Hello, %s&#x27;</span> % <span class="hljs-string">&#x27;world&#x27;</span><br><span class="hljs-string">&#x27;Hello, world&#x27;</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>k=<span class="hljs-number">2</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;big&#x27;</span>, k)<br><span class="hljs-string">&#x27;big 2&#x27;</span><br></code></pre></td></tr></table></figure><ul><li><p>多个</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;Hi, %s, you have $%d.&#x27;</span> % (<span class="hljs-string">&#x27;Michael&#x27;</span>, <span class="hljs-number">1000000</span>)<br><span class="hljs-string">&#x27;Hi, Michael, you have $1000000.&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>如果你不太确定应该用什么，%s永远起作用，它会把任何数据类型转换为字符串</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;Age: %s. Gender: %s&#x27;</span> % (<span class="hljs-number">25</span>, <span class="hljs-literal">True</span>)<br><span class="hljs-string">&#x27;Age: 25. Gender: True&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="format-格式化"><a href="#format-格式化" class="headerlink" title="format 格式化"></a>format 格式化</h3><p>format()它会用传入的参数依次替换字符串内的占位符{0}、{1}……</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;Hello, &#123;0&#125;, 成绩提升了 &#123;1:.1f&#125;%&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-number">17.125</span>)<br><span class="hljs-string">&#x27;Hello, 小明, 成绩提升了 17.1%&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="字符转义"><a href="#字符转义" class="headerlink" title="字符转义"></a>字符转义</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#如果字符串里面有很多字符都需要转义，就需要加很多\，为了简化，Python还允许用``r&#x27;&#x27;表示&#x27;&#x27;``内部的字符串默认不转义</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\\\t\\&#x27;</span>)<br>\       \<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-string">r&#x27;\\\t\\&#x27;</span>)<br>\\\t\\<br><br><br><span class="hljs-comment">#如果字符串内部有很多换行，用\n写在一行里不好阅读，为了简化，Python允许用&#x27;&#x27;&#x27;...&#x27;&#x27;&#x27;的格式表示多行内容，可以自己试试：</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#x27;&#x27;line1</span><br><span class="hljs-string"><span class="hljs-meta">... </span>line2</span><br><span class="hljs-string"><span class="hljs-meta">... </span>line3&#x27;&#x27;&#x27;</span>)<br>line1<br>line2<br>line3<br></code></pre></td></tr></table></figure><h2 id="显示字符串的前部分长度"><a href="#显示字符串的前部分长度" class="headerlink" title="显示字符串的前部分长度"></a>显示字符串的前部分长度</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(pi_string[:<span class="hljs-number">52</span>] + <span class="hljs-string">&quot;...&quot;</span>)<br><span class="hljs-comment"># 3.14159265358979323846264338327950288419716939937510...</span><br></code></pre></td></tr></table></figure><h1 id="input"><a href="#input" class="headerlink" title="input"></a>input</h1><p>幸好，<code>input()</code>可以让你显示一个字符串来提示用户，于是我们把代码改成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;please enter your name: &#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;hello,&#x27;</span>, name)<br></code></pre></td></tr></table></figure><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 这是一段 行注释</span><br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">这是一段 段注释</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h1 id="数据类型-和-算数运算符"><a href="#数据类型-和-算数运算符" class="headerlink" title="数据类型 和 算数运算符"></a>数据类型 和 算数运算符</h1><p>整数、浮点数、字符串、布尔型（True、False（注意大小写））、空值</p><p>所谓常量就是不能变的变量，比如常用的数学常数π就是一个常量。在Python中，通常用全部大写的变量名表示，但是不能保证其不被改变</p><p>空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">+</td><td align="left">加 - 两个对象相加</td><td align="left">a + b 输出结果 30</td></tr><tr><td align="left">-</td><td align="left">减 - 得到负数或是一个数减去另一个数</td><td align="left">a - b 输出结果 -10</td></tr><tr><td align="left">*</td><td align="left">乘 - 两个数相乘或是返回一个被重复若干次的字符串</td><td align="left">a * b 输出结果 200</td></tr><tr><td align="left">&#x2F;</td><td align="left">除 - x除以y</td><td align="left">b &#x2F; a 输出结果 2</td></tr><tr><td align="left">%</td><td align="left">取模 - 返回除法的余数</td><td align="left">b % a 输出结果 0</td></tr><tr><td align="left">**</td><td align="left">幂 - 返回x的y次幂</td><td align="left">a**b 为10的20次方， 输出结果 100000000000000000000</td></tr><tr><td align="left">&#x2F;&#x2F;</td><td align="left">取整除 - 返回商的整数部分（<strong>向下取整</strong>）</td><td align="left"><code>&gt;&gt;&gt; 9//2 = 4 &gt;&gt;&gt; -9//2 = -5</code></td></tr></tbody></table><p>&#x2F;除法计算结果是浮点数</p><p>&#x2F;&#x2F;称为地板除，两个整数的除法仍然是整数（c整数除法）</p><h1 id="编码（数据转换）"><a href="#编码（数据转换）" class="headerlink" title="编码（数据转换）"></a>编码（数据转换）</h1><p>ord()函数获取字符的整数表示</p><p>&gt;&gt;&gt; ord(‘中’)</p><p>20013</p><p>chr()函数把编码转换为对应的字符</p><p>&gt;&gt;&gt; chr(25991)</p><p>‘文’</p><p>str通过encode()可以编码为bytes</p><p>&gt;&gt;&gt; ‘ABC’.encode(‘ascii’)</p><p>b’ABC’</p><p>&gt;&gt;&gt; ‘中文’.encode(‘utf-8’)</p><p>b’\xe4\xb8\xad\xe6\x96\x87’</p><p>要把bytes变为str，就需要用decode()</p><p>&gt;&gt;&gt; b’ABC’.decode(‘ascii’)</p><p>‘ABC’</p><p>要计算str包含多少个字符，可以用len()函数</p><p>&gt;&gt;&gt; len(‘ABC’)</p><p>3</p><p>&gt;&gt;&gt; len(‘中文’)</p><p>2</p><p>len()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数</p><p>&gt;&gt;&gt; len(b’ABC’)</p><p>3</p><p>&gt;&gt;&gt; len(b’\xe4\xb8\xad\xe6\x96\x87’)</p><p>6</p><p>&gt;&gt;&gt; len(‘中文’.encode(‘utf-8’))</p><p>6</p><hr><p>‘ABC’和b’ABC’，</p><p>前者是str，在内存中以Unicode表示，一个字符对应若干个字节</p><p>后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节</p><h1 id="List列表（类似数组）"><a href="#List列表（类似数组）" class="headerlink" title="List列表（类似数组）"></a>List列表（类似数组）</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">s = [<span class="hljs-number">0</span>]*<span class="hljs-number">10</span><span class="hljs-comment">#10个0</span><br>[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br><br>s = [<span class="hljs-string">&#x27;hello&#x27;</span>]*<span class="hljs-number">3</span>    <span class="hljs-comment">#10个&#x27;hello&#x27;</span><br>[<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-string">&#x27;hello&#x27;</span>]<br><br>s = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>))<span class="hljs-comment">#10个 从0到10</span><br>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]<br><br></code></pre></td></tr></table></figure><hr><p>Python内置的一种数据类型是list。list是一种有序的集合，可以随时添加和删除其中的元素。</p><p>&gt;&gt;&gt; classmates &#x3D; [‘Jack’, 180, 1.69]</p><p>&gt;&gt;&gt; classmates</p><p>[‘Jack’, 180, 1.69]</p><hr><p>如果要取最后一个元素，除了计算索引位置外，还可以用-1做索引，直接获取最后一个元素：</p><p>&gt;&gt;&gt; classmates[-1]</p><p>‘Tracy’</p><hr><p>list是一个可变的有序表，所以，可以往list中追加元素到末尾：</p><p>&gt;&gt;&gt; classmates.append(‘Adam’)</p><p>&gt;&gt;&gt; classmates</p><p>[‘Michael’, ‘Bob’, ‘Tracy’, ‘Adam’]</p><p>也可以把元素插入到指定的位置，比如索引号为1的位置：</p><p>&gt;&gt;&gt; classmates.insert(1, ‘Jack’)</p><p>&gt;&gt;&gt; classmates</p><p>[‘Michael’, ‘Jack’, ‘Bob’, ‘Tracy’, ‘Adam’]</p><p>要删除list末尾的元素，用pop()方法：</p><p>&gt;&gt;&gt; classmates.pop()</p><p>‘Adam’</p><p>&gt;&gt;&gt; classmates</p><p>[‘Michael’, ‘Jack’, ‘Bob’, ‘Tracy’]</p><p>要删除指定位置的元素，用pop(i)方法，其中i是索引位置：</p><p>&gt;&gt;&gt; classmates.pop(1)</p><p>‘Jack’</p><p>&gt;&gt;&gt; classmates</p><p>[‘Michael’, ‘Bob’, ‘Tracy’]</p><hr><p>-———————————————————————————————————————</p><p>list元素也可以是另一个list，比如：</p><p>&gt;&gt;&gt; s &#x3D; [‘python’, ‘java’, [‘asp’, ‘php’], ‘scheme’]</p><p>&gt;&gt;&gt; len(s)</p><p>4</p><p>要注意s只有4个元素，其中s[2]又是一个list，如果拆开写就更容易理解了</p><p>&gt;&gt;&gt; p &#x3D; [‘asp’, ‘php’]</p><p>&gt;&gt;&gt; s &#x3D; [‘python’, ‘java’, p, ‘scheme’]</p><p>要访问’php’可以写p[1]或者s[2][1]，因此s可以看成是一个二维数组</p><h1 id="Tuple元组（静态数组）"><a href="#Tuple元组（静态数组）" class="headerlink" title="Tuple元组（静态数组）"></a>Tuple元组（静态数组）</h1><p>另一种有序列表叫元组：tuple</p><p>。tuple和list非常类似，但是tuple一旦初始化就不能修改</p><p>&gt;&gt;&gt; classmates &#x3D; (‘Michael’, ‘Bob’, ‘Tracy’)</p><p>要定义一个只有1个元素的tuple，如果你这么定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>t = (<span class="hljs-number">1</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>t<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>定义的不是tuple，是<code>1</code>这个数！这是因为括号<code>()</code>既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是<code>1</code>。</p><p>所以，只有1个元素的tuple定义时必须加一个逗号<code>,</code>，来消除歧义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>t = (<span class="hljs-number">1</span>,)<br><span class="hljs-meta">&gt;&gt;&gt; </span>t<br>(<span class="hljs-number">1</span>,)<br></code></pre></td></tr></table></figure><p>Python在显示只有1个元素的tuple时，也会加一个逗号<code>,</code>，以免你误解成数学计算意义上的括号。</p><p>最后来看一个“可变的”tuple：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>t = (<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>])<br><span class="hljs-meta">&gt;&gt;&gt; </span>t[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;X&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>t[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;Y&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>t<br>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, [<span class="hljs-string">&#x27;X&#x27;</span>, <span class="hljs-string">&#x27;Y&#x27;</span>])<br></code></pre></td></tr></table></figure><h2 id="str-replace-替换"><a href="#str-replace-替换" class="headerlink" title="str.replace 替换"></a>str.replace 替换</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>message = <span class="hljs-string">&quot;I really like dogs.&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>message.replace(<span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-string">&#x27;cat&#x27;</span>)<br><span class="hljs-string">&#x27;I really like cats.&#x27;</span><br></code></pre></td></tr></table></figure><h1 id="if-、-for-、-while-、-range"><a href="#if-、-for-、-while-、-range" class="headerlink" title="if 、 for 、 while 、 range"></a>if 、 for 、 while 、 range</h1><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><p><strong>变体</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">ii = <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> ss == <span class="hljs-number">2</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br><br><span class="hljs-comment">#当ss == 2时 ii=1 否则 ii=0</span><br></code></pre></td></tr></table></figure><p>if age &gt;&#x3D; 18:</p><p>​    print(‘adult’)</p><p>else:</p><p>​    print(‘teenager’)</p><p>age &#x3D; 3</p><p>if age &gt;&#x3D; 18:</p><p>​    print(‘adult’)</p><p>elif age &gt;&#x3D; 6:</p><p>​    print(‘teenager’)</p><p>else:</p><p>​    print(‘kid’)</p><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p>所以for x in …循环就是把每个元素代入变量x，然后执行缩进块的语句。</p><p>再比如我们想计算1-10的整数之和，可以用一个sum变量做累加：</p><p>sum &#x3D; 0</p><p>for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]:</p><p>​    sum &#x3D; sum + x</p><p>print(sum)</p><hr><p>sum &#x3D; 0</p><p>for x in  range(101):</p><p>​    sum &#x3D; sum + x</p><p>print(sum)</p><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><p>while循环</p><p>sum &#x3D; 0</p><p>n &#x3D; 99</p><p>while n &gt; 0:</p><p>​    sum &#x3D; sum + n</p><p>​    n &#x3D; n - 2</p><p>print(sum)</p><h2 id="range"><a href="#range" class="headerlink" title="range"></a>range</h2><p>range(start, stop[, step])    可以生成一个整数序列，</p><p>start: 计数从 start 开始。默认是从 0 开始。例如range（5）等价于range（0， 5）;</p><p>stop: 计数到 stop 结束，但不包括 stop。例如：range（0， 5） 是[0, 1, 2, 3, 4]没有5</p><p>step：步长，默认为1。例如：range（0， 5） 等价于 range(0, 5, 1)</p><p>&gt;&gt;&gt; list(range(5))</p><p>[0, 1, 2, 3, 4]</p><p>&gt;&gt;&gt;range(10)        # 从 0 开始到 10</p><p>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</p><p>&gt;&gt;&gt; range(1, 11)     # 从 1 开始到 11</p><p>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</p><p>&gt;&gt;&gt; range(0, 30, 5)  # 步长为 5</p><p>[0, 5, 10, 15, 20, 25]</p><p>&gt;&gt;&gt; range(0, 10, 3)  # 步长为 3</p><p>[0, 3, 6, 9]</p><p>&gt;&gt;&gt; range(0, -10, -1) # 负数</p><p>[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]</p><p>&gt;&gt;&gt; range(0)</p><p>[]</p><p>&gt;&gt;&gt; range(1, 0)</p><p>[]</p><h1 id="Dict（字典）"><a href="#Dict（字典）" class="headerlink" title="Dict（字典）"></a>Dict（字典）</h1><p>Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。</p><p>如果用dict实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用Python写一个dict如下：</p><p>&gt;&gt;&gt; d &#x3D; {‘Michael’: 95, ‘Bob’: 75, ‘Tracy’: 85}</p><p>&gt;&gt;&gt; d[‘Michael’]</p><p>95 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">Kw = &#123;<span class="hljs-string">&#x27;city&#x27;</span>: <span class="hljs-number">22</span>, <span class="hljs-string">&#x27;job&#x27;</span>: <span class="hljs-number">33</span>&#125;: <br><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;city&#x27;</span> <span class="hljs-keyword">in</span> kw:<br><span class="hljs-comment"># 有city参数</span><br>    <span class="hljs-keyword">pass</span><br><br><br>&gt;&gt;&gt;kw.get(<span class="hljs-string">&#x27;city&#x27;</span>)<br><span class="hljs-number">22</span><br>&gt;&gt;&gt;kw.[<span class="hljs-string">&#x27;city&#x27;</span>]<br><span class="hljs-number">22</span><br></code></pre></td></tr></table></figure><h2 id="字典内置函数-方法"><a href="#字典内置函数-方法" class="headerlink" title="字典内置函数&amp;方法"></a>字典内置函数&amp;方法</h2><p>Python字典包含了以下内置函数：</p><table><thead><tr><th align="left">序号</th><th align="left">函数及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-cmp.html">cmp(dict1, dict2)</a> 比较两个字典元素。</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-len.html">len(dict)</a> 计算字典元素个数，即键的总数。</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-str.html">str(dict)</a> 输出字典可打印的字符串表示。</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-type.html">type(variable)</a> 返回输入的变量类型，如果变量是字典就返回字典类型。</td></tr></tbody></table><p>Python字典包含了以下内置方法：</p><table><thead><tr><th align="left">序号</th><th align="left">函数及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-clear.html">dict.clear()</a> 删除字典内所有元素</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-copy.html">dict.copy()</a> 返回一个字典的浅复制</td></tr><tr><td align="left">3</td><td align="left">[dict.fromkeys(seq<a href="https://www.runoob.com/python/att-dictionary-fromkeys.html">, val])</a> 创建一个新字典，以序列 seq 中元素做字典的键，val 为字典所有键对应的初始值</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-get.html">dict.get(key, default&#x3D;None)</a> 返回指定键的值，如果值不在字典中返回default值</td></tr><tr><td align="left">5</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-has_key.html">dict.has_key(key)</a> 如果键在字典dict里返回true，否则返回false</td></tr><tr><td align="left">6</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-items.html">dict.items()</a> 以列表返回可遍历的(键, 值) 元组数组</td></tr><tr><td align="left">7</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-keys.html">dict.keys()</a> 以列表返回一个字典所有的键</td></tr><tr><td align="left">8</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-setdefault.html">dict.setdefault(key, default&#x3D;None)</a> 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default</td></tr><tr><td align="left">9</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-update.html">dict.update(dict2)</a> 把字典dict2的键&#x2F;值对更新到dict里</td></tr><tr><td align="left">10</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-values.html">dict.values()</a> 以列表返回字典中的所有值</td></tr><tr><td align="left">11</td><td align="left">[pop(key<a href="https://www.runoob.com/python/python-att-dictionary-pop.html">,default])</a> 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。</td></tr><tr><td align="left">12</td><td align="left"><a href="https://www.runoob.com/python/python-att-dictionary-popitem.html">popitem()</a> 返回并删除字典中的最后一对键和值。</td></tr></tbody></table><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><h2 id="基本打开输出文件"><a href="#基本打开输出文件" class="headerlink" title="基本打开输出文件"></a>基本打开输出文件</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;pi_digits.txt&#x27;</span>) <span class="hljs-keyword">as</span> file_object:<br>    contents = file_object.read()<br>    <span class="hljs-built_in">print</span>(contents)<br></code></pre></td></tr></table></figure><p>在这个程序中，第1行代码做了大量的工作。我们先来看看函数open() 。要以任何方式使用文件——哪怕仅仅是打印其内容，都得先打开 文件，这样才能访问它。函数open()接受一个参数：要打开的文件的名称。Python在当前执行的文件所在的目录中查找指定的文件。在这个示例中，当前运行的是file_reader.py，因此Python在file_reader.py所在的目录中查找pi_digits.txt。函数open() 返回一个表示文件的对象。在这里，open(‘pi_digits.txt’) 返回一个表示文件pi_digits.txt 的对象；Python将这个对象存储在我们将在后面使用的变量中。</p><p>关键字with 在不再需要访问文件后将其关闭。在这个程序中，注意到我们调用了open() ，但没有调用close() ；你也可以调用open() 和close() 来打开和关闭文件，但这样做时，如果程序存在bug，导致close() 语句未执行，文件将不会关闭。这看似微不足道，但未妥善地关闭文件可能会导致数据丢失或受损。如果在程序中过早地调用close() ，你会发现需要使用文件时它已关闭 （无法访问），这会导致更多的错误。并非在任何情况下都能轻松确定关闭文件的恰当时机，但通过使用前面所示的结构，可让Python去确定：你只管打开文件，并在需要时使用它，Python自会在合适的时候自动将其关闭。</p><h2 id="删除字符串末尾的空白-rstrip"><a href="#删除字符串末尾的空白-rstrip" class="headerlink" title="删除字符串末尾的空白 rstrip"></a>删除字符串末尾的空白 rstrip</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;pi_digits.txt&#x27;</span>) <span class="hljs-keyword">as</span> file_object:<br>    contents = file_object.read()<br>    <span class="hljs-built_in">print</span>(contents.rstrip())<br></code></pre></td></tr></table></figure><p>相比于原始文件，该输出唯一不同的地方是末尾多了一个空行。为何会多出这个空行呢？因为read() 到达文件末尾时返回一个空字符串，而将这个空字符串显示出来时就是一个空行。要删除多出来的空行，可在print 语句中使用rstrip() ：</p><p>每行左边的空格，为删除这些空格，可使用strip() </p><h2 id="逐行读取文件"><a href="#逐行读取文件" class="headerlink" title="逐行读取文件"></a>逐行读取文件</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">filename = <span class="hljs-string">&#x27;pi_digits.txt&#x27;</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename) <span class="hljs-keyword">as</span> file_object:<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> file_object:<br>    <span class="hljs-built_in">print</span>(line.rstrip())<br></code></pre></td></tr></table></figure><h2 id="文件打开模式"><a href="#文件打开模式" class="headerlink" title="文件打开模式"></a>文件打开模式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">filename = <span class="hljs-string">&#x27;programming.txt&#x27;</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> file_object:<br>    file_object.write(<span class="hljs-string">&quot;I love programming.&quot;</span>)<br></code></pre></td></tr></table></figure><p>在这个示例中，调用open() 时提供了两个实参（见❶）。第一个实参也是要打开的文件的名称；第二个实参（’w’ ）告诉Python，我们要以写入模式 打开这个文件。打开文件时，<strong>可指定读取模式 （’r’ ）、写入模式 （’w’ ）、附加模式 （’a’ ）附加到文件末尾、让你能够读取和写入文件的模式（’r+’ ）</strong>。如果你省略了模式实参，Python将以默认的只读模式打开文件。</p><h2 id="异常处理-try-except"><a href="#异常处理-try-except" class="headerlink" title="异常处理 try-except"></a>异常处理 try-except</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">filename = <span class="hljs-string">&#x27;alice.txt&#x27;</span><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename) <span class="hljs-keyword">as</span> f_obj:<br>    contents = f_obj.read()<br><span class="hljs-keyword">except</span> FileNotFoundError:<br>    msg = <span class="hljs-string">&quot;Sorry, the file &quot;</span> + filename + <span class="hljs-string">&quot; does not exist.&quot;</span><br><span class="hljs-built_in">print</span>(msg)<br></code></pre></td></tr></table></figure><p>在这个示例中，try 代码块引发FileNotFoundError 异常，因此Python找出与该错误匹配的except 代码块，并运行其中的代码。最终的结果是显示一条友好的错误消息，而不是traceback：</p><h1 id="一些方法"><a href="#一些方法" class="headerlink" title="一些方法"></a>一些方法</h1><h2 id="count"><a href="#count" class="headerlink" title=".count()"></a>.count()</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>Python count() 方法用于统计字符串里某个字符出现的次数。可选参数为在字符串搜索的开始与结束位置。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>count()方法语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span>.count(sub, start= <span class="hljs-number">0</span>,end=<span class="hljs-built_in">len</span>(string))<br></code></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li>sub – 搜索的子字符串</li><li>start – 字符串开始搜索的位置。默认为第一个字符,第一个字符索引值为0。</li><li>end – 字符串中结束搜索的位置。字符中第一个字符的索引为 0。默认为字符串的最后一个位置。</li></ul><h2 id="to-bytes"><a href="#to-bytes" class="headerlink" title=".to_bytes()"></a>.to_bytes()</h2><p>(0x12).to_bytes(10, byteorder&#x3D; ‘big’, signed &#x3D; ‘true’)</p><ul><li><p>10：表示转换后的数据占10个字节</p></li><li><p>byteorder：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;(<span class="hljs-number">0x12</span>).to_bytes(<span class="hljs-number">10</span>, byteorder = <span class="hljs-string">&#x27;big&#x27;</span>)<br><br><span class="hljs-comment">#b&#x27;\xf8\x12\x00\x00&#x27;</span><br><br>&gt;&gt;&gt;(<span class="hljs-number">0x12</span>).to_bytes(<span class="hljs-number">10</span>, byteorder = <span class="hljs-string">&#x27;little&#x27;</span>)<br><br><span class="hljs-comment">#b&#x27;\x00\x00\x12\xf8&#x27;</span><br></code></pre></td></tr></table></figure><ul><li>signed： 表示有符号和无符号</li></ul><h2 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h2><p>函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：(类似于指针？？？？准确描述应该是类似 tpyedef )</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-built_in">abs</span> <span class="hljs-comment"># 变量a指向abs函数</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a(-<span class="hljs-number">1</span>) <span class="hljs-comment"># 所以也可以通过a调用abs函数1</span><br></code></pre></td></tr></table></figure><h2 id="abs-绝对值"><a href="#abs-绝对值" class="headerlink" title="abs 绝对值"></a>abs 绝对值</h2><p>abs( x )函数 取绝对值</p><p>x – 数值表达式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">abs</span>(<span class="hljs-number">100</span>)<span class="hljs-number">100</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">abs</span>(-<span class="hljs-number">20</span>)<span class="hljs-number">20</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">abs</span>(<span class="hljs-number">12.34</span>)<span class="hljs-number">12.34</span><br></code></pre></td></tr></table></figure><h2 id="max-找平均值"><a href="#max-找平均值" class="headerlink" title="max 找平均值"></a>max 找平均值</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><br>list1 = [<span class="hljs-number">123</span>, <span class="hljs-number">568</span>, <span class="hljs-number">423</span>, <span class="hljs-number">365</span>]<br><br><span class="hljs-built_in">print</span>( np.mean(list1) )<br></code></pre></td></tr></table></figure><h2 id="max-找最大-小值"><a href="#max-找最大-小值" class="headerlink" title="max 找最大&#x2F;小值"></a>max 找最大&#x2F;小值</h2><p>max( x, y, z, …. )  可以接收任意多个参数，并返回最大的那个（可以传入list）：</p><p>x – 数值表达式。y – 数值表达式。z – 数值表达式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><span class="hljs-number">2</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">max</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">5</span>)<br><span class="hljs-number">3</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>list1 = [<span class="hljs-number">123</span>, <span class="hljs-number">568</span>, <span class="hljs-number">423</span>, <span class="hljs-number">365</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Max value element : &quot;</span>, <span class="hljs-built_in">max</span>(list1))<br>Max value element :  <span class="hljs-number">568</span><br></code></pre></td></tr></table></figure><h2 id="exal-执行字符串类型的表达式"><a href="#exal-执行字符串类型的表达式" class="headerlink" title="exal 执行字符串类型的表达式"></a>exal 执行字符串类型的表达式</h2><p>eval(expression[, globals[, locals]])函数   函数用来执行一个字符串表达式，并返回表达式的值。</p><p>expression – 表达式。</p><p>globals – 变量作用域，全局命名空间，如果被提供，则必须是一个字典对象。</p><p>locals – 变量作用域，局部命名空间，如果被提供，可以是任何映射对象。</p><p>&gt;&gt;&gt;x &#x3D; 7</p><p>&gt;&gt;&gt; eval( ‘3 * x’ )</p><p>21</p><p>&gt;&gt;&gt; eval(‘pow(2,2)’)</p><p>4</p><p>a&#x3D;eval(input(“请输入一个整数”))           #（自动类型转换）</p><h2 id="int-强制转换"><a href="#int-强制转换" class="headerlink" title="int 强制转换"></a>int 强制转换</h2><p>class int(x, base&#x3D;10)    强制转换返回整型数据。</p><p>x – 字符串或数字。base – 进制数，默认十进制。</p><p>&gt;&gt;&gt; int(‘0xa’,16)  </p><p>10  </p><p>&gt;&gt;&gt; int(‘10’,8)  </p><p>8</p><p>a&#x3D;int(input(“请输入一个整数”))             #（强制类型转换）</p><h2 id="type-判断对象类型"><a href="#type-判断对象类型" class="headerlink" title="type 判断对象类型"></a>type 判断对象类型</h2><p>首先，我们来判断对象类型，使用<code>type()</code>函数：</p><p>基本类型都可以用<code>type()</code>判断：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haskell">&gt;&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">type</span>(123)</span><br>&lt;<span class="hljs-keyword">class</span> &#x27;int&#x27;&gt;<br>&gt;&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">type</span>(&#x27;<span class="hljs-title">str&#x27;</span>)</span><br>&lt;<span class="hljs-keyword">class</span> &#x27;str&#x27;&gt;<br>&gt;&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">type</span>(<span class="hljs-type">None</span>)</span><br>&lt;<span class="hljs-class"><span class="hljs-keyword">type</span>(<span class="hljs-type">None</span>) &#x27;<span class="hljs-type">NoneType&#x27;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果一个变量指向函数或者类，也可以用<code>type()</code>判断：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(<span class="hljs-built_in">abs</span>)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;builtin_function_or_method&#x27;</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(a)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.Animal&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>但是<code>type()</code>函数返回的是什么类型呢？它返回对应的Class类型。如果我们要在<code>if</code>语句中判断，就需要比较两个变量的type类型是否相同：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">type</span>(<span class="hljs-number">123</span>)==<span class="hljs-built_in">type</span>(<span class="hljs-number">456</span>)</span><br>True<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">type</span>(<span class="hljs-number">123</span>)==<span class="hljs-built_in">int</span></span><br>True<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">type</span>(<span class="hljs-string">&#x27;abc&#x27;</span>)==<span class="hljs-built_in">type</span>(<span class="hljs-string">&#x27;123&#x27;</span>)</span><br>True<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">type</span>(<span class="hljs-string">&#x27;abc&#x27;</span>)==<span class="hljs-built_in">str</span></span><br>True<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">type</span>(<span class="hljs-string">&#x27;abc&#x27;</span>)==<span class="hljs-built_in">type</span>(<span class="hljs-number">123</span>)</span><br>False<br></code></pre></td></tr></table></figure><p>判断基本数据类型可以直接写<code>int</code>，<code>str</code>等，但如果要判断一个对象是否是函数怎么办？可以使用<code>types</code>模块中定义的常量：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">import</span> types</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fn</span>():</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    <span class="hljs-keyword">pass</span></span><br><span class="hljs-meta prompt_">...</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">type</span>(fn)==types.FunctionType</span><br>True<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">type</span>(<span class="hljs-built_in">abs</span>)==types.BuiltinFunctionType</span><br>True<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">type</span>(<span class="hljs-keyword">lambda</span> x: x)==types.LambdaType</span><br>True<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">type</span>((x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)))==types.GeneratorType</span><br>True<br></code></pre></td></tr></table></figure><h2 id="isinstance-判断类型是否相同"><a href="#isinstance-判断类型是否相同" class="headerlink" title="isinstance 判断类型是否相同"></a>isinstance 判断类型是否相同</h2><p>isinstance(object, classinfo)     如果对象的类型与参数二的类型（classinfo）相同则返回 True，否则返回 False</p><p>object – 实例对象。</p><p>classinfo – 可以是直接或间接类名、基本类型或者由它们组成的元组。</p><p>能用<code>type()</code>判断的基本类型也可以用<code>isinstance()</code>判断：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-built_in">str</span>)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(<span class="hljs-number">123</span>, <span class="hljs-built_in">int</span>)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(<span class="hljs-string">b&#x27;a&#x27;</span>, <span class="hljs-built_in">bytes</span>)<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>并且还可以判断一个变量是否是某些类型中的一种，比如下面的代码就可以判断是否是list或者tuple：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], (<span class="hljs-built_in">list</span>, <span class="hljs-built_in">tuple</span>))<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>), (<span class="hljs-built_in">list</span>, <span class="hljs-built_in">tuple</span>))<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#判断传入的参数是否正确</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(x, (<span class="hljs-built_in">int</span>, <span class="hljs-built_in">float</span>)):<br>        <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&#x27;bad operand type&#x27;</span>)<br></code></pre></td></tr></table></figure><p>isinstance() 与 type() 区别：</p><p>type() 不会认为子类是一种父类类型，不考虑继承关系。</p><p>isinstance() 会认为子类是一种父类类型，考虑继承关系。</p><p>如果要判断两个类型是否相同推荐使用 isinstance()。</p><h2 id="dir-获得对象的所有属性和方法"><a href="#dir-获得对象的所有属性和方法" class="headerlink" title="dir 获得对象的所有属性和方法"></a>dir 获得对象的所有属性和方法</h2><p>如果要获得一个对象的所有属性和方法，可以使用<code>dir()</code>函数，它返回一个包含字符串的list，比如，获得一个str对象的所有属性和方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">dir</span>(<span class="hljs-string">&#x27;ABC&#x27;</span>)<br>[<span class="hljs-string">&#x27;__add__&#x27;</span>, <span class="hljs-string">&#x27;__class__&#x27;</span>,..., <span class="hljs-string">&#x27;__subclasshook__&#x27;</span>, <span class="hljs-string">&#x27;capitalize&#x27;</span>, <span class="hljs-string">&#x27;casefold&#x27;</span>,..., <span class="hljs-string">&#x27;zfill&#x27;</span>]<br></code></pre></td></tr></table></figure><p>类似<code>__xxx__</code>的属性和方法在Python中都是有特殊用途的，比如<code>__len__</code>方法返回长度。在Python中，如果你调用<code>len()</code>函数试图获取一个对象的长度，实际上，在<code>len()</code>函数内部，它自动去调用该对象的<code>__len__()</code>方法，所以，下面的代码是等价的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">len</span>(<span class="hljs-string">&#x27;ABC&#x27;</span>)<br><span class="hljs-number">3</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;ABC&#x27;</span>.__len__()<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h2 id="二次三次方根"><a href="#二次三次方根" class="headerlink" title="二次三次方根"></a>二次三次方根</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">9</span>*<span class="hljs-number">9</span><br>== <span class="hljs-number">9</span>**<span class="hljs-number">2</span><br><br><span class="hljs-number">9</span>*<span class="hljs-number">9</span>*<span class="hljs-number">9</span><br>== <span class="hljs-number">9</span>**<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h1 id="math模块的一些方法"><a href="#math模块的一些方法" class="headerlink" title="math模块的一些方法"></a>math模块的一些方法</h1><h2 id="math-modf-分离小数和整数部分"><a href="#math-modf-分离小数和整数部分" class="headerlink" title="math.modf(分离小数和整数部分)"></a>math.modf(分离小数和整数部分)</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>modf() 方法返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>以下展示了使用 modf() 方法的实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math   <span class="hljs-comment"># This will import math module</span><br><br><span class="hljs-built_in">print</span>( math.modf(-<span class="hljs-number">100.12</span>) )<br><span class="hljs-built_in">print</span>( math.modf(-<span class="hljs-number">100.12</span>)[<span class="hljs-number">0</span>] )<br></code></pre></td></tr></table></figure><p>以上实例运行后输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">(-<span class="hljs-number">0.12000000000000455</span>, -<span class="hljs-number">100.0</span>)<br>-<span class="hljs-number">0.12000000000000455</span><br></code></pre></td></tr></table></figure><h1 id="用户自定义函数"><a href="#用户自定义函数" class="headerlink" title="用户自定义函数"></a>用户自定义函数</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_abs</span>(<span class="hljs-params">x</span>):<br><br>   <span class="hljs-keyword">if</span> x &gt;= <span class="hljs-number">0</span>:<br><br>      <span class="hljs-keyword">return</span> x<br><br>   <span class="hljs-keyword">else</span>:<br><br>       <span class="hljs-keyword">return</span> -x<br></code></pre></td></tr></table></figure><p>（导入其他文件内的函数的方法）如果你已经把<code>my_abs()</code>的函数定义保存为<code>abs.py</code>文件了，那么，可以在该文件的当前目录下启动Python解释器，用<code>from abs import my_abs</code>来导入<code>my_abs()</code>函数，注意<code>abs</code>是文件名（不含<code>.py</code>扩展名）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> <span class="hljs-built_in">abs</span> <span class="hljs-keyword">import</span> my_abs<br><span class="hljs-meta">&gt;&gt;&gt; </span>my_abs(-<span class="hljs-number">9</span>) <br><span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><h2 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#pass语句，实际上pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来。但是缺少了pass，代码运行就会有语法错误。</span><br><span class="hljs-keyword">if</span> age &gt;= <span class="hljs-number">18</span>:<br><span class="hljs-keyword">pass</span><br> <br>函数返回多个值<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_two</span>(<span class="hljs-params">x, y</span>):<br>    x = x + <span class="hljs-number">1</span><br>    y = y + <span class="hljs-number">2</span><br><span class="hljs-keyword">return</span> x, y<br> <br><span class="hljs-meta">&gt;&gt;&gt; </span>x = y = <span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>x, y = add_two(x,y)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(x, y)<br><span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>r = add_two(x,y)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(r)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>其实返回值是一个tuple(静态数组)！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。</p><p>函数的传入参数<br>函数传入list要特别小心，函数内的修改会影响其本身，类似C中的指针对list产生了修改。<br>关键字传值(带**的传值)传入的是值，不会影响原来的内容。</p><h2 id="函数的输入"><a href="#函数的输入" class="headerlink" title="函数的输入"></a>函数的输入</h2><h3 id="函数的默认参数"><a href="#函数的默认参数" class="headerlink" title="函数的默认参数"></a>函数的默认参数</h3><p>默认参数。由于我们经常计算x2，所以，完全可以把第二个参数n的默认值设定为2：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">power</span>(<span class="hljs-params">x, n=<span class="hljs-number">2</span></span>):<br>    s = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> n &gt; <span class="hljs-number">0</span>:<br>        n = n - <span class="hljs-number">1</span><br>        s = s * x<br>    <span class="hljs-keyword">return</span> s<br></code></pre></td></tr></table></figure><p>调用时可以 power(5) 直接计算5的2次方，也可以power(5,3)计算5的3次方。即默认参数可以传入也可以不传入。<br>定义默认参数要牢记一点：默认参数必须指向不变对象！</p><p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431752945034eb82ac80a3e64b9bb4929b16eeed1eb9000">具体可以点击此处参考</a></p><h3 id="输入可变长变量"><a href="#输入可变长变量" class="headerlink" title="输入可变长变量"></a>输入可变长变量</h3><p>可变长度的传入变量，加了星号（*）的变量名会存放所有未命名的变量参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">printinfo</span>(<span class="hljs-params"> *vartuple </span>):<br>   <span class="hljs-string">&quot;打印任何传入的参数&quot;</span><br>   <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;输出: &quot;</span><br>   <span class="hljs-keyword">for</span> var <span class="hljs-keyword">in</span> vartuple:<br>      <span class="hljs-built_in">print</span> var<br>   <span class="hljs-keyword">return</span>;<br><br> <br><span class="hljs-comment"># 调用printinfo 函数</span><br>printinfo( <span class="hljs-number">10</span> );<br>printinfo( <span class="hljs-number">70</span>, <span class="hljs-number">60</span>, <span class="hljs-number">50</span> );<br></code></pre></td></tr></table></figure><h3 id="关键字参数（字典-dict-参数）"><a href="#关键字参数（字典-dict-参数）" class="headerlink" title="关键字参数（字典(dict)参数）"></a>关键字参数（字典(dict)参数）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">person</span>(<span class="hljs-params">name, age, **kw</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;name:&#x27;</span>, name, <span class="hljs-string">&#x27;age:&#x27;</span>, age, <span class="hljs-string">&#x27;other:&#x27;</span>, kw)<br> <br><span class="hljs-meta">&gt;&gt;&gt; </span>person(<span class="hljs-string">&#x27;Michael&#x27;</span>, <span class="hljs-number">30</span>)<br>name: Michael age: <span class="hljs-number">30</span> other: &#123;&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>person(<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-number">35</span>, city=<span class="hljs-string">&#x27;Beijing&#x27;</span>)<br>name: Bob age: <span class="hljs-number">35</span> other: &#123;<span class="hljs-string">&#x27;city&#x27;</span>: <span class="hljs-string">&#x27;Beijing&#x27;</span>&#125;<br><span class="hljs-comment">#如果函数内使用了某个关键字参数，但调用时没有传入，代码会有异常</span><br><span class="hljs-comment">#如果要限制只能传指定名字的参数，则可以使用命名关键字参数</span><br></code></pre></td></tr></table></figure><h3 id="命名关键词参数"><a href="#命名关键词参数" class="headerlink" title="命名关键词参数"></a>命名关键词参数</h3> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#命名关键字参数，是对关键字参数方式的进一步约束，更安全了</span><br><span class="hljs-comment">#定义需要一个*号作为分隔符，*后面的参数表示只能传递该名字的参数</span><br><span class="hljs-comment">#如下表示两个位置参数，还有两个名为city和job的关键字参数，调用时传其它名字会报错</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">person</span>(<span class="hljs-params">name, age, *, city, job</span>):<br>    <span class="hljs-built_in">print</span>(name, age, city, job)<br></code></pre></td></tr></table></figure><p>和关键字参数<code>**kw</code>不同，命名关键字参数需要一个特殊分隔符<code>*</code>，<code>*</code>后面的参数被视为命名关键字参数。</p><p>调用方式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>person(<span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-number">24</span>, city=<span class="hljs-string">&#x27;Beijing&#x27;</span>, job=<span class="hljs-string">&#x27;Engineer&#x27;</span>)<br>Jack <span class="hljs-number">24</span> Beijing Engineer<br></code></pre></td></tr></table></figure><p>添加缺省值，从而简化调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">person</span>(<span class="hljs-params">name, age, *, city=<span class="hljs-string">&#x27;Beijing&#x27;</span>, job</span>):<br>    <span class="hljs-built_in">print</span>(name, age, city, job)<br></code></pre></td></tr></table></figure><p>由于命名关键字参数<code>city</code>具有默认值，调用时，可不传入<code>city</code>参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>person(<span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-number">24</span>, job=<span class="hljs-string">&#x27;Engineer&#x27;</span>)<br>Jack <span class="hljs-number">24</span> Beijing Engineer<br></code></pre></td></tr></table></figure><h1 id="匿名函数lambda"><a href="#匿名函数lambda" class="headerlink" title="匿名函数lambda"></a>匿名函数lambda</h1><p>python 使用 lambda 来创建匿名函数。</p><ul><li>lambda只是一个表达式，函数体比def简单很多。</li><li>lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。</li><li>lambda函数拥有自己的命名空间，且不能访问自有参数列表之外或全局命名空间里的参数。</li><li>虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。</li></ul><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p>lambda函数的语法只包含一个语句，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">lambda</span> [arg1 [,arg2,.....argn]]:expression<br></code></pre></td></tr></table></figure><p>如下实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 可写函数说明</span><br><span class="hljs-built_in">sum</span> = <span class="hljs-keyword">lambda</span> arg1, arg2: arg1 + arg2;<br> <br><span class="hljs-comment"># 调用sum函数</span><br><span class="hljs-built_in">print</span>( <span class="hljs-string">&quot;相加后的值为 : &quot;</span>, <span class="hljs-built_in">sum</span>( <span class="hljs-number">10</span>, <span class="hljs-number">20</span> ))<br><span class="hljs-built_in">print</span>( <span class="hljs-string">&quot;相加后的值为 : &quot;</span>, <span class="hljs-built_in">sum</span>( <span class="hljs-number">20</span>, <span class="hljs-number">20</span> ))<br></code></pre></td></tr></table></figure><h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><h2 id="面向过程-和-面向对象的对比"><a href="#面向过程-和-面向对象的对比" class="headerlink" title="面向过程 和 面向对象的对比"></a>面向过程 和 面向对象的对比</h2><p>Q：存储学生的信息并打印出来</p><p><strong>面向过程</strong></p><p> 假设我们要处理学生的成绩表，为了表示一个学生的成绩，面向过程的程序可以用一个dict表示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">std1 = &#123; <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Michael&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">98</span> &#125;<br>std2 = &#123; <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">81</span> &#125;<br></code></pre></td></tr></table></figure><p>而处理学生成绩可以通过函数实现，比如打印学生的成绩：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_score</span>(<span class="hljs-params">std</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%s: %s&#x27;</span> % (std[<span class="hljs-string">&#x27;name&#x27;</span>], std[<span class="hljs-string">&#x27;score&#x27;</span>]))<br></code></pre></td></tr></table></figure><p><strong>面向对象</strong></p><p>如果采用面向对象的程序设计思想，我们首选思考的不是程序的执行流程，而是<code>Student</code>这种数据类型应该被视为一个对象，这个对象拥有<code>name</code>和<code>score</code>这两个属性（Property）。如果要打印一个学生的成绩，首先必须创建出这个学生对应的对象，然后，给对象发一个<code>print_score</code>消息，让对象自己把自己的数据打印出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, score</span>):<br>        <span class="hljs-variable language_">self</span>.name = name<br>        <span class="hljs-variable language_">self</span>.score = score<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">print_score</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%s: %s&#x27;</span> % (<span class="hljs-variable language_">self</span>.name, <span class="hljs-variable language_">self</span>.score))<br></code></pre></td></tr></table></figure><p>给对象发消息实际上就是调用对象对应的关联函数，我们称之为对象的方法（Method）。面向对象的程序写出来就像这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">bart = Student(<span class="hljs-string">&#x27;Bart Simpson&#x27;</span>, <span class="hljs-number">59</span>)<br>lisa = Student(<span class="hljs-string">&#x27;Lisa Simpson&#x27;</span>, <span class="hljs-number">87</span>)<br>bart.print_score()<br>lisa.print_score()<br></code></pre></td></tr></table></figure><h2 id="类、实例、方法和属性"><a href="#类、实例、方法和属性" class="headerlink" title="类、实例、方法和属性"></a>类、实例、方法和属性</h2><ul><li>类 Student</li><li>实例 jack</li><li>方法 print_score</li><li>属性 obj_name</li><li>增加属性 gender</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>): <span class="hljs-comment">#Student是类</span><br>    obj_name = <span class="hljs-string">&#x27;this is obj name str！&#x27;</span><span class="hljs-comment">#这个类有一个属性（类属性）</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, score</span>):  <span class="hljs-comment">#特殊方法“__init__”前后分别有两个下划线！！！</span><br>        <span class="hljs-variable language_">self</span>.name = name<br>        <span class="hljs-variable language_">self</span>.score = score<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">print_score</span>(<span class="hljs-params">self</span>):<span class="hljs-comment">#print_score 这个函数就是方法</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%s: %s&#x27;</span> % (<span class="hljs-variable language_">self</span>.name, <span class="hljs-variable language_">self</span>.score))<br>        <br>jack = Student(<span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-number">95</span>)  <span class="hljs-comment">#jack是实例</span><br>jack.gender = <span class="hljs-string">&#x27;man&#x27;</span> <span class="hljs-comment">#此处加了一个属性（实例属性）</span><br><br><span class="hljs-built_in">print</span> (<span class="hljs-string">&#x27;%s is a %s&#x27;</span> % (jack.name, jack.gender))<span class="hljs-comment">#输出 增加的实例属性</span><br><span class="hljs-built_in">print</span> (<span class="hljs-string">&#x27;%s&#x27;</span> % (jack.obj_name))<span class="hljs-comment">#输出类属性</span><br><span class="hljs-built_in">print</span> (<span class="hljs-string">&#x27;Hi,%s your score is %s&#x27;</span> % (jack.name, jack.score))<span class="hljs-comment">#输出实例的属性</span><br><span class="hljs-comment">#运行结果</span><br>Jack <span class="hljs-keyword">is</span> a man<br>this <span class="hljs-keyword">is</span> obj name <span class="hljs-built_in">str</span>！<br>Hi，Jack yours score <span class="hljs-keyword">is</span> <span class="hljs-number">95</span><br></code></pre></td></tr></table></figure><h3 id="类-实例"><a href="#类-实例" class="headerlink" title="类 实例"></a>类 实例</h3><p>类是创建实例的模板，而实例则是一个一个具体的对象，各个实例拥有的数据都互相独立，互不影响；</p><hr><p>面向对象最重要的概念就是<strong>类（Class）</strong>和<strong>实例（Instance）</strong>，必须牢记类是抽象的模板，比如Student类，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的<strong>方法</strong>，但各自的数据可能不同。</p><p>仍以Student类为例，在Python中，定义类是通过<code>class</code>关键字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>): <span class="hljs-comment">#Student是类</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, score</span>):  <span class="hljs-comment">#特殊方法“__init__”前后分别有两个下划线！！！</span><br>        <span class="hljs-variable language_">self</span>.name = name<br>        <span class="hljs-variable language_">self</span>.score = score<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">print_score</span>(<span class="hljs-params">self</span>):<span class="hljs-comment">#这就是方法</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%s: %s&#x27;</span> % (<span class="hljs-variable language_">self</span>.name, <span class="hljs-variable language_">self</span>.score))<br></code></pre></td></tr></table></figure><p><code>class</code>后面紧接着是类名，即<code>Student</code>，类名通常是大写开头的单词，紧接着是<code>(object)</code>，表示该类是从哪个类继承下来的，继承的概念我们后面再讲，通常，如果没有合适的继承类，就使用<code>object</code>类，这是所有类最终都会继承的类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">jack = Student(<span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-number">95</span>)     <span class="hljs-comment">#jack是实例</span><br></code></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p><strong>方法</strong>就是与实例绑定的函数，和普通函数不同，方法可以直接访问实例的数据；</p><hr><p>面向对象编程的一个重要特点就是数据封装。在上面的<code>Student</code>类中，每个实例就拥有各自的<code>name</code>和<code>score</code>这些数据。我们可以通过函数来访问这些数据，比如打印一个学生的成绩：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_score</span>(<span class="hljs-params">std</span>):<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%s: %s&#x27;</span> % (std.name, std.score))<br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>print_score(bart)<br>Bart Simpson: <span class="hljs-number">59</span><br></code></pre></td></tr></table></figure><p>但是，既然<code>Student</code>实例本身就拥有这些数据，要访问这些数据，就没有必要从外面的函数去访问，可以直接在<code>Student</code>类的内部定义访问数据的函数，这样，就把“数据”给封装起来了。这些封装数据的函数是和<code>Student</code>类本身是关联起来的，我们称之为类的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, score</span>):<br>        <span class="hljs-variable language_">self</span>.name = name<br>        <span class="hljs-variable language_">self</span>.score = score<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">print_score</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%s: %s&#x27;</span> % (<span class="hljs-variable language_">self</span>.name, <span class="hljs-variable language_">self</span>.score))<br></code></pre></td></tr></table></figure><p>要定义一个方法，除了第一个参数是<code>self</code>外，其他和普通函数一样。要调用一个方法，只需要在实例变量上直接调用，除了<code>self</code>不用传递，其他参数正常传入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bart.print_score()<br>Bart Simpson: <span class="hljs-number">59</span><br></code></pre></td></tr></table></figure><h3 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h3><ul><li>实例增加属性</li></ul><p>类相当于一个模板，用模板（类）定义实例后，实例还可以再加其他属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>): <span class="hljs-comment">#Student是类</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, score</span>):  <span class="hljs-comment">#特殊方法“__init__”前后分别有两个下划线！！！</span><br>        <span class="hljs-variable language_">self</span>.name = name<br>        <span class="hljs-variable language_">self</span>.score = score<br><br>jack = Student(<span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-number">95</span>)<br>jack.gender = <span class="hljs-string">&#x27;man&#x27;</span> <span class="hljs-comment">#此处加了一个属性</span><br><br><br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;%s is a %s&quot;</span> % (jack.name, jack.gender))<br></code></pre></td></tr></table></figure><h2 id="访问限制-private"><a href="#访问限制-private" class="headerlink" title="访问限制 private"></a>访问限制 private</h2><p>外部无法访问，只能通过方法访问（私有变量）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, score</span>):<br>        <span class="hljs-variable language_">self</span>.__name = name<span class="hljs-comment">#变成私有变量（private）了</span><br>        <span class="hljs-variable language_">self</span>.__score = score<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">print_score</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%s: %s&#x27;</span> % (<span class="hljs-variable language_">self</span>.__name, <span class="hljs-variable language_">self</span>.__score))<br></code></pre></td></tr></table></figure><hr><p>需要注意的是，在Python中，变量名类似<code>__xxx__</code>的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用<code>__name__</code>、<code>__score__</code>这样的变量名。</p><p>有些时候，你会看到以一个下划线开头的实例变量名，比如<code>_name</code>，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。</p><p>双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问<code>__name</code>是因为Python解释器对外把<code>__name</code>变量改成了<code>_Student__name</code>，所以，仍然可以通过<code>_Student__name</code>来访问<code>__name</code>变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bart._Student__name<br><span class="hljs-string">&#x27;Bart Simpson&#x27;</span><br></code></pre></td></tr></table></figure><p>但是强烈建议你不要这么干，因为不同版本的Python解释器可能会把<code>__name</code>改成不同的变量名。</p><p>总的来说就是，Python本身没有任何机制阻止你干坏事，一切全靠自觉。</p><p>最后注意下面的这种<strong>错误写法</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bart = Student(<span class="hljs-string">&#x27;Bart Simpson&#x27;</span>, <span class="hljs-number">59</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bart.get_name()<br><span class="hljs-string">&#x27;Bart Simpson&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>bart.__name = <span class="hljs-string">&#x27;New Name&#x27;</span> <span class="hljs-comment"># 设置__name变量！</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>bart.__name<br><span class="hljs-string">&#x27;New Name&#x27;</span><br></code></pre></td></tr></table></figure><p>表面上看，外部代码“成功”地设置了<code>__name</code>变量，但实际上这个<code>__name</code>变量和class内部的<code>__name</code>变量<em>不是</em>一个变量！内部的<code>__name</code>变量已经被Python解释器自动改成了<code>_Student__name</code>，而外部代码给<code>bart</code>新增了一个<code>__name</code>变量。不信试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bart.get_name() <span class="hljs-comment"># get_name()内部返回self.__name</span><br><span class="hljs-string">&#x27;Bart Simpson&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p><strong>用组合的方式建立了类与组合的类之间的关系，它是一种‘有’的关系,比如教授有生日，教授教python课程</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BirthDate</span>:    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,year,month,day</span>):<br>        <span class="hljs-variable language_">self</span>.year=year<br>        <span class="hljs-variable language_">self</span>.month=month<br>        <span class="hljs-variable language_">self</span>.day=day<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Couse</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,name,price,period</span>):<br>        <span class="hljs-variable language_">self</span>.name=name<br>        <span class="hljs-variable language_">self</span>.price=price<br>        <span class="hljs-variable language_">self</span>.period=period<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,name,gender,birth,course</span>):<br>        <span class="hljs-variable language_">self</span>.name=name <br>        <span class="hljs-variable language_">self</span>.gender=gender<br>        <span class="hljs-variable language_">self</span>.birth=birth<br>        <span class="hljs-variable language_">self</span>.course=course<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">teach</span>(<span class="hljs-params">self</span>): <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;teaching&#x27;</span>)<br>p1=Teacher(<span class="hljs-string">&#x27;egon&#x27;</span>,<span class="hljs-string">&#x27;male&#x27;</span>, <br>            BirthDate(<span class="hljs-string">&#x27;1995&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;27&#x27;</span>), <br>            Couse(<span class="hljs-string">&#x27;python&#x27;</span>,<span class="hljs-string">&#x27;28000&#x27;</span>,<span class="hljs-string">&#x27;4 months&#x27;</span>)<br>           ) <br><br><span class="hljs-built_in">print</span>(p1.birth.year,p1.birth.month,p1.birth.day) <br><br><span class="hljs-built_in">print</span>(p1.course.name,p1.course.price,p1.course.period)<br><span class="hljs-string">&#x27;&#x27;&#x27; </span><br><span class="hljs-string">运行结果: </span><br><span class="hljs-string">1 27 </span><br><span class="hljs-string">python 28000 4 months </span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>当类之间有显著不同，并且较小的类是较大的类所需要的组件时，用组合比较好</strong></p><h2 id="继承-多态"><a href="#继承-多态" class="headerlink" title="继承 多态"></a>继承 多态</h2><ul><li>抽象：抽象即抽取类似或者说比较像的部分。是一个从具题到抽象的过程。</li><li>继承：子类继承了父类的方法和属性</li><li>派生：子类在父类方法和属性的基础上产生了新的方法和属性</li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li>建立一个新类（子类 Subclass）可以copy一份原来类（父类 基类或超类 Base class、Super class）的全部功能（方法、变量 等）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-title class_ inherited__">object</span>):<span class="hljs-comment">#父类</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Animal is running...&#x27;</span>)<br>        <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-title class_ inherited__">Animal</span>):<span class="hljs-comment">#子类</span><br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment">#运行结果</span><br>Animal <span class="hljs-keyword">is</span> running...<span class="hljs-comment">#子类有了父类的方法</span><br></code></pre></td></tr></table></figure><ul><li>当子类和父类都存在相同的<code>run()</code>方法时，我们说，子类的<code>run()</code>覆盖了父类的<code>run()</code>，在代码运行的时候，总是会调用子类的<code>run()</code>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-title class_ inherited__">object</span>):<span class="hljs-comment">#父类</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Animal is running...&#x27;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-title class_ inherited__">Animal</span>):<span class="hljs-comment">#子类</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Dog is running...&#x27;</span>)<br><br><span class="hljs-comment">#运行结果</span><br>Dog <span class="hljs-keyword">is</span> running...<span class="hljs-comment">#子类覆盖了父类的方法</span><br></code></pre></td></tr></table></figure><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p><strong>就是一个集合的概念，子类包含了父类，子类比父类范围更大，这种好处是通用性更强</strong></p><ul><li>子类继承了父类的类型，子类既是  <strong>子类类型</strong>  也是  <strong>父类类型</strong>  </li><li>传入类型设置为  父类   可以有很好的通用性</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-title class_ inherited__">object</span>):<span class="hljs-comment">#父类</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Animal is running...&#x27;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-title class_ inherited__">Animal</span>):<span class="hljs-comment">#子类</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Dog is running...&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run_twice</span>(<span class="hljs-params">animal</span>):<span class="hljs-comment">#因为传入的是 父类 所以子类父类都可以用    有很好通用性</span><br>    animal.run()<br>    animal.run()<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>run_twice(Animal())<br>Animal <span class="hljs-keyword">is</span> running...<br>Animal <span class="hljs-keyword">is</span> running...<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>run_twice(Dog())<br>Dog <span class="hljs-keyword">is</span> running...<br>Dog <span class="hljs-keyword">is</span> running...<br></code></pre></td></tr></table></figure><hr><p>要理解什么是多态，我们首先要对数据类型再作一点说明。当我们定义一个class的时候，我们实际上就定义了一种数据类型。我们定义的数据类型和Python自带的数据类型，比如str、list、dict没什么两样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-built_in">list</span>() <span class="hljs-comment"># a是list类型</span><br>b = Animal() <span class="hljs-comment"># b是Animal类型</span><br>c = Dog() <span class="hljs-comment"># c是Dog类型</span><br></code></pre></td></tr></table></figure><p>判断一个变量是否是某个类型可以用<code>isinstance()</code>判断：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(a, <span class="hljs-built_in">list</span>)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(b, Animal)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(c, Dog)<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>看来<code>a</code>、<code>b</code>、<code>c</code>确实对应着<code>list</code>、<code>Animal</code>、<code>Dog</code>这3种类型。</p><p>但是等等，试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(c, Animal)<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>看来<code>c</code>不仅仅是<code>Dog</code>，<code>c</code>还是<code>Animal</code>！</p><p>不过仔细想想，这是有道理的，因为<code>Dog</code>是从<code>Animal</code>继承下来的，当我们创建了一个<code>Dog</code>的实例<code>c</code>时，我们认为<code>c</code>的数据类型是<code>Dog</code>没错，但<code>c</code>同时也是<code>Animal</code>也没错，<code>Dog</code>本来就是<code>Animal</code>的一种！</p><p>所以，在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。但是，反过来就不行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>b = Animal()<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(b, Dog)<br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p><code>Dog</code>可以看成<code>Animal</code>，但<code>Animal</code>不可以看成<code>Dog</code>。</p><p>要理解多态的好处，我们还需要再编写一个函数，这个函数接受一个<code>Animal</code>类型的变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">run_twice</span>(<span class="hljs-params">animal</span>):<br>    animal.run()<br>    animal.run()<br></code></pre></td></tr></table></figure><p>当我们传入<code>Animal</code>的实例时，<code>run_twice()</code>就打印出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>run_twice(Animal())<br>Animal <span class="hljs-keyword">is</span> running...<br>Animal <span class="hljs-keyword">is</span> running...<br></code></pre></td></tr></table></figure><p>当我们传入<code>Dog</code>的实例时，<code>run_twice()</code>就打印出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>run_twice(Dog())<br>Dog <span class="hljs-keyword">is</span> running...<br>Dog <span class="hljs-keyword">is</span> running...<br></code></pre></td></tr></table></figure><p>当我们传入<code>Cat</code>的实例时，<code>run_twice()</code>就打印出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>run_twice(Cat())<br>Cat <span class="hljs-keyword">is</span> running...<br>Cat <span class="hljs-keyword">is</span> running...<br></code></pre></td></tr></table></figure><p>看上去没啥意思，但是仔细想想，现在，如果我们再定义一个<code>Tortoise</code>类型，也从<code>Animal</code>派生：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tortoise</span>(<span class="hljs-title class_ inherited__">Animal</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Tortoise is running slowly...&#x27;</span>)<br></code></pre></td></tr></table></figure><p>当我们调用<code>run_twice()</code>时，传入<code>Tortoise</code>的实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>run_twice(Tortoise())<br>Tortoise <span class="hljs-keyword">is</span> running slowly...<br>Tortoise <span class="hljs-keyword">is</span> running slowly...<br></code></pre></td></tr></table></figure><p>你会发现，新增一个<code>Animal</code>的子类，不必对<code>run_twice()</code>做任何修改，实际上，任何依赖<code>Animal</code>作为参数的函数或者方法都可以不加修改地正常运行，原因就在于多态。</p><p>多态的好处就是，当我们需要传入<code>Dog</code>、<code>Cat</code>、<code>Tortoise</code>……时，我们只需要接收<code>Animal</code>类型就可以了，因为<code>Dog</code>、<code>Cat</code>、<code>Tortoise</code>……都是<code>Animal</code>类型，然后，按照<code>Animal</code>类型进行操作即可。由于<code>Animal</code>类型有<code>run()</code>方法，因此，传入的任意类型，只要是<code>Animal</code>类或者子类，就会自动调用实际类型的<code>run()</code>方法，这就是多态的意思：</p><p>对于一个变量，我们只需要知道它是<code>Animal</code>类型，无需确切地知道它的子类型，就可以放心地调用<code>run()</code>方法，而具体调用的<code>run()</code>方法是作用在<code>Animal</code>、<code>Dog</code>、<code>Cat</code>还是<code>Tortoise</code>对象上，由运行时该对象的确切类型决定，这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种<code>Animal</code>的子类时，只要确保<code>run()</code>方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则：</p><p>对扩展开放：允许新增<code>Animal</code>子类；</p><p>对修改封闭：不需要修改依赖<code>Animal</code>类型的<code>run_twice()</code>等函数。</p><p>继承还可以一级一级地继承下来，就好比从爷爷到爸爸、再到儿子这样的关系。而任何类，最终都可以追溯到根类object，这些继承关系看上去就像一颗倒着的树。比如如下的继承树：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ascii">                ┌───────────────┐<br>                │    object     │<br>                └───────────────┘<br>                        │<br>           ┌────────────┴────────────┐<br>           │                         │<br>           ▼                         ▼<br>    ┌─────────────┐           ┌─────────────┐<br>    │   Animal    │           │    Plant    │<br>    └─────────────┘           └─────────────┘<br>           │                         │<br>     ┌─────┴──────┐            ┌─────┴──────┐<br>     │            │            │            │<br>     ▼            ▼            ▼            ▼<br>┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐<br>│   Dog   │  │   Cat   │  │  Tree   │  │ Flower  │<br>└─────────┘  └─────────┘  └─────────┘  └─────────┘<br></code></pre></td></tr></table></figure><h4 id="静态语言-vs-动态语言"><a href="#静态语言-vs-动态语言" class="headerlink" title="静态语言 vs 动态语言"></a>静态语言 vs 动态语言</h4><p>对于静态语言（例如Java）来说，如果需要传入<code>Animal</code>类型，则传入的对象必须是<code>Animal</code>类型或者它的子类，否则，将无法调用<code>run()</code>方法。</p><p>对于Python这样的动态语言来说，则不一定需要传入<code>Animal</code>类型。我们只需要保证传入的对象有一个<code>run()</code>方法就可以了：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Timer</span>(object):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>        print(<span class="hljs-string">&#x27;Start...&#x27;</span>)<br></code></pre></td></tr></table></figure><p>这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</p><p>Python的“file-like object“就是一种鸭子类型。对真正的文件对象，它有一个<code>read()</code>方法，返回其内容。但是，许多对象，只要有<code>read()</code>方法，都被视为“file-like object“。许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了<code>read()</code>方法的对象。</p><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p><strong>抽象类是一个特殊的类，它的特殊之处在于只能被继承，不能被实例化</strong></p><p><em>比如我们有香蕉的类，有苹果的类，有桃子的类，从这些类抽取相同的内容就是水果这个抽象的类，你吃水果时，要么是吃一个具体的香蕉，要么是吃一个具体的桃子。。。。。。你永远无法吃到一个叫做水果的东西</em></p><p><em>从实现角度来看，抽象类与普通类的不同之处在于：抽象类中有抽象方法，该类不能被实例化，只能被继承，且子类必须实现抽象方法。这一点与接口有点类似，但其实是不同的，即将揭晓答案</em></p><h2 id="经典类和新式类"><a href="#经典类和新式类" class="headerlink" title="经典类和新式类"></a>经典类和新式类</h2><p><img src="/2020/297a89d9/1610094679745.jpg" alt="1610094679745"></p>]]></content>
    
    
    <categories>
      
      <category>language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bluetooth蓝牙</title>
    <link href="/2020/95869d00/"/>
    <url>/2020/95869d00/</url>
    
    <content type="html"><![CDATA[<h1 id="蓝牙分类"><a href="#蓝牙分类" class="headerlink" title="蓝牙分类"></a>蓝牙分类</h1><pre><code class=" mermaid">graph LRBluetooth_3.0 --&gt;BRBluetooth_3.0 --&gt;EDRBluetooth_3.0 --&gt;AMP_HS</code></pre><pre><code class=" mermaid">graph LRBluetooth_4.0 --&gt;BRBluetooth_4.0 --&gt;EDRBluetooth_4.0 --&gt;AMP_HSBluetooth_4.0 --&gt;LE</code></pre><p>只有一种蓝牙即 Bluetooth SIG。</p><p>但是蓝牙技术本身包括四种类型：BR、EDR、AMP 和 LE。</p><p>为了方便，人们将以前的 BR&#x2F;EDR&#x2F;AMP 技术称为“经典蓝牙”（BT）技术。</p><p>LE也即低功耗蓝牙BLE。</p><h1 id="SPP"><a href="#SPP" class="headerlink" title="SPP"></a>SPP</h1><p>SPP（Serial Port Profile）串口</p>]]></content>
    
    
    <categories>
      
      <category>Communication</category>
      
    </categories>
    
    
    <tags>
      
      <tag>embedded</tag>
      
      <tag>bluetooth</tag>
      
      <tag>蓝牙</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SourceInsigh中Qicker的使用</title>
    <link href="/2020/4ade0b2f/"/>
    <url>/2020/4ade0b2f/</url>
    
    <content type="html"><![CDATA[<h1 id="Qicker-em"><a href="#Qicker-em" class="headerlink" title="Qicker.em"></a>Qicker.em</h1><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ol><li><p>代码补全：</p><ul><li><p>wh：       while（）</p></li><li><p>if，ife，ifs：     if，if else， if elseif else</p></li><li><p>for：      for</p></li><li><p>fo：自动生成for语句与for命令相比它直接会定义循环变量</p></li></ul>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> ( ulI = <span class="hljs-number">0</span>; ulI &lt; # ; ulI++ )<br>&#123;<br>    UINT32_T ulI = <span class="hljs-number">0</span>;<br>    #<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>do: do while</li><li>switch：</li><li>case：</li><li>#ifd: #ifdef</li><li>#if：</li><li>cpp ：自动生成适用于c++的c原型说明定义</li><li>struct：</li><li>enum：</li></ul></li><li><p>添加文件头注释： 命令：fi 解释：file  </p></li><li><p>添加函数头注释（.h）： 命令：fi 解释：file </p></li><li><p>增加修改历史列表： 命令：hi （会报错）</p></li><li><p>根据（.c）生成（.h）文件：命令：hdn</p></li><li><p>添加函数说明注释： 命令：fu 解释： function  </p></li><li><p>添加单行注释：（<span style="color:red">不知道为什么没用</span>）</p><ul><li>命令：as 解释： add start    (添加之后 <code>/* add by zhangsan, 20140504, Mantis号:d, 原: */</code> ) </li><li>命令：ms 解释： modify start  (添加之后：<code>/ modify by zhangsan, 20140504, Mantis号:d, 原因: */</code>  ) </li><li>命令：ds 解释： delete start  (添加之后：<code>/ delete by zhangsan, 20140504, Mantis号:d, 原因: */</code>  )</li></ul></li><li><p>添加标记注释： </p><ul><li><p>命令：ab 解释： add begin    (添加之后：<code>/* add begin by zhangsan, 20140504, Mantis号:d 原因: */</code>) </p></li><li><p>命令：mb 解释： modify begin  (添加之后：<code>/* modify begin by zhangsan, 20140504, Mantis号:d 原因: */</code>) </p></li><li><p>命令：me 解释： modify end    (添加之后：<code>/* modify end by zhangsan, 20140504 */</code>)  </p></li><li><p>命令：db 解释： delete begin  (添加之后：<code>/* delete begin by zhangsan, 20140504, Mantis号:d 原因: */</code>) </p></li><li><p>命令：de 解释： delete end    (添加之后：<code>/* delete end by zhangsan, 20140504 */</code>)</p></li></ul></li><li><p>配置命令：</p></li></ol><ul><li>命令：co 解释：config （修改相关配置信息）</li></ul><p> 如何使用呢，以为整个文件添加注释为例，在源文件的任何地方输入命令 fi 之后直接按ctrl + enter(配置的快捷键)即可。</p><h2 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h2><p> source insight有很多宏可以用，这里介绍的宏是quicker.em这个宏，它是华为的一个员工写的，很实用。</p><ol><li><p>安装quicker.em宏</p><ul><li><p>打开base这个工程Project-&gt;Open Project，选择base工程，即可打开；</p></li><li><p>将宏文件quicker.em添加到该base工程中；</p></li><li><p>设置宏的快捷方式：Options-&gt;Key Assignments，找到Marco:AutoExpand,添加快捷键即可，一般推介用Ctrl+Enter组合键。</p></li></ul></li><li><p>HeaderFileCreate，这个宏功能用于自动创建一个.c文件的头文件。</p><p>使用方法：</p><ul><li>创建自定义快捷菜单Options-&gt;Menu Assignments，选择Macro:HeaderFileCreate这一项，将它添加到右边Menu项的Work下，然后点Insert插入，点OK即可。</li><li>打开该.c文件，在work栏就能看到我们刚才添加的自定义快捷菜单HeaderFileCreate，点击它，就自动生产头文件了。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ide</tag>
      
      <tag>sourceinsigh</tag>
      
      <tag>si</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DSlogic协议开发笔记</title>
    <link href="/2020/5ced0506/"/>
    <url>/2020/5ced0506/</url>
    
    <content type="html"><![CDATA[<h1 id="参考资料-smiley"><a href="#参考资料-smiley" class="headerlink" title="参考资料:smiley:"></a>参考资料:smiley:</h1><p><a href="https://sigrok.org/wiki/Protocol_decoder_HOWTO">Protocol decoder HOWTO(新手指导)</a></p><p><a href="https://sigrok.org/wiki/Protocol_decoder_API#register-function">Protocol decoder API</a></p><p><a href="https://sigrok.org/wiki/Protocol_decoder_API/Queries">Protocol decoder API&#x2F;Queries</a></p><h1 id="名词解析"><a href="#名词解析" class="headerlink" title="名词解析"></a>名词解析</h1><ul><li><strong>Protocol Decoders (PDs)</strong></li></ul><p>协议解码器</p><ul><li><strong>libsigrokdecode</strong></li></ul><p>是一个采用C语言编写的共享库,提供了数据流协议解码功能。该协议解码器采用Python(&#x3D; 3.0)编写。 </p><h1 id="Decoder-class-functions"><a href="#Decoder-class-functions" class="headerlink" title="Decoder class functions"></a>Decoder class functions</h1><h2 id="必须的函数"><a href="#必须的函数" class="headerlink" title="必须的函数"></a>必须的函数</h2><ul><li>start(self)</li></ul><p> 这个函数在解码开始之前被调用。这里可以  [register()](#Decoder registration) 输出类型，检查用户提供的PD选项的有效性，等等。 </p><ul><li>decode(self) （解码）</li></ul><p>在 <strong>non-stacked</strong> 解码器中，这个函数由libsigrokdecode后端调用以开始解码。它不接受任何参数，而是进入一个无限循环，并通过调用更通用的wait()方法获取样本。这使得特定的协议解码器从繁琐但常见的任务中解放出来，比如检测边缘，或者在相对于当前位置的特定时间点采样信号。</p><p>  注意:这个decode(self)方法的签名已经在协议解码器API的第三版中引入，在以前的版本中只有decode(self、startsample、endsample、data)是可用的。</p><ul><li>decode(self, startsample, endsample, data)</li></ul><p>…</p><h2 id="可选的函数"><a href="#可选的函数" class="headerlink" title="可选的函数"></a>可选的函数</h2><ul><li>metadata(self, key, value)（  元数据 ）</li></ul><p> 用于传递关于数据流的解码器元数据。目前 <strong><code>key</code></strong>  的唯一值是sigrokdecode.SRD_CONF_SAMPLERATE， <strong><code>value</code></strong>  则为数据流的采样率（samplerate），单位为Hz。 </p><h1 id="Decoder-registration"><a href="#Decoder-registration" class="headerlink" title="Decoder registration"></a>Decoder registration</h1><p> 解码器类必须包含几个指定PD元数据的属性。可以使用以下关键字：</p><p><a href="https://sigrok.org/wiki/Protocol_decoder_API">原文查考 Decoder registration 章节</a></p><table><thead><tr><th>Key</th><th>Description</th></tr></thead><tbody><tr><td><strong><code>api_version</code></strong></td><td>这个模块使用的libsigrokdecode API版本。现在不是2就是3。</td></tr><tr><td><strong><code>id</code></strong></td><td>此协议解码器的简短唯一标识符。它应该是全小写的，只包含a-z, 0-9和下划线。这必须匹配PD的Python模块名(decoders目录中的子目录名)。siglock -cli工具使用它在命令行上指定PDs。例如:’jtag’， ‘sdcard_spi’， ‘uart’。</td></tr><tr><td><strong><code>name</code></strong></td><td>解码器的名称。当列出可用的PDs时使用。例如:“JTAG”，“SD卡(SPI模式)”，“UART”。</td></tr><tr><td><strong><code>longname</code></strong></td><td>译码器的(长)名。当列出可用的PDs时使用。Example: ‘Joint Test Action Group (IEEE 1149.1)’, ‘Secure Digital card (SPI mode)’, ‘Universal Asynchronous Receiver&#x2F;Transmitter（UART）’</td></tr><tr><td><strong><code>desc</code></strong></td><td>解码器的自由的一行描述。当列出可用的PDs时使用。应该以句号结束。Example: ‘Protocol for testing, debugging, and flashing ICs.’, ‘Secure Digital card (SPI mode) low-level protocol.’, ‘Asynchronous, serial bus.’.</td></tr><tr><td><strong><code>license</code></strong></td><td>提供模块的许可证。这必须是gplv2+(即GNU通用公共许可证2或更高版本)，或者gplv3+ (GNU通用公共许可证3或更高版本)。libsigrokdecode中不允许为模块提供其他许可证。</td></tr><tr><td><strong><code>inputs</code></strong></td><td>此解码器需要的输入类型列表。如果解码器从逻辑分析器驱动程序获取输入，则应将其设置为logic，该逻辑将映射到数据籽类型SR_DF_LOGIC。如果它从另一个PD获取输入，则应该将其设置为该PD的输出键的值。它应该符合与id键相同的规则(小写，没有空格，等等)。</td></tr><tr><td><strong><code>outputs</code></strong></td><td>此解码器产生的输出类型列表。如果这个解码器能够将解码后的数据反馈到数据流中，那么它的输出将被标识为该密钥的值。它应该与id键遵循相同的规则。</td></tr><tr><td><strong><code>channels</code></strong></td><td>该密钥包含有关<strong>必须</strong>提供给该PD的通道(pin)的信息;没有他们，PD将无法工作。例如，SPI解码器必须知道哪个信道有时钟信号。该键包含一个通道条目的元组，其中每个条目都是一个Python dict，其键为id、name和desc。Example: <strong><code>&#123;&#39;id&#39;: &#39;rx&#39;, &#39;name&#39;: &#39;RX&#39;, &#39;desc&#39;: &#39;UART receive line&#39;&#125;</code></strong>.</td></tr><tr><td><strong><code>optional_channels</code></strong></td><td>PD可选的通道，但不是必须的。该键的格式与上面的通道键相同(dicts的元组)。如果相应的协议解码器没有可选通道，则允许该元组为空。</td></tr><tr><td><strong><code>options</code></strong></td><td>描述此解码器的选项的元组。每个元组条目都是一个Python dict，其键id、desc、缺省值和值。如果PD没有可选的通道，则此元组可以为空。Example: <strong><code>&#123;&#39;id&#39;: &#39;bitorder&#39;, &#39;desc&#39;: &#39;Bit order&#39;, &#39;default&#39;: &#39;msb-first&#39;, &#39;values&#39;: (&#39;msb-first&#39;, &#39;lsb-first&#39;)&#125;</code></strong>.</td></tr><tr><td><strong><code>annotations</code></strong></td><td>此协议解码器可以输出的注释类的列表。此列表的元素是由标识符字符串和可读的描述字符串组成的元组。标识符字符串可以在siglock -cli选项中用于选择特定的注释类型，因此不应该包含空白或特殊字符。</td></tr><tr><td><strong><code>annotation_rows</code></strong></td><td>注释行用于将多个注释类型分组在一起。这个列表的元素是三个元素元组，包括: 1.注释行ID(与其他ID的命名规则相同)。2.注释行的人类可读的名称&#x2F;描述字符串。3. 包含注释元组中注释类的索引的元组。<a href="https://sigrok.org/wiki/Protocol_decoder_HOWTO#annotations_.26_annotation_rows">示例参考</a></td></tr><tr><td><strong><code>binary</code></strong></td><td>此协议解码器可以输出的二进制输出类型列表，格式与**<code>annotations</code>**列表相同。</td></tr></tbody></table><h1 id="self-put"><a href="#self-put" class="headerlink" title="self.put( )"></a>self.put( )</h1><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p><strong>put(startsample, endsample, output_id, data)</strong></p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>startsample：开始的序号</p><p>endsample：结束的序号</p><p>output_id：取值看下表</p><p>data：根据output_id的不同数据也不同</p><table><thead><tr><th>output_id</th><th>funcation</th></tr></thead><tbody><tr><td><strong>OUTPUT_ANN</strong></td><td>注释信息</td></tr><tr><td><strong>OUTPUT_PYTHON</strong></td><td></td></tr><tr><td><strong>OUTPUT_BINARY</strong></td><td></td></tr><tr><td><strong>OUTPUT_META</strong></td><td></td></tr></tbody></table><ol><li><strong>OUTPUT_ANN</strong>：</li></ol><ul><li><p>这个东西在显示bit数据时会在信号上有小点点指示。</p></li><li><p>不同缩放级别显示不同内容<br>Example: <code>self.put(10, 20, self.out_ann, [4, [&#39;Start&#39;, &#39;St&#39;, &#39;S&#39;]])</code></p></li><li><p>data参数是一个包含两个项的Python列表。第一项是注释索引(由解码器中项的顺序决定)。第二个是注释字符串列表。字符串应该是相同注释文本的长版本和短版本(按长度排序，最长优先)，可以由前端根据缩放级别显示不同的注释文本。</p></li></ul><ol start="2"><li><strong>OUTPUT_PYTHON</strong> ：</li></ol><ul><li><p>输出特定格式的数据么？（ 数据内容本身完全依赖于各自的解码器，应该在其pd.py文件中记录。 ）</p><p>Example: <em><code>self.put(10, 20, self.out_python, [&#39;PACKET&#39;, [&#39;Foo&#39;, 19.7, [1, 2, 3], (&#39;bar&#39;, &#39;baz&#39;)]])</code></em> </p></li><li><p>数据参数是将传递给堆叠解码器的任意Python对象。格式和内容完全依赖于解码器。通常，包含各种内容的Python列表被传递给堆叠的PDs。</p></li></ul><ol start="3"><li><p><strong>OUTPUT_BINARY</strong>：</p><ul><li><p>输出数据0x55 0xaa等等（ 二进制格式的索引为4，发出的字节分别为0xfe、0x55、0xaa）</p><p> Example: <em><code>self.put(10, 20, self.out_binary, [4, b&#39;\xfe\x55\xaa&#39;])</code></em> </p></li><li><p>data参数是一个包含两个项的Python列表。第一项是二进制格式的索引(由解码器中项的顺序决定)。第二个是Python bytes对象。</p></li></ul></li><li><p><strong>OUTPUT_META</strong> ：</p></li></ol><ul><li><p>输出解码出来的数字（ 在本例中数据本身是一个浮点数）</p><p> Example: <em><code>self.put(10, 20, self.out_meta, 15.7)</code></em> </p></li><li><p>数据参数是特定类型的Python对象，在各自的register()函数中定义</p></li></ul><h1 id="self-wait"><a href="#self-wait" class="headerlink" title="self.wait()"></a>self.wait()</h1><p>这是协议解码器用来将查询发送到libsigrokdecode后端的API调用。<br>从PD的角度来看，这是一个阻塞呼叫。它将阻塞，直到在样本数据中找到指定的条件，然后才将控制权返回给PD。</p><h2 id="原型-1"><a href="#原型-1" class="headerlink" title="原型"></a>原型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">wait</span>(<span class="hljs-params">self, conds</span>):<br>    <span class="hljs-comment"># 1. 等待，直到conds中的一个或多个条件匹配.</span><br>    <span class="hljs-comment"># 2. 设置 self.samplenum ，匹配样本的绝对样本数.</span><br>    <span class="hljs-comment"># 3. 根据 self.matched 条件匹配.</span><br>    <span class="hljs-comment"># 4. 返回一个包含匹配样本的pin值的元组.</span><br></code></pre></td></tr></table></figure><h2 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h2><h3 id="空参"><a href="#空参" class="headerlink" title="空参"></a>空参</h3><p>如果完全不提供conds，或者它是一个空列表[]，或者它只是一个“空”条件{}，那么后端将直接跳到下一个示例。 （相当于直接进入下一个样本）</p><p><strong>Examples:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Don&#x27;t wait for any condition, just skip to the next sample.</span><br>pins = <span class="hljs-variable language_">self</span>.wait()<br>pins = <span class="hljs-variable language_">self</span>.wait([])<br>pins = <span class="hljs-variable language_">self</span>.wait(&#123;&#125;)<br>pins = <span class="hljs-variable language_">self</span>.wait(&#123;<span class="hljs-string">&#x27;skip&#x27;</span>: <span class="hljs-number">1</span>&#125;) <span class="hljs-comment"># Skip one sample, see below.</span><br></code></pre></td></tr></table></figure><h3 id="conds-引脚状态条件-上下沿"><a href="#conds-引脚状态条件-上下沿" class="headerlink" title="conds 引脚状态条件(上下沿)"></a><strong>conds</strong> 引脚状态条件(上下沿)</h3><table><thead><tr><th>Value</th><th>Describe</th></tr></thead><tbody><tr><td>‘<strong>l’</strong></td><td>Low pin value (logical 0)</td></tr><tr><td>‘h’</td><td>High pin value (logical 1)</td></tr><tr><td>‘r’</td><td>Rising edge</td></tr><tr><td>‘f’</td><td>Falling edge</td></tr><tr><td>‘e’</td><td>Either edge (rising or falling)</td></tr><tr><td>‘s’</td><td>稳定状态 Stable state, the opposite of ‘e’. That is, there was no edge and the current and previous pin value were both low (or both high).</td></tr><tr><td>other</td><td>任何其他值都会产生错误。</td></tr></tbody></table><p><strong>Examples:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Wait until pin 7 has a falling edge.</span><br>pins = <span class="hljs-variable language_">self</span>.wait(&#123;<span class="hljs-number">7</span>: <span class="hljs-string">&#x27;f&#x27;</span>&#125;)<br><br><span class="hljs-comment"># Wait until pin 3 has a rising edge “and” pin 4 is high at the same time.</span><br>pins = <span class="hljs-variable language_">self</span>.wait(&#123;<span class="hljs-number">3</span>: <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-number">4</span>: <span class="hljs-string">&#x27;h&#x27;</span>&#125;)<br><br><span class="hljs-comment"># Wait until pins 2-4 are low and pin 16 has any edge.</span><br>pins = <span class="hljs-variable language_">self</span>.wait(&#123;<span class="hljs-number">2</span>: <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-number">3</span>: <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-number">4</span>: <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-number">16</span>: <span class="hljs-string">&#x27;e&#x27;</span>&#125;)<br></code></pre></td></tr></table></figure><h3 id="conds-样品跳过条-样本数量"><a href="#conds-样品跳过条-样本数量" class="headerlink" title="conds 样品跳过条(样本数量)"></a><strong>conds</strong> 样品跳过条(样本数量)</h3><p>后端另一个常见的查询是，当解码器想要跳过一定数量的样本时，而不管样本值是什么(因为它们与当前的协议无关)。<br>这可以通过条件dict中的一个特殊键来实现— ‘<strong>skip’</strong> 。 ‘<strong>skip’</strong> 键的值是要跳过的样本的整数。</p><p>解码器也可以跳过一定的时间，通过使用采样来计算 ‘<strong>skip’</strong> 键的正确值。</p><p><strong>Examples:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Skip over the next 100 samples.</span><br>pins = <span class="hljs-variable language_">self</span>.wait(&#123;<span class="hljs-string">&#x27;skip&#x27;</span>: <span class="hljs-number">100</span>&#125;)<br><br><span class="hljs-comment"># Skip over the next 20ms of samples.</span><br>pins = <span class="hljs-variable language_">self</span>.wait(&#123;<span class="hljs-string">&#x27;skip&#x27;</span>: <span class="hljs-number">20</span> * (<span class="hljs-number">1000</span> / <span class="hljs-variable language_">self</span>.samplerate)&#125;)<br><br><span class="hljs-comment"># Skip half a bitwidth of samples (e.g. for UART).</span><br><span class="hljs-variable language_">self</span>.halfbitwidth = <span class="hljs-built_in">int</span>((<span class="hljs-variable language_">self</span>.samplerate / <span class="hljs-variable language_">self</span>.options[<span class="hljs-string">&#x27;baudrate&#x27;</span>]) / <span class="hljs-number">2.0</span>)<br>pins = <span class="hljs-variable language_">self</span>.wait(&#123;<span class="hljs-string">&#x27;skip&#x27;</span>: <span class="hljs-variable language_">self</span>.halfbitwidth&#125;)<br></code></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">pins = <span class="hljs-variable language_">self</span>.wait(&#123;<span class="hljs-string">&#x27;skip&#x27;</span>: <span class="hljs-number">100</span>&#125;)  <span class="hljs-comment">#这里的pins是元组，</span><br>(pins,) = <span class="hljs-variable language_">self</span>.wait(&#123;<span class="hljs-string">&#x27;skip&#x27;</span>: <span class="hljs-number">100</span>&#125;)<span class="hljs-comment">#可以写成这样</span><br></code></pre></td></tr></table></figure><h1 id="self-skip"><a href="#self-skip" class="headerlink" title="self.skip()"></a>self.skip()</h1><p><strong>这个函数不知道怎么回事，用了会报错</strong></p><p>注意这下面的skip不是wait</p><p>在相同的条件下混合通道索引键和“跳过”键通常没有多大意义，然而，在不同的情况下，混合索引键和“跳过”键是非常合理的: </p><p>（下面的语句应该是  <code>((pin7 e)和(pin12 l))或(skip 10000)</code> ）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Wait until there&#x27;s</span><br><span class="hljs-comment"># a) an edge on pin 7 and a low state on pin 12, and/or</span><br><span class="hljs-comment"># b) 1000 samples passed by,</span><br><span class="hljs-comment"># whichever occurs first (both conditions could occur at the same time too).</span><br><span class="hljs-comment"># This is basically &quot;wait for an edge on pin 7 and a low state on pin 12,</span><br><span class="hljs-comment"># with a timeout of 1000 samples&quot;.</span><br>pins = <span class="hljs-variable language_">self</span>.skip((&#123;<span class="hljs-number">7</span>: <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-number">12</span>: <span class="hljs-string">&#x27;l&#x27;</span>&#125;, &#123;<span class="hljs-string">&#x27;skip&#x27;</span>: <span class="hljs-number">1000</span>&#125;))<br></code></pre></td></tr></table></figure><h1 id="self-matched"><a href="#self-matched" class="headerlink" title="self.matched"></a>self.matched</h1><p>当解码器通过<strong>self.wait（）</strong>请求前端等待多个条件时，当该调用返回时，PD仅知道<strong>至少一个</strong>条件已匹配。但是，在大多数情况下，它还需要知道<strong>哪些</strong>条件匹配（或不匹配）。</p><p>这是<strong>self.matched</strong>提供的信息。它是布尔值（<strong>True</strong>或<strong>False</strong>）的元组，始终包含与上次<strong>self.wait（）</strong>调用中存在的条件一样多的条目。对于每个条件，各自的布尔值表示此特定条件是否匹配。</p><p><strong>Example:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 等待，直到引脚9的上升边 或 引脚27的高状态(逻辑1)， 或 经过一定的“时间”(这里:跳过1000个样本)。这意味着有一个1000个样本的“超时”之后self.wait()将返回(不管其他条件如何)。</span><br>pins = <span class="hljs-variable language_">self</span>.wait([&#123;<span class="hljs-number">9</span>: <span class="hljs-string">&#x27;r&#x27;</span>&#125;, &#123;<span class="hljs-number">27</span>: <span class="hljs-string">&#x27;h&#x27;</span>&#125;, &#123;<span class="hljs-string">&#x27;skip&#x27;</span>: <span class="hljs-number">1000</span>&#125;])<br><br><span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.matched == (<span class="hljs-literal">True</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>):<br>    <span class="hljs-comment"># 前两个条件是同时匹配的。</span><br>    <span class="hljs-comment"># Pin 9 contains a rising edge and pin 27 is high.</span><br><span class="hljs-keyword">elif</span> <span class="hljs-variable language_">self</span>.matched == (<span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>):<br>    <span class="hljs-comment"># Rising edge on pin 9, pin 27 is guaranteed to not be high.</span><br><span class="hljs-keyword">elif</span> <span class="hljs-variable language_">self</span>.matched == (<span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>):<br>    <span class="hljs-comment"># Pin 27 is high, pin 9 is guaranteed to not be a rising edge.</span><br><span class="hljs-keyword">elif</span> <span class="hljs-variable language_">self</span>.matched == (<span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>):<br>    <span class="hljs-comment"># Pin 9 is not a rising edge, pin 27 is not high, but 1000 samples were skipped.</span><br><span class="hljs-keyword">elif</span> <span class="hljs-variable language_">self</span>.matched == (<span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">True</span>):<br>    <span class="hljs-comment"># Pin 9 is not a rising edge, pin 27 is high, and it just so happens that</span><br>    <span class="hljs-comment"># exactly 1000 samples were skipped.</span><br><span class="hljs-keyword">elif</span> <span class="hljs-variable language_">self</span>.matched == (<span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>):<br>    <span class="hljs-comment"># Bug, this cannot happen. self.wait() only returns upon &gt;= 1 matches.</span><br></code></pre></td></tr></table></figure><p>对于’skip’键&#x2F;值对self。如果达到指定数目的样本，则匹配的tuple将包含一个真值。 </p><p><strong>Example:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Wait for a falling edge on channel 18, or until 25000 samples passed by.</span><br>pins = <span class="hljs-variable language_">self</span>.wait([&#123;<span class="hljs-number">18</span>: <span class="hljs-string">&#x27;f&#x27;</span>&#125;, &#123;<span class="hljs-string">&#x27;skip&#x27;</span>: <span class="hljs-number">25000</span>&#125;])<br><br><span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.matched[<span class="hljs-number">0</span>]:<br>    <span class="hljs-comment"># Pin 18 has a falling edge.</span><br><span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.matched[<span class="hljs-number">1</span>]:<br>    <span class="hljs-comment"># 25000 samples were skipped.</span><br></code></pre></td></tr></table></figure><h1 id="self-samplenum"><a href="#self-samplenum" class="headerlink" title="self.samplenum"></a>self.samplenum</h1><p><em>self.samplenum 相当于一个指针，指示当前解码器解码的样本的位置</em></p><p> <strong>self.samplenum</strong>是一个特殊属性，对于协议解码器来说是只读的，并且只能由libsigrokdecode后端设置。 </p><p> <strong>self.samplenum</strong> 总是在最后一次self.wait()调用返回后的当前绝对样本号(从0开始)。 </p><h1 id="self-samplerate"><a href="#self-samplerate" class="headerlink" title="self.samplerate"></a>self.samplerate</h1><p>采样率</p><h1 id="self-has-channel"><a href="#self-has-channel" class="headerlink" title="self.has_channel"></a>self.has_channel</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#code1 </span><br>...<br><span class="hljs-variable language_">self</span>.have_cs = <span class="hljs-variable language_">self</span>.has_channel(<span class="hljs-number">3</span>)<br>...<br><br><span class="hljs-comment">#code2</span><br>...<br><span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.have_cs <span class="hljs-keyword">and</span> (first <span class="hljs-keyword">or</span> (<span class="hljs-variable language_">self</span>.matched &amp; (<span class="hljs-number">0b1</span> &lt;&lt; <span class="hljs-variable language_">self</span>.have_cs))):<br>    ....<br>...<br></code></pre></td></tr></table></figure><p>self.has_channel返回的值似乎是对应通道的值，比如这里返回的应该是3.</p><h1 id="一些奇怪的问题"><a href="#一些奇怪的问题" class="headerlink" title="一些奇怪的问题"></a>一些奇怪的问题</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">xxxxx</span>(<span class="hljs-params">self</span>):<br>    logging.info(<span class="hljs-string">&#x27;----- xxx start -----&#x27;</span>)<br>    data = <span class="hljs-number">0</span><br>    bit_count = <span class="hljs-number">5</span><br><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        pin_state = <span class="hljs-variable language_">self</span>.wait( [&#123;<span class="hljs-number">0</span>: <span class="hljs-string">&#x27;r&#x27;</span>&#125;, &#123;<span class="hljs-string">&#x27;skip&#x27;</span>: <span class="hljs-variable language_">self</span>.freq_half_samp &#125;] )<br>        <span class="hljs-keyword">if</span>( <span class="hljs-variable language_">self</span>.matched &amp; (<span class="hljs-number">0b1</span> &lt;&lt; <span class="hljs-number">0</span>) ):        <span class="hljs-comment">#r</span><br>            <span class="hljs-variable language_">self</span>.LS_2 |= <span class="hljs-number">0b0</span> &lt;&lt; bit_count<br>            <span class="hljs-variable language_">self</span>.wait( [&#123;<span class="hljs-string">&#x27;skip&#x27;</span>: (<span class="hljs-variable language_">self</span>.bit_samp-<span class="hljs-variable language_">self</span>.freq_quarter_samp) &#125;] )<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-variable language_">self</span>.LS_2 |= <span class="hljs-number">0b1</span> &lt;&lt; bit_count<br>            <span class="hljs-variable language_">self</span>.wait( [&#123;<span class="hljs-string">&#x27;skip&#x27;</span>: (<span class="hljs-variable language_">self</span>.bit_samp-<span class="hljs-variable language_">self</span>.freq_half_samp) &#125;] )<br>        <span class="hljs-keyword">if</span>( bit_count == <span class="hljs-number">0</span> ):<br>            <span class="hljs-keyword">break</span><br>        bit_count -= <span class="hljs-number">1</span><br>    logging.info(<span class="hljs-string">&#x27;----- xxx end -----&#x27;</span>)<br>    <span class="hljs-keyword">return</span> data<br><br><br></code></pre></td></tr></table></figure><p>注意到<code>pin_state = self.wait( [&#123;0: &#39;r&#39;&#125;, &#123;&#39;skip&#39;: self.freq_half_samp &#125;] )</code>语句，把pin_state删掉就可以正常运行，若没删if后面的self.wait就会一直出问题。</p><ul><li>原因应该是pin_state没打括号，pin_state变成了元组，所以出现这种情况</li></ul><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="一些快速处理数据的方法"><a href="#一些快速处理数据的方法" class="headerlink" title="一些快速处理数据的方法"></a>一些快速处理数据的方法</h2><ul><li>快速计算奇偶校验</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ones = <span class="hljs-built_in">bin</span>(<span class="hljs-number">0x55</span>).count(<span class="hljs-string">&#x27;1&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li>BCD转成整数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">bcd2int</span>(<span class="hljs-params">b</span>):<br>    <span class="hljs-keyword">return</span> (b &amp; <span class="hljs-number">0x0f</span>) + ((b &gt;&gt; <span class="hljs-number">4</span>) * <span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><ul><li>一种将总线引脚序列转换为数字值的好方法：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">reduce_bus</span>(<span class="hljs-params">bus</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-number">0xFF</span> <span class="hljs-keyword">in</span> bus:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span> <span class="hljs-comment"># unassigned bus channels</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> reduce(<span class="hljs-keyword">lambda</span> a, b: (a &lt;&lt; <span class="hljs-number">1</span>) | b, <span class="hljs-built_in">reversed</span>(bus))<br></code></pre></td></tr></table></figure><ul><li>根据协议命令构造方法名的一个好方法是(假设cmd是8，这将调用self.handle_cmd_0x08函数):</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">fn = <span class="hljs-built_in">getattr</span>(<span class="hljs-variable language_">self</span>, <span class="hljs-string">&#x27;handle_cmd_0x%02x&#x27;</span> % cmd);<br>fn(arg1, arg2, ...)<br></code></pre></td></tr></table></figure><ul><li>一种处理Python缺少枚举类型(对状态、pin索引、注释索引等有用)的方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cycle</span>:<br>    NONE, MEMRD, MEMWR, IORD, IOWR, FETCH, INTACK = <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dslogic</tag>
      
      <tag>逻辑分析仪</tag>
      
      <tag>pyhton</tag>
      
      <tag>decoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言高质量编程</title>
    <link href="/2019/b0d7d162/"/>
    <url>/2019/b0d7d162/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言高质量编程"><a href="#C语言高质量编程" class="headerlink" title="C语言高质量编程"></a>C语言高质量编程</h1><h1 id="1-2-头文件的结构"><a href="#1-2-头文件的结构" class="headerlink" title="1.2 头文件的结构"></a>1.2 头文件的结构</h1><ol><li>头文件开头处的版权和版本声明（参见示例1-1）。</li><li>预处理块。</li><li>函数和类结构声明等。</li></ol><p>假设头文件名称为 <code>graphics.h</code>，头文件的结构参见下面。</p><ul><li>【规则1-2-1】为了防止头文件被重复引用，应当用<code>ifndef/define/endif</code> 结构产生预处理块。</li><li>【规则 1-2-2】用<code>#include &lt;filename.h&gt;</code> 格式来引用标准库的头文件（编译器将从标准库目录开始搜索）。</li><li>【规则1-2-3】用<code>#include “filename.h”</code> 格式来引用非标准库的头文件（编译器将从用户的工作目录开始搜索）。</li><li>【建议1-2-1】头文件中只存放“声明”而不存放“定义”在 C++ 语法中，类的成员函数可以在声明的同时被定义，并且自动成为内联函数。这虽然会带来书写上的方便，但却造成了风格不一致，弊大于利。建议将成员函数的定义与声明分开，不论该函数体有多么小。</li><li>【建议1-2-2】不提倡使用全局变量，尽量不要在头文件中出现象extern int value 这类声明。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> GRAPHICS_H <span class="hljs-comment">// 防止graphics.h 被重复引用</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GRAPHICS_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span> <span class="hljs-comment">// 引用标准库的头文件</span></span><br>⋯<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> “myheader.h” <span class="hljs-comment">// 引用非标准库的头文件</span></span><br>⋯<br><span class="hljs-type">void</span> <span class="hljs-title function_">Function1</span><span class="hljs-params">(⋯)</span>; <span class="hljs-comment">// 全局函数声明</span><br>⋯<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Box</span> // 类结构声明</span><br><span class="hljs-class">&#123;</span><br>⋯<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h1 id="1-3-定义文件的结构"><a href="#1-3-定义文件的结构" class="headerlink" title="1.3 定义文件的结构"></a>1.3 定义文件的结构</h1><p>定义文件有三部分内容：</p><ol><li>定义文件开头处的版权和版本声明（参见示例1-1）。</li><li>对一些头文件的引用。</li><li>程序的实现体（包括数据和代码）。<br>假设定义文件的名称为 graphics.cpp，定义文件的结构参见下面。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> “graphics.h” <span class="hljs-comment">// 引用头文件</span></span><br>⋯<br><span class="hljs-comment">// 全局函数的实现体</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Function1</span><span class="hljs-params">(⋯)</span><br>&#123;<br>⋯<br>&#125;<br><span class="hljs-comment">// 类成员函数的实现体</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Box::Draw</span><span class="hljs-params">(⋯)</span><br>&#123;<br>⋯<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="2-1-空行"><a href="#2-1-空行" class="headerlink" title="2.1 空行"></a>2.1 空行</h1><p>空行起着分隔程序段落的作用。空行得体（不过多也不过少）将使程序的布局更加清晰。空行不会浪费内存，虽然打印含有空行的程序是会多消耗一些纸张，但是值得。所以不要舍不得用空行。</p><ul><li>【规则 2-1-1】在每个类声明之后、每个函数定义结束之后都要加空行。参见示例2-1（a）</li><li>【规则2-1-2】在一个函数体内，逻揖上密切相关的语句之间不加空行，其它地方应加空行分隔</li></ul><h1 id="2-2-代码行"><a href="#2-2-代码行" class="headerlink" title="2.2 代码行"></a>2.2 代码行</h1><ul><li>【规则2-2-1】<strong>一行代码只做一件事情</strong>，<strong>如只定义一个变量</strong>，或只写一条语句。这样的代码容易阅读，并且方便于写注释。</li><li>【规则2-2-2】if、for、while、do 等语句自占一行，执行语句不得紧跟其后。**不论执行语句有多少都要加{}**。这样可以防止书写失误。</li></ul><h1 id="2-3-代码行内的空格"><a href="#2-3-代码行内的空格" class="headerlink" title="2.3 代码行内的空格"></a>2.3 代码行内的空格</h1><ul><li>【规则2-3-1】关键字之后要留空格。象const、virtual、inline、case 等关键字之后至少要留一个空格，否则无法辨析关键字。象if、for、while 等关键字之后应留一个空格再跟左括号‘（’，以突出关键字。</li><li>【规则2-3-2】函数名之后不要留空格，紧跟左括号‘（’，以与关键字区别。</li><li><strong>【规则2-3-3】</strong>‘（’向后紧跟，‘）’、‘，’、‘;’ 向前紧跟，<strong>紧跟处不留空格。</strong></li><li><strong>【规则2-3-4】</strong>‘，’之后要留空格，如<code>Function(x,  y,  z)</code>。如果‘;’不是一行的结束符号，其后要留空格，如<code>for (initialization;  condition;  update)</code>。</li><li>【规则2-3-5】赋值操作符、比较操作符、算术操作符、逻辑操作符、位域操作符，如“&#x3D;”、“+&#x3D;” “&gt;&#x3D;”、“&lt;&#x3D;”、“+”、“*”、“%”、“&amp;&amp;”、“||”、“&lt;&lt;”,“^”等二元操作符的前后应当加空格。</li><li>【规则2-3-6】一元操作符如“!”、“~”、“++”、“–”、“&amp;”（地址运算符）等前后不加空格。</li><li>【规则2-3-7】xu“［］”、“.”、“-&gt;”这类操作符前后不加空格。</li><li>【建议2-3-1】对于表达式比较长的for 语句和if 语句，为了紧凑起见可以适当地去掉一些空格，如<code>for (i=0; i&lt;10; i++)和if ((a&lt;=b) &amp;&amp; (c&lt;=d))</code></li></ul><h1 id="2-4-对齐"><a href="#2-4-对齐" class="headerlink" title="2.4 对齐"></a>2.4 对齐</h1><ul><li>【规则2-4-1】程序的分界符‘{’和‘}’应独占一行并且位于同一列，同时与引用它们的语句左对齐。</li><li>【规则2-4-2】{ }之内的代码块在‘{’右边数格处左对齐。</li></ul><h1 id="2-5-长行拆分"><a href="#2-5-长行拆分" class="headerlink" title="2.5 长行拆分"></a>2.5 长行拆分</h1><ul><li>【规则2-5-1】代码行最大长度宜控制在70 至80 个字符以内。代码行不要过长，否则眼睛看不过来，也不便于打印。</li><li>【规则2-5-2】长表达式要在低优先级操作符处拆分成新行，操作符放在新行之首（以便突出操作符）。拆分出的新行要进行适当的缩进，使排版整齐，语句可读。</li></ul><h1 id="2-6-修饰符的位置"><a href="#2-6-修饰符的位置" class="headerlink" title="2.6 修饰符的位置"></a>2.6 修饰符的位置</h1><p>修饰符 * 和＆ 应该靠近数据类型还是该靠近变量名，是个有争议的活题。若将修饰符 * 靠近数据类型，例如：int*  x; 从语义上讲此写法比较直观，即x是int 类型的指针。上述写法的弊端是容易引起误解，例如：int*  x, y; 此处y 容易被误解为指针变量。虽然将x 和y 分行定义可以避免误解，但并不是人人都愿意这样做。</p><ul><li>【规则2-6-1】应当将修饰符 * 和＆ 紧靠变量名</li></ul><h1 id="2-7-注释"><a href="#2-7-注释" class="headerlink" title="2.7 注释"></a>2.7 注释</h1><p>C 语言的注释符为“&#x2F;<em>…</em>&#x2F;”。C++语言中，程序块的注释常采用“&#x2F;<em>…</em>&#x2F;”，行注释一般采用“&#x2F;&#x2F;…”。注释通常用于：<br>（1）版本、版权声明；<br>（2）函数接口说明；<br>（3）重要的代码行或段落提示。<br>虽然注释有助于理解代码，但注意不可过多地使用注释。<br>【规则2-7-1】注释是对代码的“提示”，而不是文档。程序中的注释不可喧宾夺主，注释太多了会让人眼花缭乱。注释的花样要少。<br>【规则2-7-2】如果代码本来就是清楚的，则不必加注释。否则多此一举，令人厌烦。例如i++; &#x2F;&#x2F; i 加 1，多余的注释<br>【规则2-7-3】边写代码边注释，修改代码同时修改相应的注释，以保证注释与代码的一致性。不再有用的注释要删除。<br>【规则2-7-4】注释应当准确、易懂，防止注释有二义性。错误的注释不但无益反而有害。<br>【规则2-7-5】尽量避免在注释中使用缩写，特别是不常用缩写。<br>【规则2-7-6】注释的位置应与被描述的代码相邻，可以放在代码的上方或右方，不可放在下方。<br><strong>【规则2-7-8】</strong>当代码比较长，特别是有多重嵌套时，应当在一些段落的结束处加注释，便于阅读。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 函数介绍：</span><br><span class="hljs-comment">* 输入参数：</span><br><span class="hljs-comment">* 输出参数：</span><br><span class="hljs-comment">* 返回值：</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Function</span><span class="hljs-params">(<span class="hljs-type">float</span> x, <span class="hljs-type">float</span> y, <span class="hljs-type">float</span> z)</span><br>&#123;<br>    …<br>&#125;<br><br><span class="hljs-keyword">if</span> (…)<br>&#123;<br>    …<br>    <span class="hljs-keyword">while</span> (…)<br>    &#123;<br>        …<br>    &#125; <span class="hljs-comment">// end of while</span><br>    …<br>&#125; <span class="hljs-comment">// end of if</span><br><br></code></pre></td></tr></table></figure><h1 id="3-2-简单的单片机应用程序命名规则"><a href="#3-2-简单的单片机应用程序命名规则" class="headerlink" title="3.2 简单的单片机应用程序命名规则"></a>3.2 简单的单片机应用程序命名规则</h1><ol><li>函数名用大写字母开头的单词组合而成。<br>例如：<br>void Draw(void); &#x2F;&#x2F; 函数名<br>void Setvalue(int value); &#x2F;&#x2F; 函数名</li><li>变量和参数用小写字母开头的单词组合而成，float 变量名前加 f，int 变量名前加 i，bit变量前加 b 。（char 不加）<br>例如：<br>bit b_tirm;<br>int i_time;<br>float f_time;<br>char time;</li><li>常量、宏定义（DF_xxx）全用大写的字母，用下划线分割单词。<br>例如：<br>code char MAX &#x3D; 100;<br>#define DF_MAX 100</li></ol><h1 id="4-3-if-语句"><a href="#4-3-if-语句" class="headerlink" title="4.3 if 语句"></a>4.3 if 语句</h1><h2 id="4-3-1-布尔变量与零值比较"><a href="#4-3-1-布尔变量与零值比较" class="headerlink" title="4.3.1 布尔变量与零值比较"></a>4.3.1 布尔变量与零值比较</h2><p>【规则4-3-1】不可将布尔变量直接与TRUE、FALSE 或者1、0 进行比较。根据布尔类型的语义，零值为“假”（记为FALSE），任何非零值都是“真”（记为TRUE）。TRUE 的值究竟是什么并没有统一的标准。例如Visual C++ 将TRUE 定义为</p><p>1，而Visual Basic 则将TRUE 定义为-1。</p><p>假设布尔变量名字为flag，它与零值比较的标准if 语句如下：</p><p>if (flag) &#x2F;&#x2F; 表示flag 为真</p><p>if (!flag) &#x2F;&#x2F; 表示flag 为假</p><p>其它的用法都属于不良风格，例如：<br>if (flag &#x3D;&#x3D; TRUE)<br>if (flag &#x3D;&#x3D; 1 )<br>if (flag &#x3D;&#x3D; FALSE)</p><p>if (flag &#x3D;&#x3D; 0)</p><h2 id="4-3-2-整型变量与零值比较"><a href="#4-3-2-整型变量与零值比较" class="headerlink" title="4.3.2 整型变量与零值比较"></a>4.3.2 整型变量与零值比较</h2><p>【规则4-3-2】应当将整型变量用“&#x3D;&#x3D;”或“！&#x3D;”直接与0 比较。<br>假设整型变量的名字为value，它与零值比较的标准if 语句如下：<br>if (value &#x3D;&#x3D; 0)<br>if (value !&#x3D; 0)<br>不可模仿布尔变量的风格而写成<br>if (value) &#x2F;&#x2F; 会让人误解 value 是布尔变量</p><p>if (!value)</p><h2 id="4-3-3-浮点变量与零值比较"><a href="#4-3-3-浮点变量与零值比较" class="headerlink" title="4.3.3 浮点变量与零值比较"></a>4.3.3 浮点变量与零值比较</h2><p>【规则4-3-3】不可将浮点变量用“&#x3D;&#x3D;”或“！&#x3D;”与任何数字比较。千万要留意，无论是float 还是double 类型的变量，都有精度限制。所以一定要避免将浮点变量用“&#x3D;&#x3D;”或“！&#x3D;”与数字比较，应该设法转化成“&gt;&#x3D;”或“&lt;&#x3D;”形式。</p><p>假设浮点变量的名字为x，应当将</p><p>if (x &#x3D;&#x3D; 0.0) &#x2F;&#x2F; 隐含错误的比较<br>转化为<br>if ((x&gt;&#x3D;-EPSINON) &amp;&amp; (x&lt;&#x3D;EPSINON))</p><p>其中EPSINON 是允许的误差（即精度）。</p><h3 id="4-3-4-指针变量与零值比较"><a href="#4-3-4-指针变量与零值比较" class="headerlink" title="4.3.4 指针变量与零值比较"></a>4.3.4 指针变量与零值比较</h3><p>【规则4-3-4】应当将指针变量用“&#x3D;&#x3D;”或“！&#x3D;”与NULL 比较。指针变量的零值是“空”（记为NULL）。尽管NULL 的值与0 相同，但是两者意义不同。假设指针变量的名字为p，它与零值比较的标准if 语句如下：</p><p>if (p &#x3D;&#x3D; NULL) &#x2F;&#x2F; p 与NULL 显式比较，强调p 是指针变量</p><p>if (p !&#x3D; NULL)<br>不要写成<br>if (p &#x3D;&#x3D; 0) &#x2F;&#x2F; 容易让人误解p 是整型变量<br>if (p !&#x3D; 0)<br>或者<br>if (p) &#x2F;&#x2F; 容易让人误解p 是布尔变量</p><p>if (!p)</p><h3 id="4-3-5-对if-语句的补充说明"><a href="#4-3-5-对if-语句的补充说明" class="headerlink" title="4.3.5 对if 语句的补充说明"></a>4.3.5 对if 语句的补充说明</h3><p>有时候我们可能会看到 if (NULL &#x3D;&#x3D; p) 这样古怪的格式。不是程序写错了，是程序员为了防止将 if (p &#x3D;&#x3D; NULL) 误写成 if (p &#x3D; NULL)，而有意把p 和NULL 颠倒。编译器认为 if (p &#x3D; NULL) 是合法的，但是会指出 if (NULL &#x3D; p)是错误的，因为NULL不能被赋值。</p><h1 id="4-4-循环语句的效率"><a href="#4-4-循环语句的效率" class="headerlink" title="4.4 循环语句的效率"></a>4.4 循环语句的效率</h1><p>【建议4-4-1】在多重循环中，如果有可能，应当将最长的循环放在最内层，最短的循环放在最外层，以减少CPU 跨切循环层的次数。例如示例4-4(b)的效率比示例4-4(a)的高。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 示例 4-4(a) 低效率：长循环在最外层 </span><br><span class="hljs-keyword">for</span> (row=<span class="hljs-number">0</span>; row&lt;<span class="hljs-number">100</span>; row++)<br>&#123;<br>    <span class="hljs-keyword">for</span> ( col=<span class="hljs-number">0</span>; col&lt;<span class="hljs-number">5</span>; col++ )<br>    &#123;<br>        sum = sum + a[row][col];<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 示例4-4(b) 高效率：长循环在最内层</span><br><span class="hljs-keyword">for</span> (col=<span class="hljs-number">0</span>; col&lt;<span class="hljs-number">5</span>; col++ )<br>&#123;<br>    <span class="hljs-keyword">for</span> (row=<span class="hljs-number">0</span>; row&lt;<span class="hljs-number">100</span>; row++)<br>    &#123;<br>        sum = sum + a[row][col];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>【建议4-4-2】如果循环体内存在逻辑判断，并且循环次数很大，宜将逻辑判断移到循环体的外面。示例4-4(c)的程序比示例4-4(d)多执行了N-1 次逻辑判断。并且由于前者老要进行逻辑判断，打断了循环“流水线”作业，使得编译器不能对循环进行优化处理，降低了效率。如果N 非常大，最好采用示例4-4(d)的写法，可以提高效率。如果N 非常小，两者效率差别并不明显，采用示例4-4(c)的写法比较好，因为程序更加简洁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 效率低但程序简洁</span><br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;N; i++)<br>&#123;<br>    <span class="hljs-keyword">if</span> (condition)<br>        DoSomething();<br>    <span class="hljs-keyword">else</span><br>        DoOtherthing();<br>&#125;<br><span class="hljs-comment">// 效率高但程序不简洁</span><br><span class="hljs-keyword">if</span> (condition)<br>&#123;<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;N; i++)<br>        DoSomething();<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;N; i++)<br>        DoOtherthing();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="4-5-for-语句的循环控制变量"><a href="#4-5-for-语句的循环控制变量" class="headerlink" title="4.5 for 语句的循环控制变量"></a>4.5 for 语句的循环控制变量</h1><p>【规则4-5-1】不可在for 循环体内修改循环变量，防止for 循环失去控制。<br>【建议4-5-1】建议for 语句的循环控制变量的取值采用“半开半闭区间”写法。<br>示例 4-5(a)中的x 值属于半开半闭区间“0 &#x3D;&lt; x &lt; N”，起点到终点的间隔为N，循环次数为N。<br>示例 4-5(b)中的x 值属于闭区间“0 &#x3D;&lt; x &lt;&#x3D; N-1”，起点到终点的间隔为N-1，循环次数为N。</p><p>相比之下，示例4-5(a)的写法更加直观，尽管两者的功能是相同的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 循环变量属于半开半闭区间 </span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>; x&lt;N; x++)<br>&#123;<br>    ⋯<br>&#125;<br><span class="hljs-comment">// 循环变量属于闭区间</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>; x&lt;=N<span class="hljs-number">-1</span>; x++)<br>&#123;<br>    ⋯<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="4-6-switch-语句"><a href="#4-6-switch-语句" class="headerlink" title="4.6 switch 语句"></a>4.6 switch 语句</h1><p>【规则4-6-1】每个case 语句的结尾不要忘了加break，否则将导致多个分支重叠（除非有意使多个分支重叠）。<br>【规则4-6-2】不要忘记最后那个default 分支。即使程序真的不需要default 处理，也应该保留语句 default : break; 这样做并非多此一举，而是为了防止别人误以为你忘了default 处理。</p><h1 id="4-7-goto-语句"><a href="#4-7-goto-语句" class="headerlink" title="4.7 goto 语句"></a>4.7 goto 语句</h1><p>自从提倡结构化设计以来，goto 就成了有争议的语句。首先，由于goto 语句可以灵活跳转，如果不加限制，它的确会破坏结构化设计风格。其次，goto 语句经常带来错误或隐患。它可能跳过了某些对象的构造、变量的初始化、重要的计算等语句，例如：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pf">goto <span class="hljs-keyword">state</span>;<br>String s1, s2; // 被goto 跳过<br>int sum = <span class="hljs-number">0</span>; // 被goto 跳过<br>⋯<br><span class="hljs-keyword">state</span>:<br>⋯<br></code></pre></td></tr></table></figure><p>所以我们主张少用、慎用goto 语句，而不是禁用。</p><h1 id="5-1-为什么需要常量"><a href="#5-1-为什么需要常量" class="headerlink" title="5.1 为什么需要常量"></a>5.1 为什么需要常量</h1><p>如果不使用常量，直接在程序中填写数字或字符串，将会有什么麻烦？<br>（1） 程序的可读性（可理解性）变差。程序员自己会忘记那些数字或字符串是什么意思，用户则更加不知它们从何处来、表示什么。<br>（2） 在程序的很多地方输入同样的数字或字符串，难保不发生书写错误。</p><p>（3） 如果要修改数字或字符串，则会在很多地方改动，既麻烦又容易出错。</p><p>【规则5-1-1】尽量使用含义直观的常量来表示那些将在程序中多次出现的数字或字符串。</p><h1 id="5-2-const-与-define-的比较"><a href="#5-2-const-与-define-的比较" class="headerlink" title="5.2 const 与 #define 的比较"></a>5.2 const 与 #define 的比较</h1><p>C++ 语言可以用const 来定义常量，也可以用 #define 来定义常量。但是前者比后者有更多的优点：<br>（1） const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误（边际效应）。</p><p>（2） 有些集成化的调试工具可以对 const 常量进行调试，但是不能对宏常量进行调试。</p><p>【规则5-2-1】在C++ 程序中只使用const 常量而不使用宏常量，即const 常量完全取代宏常量</p><h1 id="5-3-常量定义规则"><a href="#5-3-常量定义规则" class="headerlink" title="5.3 常量定义规则"></a>5.3 常量定义规则</h1>]]></content>
    
    
    <categories>
      
      <category>language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PID算法</title>
    <link href="/2019/14ee3806/"/>
    <url>/2019/14ee3806/</url>
    
    <content type="html"><![CDATA[<h2 id="PID算法笔记"><a href="#PID算法笔记" class="headerlink" title="PID算法笔记"></a>PID算法笔记</h2><p>位式控制算法，只考虑当前值，控制量有惯性，比较僵硬</p><h3 id="P–比例算法"><a href="#P–比例算法" class="headerlink" title="P–比例算法"></a>P–比例算法</h3><ul><li>只考虑现在的误差</li></ul><p>E<sub>k</sub> &#x3D; S<sub>V</sub> - X<sub>k</sub>(E<sub>k</sub>差值  S<sub>v</sub>期望值  X<sub>k</sub>当前值)</p><p>单纯的P控制算法：P<sub>out</sub>&#x3D;K<sub>p</sub> * E<sub>k</sub> ( P<sub>out</sub>输出的控制量  K<sub>p</sub>控制量  E<sub>k</sub>差值)</p><p><strong>单纯的P控制算法当前误差等于零后不控制</strong></p><p>P<sub>out</sub>&#x3D;K<sub>p</sub> * E<sub>k</sub>+OUT<sub>0</sub>(OUT<sub>0</sub>是一个常数维持静态误差)</p><hr><h3 id="I–积分算法"><a href="#I–积分算法" class="headerlink" title="I–积分算法"></a>I–积分算法</h3><ul><li>根据历史误差控制</li></ul><p>E<sub>1</sub>, E<sub>2</sub>, E<sub>3</sub>, E<sub>4</sub>, E<sub>5</sub>, ……….. E<sub>k</sub>  (E<sub>k</sub>差值)</p><p>S<sub>k</sub>&#x3D;E<sub>1</sub>+ E<sub>2</sub>+ E<sub>3</sub>+ E<sub>4</sub>+ E<sub>5</sub>+ ……….. +E<sub>k</sub>    (S<sub>k</sub> 误差和即积分)</p><p>I<sub>out</sub>&#x3D;K<sub>p</sub> * S<sub>k</sub> (I<sub>out</sub>输出的控制量  K<sub>p</sub>控制量)</p><p><strong>单纯的I控制算法历史误差等于零后不控制（当前误差可能很大）</strong></p><p>I<sub>out</sub>&#x3D;K<sub>p</sub> * S<sub>k</sub> +OUT<sub>0</sub>(OUT<sub>0</sub>是一个常数维持静态误差)</p><hr><h3 id="D–微分算法"><a href="#D–微分算法" class="headerlink" title="D–微分算法"></a>D–微分算法</h3><ul><li>考察最近变化趋势进行控制</li></ul><p>D<sub>k</sub>&#x3D;E<sub>k</sub> - E<sub>k-1</sub></p><p>D<sub>out</sub>&#x3D;K<sub>p</sub> * D<sub>k</sub> </p><hr><hr><hr><h2 id="Proportion-比例"><a href="#Proportion-比例" class="headerlink" title="Proportion (比例)"></a>Proportion (比例)</h2><p>误差越大，反馈越大</p><p>过小时系统反应很慢，过大时会产生振荡</p><ul><li>开环增益越大，稳态误差减小（无法消除，属于有差调节）</li><li>过渡时间缩短</li><li>稳定程度变差</li></ul><h2 id="Integral（积分）"><a href="#Integral（积分）" class="headerlink" title="Integral（积分）"></a>Integral（积分）</h2><p>误差持续越久，反馈越大</p><p>第一次到达目标会产生过冲，超调</p><p>积分求位置误差</p><ul><li>消除系统稳态误差（能够消除静态误差，属于无差调节）</li><li>稳定程度变差</li></ul><h2 id="Differential（微分）"><a href="#Differential（微分）" class="headerlink" title="Differential（微分）"></a>Differential（微分）</h2><p>误差变化率越大，反馈越大</p><p>根据以前的变化率预测未来的变化率</p><p>过大时会拖慢系统响应速度</p><p>提高响应速度，减少震荡</p><ul><li>减小超调量</li><li>减小调节时间（与P控制相比较而言）</li><li>增强系统稳定性</li><li>增加系统阻尼程度</li></ul><h2 id="PID总结"><a href="#PID总结" class="headerlink" title="PID总结"></a>PID总结</h2><ul><li><strong>稳定性</strong>（P和I降低系统稳定性，D提高系统稳定性）：在平衡状态下，系统受到某个干扰后，经过一段时间其被控量可以达到某一稳定状态；</li><li><strong>准确性</strong>（P和I提高稳态精度，D无作用）：系统处于稳态时，其稳态误差；</li><li><strong>快速性</strong>（P和D提高响应速度，I降低响应速度）：系统对动态响应的要求。一般由过渡时间的长短来衡量。</li></ul>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构</title>
    <link href="/2019/79666db/"/>
    <url>/2019/79666db/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="C语言打印运行时间"><a href="#C语言打印运行时间" class="headerlink" title="C语言打印运行时间"></a>C语言打印运行时间</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;time.h&gt;</span></span><br><span class="hljs-type">time_t</span> start, stop;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    start = clock();<span class="hljs-comment">//滴答时钟</span><br>    <span class="hljs-comment">//运行的函数</span><br>    stop = clock();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf----%lf\r\n&quot;</span>, (<span class="hljs-type">double</span>)(stop-start),(<span class="hljs-type">double</span>)(stop-start)/CLK_TCK);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="尾递归可以优化成For"><a href="#尾递归可以优化成For" class="headerlink" title="尾递归可以优化成For"></a>尾递归可以优化成For</h2><p>尾递归：程序返回时才发生递归。</p><h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h2 id="1-3-应用实例：最大子列和问题"><a href="#1-3-应用实例：最大子列和问题" class="headerlink" title="1.3 应用实例：最大子列和问题"></a>1.3 应用实例：最大子列和问题</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">Max3</span><span class="hljs-params">( <span class="hljs-type">int</span> A, <span class="hljs-type">int</span> B, <span class="hljs-type">int</span> C )</span><br>&#123; <span class="hljs-comment">/* 返回3个整数中的最大值 */</span><br>    <span class="hljs-keyword">return</span> A &gt; B ? A &gt; C ? A : C : B &gt; C ? B : C;<br>&#125;<br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">DivideAndConquer</span><span class="hljs-params">( <span class="hljs-type">int</span> List[], <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right )</span><br>&#123; <span class="hljs-comment">/* 分治法求List[left]到List[right]的最大子列和 */</span><br>    <span class="hljs-type">int</span> MaxLeftSum, MaxRightSum; <span class="hljs-comment">/* 存放左右子问题的解 */</span><br>    <span class="hljs-type">int</span> MaxLeftBorderSum, MaxRightBorderSum; <span class="hljs-comment">/*存放跨分界线的结果*/</span><br> <br>    <span class="hljs-type">int</span> LeftBorderSum, RightBorderSum;<br>    <span class="hljs-type">int</span> center, i;<br> <br>    <span class="hljs-keyword">if</span>( left == right )  &#123; <span class="hljs-comment">/* 递归的终止条件，子列只有1个数字 */</span><br>        <span class="hljs-keyword">if</span>( List[left] &gt; <span class="hljs-number">0</span> )  <span class="hljs-keyword">return</span> List[left];<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br> <br>    <span class="hljs-comment">/* 下面是&quot;分&quot;的过程 */</span><br>    center = ( left + right ) / <span class="hljs-number">2</span>; <span class="hljs-comment">/* 找到中分点 */</span><br>    <span class="hljs-comment">/* 递归求得两边子列的最大和 */</span><br>    MaxLeftSum = DivideAndConquer( List, left, center );<br>    MaxRightSum = DivideAndConquer( List, center+<span class="hljs-number">1</span>, right );<br> <br>    <span class="hljs-comment">/* 下面求跨分界线的最大子列和 */</span><br>    MaxLeftBorderSum = <span class="hljs-number">0</span>; LeftBorderSum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>( i=center; i&gt;=left; i-- ) &#123; <span class="hljs-comment">/* 从中线向左扫描 */</span><br>        LeftBorderSum += List[i];<br>        <span class="hljs-keyword">if</span>( LeftBorderSum &gt; MaxLeftBorderSum )<br>            MaxLeftBorderSum = LeftBorderSum;<br>    &#125; <span class="hljs-comment">/* 左边扫描结束 */</span><br> <br>    MaxRightBorderSum = <span class="hljs-number">0</span>; RightBorderSum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>( i=center+<span class="hljs-number">1</span>; i&lt;=right; i++ ) &#123; <span class="hljs-comment">/* 从中线向右扫描 */</span><br>        RightBorderSum += List[i];<br>        <span class="hljs-keyword">if</span>( RightBorderSum &gt; MaxRightBorderSum )<br>            MaxRightBorderSum = RightBorderSum;<br>    &#125; <span class="hljs-comment">/* 右边扫描结束 */</span><br> <br>    <span class="hljs-comment">/* 下面返回&quot;治&quot;的结果 */</span><br>    <span class="hljs-keyword">return</span> Max3( MaxLeftSum, MaxRightSum, MaxLeftBorderSum + MaxRightBorderSum );<br>&#125;<br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">MaxSubseqSum3</span><span class="hljs-params">( <span class="hljs-type">int</span> List[], <span class="hljs-type">int</span> N )</span><br>&#123; <span class="hljs-comment">/* 保持与前2种算法相同的函数接口 */</span><br>    <span class="hljs-keyword">return</span> DivideAndConquer( List, <span class="hljs-number">0</span>, N<span class="hljs-number">-1</span> );<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第二章-线性结构"><a href="#第二章-线性结构" class="headerlink" title="第二章 线性结构"></a>第二章 线性结构</h1><h2 id="2-1-线性表及其实现"><a href="#2-1-线性表及其实现" class="headerlink" title="2.1 线性表及其实现"></a>2.1 线性表及其实现</h2><h3 id="数组实现"><a href="#数组实现" class="headerlink" title="数组实现"></a>数组实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Position;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">List</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> &#123;</span><br>    ElementType Data[MAXSIZE];<br>    Position Last;<br>&#125;;<br> <br><span class="hljs-comment">/* 初始化 */</span><br>List <span class="hljs-title function_">MakeEmpty</span><span class="hljs-params">()</span><br>&#123;<br>    List L;<br> <br>    L = (List)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> LNode));<br>    L-&gt;Last = <span class="hljs-number">-1</span>;<br> <br>    <span class="hljs-keyword">return</span> L;<br>&#125;<br> <br><span class="hljs-comment">/* 查找 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR -1</span><br> <br>Position <span class="hljs-title function_">Find</span><span class="hljs-params">( List L, ElementType X )</span><br>&#123;<br>    Position i = <span class="hljs-number">0</span>;<br> <br>    <span class="hljs-keyword">while</span>( i &lt;= L-&gt;Last &amp;&amp; L-&gt;Data[i]!= X )<br>        i++;<br>    <span class="hljs-keyword">if</span> ( i &gt; L-&gt;Last )  <span class="hljs-keyword">return</span> ERROR; <span class="hljs-comment">/* 如果没找到，返回错误信息 */</span><br>    <span class="hljs-keyword">else</span>  <span class="hljs-keyword">return</span> i;  <span class="hljs-comment">/* 找到后返回的是存储位置 */</span><br>&#125;<br> <br><span class="hljs-comment">/* 插入 */</span><br><span class="hljs-comment">/*注意:在插入位置参数P上与课程视频有所不同，课程视频中i是序列位序（从1开始），这里P是存储下标位置（从0开始），两者差1*/</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">Insert</span><span class="hljs-params">( List L, ElementType X, Position P )</span> <br>&#123; <span class="hljs-comment">/* 在L的指定位置P前插入一个新元素X */</span><br>    Position i;<br> <br>    <span class="hljs-keyword">if</span> ( L-&gt;Last == MAXSIZE<span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-comment">/* 表空间已满，不能插入 */</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;表满&quot;</span>); <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>    &#125;  <br>    <span class="hljs-keyword">if</span> ( P&lt;<span class="hljs-number">0</span> || P&gt;L-&gt;Last+<span class="hljs-number">1</span> ) &#123; <span class="hljs-comment">/* 检查插入位置的合法性 */</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;位置不合法&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>    &#125; <br>    <span class="hljs-keyword">for</span>( i=L-&gt;Last; i&gt;=P; i-- )<br>        L-&gt;Data[i+<span class="hljs-number">1</span>] = L-&gt;Data[i]; <span class="hljs-comment">/* 将位置P及以后的元素顺序向后移动 */</span><br>    L-&gt;Data[P] = X;  <span class="hljs-comment">/* 新元素插入 */</span><br>    L-&gt;Last++;       <span class="hljs-comment">/* Last仍指向最后元素 */</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <br>&#125; <br> <br><span class="hljs-comment">/* 删除 */</span><br><span class="hljs-comment">/*注意:在删除位置参数P上与课程视频有所不同，课程视频中i是序列位序（从1开始），这里P是存储下标位置（从0开始），两者差1*/</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">Delete</span><span class="hljs-params">( List L, Position P )</span><br>&#123; <span class="hljs-comment">/* 从L中删除指定位置P的元素 */</span><br>    Position i;<br> <br>    <span class="hljs-keyword">if</span>( P&lt;<span class="hljs-number">0</span> || P&gt;L-&gt;Last ) &#123; <span class="hljs-comment">/* 检查空表及删除位置的合法性 */</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;位置%d不存在元素&quot;</span>, P ); <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>    &#125;<br>    <span class="hljs-keyword">for</span>( i=P+<span class="hljs-number">1</span>; i&lt;=L-&gt;Last; i++ )<br>        L-&gt;Data[i<span class="hljs-number">-1</span>] = L-&gt;Data[i]; <span class="hljs-comment">/* 将位置P+1及以后的元素顺序向前移动 */</span><br>    L-&gt;Last--; <span class="hljs-comment">/* Last仍指向最后元素 */</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;   <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">PtrToLNode</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> &#123;</span><br>    ElementType Data;<br>    PtrToLNode Next;<br>&#125;;<br><span class="hljs-keyword">typedef</span> PtrToLNode Position;<br><span class="hljs-keyword">typedef</span> PtrToLNode List;<br> <br><span class="hljs-comment">/* 查找 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR NULL</span><br> <br>Position <span class="hljs-title function_">Find</span><span class="hljs-params">( List L, ElementType X )</span><br>&#123;<br>    Position p = L; <span class="hljs-comment">/* p指向L的第1个结点 */</span><br> <br>    <span class="hljs-keyword">while</span> ( p &amp;&amp; p-&gt;Data!=X )<br>        p = p-&gt;Next;<br> <br>    <span class="hljs-comment">/* 下列语句可以用 return p; 替换 */</span><br>    <span class="hljs-keyword">if</span> ( p )<br>        <span class="hljs-keyword">return</span> p;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> ERROR;<br>&#125;<br> <br><span class="hljs-comment">/* 带头结点的插入 */</span><br><span class="hljs-comment">/*注意:在插入位置参数P上与课程视频有所不同，课程视频中i是序列位序（从1开始），这里P是链表结点指针，在P之前插入新结点 */</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">Insert</span><span class="hljs-params">( List L, ElementType X, Position P )</span><br>&#123; <span class="hljs-comment">/* 这里默认L有头结点 */</span><br>    Position tmp, pre;<br> <br>    <span class="hljs-comment">/* 查找P的前一个结点 */</span>        <br>    <span class="hljs-keyword">for</span> ( pre=L; pre&amp;&amp;pre-&gt;Next!=P; pre=pre-&gt;Next ) ;            <br>    <span class="hljs-keyword">if</span> ( pre==<span class="hljs-literal">NULL</span> ) &#123; <span class="hljs-comment">/* P所指的结点不在L中 */</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;插入位置参数错误\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* 找到了P的前一个结点pre */</span><br>        <span class="hljs-comment">/* 在P前插入新结点 */</span><br>        tmp = (Position)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> LNode)); <span class="hljs-comment">/* 申请、填装结点 */</span><br>        tmp-&gt;Data = X; <br>        tmp-&gt;Next = P;<br>        pre-&gt;Next = tmp;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br> <br><span class="hljs-comment">/* 带头结点的删除 */</span><br><span class="hljs-comment">/*注意:在删除位置参数P上与课程视频有所不同，课程视频中i是序列位序（从1开始），这里P是拟删除结点指针 */</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">Delete</span><span class="hljs-params">( List L, Position P )</span><br>&#123; <span class="hljs-comment">/* 这里默认L有头结点 */</span><br>    Position tmp, pre;<br> <br>    <span class="hljs-comment">/* 查找P的前一个结点 */</span>        <br>    <span class="hljs-keyword">for</span> ( pre=L; pre&amp;&amp;pre-&gt;Next!=P; pre=pre-&gt;Next ) ;            <br>    <span class="hljs-keyword">if</span> ( pre==<span class="hljs-literal">NULL</span> || P==<span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">/* P所指的结点不在L中 */</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;删除位置参数错误\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* 找到了P的前一个结点pre */</span><br>        <span class="hljs-comment">/* 将P位置的结点删除 */</span><br>        pre-&gt;Next = P-&gt;Next;<br>        <span class="hljs-built_in">free</span>(P);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-2-堆栈"><a href="#2-2-堆栈" class="headerlink" title="2.2 堆栈"></a>2.2 堆栈</h2><h3 id="数组实现-1"><a href="#数组实现-1" class="headerlink" title="数组实现"></a>数组实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Position;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SNode</span> &#123;</span><br>    ElementType *Data; <span class="hljs-comment">/* 存储元素的数组 */</span><br>    Position Top;      <span class="hljs-comment">/* 栈顶指针 */</span><br>    <span class="hljs-type">int</span> MaxSize;       <span class="hljs-comment">/* 堆栈最大容量 */</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SNode</span> *<span class="hljs-title">Stack</span>;</span><br> <br>Stack <span class="hljs-title function_">CreateStack</span><span class="hljs-params">( <span class="hljs-type">int</span> MaxSize )</span><br>&#123;<br>    Stack S = (Stack)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> SNode));<br>    S-&gt;Data = (ElementType *)<span class="hljs-built_in">malloc</span>(MaxSize * <span class="hljs-keyword">sizeof</span>(ElementType));<br>    S-&gt;Top = <span class="hljs-number">-1</span>;<br>    S-&gt;MaxSize = MaxSize;<br>    <span class="hljs-keyword">return</span> S;<br>&#125;<br> <br><span class="hljs-type">bool</span> <span class="hljs-title function_">IsFull</span><span class="hljs-params">( Stack S )</span><br>&#123;<br>    <span class="hljs-keyword">return</span> (S-&gt;Top == S-&gt;MaxSize<span class="hljs-number">-1</span>);<br>&#125;<br> <br><span class="hljs-type">bool</span> <span class="hljs-title function_">Push</span><span class="hljs-params">( Stack S, ElementType X )</span><br>&#123;<br>    <span class="hljs-keyword">if</span> ( IsFull(S) ) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;堆栈满&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        S-&gt;Data[++(S-&gt;Top)] = X;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br> <br><span class="hljs-type">bool</span> <span class="hljs-title function_">IsEmpty</span><span class="hljs-params">( Stack S )</span><br>&#123;<br>    <span class="hljs-keyword">return</span> (S-&gt;Top == <span class="hljs-number">-1</span>);<br>&#125;<br> <br>ElementType <span class="hljs-title function_">Pop</span><span class="hljs-params">( Stack S )</span><br>&#123;<br>    <span class="hljs-keyword">if</span> ( IsEmpty(S) ) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;堆栈空&quot;</span>);<br>        <span class="hljs-keyword">return</span> ERROR; <span class="hljs-comment">/* ERROR是ElementType的特殊值，标志错误 */</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <br>        <span class="hljs-keyword">return</span> ( S-&gt;Data[(S-&gt;Top)--] );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="链表实现-1"><a href="#链表实现-1" class="headerlink" title="链表实现"></a>链表实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SNode</span> *<span class="hljs-title">PtrToSNode</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SNode</span> &#123;</span><br>    ElementType Data;<br>    PtrToSNode Next;<br>&#125;;<br><span class="hljs-keyword">typedef</span> PtrToSNode Stack;<br> <br>Stack <span class="hljs-title function_">CreateStack</span><span class="hljs-params">( )</span> <br>&#123; <span class="hljs-comment">/* 构建一个堆栈的头结点，返回该结点指针 */</span><br>    Stack S;<br> <br>    S = (Stack)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> SNode));<br>    S-&gt;Next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> S;<br>&#125;<br> <br><span class="hljs-type">bool</span> <span class="hljs-title function_">IsEmpty</span> <span class="hljs-params">( Stack S )</span><br>&#123; <span class="hljs-comment">/* 判断堆栈S是否为空，若是返回true；否则返回false */</span><br>    <span class="hljs-keyword">return</span> ( S-&gt;Next == <span class="hljs-literal">NULL</span> );<br>&#125;<br> <br><span class="hljs-type">bool</span> <span class="hljs-title function_">Push</span><span class="hljs-params">( Stack S, ElementType X )</span><br>&#123; <span class="hljs-comment">/* 将元素X压入堆栈S */</span><br>    PtrToSNode TmpCell;<br> <br>    TmpCell = (PtrToSNode)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> SNode));<br>    TmpCell-&gt;Data = X;<br>    TmpCell-&gt;Next = S-&gt;Next;<br>    S-&gt;Next = TmpCell;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br> <br>ElementType <span class="hljs-title function_">Pop</span><span class="hljs-params">( Stack S )</span>  <br>&#123; <span class="hljs-comment">/* 删除并返回堆栈S的栈顶元素 */</span><br>    PtrToSNode FirstCell;<br>    ElementType TopElem;<br> <br>    <span class="hljs-keyword">if</span>( IsEmpty(S) ) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;堆栈空&quot;</span>); <br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        FirstCell = S-&gt;Next; <br>        TopElem = FirstCell-&gt;Data;<br>        S-&gt;Next = FirstCell-&gt;Next;<br>        <span class="hljs-built_in">free</span>(FirstCell);<br>        <span class="hljs-keyword">return</span> TopElem;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-3-队列"><a href="#2-3-队列" class="headerlink" title="2.3 队列"></a>2.3 队列</h2><h3 id="数组实现-2"><a href="#数组实现-2" class="headerlink" title="数组实现"></a>数组实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Position;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> &#123;</span><br>    ElementType *Data;     <span class="hljs-comment">/* 存储元素的数组 */</span><br>    Position Front, Rear;  <span class="hljs-comment">/* 队列的头、尾指针 */</span><br>    <span class="hljs-type">int</span> MaxSize;           <span class="hljs-comment">/* 队列最大容量 */</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> *<span class="hljs-title">Queue</span>;</span><br> <br>Queue <span class="hljs-title function_">CreateQueue</span><span class="hljs-params">( <span class="hljs-type">int</span> MaxSize )</span><br>&#123;<br>    Queue Q = (Queue)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> QNode));<br>    Q-&gt;Data = (ElementType *)<span class="hljs-built_in">malloc</span>(MaxSize * <span class="hljs-keyword">sizeof</span>(ElementType));<br>    Q-&gt;Front = Q-&gt;Rear = <span class="hljs-number">0</span>;<br>    Q-&gt;MaxSize = MaxSize;<br>    <span class="hljs-keyword">return</span> Q;<br>&#125;<br> <br><span class="hljs-type">bool</span> <span class="hljs-title function_">IsFull</span><span class="hljs-params">( Queue Q )</span><br>&#123;<br>    <span class="hljs-keyword">return</span> ((Q-&gt;Rear+<span class="hljs-number">1</span>)%Q-&gt;MaxSize == Q-&gt;Front);<br>&#125;<br> <br><span class="hljs-type">bool</span> <span class="hljs-title function_">AddQ</span><span class="hljs-params">( Queue Q, ElementType X )</span><br>&#123;<br>    <span class="hljs-keyword">if</span> ( IsFull(Q) ) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;队列满&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        Q-&gt;Rear = (Q-&gt;Rear+<span class="hljs-number">1</span>)%Q-&gt;MaxSize;<br>        Q-&gt;Data[Q-&gt;Rear] = X;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br> <br><span class="hljs-type">bool</span> <span class="hljs-title function_">IsEmpty</span><span class="hljs-params">( Queue Q )</span><br>&#123;<br>    <span class="hljs-keyword">return</span> (Q-&gt;Front == Q-&gt;Rear);<br>&#125;<br> <br>ElementType <span class="hljs-title function_">DeleteQ</span><span class="hljs-params">( Queue Q )</span><br>&#123;<br>    <span class="hljs-keyword">if</span> ( IsEmpty(Q) ) &#123; <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;队列空&quot;</span>);<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-keyword">else</span>  &#123;<br>        Q-&gt;Front =(Q-&gt;Front+<span class="hljs-number">1</span>)%Q-&gt;MaxSize;<br>        <span class="hljs-keyword">return</span>  Q-&gt;Data[Q-&gt;Front];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="链表实现-2"><a href="#链表实现-2" class="headerlink" title="链表实现"></a>链表实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">PtrToNode</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span> <span class="hljs-comment">/* 队列中的结点 */</span><br>    ElementType Data;<br>    PtrToNode Next;<br>&#125;;<br><span class="hljs-keyword">typedef</span> PtrToNode Position;<br> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> &#123;</span><br>    Position Front, Rear;  <span class="hljs-comment">/* 队列的头、尾指针 */</span><br>    <span class="hljs-type">int</span> MaxSize;           <span class="hljs-comment">/* 队列最大容量 */</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> *<span class="hljs-title">Queue</span>;</span><br> <br><span class="hljs-type">bool</span> <span class="hljs-title function_">IsEmpty</span><span class="hljs-params">( Queue Q )</span><br>&#123;<br>    <span class="hljs-keyword">return</span> ( Q-&gt;Front == <span class="hljs-literal">NULL</span>);<br>&#125;<br> <br>ElementType <span class="hljs-title function_">DeleteQ</span><span class="hljs-params">( Queue Q )</span><br>&#123;<br>    Position FrontCell; <br>    ElementType FrontElem;<br>     <br>    <span class="hljs-keyword">if</span>  ( IsEmpty(Q) ) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;队列空&quot;</span>);<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        FrontCell = Q-&gt;Front;<br>        <span class="hljs-keyword">if</span> ( Q-&gt;Front == Q-&gt;Rear ) <span class="hljs-comment">/* 若队列只有一个元素 */</span><br>            Q-&gt;Front = Q-&gt;Rear = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">/* 删除后队列置为空 */</span><br>        <span class="hljs-keyword">else</span>                     <br>            Q-&gt;Front = Q-&gt;Front-&gt;Next;<br>        FrontElem = FrontCell-&gt;Data;<br> <br>        <span class="hljs-built_in">free</span>( FrontCell );  <span class="hljs-comment">/* 释放被删除结点空间  */</span><br>        <span class="hljs-keyword">return</span>  FrontElem;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第三章-树"><a href="#第三章-树" class="headerlink" title="第三章 树"></a>第三章 树</h1><h2 id="3-3-二叉树的遍历"><a href="#3-3-二叉树的遍历" class="headerlink" title="3.3 二叉树的遍历"></a>3.3 二叉树的遍历</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">InorderTraversal</span><span class="hljs-params">( BinTree BT )</span><br>&#123;<br>    <span class="hljs-keyword">if</span>( BT ) &#123;<br>        InorderTraversal( BT-&gt;Left );<br>        <span class="hljs-comment">/* 此处假设对BT结点的访问就是打印数据 */</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, BT-&gt;Data); <span class="hljs-comment">/* 假设数据为整型 */</span><br>        InorderTraversal( BT-&gt;Right );<br>    &#125;<br>&#125;<br> <br><span class="hljs-type">void</span> <span class="hljs-title function_">PreorderTraversal</span><span class="hljs-params">( BinTree BT )</span><br>&#123;<br>    <span class="hljs-keyword">if</span>( BT ) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, BT-&gt;Data );<br>        PreorderTraversal( BT-&gt;Left );<br>        PreorderTraversal( BT-&gt;Right );<br>    &#125;<br>&#125;<br> <br><span class="hljs-type">void</span> <span class="hljs-title function_">PostorderTraversal</span><span class="hljs-params">( BinTree BT )</span><br>&#123;<br>    <span class="hljs-keyword">if</span>( BT ) &#123;<br>        PostorderTraversal( BT-&gt;Left );<br>        PostorderTraversal( BT-&gt;Right );<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, BT-&gt;Data);<br>    &#125;<br>&#125;<br> <br><span class="hljs-type">void</span> <span class="hljs-title function_">LevelorderTraversal</span> <span class="hljs-params">( BinTree BT )</span><br>&#123; <br>    Queue Q; <br>    BinTree T;<br> <br>    <span class="hljs-keyword">if</span> ( !BT ) <span class="hljs-keyword">return</span>; <span class="hljs-comment">/* 若是空树则直接返回 */</span><br>     <br>    Q = CreatQueue(); <span class="hljs-comment">/* 创建空队列Q */</span><br>    AddQ( Q, BT );<br>    <span class="hljs-keyword">while</span> ( !IsEmpty(Q) ) &#123;<br>        T = DeleteQ( Q );<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, T-&gt;Data); <span class="hljs-comment">/* 访问取出队列的结点 */</span><br>        <span class="hljs-keyword">if</span> ( T-&gt;Left )   AddQ( Q, T-&gt;Left );<br>        <span class="hljs-keyword">if</span> ( T-&gt;Right )  AddQ( Q, T-&gt;Right );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>堆栈</tag>
      
      <tag>队列</tag>
      
      <tag>链表</tag>
      
      <tag>树</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蓝桥杯嵌入式 国赛扩展板 CT117E-EX 学习笔记</title>
    <link href="/2019/ea2a1972/"/>
    <url>/2019/ea2a1972/</url>
    
    <content type="html"><![CDATA[<h1 id="蓝桥杯嵌入式国赛扩展板-CT117E-EX-学习笔记"><a href="#蓝桥杯嵌入式国赛扩展板-CT117E-EX-学习笔记" class="headerlink" title="蓝桥杯嵌入式国赛扩展板 CT117E-EX 学习笔记"></a>蓝桥杯嵌入式国赛扩展板 CT117E-EX 学习笔记</h1><h1 id="CT117E-EX-扩展板笔记"><a href="#CT117E-EX-扩展板笔记" class="headerlink" title="CT117E-EX 扩展板笔记"></a>CT117E-EX 扩展板笔记</h1><hr><h2 id="数码管（74HC595）"><a href="#数码管（74HC595）" class="headerlink" title="数码管（74HC595）"></a>数码管（74HC595）</h2><blockquote><p>博主参加国赛有点皮，准备的不够就参赛了，结果国赛没敲出来数码管实在有点可惜。望看到本文的朋友在准备国赛一定要把这个功能做到盲打出来，第十届国赛没提供数码管的驱动。</p></blockquote><h3 id="RCLK-R-存储寄存器读取"><a href="#RCLK-R-存储寄存器读取" class="headerlink" title="RCLK(R:存储寄存器读取)"></a>RCLK(R:存储寄存器读取)</h3><ul><li>上升沿    移位寄存器进入存储寄存器</li><li>下降沿    数据保持不变</li></ul><h3 id="SCK-S-送入595"><a href="#SCK-S-送入595" class="headerlink" title="SCK(S:送入595)"></a>SCK(S:送入595)</h3><ul><li>上升沿    数据寄存器数据移位。Q0–&gt;Q1–&gt;Q2–&gt;Q3–&gt;…–&gt;Q7;</li><li>下降沿    移位寄存器数据不变</li></ul><h3 id="SER（数据脚）"><a href="#SER（数据脚）" class="headerlink" title="SER（数据脚）"></a>SER（数据脚）</h3><ul><li>串行数据输入端</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">SEG_DisplayValue</span><span class="hljs-params">(u8 Bit1,  u8 Bit2, u8 Bit3)</span><br>&#123;<br>u8 i = <span class="hljs-number">0</span>;<span class="hljs-comment">//</span><br>u8 code_tmp = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    *略过部分代码</span><br><span class="hljs-comment">    */</span><br><br>code_tmp = Seg7[Bit1];<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)&#123;<br><br><span class="hljs-keyword">if</span>(code_tmp &amp; <span class="hljs-number">0x80</span>)&#123;<br>SER_H;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>SER_L;<br>&#125;<br>SCK_H;<span class="hljs-comment">//数据移位</span><br>code_tmp = code_tmp &lt;&lt; <span class="hljs-number">1</span>;   <br>SCK_L;<br>&#125;<br>RCLK_H;<span class="hljs-comment">//上升沿时移位寄存器进入存储寄存器</span><br>RCLK_L;<span class="hljs-comment">//下降沿是数据保持不变</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数码管显示数组"><a href="#数码管显示数组" class="headerlink" title="数码管显示数组"></a>数码管显示数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">u8 code t_display[]=&#123;                       <span class="hljs-comment">//标准字库</span><br><span class="hljs-comment">//   0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F</span><br><span class="hljs-number">0x3F</span>,<span class="hljs-number">0x06</span>,<span class="hljs-number">0x5B</span>,<span class="hljs-number">0x4F</span>,<span class="hljs-number">0x66</span>,<span class="hljs-number">0x6D</span>,<span class="hljs-number">0x7D</span>,<span class="hljs-number">0x07</span>,<span class="hljs-number">0x7F</span>,<span class="hljs-number">0x6F</span>,<span class="hljs-number">0x77</span>,<span class="hljs-number">0x7C</span>,<span class="hljs-number">0x39</span>,<span class="hljs-number">0x5E</span>,<span class="hljs-number">0x79</span>,<span class="hljs-number">0x71</span>,<br><br><span class="hljs-comment">//black  -     H    J    K    L    N    o   P    U     t    G    Q    r   M    y</span><br><span class="hljs-number">0x00</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x76</span>,<span class="hljs-number">0x1E</span>,<span class="hljs-number">0x70</span>,<span class="hljs-number">0x38</span>,<span class="hljs-number">0x37</span>,<span class="hljs-number">0x5C</span>,<span class="hljs-number">0x73</span>,<span class="hljs-number">0x3E</span>,<span class="hljs-number">0x78</span>,<span class="hljs-number">0x3d</span>,<span class="hljs-number">0x67</span>,<span class="hljs-number">0x50</span>,<span class="hljs-number">0x37</span>,<span class="hljs-number">0x6e</span>,<br>    <br> <span class="hljs-comment">//0. 1. 2. 3. 4. 5. 6. 7. 8. 9. -1</span><br><span class="hljs-number">0xBF</span>,<span class="hljs-number">0x86</span>,<span class="hljs-number">0xDB</span>,<span class="hljs-number">0xCF</span>,<span class="hljs-number">0xE6</span>,<span class="hljs-number">0xED</span>,<span class="hljs-number">0xFD</span>,<span class="hljs-number">0x87</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xEF</span>,<span class="hljs-number">0x46</span>&#125;;    <br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//   0    1    2    3    4    5    6    7    8    9</span><br><br><span class="hljs-number">0x3F</span>,<span class="hljs-number">0x06</span>,<span class="hljs-number">0x5B</span>,<span class="hljs-number">0x4F</span>,<span class="hljs-number">0x66</span>,<span class="hljs-number">0x6D</span>,<span class="hljs-number">0x7D</span>,<span class="hljs-number">0x07</span>,<span class="hljs-number">0x7F</span>,<span class="hljs-number">0x6F</span>,<span class="hljs-number">0x77</span><br></code></pre></td></tr></table></figure><hr><h2 id="ADC按键"><a href="#ADC按键" class="headerlink" title="ADC按键"></a>ADC按键</h2><h3 id="ADC-KEY-引脚"><a href="#ADC-KEY-引脚" class="headerlink" title="ADC KEY 引脚"></a>ADC KEY 引脚</h3><p> PA5      ADC_12_<strong>IN5</strong></p><blockquote><p>背下ADC按键区间</p></blockquote><h3 id="按键值"><a href="#按键值" class="headerlink" title="按键值"></a>按键值</h3><table><thead><tr><th align="left">ADC值</th><th>ADC按键区间</th></tr></thead><tbody><tr><td align="left">0</td><td>&lt;100</td></tr><tr><td align="left">200</td><td>&lt;400</td></tr><tr><td align="left">600</td><td>&lt;800</td></tr><tr><td align="left">1000</td><td>&lt;1200</td></tr><tr><td align="left">1300-1400</td><td>&lt;1600</td></tr><tr><td align="left">1700-1900</td><td>&lt;2000</td></tr><tr><td align="left">2100-2400</td><td>&lt;2600</td></tr><tr><td align="left">2800-3000</td><td>&lt;3200</td></tr></tbody></table><hr><h2 id="DHT11模块"><a href="#DHT11模块" class="headerlink" title="DHT11模块"></a>DHT11模块</h2><h3 id="芯片性能"><a href="#芯片性能" class="headerlink" title="芯片性能"></a>芯片性能</h3><ul><li>温度测量范围：0－50℃</li><li>湿度测量范围：20－90％RH</li><li>采样周期 ：1S</li></ul><h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><table><thead><tr><th>Byte0</th><th>Byte1</th><th>Byte2</th><th>Byte3</th><th>Byte4</th></tr></thead><tbody><tr><td>湿度整数数据</td><td>湿度小数数据</td><td>温度整数数据</td><td>温度小数数据</td><td>校验和</td></tr></tbody></table><h3 id="编程思路"><a href="#编程思路" class="headerlink" title="编程思路"></a>编程思路</h3><ul><li>主机输出</li><li>主机拉  <strong>低</strong>  至少 <font color="red">18ms</font></li><li>主机拉  <strong>高</strong>  <font color="red">20-40us</font></li><li>主机输入</li><li>主机等待信号线拉 <strong>低</strong>   （DHT11发送持续  <strong>40-50us</strong> 的  <strong>低</strong>   响应信号）</li><li>主机等待信号线拉 <strong>高</strong>   （DHT11发送持续  <strong>40-50us</strong> 的  <strong>高</strong>   拉高信号）</li><li>for(){   &#x2F;&#x2F;40bit数据       5Byte<ul><li>主机等待数据线拉<strong>低</strong>    （数据Bit开始）</li><li>主机等待数据线拉<strong>高</strong>    </li><li>主机延时 时间大于<strong>28us</strong>小于<strong>70us</strong>    （ <font color="red">Type值 40us</font>）</li><li>主机读取数据</li></ul></li><li>}</li><li>主机输出</li><li>主机拉高</li></ul><h3 id="技巧-TIP"><a href="#技巧-TIP" class="headerlink" title="技巧&amp;TIP"></a>技巧&amp;TIP</h3><ul><li>DHT11分辨率都是整数级别的<strong>读取小数的数据部分没有意义</strong>。（全为0）</li><li>读取间隔建议大于100ms（采样 1S 过高的读取频率没有意义）</li><li>在72MHz频率下 <strong>Delay_LCD</strong> 运行一次大约 <strong>375us</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Delay_LCD</span><span class="hljs-params">(u16 n)</span><br>&#123;<br>u16 i,j;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>;i&lt;n;++i)<br><span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">3000</span>;++j);<br>&#125;<br><span class="hljs-comment">//将里面的 3000 改成 8 运行一次大概 1us </span><br><span class="hljs-comment">//运行次数越少比1us越多</span><br><span class="hljs-comment">//运行次数越多比1us越少</span><br></code></pre></td></tr></table></figure><hr><h2 id="18B20模块"><a href="#18B20模块" class="headerlink" title="18B20模块"></a>18B20模块</h2><h3 id="芯片性能-1"><a href="#芯片性能-1" class="headerlink" title="芯片性能"></a>芯片性能</h3><ul><li>±0.5°C accuracy from -10°C to +85°C</li><li>Can be powered from data line. Power supply range is 3.0V to 5.5V</li><li>Converts 12-bit temperature to digital word in 750 ms (max.)</li></ul><h3 id="数据格式-1"><a href="#数据格式-1" class="headerlink" title="数据格式"></a>数据格式</h3><h4 id="数据格式-2"><a href="#数据格式-2" class="headerlink" title="数据格式"></a>数据格式</h4><ul><li>写Byte数据先写<strong>低位</strong></li><li>读Byte数据先读出的是<strong>低位</strong></li><li>读出来的温度先是  <strong>LSM 8bit</strong>  然后是 MSB 8bit</li></ul><h4 id="总线协议-时序"><a href="#总线协议-时序" class="headerlink" title="总线协议&amp;时序"></a>总线协议&amp;时序</h4><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-n4fqEHfa-1627893566676)(蓝桥杯嵌入式决赛笔记.assets&#x2F;01-1557625836489.png)]</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-MDCAsN9Z-1627893566679)(蓝桥杯嵌入式决赛笔记.assets&#x2F;02.png)]</p><h3 id="编程思路-1"><a href="#编程思路-1" class="headerlink" title="编程思路"></a>编程思路</h3><blockquote><p>第十届提供了底层接口，比赛会下面这些就好了</p></blockquote><p>0xCCOW_SKIP_ROM</p><p>0x44DS18B20_CONVERT</p><p>0xCCOW_SKIP_ROM</p><p>0xBEDS18B20_READ</p><hr><h2 id="LIS302DL"><a href="#LIS302DL" class="headerlink" title="LIS302DL"></a>LIS302DL</h2><p>NULL</p><hr><h2 id="光敏-D-A"><a href="#光敏-D-A" class="headerlink" title="光敏 D&amp;A"></a>光敏 D&amp;A</h2><h3 id="光敏D"><a href="#光敏D" class="headerlink" title="光敏D"></a>光敏D</h3><ul><li>GPIOA_Pin_3 </li><li>GPIO_Mode_IPU</li></ul><h3 id="光敏A"><a href="#光敏A" class="headerlink" title="光敏A"></a>光敏A</h3><blockquote><p>AD通道号就是Pin号</p></blockquote><ul><li>GPIOA_Pin_4</li><li>ADC1</li><li>ADC_Channel_4</li></ul><hr><h2 id="电位器"><a href="#电位器" class="headerlink" title="电位器"></a>电位器</h2><blockquote><p>省赛内容没什么好说的</p></blockquote><p>NULL</p><hr><h2 id="PULS-PWM"><a href="#PULS-PWM" class="headerlink" title="PULS&amp;PWM"></a>PULS&amp;PWM</h2><blockquote><p>比较捕获模式万能解题。如果题目不是要求同时采集CH1和CH2可以用PWM捕获模式挺好用的，改进一下可以不使用中断直接读取出占空比和频率，效率挺高。</p></blockquote><p>PA1        TIM2_CH2</p><p>PA2        TIM2_CH3</p><p>PA6        TIM3_CH1</p><p>PA7        TIM3_CH2</p><hr><h2 id="界面颜色搭配"><a href="#界面颜色搭配" class="headerlink" title="界面颜色搭配"></a>界面颜色搭配</h2><blockquote><p>萝卜青菜各有所爱，好看就行了</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">LCD_SetBackColor(Blue);<span class="hljs-comment">//界面标题</span><br>LCD_SetTextColor(White);<br><span class="hljs-comment">//Line01</span><br>LCD_SetBackColor(White);<span class="hljs-comment">//界面内容</span><br>LCD_SetTextColor(Blue);<br><span class="hljs-comment">//Line1-77</span><br>LCD_SetBackColor(Blue);<span class="hljs-comment">//界面介绍</span><br>LCD_SetTextColor(Black);<br><span class="hljs-comment">//Line892</span><br></code></pre></td></tr></table></figure><h1 id="蓝桥的其他文章与我个人敲的代码"><a href="#蓝桥的其他文章与我个人敲的代码" class="headerlink" title="蓝桥的其他文章与我个人敲的代码"></a>蓝桥的其他文章与我个人敲的代码</h1><p><a href="https://blog.csdn.net/weixin_42078116/article/details/87983401">蓝桥杯嵌入式STM32 零碎笔记</a></p><p><a href="https://blog.csdn.net/weixin_42078116/article/details/90905914">蓝桥杯嵌入式 错题本</a></p><p>省赛及国赛的赛题的实现代码可以在我的下载里面找到</p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>蓝桥杯</tag>
      
      <tag>ct117e-ex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蓝桥杯嵌入式 错题本</title>
    <link href="/2019/62231d0e/"/>
    <url>/2019/62231d0e/</url>
    
    <content type="html"><![CDATA[<h1 id="杂乱笔记"><a href="#杂乱笔记" class="headerlink" title="杂乱笔记"></a>杂乱笔记</h1><hr><h2 id="Keil仿真准确测量运行时间"><a href="#Keil仿真准确测量运行时间" class="headerlink" title="Keil仿真准确测量运行时间"></a>Keil仿真准确测量运行时间</h2><p>Debug-&gt;Setting-&gt;Trsce-&gt;Core 修改好核心时钟频率即可准确测量函数运行时间</p><hr><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><blockquote><p>图看百度</p></blockquote><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-CSWmqarp-1627893544937)(STM32杂乱笔记.assets&#x2F;00.jpg)]</p><ul><li>坑</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//编译报错</span><br>(DS18B20_DQ_IN != <span class="hljs-number">0</span>)? data_temp |= <span class="hljs-number">0x80</span>:data_temp&amp;=<span class="hljs-number">0x7f</span>;<br><br><span class="hljs-comment">//规范写法</span><br>(DS18B20_DQ_IN!=<span class="hljs-number">0</span>)? (data_temp|=<span class="hljs-number">0x80</span>):(data_temp&amp;=<span class="hljs-number">0x7f</span>);<br></code></pre></td></tr></table></figure><ul><li>！！！极注意！！！  请小心有位运算时打上括号            &lt;&lt;  比  +-  要低</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">u16 temp;<br>u8 h,l;<br>temp = (u16)(h&lt;&lt;<span class="hljs-number">8</span>) + l;<span class="hljs-comment">// 正确语法</span><br>temp = h&lt;&lt;<span class="hljs-number">8</span> + l;<span class="hljs-comment">// 错误语法！！！！！</span><br></code></pre></td></tr></table></figure><hr><h2 id="snprintf"><a href="#snprintf" class="headerlink" title="snprintf();"></a>snprintf();</h2><ul><li>所传入的值以<strong>‘&#x2F;0’</strong>结尾    要得到   <strong>20</strong>  个数据需要传入参数  <strong>20+1</strong></li></ul><hr><h2 id="通用-TIM-输出低电平"><a href="#通用-TIM-输出低电平" class="headerlink" title="通用  TIM  输出低电平"></a>通用  TIM  输出低电平</h2><p>调用 TIM_CCxCmd 关闭输出使能即可<strong>持续输出低电平</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">TIM_CCxCmd</span><span class="hljs-params">(TIM_TypeDef* TIMx, <span class="hljs-type">uint16_t</span> TIM_Channel, <span class="hljs-type">uint16_t</span> TIM_CCx)</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>CCxE位</th><th>OCx输出状态</th></tr></thead><tbody><tr><td>0</td><td>禁止输出(OCx&#x3D;0，OCx_EN&#x3D;0)</td></tr><tr><td>1</td><td>OCx &#x3D; OCxREF + 极性，OCx_EN&#x3D;1</td></tr></tbody></table><hr><h2 id="Printf第一个字符丢失"><a href="#Printf第一个字符丢失" class="headerlink" title="Printf第一个字符丢失"></a>Printf第一个字符丢失</h2><ul><li>将发送放在等待标志位后面即可解决问题</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">&#123;<br><span class="hljs-comment">/* Loop until the end of transmission */</span><br><span class="hljs-keyword">while</span> (USART_GetFlagStatus(USART2, USART_FLAG_TC) == RESET);<br><br><span class="hljs-comment">/* Place your implementation of fputc here */</span><br><span class="hljs-comment">/* e.g. write a character to the USART */</span><br>USART_SendData(USART2, (<span class="hljs-type">uint8_t</span>) ch);<br><br><span class="hljs-keyword">return</span> ch;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="union计算移位"><a href="#union计算移位" class="headerlink" title="union计算移位"></a>union计算移位</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">union</span><br>&#123;<br>u16 Val_u16;<br>u8 Val_u8[<span class="hljs-number">2</span>];<br>&#125;_HL_UNION;<br></code></pre></td></tr></table></figure><hr><h2 id="USART里面DMA要修改"><a href="#USART里面DMA要修改" class="headerlink" title="USART里面DMA要修改"></a>USART里面DMA要修改</h2><p>移植官方的库的时候     要把DST(destination) 为 SRC(source)</p><hr><h2 id="做赛题时遇到的问题"><a href="#做赛题时遇到的问题" class="headerlink" title="做赛题时遇到的问题"></a>做赛题时遇到的问题</h2><ul><li><p>AO1 AO2无法满量程  4068</p></li><li><p>display 一次时间太久</p><ul><li>分成Init 和刷新部分     且每次刷新屏幕一行</li></ul></li><li><p>IT.c 文件复制模板</p><ul><li>Get</li></ul></li><li><p>RCC_PCLK1Config（）是什么东西</p><ul><li>预分频</li></ul></li><li><p>ADC_GetFlag    ADC_FLAG_EOC 完成标志位</p><ul><li>1为完成   <code>！= SET</code></li></ul></li><li><p>Snprintf对浮点数的对齐处理似乎有问题</p><ul><li>手动对齐</li></ul></li><li><p>R37</p><ul><li>ADC12 CH8</li></ul></li><li><p>RTC ！！！！  </p><ul><li>注意！要在官方库文件里面加SetCounter！还要修改分频系数！  </li><li>分频系数要改，然后还要加一个预装载值</li></ul></li><li><p>USART2的RX     DMA  CH6</p><ul><li>USART2 RX</li><li>DMA_SetCurrDataCounter 要先关闭  DMA 使能时才能调用</li><li>注意数组的越界！！！！！</li></ul></li><li><p>关于TIM2的CH3与USART2的TX冲突的解决办法</p><ul><li>关闭USART2使能       关闭USART2时钟          使能CH3              ———-&amp;&#x2F;&#x2F;使能</li><li>关闭CH3                      打开USART2时钟         打开USART2使能 ———-&amp;&#x2F;&#x2F;使能</li></ul></li><li><p>define   （x）   </p><ul><li>只是简单代换注意括号</li></ul></li><li><p>usart例程没开 usart  时钟？</p><ul><li>在.h文件里面</li></ul></li><li><p>usart与捕获不冲突</p><ul><li>对  不冲突</li></ul></li><li><p>相位不同的互补方波</p><ul><li>重置定时器</li><li>再重新Init</li></ul></li><li><p>强制为    高&#x2F;低    电平    TIM_ForcedOCxConfig     </p><ul><li>强制电平是类似于 OC 的一种 Mode 用完了需要    TIM_OCxInit</li></ul></li><li><p>操作LED后要将573的N_LE引脚拉低    这样才能避免操作LCD时影响到LED的亮灭。</p></li><li><p>USART_IT_IDLE 空闲中断要用   USART_ReceiveData(USARTx);  或者  USARTx-&gt;SR; USARTx-&gt;DR;   清除中断。USART_ClearITPendingBit清除不了。</p></li></ul><h1 id="蓝桥的其他文章与我个人敲的代码"><a href="#蓝桥的其他文章与我个人敲的代码" class="headerlink" title="蓝桥的其他文章与我个人敲的代码"></a>蓝桥的其他文章与我个人敲的代码</h1><p><a href="https://blog.csdn.net/weixin_42078116/article/details/87983401">蓝桥杯嵌入式STM32 零碎笔记</a></p><p><a href="https://blog.csdn.net/weixin_42078116/article/details/90905706">蓝桥杯嵌入式国赛扩展板 CT117E-EX 学习</a></p><p>省赛及国赛的赛题的实现代码可以在我的下载里面找到</p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蓝桥杯STM32国赛笔记</title>
    <link href="/2019/b9b15cd2/"/>
    <url>/2019/b9b15cd2/</url>
    
    <content type="html"><![CDATA[<h1 id="CT117E-EX-扩展板笔记"><a href="#CT117E-EX-扩展板笔记" class="headerlink" title="CT117E-EX 扩展板笔记"></a>CT117E-EX 扩展板笔记</h1><h2 id="数码管（74HC595）"><a href="#数码管（74HC595）" class="headerlink" title="数码管（74HC595）"></a>数码管（74HC595）</h2><h3 id="RCLK-R-存储寄存器读取"><a href="#RCLK-R-存储寄存器读取" class="headerlink" title="RCLK(R:存储寄存器读取)"></a>RCLK(R:存储寄存器读取)</h3><ul><li>上升沿    移位寄存器进入存储寄存器</li><li>下降沿    数据保持不变</li></ul><h3 id="SCK-S-送入595"><a href="#SCK-S-送入595" class="headerlink" title="SCK(S:送入595)"></a>SCK(S:送入595)</h3><ul><li>上升沿    数据寄存器数据移位。Q0–&gt;Q1–&gt;Q2–&gt;Q3–&gt;…–&gt;Q7;</li><li>下降沿    移位寄存器数据不变</li></ul><h3 id="SER（数据脚）"><a href="#SER（数据脚）" class="headerlink" title="SER（数据脚）"></a>SER（数据脚）</h3><ul><li>串行数据输入端</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">SEG_DisplayValue</span><span class="hljs-params">(u8 Bit1,  u8 Bit2, u8 Bit3)</span><br>&#123;<br>u8 i = <span class="hljs-number">0</span>;<span class="hljs-comment">//</span><br>u8 code_tmp = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    *略过部分代码</span><br><span class="hljs-comment">    */</span><br><br>code_tmp = Seg7[Bit1];<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)&#123;<br><br><span class="hljs-keyword">if</span>(code_tmp &amp; <span class="hljs-number">0x80</span>)&#123;<br>SER_H;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>SER_L;<br>&#125;<br>SCK_H;<span class="hljs-comment">//数据移位</span><br>code_tmp = code_tmp &lt;&lt; <span class="hljs-number">1</span>;   <br>SCK_L;<br>&#125;<br>RCLK_H;<span class="hljs-comment">//上升沿时移位寄存器进入存储寄存器</span><br>RCLK_L;<span class="hljs-comment">//下降沿是数据保持不变</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数码管显示数组"><a href="#数码管显示数组" class="headerlink" title="数码管显示数组"></a>数码管显示数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">u8 code t_display[]=&#123;                       <span class="hljs-comment">//标准字库</span><br><span class="hljs-comment">//   0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F</span><br><span class="hljs-number">0x3F</span>,<span class="hljs-number">0x06</span>,<span class="hljs-number">0x5B</span>,<span class="hljs-number">0x4F</span>,<span class="hljs-number">0x66</span>,<span class="hljs-number">0x6D</span>,<span class="hljs-number">0x7D</span>,<span class="hljs-number">0x07</span>,<span class="hljs-number">0x7F</span>,<span class="hljs-number">0x6F</span>,<span class="hljs-number">0x77</span>,<span class="hljs-number">0x7C</span>,<span class="hljs-number">0x39</span>,<span class="hljs-number">0x5E</span>,<span class="hljs-number">0x79</span>,<span class="hljs-number">0x71</span>,<br><br><span class="hljs-comment">//black  -     H    J    K    L    N    o   P    U     t    G    Q    r   M    y</span><br><span class="hljs-number">0x00</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x76</span>,<span class="hljs-number">0x1E</span>,<span class="hljs-number">0x70</span>,<span class="hljs-number">0x38</span>,<span class="hljs-number">0x37</span>,<span class="hljs-number">0x5C</span>,<span class="hljs-number">0x73</span>,<span class="hljs-number">0x3E</span>,<span class="hljs-number">0x78</span>,<span class="hljs-number">0x3d</span>,<span class="hljs-number">0x67</span>,<span class="hljs-number">0x50</span>,<span class="hljs-number">0x37</span>,<span class="hljs-number">0x6e</span>,<br>    <br> <span class="hljs-comment">//0. 1. 2. 3. 4. 5. 6. 7. 8. 9. -1</span><br><span class="hljs-number">0xBF</span>,<span class="hljs-number">0x86</span>,<span class="hljs-number">0xDB</span>,<span class="hljs-number">0xCF</span>,<span class="hljs-number">0xE6</span>,<span class="hljs-number">0xED</span>,<span class="hljs-number">0xFD</span>,<span class="hljs-number">0x87</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xEF</span>,<span class="hljs-number">0x46</span>&#125;;    <br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//   0    1    2    3    4    5    6    7    8    9</span><br><br><span class="hljs-number">0x3F</span>,<span class="hljs-number">0x06</span>,<span class="hljs-number">0x5B</span>,<span class="hljs-number">0x4F</span>,<span class="hljs-number">0x66</span>,<span class="hljs-number">0x6D</span>,<span class="hljs-number">0x7D</span>,<span class="hljs-number">0x07</span>,<span class="hljs-number">0x7F</span>,<span class="hljs-number">0x6F</span>,<span class="hljs-number">0x77</span><br></code></pre></td></tr></table></figure><h2 id="ADC按键"><a href="#ADC按键" class="headerlink" title="ADC按键"></a>ADC按键</h2><h3 id="ADC-KEY-引脚"><a href="#ADC-KEY-引脚" class="headerlink" title="ADC KEY 引脚"></a>ADC KEY 引脚</h3><p> PA5      ADC_12_<strong>IN5</strong></p><h3 id="按键值"><a href="#按键值" class="headerlink" title="按键值"></a>按键值</h3><table><thead><tr><th align="left">ADC值</th><th>ADC按键区间</th></tr></thead><tbody><tr><td align="left">0</td><td>&lt;100</td></tr><tr><td align="left">200</td><td>&lt;400</td></tr><tr><td align="left">600</td><td>&lt;800</td></tr><tr><td align="left">1000</td><td>&lt;1200</td></tr><tr><td align="left">1300-1400</td><td>&lt;1600</td></tr><tr><td align="left">1700-1900</td><td>&lt;2000</td></tr><tr><td align="left">2100-2400</td><td>&lt;2600</td></tr><tr><td align="left">2800-3000</td><td>&lt;3200</td></tr></tbody></table><h2 id="DHT11模块"><a href="#DHT11模块" class="headerlink" title="DHT11模块"></a>DHT11模块</h2><h3 id="芯片性能"><a href="#芯片性能" class="headerlink" title="芯片性能"></a>芯片性能</h3><ul><li>温度测量范围：0－50℃</li><li>湿度测量范围：20－90％RH</li><li>采样周期 ：1S</li></ul><h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><table><thead><tr><th>Byte0</th><th>Byte1</th><th>Byte2</th><th>Byte3</th><th>Byte4</th></tr></thead><tbody><tr><td>湿度整数数据</td><td>湿度小数数据</td><td>温度整数数据</td><td>温度小数数据</td><td>校验和</td></tr></tbody></table><h3 id="编程思路"><a href="#编程思路" class="headerlink" title="编程思路"></a>编程思路</h3><ul><li>主机输出</li><li>主机拉  <strong>低</strong>  至少 <font color="red">18ms</font></li><li>主机拉  <strong>高</strong>  <font color="red">20-40us</font></li><li>主机输入</li><li>主机等待信号线拉 <strong>低</strong>   （DHT11发送持续  <strong>40-50us</strong> 的  <strong>低</strong>   响应信号）</li><li>主机等待信号线拉 <strong>高</strong>   （DHT11发送持续  <strong>40-50us</strong> 的  <strong>高</strong>   拉高信号）</li><li>for(){   &#x2F;&#x2F;40bit数据       5Byte<ul><li>主机等待数据线拉<strong>低</strong>    （数据Bit开始）</li><li>主机等待数据线拉<strong>高</strong>    </li><li>主机延时 时间大于<strong>28us</strong>小于<strong>70us</strong>    （ <font color="red">Type值 40us</font>）</li><li>主机读取数据</li></ul></li><li>}</li><li>主机输出</li><li>主机拉高</li></ul><h3 id="技巧-TIP"><a href="#技巧-TIP" class="headerlink" title="技巧&amp;TIP"></a>技巧&amp;TIP</h3><ul><li><p>DHT11分辨率都是整数级别的<strong>读取小数的数据部分没有意义</strong>。（全为0）</p></li><li><p>读取间隔建议大于100ms（采样 1S 过高的读取频率没有意义）</p></li><li><p>在72MHz频率下 <strong>Delay_LCD</strong> 运行一次大约 <strong>375us</strong></p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Delay_LCD</span><span class="hljs-params">(u16 n)</span><br>&#123;<br>u16 i,j;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>;i&lt;n;++i)<br><span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">3000</span>;++j);<br>&#125;<br><span class="hljs-comment">//将里面的 3000 改成 8 运行一次大概 1us </span><br><span class="hljs-comment">//运行次数越少比1us越多</span><br><span class="hljs-comment">//运行次数越多比1us越少</span><br></code></pre></td></tr></table></figure><h2 id="18B20模块"><a href="#18B20模块" class="headerlink" title="18B20模块"></a>18B20模块</h2><h3 id="芯片性能-1"><a href="#芯片性能-1" class="headerlink" title="芯片性能"></a>芯片性能</h3><ul><li>±0.5°C accuracy from -10°C to +85°C</li><li>Can be powered from data line. Power supply range is 3.0V to 5.5V</li><li>Converts 12-bit temperature to digital word in 750 ms (max.)</li></ul><h3 id="数据格式-1"><a href="#数据格式-1" class="headerlink" title="数据格式"></a>数据格式</h3><h4 id="数据格式-2"><a href="#数据格式-2" class="headerlink" title="数据格式"></a>数据格式</h4><ul><li><p>写Byte数据先写<strong>低位</strong></p></li><li><p>读Byte数据先读出的是<strong>低位</strong></p></li><li><p>读出来的温度先是  <strong>LSM 8bit</strong>  然后是 MSB 8bit</p></li></ul><h4 id="总线协议-时序"><a href="#总线协议-时序" class="headerlink" title="总线协议&amp;时序"></a>总线协议&amp;时序</h4><p><img src="/2019/b9b15cd2/01-1557625836489.png" alt="复位时序"></p><p><img src="/2019/b9b15cd2/02.png" alt="读写时序"></p><h3 id="编程思路-1"><a href="#编程思路-1" class="headerlink" title="编程思路"></a>编程思路</h3><p>0xCCOW_SKIP_ROM</p><p>0x44DS18B20_CONVERT</p><p>0xCCOW_SKIP_ROM</p><p>0xBEDS18B20_READ</p><h2 id="LIS302DL"><a href="#LIS302DL" class="headerlink" title="LIS302DL"></a>LIS302DL</h2><p>NULL</p><h2 id="光敏-D-A"><a href="#光敏-D-A" class="headerlink" title="光敏 D&amp;A"></a>光敏 D&amp;A</h2><h3 id="光敏D"><a href="#光敏D" class="headerlink" title="光敏D"></a>光敏D</h3><ul><li>GPIOA_Pin_3 </li><li>GPIO_Mode_IPU</li></ul><h3 id="光敏A"><a href="#光敏A" class="headerlink" title="光敏A"></a>光敏A</h3><ul><li><p>GPIOA_Pin_4</p></li><li><p>ADC1</p></li><li><p>ADC_Channel_4</p></li></ul><h2 id="电位器"><a href="#电位器" class="headerlink" title="电位器"></a>电位器</h2><p>NULL</p><h2 id="PULS-PWM"><a href="#PULS-PWM" class="headerlink" title="PULS&amp;PWM"></a>PULS&amp;PWM</h2><p>PA1        TIM2_CH2</p><p>PA2        TIM2_CH3</p><p>PA6        TIM3_CH1</p><p>PA7        TIM3_CH2</p><h2 id="界面颜色搭配"><a href="#界面颜色搭配" class="headerlink" title="界面颜色搭配"></a>界面颜色搭配</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">LCD_SetBackColor(Blue);<br>LCD_SetTextColor(White);<br><span class="hljs-comment">//Line01</span><br>LCD_SetBackColor(White);<br>LCD_SetTextColor(Blue);<br><span class="hljs-comment">//Line1-77</span><br>LCD_SetBackColor(Blue);<br>LCD_SetTextColor(Black);<br><span class="hljs-comment">//Line892</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stm32</tag>
      
      <tag>蓝桥杯</tag>
      
      <tag>国赛</tag>
      
      <tag>ct117e</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C按特定格式读取字符串的数据 Sscanf的用法</title>
    <link href="/2019/d334b917/"/>
    <url>/2019/d334b917/</url>
    
    <content type="html"><![CDATA[<h1 id="C按特定格式读取字符串的数据-sscanf的用法"><a href="#C按特定格式读取字符串的数据-sscanf的用法" class="headerlink" title="C按特定格式读取字符串的数据 sscanf的用法"></a>C按特定格式读取字符串的数据 sscanf的用法</h1><h1 id="Sscanf-函数"><a href="#Sscanf-函数" class="headerlink" title="Sscanf 函数"></a>Sscanf 函数</h1><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">int</span> <span class="hljs-title function_">sscanf</span><span class="hljs-params">( <span class="hljs-type">const</span> <span class="hljs-type">char</span> *buffer, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, [ argument ] ...   )</span>; <br><br></code></pre></td></tr></table></figure><p>buffer   存储的数据<br>format 窗体控件字符串。 有关详细信息，请参阅”格式规范”。<br>argument    可选自变量<br>locale   要使用的区域设置</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>sscanf与scanf类似，都是用于输入的，只是后者以键盘(stdin)为输入源，前者以<strong>固定字符串</strong>为输入源。</p><h3 id="控制字符说明"><a href="#控制字符说明" class="headerlink" title="控制字符说明"></a>控制字符说明</h3><blockquote><p>%c  一个单一的字符<br>%d  一个十进制整数<br>%i  一个整数<br>%e, %f, %g 一个浮点数<br>%o  一个八进制数<br>%s  一个字符串<br>%x  一个十六进制数<br>%p  一个指针<br>%n  一个等于读取字符数量的整数<br>%u  一个无符号整数<br>%[]  一个字符集<br>%%  一个精度符</p></blockquote><h2 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h2><p>函数将返回成功赋值的字段个数；返回值不包括已读取但未赋值的字段个数。 返回值为 0 表示没有将任何字段赋值。 如果在第一次读取之前到达字符串结尾，则返回EOF。</p><h2 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">char</span> buf[<span class="hljs-number">512</span>];<br><span class="hljs-built_in">sscanf</span>(<span class="hljs-string">&quot;123456 &quot;</span>, <span class="hljs-string">&quot;%s&quot;</span>, buf);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf);<br><span class="hljs-comment">//结果为：123456</span><br><br><br><span class="hljs-comment">//取指定长度的字符串。如在下例中，取最大长度为4字节的字符串。</span><br><span class="hljs-built_in">sscanf</span>(<span class="hljs-string">&quot;123456 &quot;</span>, <span class="hljs-string">&quot;%4s&quot;</span>, buf);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf);<br><span class="hljs-comment">//结果为：1234</span><br><br><span class="hljs-comment">//取到指定字符为止的字符串。如在下例中，取遇到空格为止字符串。</span><br><span class="hljs-built_in">sscanf</span>(<span class="hljs-string">&quot;123456 abcdedf&quot;</span>, <span class="hljs-string">&quot;%[^ ]&quot;</span>, buf);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf);<br><span class="hljs-comment">//结果为：123456</span><br><br><span class="hljs-comment">//取仅包含指定字符集的字符串。如在下例中，取仅包含1到9和小写字母的字符串。</span><br><span class="hljs-built_in">sscanf</span>(<span class="hljs-string">&quot;123456abcdedfBCDEF&quot;</span>, <span class="hljs-string">&quot;%[1-9a-z]&quot;</span>, buf);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf);<br><span class="hljs-comment">//结果为：123456abcdedf</span><br><br><span class="hljs-comment">//取到指定字符集为止的字符串。如在下例中，取遇到大写字母为止的字符串。</span><br><span class="hljs-built_in">sscanf</span>(<span class="hljs-string">&quot;123456abcdedfBCDEF&quot;</span>, <span class="hljs-string">&quot;%[^A-Z]&quot;</span>, buf);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf);<br><span class="hljs-comment">//结果为：123456abcdedf</span><br><br><span class="hljs-comment">//给定一个字符串iios/12DDWDFF@122，获取 / 和 @ 之间的字符串，先将 &quot;iios/&quot;过滤掉，再将非&#x27;@&#x27;的一串内容送到buf中</span><br><span class="hljs-built_in">sscanf</span>(<span class="hljs-string">&quot;iios/12DDWDFF@122&quot;</span>, <span class="hljs-string">&quot;%*[^/]/%[^@]&quot;</span>, buf);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf);<br><span class="hljs-comment">//结果为：12DDWDFF</span><br><br><span class="hljs-comment">//给定一个字符串&quot;hello, world&quot;，仅保留&quot;world&quot;。（注意：“，”之后有一空格）</span><br><span class="hljs-built_in">sscanf</span>(<span class="hljs-string">&quot;hello, world&quot;</span>, <span class="hljs-string">&quot;%*s%s&quot;</span>, buf);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf);<br><span class="hljs-comment">//结果为：world</span><br><br></code></pre></td></tr></table></figure><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p><img src="/2019/d334b917/Center.png" alt="c"></p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sscanf</tag>
      
      <tag>c/c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32F070系列的IAP程序</title>
    <link href="/2018/2d20bb21/"/>
    <url>/2018/2d20bb21/</url>
    
    <content type="html"><![CDATA[<h1 id="STM32F070系列的IAP程序"><a href="#STM32F070系列的IAP程序" class="headerlink" title="STM32F070系列的IAP程序"></a>STM32F070系列的IAP程序</h1><h1 id="总程序思路"><a href="#总程序思路" class="headerlink" title="总程序思路"></a>总程序思路</h1><p><img src="/2018/2d20bb21/70.png" alt="bootloader"></p><p><img src="/2018/2d20bb21/70-16635087132592.png" alt="app"></p><p>之所以不直接将接收到的BIN文件直接写入到APP区域是因为如果升级过程出现某些错误时，程序将会清除升级标志位，并跳转到APP运行程序减少产品变砖的概率。</p><p><em><strong>注：如果在  将BacpupApp区域的BIN文件拷贝到App区域   这一步如果拷贝两次都校验失败将会导致程序停掉。</strong></em></p><h1 id="STM32内Flash区域划分"><a href="#STM32内Flash区域划分" class="headerlink" title="STM32内Flash区域划分"></a>STM32内Flash区域划分</h1><p> <img src="/2018/2d20bb21/70-16635087883674.png" alt="stm32"></p><p><img src="/2018/2d20bb21/70-16635087985376.png" alt="flash"></p><p>此次使用的MCU型号是STM32F070CB，由其Flash组织特性可知其Flash一页为1KB（若总Flash大小，大于等于256KB则其一页大小为2KB），为了程序简单高效，所以使FLAG占用一页（1KB）的位置（Flag只使用了前2B的空间）。</p><h1 id="STM32与上位机通信过程"><a href="#STM32与上位机通信过程" class="headerlink" title="STM32与上位机通信过程"></a>STM32与上位机通信过程</h1><h2 id="上位机发送给STM32"><a href="#上位机发送给STM32" class="headerlink" title="上位机发送给STM32"></a>上位机发送给STM32</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 16B 命令数据长度</span><br><span class="hljs-comment"># 注：命令长度设置为 0x10  即16B大小</span><br>0x55  0xAA   0x01    命令长度    命令码   固件总包数   0x00   0x00   0x00   0x00   0x00   0x00   0x00  0x00   0x00    和校验<br><br><span class="hljs-comment"># 1024+7B 固件数据长度</span><br>0x55  0xAA   0x01  包号  命令码     0xFF   BINData[1024]    和校验<br></code></pre></td></tr></table></figure><h2 id="STM32发送给上位机"><a href="#STM32发送给上位机" class="headerlink" title="STM32发送给上位机"></a>STM32发送给上位机</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 16B 命令数据长度</span><br><span class="hljs-comment"># 注：命令长度设置为 0x10  即16B大小</span><br>0x55  0xAA   0x01  命令长度  命令码    0x00   0x00   0x00   0x00   0x00   0x00   0x00   0x00   0x00   0x00    和校验<br></code></pre></td></tr></table></figure><p><img src="/2018/2d20bb21/70-16635090195918.png" alt="img"></p><h1 id="IAP应用说明"><a href="#IAP应用说明" class="headerlink" title="IAP应用说明"></a>IAP应用说明</h1><ul><li>App区域和Bootloader区域都有IAP实现的程序段，所以要实现IAP就要要求App区域和Bootloader的程序都可以正常工作。</li></ul><p>App程序需要做的修改：</p><ol><li>添加 iap.c 文件，并在main函数最前面调用 iap.c 里的函数    iRemapIrqVector();   重映射中断向量</li><li>用这种方法重映射中断向量，RAM的前0xC0个字节不能用，需要将RAM始地址修改到  0x2000 00C0 处，将Size大小减掉0xC0</li><li>ROM起始地址修改到  0x0800 3000 处，将Size大小设置成0xE800（58KB）</li><li>在程序的串口命令判断中添加IAP升级命令判断，满足条件则使能升级标志位，并重启MCU进入Bootloader</li><li>刷入APP和Bootloader</li></ol><h1 id="关于移植到其他芯片"><a href="#关于移植到其他芯片" class="headerlink" title="关于移植到其他芯片"></a>关于移植到其他芯片</h1><ol><li>如果移植到F103系列芯片的话重映射中断向量将变得非常简单，一行代码就搞定，也就无需修改RAM起始地址</li><li>如果移植的芯片容量不一样需要查看其一个页的大小是多少，然后重新划分Flash区域</li></ol><p>Bootloader源码下载：<a href="https://download.csdn.net/download/weixin_42078116/10610445">源码</a><br>App区源码：待加入<br>上位机程序和源码：<a href="https://download.csdn.net/download/weixin_42078116/10610490">源码</a></p><p>参考资料：</p><p><a href="http://www.openedv.com/forum.php?mod=viewthread&tid=85906">STM32实现IAP功能的学习笔记</a></p><p><a href="http://www.openedv.com/forum.php?mod=viewthread&tid=85906">STM32实现IAP功能的学习笔记</a> </p><h1 id="扩展：STM32运行过程"><a href="#扩展：STM32运行过程" class="headerlink" title="扩展：STM32运行过程"></a>扩展：STM32运行过程</h1><blockquote><p>  TIPS：STM32上电后先  <strong>执行复位中断 Reset_Handler</strong>  然后才会进入  main 函数。</p><p>  STM32的程序运行过程在很多资料里也都有介绍，因为STM32F103的单片机是基于Cortex-M3核的，它的内部主要是通过中断向量表来响应各种中断，内部闪存的起始地址是0x08000000，中断向量表的起始地址是0x8000004，程序启动后，将首先从“中断向量表”取出复位中断向量执行复位中断程序完成启动，当中断来临时STM32 的内部硬件机制亦会自动将 PC 指针定位到“中断向量表”处，并根据中断源取出对应的中断向量执行相应的中断服务程序。</p><p>  <img src="/2018/2d20bb21/70-166350916978910.png" alt="img"></p><p>  如上图所示STM32的正常启动流程是：<br>  a. STM32上电后会从 0x8000004 处取出复位中断向量的地址，并跳转执行复位中断服务程序，如标号1所示；<br>  b. 复位中断复位程序执行完成之后就会跳转到我们的main函数如标号2所示；<br>  c. main函数一般为死循环，当其收到某一中断请求之后STM32会强制把PC指针指向中断向量表，如标号3所示；<br>  d. 查询中断向量表，根据中断源来跳转到相应的中断服务程序中执行响应的操作；如标号4、5所示；<br>  e. 执行完中断服务程序之后会再回到main函数中，如标号6所示。</p><p>  以上是STM32的正常运行过程，而当加入IAP程序之后，运行流程就如下所示：</p><p>  <img src="/2018/2d20bb21/70-166350918005812.png" alt="img"></p><p>  加入IAP后程序运行如下：<br>  a. STM32复位之后还是从0x8000004处获取中断向量表的地址，并跳转执行复位中断服务程序，如标号1所示；<br>  b. 执行完复位中断服务程序之后回调转到IAP的main函数中，如标号2所示；<br>  c. IAP的过程就是通过某种选定的通信方式（如串口）来接收程序文件，并且存储在指定的FLASH空间里，随后会加载新的程序，而新程序<br>  的复位中断向量起始地址为0X08000004+N+M，取出新程序的复位中断向量的地址，并跳转执行新程序的复位中断服务程序，随后跳转<br>  至新程序的 main 函数，如标号3、4所示；<br>  d. 此时在STM32的FLASH里面会有两个中断向量表，在新程序 main 函数执行的过程中，当中断来临时PC指针仍会回跳转至地址为<br>  0x8000004 中断向量表处，而并不是新程序的中断向量表，这是由STM32的硬件机制决定的，如标号5所示；<br>  e. 查询中断向量表，根据中断源来跳转到新的中断服务程序中执行响应的操作，如标号6所示；<br>  f. 执行完中断服务程序之后会再回到main函数中，如标号7、8所示。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>misc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iap</tag>
      
      <tag>bootloader</tag>
      
      <tag>stm32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蓝桥杯 超准超声波测距</title>
    <link href="/2018/125d6be2/"/>
    <url>/2018/125d6be2/</url>
    
    <content type="html"><![CDATA[<h1 id="蓝桥杯-单片机组-超准超声波测距"><a href="#蓝桥杯-单片机组-超准超声波测距" class="headerlink" title="蓝桥杯 单片机组 超准超声波测距"></a>蓝桥杯 单片机组 超准超声波测距</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Timer1Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <span class="hljs-comment">//2000微秒@12.000MHz</span><br>&#123;<br>    AUXR &amp;= <span class="hljs-number">0xBF</span>; <span class="hljs-comment">//定时器时钟12T模式</span><br>    TMOD &amp;= <span class="hljs-number">0x0F</span>; <span class="hljs-comment">//设置定时器模式</span><br>    TMOD |= <span class="hljs-number">0x10</span>; <span class="hljs-comment">//设置定时器模式</span><br>    TL1 = <span class="hljs-number">0x30</span>; <span class="hljs-comment">//设置定时初值</span><br>    TH1 = <span class="hljs-number">0xF8</span>; <span class="hljs-comment">//设置定时初值</span><br>    TF1 = <span class="hljs-number">0</span>; <span class="hljs-comment">//清除TF1标志</span><br>    <span class="hljs-comment">// TR1 = 1; //定时器1开始计时</span><br>&#125;<br><br> <br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Sand_wav</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> i;<br><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">20</span>;i++)<br>    &#123;<br>        P10 = ~P10;<br>        &#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> i;_nop_();_nop_();i = <span class="hljs-number">33</span>;<span class="hljs-keyword">while</span> (--i);&#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> <span class="hljs-title function_">Read_wav</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">float</span> range;<br><br>    Sand_wav();<br>     <br>    <span class="hljs-comment">// TR0 = 0;</span><br>    TR1 = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>((P11 != <span class="hljs-number">0</span>) &amp;&amp; (TF1 == <span class="hljs-number">0</span>));<br>    TR1 = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// TR0 = 1;</span><br>     <br>    <span class="hljs-keyword">if</span>(TF1 == <span class="hljs-number">1</span>)<br>    &#123;<br>        TF1 = <span class="hljs-number">0</span>;<br>        TL1 = <span class="hljs-number">0x30</span>; <span class="hljs-comment">//设置定时初值</span><br>        TH1 = <span class="hljs-number">0xF8</span>; <span class="hljs-comment">//设置定时初值</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">99</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        range = TH1*<span class="hljs-number">256</span> + TL1 <span class="hljs-number">-63535</span> +<span class="hljs-number">260</span>;<br>     <br>        range = range * <span class="hljs-number">0.017</span>;<br>     <br>        TL1 = <span class="hljs-number">0x30</span>; <span class="hljs-comment">//设置定时初值</span><br>        TH1 = <span class="hljs-number">0xF8</span>; <span class="hljs-comment">//设置定时初值</span><br>     <br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>)range;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意   </p><ul><li>ET1不要打开</li><li>在Read_wav没有关闭T0要注意主程序延时使程序进入中断</li><li>清除中断标志   重新TH0 TL0初值赋值</li><li>运算时减去260是除去发送波形的间隔（此BUG极大影响了精准度 近4cm）</li></ul><p>单片机组 和 嵌入式组的相关代码资源可以在我的主页下载。</p>]]></content>
    
    
    <categories>
      
      <category>misc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>蓝桥杯</tag>
      
      <tag>超声波</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式编程杂乱笔记</title>
    <link href="/2018/ef667962/"/>
    <url>/2018/ef667962/</url>
    
    <content type="html"><![CDATA[<h1 id="嵌入式编程杂乱笔记目录"><a href="#嵌入式编程杂乱笔记目录" class="headerlink" title="嵌入式编程杂乱笔记目录"></a>嵌入式编程杂乱笔记目录</h1><p>[TOC]</p><h1 id="硬件类"><a href="#硬件类" class="headerlink" title="硬件类"></a>硬件类</h1><h2 id="NTC和PTC"><a href="#NTC和PTC" class="headerlink" title="NTC和PTC"></a>NTC和PTC</h2><p>NTC (Negative Temperature Coefficient 负温度系数)      PTC (Positive 正温度系数)</p><h2 id="VCC、-VDD、VEE、VSS区别"><a href="#VCC、-VDD、VEE、VSS区别" class="headerlink" title="VCC、 VDD、VEE、VSS区别"></a>VCC、 VDD、VEE、VSS区别</h2><ul><li>一、解释<br>VCC：C&#x3D;circuit 表示电路的意思, 即接入电路的电压；<br>VDD：D&#x3D;device 表示器件的意思, 即器件内部的工作电压；<br>VSS：S&#x3D;series 表示公共连接的意思，通常指电路公共接地端电压；<br>VEE：负电压供电；<br>VPP：编程&#x2F;擦除电压。</li><li>二、说明<br>1、对于数字电路来说，VCC是电路的供电电压,VDD是芯片的工作电压（通常Vcc&gt;Vdd），VSS是接地点。<br>2、有些IC既有VDD引脚又有VCC引脚，说明这种器件自身带有电压转换功能。<br>3、在场效应管（或COMS器件）中，VDD为漏极，VSS为源极，VDD和VSS指的是元件引脚，而不表示供电电压。</li></ul><h2 id="NOR-NAND"><a href="#NOR-NAND" class="headerlink" title="NOR NAND"></a>NOR NAND</h2><p>NOR(或非) NAND(与非)</p><p>SLC（Single-Level Cell）、MLC（Multi-Level Cell） 、 TLC（Triple-Level Cell）</p><p><strong>共同点：</strong></p><p>两者向浮栅中注入电子表示0(电子浮栅效应管存在导电沟道bit位被接地 见后续图片)，未注入表示1，对其清除数据是对其写1。</p><ul><li><strong>NOR FLASH</strong><ul><li>随机读取(可随机读取，能直接运行代码，BIOS)</li><li>随机读取较快、写入较很慢(热电子注入效率更低)、擦除次数较少、</li><li>容量较小、体积较小、可靠性高一些、数据保存期更高</li><li>初始通电消耗更多的电流, 待机状态电流远远更低</li><li></li><li>浮栅 热电子注入方式充电、FN隧道效应放电</li></ul></li><li><strong>NAND FLASH</strong><ul><li>块读取(块读取，不能运行代码)</li><li>随机读取较慢(地址线复用导致)、顺序读取速度较快、写入较快、擦除次数较多、</li><li>容量较大、体积较大、可靠性较低一些(较容易发生位交换现象)、数据保存期低一些</li><li>待机状态功耗较高</li><li></li><li>浮栅 FN隧道效应充电、FN隧道效应放电</li></ul></li></ul><p><img src="/2018/ef667962/contenteetimes-images-design-embedded-2018-fl-1-t1.jpg" alt="img"></p><h3 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h3><h4 id="浮栅效应管"><a href="#浮栅效应管" class="headerlink" title="浮栅效应管"></a>浮栅效应管</h4><p>NOR FLASH 和 NAND FLASH 都是使用浮栅场效应管(Floating Gate FET)作为基本存储单元来存储数据的，浮栅场效应管共有 4 个端电极，分别是为源极（Source）、漏极（Drain）、控制栅极（Control Gate）和浮置栅极（Floating Gate），前 3 个端电极的作用于普通 MOSFET 是一样的，区别仅在于浮栅，FLASH 就是利用浮栅是否存储电荷来表征数字 0’和‘1’的。</p><p>当向浮栅注入电荷后，D 和 S 之间存在导电沟道，从 D 极读到‘0’<span style="color:#29b6f6">(电子浮栅效应管存在导电沟道bit位被接地 见后续图片)</span>；当浮栅中没有电荷时，D 和 S 间没有导电沟道，从 D 极读到‘1’，原理示意图见图</p><p>注：SLC 可以简单认为是利用浮栅是否存储电荷来表征数字 0’和‘1’的，MLC 则是要利用浮栅中电荷的多少来表征‘00’，‘01’，‘10’和‘11’的，TLC 与 MLC 类似。</p><blockquote><p>  SLC传统上，每个储存单元内储存1个信息位，称为单阶储存单元（Single-Level Cell，SLC）。SLC闪存的优点是传输速度更快，功率消耗更低和储存单元的寿命更长，成本也就更高。一般情况下，SLC多数用于企业级的固态硬盘中，由于企业对于数据的安全性要求更高，需要保存更长时间。</p><p>  MLC多阶储存单元（Multi-Level Cell,MLC）可以在每个储存单元内储存2个以上的信息位。与SLC相比，MLC成本较低，其传输速度较慢，功率消耗较高和储存单元的寿命较低。 但目前主流的固态硬盘中，性能较为优秀的产品选用的都是MLC颗粒，因此可以说MLC颗粒的固态硬盘拥有较高的性价比。甚至一些企业级的固态硬盘，使用的也是MLC颗粒，被专门优化过，称为eMLC颗粒，e代表的是企业enterprise。</p><p>  TLC三阶储存单元（Triple-Level Cell, TLC），这种架构的原理与MLC类似，但可以在每个储存单元内储存3个信息位。由于存储的数据密度相对MLC和SLC更大，所以价格也就更便宜，但使用寿命和性能也就更低，不过这并不能阻止人们购买TLC颗粒的固态硬盘。甚至目前市场上绝大多数的入门级产品使用的都是TLC颗粒。而为了解决TLC颗粒过低的写入寿命问题，许多厂商都在研发新技术，3D-TLC就是这样的技术，目前已经比较广泛的应用在产品中，其性能甚至可以和MLC颗粒一较长短，使用寿命得到大幅度的延长。</p></blockquote><p><img src="/2018/ef667962/20200311_01_Nor_FLASH_vs_NAND_FLASH.png" alt="Nor FLASH和NAND FLASH基本结构和特点的异同"></p><h5 id="读-写-擦除"><a href="#读-写-擦除" class="headerlink" title="读 写 擦除"></a>读 写 擦除</h5><p>FLASH 中，常用的向浮栅注入电荷的技术有两种—热电子注入(hot electron injection)和 F-N 隧道效应(Fowler Nordheim tunneling)；从浮栅中挪走电荷的技术通常使用 F-N 隧道效应(Fowler Nordheim tunneling)，基本原理见图。</p><p>写操作就是向浮栅注入电荷的过程，NOR FLASH 通过热电子注入方式向浮栅注入电荷（这种方法的电荷注入效率较低，因此 NOR FLASH 的写速率较低），NAND FLASH 则通过 F-N 隧道效应向浮栅注入电荷。FLASH 在写操作之前，必须先将原来的数据擦除（即将浮栅中的电荷挪走），也即 FLASH 擦除后读出的都是‘1’。<span style="color:#29b6f6">(只能擦除再写入的原因应该是擦除和写入加的电压是反向的, 一个是充电, 一个是放电)</span></p><p>擦除操作就是从浮栅中挪走电荷的过程，NOR FLASH 和 NAND FLASH 都是通过 F-N 隧道效应将浮栅中的电荷挪走的。</p><p>读出操作时，控制栅极上施加的电压很小，不会改变浮栅中的电荷量，即读出操作不会改变 FLASH 中原有的数据，也即浮栅有电荷时，D 和 S 间存在导电沟道，从 D 极读到‘0’<span style="color:#29b6f6">(电子浮栅效应管存在导电沟道bit位被接地 见后续图片)</span>；当浮栅中没有电荷时，D 和 S 间没有导电沟道，从 D 极读到‘1’。</p><p><a href="https://www.sunev.cn/blog/wp-content/uploads/2020/03/20200311_03_Nor_FLASH_vs_NAND_FLASH.png"><img src="/2018/ef667962/20200311_03_Nor_FLASH_vs_NAND_FLASH.png" alt="Nor FLASH和NAND FLASH基本结构和特点的异同"></a></p><h4 id="NOR-和-NAND-Flash-的结构特性"><a href="#NOR-和-NAND-Flash-的结构特性" class="headerlink" title="NOR 和 NAND Flash 的结构特性"></a>NOR 和 NAND Flash 的结构特性</h4><h6 id="NOR-Flash"><a href="#NOR-Flash" class="headerlink" title="NOR Flash"></a>NOR Flash</h6><p>NOR FLASH 的结构原理图见图 ，可见每个 Bit Line 下的基本存储单元是并联的，当某个 Word Line 被选中后，就可以实现对该 Word 的读取，也就是可以实现位读取（即 Random Ａccess），且具有较高的读取速率</p><p>下图是一个 3*8bit 的 NOR FLASH 的原理结构图，这种并联结构决定了 NOR FLASH 的很多特性。</p><p><img src="/2018/ef667962/20200311_04_Nor_FLASH_vs_NAND_FLASH.png" alt="Nor FLASH和NAND FLASH基本结构和特点的异同"></p><p>下图是沿 Bit Line 切面的剖面图，展示了 NOR FLASH 的硅切面示意图，</p><p><img src="/2018/ef667962/20200311_05_Nor_FLASH_vs_NAND_FLASH.png" alt="Nor FLASH和NAND FLASH基本结构和特点的异同"></p><ol><li>基本存储单元的并联结构决定了金属导线占用很大的面积，因此 NOR　FLASH 的存储密度较低，无法适用于需要大容量存储的应用场合，即适用于 code-storage，不适用于 data-storage。</li><li>基本存储单元的并联结构决定了 NOR FLASH 具有存储单元可独立寻址且读取效率高的特性，因此适用于 code-storage，且程序可以直接在 NOR 中运行（即具有 RAM 的特性）。</li><li>NOR FLASH 写入采用了热电子注入方式，效率较低，因此 NOR 写入速率较低，不适用于频繁擦除&#x2F;写入场合。</li></ol><blockquote><p>  最后来个小贴士：NOR  FLASH 的中的 N 是 NOT，含义是 Floating Gate 中有电荷时，读出‘0’，无电荷时读出‘1’，是一种‘非’的逻辑；OR 的含义是同一个 Bit Line 下的各个基本存储单元是并联的，是一种‘或’的逻辑，这就是 NOR 的由来。 </p></blockquote><h6 id="NAND-Flash"><a href="#NAND-Flash" class="headerlink" title="NAND Flash"></a>NAND Flash</h6><p>NAND FLASH 的结构原理图见图，可见每个 Bit Line 下的基本存储单元是串联的，NAND 读取数据的单位是 Page，当需要读取某个 Page 时，FLASH 控制器就不在这个 Page 的 Word Line 施加电压，而对其他所有 Page 的 Word Line 施加电压（电压值不能改变 Floating Gate 中电荷数量），让这些 Page 的所有基本存储单元的 D 和 S 导通，而我们要读取的 Page 的基本存储单元的 D 和 S 的导通&#x2F;关断状态则取决于 Floating Gate 是否有电荷，有电荷时，Bit Line 读出‘0’，无电荷 Bit Line 读出‘1’，实现了 Page 数据的读出，可见 NAND 无法实现位读取（即 Random Ａccess），程序代码也就无法在 NAND 上运行。</p><p>下图是一个 8*8bit 的 NAND FLASH 的原理结构图，NAND FLASH 的串联结构决定了其很多特点。</p><p><img src="/2018/ef667962/20200311_07_Nor_FLASH_vs_NAND_FLASH.png" alt="Nor FLASH和NAND FLASH基本结构和特点的异同"></p><p>下图是沿 Bit Line 切面的剖面图，展示了 NAND FLASH 的硅切面示意图</p><p><img src="/2018/ef667962/20200311_08_Nor_FLASH_vs_NAND_FLASH.png" alt="Nor FLASH和NAND FLASH基本结构和特点的异同"></p><ol><li>基本存储单元的串联结构减少了金属导线占用的面积，Die 的利用率很高，因此 NAND FLASH 存储密度高，适用于需要大容量存储的应用场合，即适用于 data-storage，见图 3.3[3]。</li><li>基本存储单元的串联结构决定了 NAND FLASH 无法进行位读取，也就无法实现存储单元的独立寻址，因此程序不可以直接在 NAND 中运行,因此 NAND 是以 Page 为读取单位和写入单位，以 Block 为擦除单位，见图 3.6。</li><li>NAND FLASH 写入采用 F-N 隧道效应方式，效率较高，因此 NAND 擦除&#x2F;写入速率很高，适用于频繁擦除&#x2F;写入场合。同时 NAND 是以 Page 为单位进行读取的，因此读取速率也不算低（稍低于 NOR）。</li></ol><blockquote><p>  最后来个小贴士：NAND FLASH 的中的 N 是 NOT，含义是 Floating Gate 中有电荷时，读出‘0’，无电荷时读出‘1’，是一种‘非’的逻辑；AND 的含义是同一个 Bit Line 下的各个基本存储单元是串联的，是一种‘与’的逻辑，这就是 NAND 的由来。</p></blockquote><h6 id="NOR-和-NAND-的对比"><a href="#NOR-和-NAND-的对比" class="headerlink" title="NOR 和 NAND 的对比"></a>NOR 和 NAND 的对比</h6><p><img src="/2018/ef667962/20200311_10_Nor_FLASH_vs_NAND_FLASH.png" alt="Nor FLASH和NAND FLASH基本结构和特点的异同"></p><p><img src="/2018/ef667962/20200311_11_Nor_FLASH_vs_NAND_FLASH.png" alt="Nor FLASH和NAND FLASH基本结构和特点的异同"></p><h2 id="eMMC"><a href="#eMMC" class="headerlink" title="eMMC"></a>eMMC</h2><p>eMMC (Embedded Multi Media Card) 为MMC协会所订立的主要针对手机或平板电脑等产品的内嵌式存储器标准规格。</p><p><strong>eMMC</strong> 是 **flash(一般是NAND flash)<strong>加</strong>主控IC(坏块处理 ECC纠错 和数据管理)**，封装相对比较标准，并对外提供标准接口，类似于SD卡。</p><blockquote><p>  Flash的生产厂家主要有： Samsung, Toshiba,Hynix, Intel, Micron,</p><p>  flash控制IC主要有：Phison（群联）, SMI（慧荣）, SiliconGo(硅格半导体）</p></blockquote><p>几乎所有的手机和平板电脑都使用这种形式的闪存作为主存储，直到 2016 年<a href="https://en.wikipedia.org/wiki/Universal_Flash_Storage">通用闪存</a>(UFS) 开始控制市场。</p><p>eMMC 不支持<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI-bus</a>协议，一般使用 MLC NAND flash。</p><table><thead><tr><th align="center"></th><th align="center">Sequential Read(MB&#x2F;s)</th><th align="center">Sequential Write(MB&#x2F;s)</th><th align="center">Random Read(IO&#x2F;s)</th><th align="center">Random Write(IO&#x2F;s)</th><th align="center">Clock Frequency(Mhz)</th><th align="center">Used in</th></tr></thead><tbody><tr><td align="center">eMMC 4.3</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">eMMC 4.4</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">eMMC 4.41</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">52[<a href="https://en.wikipedia.org/wiki/MultiMediaCard#cite_note-11">11]</a></td><td align="center"></td></tr><tr><td align="center">eMMC 4.5</td><td align="center">140[<a href="https://en.wikipedia.org/wiki/MultiMediaCard#cite_note-12">12]</a></td><td align="center">50</td><td align="center">7000</td><td align="center">2000</td><td align="center">200</td><td align="center"><a href="https://en.wikipedia.org/wiki/Snapdragon_800">Snapdragon 800</a></td></tr><tr><td align="center">eMMC 5.0</td><td align="center">250</td><td align="center">90</td><td align="center">7000</td><td align="center">13000</td><td align="center"></td><td align="center">Snapdragon 801</td></tr><tr><td align="center">eMMC 5.1</td><td align="center">250</td><td align="center">125</td><td align="center">11000</td><td align="center">13000</td><td align="center"></td><td align="center">Snapdragon 820</td></tr></tbody></table><h2 id="UFS"><a href="#UFS" class="headerlink" title="UFS"></a>UFS</h2><table><thead><tr><th align="center">UFS</th><th align="center">1.0</th><th align="center">1.1</th><th align="center">2.0</th><th align="center">2.1</th><th align="center">2.2</th><th align="center">3.0</th><th align="center">3.1</th><th align="center">4.0</th></tr></thead><tbody><tr><td align="center">Introduced</td><td align="center">2011-02</td><td align="center">2012-06</td><td align="center">2013-09</td><td align="center">2016-04</td><td align="center">2020-08</td><td align="center">2018-01</td><td align="center">2020-01</td><td align="center">2022-08</td></tr><tr><td align="center">Bandwidth per lane</td><td align="center">300 MB&#x2F;s</td><td align="center">600 MB&#x2F;s</td><td align="center">1450 MB&#x2F;s</td><td align="center">2900 MB&#x2F;s</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">Max. number of lanes</td><td align="center">1</td><td align="center">2</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">Max. total bandwidth</td><td align="center">300 MB&#x2F;s</td><td align="center">1200 MB&#x2F;s</td><td align="center">2900 MB&#x2F;s</td><td align="center">5800 MB&#x2F;s</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><a href="https://en.wikipedia.org/wiki/M-PHY">M-PHY</a> version</td><td align="center">?</td><td align="center">?</td><td align="center">3.0</td><td align="center">?</td><td align="center">4.1</td><td align="center">5.0</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><a href="https://en.wikipedia.org/wiki/UniPro">UniPro</a> version</td><td align="center">?</td><td align="center">?</td><td align="center">1.6</td><td align="center">?</td><td align="center">1.8</td><td align="center">2.0</td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="NFC"><a href="#NFC" class="headerlink" title="NFC"></a>NFC</h2><p><strong>近场通信</strong>（英语：Near-field communication，NFC），又称<strong>近距离无线通信</strong>、<strong>近距离通信</strong>，是一套<a href="https://zh.wikipedia.org/wiki/%E9%80%9A%E8%A8%8A%E5%8D%94%E5%AE%9A">通信协议</a>，让两个电子设备（其中一个通常是移动设备，例如<a href="https://zh.wikipedia.org/wiki/%E6%99%BA%E6%85%A7%E5%9E%8B%E6%89%8B%E6%A9%9F">智能手机</a>）在相距几厘米之内进行<a href="https://zh.wikipedia.org/wiki/%E8%B3%87%E6%96%99%E5%82%B3%E8%BC%B8">通信</a>。</p><p>近场通信是一种短距高频的无线电技术，在<strong>13.56MHz</strong>频率运行于20厘米距离内[<a href="https://zh.wikipedia.org/zh-cn/%E8%BF%91%E5%A0%B4%E9%80%9A%E8%A8%8A#cite_note-Ortiz_2008-5">5]</a>。其传输速度有106 Kbit&#x2F;秒、212 Kbit&#x2F;秒或者424 Kbit&#x2F;秒三种。</p><p>NFC的工作模式有<strong>卡模式</strong>、<strong>读写器模式</strong>和<strong>点对点模式</strong>三种</p><h2 id="RFID"><a href="#RFID" class="headerlink" title="RFID"></a>RFID</h2><p><strong>射频识别</strong>（英语：<strong>R</strong>adio <strong>F</strong>requency <strong>ID</strong>entification，<a href="https://zh.wikipedia.org/wiki/%E7%B8%AE%E5%AF%AB">缩写</a>：<strong>RFID</strong>）是一种<a href="https://zh.wikipedia.org/wiki/%E7%84%A1%E7%B7%9A">无线</a><a href="https://zh.wikipedia.org/wiki/%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF">通信技术</a>，可以通过<a href="https://zh.wikipedia.org/wiki/%E6%97%A0%E7%BA%BF%E7%94%B5">无线电</a>信号识别特定目标并读写相关数据，而无需识别系统与特定目标之间建立<a href="https://zh.wikipedia.org/wiki/%E6%9C%BA%E6%A2%B0">机械</a>或者<a href="https://zh.wikipedia.org/wiki/%E5%85%89%E5%AD%A6">光学</a>接触。</p><p>某些标签在识别时从识别器发出的电磁场中就可以得到能量，<strong>并不需要电池</strong>；<strong>也有标签本身拥有电源</strong>，并可以主动发出无线电波（调成无线电频率的电磁场）。</p><p>无源 RFID 标签主要在三个频率范围内运行：</p><ul><li><a href="https://blog.atlasrfidstore.com/low-frequency-rfid-and-animal-identification">低频</a>(LF) 125 -134 kHz</li><li>高频 (HF)13.56 MHz</li><li><a href="https://blog.atlasrfidstore.com/what-is-rfid">超高频</a>(UHF) 856 MHz 至 960 MHz</li></ul><blockquote><p>  <strong>NFC 与 RFID 有什么区别？</strong></p><p>  简而言之：</p><p>  RFID 代表射频识别，一种在不同距离的非接触式单向<strong>通信方法</strong>。</p><p>  NFC 近场通信，允许双向通信并需要用户操作，从特性上来看NFC的功能会更强，<strong>NFC是RFID的一个子集</strong>。 </p><p>  RFID 是使用无线电波唯一识别物品的过程，而 NFC 是 RFID 技术系列中的一个专门子集。具体来说，NFC 是高频 (HF) RFID 的一个分支，均工作在 13.56 MHz 频率。NFC 旨在成为一种安全的数据交换形式，NFC 设备既可以作为 NFC 阅读器，也可以作为 <a href="https://www.atlasrfidstore.com/near-field-communication/">NFC 标签</a>。这种独特的功能允许 NFC 设备进行点对点通信。</p><p>  归根结底，<strong>NFC 建立在 HF RFID 的标准之上</strong>，并将其工作频率的局限性转化为近场通信的独特功能。</p><ul><li><strong>范围和应用</strong>——NFC 的作用范围非常短，一般工作范围在 0.1 米以内。它是一种用户交互技术，需要用户的特殊参与才能保证支付或访问等功能的完成。NFC技术在门禁、公共交通、移动支付等领域发挥着巨大的作用。</li><li>另一方面，RFID 扫描器可以同时读取大量标签，这在仓库库存中很常见。RFID 在数百英尺的距离内工作。 </li><li><strong>通信</strong>——RFID 通常只能进行单向通信（从标签到阅读器），而 NFC 则能够进行双向通信。 </li><li><strong>数据存储——NFC</strong>可以存储比简单识别信息更复杂的数据。NFC 标签最多可以存储 4KB 的数据。这些数据可以采用多种格式，包括文本、URL 和媒体。虽然 RFID 标签通常需要昂贵的读取器来提取数据，但大多数现代智能手机都配备了 NFC 读取功能。这大大降低了实施 NFC 标签的成本，因为用户可以简单地使用他们的智能手机读取数据。智能手机可以在标签或卡上读取和写入数据，获取详细的元数据，在扫描标签时启动应用程序或 URL，还可以使用 NFC（点对点 (P2P) 通信）在手机之间共享数据。</li></ul></blockquote><h1 id="编译器相关"><a href="#编译器相关" class="headerlink" title="编译器相关"></a>编译器相关</h1><h2 id="Keil仿真准确测量运行时间"><a href="#Keil仿真准确测量运行时间" class="headerlink" title="Keil仿真准确测量运行时间"></a>Keil仿真准确测量运行时间</h2><p>Debug-&gt;Setting-&gt;Trsce-&gt;Core 修改好核心时钟频率即可准确测量函数运行时间</p><h2 id="程序内存位置分配"><a href="#程序内存位置分配" class="headerlink" title="程序内存位置分配"></a>程序内存位置分配</h2><ul><li><p>bss段：</p><ul><li><strong>未初始化的全局变量</strong></li><li>BSS段（BSS segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域。BSS是英文BlockStarted by Symbol的简称。BSS段属于静态内存分配。</li></ul></li><li><p>data段：</p><ul><li><strong>已初始化的全局变量</strong></li><li>数据段（DATA segment）通常是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。</li></ul></li><li><p>text段：</p><ul><li>代码段</li><li>代码段（CODE segment&#x2F;TEXTsegment）通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读,某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。</li></ul></li><li><p>rodata段：</p><ul><li>？？？</li><li>存放C中的字符串和#define定义的常量</li></ul></li><li><p>heap堆：</p><ul><li>堆（程序员指定的内存 malloc）</li><li>当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）</li></ul></li><li><p>stack栈：</p><ul><li>栈</li><li>是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存&#x2F;恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。</li></ul></li><li><p>常量段：</p><ul><li>？？？</li><li>常量段一般包含编译器产生的数据（与只读段包含用户定义的只读数据不同）。比如说由一个语句a&#x3D;2+3编译器把2+3编译期就算出5，存成常量5在常量段中</li></ul></li></ul><h2 id="Pragma-Pack-内存对齐"><a href="#Pragma-Pack-内存对齐" class="headerlink" title="#Pragma Pack (内存对齐)"></a>#Pragma Pack (内存对齐)</h2><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><ol><li><p>复杂类型中各个成员按照它们被声明的顺序在内存中顺序存储，第一个成员的地址和整个类型的地址相同</p></li><li><p>结构、联合或者类的对齐长度，按照#pragma pack    <strong>指定的对齐参数</strong>   和     <strong>这个数据成员自身长度</strong>     两个中    <strong>比较小</strong>     的那个进行。（确定成员位置）</p></li><li><p>复杂类型（如结构）整体的对齐&lt;注意是“整体”&gt;是按照结构体中     <strong>长度最大的数据成员</strong>     和    <strong>#pragma pack指定值之间</strong>     <strong>较小</strong>    的那个值进行；这样在成员是复杂类型时，可以最小化长度。（确定对齐大小）</p></li></ol><p>即：先用规则3确定变量对齐的“容器”大小，再用规则2确定各个变量的存放位置。</p><h3 id="看图"><a href="#看图" class="headerlink" title="看图"></a>看图</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stc</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> one;<br>    <span class="hljs-type">short</span> two;<br>    <span class="hljs-type">char</span> three;<br>    <span class="hljs-type">int</span> four;<br>&#125; c,d;<br></code></pre></td></tr></table></figure><ul><li>#pragma pack (1)</li></ul><p><img src="/2018/ef667962/%E6%97%A0%E6%A0%87%E9%A2%98.png" alt="无标题"></p><ul><li>#pragma pack (2)</li></ul><p><img src="/2018/ef667962/%E6%97%A0%E6%A0%87%E9%A2%98-1608969543089.png" alt="无标题"></p><ul><li>#pragma pack (4)</li></ul><p><img src="/2018/ef667962/%E6%97%A0%E6%A0%87%E9%A2%98-1608969576331.png" alt="无标题"></p><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><ul><li><p>pragma pack(n)</p></li><li><p>pragma pack()</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(1)<span class="hljs-comment">//自定义对齐参数   指定对齐参数</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">MotorStartStop_</span>&#123;</span><br><span class="hljs-comment">//Code******</span><br>&#125; MStartStopRec_TYPEDEF;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack()<span class="hljs-comment">//取消自定义的对齐参数</span></span><br></code></pre></td></tr></table></figure><ul><li><p>Pragma Pack(push)</p></li><li><p>Pragma Pack(pop)</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(push)<span class="hljs-comment">//Push压栈  保存系统的对齐方式(push指令之前的对齐状态)</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(1)<span class="hljs-comment">//            自定义对齐方式</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">MotorStartStop_</span>&#123;</span><br><span class="hljs-comment">//Code******</span><br>&#125; MStartStopRec_TYPEDEF;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(pop)<span class="hljs-comment">//Pop弹出    恢复系统的对齐方式</span></span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(push,1)<span class="hljs-comment">//此语句等同于以下两条语句</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(push)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(1) </span><br></code></pre></td></tr></table></figure><h2 id="pragma-OPTIMIZE-n-优化级别调整"><a href="#pragma-OPTIMIZE-n-优化级别调整" class="headerlink" title="#pragma OPTIMIZE(n)(优化级别调整)"></a>#pragma OPTIMIZE(n)(优化级别调整)</h2><p><span style="color:red">在ARM里面已经用不了</span></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> save<span class="hljs-comment">//SAVE指令将优化指令的当前设置存储到一个SAVE堆栈中。可以使用RESTORE指令还原设置。</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> optimize (1)</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">func</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>.<br>.<br>.<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> restore<span class="hljs-comment">//RESTORE指令 恢复</span></span><br></code></pre></td></tr></table></figure><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p> tip:宏函数</p><p>在大多数情况下，内联特定功能的决定最好留给编译器。使用<code>__inline__</code>或<code>inline</code>关键字限定函数的功能向编译器暗示它可以内联该函数，<strong>但最终决定权在于编译器</strong>。使用限定函数将<code>__attribute__((always_inline))</code>强制编译器内联函数。 </p><h3 id="inline内联"><a href="#inline内联" class="headerlink" title="__inline内联"></a><del>__inline内联</del></h3><p>最终决定权在于编译器,不使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __inline <span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>&#123;<br>    <span class="hljs-keyword">return</span> x*<span class="hljs-number">5</span>+<span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">g</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span>&#123;<br>    <span class="hljs-keyword">return</span> f(x) + f(y);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="forceinline强制内联"><a href="#forceinline强制内联" class="headerlink" title="__forceinline强制内联"></a>__forceinline强制内联</h3><ol><li><p><code>__forceinline</code>的语义与C ++ <code>inline</code> 关键字的语义完全相同。编译器将尝试内联该函数，而不管其特性如何。</p><p><strong>在某些情况下，编译器可能会选择忽略<code>__forceinline</code>关键字而不是内联函数。</strong>例如：</p><ul><li>递归函数永远不会内联到自身中。</li><li>使用函数<code>alloca()</code>(内存分配函数)永远不会内联。</li></ul><p><code>__forceinline</code>是存储类限定符。它不影响函数的类型。</p></li><li><p>它等效于 <strong>attribute</strong>((always_inline))</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">__forceinline <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">max</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> x &gt; y ? x : y; <span class="hljs-comment">// always inline if possible</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">max</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> __<span class="hljs-title function_">attribute__</span><span class="hljs-params">((always_inline))</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">max</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> x &gt; y ? x : y; <span class="hljs-comment">// always inline if possible</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用递减的循环可以提高程序运行效率"><a href="#使用递减的循环可以提高程序运行效率" class="headerlink" title="使用递减的循环可以提高程序运行效率"></a>使用递减的循环可以提高程序运行效率</h2><p><a href="http://www.keil.com/support/man/docs/armcc/armcc_chr1359124222426.htm">参考  C代码中循环终止的优化 </a></p><ul><li>使用简单终止循环的条件。</li><li>使用递减到0的循环 </li><li>使用 unsigned int 类型</li><li>与0进行对比</li></ul><h2 id="volatile-的使用"><a href="#volatile-的使用" class="headerlink" title="volatile 的使用"></a>volatile 的使用</h2><ul><li>访问内存映射的外围设备。</li><li>在多个线程之间共享全局变量。</li><li>在中断例程或信号处理程序中访问全局变量。</li></ul><h2 id="纯函数-优化"><a href="#纯函数-优化" class="headerlink" title="纯函数(优化)"></a>纯函数(优化)</h2><p> <code>__pure</code>  </p><p>纯函数定义：同样的的输入有同样的输出， 纯函数无法通过使用全局变量或通过指针间接读取或写入全局状态 </p><p>优势：编译器通常可以执行强大的优化， 例如通用子表达式消除（CSE） 。</p><h2 id="packed-pragma-packed-字节对齐"><a href="#packed-pragma-packed-字节对齐" class="headerlink" title="__packed  #pragma packed 字节对齐"></a>__packed  #pragma packed 字节对齐</h2><p> 将整个结构声明为 __packed 通常会导致代码大小和性能的损失。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">__packed <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mystruct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> c;<br>    <span class="hljs-type">short</span> s;<br>&#125; <span class="hljs-comment">// 不建议的</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mystruct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> c;<br>    __packed <span class="hljs-type">short</span> s; <span class="hljs-comment">// 建议的</span><br>&#125;<br></code></pre></td></tr></table></figure><p> <a href="http://www.keil.com/support/man/docs/armcc/armcc_chr1359124230195.htm">参考</a></p><p><a href="http://www.keil.com/support/man/docs/armcc/armcc_chr1359124230944.htm">__packed和#pragma packed对比</a></p><h2 id="func-FUNCTION-FILE-LINE"><a href="#func-FUNCTION-FILE-LINE" class="headerlink" title="__func__ __FUNCTION__ __FILE__ __LINE__"></a>__func__ __FUNCTION__ __FILE__ __LINE__</h2><p>__func__ __FUNCTION__ __FILE__ __LINE__</p><p>获取当前函数名称</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This function is called &#x27;%s&#x27;.\n&quot;</span>, __func__);<br>&#125;<br></code></pre></td></tr></table></figure><p>prints:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">This function is called <span class="hljs-string">&#x27;foo&#x27;</span>.<br></code></pre></td></tr></table></figure><h2 id="attribute-used-不能将其优化移除"><a href="#attribute-used-不能将其优化移除" class="headerlink" title="__attribute__((used))不能将其优化移除"></a>__attribute__((used))不能将其优化移除</h2><p>用这个东西声明函数之后，即使这个函数没有被引用，编译器也不能将其优化移除，仍然要求将此函数保留在工程中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lose_this</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">keep_this</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> __<span class="hljs-title function_">attribute__</span><span class="hljs-params">((used))</span>;     <span class="hljs-comment">// retained in object file</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">keep_this</span> <span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>  <span class="hljs-keyword">return</span> (arg+<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">keep_this_too</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> __<span class="hljs-title function_">attribute__</span><span class="hljs-params">((used))</span>; <span class="hljs-comment">// 保留在工程文件中</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">keep_this_too</span> <span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>  <span class="hljs-keyword">return</span> (arg<span class="hljs-number">-1</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>  <span class="hljs-keyword">for</span> (;;);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="attribute-section-“XX-name”-放置到特定的段里面"><a href="#attribute-section-“XX-name”-放置到特定的段里面" class="headerlink" title="__attribute__((section(“XX_name”)))放置到特定的段里面"></a>__attribute__((section(“XX_name”)))放置到特定的段里面</h2><p><strong>XX_name:是输入段的名称(字符串)。</strong></p><p>这个东西是告诉编译器，将特定的函数或者变量放置到特定的段里面。</p><p>变量和函数在输入段中的地址是连续的，并顺序先按section名(也就是XX_name)排序，section内再按照函数名称进行排序。</p><h2 id="attribute-at-0x00-将变量定义到指定的地方"><a href="#attribute-at-0x00-将变量定义到指定的地方" class="headerlink" title="__attribute__((at(0x00)))将变量定义到指定的地方"></a>__attribute__((at(0x00)))将变量定义到指定的地方</h2><p>将变量定义到指定的地方</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//linux</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> temp_A@<span class="hljs-number">0x00</span>; <span class="hljs-comment">//定义无符号变量temp_A，强制其地址为0x00 变量@地址</span><br><span class="hljs-comment">//keil</span><br><span class="hljs-type">uint8_t</span> cnt __attribute__((at(<span class="hljs-number">0x20008000</span>))); <span class="hljs-comment">//格式固定下划线为两个下划线，括号必须那么多层</span><br></code></pre></td></tr></table></figure><h2 id="attribute-alias-“sss”-起别名"><a href="#attribute-alias-“sss”-起别名" class="headerlink" title="__attribute__((alias(“sss”)))起别名"></a>__attribute__((alias(“sss”)))起别名</h2><p>相当于起别名</p><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, __FUNCTION__);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">bar</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> __<span class="hljs-title function_">attribute__</span><span class="hljs-params">((alias(<span class="hljs-string">&quot;foo&quot;</span>)))</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">gazonk</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    bar(); <span class="hljs-comment">// calls foo</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Code-RO-RW-ZI"><a href="#Code-RO-RW-ZI" class="headerlink" title="Code RO RW ZI"></a>Code RO RW ZI</h2><p>Program Size: Code&#x3D;14554 RO-data&#x3D;1234 RW-data&#x3D;272 ZI-data&#x3D;6168  </p><p>Program Size: Code&#x3D;13682 RO-data&#x3D;1098 RW-data&#x3D;224 ZI-data&#x3D;6160  </p><ul><li><p>Code </p></li><li><p>Read Only</p></li><li><p>Read Write</p></li><li><p>Zero Initial</p></li></ul><blockquote><p>  编译器插入一个小的引导程序代码，该代码从编译好的image中获取具有初始化数据初始值的块，并将其复制到 RAM（这是 RW 区域）中。然后它将剩余的已用 RAM（ZI 区域）清零。然后控制权转移到程序员编写的实际代码中。</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Total</span> RO Size (Code+Ro data)                <span class="hljs-number">36732</span> (<span class="hljs-number">35</span>.<span class="hljs-number">87</span>kB)<br><span class="hljs-attribute">Total</span> RW Size (RW Data + ZI Data)           <span class="hljs-number">27348</span> (<span class="hljs-number">26</span>.<span class="hljs-number">71</span>kB<br><span class="hljs-attribute">Total</span> ROM Size (Code + RO Data + RW Data)   <span class="hljs-number">36812</span> (<span class="hljs-number">35</span>.<span class="hljs-number">95</span>kB<br></code></pre></td></tr></table></figure></blockquote><h2 id="汇编延时-不受优化影响"><a href="#汇编延时-不受优化影响" class="headerlink" title="汇编延时 不受优化影响"></a>汇编延时 不受优化影响</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 汇编延时</span><br><span class="hljs-comment"> * @attention us延时不是很准确</span><br><span class="hljs-comment"> * @details 三个汇编指令理论应该是三个时钟周期</span><br><span class="hljs-comment"> * 则 理论上</span><br><span class="hljs-comment"> * ms AsmDelay( n*(SystemCoreClock/3000) )</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 实际有所差异 在STM32F105上</span><br><span class="hljs-comment"> * ms AsmDelay( n*(SystemCoreClock/6000) )</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined (__CC_ARM)              <span class="hljs-comment">// ARM Compiler</span></span><br>__attribute__((always_inline)) __ASM <span class="hljs-type">void</span> <span class="hljs-title function_">AsmDelay</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> t)</span><br>&#123;<br>    subs    r0, #<span class="hljs-number">1</span>;<br>    bne     AsmDelay;<br>    bx      lr;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined (__ICCARM__)         <span class="hljs-comment">// IAR Compiler</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">AsmDelay</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> t)</span><br>&#123;<br>    __asm(<br>    <span class="hljs-string">&quot;subs  r0, #1\n&quot;</span><br>    <span class="hljs-string">&quot;bne.n AsmDelay\n&quot;</span><br>    <span class="hljs-string">&quot;bx    lr&quot;</span><br>    );<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> <span class="hljs-keyword">define</span> (__GUNC__)            <span class="hljs-comment">// GUN Compiler</span></span><br><span class="hljs-type">void</span> __attribute__((naked)) AsmDelay(<span class="hljs-type">uint32_t</span> t)<br>&#123;<br>    __asm(<br>    <span class="hljs-string">&quot;subs  r0, #1\n&quot;</span><br>    <span class="hljs-string">&quot;bne   AsmDelay\n&quot;</span><br>    <span class="hljs-string">&quot;bx    lr&quot;</span><br>    );<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h2 id="大小端-endian"><a href="#大小端-endian" class="headerlink" title="大小端 endian"></a>大小端 endian</h2><ul><li>大端模式Big-endian，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；<code>大端模式便于阅读</code></li><li>小端模式Little-endian，………..</li></ul><table><thead><tr><th>0x00123456</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>大端</td><td></td><td></td><td></td><td></td></tr><tr><td>地址</td><td>0x00000000</td><td>0x00000001</td><td>0x00000002</td><td>0x00000003</td></tr><tr><td>数值</td><td>0x00</td><td>0x12</td><td>0x34</td><td>0x56</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>小端</strong></td><td></td><td></td><td></td><td></td></tr><tr><td>地址</td><td>0x00000000</td><td>0x00000001</td><td>0x00000002</td><td>0x00000003</td></tr><tr><td>数值</td><td>0x56</td><td>0x34</td><td>0x12</td><td>0x00</td></tr></tbody></table><h1 id="C类"><a href="#C类" class="headerlink" title="C类"></a>C类</h1><h2 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h2><ol><li>选择合适的变量长度(最短的标识符显示最多信息量的原则)</li><li>短变量名i,j等一般作用域较小，有限范围内有效</li></ol><h3 id="循环变量的命名"><a href="#循环变量的命名" class="headerlink" title="循环变量的命名"></a>循环变量的命名</h3><p><strong>避免使用i、j、k等名字</strong></p><p>如果循环体长度较长的话，那就很容易使人忘记它代表的是什么，因此最好给循环控制变量一个富有意义的名字。由于经常进行更改，扩展和拷贝等代码到另一个程序中，因此，大多数有经验的程序员都避免用i、j、k这类的名字。<br>通过精心对循环控制变量进行命名，可以避免它们的交叉：当你想用i时误用了j，或者想用j时却又误用了i。<br>如果不得不使用它们的话，那除了把它们用作循环控制变量之外，最好不再用作别的变量名。这一约定是众所周知的，如果不遵守它只会引起别人的困惑。</p><h3 id="状态变量的命名"><a href="#状态变量的命名" class="headerlink" title="状态变量的命名"></a>状态变量的命名</h3><p>利用枚举类型和命名常量来设置状态量的值</p><p>如果没有注释，将数值赋给状态量将是非常费解的。</p><h3 id="逻辑变量命名"><a href="#逻辑变量命名" class="headerlink" title="逻辑变量命名"></a>逻辑变量命名</h3><p>使用肯定的逻辑变量名。</p><p>否定式的变量名如NotFound、NotDone和Notsuccessful等在“非”运算中是很难读懂的，如：</p>  <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">if not NotFound</span><br></code></pre></td></tr></table></figure><h3 id="参量的命名"><a href="#参量的命名" class="headerlink" title="参量的命名"></a>参量的命名</h3><p><strong>对常量来说，应该用它所代表的抽象实体而不是数值来命名。</strong><br>FIVE是一个很不恰当的常量名称（不管它代表的数值是否是5.0）；CYCLES_NEEDED则是个恰当的名称，CYCLES_NEEDED可以等于5.0也可以等于6.0，而Five &#x3D; 6.0则是个荒唐的语句。</p><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p><img src="/2018/ef667962/00.jpeg"></p><blockquote><p>  简记</p><p>  算术运算符 &gt; 关系运算符  &gt; 位运算符 &gt; 逻辑运算符 &gt; 赋值运算符</p></blockquote><ul><li>坑</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//编译报错 ！赋值运算符优先级最低！</span><br>(DS18B20_DQ_IN != <span class="hljs-number">0</span>) ? data_temp|=<span class="hljs-number">0x80</span> : data_temp&amp;=<span class="hljs-number">0x7f</span>;<br><span class="hljs-comment">//规范写法</span><br>(DS18B20_DQ_IN!=<span class="hljs-number">0</span>) ? (data_temp|=<span class="hljs-number">0x80</span>):(data_temp&amp;=<span class="hljs-number">0x7f</span>);<br></code></pre></td></tr></table></figure><ul><li>！！！极注意！！！  请小心有位运算时打上括号            &lt;&lt;  比  +-  要低 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">u16 temp;<br>u8 h,l;<br>temp = (u16)(h&lt;&lt;<span class="hljs-number">8</span>) + l;<span class="hljs-comment">// 正确语法</span><br>temp = h&lt;&lt;<span class="hljs-number">8</span> + l;<span class="hljs-comment">// 错误语法！！！！！</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="printf"><a href="#printf" class="headerlink" title="printf()"></a>printf()</h2><table><thead><tr><th align="left">转换说明符</th><th>输出</th></tr></thead><tbody><tr><td align="left">%a，%A</td><td>浮点数、十六进制、p-计数法（c99）</td></tr><tr><td align="left">%c</td><td>一个单一的字符</td></tr><tr><td align="left">%d</td><td>有符号十进制整数</td></tr><tr><td align="left">%f</td><td>浮点数、十六进制数法</td></tr><tr><td align="left">%e,%E</td><td>e计数法，E计数法</td></tr><tr><td align="left">%g,%G</td><td>g自动使用%e和%f，G自动使用%E和%f</td></tr><tr><td align="left">%i</td><td>有符号十进制整数</td></tr><tr><td align="left">%o</td><td>一个八进制数</td></tr><tr><td align="left">%p</td><td>一个指针</td></tr><tr><td align="left">%s</td><td>一个字符串</td></tr><tr><td align="left">%u</td><td>无符号十进制整数</td></tr><tr><td align="left">%x，%X</td><td>十六进制数字的无符号十六进制整数</td></tr><tr><td align="left">%%</td><td>百分号</td></tr></tbody></table><table><thead><tr><th>标志</th><th>意义</th></tr></thead><tbody><tr><td>-</td><td>项目是左对齐的；打印在字符的最左侧开始处。</td></tr><tr><td>+</td><td>有符号的值显示正负号。</td></tr><tr><td>(空格)</td><td>带前导空格，复数会带减号符号，+会覆盖空格标志。</td></tr><tr><td>#</td><td>%o以0开始，%x以0x开始，浮点保证打印小数点，%g防止尾随零被删</td></tr><tr><td>0</td><td>前导零填充，会忽略-符号。</td></tr><tr><td>修饰符</td><td>意义</td></tr><tr><td>———</td><td>————————————————————</td></tr><tr><td>digit(s)</td><td>字段宽度的最小值。<br/>%4d</td></tr><tr><td>.digit(s)</td><td>精度。<br/>%5.2f</td></tr><tr><td>h</td><td>和整数说明符一起使用。表示short int或unsigned short int<br/>%hu、%hx、%6.4hd</td></tr><tr><td>hh</td><td>和整数说明符一起使用。表示signed char或unsigned char<br/>%hhu、%hhx、%6.4hhd</td></tr><tr><td>j</td><td>和整数说明符一起使用。表示intmax_t或uintmax_t<br/>%jd、%8jX</td></tr><tr><td>l</td><td>和整数说明符一起使用。long int或unsigned long int<br/>%ld、%lu</td></tr><tr><td>ll</td><td>和整数说明符一起使用。long long int或unsigned long long int（C99）<br/>%lld、%llu</td></tr><tr><td>L</td><td>和浮点数一起使用。表示long double<br/>%Lf、%Le</td></tr><tr><td>t</td><td>和整数说明符一起使用。ptrdiff_t（两个指针的差，相对向量）(C99)</td></tr><tr><td>z</td><td>和整数转换符一起使用。表示一个size_t值（sizeof的返回值）(C99)</td></tr></tbody></table><h2 id="数值数据类型-u-ul-b"><a href="#数值数据类型-u-ul-b" class="headerlink" title="数值数据类型 u ul b"></a>数值数据类型 u ul b</h2><h3 id="用于说明数据类型"><a href="#用于说明数据类型" class="headerlink" title="用于说明数据类型"></a>用于说明数据类型</h3><p>u &#x3D;&#x3D; unsigned int</p><p>l &#x3D;&#x3D;  long</p><p>ul &#x3D;&#x3D; unsigned long</p><p>数值后面加“L”和“l”（小写的l）的意义是该数值是long型。<br>详细说如下：<br>5L的数据类型为long int。<br>5.12L   的数据类型为long double。<br>数值后面加“U”和“u”的意义是该数值是unsigned型。</p><h3 id="用于说明数值表示方法"><a href="#用于说明数值表示方法" class="headerlink" title="用于说明数值表示方法"></a>用于说明数值表示方法</h3><table><thead><tr><th>进制↓   \   表示方法→</th><th>前面加</th><th></th><th>示例</th></tr></thead><tbody><tr><td>二进制</td><td>0b</td><td></td><td>0b1010 &#x3D; 10</td></tr><tr><td>八进制</td><td>0</td><td></td><td>012 &#x3D; 10</td></tr><tr><td>十进制</td><td></td><td>u l ul</td><td>1u (规范性)</td></tr><tr><td>十六进制</td><td>0x</td><td></td><td>0x12 &#x3D; 18</td></tr></tbody></table><ul><li>注意：在宏定义中数字应加上尾缀，避免与八进制混淆</li></ul><h2 id="sprintf"><a href="#sprintf" class="headerlink" title="sprintf()"></a>sprintf()</h2><ul><li><p>写入buff的数据会连带‘\0’一起写入</p></li><li><p>在 C 里，对“字符串”的通常约定，是以 <code>&#39;\0&#39;</code> 为结尾的字符串。从而在传递字符串参数的时候，只需要一个指向字符串首字符的指针。来自 C 的操作字符串的函数(<code>sprintf</code>, <code>strcpy</code>, <code>strcat</code>, 等等)通常都遵循这一约定，包括在写字符串的时候，会在末尾添加一个 <code>&#39;\0&#39;</code> 。（除非在某些情况下有特殊约定）</p><p>但是，<code>memcpy</code> 等不是操作字符串的函数，就不会添加最后的 <code>&#39;\0&#39;</code> 。</p></li></ul><h2 id="snprintf"><a href="#snprintf" class="headerlink" title="snprintf()"></a>snprintf()</h2><ul><li>所传入的值以<strong>‘\0’</strong>结尾    要得到   <strong>20</strong>  个数据需要传入参数  <strong>20+1</strong></li><li>如果传入的str是<code>&quot;Hello&quot;</code> size参数是5则 无法写入<code>&#39;\0&#39;</code> ,size参数是6 则可以写入 <code>&#39;\0&#39;</code></li></ul><h2 id="sscanf"><a href="#sscanf" class="headerlink" title="sscanf()"></a>sscanf()</h2><h3 id="原型-1"><a href="#原型-1" class="headerlink" title="原型"></a>原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sscanf</span><span class="hljs-params">( <span class="hljs-type">const</span> <span class="hljs-type">char</span> *buffer, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, [ argument ] ...   )</span>; <br><br></code></pre></td></tr></table></figure><p>buffer   存储的数据<br>format 窗体控件字符串。 有关详细信息，请参阅”格式规范”。<br>argument    可选自变量<br>locale   要使用的区域设置</p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>sscanf与scanf类似，都是用于输入的，只是后者以键盘(stdin)为输入源，前者以<strong>固定字符串</strong>为输入源。</p><h4 id="控制字符说明"><a href="#控制字符说明" class="headerlink" title="控制字符说明"></a>控制字符说明</h4><blockquote><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs txt">%c  一个单一的字符 <br>%d  一个十进制整数 <br>%i  一个整数 <br>%e, %f, %g 一个浮点数 <br>%o  一个八进制数 <br>%s  一个字符串 <br>%x  一个十六进制数 <br>%p  一个指针 <br>%n  一个等于读取字符数量的整数<br>%u  一个无符号整数<br>%[]  一个字符集 <br>\%\%  一个精度符<br></code></pre></td></tr></table></figure></blockquote><h3 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h3><p>函数将返回成功赋值的字段个数；返回值不包括已读取但未赋值的字段个数。 返回值为 0 表示没有将任何字段赋值。 如果在第一次读取之前到达字符串结尾，则返回EOF。</p><h3 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h3><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> buf[<span class="hljs-number">512</span>];<br><span class="hljs-built_in">sscanf</span>(<span class="hljs-string">&quot;123456 &quot;</span>, <span class="hljs-string">&quot;%s&quot;</span>, buf);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf);<br><span class="hljs-comment">//结果为：123456</span><br><br><br><span class="hljs-comment">//取指定长度的字符串。如在下例中，取最大长度为4字节的字符串。</span><br><span class="hljs-built_in">sscanf</span>(<span class="hljs-string">&quot;123456 &quot;</span>, <span class="hljs-string">&quot;%4s&quot;</span>, buf);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf);<br><span class="hljs-comment">//结果为：1234</span><br><br><span class="hljs-comment">//取到指定字符为止的字符串。如在下例中，取遇到空格为止字符串。</span><br><span class="hljs-built_in">sscanf</span>(<span class="hljs-string">&quot;123456 abcdedf&quot;</span>, <span class="hljs-string">&quot;%[^ ]&quot;</span>, buf);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf);<br><span class="hljs-comment">//结果为：123456</span><br><br><span class="hljs-comment">//取仅包含指定字符集的字符串。如在下例中，取仅包含1到9和小写字母的字符串。</span><br><span class="hljs-built_in">sscanf</span>(<span class="hljs-string">&quot;123456abcdedfBCDEF&quot;</span>, <span class="hljs-string">&quot;%[1-9a-z]&quot;</span>, buf);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf);<br><span class="hljs-comment">//结果为：123456abcdedf</span><br><br><span class="hljs-comment">//取到指定字符集为止的字符串。如在下例中，取遇到大写字母为止的字符串。</span><br><span class="hljs-built_in">sscanf</span>(<span class="hljs-string">&quot;123456abcdedfBCDEF&quot;</span>, <span class="hljs-string">&quot;%[^A-Z]&quot;</span>, buf);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf);<br><span class="hljs-comment">//结果为：123456abcdedf</span><br><br><span class="hljs-comment">//给定一个字符串iios/12DDWDFF@122，获取 / 和 @ 之间的字符串，先将 &quot;iios/&quot;过滤掉，再将非&#x27;@&#x27;的一串内容送到buf中</span><br><span class="hljs-built_in">sscanf</span>(<span class="hljs-string">&quot;iios/12DDWDFF@122&quot;</span>, <span class="hljs-string">&quot;%*[^/]/%[^@]&quot;</span>, buf);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf);<br><span class="hljs-comment">//结果为：12DDWDFF</span><br><br><span class="hljs-comment">//给定一个字符串&quot;hello, world&quot;，仅保留&quot;world&quot;。（注意：“，”之后有一空格）</span><br><span class="hljs-built_in">sscanf</span>(<span class="hljs-string">&quot;hello, world&quot;</span>, <span class="hljs-string">&quot;%*s%s&quot;</span>, buf);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf);<br><span class="hljs-comment">//结果为：world</span><br><br></code></pre></td></tr></table></figure><h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><p><img src="/2018/ef667962/20161218131342960.png"></p><h2 id="Union"><a href="#Union" class="headerlink" title="Union"></a>Union</h2><h3 id="数据拆分、移位"><a href="#数据拆分、移位" class="headerlink" title="数据拆分、移位"></a>数据拆分、移位</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">union</span><br>&#123;<br>u16 Val_u16;<br>u8 Val_u8[<span class="hljs-number">2</span>];<br>&#125;_HL_UNION;<br></code></pre></td></tr></table></figure><h2 id="Struct"><a href="#Struct" class="headerlink" title="Struct"></a>Struct</h2><ul><li>注意节约内存，小数据全部写在前面方便对齐。</li><li>结构体内的结构体因为已经是对其了的，所以，可以建议放在最前、最后。</li></ul><h2 id="匿名-union-struct"><a href="#匿名-union-struct" class="headerlink" title="匿名 union struct"></a>匿名 union struct</h2><p>可以在<strong>结构体</strong>中声明某个联合体（或结构体）而不用指出它的名字，如此之后就可以像使用结构体成员一样直接使用其中联合体（或结构体）的成员。</p><blockquote><p>  Anonymous unions are a GNU extension, not part of any standard version of the C language. </p><p>  <strong>Anonymous unions were added in C11, so they are now a standard part of the language. Presumably GCC’s <code>-std=c11</code> lets you use them.</strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// union 普通联合</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  <span class="hljs-type">char</span> title[<span class="hljs-number">50</span>];<br>  <span class="hljs-type">char</span> author[<span class="hljs-number">50</span>];<br>  <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>    <span class="hljs-type">float</span> dollars;<br>    <span class="hljs-type">int</span> yen;<br>  &#125; price;<br>&#125; book;<br><span class="hljs-comment">// anonymous union 匿名联合</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  <span class="hljs-type">char</span> title[<span class="hljs-number">50</span>];<br>  <span class="hljs-type">char</span> author[<span class="hljs-number">50</span>];<br>  <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>    <span class="hljs-type">float</span> dollars;<br>    <span class="hljs-type">int</span> yen;<br>  &#125;;<br>&#125; book;<br><br><span class="hljs-comment">// 在前一种定义的情况下，需要使用：</span><br>book.price.dollars;<br>book.price.yen;<br><span class="hljs-comment">// 而在后面一种定义下，我们直接使用：</span><br>book.dollars;<br>book.yen;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">person_jim_t</span>&#123;</span>  <br>    <span class="hljs-type">char</span>    *name;  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span>  <br>        <span class="hljs-type">int</span>  area_code;  <br>        <span class="hljs-type">long</span> phone_number;  <br>    &#125;; <br>&#125;<span class="hljs-type">person_jim_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">person_tim_t</span>&#123;</span><br>    <span class="hljs-type">char</span>    *name;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span>&#123;</span><br>        <span class="hljs-type">char</span> gender;<br>        <span class="hljs-type">int</span>  id;<br>    &#125;;<br>&#125;<span class="hljs-type">person_tim_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">union</span> _<span class="hljs-title">net_info_t</span>&#123;</span><br>    <span class="hljs-type">uint32_t</span>                val[<span class="hljs-number">3</span>];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>        <span class="hljs-type">uint8_t</span>             ip[<span class="hljs-number">4</span>];          <span class="hljs-comment">// int ip address</span><br>        <span class="hljs-type">uint8_t</span>             mask[<span class="hljs-number">4</span>];        <span class="hljs-comment">// </span><br>        <span class="hljs-type">uint8_t</span>             gateway[<span class="hljs-number">4</span>];     <span class="hljs-comment">// </span><br>    &#125;;<br>&#125; <span class="hljs-type">net_info_t</span>;<br></code></pre></td></tr></table></figure><h3 id="keil"><a href="#keil" class="headerlink" title="keil"></a>keil</h3><p>keil也支持匿名结构体、联合体 需要使用编译器参数<code>#pragma anon_unions</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> anon_unions</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">union</span> &#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> num;<br><span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nLow        :<span class="hljs-number">8</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nHigh         :<span class="hljs-number">8</span>;<br>&#125;;<br>&#125;kkTypedef;<br></code></pre></td></tr></table></figure><h2 id="register"><a href="#register" class="headerlink" title="register"></a>register</h2><p>　　这个关键字<strong>请求</strong>（只是请求，最终看编译器）编译器尽可能的将变量存在CPU内部寄存器中，而不是通过内存寻址访问，以提高效率。注意是尽可能，不是绝对。你想想，一个CPU 的寄存器也就那么几个或几十个，你要是定义了很多很多register 变量，它累死也可能不能全部把这些变量放入寄存器吧。</p><p>register是一个C语言的关键字，用来声明寄存器变量，即存放在CPU的寄存器里的变量。寄存器变量的访问速度比内存变量快得多，因为寄存器是CPU内部的组成部分，而内存是外部的设备。</p><ul><li>寄存器变量只能用于基本数据类型，如int, char, float等，不能用于数组、结构体、联合等复合类型<a href="https://zh.wikipedia.org/wiki/%E5%AF%84%E5%AD%98%E5%99%A8">1</a>。</li><li>寄存器变量的作用域和自动变量相同，即只在定义它的函数或代码块内有效<a href="https://zh.wikipedia.org/wiki/%E5%AF%84%E5%AD%98%E5%99%A8">1</a>。</li><li>寄存器变量不能取地址，因为它们没有固定的内存位置。</li><li>寄存器变量的数量受到CPU寄存器的限制，如果声明过多的寄存器变量，编译器可能会忽略register关键字，将它们当作普通的自动变量处理。</li></ul><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><ul><li>典型用处<ul><li>寄存器的访问</li><li>全局变量被中断修改</li><li>多线程共享的变量</li></ul></li><li>const volatile<ul><li>两者同时修饰一个对象的典型情况，是用于驱动中访问外部设备的只读寄存器。</li><li>（1）本程序段中不能对a作修改，任何修改都是非法的，或者至少是粗心，编译器应该报错，防止这种粗心；</li><li>（2）另一个程序段则完全有可能修改，因此编译器最好不要做太激进的优化。</li></ul></li></ul><ol><li><p>并行设备的硬件寄存器（如：状态寄存器）</p><ul><li><p>延伸 const  volatile</p><ul><li><blockquote><p>  两者同时修饰一个对象的典型情况，是用于驱动中访问外部设备的只读寄存器。</p><ol><li>本程序段中不能对a作修改，任何修改都是非法的，或者至少是粗心，编译器应该报错，防止这种粗心；</li><li>另一个程序段则完全有可能修改，因此编译器最好不要做太激进的优化。</li></ol></blockquote></li></ul></li></ul></li><li><p>一个中断服务子程序中会访问到的<strong>非自动变量</strong>(Non-automatic variables)</p><ul><li><strong>自动变量</strong>：是在函数内部定义和使用的变量，它是<strong>局部变量</strong>。</li><li><strong>非自动变量</strong>：有两种，一种是<strong>全局变量</strong>，一种是<strong>静态变量</strong>。</li></ul></li><li><p>多线程应用中被几个任务共享的变量</p></li></ol><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><ul><li><p>提高程序鲁棒性（Robust）稳健性</p></li><li><p>主要有两种用法</p><ul><li>修饰全局变量也就是文件上定义的变量，防止被extern，污染命名空间（命名冲突）</li><li>修饰函数内定义的变量，保持变量的持久性（函数体内定义）</li></ul></li><li><p>优化代码结构和程序性能</p><ul><li>内存放在静态数据区，这样可以提高数据的局部性，提高缓存的利用效率</li><li>多次调用不会多次分配内存，节省内存分配时间</li><li>显示的声明作用域和生命周期，提高代码可读性和可维护性</li></ul></li><li><p>默认初始化为0，不需要显式的初始化为0，存放在静态数据区（类似于全局变量的位置）</p></li><li><p>模块内不对外开放的变量都应该使用static修饰</p></li></ul><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><ul><li>不可变</li><li>提高程序鲁棒性（Robust）稳健性</li><li>没有修改需求的指针都应该被const修饰</li></ul><h3 id="关于Const指针"><a href="#关于Const指针" class="headerlink" title="关于Const指针"></a>关于Const指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">int</span> *p1;<span class="hljs-comment">//指向常量的指针 (const int) *p1，指向的值不能修改，指针本身可以修改</span><br><br><span class="hljs-type">int</span> *<span class="hljs-type">const</span> p2;    <span class="hljs-comment">//指针是常量 int *(const p2) 不能指向别的变量，但是指向的变量可以修改因为不能被修改所以必须要被初始化。</span><br>   <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *<span class="hljs-type">const</span> p3;<span class="hljs-comment">//不能指向别的变量，也不能修改指向变量的值</span><br><br><span class="hljs-comment">//注意   这个等同于第一个   容易产生误解尽量不要使用这个表达</span><br><span class="hljs-type">int</span> <span class="hljs-type">const</span> *p;<span class="hljs-comment">//指向常量的指针</span><br></code></pre></td></tr></table></figure><h3 id="Const常量可以被修改"><a href="#Const常量可以被修改" class="headerlink" title="Const常量可以被修改"></a>Const常量可以被修改</h3><p>对于一个Cont常量，实际上你访问的是它的<strong>内存拷贝</strong>，你仍然可以去用指针去修改它。</p><h3 id="const-局部变量"><a href="#const-局部变量" class="headerlink" title="const 局部变量"></a>const 局部变量</h3><p>const 局部变量居然定义在stack上，用指针居然可以修改其值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> const_val=<span class="hljs-number">66</span>;<br><span class="hljs-type">int</span> *p = &amp;const_val;<br>    <br>*p = <span class="hljs-number">33</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;const_val=%d \r\n&quot;</span>, const_val );<span class="hljs-comment">//const_val=33</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="const-volatile"><a href="#const-volatile" class="headerlink" title="const volatile"></a>const volatile</h3><p>见 volatile 相关内容</p><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id="const-指针"><a href="#const-指针" class="headerlink" title="const 指针"></a>const 指针</h3><p><a href="###%E5%85%B3%E4%BA%8EConst%E6%8C%87%E9%92%88">关于Const指针</a></p><h3 id="有x个指针的数组"><a href="#有x个指针的数组" class="headerlink" title="有x个指针的数组"></a>有x个指针的数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *p2[<span class="hljs-number">3</span>]<span class="hljs-comment">//这是有三个指针的数组</span><br></code></pre></td></tr></table></figure><h3 id="指向x个元素数组的指针"><a href="#指向x个元素数组的指针" class="headerlink" title="指向x个元素数组的指针"></a>指向x个元素数组的指针</h3><ul><li>指针执行<code>p1 = p1 + 1;</code>操作，p1中的值会增加12个字节</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> (*p1)[<span class="hljs-number">3</span>]<span class="hljs-comment">//指向x个元素数组的指针</span><br></code></pre></td></tr></table></figure><h3 id="二维、多维数组的指针"><a href="#二维、多维数组的指针" class="headerlink" title="二维、多维数组的指针"></a>二维、多维数组的指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>] =&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;,&#123;<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;&#125;<br><span class="hljs-type">int</span> (*pa)[<span class="hljs-number">2</span>] = a<br><span class="hljs-comment">//a是指向指针的指针</span><br><span class="hljs-comment">//a是一个指针，他指向的是下一维度的数组的头（指针、地址，它指向二维数组的第一个值），</span><br>*(*(a+<span class="hljs-number">0</span>)+<span class="hljs-number">0</span>) == <span class="hljs-number">1</span><br>*(*(a+<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>) == <span class="hljs-number">2</span><br>*(*(a+<span class="hljs-number">1</span>)+<span class="hljs-number">0</span>) == <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h3 id="指针参数的内存传递"><a href="#指针参数的内存传递" class="headerlink" title="指针参数的内存传递"></a>指针参数的内存传递</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a=<span class="hljs-number">10</span>, b=<span class="hljs-number">20</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">fun_p</span><span class="hljs-params">(<span class="hljs-type">int</span> *p)</span><br>&#123;<br>    p = &amp;b;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">fun_p_p</span><span class="hljs-params">(<span class="hljs-type">int</span> *p)</span><br>&#123;<br>    *p = &amp;b;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> *p_a = &amp;a;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&amp;a=%X-&amp;b=%X\r\n&quot;</span>, &amp;a, &amp;b);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;p_a=%X\r\n&quot;</span>, p_a);<br><br>    fun_p(p_a);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;p_a=%X\r\n&quot;</span>, p_a);<br><br>    fun_p_p(&amp;p_a);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;p_a=%X\r\n&quot;</span>, p_a);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译器总是要为函数的每个参数制作临时副本，<code>void fun_p(int *p)</code>函数的指针参数是<code>p</code>，编译器为其分配的副本是<code>_p</code>，编译器使<code>_p=p</code>就是两者不是同一个变量但是指向相同的地址，函数里面修改了<code>_P</code>的指向，但是并没有修改<code>p</code>的指向，所以导致函数<code>void fun_p(int *p)</code>并没有得到期待的运行结果。</p><p>而<code>void fun_p_p(int *p)</code>函数是用指向<code>p_a</code>的指针修改了<code>p_a</code>的值。</p><p><span style="color:red">修改某个变量，要用指向这个变量的指针！而修改指针要用（指向指针的指针）才行！</span></p><h3 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h3><p>申请内存后的指针，被<code>free() </code>或<code> delete()</code>之后内存被释放，但是指针还是指向的那块内存，这个指针就叫野指针。</p><h2 id="跳的转到指定地址执行程序"><a href="#跳的转到指定地址执行程序" class="headerlink" title="跳的转到指定地址执行程序"></a>跳的转到指定地址执行程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">第一种办法：<span class="hljs-keyword">goto</span><br>第二种办法：<br><span class="hljs-comment">//解释</span><br><span class="hljs-type">void</span> (*)(<span class="hljs-type">void</span>)<span class="hljs-comment">//函数指针类型</span><br>(<span class="hljs-type">void</span> (*)(<span class="hljs-type">void</span>)) <span class="hljs-number">100</span><span class="hljs-comment">//将 100 强制转换为 函数指针类型</span><br><br><span class="hljs-comment">//函数定义</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">//code</span><br>&#125;<br><br><span class="hljs-comment">//函数调用</span><br>func();<br><br><span class="hljs-comment">//使用函数指针来执行</span><br><span class="hljs-type">void</span> (*pF)(<span class="hljs-type">void</span>) = func;<span class="hljs-comment">//使用函数指针指向func函数</span><br>pF();<span class="hljs-comment">//利用函数指针调用函数</span><br></code></pre></td></tr></table></figure><h2 id="内联函数-inline"><a href="#内联函数-inline" class="headerlink" title="内联函数 inline"></a>内联函数 inline</h2><p>详见Keil-&gt; Arm Compiler 6 User’s Guides-&gt; Inlining functions</p><table><thead><tr><th>Inlining options, keywords, or attributes</th><th>Description</th></tr></thead><tbody><tr><td><code>__inline__</code></td><td>Specify  this keyword on a function definition or declaration as a hint to the compiler  to favor inlining of the function. However, for each function call, the compiler  still decides whether to inline the function. This is equivalent to  <code>__inline</code>.</td></tr><tr><td><code>__attribute__((always_inline))</code></td><td>Specify  this function attribute on a function definition or declaration to tell the  compiler to always inline this function, with certain exceptions such as for  recursive functions. This overrides the <code>-fno-inline-functions</code>  option.</td></tr><tr><td><code>__attribute__((noinline))</code></td><td>Specify  this function attribute on a function definition or declaration to tell the  compiler to not inline the function. This is equivalent to  <code>__declspec(noinline)</code>.</td></tr><tr><td><code>-fno-inline-functions</code></td><td>This  is a compiler command-line option. Specify this option to the compiler to  disable inlining. This option overrides the <code>__inline__</code>  hint.</td></tr></tbody></table><p><strong>Note:</strong></p><ul><li>Arm Compiler only  inlines functions within the same compilation unit, unless you use Link Time  Optimization. For more information, see <a href="armclang_intro_chr1413367986635.htm"><em>Optimizing across modules with link time  optimization</em></a> in the Software Development  Guide. </li><li>C++ and C99 provide the <code>inline</code> language keyword. The effect of  this <code>inline</code> language keyword is identical to the effect of using  the <code>__inline__</code> compiler keyword. However, the effect in C99 mode is  different from the effect in C++ or other C that does not adhere to the C99  standard. For more information, see <a href="https://developer.arm.com/docs/101754/0614/armclang-reference/other-compiler-specific-features/inline-functions"><em>Inline functions</em></a> in  the Arm Compiler Reference Guide. </li><li>Function inlining normally happens at higher optimization levels, such as  <code>-O2</code>, except when you specify  <code>__attribute__((always_inline))</code>.</li></ul><h2 id="do-while-continue"><a href="#do-while-continue" class="headerlink" title="do while continue"></a>do while continue</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 相当于一个go to 去到了contin</span><br>    <span class="hljs-comment">// ...</span><br>contin:;<br>&#125; <span class="hljs-keyword">while</span> (<span class="hljs-comment">/* ... */</span>);<br></code></pre></td></tr></table></figure><h2 id="预编译ifdef"><a href="#预编译ifdef" class="headerlink" title="预编译ifdef"></a>预编译ifdef</h2><ul><li><p>第一种</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> WIN7</span><br>     xxx<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined WIN8 </span><br>xxx<br><span class="hljs-meta">#<span class="hljs-keyword">else</span> </span><br>xxxx<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li><li><p>第二种</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(WIN7)</span><br>xxx<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(WIN8) </span><br>xxx<br><span class="hljs-meta">#<span class="hljs-keyword">else</span> </span><br>xxxx<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure></li></ul><h2 id="宏相关"><a href="#宏相关" class="headerlink" title="宏相关"></a>宏相关</h2><ul><li><p>一般来说在宏中不要使用增量(++i)或减量(–i)运算符。假设宏里面有多个替换，结果是不可预知的。</p></li><li><p>在宏后面对宏的注释应该要用块注释，而不应使用行注释。因为有些编译器会将行注释理解成宏的一部分(这么智障的编译器嘛？？)。</p></li><li><p>define定义一个宏函数记得写 do{}while(0)</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> device_init_wakeup(dev,val) \ </span><br> device_can_wakeup(dev) = !!(val);   \ <br> device_set_wakeup_enable(dev,val);<br> <br> <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>) device_init_wakeup(d, v);<br></code></pre></td></tr></table></figure><p>   为什么不简单写{}</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> device_init_wakeup(dev,val) \ </span><br>&#123; device_can_wakeup(dev) = !!(val); \ <br>device_set_wakeup_enable(dev,val); &#125;<br><br><span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>) <br>    device_init_wakeup(d, v);<br><span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">continue</span>;<br></code></pre></td></tr></table></figure></li><li><p>__FILE__和__LINE__，FILE展开为当前源文件的文件名，是一个字符串，LINE展开为当前代码行的行号，是一个整数。</p></li><li><p>类似上面的 C99有__func__ 可以打印出当前函数名，但是注意这是一个变量而不是宏。</p></li><li><p>gcc 定义宏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">gcc -c -DMACHINE=<span class="hljs-number">8086</span> main.c<br></code></pre></td></tr></table></figure></li><li><p>在宏中用#将宏参量（可以是变量、函数名）转换成<strong>字符串</strong>。——创建字符串</p></li><li><p>在宏中用##将两者进行粘合变成<strong>一个标识符</strong>(变量等…)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> X_NAME(n) x##n</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> X_CHAR(x)#x</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PSQR(x)printf( <span class="hljs-string">&quot;The square of &quot;</span> #x <span class="hljs-string">&quot; is %d\n&quot;</span>,((x)*(x)) )</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PSQRx(x)printf( <span class="hljs-string">&quot;The square of %s is %d\n&quot;</span>, #x, ((x)*(x)) )</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">X_NAME</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span> = <span class="hljs-number">5</span>;<span class="hljs-comment">//等价于   x1 = 5;</span><br>PSQR( x1 );<br>PSQRx( x1 );<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s-%s-%d\r\n&quot;</span>, X_CHAR( X_NAME(<span class="hljs-number">1</span>) ), X_CHAR( x1 ), X_NAME(<span class="hljs-number">1</span>) );<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出：</span><br><span class="hljs-comment">The square of x1 is 25</span><br><span class="hljs-comment">The square of x1 is 25</span><br><span class="hljs-comment">X_NAME( 1 )-x1-5</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li><li><p>可变参数</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEBUGP(format, ...) printk(format, ## __VA_ARGS__)</span><br></code></pre></td></tr></table></figure></li></ul><ul><li>在C语言中，未定义的宏默认值为0。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> CONFIG_CHARGE_OUT_SHUTDOWN != 0</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;CONFIG_CHARGE_OUT_SHUTDOWN is not equal to zero.\n&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;CONFIG_CHARGE_OUT_SHUTDOWN is not defined or equal to zero.\n&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">// 在上述代码中，由于 `CONFIG_CHARGE_OUT_SHUTDOWN` 没有被定义，`#if` 指令的条件不成立，所以第一个 `printf` 语句不会被编译。相反，由于存在 `#else` 部分，第二个 `printf` 语句会被编译并执行，输出 &quot;CONFIG_CHARGE_OUT_SHUTDOWN is not defined or equal to zero.&quot;。</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="宏展开的顺序"><a href="#宏展开的顺序" class="headerlink" title="宏展开的顺序"></a>宏展开的顺序</h3><ul><li><p>带#和带##的运算符不需要进行参数的展开！！除了带#和##运算符的参数之外，其它参数在替换之前要对实参本身做充分的展开，所以应该先把sub_z展开成26再替换到alt[x]中x的位置。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> sh(x) printf(<span class="hljs-string">&quot;n&quot;</span> #x <span class="hljs-string">&quot;=%d, or %d\n&quot;</span>,n##x,alt[x])</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> sub_z 26</span><br><br>sh(sub_z)<br><span class="hljs-comment">//展开成了printf(&quot;n&quot; &quot;sub_z&quot; &quot;=%d, or %d\n&quot;,nsub_z,alt[26])</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h2><h3 id="signed-int转换到unsigned-int"><a href="#signed-int转换到unsigned-int" class="headerlink" title="signed int转换到unsigned int"></a>signed int转换到unsigned int</h3><p>带符号整型转换到无符号整型,最高位(high-order bit)会丧失其作为符号位的功能。如果该带符号整数的值非负,那么转换后值不变;如果该带符号整数的值为负,那么转换后的结果通常是一个非常大的正数。</p><h2 id="uint32-t-无符号相减-定时器溢出问题"><a href="#uint32-t-无符号相减-定时器溢出问题" class="headerlink" title="uint32_t 无符号相减 定时器溢出问题"></a>uint32_t 无符号相减 定时器溢出问题</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">timer_loop</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Timer</span>* <span class="hljs-title">target</span>;</span><br><span class="hljs-keyword">for</span>(target=head_handle; target; target=target-&gt;next) &#123;<br><span class="hljs-keyword">if</span>(_timer_ticks &gt;= target-&gt;timeout) &#123;<br><span class="hljs-keyword">if</span>(target-&gt;repeat == <span class="hljs-number">0</span>) &#123;<br>timer_stop(target);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>target-&gt;timeout = _timer_ticks + target-&gt;repeat;<br>&#125;<br>target-&gt;timeout_cb();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个uint32_t的_timer_ticks，每毫秒自加1，设备运行到49天的时候会涉及到溢出的问题。所以在timer_loop里面的判断超时的语句需要小修改下。</p><p><code>if(_timer_ticks &gt;= target-&gt;timeout)</code></p><p> 修改为 </p><p><code>if((int)((uint32_t)(target-&gt;timeout -_timer_ticks)) &lt;= 0)</code> </p><p>完美解决uint32_t变量溢出时，超时判断有误的bug</p><p>HAL库的无符号相减，tick是++</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>((now_tick - tick_start) &lt; wait )<br>&#123;&#125;<br><br><span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure><p><strong>RT-thread 内的判断</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 最大定时长度是 RT_TICK_MAX / 2</span><br><span class="hljs-keyword">if</span> ((current_tick - t-&gt;timeout_tick) &lt; RT_TICK_MAX / <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p><strong>这里其实涉及的是无符号数相减，减出负数</strong></p><p>负数在计算机内是用其补码来存储的。</p><p>减法会被换算成两个数的加法，a-b会被换算成a加上b的补码，即a+(~b+1)。</p><p>252-250&#x3D;(b1111 1100)+(b0000 0110)&#x3D;(b0000 0010)&#x3D;2</p><p>1-250&#x3D;(b0000 0001)+(b0000 0110)&#x3D;(b0000 0111)&#x3D;7</p><p><em><strong>所以计算两值的差值就可以直接相减</strong></em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">uint8_t</span> now = <span class="hljs-number">2</span>;<br><span class="hljs-type">uint8_t</span> pre = <span class="hljs-number">250</span>;<br><span class="hljs-type">uint8_t</span> differ=<span class="hljs-number">0</span>;<br><br>differ = (<span class="hljs-type">uint8_t</span>)(now - pre);<br><span class="hljs-comment">// differ = 0x08</span><br></code></pre></td></tr></table></figure><h2 id="c编译原理"><a href="#c编译原理" class="headerlink" title="c编译原理"></a>c编译原理</h2><p><img src="/2018/ef667962/2018051223284857.png" alt="2018051223284857"></p><p><img src="/2018/ef667962/20180513215202780.png" alt="20180513215202780"></p><h3 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h3><ul><li>define展开</li><li>FILE LINE等展开</li><li>include包含</li><li>转化 .i 文件</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">gcc -E<br></code></pre></td></tr></table></figure><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><ul><li>优化在这进行，包括数值计算一类</li><li>编译成汇编文件</li><li>转化 .s .asm文件</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">gcc -S<br></code></pre></td></tr></table></figure><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><ul><li>汇编语言代码翻译成目标机器指令的过程</li><li>data段code段在这里产生</li><li>转化 .o .obj文件</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">gcc -c<br></code></pre></td></tr></table></figure><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><ul><li>链接成 .exe .out .axf等</li><li>动态链接、静态链接(动态库.so、静态库.a)</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">gcc<br></code></pre></td></tr></table></figure><h2 id="内存分配相关"><a href="#内存分配相关" class="headerlink" title="内存分配相关"></a>内存分配相关</h2><p><img src="/2018/ef667962/215103893_2_20210208091156224-16901904300991.png" alt="Stm32RAM布局"></p><p><img src="/2018/ef667962/806053-20170722131756261-1095755633.png" alt="806053-20170722131756261-1095755633"></p><h3 id="code-代码区"><a href="#code-代码区" class="headerlink" title=".code 代码区"></a>.code 代码区</h3><p>代码段（code segment&#x2F;text segment ）通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。</p><blockquote><p>  STM32 在上电启动之后默认从 Flash 启动, 在STM32里面Code部分不会被搬运到RAM内</p></blockquote><h3 id="data-已初始化区"><a href="#data-已初始化区" class="headerlink" title=".data 已初始化区"></a>.data 已初始化区</h3><h3 id="bss-未初始化区"><a href="#bss-未初始化区" class="headerlink" title=".bss 未初始化区"></a>.bss 未初始化区</h3><h3 id="heap-堆区"><a href="#heap-堆区" class="headerlink" title="heap 堆区"></a>heap 堆区</h3><h3 id="stack-栈区"><a href="#stack-栈区" class="headerlink" title="stack 栈区"></a>stack 栈区</h3><p><img src="/2018/ef667962/686215-20151218231826459-500964006.png" alt="686215-20151218231826459-500964006"></p><ul><li><strong>在C语言中，函数参数的入栈顺序是从右到左</strong></li></ul><h2 id="new-delete-malloc-free"><a href="#new-delete-malloc-free" class="headerlink" title="new delete malloc free"></a>new delete malloc free</h2><blockquote><p>  free两次有时可能是极其严重的安全漏洞，将一个指针释放两次是非常危险的行为，它可能造成任意代码执行。 <a href="https://awakened1712.github.io/hacking/hacking-whatsapp-gif-rce/">参考</a></p></blockquote><h3 id="new-delete"><a href="#new-delete" class="headerlink" title="new &#x2F; delete"></a>new &#x2F; delete</h3><ul><li>Allocate &#x2F; release memory 分配&#x2F;释放<ol><li>Memory allocated from ‘Free Store’.   这个FreeStore和Heap不一定一样 似乎取决于它的具体实现方式</li><li>Returns a fully typed pointer.</li><li><code>new</code> (standard version) never returns a <code>NULL</code> (will throw on failure).</li><li>Are called with Type-ID (compiler calculates the size). 使用 Type-ID 调用（编译器计算大小）。</li><li>Has a version explicitly to handle arrays. 有一个明确的版本来处理数组。</li><li>Reallocating (to get more space) not handled intuitively (because of copy constructor). 重新分配（以获得更多空间）没有直观地处理（因为复制构造函数）。</li><li>Whether they call <code>malloc</code> &#x2F; <code>free</code> is implementation defined. 他们是否调用<code>malloc</code>&#x2F;<code>free</code>是由实现来定义的。</li><li>Can add a new memory allocator to deal with low memory (<code>std::set_new_handler</code>).</li><li><code>operator new</code> &#x2F; <code>operator delete</code> can be overridden legally.</li><li><strong>Constructor &#x2F; destructor used to initialize &#x2F; destroy the object.  构造函数&#x2F;析构函数用于初始化&#x2F;销毁对象。</strong></li></ol></li></ul><h3 id="malloc-free"><a href="#malloc-free" class="headerlink" title="malloc &#x2F; free"></a>malloc &#x2F; free</h3><ul><li>Allocate &#x2F; release memory<ol><li>Memory allocated from ‘Heap’.</li><li>Returns a <code>void*</code>.</li><li>Returns <code>NULL</code> on failure.</li><li>Must specify the size required in bytes. 必须以字节为单位指定所需的大小。</li><li>Allocating array requires manual calculation of space. 分配数组需要手动计算空间。</li><li>Reallocating larger chunk of memory simple (no copy constructor to worry about). 重新分配更大的内存块很简单（无需担心复制构造函数）。</li><li>They will <strong>NOT</strong> call <code>new</code> &#x2F; <code>delete</code>.</li><li>No way to splice user code into the allocation sequence to help with low memory. 无法将用户代码拼接到分配序列中以帮助解决内存不足的问题。</li><li><code>malloc</code> &#x2F; <code>free</code> can <strong>NOT</strong> be overridden legally.</li></ol></li></ul><h3 id="Table-comparison-of-the-features"><a href="#Table-comparison-of-the-features" class="headerlink" title="Table comparison of the features:"></a>Table comparison of the features:</h3><table><thead><tr><th align="left">Feature</th><th align="left"><code>new</code> &#x2F; <code>delete</code></th><th align="left"><code>malloc</code> &#x2F; <code>free</code></th></tr></thead><tbody><tr><td align="left">Memory allocated from</td><td align="left">‘Free Store’</td><td align="left">‘Heap’</td></tr><tr><td align="left">Returns</td><td align="left">Fully typed pointer</td><td align="left"><code>void*</code></td></tr><tr><td align="left">On failure</td><td align="left">Throws (never returns <code>NULL</code>)</td><td align="left">Returns <code>NULL</code></td></tr><tr><td align="left">Required size</td><td align="left">Calculated by compiler</td><td align="left">Must be specified in bytes<br/>必须以字节为单位指定</td></tr><tr><td align="left">Handling arrays<br>处理数组</td><td align="left">Has an explicit version</td><td align="left">Requires manual calculations</td></tr><tr><td align="left">Reallocating<br>重新分配</td><td align="left">Not handled intuitively</td><td align="left">Simple (no copy constructor)</td></tr><tr><td align="left">Call of reverse</td><td align="left">Implementation defined</td><td align="left">No</td></tr><tr><td align="left">Low memory cases</td><td align="left">Can add a new memory allocator<br>可以添加新的内存分配器</td><td align="left">Not handled by user code<br>不由用户代码处理</td></tr><tr><td align="left">Overridable</td><td align="left">Yes</td><td align="left">No</td></tr><tr><td align="left">Use of constructor &#x2F; destructor<br>构造函数&#x2F;析构函数的使用</td><td align="left">Yes</td><td align="left">No</td></tr><tr><td align="left">Type</td><td align="left">运算符</td><td align="left">函数</td></tr></tbody></table><p>Technically, memory allocated by <code>new</code> comes from the ‘Free Store’ while memory allocated by <code>malloc</code> comes from the ‘Heap’. Whether these two areas are the same is an implementation detail, which is another reason that <code>malloc</code> and <code>new</code> cannot be mixed. 从技术上讲，分配的内存<code>new</code>来自“免费存储”，而分配的内存<code>malloc</code>来自“堆”。这两个区域是否相同是一个实现细节，这是另一个<code>malloc</code>不能<code>new</code>混为一谈的原因。</p><ul><li><p>最相关的区别是<code>new</code>运算符分配内存然后调用<strong>构造函数</strong>，<code>delete</code>调用<strong>析构函数</strong>然后释放内存。</p><ul><li>严格来说，new 操作符只是分配内存。是 new 表达式调用 new 运算符，然后在分配的内存中运行构造函数。</li></ul></li><li><p><code>new</code>调用对象的ctor，<code>delete</code>调用dtor。</p><p><code>malloc</code>&amp;<code>free</code>只是分配和释放原始内存。</p></li></ul><h2 id="复合字面量（Compound-Literals）"><a href="#复合字面量（Compound-Literals）" class="headerlink" title="复合字面量（Compound Literals）"></a>复合字面量（Compound Literals）</h2><p>字面量是<strong>除了符号常量之外的常量</strong>。</p><p>如，1是int型字面量，3.14是float型字面量，’C’是char型字面量，’Yudao’是字符串字面量。</p><p>那么，数组和结构体是否也能有字面量来表示呢？</p><p>因此，C99标准委员会就新增了复合字面量(compound literals)。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><blockquote><p>  ( type-name ) { initializer-list }</p><p>  ( type-name ) { initializer-list , }</p></blockquote><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><blockquote><p>  The type name shall specify an object type or an array of unknown size, but not a variable length array type.<br>  type name指定了数组类型或结构体类型，数组长度不能是可变的。</p><p>  No initializer shall attempt to provide a value for an object not contained within the entire unnamed object specified by the compound literal.<br>  匿名”对象”的初始化必须在在复合字面量的大括号中。</p><p>  If the compound literal occurs outside the body of a function, the initializer list shall consist of constant expressions.<br>  如果复合字面量是文件作用域，initializer list的表达式必须是常量表达式。</p></blockquote><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>例如下面是一个普通的数组声明。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">int</span> age[<span class="hljs-number">2</span>]=[<span class="hljs-number">19</span>,<span class="hljs-number">20</span>];<br></code></pre></td></tr></table></figure><p>下面创建了一个和age数组相同的匿名数组，也有两个int类型值</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">(<span class="hljs-built_in">int</span> [<span class="hljs-number">2</span>])&#123;<span class="hljs-number">19</span>,<span class="hljs-number">20</span>&#125;; <span class="hljs-comment">//内含2个元素的复合字面量</span><br></code></pre></td></tr></table></figure><p>注意去掉申明中的数组名，留下的<code>int[2]</code>就是复合字面量的类型名。</p><p>因为复合字面量是匿名的，所以不能先创建然后再使用它，必须在创建的同时使用它。</p><p><strong>一般需要这样定义使用：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 简单用法       ***</span><br><span class="hljs-type">int</span> *pt1;<br>pt1=(<span class="hljs-type">int</span>[<span class="hljs-number">2</span>])&#123;<span class="hljs-number">19</span>,<span class="hljs-number">20</span>&#125;;<br><br><span class="hljs-comment">// 对于多维数组   ***</span><br><span class="hljs-type">int</span> (*pt2)[<span class="hljs-number">4</span>];<br><span class="hljs-comment">//申明一个指向二维数组的指针，该数组内有2个数组元素</span><br><span class="hljs-comment">//每个元素是内含4个int类型值的数组</span><br>pt2 = (<span class="hljs-type">int</span> [<span class="hljs-number">2</span>][<span class="hljs-number">4</span>]) &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,&#125;,&#123;<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,&#125;&#125;;<br><br><span class="hljs-comment">// 对于结构体     ***</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">foo</span> &#123;</span><br>  <span class="hljs-type">int</span> a; <br>  <span class="hljs-type">char</span> b[<span class="hljs-number">2</span>];<br>&#125; structure;<br>structure = ((<span class="hljs-keyword">struct</span> foo) &#123;<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;a&#x27;</span>&#125;);<br></code></pre></td></tr></table></figure><p>一些应用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> AV_FOURCC_MAX_STRING_SIZE 32</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> av_fourcc2str(fourcc) av_fourcc_make_string((char[AV_FOURCC_MAX_STRING_SIZE])&#123;0&#125;, fourcc)</span><br><br><span class="hljs-type">char</span> *<span class="hljs-title function_">av_fourcc_make_string</span><span class="hljs-params">(<span class="hljs-type">char</span> *buf, <span class="hljs-type">uint32_t</span> fourcc)</span><br><br><span class="hljs-type">uint32_t</span> type = <span class="hljs-number">1024</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, av_fourcc2str(type));<br><br><span class="hljs-comment">// 匿名构建了一块内存地址 (char[AV_FOURCC_MAX_STRING_SIZE])&#123;0&#125; </span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-type">void</span>* data;<br><span class="hljs-type">int</span>   length;<br>&#125; Array;<br><span class="hljs-type">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">(Array* arr)</span> &#123; &#125;<br><br><span class="hljs-comment">// 曾经的写法</span><br><span class="hljs-type">int</span>   data[]  = &#123; <span class="hljs-number">1</span> &#125;;<br>Array arr [<span class="hljs-number">1</span>] = &#123;data, <span class="hljs-number">1</span>&#125;;<br>foo(arr);<br><br><span class="hljs-comment">// 现在的写法</span><br>foo( (Array[]) &#123; (<span class="hljs-type">int</span>[]) &#123; <span class="hljs-number">1</span> &#125;, <span class="hljs-number">1</span> &#125; );<br></code></pre></td></tr></table></figure><h2 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h2><h1 id="STM32相关"><a href="#STM32相关" class="headerlink" title="STM32相关"></a>STM32相关</h1><h2 id="ADC-与-通道映射关系"><a href="#ADC-与-通道映射关系" class="headerlink" title="ADC 与 通道映射关系"></a>ADC 与 通道映射关系</h2><p><img src="/2018/ef667962/ADC%E9%80%9A%E9%81%93%E4%B8%8E%E5%BC%95%E8%84%9A%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB.png" alt="ADC通道与引脚对应关系"></p><h2 id="Printf第一个字符丢失"><a href="#Printf第一个字符丢失" class="headerlink" title="Printf第一个字符丢失"></a>Printf第一个字符丢失</h2><ul><li>将发送放在等待标志位后面即可解决问题</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">&#123;<br><span class="hljs-comment">/* Loop until the end of transmission */</span><br><span class="hljs-keyword">while</span> (USART_GetFlagStatus(USART2, USART_FLAG_TC) == RESET);<br><br><span class="hljs-comment">/* Place your implementation of fputc here */</span><br><span class="hljs-comment">/* e.g. write a character to the USART */</span><br>USART_SendData(USART2, (<span class="hljs-type">uint8_t</span>) ch);<br><br><span class="hljs-keyword">return</span> ch;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="通用TIM-PWM输出低电平"><a href="#通用TIM-PWM输出低电平" class="headerlink" title="通用TIM PWM输出低电平"></a>通用TIM PWM输出低电平</h2><p>调用 TIM_CCxCmd 关闭输出使能即可<strong>持续输出低电平</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">TIM_CCxCmd</span><span class="hljs-params">(TIM_TypeDef* TIMx, <span class="hljs-type">uint16_t</span> TIM_Channel, <span class="hljs-type">uint16_t</span> TIM_CCx)</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>CCxE位</th><th>OCx输出状态</th></tr></thead><tbody><tr><td>0</td><td>禁止输出(OCx&#x3D;0，OCx_EN&#x3D;0)</td></tr><tr><td>1</td><td>OCx &#x3D; OCxREF + 极性，OCx_EN&#x3D;1</td></tr></tbody></table><h2 id="杂乱笔记"><a href="#杂乱笔记" class="headerlink" title="杂乱笔记"></a>杂乱笔记</h2><ul><li><p>仿真建议使用SWD模式(使用的线少)         emmm。。。。？</p></li><li><p>KEY_UP高电有效（可用于唤醒）、KEY0、KEY1低电有效</p></li><li><p><strong>编译器会默认把没有赋值的变量自动赋值为0（真的是这样吗？，局部变量呢？答复:局部变量不会被初始化,请一定注意要去手动进行初始化）</strong></p></li><li><p><strong>NTC (Negative Temperature Coefficient 负温度系数)      PTC (Positive 正温度系数)</strong></p></li><li><p>RTC (实时时钟)</p></li><li><p>APB1和APB2的区别,<br>APB1操作速度限于36MHz,上面连接的是低速外设,包括 TIM234567、WWDG、SPI2、SPI3、USART23、UART45、CAN12、PWRPower interface clock、 BKP、 DAC、I2C12、等，<strong>具体请参考7.3.8章节APB1外设使能寄存器</strong><br>APB2操作速度全速,上面连接的是高速外设,包括 UART1 、SPI1、Timer1、ADC1、ADC2、所有普通 IO 口(PA-PE)(PA-PE)(PA-PE)(PA-PE)(PA-PE)(PA-PE) 、第二功能IO 口 、<strong>具体请参考7.3.7章节APB2外设使能寄存器</strong></p></li><li><p>原子提供的delay_ms 最大是1864ms不能超过这个值</p></li><li><p>volatile 简单地说就是防止编译器对代码进行优化。</p></li><li><p>enum 枚举类型</p></li><li><p><strong>SysTick     LOAD 转载到 VAL 需要时钟周期所以计算 LOAD 时需要-1</strong></p></li><li><p><strong>PA13 PA14 PA15 PB3 PB4 上电默认是SWD+JTAG模式所以这些GPIO口不能直接使用可调用 GPIO_PinRemapConfig 函数修改</strong></p></li><li><p>DAC要将对应的IO设置成模拟输入！！！</p></li><li><p>USART1 时钟脉冲来源   PCLK2     USART2-4来源   PCLK1</p></li><li><p><strong>使用USART不需要使能AFIO    （发生重映射才需要进行打开AFIO参考CSDN）</strong></p></li><li><p>0,1,2,3,4 各有自己的中断函数        5-9共用一个中断函数    10-15共用一个中断函数</p></li><li><p><strong>u8 temp <em>attribute</em>((at (地址)));&#x2F;&#x2F;需要定义为全局变量—-定义变量到指定地址</strong></p></li><li><p>容量</p><p>4表示16KB （小容量ld）<br>6表示32KB （小容量ld）<br>8表示64KB （中容量md）<br>B表示128KB （中容量md）<br>C表示256KB （大容量hd）<br>E表示512KB （大容量hd）<br>F表示768KB （超大容量xl）<br>G表示1024KB （超大容量xl）</p></li><li><p>ADC输入范围：VREF- ≤  VIN  ≤  VREF+</p></li><li><p>在扫描模式下，由ADC_SQRx或者ADC_JSQRx寄存器选中的通道被转换。如果设置了EOCIE或者JEOCIE，在最后一个通道转换完毕后才会产生EOC或者JEOC中断。</p></li><li><p>ADC ADC1通道17 测得的是内部参考电压(根据数据手册中的数据，这个参照电压的典型值是1.20V，最小值是1.16V，最大值是1.24V)，!!!不是ADC的参考电压Vref+!!!</p></li><li><p>系统滴答定时器</p><p>SysTick-&gt;CTRL        类似控制及状态位寄存器<br>SysTick-&gt;LOAD   到时间自动重装的重装载寄存器<br>SysTick-&gt;VAL      当前数值寄存器<br>SysTick-&gt;CALIB      校准数值寄存器（暂时没有用到）</p></li></ul><h1 id="RTOS相关"><a href="#RTOS相关" class="headerlink" title="RTOS相关"></a>RTOS相关</h1><h2 id="进程-线程-协程"><a href="#进程-线程-协程" class="headerlink" title="进程 线程 协程"></a>进程 线程 协程</h2><p>参考：<a href="https://www.cnblogs.com/Survivalist/p/11527949.html">一文读懂什么是进程、线程、协程</a></p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><blockquote><p>  <strong>进程的概念</strong></p><p>  进程 – 是现代操作系统的一个基本概念，是并发程序出现后出现的一个重要概念，它是指 程序在一个数据集合上运行的过程，是系统进行资源分配和调度运行的一个独立单位，有时 也称为活动、路径或任务。</p></blockquote><ul><li>资源分配的最小单位(拥有独立的地址空间，同一个进程内的线程共享进程地址空间)</li><li>进程是程序执行的实例</li><li><strong>我的理解是在windows里面每一个程序启动都会有一个进程的存在，这个进程会有一个虚拟的地址空间。</strong>（而在STM32一类芯片内是没有虚拟地址空间的，如果跑了RTOS，系统所调度的其实是<strong>进程的子项线程</strong>）</li></ul><blockquote><p>  我们都知道计算机的核心是CPU，它承担了所有的计算任务；而操作系统是计算机的管理者，它负责任务的调度、资源的分配和管理，统领整个计算机硬件；应用程序则是具有某种功能的程序，程序是运行于操作系统之上的。</p><p>    进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。进程是一种抽象的概念，从来没有统一的标准定义。</p><p>  进程一般由程序、数据集合和进程控制块三部分组成。</p><ul><li>程序用于描述进程要完成的功能，是控制进程执行的指令集；</li><li>数据集合是程序在执行时所需要的数据和工作区；</li><li>程序控制块(Program Control Block，简称PCB)，包含进程的描述信息和控制信息，是进程存在的唯一标志。</li></ul><p>  进程具有的特征：</p><ul><li><strong>动态性：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的；</strong></li><li>并发性：任何进程都可以同其他进程一起并发执行；</li><li>独立性：进程是系统进行资源分配和调度的一个独立单位；</li><li>结构性：进程由程序、数据和进程控制块三部分组成。</li></ul></blockquote><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><blockquote><p>  <strong>线程的概念</strong></p><p>  线程– <strong>是进程中的一个实体,是被系统调度和分配的基本单元</strong>。 每个程序至少包含一个线 程，那就是主线程。 线程自己只拥有很少的系统资源（如程序计数器、一组寄存器和栈）， 但它可与同属一个进程的其他线程共享所属进程所拥有的全部资源，同一进程中的多个线程 之间可以并发执行，从而更好地改善了系统资源的利用率。</p></blockquote><ul><li>程序执行的最小单位</li><li>CPU调度最小单位，一个进程并发多个线程</li></ul><blockquote><p>  线程是程序执行流的最小单元，是处理器调度和分派的基本单位。一个<strong>进程</strong>可以有一个或多个<strong>线程</strong>，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。</p><p>  一个标准的<strong>线程</strong>由线程ID、当前指令指针(PC)、寄存器和堆栈组成。</p><p>  而<strong>进程</strong>由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成。</p><p>  <img src="/2018/ef667962/process.png" alt="image"></p><p>  如上图，在任务管理器的进程一栏里，有道词典和有道云笔记就是<strong>进程</strong>，而在进程下又有着多个执行不同任务的<strong>线程</strong>。</p></blockquote><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><ul><li>它是基于线程的，一个线程内有多个协程</li><li>由程序员自行管理的更加轻量的线程</li></ul><blockquote><h2 id="协程-1"><a href="#协程-1" class="headerlink" title="协程"></a>协程</h2><p>  协程，英文Coroutines，是一种基于线程之上，但又比线程更加轻量级的存在，这种由程序员自己写程序来管理的轻量级线程叫做『用户空间线程』，具有对内核来说不可见的特性。</p><p>  因为是自主开辟的异步任务，所以很多人也更喜欢叫它们纤程（Fiber），或者绿色线程（GreenThread）。正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。</p><p>  <img src="/2018/ef667962/6765e36cc4604fba897976638af03524.jpeg" alt="image"></p><h2 id="协程的目的"><a href="#协程的目的" class="headerlink" title="协程的目的"></a>协程的目的</h2><p>  在传统的J2EE系统中都是基于每个请求占用一个线程去完成完整的业务逻辑（包括事务）。所以系统的吞吐能力取决于每个线程的操作耗时。如果遇到很耗时的I&#x2F;O行为，则整个系统的吞吐立刻下降，因为这个时候线程一直处于阻塞状态，如果线程很多的时候，会存在很多线程处于空闲状态（等待该线程执行完才能执行），造成了资源应用不彻底。</p><p>  最常见的例子就是JDBC（它是同步阻塞的），这也是为什么很多人都说数据库是瓶颈的原因。这里的耗时其实是让CPU一直在等待I&#x2F;O返回，说白了线程根本没有利用CPU去做运算，而是处于空转状态。而另外过多的线程，也会带来更多的ContextSwitch开销。</p><p>  对于上述问题，现阶段行业里的比较流行的解决方案之一就是单线程加上异步回调。其代表派是node.js以及Java里的新秀Vert.x。</p><p>  而协程的目的就是当出现长时间的I&#x2F;O操作时，通过让出目前的协程调度，执行下一个任务的方式，来消除ContextSwitch上的开销。</p><h2 id="协程的特点"><a href="#协程的特点" class="headerlink" title="协程的特点"></a>协程的特点</h2><ol><li>线程的切换由操作系统负责调度，协程由用户自己进行调度，因此减少了上下文切换，提高了效率。</li><li>线程的默认Stack大小是1M，而协程更轻量，接近1K。因此可以在相同的内存中开启更多的协程。</li><li>由于在同一个线程上，因此可以避免竞争关系而使用锁。</li><li>适用于被阻塞的，且需要大量并发的场景。但不适用于大量计算的多线程，遇到此种情况，更好实用线程去解决。</li></ol></blockquote><h3 id="进程和线程关系"><a href="#进程和线程关系" class="headerlink" title="进程和线程关系"></a>进程和线程关系</h3><ul><li>资源分配给进程，同一进程内的所有线程共享该进程的所有资源；</li><li>同一个进程的线程之间可以直接交流；两个进程想通信，必须通过一个中间代理来实现；</li><li>处理机分配给线程，即真正在处理机上运行的是线程；</li><li><strong>线程共享内存空间；进程的内存是独立的；</strong></li><li>系统开销：在创建和撤销进程的时候，系统都要分配和回收资源，导致系统的明显大于创建和撤销线程时的开销。但进程有独立的地址空间，进程崩溃后，在保护模式的下不会对其他进程造成影响，而线程只是进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有独立的地址空间，一个线程死后就等于整个进程死掉，所以多进程程序要比多线程程序健壮，但是在进程切换的时候消耗的资源较大，效率差。</li><li><strong>多线程执行效率高; 多进程耗资源，安全。</strong></li></ul><h2 id="互斥量和信号量的区别"><a href="#互斥量和信号量的区别" class="headerlink" title="互斥量和信号量的区别"></a>互斥量和信号量的区别</h2><p><strong>1. 互斥量用于线程的互斥，信号量用于线程的同步。</strong></p><p>这是互斥量和信号量的根本区别，也就是互斥和同步之间的区别。</p><p>互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。</p><p>同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源</p><p><strong>2. 互斥量值只能为0&#x2F;1，信号量值可以为非负整数。</strong></p><p>也就是说，一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题。信号量可以实现多个同类资源的多线程互斥和同步。当信号量为单值信号量是，也可以完成一个资源的互斥访问。</p><p><strong>3. 互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。</strong></p><h1 id="外设"><a href="#外设" class="headerlink" title="外设"></a>外设</h1><h2 id="I2C"><a href="#I2C" class="headerlink" title="I2C"></a>I2C</h2><p>I2C，也称为 <strong>I2C</strong> 或 <strong>IIC</strong>，是飞利浦半导体于 1982 年发明的<strong>同步</strong>、<strong>多主&#x2F;多从</strong>（控制器&#x2F;目标）、<strong>分组交换</strong>、<strong>单端</strong>串行<strong>通信</strong>总线。</p><p>I2C仅使用两条双向<a href="https://en.wikipedia.org/wiki/Open-collector">集电极开</a>路或<a href="https://en.wikipedia.org/wiki/Open-drain">漏极开</a>路线路：串行数据线（SDA）和串行时钟线（SCL），由<a href="https://en.wikipedia.org/wiki/Resistor">电阻</a><a href="https://en.wikipedia.org/wiki/Pull-up_resistor">上拉</a>。使用的典型电压为+5 V或+3.3 V，但允许使用其他电压的系统。</p><p>I2C从机地址有7位、8位、10位不同的地址空间，一般来说7位比较常见。</p><p>I²C的参考设计使用一个7比特长度的<a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E5%9D%80%E7%A9%BA%E9%96%93">地址空间</a>但保留了16个地址，所以在一组总线最多可和112个节点通信[<a href="https://zh.wikipedia.org/zh-cn/I%C2%B2C#cite_note-3">a]</a>。在7位寻址过程中，从机地址在启动信号后的第一个字节开始传输，该字节的前7位为从机地址，第8位为读写位，其中0表示写，1表示读。</p><p>虽然最大的节点数目是被地址空间所限制住，但实际上也会被总线上的总<a href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E5%AE%B9">电容</a>所限制住，一般而言为400 pF。</p><p><img src="/2018/ef667962/I2C_data_transfer.svg" alt="Data transfer sequence"></p><blockquote><p>  <strong>参考上面的图像我们可以看到，</strong></p><p>  START：</p><ul><li>在SCL信号为 <strong>高</strong> 的时候，SDA由 <strong>高</strong> 变 <strong>低</strong> 是START信号。</li><li>（助记，SCL的高电平状态下SDA不允许变化，除非是start信号或者stop信号。空闲状态SCL和SDA都是高电平，start和stop都是由SDA产生的信号）</li></ul><p>  DATA TRANSMISSION：在数据传输阶段，</p><ul><li>蓝色阶段：SCL被拉低，此时SDA变成特定电平。</li><li>绿色阶段：SCL被拉 <strong>高</strong> (图中B1)，SDA的电平不允许变化。<em>数据在SCL的 <strong>上升沿</strong> 进行采样。</em></li></ul><p>  STOP：</p><ul><li>在SCL信号为H的时候，SDA由L变H是STOP信号。</li></ul></blockquote><h3 id="通信速率"><a href="#通信速率" class="headerlink" title="通信速率"></a>通信速率</h3><p><strong>双向通信速度（模式）：</strong></p><p><em>允许任意低的时钟频率</em></p><p>10 kbit&#x2F;s：低速模式</p><p>100 kbit&#x2F;s：标准模式，Standard-mode (Sm)；</p><p>400 kbit&#x2F;s：快速模式，Fast-mode (Fm)；</p><p>1 Mbit&#x2F;s：快速模式+，Fast-mode Plus (Fm+)；</p><p>3.4Mbit&#x2F;s：高速模式，High-speed mode (Hs-mode)；</p><p><strong>单向通信速度（模式）：</strong></p><p>5 Mbit&#x2F;s：超快模式，UItra Fast-mode (UFm)。</p><h2 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h2><p>串行外设接口（SPI）是一种<strong>同步串行</strong>通信规范，主要用于嵌入式系统，用于芯片（电子设备）之间的短距离有线通信。摩托罗拉在 1980 年代中期开发了该规范，该规范已成为具有许多变体的事实标准。</p><p>SPI有四个逻辑信号</p><ul><li>SCLK : Serial Clock (clock signal from main)</li><li>MOSI : Main Out Sub In (data output from main)</li><li>MISO : Main In Sub Out (data output from sub)</li><li>CS : Chip Select (<strong>active low signal</strong> from main to address devices and initiate transmission　从主设备到寻址设备并启动传输的低电平有效信号)</li></ul><p><strong>一对一SPI</strong></p><blockquote><p>  <img src="/2018/ef667962/SPI_basic_operation,_single_Main_&_Sub.svg.png" alt="SPI_basic_operation,_single_Main_&amp;_Sub.svg"></p><p>  使用单个主器件和单个子器件的基本 SPI 配置。每个器件在内部使用<a href="https://en.wikipedia.org/wiki/Shift_register">移位寄存</a>器进行串行通信，它们共同构成一个片间<a href="https://en.wikipedia.org/wiki/Circular_buffer">循环缓冲器</a>。</p></blockquote><p><strong>多点SPI</strong></p><blockquote><p>  Multidrop SPI bus (多点SPI总线)</p><p>  <img src="/2018/ef667962/SPI_main_sub_multidrop.svg.png" alt="SPI_main_sub_multidrop.svg"></p><p>  Daisy-chained SPI (菊花链式 SPI)</p><p>  <img src="/2018/ef667962/SPI_main_sub_daisychain.svg.png" alt="SPI_main_sub_daisychain.svg"></p></blockquote><p>优缺点</p><blockquote><p>  　<strong>优势</strong></p><ul><li>此协议默认全双工通信</li><li><a href="https://en.wikipedia.org/wiki/Push-pull_output">推挽式驱动器</a>（与漏极开路相反）提供良好的信号完整性和高速度</li><li><a href="https://en.wikipedia.org/wiki/Throughput">吞吐量高于</a> <a href="https://en.wikipedia.org/wiki/I%C2%B2C">I²C</a> 或 <a href="https://en.wikipedia.org/wiki/System_Management_Bus">SMBus</a>。不限于任何最大时钟速度，可实现高速运行</li><li>传输位的完全协议灵活性<ul><li>不限于 8 位符号</li><li>任意选择消息大小、内容和用途</li></ul></li><li>极其简单的硬件接口<ul><li>由于电路（包括上拉电阻）较少，因此功耗通常低于<a href="https://en.wikipedia.org/wiki/I%C2%B2C">I²C</a>或SMBus</li><li>无仲裁或相关故障模式 - 与 <a href="https://en.wikipedia.org/wiki/CAN-bus">CAN 总线</a>不同</li><li>从机使用主时钟，不需要精密振荡器</li><li>从机不需要唯一的<a href="https://en.wikipedia.org/wiki/Address_space">地址</a> – 与 <a href="https://en.wikipedia.org/wiki/I%C2%B2C">I²C</a> 或 <a href="https://en.wikipedia.org/wiki/GPIB">GPIB</a> 或 <a href="https://en.wikipedia.org/wiki/SCSI">SCSI</a> 不同</li><li>不需要收发器 - 与 <a href="https://en.wikipedia.org/wiki/CAN-bus">CAN 总线</a>不同</li></ul></li><li>IC封装上仅使用4个引脚，比并行接口少得多</li><li>每个器件最多一独特信号（芯片选择）;所有其他信号是共享的</li><li>信号是单向的，便于<a href="https://en.wikipedia.org/wiki/Galvanic_isolation">电气隔离</a></li><li>简单的软件实施</li></ul><p>  <strong>缺点</strong></p><ul><li>即使是三线式SPI，也需要比<a href="https://zh.wikipedia.org/wiki/I%C2%B2C">I²C</a>更多的IC线路</li><li>无带内寻址;共享总线上需要带外芯片选择信号</li><li>子没有硬件<a href="https://en.wikipedia.org/wiki/Flow_control_(data)">流控制</a>（但主可以延迟下一个时钟边沿以降低传输速率）</li><li>不支持动态添加节点（热插拔）<ul><li>没有从机检测机制，主机无法检测是否与从机断开。</li></ul></li><li>通常仅支持一个主设备（取决于设备的硬件实现）</li><li>未定义错误检查协议</li><li>无法进行数据检验，不定义额外的协议时（如CRC）无法保证数据正确性。</li><li>与<a href="https://en.wikipedia.org/wiki/RS-232">RS-232</a>、<a href="https://en.wikipedia.org/wiki/RS-485">RS-485</a>或<a href="https://en.wikipedia.org/wiki/CAN-bus">CAN总线</a>相比，只能处理短距离。（通过使用<a href="https://en.wikipedia.org/wiki/RS-422">RS-422</a>等收发器可以延长其距离。</li><li>信号路径中的光隔离器限制了MISO传输的时钟速度，因为时钟和数据之间增加了延迟</li><li><strong>双通道 SPI(Dual SPI)<strong>、</strong>四通道 SPI(Quad SPI)</strong> 和<strong>三线串行总线</strong>等一些变体是半双工的。</li></ul></blockquote><blockquote><p>  CKPOL (Clock Polarity) &#x3D; CPOL &#x3D; POL &#x3D; Polarity &#x3D; （时钟）极性<br>  CKPHA (Clock Phase)  &#x3D; CPHA &#x3D; PHA &#x3D; Phase &#x3D; （时钟）相位</p><h3 id="CPOL极性"><a href="#CPOL极性" class="headerlink" title="CPOL极性"></a>CPOL极性</h3><p>  先说什么是SCLK时钟的空闲时刻，其就是当SCLK在发送8个bit比特数据之前和之后的状态，于此对应的，SCLK在发送数据的时候，就是正常的工作的时候，有效active的时刻了。其英文精简解释为：Clock Polarity &#x3D; IDLE state of SCK。</p><p>  SPI的CPOL，<span style="color:#29b6f6"><strong>表示当SCLK空闲idle的时候，其电平的值是低电平0还是高电平1</strong></span>：<br>  CPOL&#x3D;0，时钟空闲idle时候的电平是低电平，所以当SCLK有效的时候，就是高电平，就是所谓的active-high；<br>  CPOL&#x3D;1，时钟空闲idle时候的电平是高电平，所以当SCLK有效的时候，就是低电平，就是所谓的active-low；<br>  <img src="/2018/ef667962/231416549884871.gif" alt="img"></p><p>  从上图中可以看出，(CPOL&#x3D;0)的SCK 波形，它有（传输）8 个脉冲，而在脉冲传输前和完成后都保持在【低电平状态】。<br>  此时的状态就是时钟的空闲状态或无效状态，因为此时没有脉冲，也就不会有数据传输。同理得出，（CPOL&#x3D;）1 的图，时钟的空闲状态或无效状态时SCK 是保持【高电平的】。</p><h3 id="CPHA相位"><a href="#CPHA相位" class="headerlink" title="CPHA相位"></a>CPHA相位</h3><p>  首先说明一点，capture strobe &#x3D; latch &#x3D; read &#x3D; sample，都是表示数据采样，数据有效的时刻。<br>  相位，对应着数据采样是在第几个边沿（edge），是第一个边沿还是第二个边沿，0对应着第一个边沿，1对应着第二个边沿。对于：</p><p>  CPHA&#x3D;0，表示第一个边沿：<br>  对于CPOL&#x3D;0，idle时候的是低电平，第一个边沿就是从低变到高，所以是上升沿；<br>  对于CPOL&#x3D;1，idle时候的是高电平，第一个边沿就是从高变到低，所以是下降沿；</p><p>  CPHA&#x3D;1，表示第二个边沿：<br>  对于CPOL&#x3D;0，idle时候的是低电平，第二个边沿就是从高变到低，所以是下降沿；<br>  对于CPOL&#x3D;1，idle时候的是高电平，第一个边沿就是从低变到高，所以是上升沿；</p><p>  <span style="color:#29b6f6"><strong>数据是在SCK的第一个时钟边沿保持稳定【数据被采样捕获】，在下一个边沿改变【SCK 的下降沿数据改变】</strong></span></p><table><thead><tr><th align="center">SPI mode</th><th align="center">Clock polarity (CPOL) 极性</th><th align="center">Clock phase (CPHA) 相位</th><th align="center">Data is shifted out on<br>数据移出</th><th align="center">Data is sampled on<br>数据采样</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">falling SCLK, and when CS activates</td><td align="center">rising SCLK</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">rising SCLK, and when CS activates</td><td align="center">falling SCLK</td></tr><tr><td align="center">2</td><td align="center">1</td><td align="center">0</td><td align="center">falling SCLK</td><td align="center">rising SCLK</td></tr><tr><td align="center">3</td><td align="center">1</td><td align="center">1</td><td align="center">rising SCLK</td><td align="center">falling SCLK</td></tr></tbody></table></blockquote><h3 id="SPI-变种-SingleSPI-DualSPI-QuadSPI-OctoSPI"><a href="#SPI-变种-SingleSPI-DualSPI-QuadSPI-OctoSPI" class="headerlink" title="SPI 变种 SingleSPI DualSPI QuadSPI OctoSPI"></a>SPI 变种 SingleSPI DualSPI QuadSPI OctoSPI</h3><p><strong>Single SPI</strong></p><blockquote><p>  SPI 适用于大多数用例，例如快速原型设计、设备编程和自动化测试。SPI 速度很快，大多数Single SPI串行吞吐率达到 10 Mbps 左右。然而，单条数据线将无法以SPI最快的速度发送数据。 多 I&#x2F;O SPI能够支持单个设备增加吞吐量。</p><p>  SPI 本身是全双工的。<strong>Dual SPI Quad SPI都是半双工</strong>，因为使用 2-4 个引脚来发送和接收。<strong>切换到双 SPI 或四 SPI 是通过在单 SPI 模式下发送命令字节来完成的</strong>。命令字节将在Dual SPI或Quad SPI下请求响应。 </p></blockquote><p><strong>Dual SPI</strong> </p><blockquote><p>   Dual SPI 具有双 I&#x2F;O 接口，与标准串行闪存设备相比，传输速率提高了一倍。MISO 和 MOSI 数据引脚以<strong>半双工</strong>模式运行，每个时钟周期发送两位。MOSI 线变为 IO0，MISO 线变为 IO1。</p></blockquote><p><strong>Quad SPI</strong></p><blockquote><p>  Quad SPI 与 Dual SPI 类似，以<strong>半双工</strong>模式运行，但吞吐量提高了四倍。添加了两条额外的数据线，每个时钟周期传输 4 位。数据线现在为 IO0、IO1、IO2 和 IO3。</p></blockquote><p><strong>Octo SPI</strong></p><blockquote><p>  与 Dual SPI 类似，以<strong>半双工</strong>模式运行，但吞吐量提高了八倍。每个时钟周期传输 8 位。</p></blockquote><h2 id="Camera"><a href="#Camera" class="headerlink" title="Camera"></a>Camera</h2><blockquote><p>  VGA，即分辨率为 640 * 480 的输出模式；<br>  QVGA，即分辨率为 320 * 240 的输出模式；<br>  QQVGA，即分辨率为 160 * 120 的输出模式</p></blockquote><h3 id="SCCB"><a href="#SCCB" class="headerlink" title="SCCB"></a>SCCB</h3><blockquote><p>  SCCB 全称是：Serial Camera Control Bus 即串行摄像头控制总线，是由 OV（OmniVision 的简称）公司定义和发展的三线式串行总线。不过，OV 公司为了减少传感器引脚的封装，现在SCCB 总线大多采用两线式接口总线。</p><p>  SCCB 与 I2C极其相似。</p></blockquote><h2 id="SD卡"><a href="#SD卡" class="headerlink" title="SD卡"></a>SD卡</h2><p><a href="https://en.wikipedia.org/wiki/SD_card">WIki</a></p><blockquote><p>  SD 卡主要有 SD、Mini SD 和 microSD(原名 TF 卡，2004 年正式更名为 Micro SD Card)</p><p>  Mini SD 已经被 microSD 取代，使用得不多。</p></blockquote><p><img src="/2018/ef667962/image-20231017181152917.png" alt="image-20231017181152917"></p><h3 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h3><p><img src="/2018/ef667962/image-20231017175051870.png" alt="image-20231017175051870"></p><h3 id="速度"><a href="#速度" class="headerlink" title="速度"></a>速度</h3><h4 id="Bus-speed"><a href="#Bus-speed" class="headerlink" title="Bus speed"></a>Bus speed</h4><p><img src="/2018/ef667962/image-20231017175127898.png" alt="image-20231017175127898"></p><h4 id="Video-Speed-Class"><a href="#Video-Speed-Class" class="headerlink" title="Video Speed Class"></a>Video Speed Class</h4><p><img src="/2018/ef667962/image-20231017175323166.png" alt="image-20231017175323166"></p><h4 id="Application-Performance-Class"><a href="#Application-Performance-Class" class="headerlink" title="Application Performance Class"></a>Application Performance Class</h4><p><img src="/2018/ef667962/image-20231017175505941.png" alt="image-20231017175505941"></p><h4 id="“×”-Class"><a href="#“×”-Class" class="headerlink" title="“×” Class"></a>“×” Class</h4><p>“×” Class是标准CD-ROM驱动器速度 150 <a href="https://en.wikipedia.org/wiki/KB/s">KB&#x2F;s </a>（大约 1.23 <a href="https://en.wikipedia.org/wiki/Mbit/s">Mbit&#x2F;s</a>）的倍数，由一些卡制造商使用，并因速度等级而被废弃。基本卡传输数据的速度高达 CD-ROM 速度的六倍 (6×)；即 900 kbit&#x2F;s 或 7.37 Mbit&#x2F;s。</p><p>制造商可能会报告<strong>最佳情况的速度</strong>，也可能会报告卡的<strong>最快读取速度</strong>，该速度通常比写入速度更快。</p><p>当卡同时列出 speed class 和 “×” Class时，后者可以被假定为仅读取速度。</p><p><img src="/2018/ef667962/image-20231017180039726.png" alt="image-20231017180039726"></p><h3 id="SDIO-接口"><a href="#SDIO-接口" class="headerlink" title="SDIO 接口"></a>SDIO 接口</h3><h4 id="Pin"><a href="#Pin" class="headerlink" title="Pin"></a>Pin</h4><p><img src="/2018/ef667962/image-20231017184426226.png" alt="image-20231017184426226"></p><h4 id="Reg"><a href="#Reg" class="headerlink" title="Reg"></a>Reg</h4><p><img src="/2018/ef667962/image-20231017184510884.png" alt="image-20231017184510884"></p><h1 id="Instruction-set-architecture-指令集架构"><a href="#Instruction-set-architecture-指令集架构" class="headerlink" title="Instruction set architecture 指令集架构"></a>Instruction set architecture 指令集架构</h1><p>Instruction set architecture(<strong>ISA</strong>)</p><p>一般来说，市场上流通的ISA有两种类型。它们是 RISC 和 CISC 架构。RISC 代表精简指令集计算机(Reduced Instruction Set Computer)，而 CISC 代表复杂指令集计算机(Complex Instruction Set Computer)。</p><p>这两种架构如今都很流行，x86（英特尔和 AMD 处理器）是顶级处理器，而 ARM（高通和联发科处理器）是最流行的 RISC 架构。</p><p>RISC 架构中使用的<strong>较少指令</strong>和其他优化技术使这些类型的处理器使用<strong>更少的功耗</strong>，使其成为智能手机、相机、智能手表和各种物联网设备的理想选择。</p><h2 id="RISC-V"><a href="#RISC-V" class="headerlink" title="RISC-V"></a>RISC-V</h2><p>RISC-V是一种基于RISC的开放标准ISA，任何人都可以使用它来设计自己的芯片，而无需支付许可费。其开源特性允许对 RISC-V ISA 进行进一步修改和扩展，以制造用于特定任务的专用芯片。</p><h2 id="ARM"><a href="#ARM" class="headerlink" title="ARM"></a>ARM</h2><p>ARM 是一种基于 RISC 的闭源 ISA，授权给公司使用其处理器和 SoC。</p><h2 id="x86"><a href="#x86" class="headerlink" title="x86"></a>x86</h2><h1 id="内建函数-builtin"><a href="#内建函数-builtin" class="headerlink" title="内建函数 builtin"></a>内建函数 builtin</h1><p><a href="https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html">Other Built-in Functions Provided by GCC</a></p><p>内建函数的函数命名，通常以 <code>__builtin</code> 开头。这些函数主要在编译器内部使用，主要是为编译器服务的。<br>GCC 还提供了大量内置函数。其中一些是用于处理异常或可变长度参数列表的内部用途，这里不再赘述，因为它们可能会随时更改；我们不建议广泛使用这些函数。<br>其余函数是为了优化目的而提供的。</p><h2 id="builtin-expect"><a href="#builtin-expect" class="headerlink" title="__builtin_expect"></a><code>__builtin_expect</code></h2><p>您可以使用<code>__builtin_expect</code>来为编译器提供分支预测信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 表示大部分情况下 ptr 都不等于 NULL</span><br><span class="hljs-keyword">if</span> (__builtin_expect (ptr != <span class="hljs-literal">NULL</span>, <span class="hljs-number">1</span>))<br>  foo (*ptr);<br></code></pre></td></tr></table></figure><h2 id="builtin-bswap32-64"><a href="#builtin-bswap32-64" class="headerlink" title="__builtin_bswap32 64"></a><code>__builtin_bswap32 64</code></h2><p>— 内置函数：int32_t <strong>__builtin_bswap32</strong> ( int32_t x )  </p><blockquote><p>返回按字节顺序反转的 x<code>0xaabbccdd</code> ；例如，变为<code>0xddccbbaa</code>。此处的字节始终表示正好 8 位。</p></blockquote><p>— 内置函数：int64_t <strong>__builtin_bswap64</strong> ( int64_t x )  </p><blockquote><p>与 类似<code>__builtin_bswap32</code>，只是参数和返回类型是 64 位。</p></blockquote><h2 id="builtin-return-address"><a href="#builtin-return-address" class="headerlink" title="__builtin_return_address"></a><code>__builtin_return_address</code></h2><p>获取当前函数调用的返回地址。这个函数通常用于调试和分析程序的调用栈。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 函数原型</span><br><span class="hljs-type">void</span> *__builtin_return_address(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> level);<br></code></pre></td></tr></table></figure><ul><li><code>level</code> 参数是一个无符号整型值，表示调用栈的深度。<ul><li><code>level</code> 为 0 时，返回当前函数的返回地址；</li><li><code>level</code> 为 1 时，返回调用当前函数的函数的返回地址；</li><li>以此类推。</li></ul></li></ul><h2 id="builtin-frame-address"><a href="#builtin-frame-address" class="headerlink" title="__builtin_frame_address"></a><code>__builtin_frame_address</code></h2><p>在函数调用过程中，还有一个“栈帧”的概念。函数每调用一次，都会将当前函数的现场（返回地址、寄存器等）保存在栈中，每一层函数调用都会将各自的现场信息都保存在各自的栈中。<br>这个栈也就是当前函数的栈帧，每一个栈帧有起始地址和结束地址，表示当前函数的堆栈信息。多层函数调用就会有多个栈帧，每个栈帧里会保存上一层栈帧的起始地址，这样各个栈帧就形成了一个调用链。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *__builtin_frame_address(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> level);<br></code></pre></td></tr></table></figure><ul><li><code>level</code> 参数是一个无符号整型值，表示调用栈的深度。<ul><li><code>level</code> 为 0 时，返回当前函数的返回地址；</li><li><code>level</code> 为 1 时，返回调用当前函数的函数的返回地址；</li><li>以此类推。</li></ul></li></ul><h1 id="嵌入式高效位算法"><a href="#嵌入式高效位算法" class="headerlink" title="嵌入式高效位算法"></a>嵌入式高效位算法</h1><p>参考资料：</p><p><a href="http://aggregate.org/MAGIC/#Bit%20Reversal">The Aggregate Magic Algorithms</a></p><p><a href="http://graphics.stanford.edu/~seander/bithacks.html">Bit Twiddling Hacks</a></p><p>WORDBITS:数据宽度</p><h2 id="位逆序"><a href="#位逆序" class="headerlink" title="位逆序"></a>位逆序</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>在整数x中反转位有点痛苦，但这里有一个32位值的SWAR算法: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-keyword">register</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> x)</span><br>&#123;<br>x = (((x &amp; <span class="hljs-number">0xaaaaaaaa</span>) &gt;&gt; <span class="hljs-number">1</span>) | ((x &amp; <span class="hljs-number">0x55555555</span>) &lt;&lt; <span class="hljs-number">1</span>));<br>x = (((x &amp; <span class="hljs-number">0xcccccccc</span>) &gt;&gt; <span class="hljs-number">2</span>) | ((x &amp; <span class="hljs-number">0x33333333</span>) &lt;&lt; <span class="hljs-number">2</span>));<br>x = (((x &amp; <span class="hljs-number">0xf0f0f0f0</span>) &gt;&gt; <span class="hljs-number">4</span>) | ((x &amp; <span class="hljs-number">0x0f0f0f0f</span>) &lt;&lt; <span class="hljs-number">4</span>));<br>x = (((x &amp; <span class="hljs-number">0xff00ff00</span>) &gt;&gt; <span class="hljs-number">8</span>) | ((x &amp; <span class="hljs-number">0x00ff00ff</span>) &lt;&lt; <span class="hljs-number">8</span>));<br><span class="hljs-keyword">return</span>((x &gt;&gt; <span class="hljs-number">16</span>) | (x &lt;&lt; <span class="hljs-number">16</span>));<br><br>&#125;<br></code></pre></td></tr></table></figure><p> 也可以重写这个算法，使用4个而不是8个常量，从而节省一些指令带宽。在我的1.2GHz Athlon(雷鸟)上，这种差别太小了，无法可靠地测量。下面是另一个版本: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-keyword">register</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> x)</span><br>&#123;<br>        <span class="hljs-keyword">register</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> y = <span class="hljs-number">0x55555555</span>;<br>        x = (((x &gt;&gt; <span class="hljs-number">1</span>) &amp; y) | ((x &amp; y) &lt;&lt; <span class="hljs-number">1</span>));<br>        y = <span class="hljs-number">0x33333333</span>;<br>        x = (((x &gt;&gt; <span class="hljs-number">2</span>) &amp; y) | ((x &amp; y) &lt;&lt; <span class="hljs-number">2</span>));<br>        y = <span class="hljs-number">0x0f0f0f0f</span>;<br>        x = (((x &gt;&gt; <span class="hljs-number">4</span>) &amp; y) | ((x &amp; y) &lt;&lt; <span class="hljs-number">4</span>));<br>        y = <span class="hljs-number">0x00ff00ff</span>;<br>        x = (((x &gt;&gt; <span class="hljs-number">8</span>) &amp; y) | ((x &amp; y) &lt;&lt; <span class="hljs-number">8</span>));<br>        <span class="hljs-keyword">return</span>((x &gt;&gt; <span class="hljs-number">16</span>) | (x &lt;&lt; <span class="hljs-number">16</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8位查表"><a href="#8位查表" class="headerlink" title="8位查表"></a>8位查表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">private Byte  <span class="hljs-title function_">BitReverse</span><span class="hljs-params">(Byte bData)</span><br>&#123;<br>    Byte[] lookup = &#123; <span class="hljs-number">0</span>, <span class="hljs-number">8</span>,  <span class="hljs-number">4</span>, <span class="hljs-number">12</span>, <br>                     <span class="hljs-number">2</span>, <span class="hljs-number">10</span>, <span class="hljs-number">6</span>, <span class="hljs-number">14</span> , <br>                     <span class="hljs-number">1</span>, <span class="hljs-number">9</span>,  <span class="hljs-number">5</span>, <span class="hljs-number">13</span>,<br>                     <span class="hljs-number">3</span>, <span class="hljs-number">11</span>, <span class="hljs-number">7</span>, <span class="hljs-number">15</span> &#125;;<br>    Byte ret_val = (Byte)(((lookup[(bData &amp; <span class="hljs-number">0x0F</span>)]) &lt;&lt; <span class="hljs-number">4</span>) + lookup[((bData &amp; <span class="hljs-number">0xF0</span>) &gt;&gt; <span class="hljs-number">4</span>)]);<br>    <span class="hljs-keyword">return</span> ret_val;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="16位查表"><a href="#16位查表" class="headerlink" title="16位查表"></a>16位查表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> BitReverseTable256[] = <br>&#123;<br>  <span class="hljs-number">0x00</span>, <span class="hljs-number">0x80</span>, <span class="hljs-number">0x40</span>, <span class="hljs-number">0xC0</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0xA0</span>, <span class="hljs-number">0x60</span>, <span class="hljs-number">0xE0</span>, <span class="hljs-number">0x10</span>, <span class="hljs-number">0x90</span>, <span class="hljs-number">0x50</span>, <span class="hljs-number">0xD0</span>, <span class="hljs-number">0x30</span>, <span class="hljs-number">0xB0</span>, <span class="hljs-number">0x70</span>, <span class="hljs-number">0xF0</span>, <br>  <span class="hljs-number">0x08</span>, <span class="hljs-number">0x88</span>, <span class="hljs-number">0x48</span>, <span class="hljs-number">0xC8</span>, <span class="hljs-number">0x28</span>, <span class="hljs-number">0xA8</span>, <span class="hljs-number">0x68</span>, <span class="hljs-number">0xE8</span>, <span class="hljs-number">0x18</span>, <span class="hljs-number">0x98</span>, <span class="hljs-number">0x58</span>, <span class="hljs-number">0xD8</span>, <span class="hljs-number">0x38</span>, <span class="hljs-number">0xB8</span>, <span class="hljs-number">0x78</span>, <span class="hljs-number">0xF8</span>, <br>  <span class="hljs-number">0x04</span>, <span class="hljs-number">0x84</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0xC4</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0xA4</span>, <span class="hljs-number">0x64</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x14</span>, <span class="hljs-number">0x94</span>, <span class="hljs-number">0x54</span>, <span class="hljs-number">0xD4</span>, <span class="hljs-number">0x34</span>, <span class="hljs-number">0xB4</span>, <span class="hljs-number">0x74</span>, <span class="hljs-number">0xF4</span>, <br>  <span class="hljs-number">0x0C</span>, <span class="hljs-number">0x8C</span>, <span class="hljs-number">0x4C</span>, <span class="hljs-number">0xCC</span>, <span class="hljs-number">0x2C</span>, <span class="hljs-number">0xAC</span>, <span class="hljs-number">0x6C</span>, <span class="hljs-number">0xEC</span>, <span class="hljs-number">0x1C</span>, <span class="hljs-number">0x9C</span>, <span class="hljs-number">0x5C</span>, <span class="hljs-number">0xDC</span>, <span class="hljs-number">0x3C</span>, <span class="hljs-number">0xBC</span>, <span class="hljs-number">0x7C</span>, <span class="hljs-number">0xFC</span>, <br>  <span class="hljs-number">0x02</span>, <span class="hljs-number">0x82</span>, <span class="hljs-number">0x42</span>, <span class="hljs-number">0xC2</span>, <span class="hljs-number">0x22</span>, <span class="hljs-number">0xA2</span>, <span class="hljs-number">0x62</span>, <span class="hljs-number">0xE2</span>, <span class="hljs-number">0x12</span>, <span class="hljs-number">0x92</span>, <span class="hljs-number">0x52</span>, <span class="hljs-number">0xD2</span>, <span class="hljs-number">0x32</span>, <span class="hljs-number">0xB2</span>, <span class="hljs-number">0x72</span>, <span class="hljs-number">0xF2</span>, <br>  <span class="hljs-number">0x0A</span>, <span class="hljs-number">0x8A</span>, <span class="hljs-number">0x4A</span>, <span class="hljs-number">0xCA</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0xAA</span>, <span class="hljs-number">0x6A</span>, <span class="hljs-number">0xEA</span>, <span class="hljs-number">0x1A</span>, <span class="hljs-number">0x9A</span>, <span class="hljs-number">0x5A</span>, <span class="hljs-number">0xDA</span>, <span class="hljs-number">0x3A</span>, <span class="hljs-number">0xBA</span>, <span class="hljs-number">0x7A</span>, <span class="hljs-number">0xFA</span>,<br>  <span class="hljs-number">0x06</span>, <span class="hljs-number">0x86</span>, <span class="hljs-number">0x46</span>, <span class="hljs-number">0xC6</span>, <span class="hljs-number">0x26</span>, <span class="hljs-number">0xA6</span>, <span class="hljs-number">0x66</span>, <span class="hljs-number">0xE6</span>, <span class="hljs-number">0x16</span>, <span class="hljs-number">0x96</span>, <span class="hljs-number">0x56</span>, <span class="hljs-number">0xD6</span>, <span class="hljs-number">0x36</span>, <span class="hljs-number">0xB6</span>, <span class="hljs-number">0x76</span>, <span class="hljs-number">0xF6</span>, <br>  <span class="hljs-number">0x0E</span>, <span class="hljs-number">0x8E</span>, <span class="hljs-number">0x4E</span>, <span class="hljs-number">0xCE</span>, <span class="hljs-number">0x2E</span>, <span class="hljs-number">0xAE</span>, <span class="hljs-number">0x6E</span>, <span class="hljs-number">0xEE</span>, <span class="hljs-number">0x1E</span>, <span class="hljs-number">0x9E</span>, <span class="hljs-number">0x5E</span>, <span class="hljs-number">0xDE</span>, <span class="hljs-number">0x3E</span>, <span class="hljs-number">0xBE</span>, <span class="hljs-number">0x7E</span>, <span class="hljs-number">0xFE</span>,<br>  <span class="hljs-number">0x01</span>, <span class="hljs-number">0x81</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0xC1</span>, <span class="hljs-number">0x21</span>, <span class="hljs-number">0xA1</span>, <span class="hljs-number">0x61</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x11</span>, <span class="hljs-number">0x91</span>, <span class="hljs-number">0x51</span>, <span class="hljs-number">0xD1</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0xB1</span>, <span class="hljs-number">0x71</span>, <span class="hljs-number">0xF1</span>,<br>  <span class="hljs-number">0x09</span>, <span class="hljs-number">0x89</span>, <span class="hljs-number">0x49</span>, <span class="hljs-number">0xC9</span>, <span class="hljs-number">0x29</span>, <span class="hljs-number">0xA9</span>, <span class="hljs-number">0x69</span>, <span class="hljs-number">0xE9</span>, <span class="hljs-number">0x19</span>, <span class="hljs-number">0x99</span>, <span class="hljs-number">0x59</span>, <span class="hljs-number">0xD9</span>, <span class="hljs-number">0x39</span>, <span class="hljs-number">0xB9</span>, <span class="hljs-number">0x79</span>, <span class="hljs-number">0xF9</span>, <br>  <span class="hljs-number">0x05</span>, <span class="hljs-number">0x85</span>, <span class="hljs-number">0x45</span>, <span class="hljs-number">0xC5</span>, <span class="hljs-number">0x25</span>, <span class="hljs-number">0xA5</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0xE5</span>, <span class="hljs-number">0x15</span>, <span class="hljs-number">0x95</span>, <span class="hljs-number">0x55</span>, <span class="hljs-number">0xD5</span>, <span class="hljs-number">0x35</span>, <span class="hljs-number">0xB5</span>, <span class="hljs-number">0x75</span>, <span class="hljs-number">0xF5</span>,<br>  <span class="hljs-number">0x0D</span>, <span class="hljs-number">0x8D</span>, <span class="hljs-number">0x4D</span>, <span class="hljs-number">0xCD</span>, <span class="hljs-number">0x2D</span>, <span class="hljs-number">0xAD</span>, <span class="hljs-number">0x6D</span>, <span class="hljs-number">0xED</span>, <span class="hljs-number">0x1D</span>, <span class="hljs-number">0x9D</span>, <span class="hljs-number">0x5D</span>, <span class="hljs-number">0xDD</span>, <span class="hljs-number">0x3D</span>, <span class="hljs-number">0xBD</span>, <span class="hljs-number">0x7D</span>, <span class="hljs-number">0xFD</span>,<br>  <span class="hljs-number">0x03</span>, <span class="hljs-number">0x83</span>, <span class="hljs-number">0x43</span>, <span class="hljs-number">0xC3</span>, <span class="hljs-number">0x23</span>, <span class="hljs-number">0xA3</span>, <span class="hljs-number">0x63</span>, <span class="hljs-number">0xE3</span>, <span class="hljs-number">0x13</span>, <span class="hljs-number">0x93</span>, <span class="hljs-number">0x53</span>, <span class="hljs-number">0xD3</span>, <span class="hljs-number">0x33</span>, <span class="hljs-number">0xB3</span>, <span class="hljs-number">0x73</span>, <span class="hljs-number">0xF3</span>, <br>  <span class="hljs-number">0x0B</span>, <span class="hljs-number">0x8B</span>, <span class="hljs-number">0x4B</span>, <span class="hljs-number">0xCB</span>, <span class="hljs-number">0x2B</span>, <span class="hljs-number">0xAB</span>, <span class="hljs-number">0x6B</span>, <span class="hljs-number">0xEB</span>, <span class="hljs-number">0x1B</span>, <span class="hljs-number">0x9B</span>, <span class="hljs-number">0x5B</span>, <span class="hljs-number">0xDB</span>, <span class="hljs-number">0x3B</span>, <span class="hljs-number">0xBB</span>, <span class="hljs-number">0x7B</span>, <span class="hljs-number">0xFB</span>,<br>  <span class="hljs-number">0x07</span>, <span class="hljs-number">0x87</span>, <span class="hljs-number">0x47</span>, <span class="hljs-number">0xC7</span>, <span class="hljs-number">0x27</span>, <span class="hljs-number">0xA7</span>, <span class="hljs-number">0x67</span>, <span class="hljs-number">0xE7</span>, <span class="hljs-number">0x17</span>, <span class="hljs-number">0x97</span>, <span class="hljs-number">0x57</span>, <span class="hljs-number">0xD7</span>, <span class="hljs-number">0x37</span>, <span class="hljs-number">0xB7</span>, <span class="hljs-number">0x77</span>, <span class="hljs-number">0xF7</span>, <br>  <span class="hljs-number">0x0F</span>, <span class="hljs-number">0x8F</span>, <span class="hljs-number">0x4F</span>, <span class="hljs-number">0xCF</span>, <span class="hljs-number">0x2F</span>, <span class="hljs-number">0xAF</span>, <span class="hljs-number">0x6F</span>, <span class="hljs-number">0xEF</span>, <span class="hljs-number">0x1F</span>, <span class="hljs-number">0x9F</span>, <span class="hljs-number">0x5F</span>, <span class="hljs-number">0xDF</span>, <span class="hljs-number">0x3F</span>, <span class="hljs-number">0xBF</span>, <span class="hljs-number">0x7F</span>, <span class="hljs-number">0xFF</span><br>&#125;;<br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v; <span class="hljs-comment">// reverse 32-bit value, 8 bits at time</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> c; <span class="hljs-comment">// c will get v reversed</span><br><br><span class="hljs-comment">// Option 1:</span><br>c = (BitReverseTable256[v &amp; <span class="hljs-number">0xff</span>] &lt;&lt; <span class="hljs-number">24</span>) | <br>    (BitReverseTable256[(v &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>] &lt;&lt; <span class="hljs-number">16</span>) | <br>    (BitReverseTable256[(v &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xff</span>] &lt;&lt; <span class="hljs-number">8</span>) |<br>    (BitReverseTable256[(v &gt;&gt; <span class="hljs-number">24</span>) &amp; <span class="hljs-number">0xff</span>]);<br><br><span class="hljs-comment">// Option 2:</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> * p = (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *) &amp;v;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> * q = (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *) &amp;c;<br>q[<span class="hljs-number">3</span>] = BitReverseTable256[p[<span class="hljs-number">0</span>]]; <br>q[<span class="hljs-number">2</span>] = BitReverseTable256[p[<span class="hljs-number">1</span>]]; <br>q[<span class="hljs-number">1</span>] = BitReverseTable256[p[<span class="hljs-number">2</span>]]; <br>q[<span class="hljs-number">0</span>] = BitReverseTable256[p[<span class="hljs-number">3</span>]];<br></code></pre></td></tr></table></figure><h2 id="整数平均值"><a href="#整数平均值" class="headerlink" title="整数平均值"></a>整数平均值</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">(x+y)/<span class="hljs-number">2</span><span class="hljs-comment">//可能导致溢出 相加溢出</span><br>    <br>(x＆y)+((x ^ y)&gt;&gt; <span class="hljs-number">1</span>)<span class="hljs-comment">//可以改用这种方法</span><br></code></pre></td></tr></table></figure><ul><li><p>原理：</p><p>这实际上是“众所周知”事实的扩展，对于二进制整数值<code>x</code>和<code>y</code>，<code>（x + y）</code> 等于<code>（（x＆y）+（x | y））</code>等于<code>（（x ^ y）+ 2 *（x＆y ））</code>。</p><p>给定两个整数值<code>x</code>和<code>y</code>，平均值的（底数）通常将由<code>（x + y）/ 2计算</code>；不幸的是，由于溢出，这可能会产生错误的结果。一个非常偷偷摸摸的替代方法是使用<code>（x＆y）+（（（x ^ y）/ 2）</code>。如果我们由于C没有指定是否对移位进行签名而意识到潜在的不可移植性，则可以将其简化为<code>（x＆y）+（（x ^ y）&gt;&gt; 1）</code>。无论哪种情况，好处是此代码序列都不会溢出。</p></li></ul><h2 id="整数求最大最小值"><a href="#整数求最大最小值" class="headerlink" title="整数求最大最小值"></a>整数求最大最小值</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">x-(((x-y)&gt;&gt;(WORDBITS<span class="hljs-number">-1</span>))&amp;(x-y))<span class="hljs-comment">//Maximum</span><br>x+(((y-x)&gt;&gt;(WORDBITS<span class="hljs-number">-1</span>))&amp;(y-x))<span class="hljs-comment">//Minimum </span><br></code></pre></td></tr></table></figure><ul><li><p>解释</p><p>WORDBITS是数据宽度（8，16，32，……）</p></li><li><p>原理</p><p>((x-y)&gt;&gt;(WORDBITS-1)) 相当于取出符号位</p><p>当x&gt;y时结果是0</p><p style="color:red"> 注意！ 当x<y时结果是全1，比如WORDBITS是8那么这个式子运算结果是0xFF </p><p style="color:red">注意！ 负数的移位似乎不太一样（当有符号整数右移时，最左边的位的值被复制到其他位）,（ 不幸的是，这种行为是特定于体系结构的）</p></li></ul><p>同样的可以利用这一点应用到其他算法中：<a href="#%E6%95%B4%E6%95%B0%E9%80%89%E6%8B%A9%E8%B5%8B%E5%80%BC">整数选择赋值</a></p><h2 id="整数选择赋值"><a href="#整数选择赋值" class="headerlink" title="整数选择赋值"></a>整数选择赋值</h2> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (a&lt;b) x=c; <span class="hljs-keyword">else</span> x=d; <span class="hljs-comment">//都是整数</span><br><br>x=((((a-b) &gt;&gt; (WORDBITS<span class="hljs-number">-1</span>)) &amp; (c^d)) ^ d) <span class="hljs-comment">//优化后</span><br></code></pre></td></tr></table></figure><ul><li><p>原理</p><p>参考<a href="#%E6%95%B4%E6%95%B0%E6%B1%82%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%80%BC">整数求最大最小值</a></p></li></ul><h2 id="没有临时值，交换值两数据的值"><a href="#没有临时值，交换值两数据的值" class="headerlink" title="没有临时值，交换值两数据的值"></a>没有临时值，交换值两数据的值</h2> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//example 1</span><br>x ^= y; <span class="hljs-comment">/* x&#x27; = (x^y) */</span><br>y ^= x;<span class="hljs-comment">/* y&#x27; = (y^(x^y)) = x */</span><br>x ^= y; <span class="hljs-comment">/* x&#x27; = (x^y)^x = y */</span><br><br><span class="hljs-comment">//example 2</span><br>x += y; <span class="hljs-comment">/* x&#x27; = (x+y) */</span><br>y = x - y;<span class="hljs-comment">/* y&#x27; = (x+y)-y = x */</span><br>x -= y;<span class="hljs-comment">/* x&#x27; = (x+y)-x = y */</span><br></code></pre></td></tr></table></figure><ul><li><p>注意:</p><p>但是当x和y之间的大小有显著差异时，较小的大小的值可能会严重损失准确性。例如，如果x的模比y大得多，那么(x+y)&#x3D;&#x3D;x，最后得到y&#x3D;0。 </p><p>这里如果变量的存储大小很小 还可能会产生溢出 计算出来的数据就会问题了</p></li></ul><h2 id="计算byte内有多少bit置1"><a href="#计算byte内有多少bit置1" class="headerlink" title="计算byte内有多少bit置1"></a>计算byte内有多少bit置1</h2><p>此为 汉明距离 问题</p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>just</p><h3 id="Bit1-Bit0数量相关"><a href="#Bit1-Bit0数量相关" class="headerlink" title="Bit1 Bit0数量相关"></a>Bit1 Bit0数量相关</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//bit 1 较少 0x1000 0000 只需要一次</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">bitcount</span> <span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (n)  &#123;<br>        count++;<br>        n &amp;= (n - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br><span class="hljs-comment">//bit 0 较少 </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">bitcount</span> <span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">8</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>);<br>    n ^= (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>) <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span> (n)<br>    &#123;<br>        count--;<br>        n &amp;= (n - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="查表"><a href="#查表" class="headerlink" title="查表"></a>查表</h3><p>8位查表 4位查表</p><h3 id="合并计数-优"><a href="#合并计数-优" class="headerlink" title="合并计数(优)"></a>合并计数(优)</h3><p>以<code>0x34520</code>为例，<code>b0011 0100 0101 0010 0000</code></p><p>第一步：每2位为一组，组内高低位相加</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tap">RAW |00110100010100100000|<br>H   |0<span class="hljs-number"> 1 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 1 </span>0<span class="hljs-number"> 0 </span>|<br>L   |<span class="hljs-number"> 0 </span>1<span class="hljs-number"> 1 </span>0<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0|<br>-------------------------|<br>H&gt;&gt;1|<span class="hljs-number"> 0 </span>1<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>1<span class="hljs-number"> 0 </span>0|<br>L   |<span class="hljs-number"> 0 </span>1<span class="hljs-number"> 1 </span>0<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0|<br><br><br>  <span class="hljs-number"> 00 </span>01<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 01 </span>01<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>+ <span class="hljs-number"> 00 </span>01<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 00 </span>00<br>= <span class="hljs-number"> 00 </span>10<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 01 </span>01<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 00 </span>00<br></code></pre></td></tr></table></figure><p>第二步：每4位为一组，组内高低位相加</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">RAW</span>  <span class="hljs-number">0010 </span><span class="hljs-number">0100 </span><span class="hljs-number">0101 </span><span class="hljs-number">0001 </span><span class="hljs-number">0000</span><br><span class="hljs-string">H</span>    <span class="hljs-number">00</span>   <span class="hljs-number">01</span>   <span class="hljs-number">01</span>   <span class="hljs-number">00</span>   <span class="hljs-number">00</span>  <br><span class="hljs-string">L</span>      <span class="hljs-number">10</span>   <span class="hljs-number">00</span>   <span class="hljs-number">01</span>   <span class="hljs-number">01</span>   <span class="hljs-number">00</span><br><span class="hljs-string">-----------------------------</span><br><span class="hljs-string">H&gt;&gt;2</span> <span class="hljs-number">0000 </span><span class="hljs-number">0001 </span><span class="hljs-number">0001 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000</span><br><span class="hljs-string">L</span>    <span class="hljs-number">0010 </span><span class="hljs-number">0000 </span><span class="hljs-number">0001 </span><span class="hljs-number">0001 </span><span class="hljs-number">0000</span><br><span class="hljs-string">-----------------------------</span><br><br><span class="hljs-attr">H:</span>   <span class="hljs-number">0000 </span><span class="hljs-number">0001 </span><span class="hljs-number">0001 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000</span><br><span class="hljs-attr">L:</span>   <span class="hljs-number">0010 </span><span class="hljs-number">0000 </span><span class="hljs-number">0001 </span><span class="hljs-number">0001 </span><span class="hljs-number">0000</span><br><span class="hljs-string">=</span>    <span class="hljs-number">0010 </span><span class="hljs-number">0001 </span><span class="hljs-number">0010 </span><span class="hljs-number">0001 </span><span class="hljs-number">0000</span> <br></code></pre></td></tr></table></figure><p>第三步：每8位为一组，组内高低位相加</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dns">RAW <span class="hljs-number">00000010</span> <span class="hljs-number">00010010</span> <span class="hljs-number">00010000</span><br>    <span class="hljs-number">0000</span>     <span class="hljs-number">0001</span>     <span class="hljs-number">0001</span>    <br>        <span class="hljs-number">0010</span>     <span class="hljs-number">0010</span>     <span class="hljs-number">0000</span><br><br>H:  <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span> <span class="hljs-number">00000001</span><br>L:  <span class="hljs-number">00000010</span> <span class="hljs-number">00000010</span> <span class="hljs-number">00000000</span><br>=   <span class="hljs-number">00000010</span> <span class="hljs-number">00000011</span> <span class="hljs-number">00000001</span><br></code></pre></td></tr></table></figure><p>第四步：每16位为一组，组内高低位相加</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">RAW 0000000000000010 0000001100000001<br><span class="hljs-code">    00000000         00000011        </span><br><span class="hljs-code">            00000010         00000001</span><br><span class="hljs-code">    </span><br>H:  0000000000000000 0000000000000011<br>L:  0000000000000010 0000000000000001<br><span class="hljs-section">=   0000000000000010 0000000000000100</span><br></code></pre></td></tr></table></figure><p>第五步：每32位为一组，组内高低位相加</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">RAW 0000000000000010 0000000000000100<br><br><span class="hljs-code">    0000000000000000 0000000000000010</span><br>+   0000000000000000 0000000000000100<br><span class="hljs-section">=   0000000000000000 0000000000000110 = 6 </span><br></code></pre></td></tr></table></figure><p>这样最后得到的00000000 00000111即7即34520二进制中1的个数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-title function_">numbits</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-type">const</span> MASK1  = <span class="hljs-number">0x55555555</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-type">const</span> MASK2  = <span class="hljs-number">0x33333333</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-type">const</span> MASK4  = <span class="hljs-number">0x0f0f0f0f</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-type">const</span> MASK8  = <span class="hljs-number">0x00ff00ff</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-type">const</span> MASK16 = <span class="hljs-number">0x0000ffff</span>;<br>    i = (i&amp;MASK1 ) + (i&gt;&gt;<span class="hljs-number">1</span> &amp;MASK1 );<br>    i = (i&amp;MASK2 ) + (i&gt;&gt;<span class="hljs-number">2</span> &amp;MASK2 );<br>    i = (i&amp;MASK4 ) + (i&gt;&gt;<span class="hljs-number">4</span> &amp;MASK4 );<br>    i = (i&amp;MASK8 ) + (i&gt;&gt;<span class="hljs-number">8</span> &amp;MASK8 );<br>    i = (i&amp;MASK16) + (i&gt;&gt;<span class="hljs-number">16</span>&amp;MASK16);<br><span class="hljs-keyword">return</span> i;<br>&#125;<br><br><span class="hljs-comment">// 另外一种实现</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TWO(c)       (0x1u &lt;&lt; (c))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MASK(c)      (((unsigned int)(-1)) / (TWO(TWO(c)) + 1u))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COUNT(x,c) ((x) &amp; MASK(c)) + (((x) &gt;&gt; (TWO(c))) &amp; MASK(c))</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">bitcount</span> <span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> n)</span><br>&#123;<br>    n = COUNT(n, <span class="hljs-number">0</span>) ;<br>    n = COUNT(n, <span class="hljs-number">1</span>) ;<br>    n = COUNT(n, <span class="hljs-number">2</span>) ;<br>    n = COUNT(n, <span class="hljs-number">3</span>) ;<br>    n = COUNT(n, <span class="hljs-number">4</span>) ;<br>    <span class="hljs-comment">/* n = COUNT(n, 5) ;      for 64-bit integers */</span><br>    <span class="hljs-keyword">return</span> n ;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="builtin-ctz"><a href="#builtin-ctz" class="headerlink" title="__builtin_ctz"></a><code>__builtin_ctz</code></h2><p>这个函数作用是返回输入数二进制表示从<strong>最低位开始(右起)的连续的0的个数</strong>；即 尾随 0 的位数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __builtin_ctz (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> x)<br><span class="hljs-type">int</span> __builtin_ctzl (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)<br><span class="hljs-type">int</span> __builtin_ctzll (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>)<br></code></pre></td></tr></table></figure><h2 id="builtin-clz"><a href="#builtin-clz" class="headerlink" title="__builtin_clz"></a><code>__builtin_clz</code></h2><p>这个函数作用是返回输入数二进制表示从<strong>最高位开始(左起)的连续的0的个数</strong>；即 前导 0 位数</p><h2 id="builtin-ffs"><a href="#builtin-ffs" class="headerlink" title="__builtin_ffs"></a><code>__builtin_ffs</code></h2><p>这个函数作用是返回输入数二进制表示的<strong>最低非0位的下标</strong>，下标从1开始计数；如果传入0则返回0。</p><h2 id="bulitin-popcount"><a href="#bulitin-popcount" class="headerlink" title="__bulitin_popcount"></a><code>__bulitin_popcount</code></h2><p>这个函数作用是返回输入的二进制表示中<strong>1的个数</strong>；如果传入0则返回 0 。</p><h2 id="builtin-parity"><a href="#builtin-parity" class="headerlink" title="__builtin_parity"></a><code>__builtin_parity</code></h2><p>这个函数作用是返回输入的二进制表示中<strong>1的个数的奇偶</strong>,也就是输入的二进制中1的个数对2取模的结果。</p><h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><h2 id="Duff’s-device"><a href="#Duff’s-device" class="headerlink" title="Duff’s device"></a>Duff’s device</h2><blockquote><p>  循环展开尝试通过每次迭代执行一批循环体来减少检查循环是否完成所需的条件分支的开销。</p><p>  为了处理迭代次数不能被展开循环增量整除的情况，汇编语言程序员的常用技术是直接跳转到展开循环体的中间来处理余数。</p><p>  Duff 在 C 中通过使用 C 的case label drop-through功能跳转到展开的正文中来实现此技术。</p><p>  Duff’s device 利用了C语言的一些特性：</p><blockquote><ul><li>case语句后面的break语句不是必须的。</li><li>在switch语句内，case标号可以出现在任意的子语句之前，甚至运行出现在if、for、while等语句内。(在这个设备发明之前，c语言是初版，switch语句的规范较为宽松)</li></ul></blockquote><p>  尽管在 C 语言中有效，<strong>但 Duff 的设备违反了常见的 C 准则</strong>，例如<a href="https://en.wikipedia.org/wiki/MISRA_C">MISRA 准则</a>。某些编译器仅限于此类准则，因此可能会拒绝 Duff 的设备。</p></blockquote><p><strong>C语言示例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span>* to, <span class="hljs-type">uint8_t</span>* from, <span class="hljs-type">uint32_t</span> count)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-type">uint32_t</span> n = (count + <span class="hljs-number">7</span>) &gt;&gt; <span class="hljs-number">3</span>;<br>    <br>    <span class="hljs-keyword">switch</span> (count % <span class="hljs-number">8</span>)<br>    &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-keyword">do</span> &#123; *to = *from++;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:      *to = *from++;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:      *to = *from++;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:      *to = *from++;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:      *to = *from++;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:      *to = *from++;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:      *to = *from++;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:      *to = *from++;<br>            &#125; <span class="hljs-keyword">while</span> (--n &gt; <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>描述语言示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs pdl">send(to, from, count)<br>register short *to, *from;<br>register count;<br>&#123;<br>    register n = (count + 7) / 8;<br>    switch (count % 8) &#123;<br>    case 0: do &#123; *to = *from++;<br>    case 7:      *to = *from++;<br>    case 6:      *to = *from++;<br>    case 5:      *to = *from++;<br>    case 4:      *to = *from++;<br>    case 3:      *to = *from++;<br>    case 2:      *to = *from++;<br>    case 1:      *to = *from++;<br>            &#125; while (--n &gt; 0);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>功能一致的等效展开</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs pdl">send(to, from, count)<br>register short *to, *from;<br>register count;<br>&#123;<br>    register n = (count + 7) / 8;<br>    switch (count % 8) &#123;<br>        case 0: *to = *from++;<br>        case 7: *to = *from++;<br>        case 6: *to = *from++;<br>        case 5: *to = *from++;<br>        case 4: *to = *from++;<br>        case 3: *to = *from++;<br>        case 2: *to = *from++;<br>        case 1: *to = *from++;<br>    &#125;<br>    while (--n &gt; 0) &#123;<br>        *to = *from++;<br>        *to = *from++;<br>        *to = *from++;<br>        *to = *from++;<br>        *to = *from++;<br>        *to = *from++;<br>        *to = *from++;<br>        *to = *from++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="memcpy"><a href="#memcpy" class="headerlink" title="memcpy"></a>memcpy</h2><blockquote><p>  他主要的思路是将文件分块尽量大些，让总线一次读取的数据全部可用。并一次拷贝多个数据，避免if等待。</p><p>  这个程序的性能经过对比可以比直接赋值的情况下高8倍以上，count值较大的情况下。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief  This function will copy memory content from source address to destination address.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param  dst is the address of destination memory, points to the copied content.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param  src  is the address of source memory, pointing to the data source to be copied.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param  count is the copied length.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @return The address of destination memory</span><br><span class="hljs-comment"> */</span><br>rt_weak <span class="hljs-type">void</span> *<span class="hljs-title function_">rt_memcpy</span><span class="hljs-params">(<span class="hljs-type">void</span> *dst, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *src, <span class="hljs-type">rt_ubase_t</span> count)</span><br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNALIGNED(X, Y) \</span><br><span class="hljs-meta">    (((long)X &amp; (sizeof (long) - 1)) | ((long)Y &amp; (sizeof (long) - 1)))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BIGBLOCKSIZE    (sizeof (long) &lt;&lt; 2)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LITTLEBLOCKSIZE (sizeof (long))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TOO_SMALL(LEN)  ((LEN) &lt; BIGBLOCKSIZE)</span><br><br>    <span class="hljs-type">char</span> *dst_ptr = (<span class="hljs-type">char</span> *)dst;<br>    <span class="hljs-type">char</span> *src_ptr = (<span class="hljs-type">char</span> *)src;<br>    <span class="hljs-type">long</span> *aligned_dst = RT_NULL;<br>    <span class="hljs-type">long</span> *aligned_src = RT_NULL;<br>    <span class="hljs-type">rt_ubase_t</span> len = count;<br><br>    <span class="hljs-comment">/* If the size is small, or either SRC or DST is unaligned,</span><br><span class="hljs-comment">    then punt into the byte copy loop.  This should be rare. */</span><br>    <span class="hljs-keyword">if</span> (!TOO_SMALL(len) &amp;&amp; !UNALIGNED(src_ptr, dst_ptr))<br>    &#123;<br>        aligned_dst = (<span class="hljs-type">long</span> *)dst_ptr;<br>        aligned_src = (<span class="hljs-type">long</span> *)src_ptr;<br><br>        <span class="hljs-comment">/* Copy 4X long words at a time if possible. */</span><br>        <span class="hljs-keyword">while</span> (len &gt;= BIGBLOCKSIZE)<br>        &#123;<br>            *aligned_dst++ = *aligned_src++;<br>            *aligned_dst++ = *aligned_src++;<br>            *aligned_dst++ = *aligned_src++;<br>            *aligned_dst++ = *aligned_src++;<br>            len -= BIGBLOCKSIZE;<br>        &#125;<br><br>        <span class="hljs-comment">/* Copy one long word at a time if possible. */</span><br>        <span class="hljs-keyword">while</span> (len &gt;= LITTLEBLOCKSIZE)<br>        &#123;<br>            *aligned_dst++ = *aligned_src++;<br>            len -= LITTLEBLOCKSIZE;<br>        &#125;<br><br>        <span class="hljs-comment">/* Pick up any residual with a byte copier. */</span><br>        dst_ptr = (<span class="hljs-type">char</span> *)aligned_dst;<br>        src_ptr = (<span class="hljs-type">char</span> *)aligned_src;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (len--)<br>        *dst_ptr++ = *src_ptr++;<br><br>    <span class="hljs-keyword">return</span> dst;<br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> UNALIGNED</span><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> BIGBLOCKSIZE</span><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> LITTLEBLOCKSIZE</span><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> TOO_SMALL</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="规范性"><a href="#规范性" class="headerlink" title="规范性"></a>规范性</h1><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><ul><li>common.h作为顶层头文件，主要放置(f10x.h、通用define、通用enum、)，不得包含用户头文件以避免循环依赖。</li><li>#ifndef标识符规范，前面加两个下划线 __COMMON_H</li><li></li></ul><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><table><thead><tr><th>类型</th><th>规则</th><th>详细</th><th>例子</th></tr></thead><tbody><tr><td>全局变量</td><td>前面加 g</td><td></td><td>gRoomHmidity</td></tr><tr><td>指针</td><td>前面加 p</td><td></td><td>pHumidity</td></tr><tr><td>有符号变量</td><td>前面加i</td><td></td><td>iTemperature</td></tr><tr><td>struct函数指针</td><td>前面加f(可选的)</td><td></td><td>fGetVal</td></tr><tr><td>不允许直接访问</td><td>前面加_</td><td></td><td>_DataVal</td></tr><tr><td>enum</td><td>变量前面加 e</td><td></td><td>eFlag</td></tr><tr><td></td><td>值全大写即可</td><td></td><td>ERR_OK</td></tr><tr><td>Typedef</td><td>后面加 _t</td><td></td><td>uint32_t</td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><ul><li>不要使用八进制，误认是十进制。</li><li>Switch default无操作需要得到注释。</li><li>禁止变量未赋值就进行使用。</li><li>如果某常量与其他常量密切相关，在定义中应该明确表示出此关系。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">float</span> RAD=<span class="hljs-number">100</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">float</span> DIAM=RAD*<span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><ul><li><strong>通讯过程中使用的结构,必须注意字节序。</strong></li><li><strong>宏定义中尽量不使用return、goto、continue、break等改变程序流程的语句。</strong></li><li>避免使用危险函数sprintf &#x2F;vsprintf&#x2F;strcpy&#x2F;strcat&#x2F;gets操作字符串<ul><li>用strncpy()代替strcpy()</li><li>用strncat()代替strcat()</li><li>用snprintf()代替sprintf()</li><li>用fgets()代替gets()</li></ul></li><li></li></ul><h1 id="特殊技巧及知识总结"><a href="#特殊技巧及知识总结" class="headerlink" title="特殊技巧及知识总结"></a>特殊技巧及知识总结</h1><ul><li>字符串中可以使用\0OO(八进制)或\xHH(十六进制)来引用ASCII码中的符号。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ascii=\x35\n&quot;</span>);  <span class="hljs-comment">// &quot;ascii=5&quot;</span><br></code></pre></td></tr></table></figure><ul><li>if&#x2F;else结构中尽量把TRUE概念较高的条件放到前面可以提高效率。</li><li>尽量把最有可能FALSE的子表达式放在“&amp;&amp;”的左边，同理尽量把最有可能为TRUE的子表达式放在“||”的左边。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>( p5 &amp;&amp; p95 )<span class="hljs-comment">//第一个不满足就不满足</span><br><span class="hljs-keyword">if</span>( p95 || p5 )<span class="hljs-comment">//第一个满足就满足</span><br></code></pre></td></tr></table></figure><ul><li>对于多维数组来说，”先行后列”的遍历效率会更高，但可能不明显。</li><li>如果某常量与其他常量密切相关，在定义中应该明确表示出此关系。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">float</span> RAD=<span class="hljs-number">100</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">float</span> DIAM=RAD*<span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><ul><li><p>如果输入参数传递的是一个ADT&#x2F;UDT类型的参数（抽象数据类型&#x2F;用户定义数据类型），宜采用 <code>const &amp;</code>的方式来传递以提高效率。而对于int等类型的基本类型的参数没有必要改成 <code>const &amp;</code>传递。指针传递，提高效率。</p></li><li><p>虽然类型名称和<code>*</code>组合是一种指针类型，但是编译器是将<code>*</code>于后面的变量结合的，列如：</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* a,b,c;<br><span class="hljs-comment">//编译器的理解是  a是int*， b、c是int</span><br><span class="hljs-comment">//这也是为什么推荐将*粘着变量的原因</span><br><span class="hljs-type">int</span> *a,b,c;<br></code></pre></td></tr></table></figure><ul><li>多维数组中的指针</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//以下四种表达是等价的</span><br><span class="hljs-comment">// i是指行，j是指列</span><br><span class="hljs-comment">// a[i][j]里面 *(a+i) 就等价于 a[i]</span><br>a[i][j]<br>*(a[i]+j)<br>(*(a+i))[j]<br>*(*(a+i)+j)<br></code></pre></td></tr></table></figure><ul><li><span style="color:red">字符数组</span>是保存字符变量的数组，而<span style="color:red">字符串</span>是以<code>\0</code>结尾的字符数组。</li><li>malloc&#x2F;free和new&#x2F;delete，这两者的区别主要有。new&#x2F;delete是C++里的，更高级，更安全，返回的是有类型的指针，出错会抛出异常。</li><li>中断内不能使用除法<ul><li>中断内有些指令需要较多的周期才能完成，它们是除法指令，双字传送指令LDRD&#x2F;STRD以及多<br>重数据传送指令(LDM&#x2F;STM)。对于前两者，CM3将为了保证中断及时响应而取消它们的执行。也就是中断内无法完成<strong>除法指令</strong>！！！</li></ul></li><li>调试模式如果单步调试，会屏蔽各种中断，定时器，IWDG都无法进行，而且定时器仍然在计数但是不会响应中断。</li></ul><h2 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">switch</span> (tx_semaphore_get(tx_semaphore, convert_ms_to_ticks(timeout)))<br>&#123;<br>    <span class="hljs-keyword">case</span> TX_SUCCESS:<br>        result = FFW_SUCCESS;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> TX_NO_INSTANCE:<br>        result = FFW_TIMEOUT;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> TX_SEMAPHORE_ERROR:<br>        result = FFW_INVALID_ARGUMENT;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        result = FFW_FAILURE;<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-comment">// convert_ms_to_ticks 这样做会更加通用</span><br></code></pre></td></tr></table></figure><h1 id="BUG-翻车集锦"><a href="#BUG-翻车集锦" class="headerlink" title="BUG 翻车集锦"></a>BUG 翻车集锦</h1><ul><li><p>TIM捕获触发DMA传输，但是在调试模式下DMA传出来的数据有问题。</p><p>把DMA出来的的数据再复制一份，复制出来的数据是没有问题的。</p><p>分析可能是，DEBUG下CPU停了，但是DMA总线还在跑，外设可能也是还在运行的，导致看起来DMA出来的数据有问题。</p></li><li><p>ADC矫正会发生ADC转换，如果有DMA配合使用，需要注意DMA需要在ADC矫正后使能。</p></li><li><p>隐式转换  小范围会转换成大范围  有一点特殊的是   unsigned int &gt; int</p></li><li><p>运算符优先级！位运算符优先级较低</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//编译报错</span><br>(DS18B20_DQ_IN != <span class="hljs-number">0</span>)? data_temp |= <span class="hljs-number">0x80</span>:data_temp&amp;=<span class="hljs-number">0x7f</span>;<br><span class="hljs-comment">//规范写法</span><br>(DS18B20_DQ_IN!=<span class="hljs-number">0</span>)? (data_temp|=<span class="hljs-number">0x80</span>):(data_temp&amp;=<span class="hljs-number">0x7f</span>);<br></code></pre></td></tr></table></figure><ul><li>运算符优先级！！！极注意！！！  请小心有位运算时打上括号            &lt;&lt;  比  +-  要低</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">u16 temp;<br>u8 h,l;<br>temp = (u16)(h&lt;&lt;<span class="hljs-number">8</span>) + l;<span class="hljs-comment">// 正确语法</span><br>temp = h&lt;&lt;<span class="hljs-number">8</span> + l;<span class="hljs-comment">// 错误语法！！！！！</span><br></code></pre></td></tr></table></figure><ul><li><p><code>0b110</code> 这种二进制写法似乎只有在GNU模式才被允许。</p></li><li><p>STM32的看门狗是使得RST引脚拉低，来复位的。所以要注意复位电容的选择，太大会导致软件无法复位。</p></li><li><p><code>代码段内 \ 换行后不能接 /* xxx */ 注释，注释需要些在 \ 的前面，如 /* xxx */ \ 这样才行</code></p></li><li><p>printf 内字符串问题</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta"># <span class="hljs-keyword">define</span> DC_LOG_ERROR    <span class="hljs-string">&quot;\x11&quot;</span></span><br><br><span class="hljs-comment">// 没有逗号 这是正常想要表达的逻辑, 前面的DC_LOG_ERROR 和 &quot;%s:%d check SID Stasrt&quot; 合并成一个表达式</span><br><span class="hljs-built_in">printf</span>(DC_LOG_ERROR  <span class="hljs-string">&quot;%s:%d check SID Stasrt&quot;</span>,__func__, __LINE__);<br><span class="hljs-comment">// 有逗号 只会识别前面一个字符串 后面的都没了</span><br><span class="hljs-built_in">printf</span>(DC_LOG_ERROR, <span class="hljs-string">&quot;%s:%d check SID Stasrt&quot;</span>,__func__, __LINE__);<br></code></pre></td></tr></table></figure></li></ul><ul><li>在 RSIC-V 的一个系统里面，系统会异常死机，报HardFault，报各种不一样的异常，排查后发现是32.768KHz的晶振所致，甚是奇怪！<ul><li>系统异常一定要优先检查 系统各大件是否运行正常 <strong>SoC、Flash、晶振(主晶振、RTC晶振)、当然还有最重要的电源</strong></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>embedded</category>
      
    </categories>
    
    
    <tags>
      
      <tag>embedded</tag>
      
      <tag>note</tag>
      
      <tag>stm32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CC2530</title>
    <link href="/2018/8d6db935/"/>
    <url>/2018/8d6db935/</url>
    
    <content type="html"><![CDATA[<blockquote><p>CC2530是针对IEEE 802.15.4，Zigbee和RF4CE应用的真正片上系统（SoC）解决方案。 它能够以非常低的总物料成本构建强大的网络节点。 CC2530将领先的射频收发器的卓越性能与业界标准增强型8051 MCU，系统内可编程闪存，8 KB RAM以及许多其他强大功能相结合。 CC2530有四种不同的闪存版本：分别为CC2530F32 &#x2F; 64&#x2F;128&#x2F;256对应32&#x2F;64&#x2F;128&#x2F;256 KB的闪存。 CC2530具有多种工作模式，非常适合需要超低功耗的系统。 运行模式之间的短暂转换时间进一步确保了低能耗。</p><p>•CC2530是TI公司推出的用来实现嵌入式ZigBee应用的低功耗片上系统。</p><p>•在单个芯片上整合了ZigBee 射频(RF)前端、内存和微控制器。</p><p>•8 位MCU（增强型、标准8051指令集）。</p><p>•256 KB Flash和8 KB 的RAM，内部16MHz RC 和 32kHz RC 振荡器。</p><p>•8路12位ADC；18个中断源；4个Timer；硬件支持的AES128 ；WDT(1.9ms-1s)；32 kHz晶振的休眠模式定时器、POR(上电复位)、BOD(掉电检测)，以及21 个通用I&#x2F;O 。</p></blockquote><h1 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><img src="/2018/8d6db935/20180211202707601.png" alt="img"></p><p>I &#x2F; O端口具有以下主要功能：</p><ul><li>21个数字通用输入&#x2F;输出引脚</li><li>通用I &#x2F; O或外设I &#x2F; O</li><li>输入上拉或下拉功能</li><li>外部中断功能</li></ul><blockquote><p>所有21个I &#x2F; O引脚都具有外部中断功能。 因此，如果需要，外部设备可能会产生中断。 外部中断功能也可用于将器件从睡眠模式（电源模式PM1，PM2和PM3）中唤醒</p></blockquote><blockquote><p>通用IO：共21个，分成3组，<strong>P0组、P1组、P2组</strong>，其中P0\P1组各8个IO，P2组5个（P2_0、P2_1、 P2_2、P2_3、 P2_4）。其中P1_0、P1_1有20mA的输出驱动能力，其余的只有4mA。</p></blockquote><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><ol><li><p>GPIO<strong>功能</strong>选择寄存器——<strong>PxSEL</strong></p><p> 寄存器PxSEL（其中x是端口号0-2）用于将端口中的每个引脚配置为<strong>通用I&#x2F;O引脚</strong>或<strong>外设I&#x2F;O引脚</strong>，可位寻址。 默认情况下，复位后，所有数字输入&#x2F;输出引脚都配置为<strong>通用上拉输入引脚</strong>。</p><blockquote><p>其中，P2SEL只有第0位至第2位是端口2的功能选择控制位，第3位至第6位是端口1的外设优先级控制位。</p></blockquote></li></ol><ul><li>0&#x3D;通用</li><li>1&#x3D;外设I&#x2F;O</li></ul><ol><li><p>GPIO<strong>输入输出方向</strong>选择寄存器——<strong>PxDIR</strong></p><p>寄存器PxDIR用于将每个端口的引脚方向设置为<strong>输入方向</strong>或<strong>输出方向</strong>。 因此，将PxDIR中的相应位设置为1，相应的引脚就变成输出方向，可位寻址。复位后为<strong>输入引脚</strong>。</p><blockquote><p>其中，P2DIR只有第0位至第4位是端口2的方向选择控制位，第6位和第7位是端口0外设优先级控制位。</p></blockquote></li></ol><ul><li><p>0&#x3D;输入</p></li><li><p>1&#x3D;输出</p></li></ul><ol start="2"><li><p>GPIO<strong>输入模式</strong>寄存器——<strong>PxINP</strong></p><p>寄存器PxINP用于设置IO端口的<strong>输入模式</strong>，通用I &#x2F; O端口引脚可配置为具有<strong>上拉</strong>，<strong>下拉</strong>或<strong>三态</strong>操作模式。 默认情况下，复位后，输入配置为带有上拉的输入。如果要取消输入端口的上拉或下拉功能，必须将PxINP中的相应位设置为1。</p><ul><li>请注意，即使IO端口是外设功能输入，配置为外设I &#x2F; O信号的引脚也不具有上拉或下拉功能。</li></ul><blockquote><p>其中，P2INP中，第0位至第4位是端口2的输入模式选择位</p><p><strong>第5位至第7位是端口0、端口1、端口2的上下拉选择位。</strong></p><ul><li>0&#x3D;PullUp</li><li>1&#x3D;PullDown</li></ul></blockquote></li></ol><ul><li>0&#x3D;上拉或下拉</li><li>1&#x3D;三态</li></ul><h1 id="Z-Stack"><a href="#Z-Stack" class="headerlink" title="Z-Stack"></a>Z-Stack</h1><h2 id="创建一个任务-Create-Task"><a href="#创建一个任务-Create-Task" class="headerlink" title="创建一个任务 Create Task"></a>创建一个任务 Create Task</h2><ul><li>&#x2F;&#x2F; 任务列表<br>const pTaskEventHandlerFn tasksArr[] &#x3D; {…..}</li><li>&#x2F;&#x2F; 初始化任务<br>void osalInitTasks( void )<br>{…..}</li><li>&#x2F;&#x2F; 任务处理函数<br>uint16 Hello_ProcessEvent(uint8 task_id, uint16 events)<br>{…}</li></ul><h2 id="HAL库之LED"><a href="#HAL库之LED" class="headerlink" title="HAL库之LED"></a>HAL库之LED</h2><ol><li>uint8 HalLedSet (uint8 leds, uint8 mode)</li></ol><table><thead><tr><th>ModeName</th><th>作用</th></tr></thead><tbody><tr><td>HAL_LED_MODE_BLINK</td><td>闪烁  (一次)</td></tr><tr><td>HAL_LED_MODE_FLASH</td><td>闪烁</td></tr><tr><td>HAL_LED_MODE_ON</td><td></td></tr><tr><td>HAL_LED_MODE_OFF</td><td></td></tr><tr><td>HAL_LED_MODE_TOGGLE</td><td>触发</td></tr></tbody></table><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><ol><li><p>uint8 osal_start_timerEx( uint8 taskID, uint16 event_id, uint16 timeout_value )</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//为指定的任务设置定时器</span><br><br>osal_start_timerEx(task_id, <span class="hljs-number">0x0001</span>, <span class="hljs-number">10000</span>);<br></code></pre></td></tr></table></figure></li><li></li></ol><h2 id="PAN-ID"><a href="#PAN-ID" class="headerlink" title="PAN_ID"></a>PAN_ID</h2><ul><li><p>全称 Personal Area Network (网络标识符)</p></li><li><p>相当于网络号，网段。</p></li></ul><p>Tools\f8Config.cfgLine59</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Define the default PAN ID.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Setting this to a value other than 0xFFFF causes</span><br><span class="hljs-comment"> * ZDO_COORD to use this value as its PAN ID and</span><br><span class="hljs-comment"> * Routers and end devices to join PAN with this ID</span><br><span class="hljs-comment"> */</span><br>-DZDAPP_CONFIG_PAN_ID=<span class="hljs-number">0x0010</span><br></code></pre></td></tr></table></figure><h2 id="Z-Stack开发步骤"><a href="#Z-Stack开发步骤" class="headerlink" title="Z-Stack开发步骤"></a>Z-Stack开发步骤</h2><h3 id="功能类型定义"><a href="#功能类型定义" class="headerlink" title="功能类型定义"></a>功能类型定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 功能类型值定义</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    DevTemp = <span class="hljs-number">1</span>,<br>    DevHumm,<br><span class="hljs-comment">//略---------------------</span><br>    DevMaxNum<br>&#125;;<br></code></pre></td></tr></table></figure><p>枚举功能类型值，需要时添加即可。</p><h3 id="定义节点功能列表"><a href="#定义节点功能列表" class="headerlink" title="定义节点功能列表"></a>定义节点功能列表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/***************************************************/</span><br><span class="hljs-comment">/* 节点功能列表                                    */</span><br><span class="hljs-comment">/***************************************************/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ep_info_t</span> <span class="hljs-title">funcList</span>[] =</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(HAS_GAS)</span><br>    &#123;<br>        <span class="hljs-comment">//stat,income,timeout,resource</span><br>        <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, sensorGasTimeout, sensorGasResAvailable,<br>        &#123; DevGas, <span class="hljs-number">0</span>, <span class="hljs-number">3</span> &#125;,                   <span class="hljs-comment">// type, id, refresh cycle</span><br>    &#125;,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-comment">//略----------------</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(ZDO_COORDINATOR)</span><br>    &#123;   <span class="hljs-comment">// 协调器</span><br>        CoordinatorNwkStateChangeRoutine,<br>        CoordinatorIncomingRoutine,<br>        CoordinatorTimeoutRoutine,<br>        CoordinatorResAvailableRoutine,<br>        &#123; DevCoordinator, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;,<br>    &#125;,<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(RTR_NWK)</span><br>    &#123;   <span class="hljs-comment">// 路由器</span><br>        RouterNwkStateChangeRoutine,<br>        RouterIncomingRoutine,<br>        RouterTimeoutRoutine,<br>        RouterResAvailableRoutine,<br>        &#123; DevRouter, <span class="hljs-number">0</span>, <span class="hljs-number">30</span> &#125;,<br>    &#125;,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p>功能列表</p></li><li><p>参考下面的 <strong>ep_info_t</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 不能修改下面的内容!!!</span><br><span class="hljs-type">const</span> uint8 funcCount = <span class="hljs-keyword">sizeof</span>(funcList) / <span class="hljs-keyword">sizeof</span>(funcList[<span class="hljs-number">0</span>]);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><br></code></pre></td></tr></table></figure></li><li><p>功能数量</p></li><li></li></ul><h3 id="ep-info-t"><a href="#ep-info-t" class="headerlink" title="ep_info_t"></a>ep_info_t</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ep_info_t</span> &#123;</span><br>    <span class="hljs-comment">// 网络状态发生变化时会调用该函数</span><br>    <span class="hljs-type">void</span> (*nwk_stat_change)(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep);<br>    <span class="hljs-comment">// 接收到数据时会调用该函数</span><br>    <span class="hljs-type">void</span> (*incoming_data)(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg);<br>    <span class="hljs-comment">// 周期性调用的函数</span><br>    <span class="hljs-type">void</span> (*time_out)(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep);<br>    <span class="hljs-comment">// 系统资源可用时调用该函数,系统资源指的是:串口接收到数据/中断等等</span><br>    <span class="hljs-type">void</span> (*res_available)(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep, RES_TYPE type, <span class="hljs-type">void</span> *res);<br>    <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> cycle成员会被用来计数,并周期性调用time_out函数</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">func_info_t</span> <span class="hljs-title">function</span>;</span><br>    <br><span class="hljs-comment">//以下数据用户不能进行更改！！！！！</span><br>    <br>    <span class="hljs-comment">// 当前端点号</span><br>    uint8 ep;<br>    <span class="hljs-comment">// 与此端点绑定的任务ID</span><br>    uint8 task_id;<br>    <span class="hljs-comment">// 递减计数,为0时调用time_out函数,并重载初值=cycle</span><br>    uint8 timerTick;<br>    uint8 userTimer;<br>    endPointDesc_t SampleApp_epDesc;<br>    SimpleDescriptionFormat_t simpleDesc;<br>&#125;;<br><br><span class="hljs-comment">//一个典型的初始化</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(ZDO_COORDINATOR)</span><br>    &#123;   <span class="hljs-comment">// 协调器</span><br>        CoordinatorNwkStateChangeRoutine,<span class="hljs-comment">//节点加入网络完成后调用</span><br>        CoordinatorIncomingRoutine,<span class="hljs-comment">//端点接收到数据后会调用</span><br>        CoordinatorTimeoutRoutine,<span class="hljs-comment">//周期调用</span><br>        CoordinatorResAvailableRoutine,<span class="hljs-comment">//系统初始化、串口收到数据、用户定时器到时 会调用</span><br>        &#123; DevCoordinator, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;,<span class="hljs-comment">//功能类型、功能编号、刷新周期</span><br>    &#125;,<br><br></code></pre></td></tr></table></figure><h4 id="nwk-stat-change"><a href="#nwk-stat-change" class="headerlink" title="nwk_stat_change"></a>nwk_stat_change</h4><p><strong>节点加入网络完成后调用</strong></p><ul><li>可用于读取当前  端点  信息</li><li></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">xxNwkStateChange</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep)</span><br>    <br><span class="hljs-type">void</span> <span class="hljs-title function_">sensorVoiceNwkStateChange</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep)</span><br>&#123;<br>    voiceEndPoint = ep;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="incoming-data"><a href="#incoming-data" class="headerlink" title="incoming_data"></a>incoming_data</h4><p><strong>端点接收到数据后会调用</strong></p><ul><li>下发的指令的处理</li><li></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">xxReceiveData</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg)</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">testReceiveData</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg)</span><br>&#123;<br>    <span class="hljs-comment">//msg-&gt;Data[0] 是接受到的总  比特   数 </span><br><span class="hljs-keyword">if</span>( (msg-&gt;Data[<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;L&#x27;</span>)&amp;&amp;(msg-&gt;Data[<span class="hljs-number">2</span>]==<span class="hljs-string">&#x27;E&#x27;</span>)&amp;&amp;(msg-&gt;Data[<span class="hljs-number">3</span>]==<span class="hljs-string">&#x27;D&#x27;</span>) )<br>    &#123;<br><span class="hljs-keyword">if</span>( msg-&gt;Data[<span class="hljs-number">4</span>]==<span class="hljs-string">&#x27;1&#x27;</span> )<br>&#123;<br>HalUARTWrite(HAL_UART_PORT_0, <span class="hljs-string">&quot;LED_1\r\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;LED_1\r\n&quot;</span>) - <span class="hljs-number">1</span>);<br><span class="hljs-comment">//HalLedBlink(HAL_LED_1, 2, 50, 100);</span><br>&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="time-out"><a href="#time-out" class="headerlink" title="time_out"></a>time_out</h4><p><strong>周期调用</strong></p><ul><li>读取传感器数据</li><li></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">xxTimeout</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep)</span><br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">sensorFireTimeout</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep)</span><br>&#123;<br>    uint8 value = FireInfo();<br>    SendData(ep-&gt;ep, &amp;value, <span class="hljs-number">0x0000</span>, TRANSFER_ENDPOINT, <span class="hljs-keyword">sizeof</span>(value));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="res-available"><a href="#res-available" class="headerlink" title="res_available"></a>res_available</h4><p><strong>系统初始化、串口收到数据、用户定时器到时 会调用</strong></p><ul><li>初始化端口、</li><li></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">xxResAvailable</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep, RES_TYPE type, <span class="hljs-type">void</span> *res)</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">sensorRainResAvailable</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep, RES_TYPE type, <span class="hljs-type">void</span> *res)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(type == ResInit)<br>    &#123;<br>        RainInit();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="IAR学习笔记"><a href="#IAR学习笔记" class="headerlink" title="IAR学习笔记"></a>IAR学习笔记</h1><h2 id="无法观察局部变量"><a href="#无法观察局部变量" class="headerlink" title="无法观察局部变量"></a>无法观察局部变量</h2><p>在软件调试的时候发现Watch窗口中无法观察局部变量的值，总是显示<unavailable><br>　　设置IAR中的”<strong>Options — c&#x2F;c++ compiler — Optimization — Level</strong>“ 选项：<br>　　Level的缺省值为Low，当我把Level选为None之后，即不执行任何优化时，全局变量、静态局部变量、局部变量的值都可以看到。</p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>embedded</tag>
      
      <tag>cc2530</tag>
      
      <tag>zigbee</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

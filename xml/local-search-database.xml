<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>PowerShell</title>
    <link href="/2022/a2c49dae/"/>
    <url>/2022/a2c49dae/</url>
    
    <content type="html"><![CDATA[<h1 id="PowerShell"><a href="#PowerShell" class="headerlink" title="PowerShell"></a>PowerShell</h1><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><h2 id="PowerShell-Oh-My-Posh-美化"><a href="#PowerShell-Oh-My-Posh-美化" class="headerlink" title="PowerShell + Oh My Posh 美化"></a>PowerShell + Oh My Posh 美化</h2><p><a href="https://www.edgeless.top/PowerShell%E7%BE%8E%E5%8C%96/">参考 PowerShell美化</a></p><h2 id="PowerShell-获取当前文件夹名称-仅获取当前文件夹名"><a href="#PowerShell-获取当前文件夹名称-仅获取当前文件夹名" class="headerlink" title="PowerShell 获取当前文件夹名称 仅获取当前文件夹名"></a>PowerShell 获取当前文件夹名称 仅获取当前文件夹名</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">(<span class="hljs-built_in">get-item</span> .).name<br></code></pre></td></tr></table></figure><h2 id="Powershell获取当前时间"><a href="#Powershell获取当前时间" class="headerlink" title="Powershell获取当前时间"></a>Powershell获取当前时间</h2><p><a href="http://www.splaybow.com/post/powershell-get-date.html">参考 PowerShell使用Get-Date获取日期和时间</a></p><p>在PowerShell中直接调用<code>Get-Date</code>，可以返回当前的日期和时间，包括年、月、日、时、分、秒。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">PS</span> &gt; <span class="hljs-built_in">Get-Date</span><br><span class="hljs-number">2022</span>年<span class="hljs-number">12</span>月<span class="hljs-number">19</span>日 <span class="hljs-number">21</span>:<span class="hljs-number">32</span>:<span class="hljs-number">28</span><br></code></pre></td></tr></table></figure><p>使用<code>-Format</code>参数来获取<code>Get-Date</code>中的年、月、日、时、分、秒。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs txt">yyyy 年<br>M    月<br>d    日<br>h    小时（12小时制）<br>H    小时（24小时制）<br>m    分钟<br>s    秒<br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">PS</span> &gt; <span class="hljs-built_in">Get-Date</span> <span class="hljs-literal">-Format</span> HH:mm:ss<br><span class="hljs-number">21</span>:<span class="hljs-number">34</span>:<span class="hljs-number">11</span><br></code></pre></td></tr></table></figure><h2 id="Powershell-ANSI颜色"><a href="#Powershell-ANSI颜色" class="headerlink" title="Powershell ANSI颜色"></a>Powershell ANSI颜色</h2><p><a href="https://juejin.cn/post/6920241597846126599">参考: 了解 ANSI 转义码的 color 设置</a></p><blockquote><p>  To use one of the ANSI escape codes, we need a literal <a href="https://en.wikipedia.org/wiki/Escape_character#ASCII_escape_character">ESC character</a>. This is octal 033, or decimal 27. In Bash, you would use <code>&quot;\033&quot;</code> or <code>&quot;\e&quot;</code>; There’s no direct equivalent sequence in PowerShell but you can instead embed an expression: <code>&quot;$([char]27)&quot;</code></p><p>  PowerShell 中没有直接等效的序列，但您可以改为嵌入一个表达式：<code>&quot;$([char]27)&quot;</code>，也就是说要将<code>\e</code>修改为<code>$([char]27)</code></p><p>  例如<code>\e[32;1m text \e[0m</code> 修改为 <code>$([char]27)[32;1m text $([char]27)[0m</code></p></blockquote><p><strong>ANSI Escape code编码中有专门控制字符颜色的控制符，</strong>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">\e[37;44;3;1m<br></code></pre></td></tr></table></figure><ul><li><code>\e</code> 代表开始ANSI Escape code</li><li><code>[</code> 代表转义序列开始符 CSI，Control Sequence Introducer</li><li><code>37;44;4;1</code> 代表以<code>; </code>分隔的文本样式控制符，其中 37 代表文本前景色为白色，44代表背景为蓝色，3代表斜体，1代表加粗，<code>;</code>的数量不做限制</li><li><code>m</code> 代表结束控制符序列</li></ul><h4 id="常用文本样式控制符"><a href="#常用文本样式控制符" class="headerlink" title="常用文本样式控制符"></a>常用文本样式控制符</h4><table><thead><tr><th>代码</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td>0</td><td>重置&#x2F;正常</td><td>关闭所有属性。</td></tr><tr><td>1</td><td>粗体或增加强度</td><td></td></tr><tr><td>2</td><td>弱化（降低强度）</td><td>未广泛支持。</td></tr><tr><td>3</td><td>斜体</td><td>未广泛支持。有时视为反相显示。</td></tr><tr><td>4</td><td>下划线</td><td></td></tr><tr><td>5</td><td>缓慢闪烁</td><td>低于每分钟150次。</td></tr><tr><td>6</td><td>快速闪烁</td><td>MS-DOS ANSI.SYS；每分钟150以上；未广泛支持。</td></tr><tr><td>7</td><td>反显</td><td>前景色与背景色交换。</td></tr><tr><td>8</td><td>隐藏</td><td>未广泛支持。</td></tr><tr><td>9</td><td>划除</td><td>字符清晰，但标记为删除。未广泛支持。</td></tr><tr><td>10</td><td>主要（默认）字体</td><td></td></tr><tr><td>11–19</td><td>替代字体</td><td>选择替代字体</td></tr><tr><td>20</td><td>尖角体</td><td>几乎无支持。</td></tr><tr><td>21</td><td>关闭粗体或双下划线</td><td>关闭粗体未广泛支持；双下划线几乎无支持。</td></tr><tr><td>22</td><td>正常颜色或强度</td><td>不强不弱。</td></tr><tr><td>23</td><td>非斜体、非尖角体</td><td></td></tr><tr><td>24</td><td>关闭下划线</td><td>去掉单双下划线。</td></tr><tr><td>25</td><td>关闭闪烁</td><td></td></tr><tr><td>27</td><td>关闭反显</td><td></td></tr><tr><td>28</td><td>关闭隐藏</td><td></td></tr><tr><td>29</td><td>关闭划除</td><td></td></tr><tr><td>30–37</td><td>设置前景色</td><td>参见下面的颜色表。</td></tr><tr><td>38</td><td>设置前景色</td><td>下一个参数是5;n或2;r;g;b，见下。</td></tr><tr><td>39</td><td>默认前景色</td><td>由具体实现定义（按照标准）。</td></tr><tr><td>40–47</td><td>设置背景色</td><td>参见下面的颜色表。</td></tr><tr><td>48</td><td>设置背景色</td><td>下一个参数是5;n或2;r;g;b，见下。</td></tr><tr><td>49</td><td>默认背景色</td><td>由具体实现定义（按照标准）。</td></tr><tr><td>51</td><td>Framed</td><td></td></tr><tr><td>52</td><td>Encircled</td><td></td></tr><tr><td>53</td><td>上划线</td><td></td></tr><tr><td>54</td><td>Not framed or encircled</td><td></td></tr><tr><td>55</td><td>关闭上划线</td><td></td></tr><tr><td>60</td><td>表意文字下划线或右边线</td><td>几乎无支持。</td></tr><tr><td>61</td><td>表意文字双下划线或双右边线</td><td></td></tr><tr><td>62</td><td>表意文字上划线或左边线</td><td></td></tr><tr><td>63</td><td>表意文字双上划线或双左边线</td><td></td></tr><tr><td>64</td><td>表意文字着重标志</td><td></td></tr><tr><td>65</td><td>表意文字属性关闭</td><td>重置60–64的所有效果。</td></tr><tr><td>90–97</td><td>设置明亮的前景色</td><td>aixterm（非标准）。</td></tr><tr><td>100–107</td><td>设置明亮的背景色</td><td>aixterm（非标准）。</td></tr></tbody></table><p>颜色对照表</p><p><img src="/2022/a2c49dae/e9436bb4998a4fbf9bd5abbe74121ccdtplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="3bit-color"></p><h2 id="Powershell-修改提示符的文字内容和颜色"><a href="#Powershell-修改提示符的文字内容和颜色" class="headerlink" title="Powershell 修改提示符的文字内容和颜色"></a>Powershell 修改提示符的文字内容和颜色</h2><p><a href="https://www.lfhacks.com/tech/powershell-prompt-customization/">参考: Powershell 修改提示符的文字内容和颜色</a></p><p><a href="https://blog.vvzero.com/2019/07/22/set-user-alias-for-windows-PowerShell/">参考: 为 Windows PowerShell 设置 User Alias （命令别名）</a></p><ol><li><p>首先我们先找到Powershell的配置文件的路径, 我们输入命令<code>echo $profile</code>就能显示.</p></li><li><p>如果这个文件不存在, 我们输入命令<code>notepad $Profile</code>或者<code>code $Profile</code>去新建一个文件.</p></li><li><p>Powershell 有一个特殊的函数： <code>prompt</code> 函数，这个函数规定了提示符的内容和外观。</p><p>我们可以利用下面的命令可以查看当前使用的 <code>prompt</code> 函数的内容：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">(<span class="hljs-built_in">Get-Command</span> Prompt).ScriptBlock<br></code></pre></td></tr></table></figure></li><li><p>通过 <code>prompt</code> 函数的返回值我们就能自定义提示符。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">prompt</span></span> &#123;<br>  <span class="hljs-string">&quot;<span class="hljs-variable">$</span>([char]27)[32m&quot;</span> + <span class="hljs-variable">$</span>(<span class="hljs-built_in">Get-Date</span> <span class="hljs-literal">-Format</span> HH:mm:ss) + <span class="hljs-string">&quot;<span class="hljs-variable">$</span>([char]27)[0m&quot;</span> +<br>  <span class="hljs-string">&quot;<span class="hljs-variable">$</span>([char]27)[95m&quot;</span> + <span class="hljs-variable">$</span>((<span class="hljs-built_in">get-item</span> .).name) + <span class="hljs-string">&quot;<span class="hljs-variable">$</span>([char]27)[0m&quot;</span> +<br>  <span class="hljs-string">&quot;<span class="hljs-variable">$</span>([char]27)[33m&gt;<span class="hljs-variable">$</span>([char]27)[0m&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>  第一行 <code>Get-Date</code>获取当前系统的时间, <code>-Format</code>格式化使用<code>HH:mm:ss</code>的格式, 前后使用了ANSI颜色转义将前景色设置为深绿色</p><p>  第二行 <code>(get-item .).name</code>获取了当前文件夹的名称, 并设置前景色为深紫色</p><p>  第三行 输出一个深黄色的<code>&gt;</code>符号</p></blockquote></li><li><p>输入 <code>. $Profile</code> 命令生效。(注意这里是大小写不敏感的)</p></li></ol><h2 id="Powershell-起别名-User-Alias-命令别名"><a href="#Powershell-起别名-User-Alias-命令别名" class="headerlink" title="Powershell 起别名(User Alias) 命令别名"></a>Powershell 起别名(User Alias) 命令别名</h2><p><a href="https://blog.vvzero.com/2019/07/22/set-user-alias-for-windows-PowerShell/">参考 为 Windows PowerShell 设置 User Alias （命令别名）</a></p><blockquote><p>  我们的思路就是将命令设置成为一个<code>function</code>, 运行这个<code>function</code>执行特定的指令即可.</p></blockquote><p>两个思路:</p><ol><li><p>使用<code>New-Alias</code>指令, 添加到Powershell的<code>$Profile</code>文件里面, 每次启动运行一次. 这个命令里面不能含有空格.</p><p><a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/new-alias?view=powershell-7.3">参考 Microsoft的Powershell文档</a></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 此命令创建一个名为 List 的别名来表示 Get-ChildItem cmdlet。</span><br><span class="hljs-built_in">New-Alias</span> <span class="hljs-literal">-Name</span> <span class="hljs-string">&quot;List&quot;</span> <span class="hljs-built_in">Get-ChildItem</span><br><span class="hljs-comment"># 为notepad++ 设置别名 np</span><br><span class="hljs-built_in">New-Alias</span> <span class="hljs-literal">-Name</span> <span class="hljs-string">&quot;np&quot;</span> notepad++.exe<br></code></pre></td></tr></table></figure></li><li><p>使用<code>function</code>指令, 添加到Powershell的<code>$Profile</code>文件里面, 把指令当作<code>function</code>的名称来调用, 这样命令可以带有空格.</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 带参数的function</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">np</span>+</span> &#123;<br>    <span class="hljs-keyword">param</span> (<br>        <span class="hljs-variable">$ComputerName</span><br>    )<br>    notepad++.exe <span class="hljs-variable">$ComputerName</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ps</tag>
      
      <tag>powershell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zsh</title>
    <link href="/2022/d911b12b/"/>
    <url>/2022/d911b12b/</url>
    
    <content type="html"><![CDATA[<h1 id="Powerlevel10k"><a href="#Powerlevel10k" class="headerlink" title="Powerlevel10k"></a>Powerlevel10k</h1><p><a href="https://github.com/romkatv/powerlevel10k">https://github.com/romkatv/powerlevel10k</a></p><ul><li>Download these four ttf files:<ul><li>[MesloLGS NF Regular.ttf](<a href="https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS">https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS</a> NF Regular.ttf)</li><li>[MesloLGS NF Bold.ttf](<a href="https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS">https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS</a> NF Bold.ttf)</li><li>[MesloLGS NF Italic.ttf](<a href="https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS">https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS</a> NF Italic.ttf)</li><li>[MesloLGS NF Bold Italic.ttf](<a href="https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS">https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS</a> NF Bold Italic.ttf)</li></ul></li><li>Double-click on each file and click “Install”. This will make <code>MesloLGS NF</code> font available to all applications on your system.</li></ul>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>zsh</tag>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ip 转换成 Location 的Api</title>
    <link href="/2022/4dd4ea8a/"/>
    <url>/2022/4dd4ea8a/</url>
    
    <content type="html"><![CDATA[<h1 id="ip-to-location"><a href="#ip-to-location" class="headerlink" title="ip to location"></a>ip to location</h1><h2 id="ipwhois"><a href="#ipwhois" class="headerlink" title="ipwhois"></a>ipwhois</h2><p>IPWHOIS.IO的IP地理定位API的URL格式很简单。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">http://ipwhois.app/json/&#123;IP&#125;<br></code></pre></td></tr></table></figure><p>例如，我们可以用以下IP地址发出API请求：47.9.123.84。</p><p><img src="/2022/4dd4ea8a/ipwhois-api.png" alt="img"></p><p><strong>参考链接:</strong></p><ul><li><a href="https://webdamn.com/ip-geolocation-api/">IP Geolocation API – IPWHOIS.IO</a></li><li><a href="https://webdamn.com/how-to-integrate-ip-geolocation-api-with-php/">How to Integrate IP Geolocation API with PHP</a></li><li><a href="https://webdamn.com/scrape-search-result-data-using-serpapi-with-python/">Scrape Search Result Data using SerpApi with Python</a></li><li><a href="https://webdamn.com/get-geocoding-using-positionstack-api-with-php/">Get Geocoding using Positionstack API with PHP</a></li><li><a href="https://webdamn.com/flight-data-using-aviationstack-api-with-php/">Flight Data using Aviationstack API with PHP</a></li><li><a href="https://webdamn.com/get-address-information-using-geocode-api-with-php/">Get Address Information using Geocode API with PHP</a></li><li><a href="https://webdamn.com/review-scraping-using-reviewapi-with-php/">Review Scraping using ReviewAPI with PHP</a></li><li><a href="https://webdamn.com/simple-web-scraping-with-zenscrape-api-using-php/">Simple Web Scraping with Zenscrape API using PHP</a></li><li><a href="https://webdamn.com/scrape-search-result-with-zenserp-api-using-php/">Scrape Search Result with Zenserp API using PHP</a></li><li><a href="https://webdamn.com/build-user-agent-lookup-system-using-userstack-api-with-php/">Build User Agent Lookup System using Userstack API with PHP</a></li><li><a href="https://webdamn.com/build-ip-lookup-website-using-ipapi-with-php/">Build IP Lookup Website using ipapi with PHP</a></li><li><a href="https://webdamn.com/build-weather-website-with-weatherstack-api-using-php/">Build Weather Website with Weatherstack API using PHP</a></li><li><a href="https://webdamn.com/get-website-visitors-info-using-ipstack-api-with-php/">Get Website Visitors Info using IPStack API with PHP</a></li><li><a href="https://webdamn.com/scrape-serp-data-using-serpstack-api-with-python/">Scrape SERP Data using SerpStack API with Python</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ip</tag>
      
      <tag>location</tag>
      
      <tag>api</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单位换算</title>
    <link href="/2022/6fb71d96/"/>
    <url>/2022/6fb71d96/</url>
    
    <content type="html"><![CDATA[<h1 id="单位换算"><a href="#单位换算" class="headerlink" title="单位换算"></a>单位换算</h1><h1 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">★ -----------------</span><br>1 km = 1000 m<br>1 m  = 100  cm<br>1 cm = 10   mm<br>1 mm = 1000 um<br><br>1    inch = 2.54 cm<br>1/10 inch = 2.54 mm<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">--------------------</span><br>1 km = 1000 m<br>1 m  = 10   dm<br>1 dm = 10   cm<br>1 cm = 10   mm<br>1 m  = 1000 mm<br>1 mm = 1000 um<br>1 um = 1000 nm<br>1 nm = 1000 pm <br>1 pm = 1000 fm<br>1 fm = 1000 am<br>...<br>1 inch              = 2.54 cm<br>1 cm                = 0.3937008 inch<br>...<br><span class="hljs-meta prompt_"># </span><span class="language-bash"></span><br><span class="language-bash">1 海里(nautical mile) = 1852 m = 1.852 km</span><br>1 km                = 0.5399568 海里(nautical mile)<br>...<br><span class="hljs-meta prompt_"># </span><span class="language-bash">英制长度单位</span><br>1 英里(mile)          = 1.609344 km<br>1 km                = 0.6213712 英里(mile)<br>...<br><span class="hljs-meta prompt_"># </span><span class="language-bash">天文学长度单位</span><br>1 光年                = 9.4653×10^12 km<br>1 天文单位 ≈ 1.496亿 千米<br>...<br><span class="hljs-meta prompt_"># </span><span class="language-bash">我国传统的长度单位</span><br>1 km                = 2 里<br>1 里                 = 150 丈 = 500 米<br>1 丈                 = 10尺<br>1 丈                 = 3.33米<br>1 尺                 = 3.33分米<br>1 m                 = 0.3 丈 = 3 尺 = 30 寸<br>1 cm                = 3 分 = 30 厘<br><br></code></pre></td></tr></table></figure><h1 id="时间单位"><a href="#时间单位" class="headerlink" title="时间单位"></a>时间单位</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">★ -----------------</span><br>1 s  = 1000 ms<br>1 ms = 1000 us<br>1 us = 1000 ns<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">   -----------------</span><br>1 minute = 60 s<br>1 s  = 1000 ms<br>1 ms = 1000 us<br>1 us = 1000 ns<br>1 ns = 1000 ps<br><br>100年      = 1世纪<br>365.25天   = 1年<br>1平太阳日     = 24小时3分56.555秒<br>1恒星日      = 23小时56分4.091秒<br>1太阳年(回归年) = 365.2422天(= 365天5小时48分46秒)<br>1恒星年      = 365.2564天(= 365天6小时9分9.5秒)<br>1朔望月      = 29.5306天<br>1恒星月      = 27.3712天<br>1太阳年      = 12个朔望日 = 354.36天<br></code></pre></td></tr></table></figure><h1 id="速度"><a href="#速度" class="headerlink" title="速度"></a>速度</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">★ -----------------</span><br>1 m/s  = 3.6 km/h<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">   -----------------</span><br>1 mph  = 1.609344 km/h<br>1 km/h = 0.6213712 mph<br><br></code></pre></td></tr></table></figure><h1 id="温度"><a href="#温度" class="headerlink" title="温度"></a>温度</h1><p>$$<br>℉ &#x3D; ℃ * (9&#x2F;5) + 32<br>$$</p><p>$$<br>℃ &#x3D; (℉ - 32)*(5&#x2F;9)<br>$$</p><p>$$<br>K &#x3D; ℃ + 273.15<br>$$</p><p>$$<br>℃ &#x3D; K - 273.15<br>$$</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">25 ℃ = 298.15 K = 77 F<br></code></pre></td></tr></table></figure><h1 id="电容单位"><a href="#电容单位" class="headerlink" title="电容单位"></a>电容单位</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>1 F  = 1000 mF<br>1 mF = 1000 uF<br>1 uF = 1000 nF<br>1 nF = 1000 pF<br></code></pre></td></tr></table></figure><p><img src="/2022/6fb71d96/tutorials068_001_zh.gif" alt="C"></p><ul><li>数值中的<code>R</code>代表小数点<code>.</code></li></ul><table><thead><tr><th align="left">标示</th><th align="left">电阻</th><th align="left">电容</th><th align="left">电感</th></tr></thead><tbody><tr><td align="left">120</td><td align="left">12Ω</td><td align="left">12pF</td><td align="left">12μH</td></tr><tr><td align="left">122</td><td align="left">1.2kΩ</td><td align="left">1.2nF</td><td align="left">1.2mH</td></tr><tr><td align="left">124</td><td align="left">120kΩ</td><td align="left">120nF</td><td align="left">120mH</td></tr><tr><td align="left">126</td><td align="left">12MΩ</td><td align="left">12μF</td><td align="left">12H</td></tr><tr><td align="left">R15</td><td align="left">0.15Ω</td><td align="left">0.15pF</td><td align="left">0.15μH</td></tr><tr><td align="left">1R5</td><td align="left">1.5Ω</td><td align="left">1.5pF</td><td align="left">1.5μH</td></tr></tbody></table><table><thead><tr><th align="center">误差符号</th><th align="center">误差</th></tr></thead><tbody><tr><td align="center">Ｆ</td><td align="center">±1％</td></tr><tr><td align="center">Ｇ</td><td align="center">±2％</td></tr><tr><td align="center">Ｊ</td><td align="center">±5％</td></tr><tr><td align="center">Ｋ</td><td align="center">±10％</td></tr><tr><td align="center">Ｍ</td><td align="center">±20％</td></tr><tr><td align="center">Ｚ</td><td align="center">80%,－20%</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>unit</tag>
      
      <tag>m</tag>
      
      <tag>cm</tag>
      
      <tag>mm</tag>
      
      <tag>s</tag>
      
      <tag>us</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android 文件传输模式 电脑无法识别</title>
    <link href="/2022/3db44d04/"/>
    <url>/2022/3db44d04/</url>
    
    <content type="html"><![CDATA[<h1 id="android-文件传输模式-电脑无法识别"><a href="#android-文件传输模式-电脑无法识别" class="headerlink" title="android 文件传输模式 电脑无法识别"></a>android 文件传输模式 电脑无法识别</h1><p>最近android手机连接电脑选择传输文件模式，电脑不再识别手机。选择照片模式就没有问题。</p><p>手机选择文件传输模式后 选择自动搜索驱动程序 安装后会 提示“这个inf中的服务安装段落无效”。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li><p>按“Win+X” 点击 “设备管理器”</p></li><li><p>在设备管理器中找到你的手机，名字可能是你的手机型号，可能是未知设备 ，</p></li><li><p>右键选择更新驱动程序.</p></li><li><p>选择 “浏览计算机以查找驱动程序软件”</p></li><li><p>选择 “让我从计算机上的可用驱动程序列表中选取”</p></li><li><p>在列表里面找到“便携设备” (可能没有这一步操作)</p></li><li><p>选择 “MTP USB 设备”</p><p><img src="/2022/3db44d04/1636599848857.png" alt="win10系统识别不了USB设备解决方法介绍-Win10系统识别不了USB设备怎么办-53系统之家"></p></li><li><p>点击 “下一步”</p></li><li><p>回到设备管理器看到设备已经可用正确运作了</p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.android.com/studio/run/oem-usb">安装原始设备制造商 (OEM) USB 驱动程序</a></p><p><a href="https://developer.android.com/studio/run/win-usb">获取 Google USB 驱动程序</a></p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>pc</tag>
      
      <tag>android</tag>
      
      <tag>mtp</tag>
      
      <tag>driver</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tmux 终端复用器(Terminal Multiplexer)</title>
    <link href="/2022/9d389561/"/>
    <url>/2022/9d389561/</url>
    
    <content type="html"><![CDATA[<h1 id="tmux-终端复用器-terminal-multiplexer"><a href="#tmux-终端复用器-terminal-multiplexer" class="headerlink" title="tmux 终端复用器(terminal multiplexer)"></a>tmux 终端复用器(terminal multiplexer)</h1><p>☆为重要内容</p><h1 id="Tmux-简介"><a href="#Tmux-简介" class="headerlink" title="Tmux 简介"></a>Tmux 简介</h1><p>tmux 终端复用器(terminal multiplexer)</p><h2 id="tmux-能干什么"><a href="#tmux-能干什么" class="headerlink" title="tmux 能干什么"></a>tmux 能干什么</h2><p>命令行的典型使用方式是，打开一个终端窗口（terminal window，以下简称”窗口”），在里面输入命令。<strong>用户与计算机的这种临时的交互，称为一次”会话”（session）</strong> 。</p><p>会话的一个重要特点是，窗口与其中启动的进程是<a href="https://www.ruanyifeng.com/blog/2016/02/linux-daemon.html">连在一起</a>的。打开窗口，会话开始；关闭窗口，会话结束，会话内部的进程也会随之终止，不管有没有运行完。</p><p>一个典型的例子就是，<a href="https://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html">SSH 登录</a>远程计算机，打开一个远程窗口执行一个命令例如<code>iperf3 -s</code>。这时，关掉SSH，会发现<code>iperf3</code>进程也被关掉了。这是因为<code>iperf3</code>属于SSH的子进程，SSH作为父进程，如果父进程关掉了，子进程也就关掉了。</p><p>为了解决这个问题，会话与窗口可以”解绑”：窗口关闭时，会话并不终止，而是继续运行，等到以后需要的时候，再让会话”绑定”其他窗口。</p><p><strong>Tmux 就是会话与窗口的”解绑”工具，将它们彻底分离。</strong></p><blockquote><ul><li>它允许在单个窗口中，同时访问多个会话。这对于同时运行多个命令行程序很有用。</li><li>它可以让新窗口”接入”已经存在的会话。</li><li>它允许每个会话有多个连接窗口，因此可以多人实时共享会话。</li><li>它还支持窗口任意的垂直和水平拆分。</li></ul></blockquote><p>类似的终端复用器还有 GNU Screen。Tmux 与它功能相似，但是更易用，也更强大。</p><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p>Tmux 一般需要自己安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Ubuntu 或 Debian</span><br>$ sudo apt-get install tmux<br><br><span class="hljs-comment"># 启动</span><br>$ tmux<br><br><span class="hljs-comment"># 退出</span><br>$ <span class="hljs-built_in">exit</span><br></code></pre></td></tr></table></figure><p>启动后底部<u>左边</u>是<strong>窗口</strong>信息（编号和名称），<u>右侧</u>是系统信息。</p><p><img src="/2022/9d389561/image-20220929235001871.png" alt="image-20220929235001871"></p><p>按下<code>Ctrl+d</code>或者显式输入<code>exit</code>命令，就可以退出 Tmux 窗口。</p><h2 id="前缀键☆"><a href="#前缀键☆" class="headerlink" title="前缀键☆"></a><strong>前缀键</strong>☆</h2><p>Tmux 窗口有大量的快捷键。所有快捷键都要通过前缀键唤起。默认的前缀键是<code>Ctrl+b</code>，即先按下<code>Ctrl+b</code>，快捷键才会生效。</p><p>举例来说，帮助命令的快捷键是<code>Ctrl+b ?</code>。它的用法是，在 Tmux 窗口中，先按下<code>Ctrl+b</code>，再按下<code>?</code>，就会显示帮助信息。</p><p>然后，按下 ESC 键或<code>q</code>键，就可以退出帮助。</p><h2 id="会话-窗格-窗口-的概念☆"><a href="#会话-窗格-窗口-的概念☆" class="headerlink" title="会话  窗格  窗口  的概念☆"></a><strong>会话  窗格  窗口  的概念</strong>☆</h2><blockquote><p>  会话 session<br>  窗口 windows<br>  窗格 pane</p></blockquote><ul><li><code>tmux new</code>的是会话, 会话可以包括多个窗口, 窗口内可以有多个窗格</li></ul><ul><li><code>tmux ls</code> 列出的是会话</li></ul><p><img src="/2022/9d389561/image-20220930003505311.png" alt="image-20220930003505311"></p><h1 id="会话的管理"><a href="#会话的管理" class="headerlink" title="会话的管理"></a>会话的管理</h1><h2 id="快捷键☆"><a href="#快捷键☆" class="headerlink" title="快捷键☆"></a>快捷键☆</h2><p>下面是一些会话相关的快捷键。</p><blockquote><ul><li><code>Ctrl+b d</code>：分离当前会话。</li><li><code>Ctrl+b s</code>：列出所有会话。</li><li><code>Ctrl+b $</code>：重命名当前会话。</li></ul></blockquote><h2 id="3-1-new新建会话☆"><a href="#3-1-new新建会话☆" class="headerlink" title="3.1 new新建会话☆"></a>3.1 new新建会话☆</h2><p>第一个启动的 Tmux 窗口，编号是<code>0</code>，第二个窗口的编号是<code>1</code>，以此类推。这些窗口对应的会话，就是 0 号会话、1 号会话。</p><p>使用编号区分会话，不太直观，更好的方法是为会话起名。</p><blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 直接新建一个</span><br>$ tmux<br><span class="hljs-comment"># 新建并设置一个名字</span><br>$ tmux new -s &lt;session-name&gt;<br></code></pre></td></tr></table></figure></blockquote><p>上面命令新建一个指定名称的会话。</p><p>在<code>tmux</code>内应该是无法执行这个指令的, 需要分屏参考下面的窗格操作章节.</p><h2 id="3-2-detach分离会话☆"><a href="#3-2-detach分离会话☆" class="headerlink" title="3.2 detach分离会话☆"></a>3.2 detach分离会话☆</h2><p>在 Tmux 窗口中，按下<code>Ctrl+b d</code>或者输入<code>tmux detach</code>命令，就会将当前会话与窗口分离。</p><blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux detach<br></code></pre></td></tr></table></figure></blockquote><p>上面命令执行后，就会退出当前 Tmux 窗口，但是会话和里面的进程仍然在后台运行。</p><p><code>tmux ls</code>命令可以查看当前所有的 Tmux 会话。</p><blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux <span class="hljs-built_in">ls</span><br><span class="hljs-comment"># or</span><br>$ tmux list-session<br></code></pre></td></tr></table></figure></blockquote><h2 id="3-3-attach接入会话☆"><a href="#3-3-attach接入会话☆" class="headerlink" title="3.3 attach接入会话☆"></a>3.3 attach接入会话☆</h2><p><code>tmux attach</code>命令用于重新接入某个已存在的会话。</p><blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用会话编号</span><br>$ tmux attach -t 0<br><br><span class="hljs-comment"># 使用会话名称</span><br>$ tmux attach -t &lt;session-name&gt;<br></code></pre></td></tr></table></figure></blockquote><h2 id="3-4-kill-session杀死会话☆"><a href="#3-4-kill-session杀死会话☆" class="headerlink" title="3.4 kill-session杀死会话☆"></a>3.4 kill-session杀死会话☆</h2><p><code>tmux kill-session</code>命令用于杀死某个会话。</p><blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用会话编号</span><br>$ tmux kill-session -t 0<br><br><span class="hljs-comment"># 使用会话名称</span><br>$ tmux kill-session -t &lt;session-name&gt;<br></code></pre></td></tr></table></figure></blockquote><h2 id="3-5-切换会话"><a href="#3-5-切换会话" class="headerlink" title="3.5 切换会话"></a>3.5 切换会话</h2><p><code>tmux switch</code>命令用于切换会话。</p><blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用会话编号</span><br>$ tmux switch -t 0<br><br><span class="hljs-comment"># 使用会话名称</span><br>$ tmux switch -t &lt;session-name&gt;<br></code></pre></td></tr></table></figure></blockquote><h2 id="3-6-重命名会话"><a href="#3-6-重命名会话" class="headerlink" title="3.6 重命名会话"></a>3.6 重命名会话</h2><p><code>tmux rename-session</code>命令用于重命名会话。</p><blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux rename-session -t 0 &lt;new-name&gt;<br></code></pre></td></tr></table></figure></blockquote><p>上面命令将0号会话重命名。</p><h1 id="窗格操作"><a href="#窗格操作" class="headerlink" title="窗格操作"></a>窗格操作</h1><h2 id="快捷键☆-1"><a href="#快捷键☆-1" class="headerlink" title="快捷键☆"></a>快捷键☆</h2><blockquote><ul><li><code>Ctrl+b %</code>：划分左右两个窗格。☆</li><li><code>Ctrl+b &quot;</code>：划分上下两个窗格。☆</li><li><code>Ctrl+b &lt;arrow key&gt;</code>：光标切换到其他窗格。<code>&lt;arrow key&gt;</code>是指向要切换到的窗格的方向键，比如切换到下方窗格，就按方向键<code>↓</code>。☆</li><li><code>Ctrl+b ;</code>：光标切换到上一个窗格。</li><li><code>Ctrl+b o</code>：光标切换到下一个窗格。</li><li><code>Ctrl+b &#123;</code>：当前窗格与上一个窗格交换位置。☆</li><li><code>Ctrl+b &#125;</code>：当前窗格与下一个窗格交换位置。☆</li><li><code>Ctrl+b Ctrl+o</code>：所有窗格向前移动一个位置，第一个窗格变成最后一个窗格。</li><li><code>Ctrl+b Alt+o</code>：所有窗格向后移动一个位置，最后一个窗格变成第一个窗格。</li><li><code>Ctrl+b x</code>：关闭当前窗格。☆</li><li><code>Ctrl+b !</code>：将当前窗格拆分为一个独立窗口。</li><li><code>Ctrl+b z</code>：当前窗格全屏显示，再使用一次会变回原来大小。</li><li><code>Ctrl+b Ctrl+&lt;arrow key&gt;</code>：按箭头方向调整窗格大小。☆</li><li><code>Ctrl+b q</code>：显示窗格编号。</li></ul></blockquote><h2 id="5-1-划分窗格"><a href="#5-1-划分窗格" class="headerlink" title="5.1 划分窗格"></a>5.1 划分窗格</h2><p><code>tmux split-window</code>命令用来划分窗格。</p><blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 划分上下两个窗格</span><br>$ tmux split-window<br><br><span class="hljs-comment"># 划分左右两个窗格</span><br>$ tmux split-window -h<br></code></pre></td></tr></table></figure></blockquote><h2 id="5-2-移动光标"><a href="#5-2-移动光标" class="headerlink" title="5.2 移动光标"></a>5.2 移动光标</h2><p><code>tmux select-pane</code>命令用来移动光标位置。</p><blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 光标切换到上方窗格</span><br>$ tmux select-pane -U<br><br><span class="hljs-comment"># 光标切换到下方窗格</span><br>$ tmux select-pane -D<br><br><span class="hljs-comment"># 光标切换到左边窗格</span><br>$ tmux select-pane -L<br><br><span class="hljs-comment"># 光标切换到右边窗格</span><br>$ tmux select-pane -R<br></code></pre></td></tr></table></figure></blockquote><h2 id="5-3-交换窗格位置"><a href="#5-3-交换窗格位置" class="headerlink" title="5.3 交换窗格位置"></a>5.3 交换窗格位置</h2><p><code>tmux swap-pane</code>命令用来交换窗格位置。</p><blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 当前窗格上移</span><br>$ tmux swap-pane -U<br><br><span class="hljs-comment"># 当前窗格下移</span><br>$ tmux swap-pane -D<br></code></pre></td></tr></table></figure></blockquote><h1 id="窗口管理"><a href="#窗口管理" class="headerlink" title="窗口管理"></a>窗口管理</h1><h2 id="快捷键☆-2"><a href="#快捷键☆-2" class="headerlink" title="快捷键☆"></a>快捷键☆</h2><p>下面是一些窗口操作的快捷键。</p><blockquote><ul><li><code>Ctrl+b c</code>：创建一个新窗口，状态栏会显示多个窗口的信息。</li><li><code>Ctrl+b p</code>：切换到上一个窗口（按照状态栏上的顺序）。</li><li><code>Ctrl+b n</code>：切换到下一个窗口。</li><li><code>Ctrl+b &lt;number&gt;</code>：切换到指定编号的窗口，其中的<code>&lt;number&gt;</code>是状态栏上的窗口编号。</li><li><code>Ctrl+b w</code>：从列表中选择窗口。</li><li><code>Ctrl+b ,</code>：窗口重命名。</li></ul></blockquote><h2 id="6-1-新建窗口"><a href="#6-1-新建窗口" class="headerlink" title="6.1 新建窗口"></a>6.1 新建窗口</h2><p><code>tmux new-window</code>命令用来创建新窗口。</p><blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux new-window<br><br><span class="hljs-comment"># 新建一个指定名称的窗口</span><br>$ tmux new-window -n &lt;window-name&gt;<br></code></pre></td></tr></table></figure></blockquote><h2 id="6-2-切换窗口"><a href="#6-2-切换窗口" class="headerlink" title="6.2 切换窗口"></a>6.2 切换窗口</h2><p><code>tmux select-window</code>命令用来切换窗口。</p><blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 切换到指定编号的窗口</span><br>$ tmux select-window -t &lt;window-number&gt;<br><br><span class="hljs-comment"># 切换到指定名称的窗口</span><br>$ tmux select-window -t &lt;window-name&gt;<br></code></pre></td></tr></table></figure></blockquote><h2 id="6-3-重命名窗口"><a href="#6-3-重命名窗口" class="headerlink" title="6.3 重命名窗口"></a>6.3 重命名窗口</h2><p><code>tmux rename-window</code>命令用于为当前窗口起名（或重命名）。</p><blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux rename-window &lt;new-name&gt;<br></code></pre></td></tr></table></figure></blockquote><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><h2 id="一些其他的快捷键"><a href="#一些其他的快捷键" class="headerlink" title="一些其他的快捷键"></a>一些其他的快捷键</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 列出所有快捷键，及其对应的 Tmux 命令</span><br>$ tmux list-keys<br><br><span class="hljs-comment"># 列出所有 Tmux 命令及其参数</span><br>$ tmux list-commands<br><br><span class="hljs-comment"># 列出当前所有 Tmux 会话的信息</span><br>$ tmux info<br><br><span class="hljs-comment"># 重新加载当前的 Tmux 配置</span><br>$ tmux source-file ~/.tmux.conf<br></code></pre></td></tr></table></figure><h2 id="开启鼠标支持"><a href="#开启鼠标支持" class="headerlink" title="开启鼠标支持"></a>开启鼠标支持</h2><p>tmux2 以上版本和 tmux2 以上版本有所不同</p><blockquote><p>  查看版本<code>tmux -V</code></p><p>  注意大写</p></blockquote><h3 id="tmux2-以上"><a href="#tmux2-以上" class="headerlink" title="tmux2 以上"></a>tmux2 以上</h3><p><strong>写入配置文件</strong></p><p>在<code>~/.tmux.conf</code>中加入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Enable mouse mode (tmux 2.1 and above)</span><br><span class="hljs-built_in">set</span> -g mouse on<br><br><span class="hljs-comment"># Mouse based copy</span><br>bind-key -T copy-mode-vi MouseDragEnd1Pane send -X copy-pipe-and-cancel <span class="hljs-string">&quot;reattach-to-user-namespace pbcopy&quot;</span><br>bind-key -T copy-mode MouseDragEnd1Pane send -X copy-pipe-and-cancel <span class="hljs-string">&quot;reattach-to-user-namespace pbcopy&quot;</span> <br></code></pre></td></tr></table></figure><p><strong>临时使用</strong></p><p>按完前缀ctrl+B后，再按冒号：进入<code>命令行</code>模式，输入<code>set -g mouse on</code></p><h3 id="tmux2-以下"><a href="#tmux2-以下" class="headerlink" title="tmux2 以下"></a>tmux2 以下</h3><p><strong>写入配置文件</strong></p><p>在<code>~/.tmux.conf</code>中加入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">setw -g mouse-resize-pane on<br>setw -g mouse-select-pane on<br>setw -g mouse-select-window on<br>setw -g mode-mouse on<br></code></pre></td></tr></table></figure><blockquote><p>  这几行的作用分别是:<br>  开启用鼠标拖动调节pane的大小（拖动位置是pane之间的分隔线）<br>  开启用鼠标点击pane来激活该pane<br>  开启用鼠标点击来切换活动window（点击位置是状态栏的窗口名称）<br>  开启window&#x2F;pane里面的鼠标支持（也即可以用鼠标滚轮回滚显示窗口内容，此时还可以用鼠标选取文本）</p></blockquote><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.hamvocke.com/blog/a-quick-and-easy-guide-to-tmux/">A Quick and Easy Guide to tmux</a></li><li><a href="https://danielmiessler.com/study/tmux/">Tactical tmux: The 10 Most Important Commands</a></li><li><a href="https://linuxize.com/post/getting-started-with-tmux/">Getting started with Tmux</a></li><li><a href="https://www.ruanyifeng.com/blog/2019/10/tmux.html">阮一峰</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>tmux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的工作法</title>
    <link href="/2022/a1ed3941/"/>
    <url>/2022/a1ed3941/</url>
    
    <content type="html"><![CDATA[<h1 id="我的工作法"><a href="#我的工作法" class="headerlink" title="我的工作法"></a>我的工作法</h1><p><a href="https://unknwon.cn/2021/211013-boring-methodology-to-be-productive/">高效工作法的朴素方法论 -By无闻</a></p><p><a href="https://zhuanlan.zhihu.com/p/42694082">逗总出品：GTD最全面教程，从入门到精通</a></p><h1 id="出来玩最重要的是出来"><a href="#出来玩最重要的是出来" class="headerlink" title="出来玩最重要的是出来"></a>出来玩最重要的是出来</h1><p>不管今天一天做什么惊天地的大事, 第一步都是先起床.</p><h2 id="花三分钟安排一天"><a href="#花三分钟安排一天" class="headerlink" title="花三分钟安排一天"></a>花三分钟安排一天</h2><p>每天开始，先梳理一遍今日视图里的所有任务</p><p>梳理任务的关键在于对于自己实际的产出效率和可用时间上的正确评判</p><h2 id="创造仪式感"><a href="#创造仪式感" class="headerlink" title="创造仪式感"></a>创造仪式感</h2><p>有的人喜欢喝咖啡, 比如倒好一杯咖啡之后就放下手机, 避免去接触任何和当前手上事务不相关的内容(放下手机并让它远离自己).</p><h1 id="推送通知是互联网时代的毒药"><a href="#推送通知是互联网时代的毒药" class="headerlink" title="推送通知是互联网时代的毒药"></a>推送通知是互联网时代的毒药</h1><p>我注意到推送通知经常会带给人们焦虑的情绪，尤其是工作上的，我对此也深恶痛绝。</p><ul><li>在工作时间(专注的时间)关掉它们(尤其是手机), 别让他们打断你的工作节奏</li></ul><h1 id="异步沟通是健康的协作方式"><a href="#异步沟通是健康的协作方式" class="headerlink" title="异步沟通是健康的协作方式"></a>异步沟通是健康的协作方式</h1><p>实时沟通会打断各自的计划, 能够以异步沟通完成的事, 千万不要去同步沟通.  </p><p>马斯克同样推崇异步沟通</p><p><a href="https://www.youtube.com/watch?v=kLscv2VAQEE">https://www.youtube.com/watch?v=kLscv2VAQEE</a></p><h1 id="给自己放个假"><a href="#给自己放个假" class="headerlink" title="给自己放个假"></a>给自己放个假</h1><p>软件类属创造性工作，而人类大脑又是世界上最复杂、最精密的仪器。</p><p>超时长工作并不会使得大脑变得更具创造性，因为每个机械师都知道零部件需要定期检查和维护。</p><p><strong>恐怕你也无法想象你的航空公司会告诉你某架次飞机会因为长期没有检修而飞得更快吧？</strong></p>]]></content>
    
    
    <categories>
      
      <category>life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>life</tag>
      
      <tag>workflow</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JPEG JPEG2000 WebP PNG GIF对比</title>
    <link href="/2022/bc4a75ff/"/>
    <url>/2022/bc4a75ff/</url>
    
    <content type="html"><![CDATA[<h1 id="图像的显示原理"><a href="#图像的显示原理" class="headerlink" title="图像的显示原理"></a>图像的显示原理</h1><h2 id="有损-x2F-无损压缩"><a href="#有损-x2F-无损压缩" class="headerlink" title="有损&#x2F;无损压缩"></a>有损&#x2F;无损压缩</h2><p>图片文件格式有可能会对图片的文件大小进行不同程度的压缩，图片的压缩分为有损压缩和无损压缩两种。</p><h3 id="有损压缩"><a href="#有损压缩" class="headerlink" title="有损压缩"></a>有损压缩</h3><p>对图像本身的改变，在保存图像时保留了较多的亮度信息，而将色相和色纯度的信息和周围的像素进行合并，合并的比例不同，压缩的比例也不同，由于信息量减少了，所以压缩比可以很高，图像质量也会相应的下降。并且这种损失是不可逆的，我们不可能从有一个有损压缩过的图片中恢复出全来的图片。常见的有损压缩手段，是按照一定的算法将临近的像素点进行合并。<br><strong>有损压缩的原理：</strong> <em>删除景物边缘的某些颜色部分，当人们在屏幕上观看这个场景图片，大脑会利用在景物上看到的颜色填补所丢失的颜色部分。</em><br><strong>有损压缩的优缺点：</strong> <em>是保持颜色的逐渐变化，删除图像中颜色的突然变化。生物学中的大量实验证明，人类大脑会利用与附近最接近的颜色来填补所丢失的颜色。例如，对于蓝色天空背景上的一朵白云，有损压缩的方法就是删除图像中景物边缘的某些颜色部分。当在·屏幕上看这幅图时，大脑会利用在景物上看到的颜色填补所丢失的颜色部分。利用有损压缩技术，某些数据被有意地删除了，而被取消的数据也不再恢复。 无可否认，利用有损压缩技术可以大大地压缩文件的数据，但是会影响图像质量。如果使用了有损压缩的图像仅在屏幕上显示，可能对图像质量影响不太大，至少对于人类眼睛的识别程度来说区别不大。可是，如果要把一幅经过有损压缩技术处理的图像用高分辨率打印机打印出来，那么图像质量就会有明显的受损痕迹。</em></p><h3 id="无损压缩"><a href="#无损压缩" class="headerlink" title="无损压缩"></a>无损压缩</h3><p>无损压缩的基本原理是相同的颜色信息只需保存一次。压缩图像的软件首先会确定图像中哪些区域是相同的，哪些是不同的。包括了重复数据的图像(如蓝天) 就可以被压缩，只有蓝天的起始点和终结点需要被记录下来。但是蓝色可能还会有不同的深浅，天空有时也可能被树木、山峰或其他的对象掩盖，这些就需要另外记录。从本质上看，无损压缩的方法可以删除一些重复数据，大大减少要在磁盘上保存的图像尺寸。但是，无损压缩的方法并不能减少图像的内存占用量，这是因为，当从磁盘上读取图像时，软件又会把丢失的像素用适当的颜色信息填充进来。如果要减少图像占用内存的容量，就必须使用有损压缩方法。<br><strong>无损压缩的特点：</strong> <em>相同的颜色信息只需保存一次。</em><br><strong>无损压缩的原理：</strong> <em>首先辨别出相同颜色的区域，然后把这些相同的数据信息进行压缩记录，也就是记录它的颜色信息、起始和终止位置。</em></p><h2 id="索引色-x2F-直接色"><a href="#索引色-x2F-直接色" class="headerlink" title="索引色&#x2F;直接色"></a>索引色&#x2F;直接色</h2><p>计算机在表示颜色的时候，有两种形式，一种称作索引颜色(Index Color)，一种称作直接颜色(Direct Color)。</p><h3 id="索引色。"><a href="#索引色。" class="headerlink" title="索引色。"></a>索引色。</h3><p>是一种以有限的方式管理数字图像颜色的技术，以节省计算机内存和文件存储，同时加速显示刷新和文件传输。即用一个数字来代表（索引）一种颜色，在存储图片的时候，存储一个数字的组合，同时存储数字到图片颜色的映射。这种方式只能存储有限种颜色，通常是256种颜色，对应到计算机系统中，使用一个字节的数字来索引一种颜色。</p><h3 id="直接色。"><a href="#直接色。" class="headerlink" title="直接色。"></a>直接色。</h3><p>使用四个数字来代表一种颜色，这四个数字分别代表这个颜色中红色、绿色、蓝色以及透明度（即rgba）。现在流行的显示设备可以在这四个维度分别支持256种变化，所以直接色可以表示2的32次方种颜色。当然并非所有的直接色都支持这么多种，为压缩空间使用，有可能只有表达红、绿、蓝的三个数字，每个数字也可能不支持256种变化之多</p><h2 id="位图-x2F-矢量图"><a href="#位图-x2F-矢量图" class="headerlink" title="位图&#x2F;矢量图"></a>位图&#x2F;矢量图</h2><h3 id="位图。"><a href="#位图。" class="headerlink" title="位图。"></a>位图。</h3><p>位图也叫做点阵图，栅格图像，像素图。简单的说，就是最小单位由像素构成的图，缩放会失真。构成位图的最小单位是像素，位图就是由像素阵列的排列来实现其显示效果的，每个像素有自己的颜色信息，在对位图图像进行编辑操作的时候，可操作的对象是每个像素，我们可以改变图像的色相、饱和度、明度，从而改变图像的显示效果。举个例子来说，位图图像就好比在巨大的沙盘上画好的画，当你从远处看的时候，画面细腻多彩，但是当你靠的非常近的时候，你就能看到组成画面的每粒沙子以及每个沙粒单纯的不可变化颜色。</p><h3 id="矢量图，"><a href="#矢量图，" class="headerlink" title="矢量图，"></a>矢量图，</h3><p>也叫做向量图。矢量图并不纪录画面上每一点的信息，而是纪录了元素形状及颜色的算法，当你打开一付矢量图的时候，软件对图形象对应的函数进行运算，将运算结果[图形的形状和颜色]显示给你看。无论显示画面是大还是小，画面上的对象对应的算法是不变的，所以，即使对画面进行倍数相当大的缩放，其显示效果仍然相同(不失真)。</p><h1 id="JPEG-JPEG2000-WebP"><a href="#JPEG-JPEG2000-WebP" class="headerlink" title="JPEG JPEG2000 WebP"></a>JPEG JPEG2000 WebP</h1><blockquote><p>  摘录自知乎: </p><p>  原文: <a href="https://zhuanlan.zhihu.com/p/19586108">https://zhuanlan.zhihu.com/p/19586108</a></p><p>  作者: <a href="https://www.zhihu.com/people/xhacker">柳东原</a> This Xhacker has super Big Cat power.</p></blockquote><p><strong>压缩性能综合看来，WebP 略好于 JPEG2000，而这两者都明显好于 JPEG。</strong></p><p>前段时间测试了一下这三种有损图像压缩算法的质量。（WebP 也能支持无损，不过这里只测试有损。）</p><p>测试结果（<a href="https://link.zhihu.com/?target=http://en.wikipedia.org/wiki/Structural_similarity">SSIM Index</a> 可理解为图片与原图片的相似度）：</p><p><img src="/2022/bc4a75ff/6dd37790364b1a5e709f8e67adab81d3_r.jpg" alt="img"></p><p><img src="/2022/bc4a75ff/868c8f801447ee85c0867556cdb1f705_r.jpg" alt="img"></p><p><img src="/2022/bc4a75ff/85ab2ef874126a10072e4669d9cd7c90_720w.jpg" alt="img"></p><p><img src="/2022/bc4a75ff/ea62d92a63b45aa121eb0ccfce4a97fd_720w.jpg" alt="img"></p><p><img src="/2022/bc4a75ff/6cdab6a9efdf3df3fba2657314d81734_720w.jpg" alt="img"></p><p><img src="/2022/bc4a75ff/323465387e562470441127b8f0cc992e_720w.jpg" alt="img"></p><p>测试细节：对于 JPEG 使用 libjpeg 压缩，JPEG 2000 使用 OpenJPEG，WebP 使用 libwebp。</p><h1 id="JPEG-PNG-GIF-WEBP"><a href="#JPEG-PNG-GIF-WEBP" class="headerlink" title="JPEG PNG GIF WEBP"></a>JPEG PNG GIF WEBP</h1><p><strong>综合看来</strong></p><ul><li>PNG 可以保存透明信息, 比较适合颜色单一, 主要是纯色的图像, ( logo&#x2F;icon&#x2F;透明图 )</li><li>JPEG 适用颜色种类多样 且颜色变化明显的图片 ( 一般照片 )</li><li>GIF 支持动画,透明, 只有8位颜色 ( 动图 )</li><li>WEBP 文件小, 支持透明, 有损无损压缩, 支持动画, 兼容性不好 ( 网页图像 )</li></ul><h2 id="JPEG"><a href="#JPEG" class="headerlink" title="JPEG"></a>JPEG</h2><p>JPEG是有损的、采用直接色的、位图。JPEG也是一种针对照片影像而广泛使用的有损压缩标准方法。JPEG图片格式的设计目标，是在不影响人类可分辨的图片质量的前提下，尽可能的压缩文件大小。这意味着JPEG去掉了一部分图片的原始信息，也即是进行了有损压缩。JPEG的图片的优点，是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，用来表达更生动的图像效果，比如颜色渐变。</p><ul><li>特性：适用于存储色彩丰富、层次分明的图片，不适合于线条绘图（drawing）和其他文字或图标（iconic）的图形，因为它的压缩方法用在这些类型的图形上，得到的结果并不好(PNG和GIF通常是用来存储这类的图形)</li></ul><h2 id="PNG"><a href="#PNG" class="headerlink" title="PNG"></a>PNG</h2><p>便携式网络图形是一种无损压缩的位图图形格式，支持索引、灰度、RGB三种颜色方案以及Alpha通道等特性</p><ul><li>特性：如果保存文本，线条或类似的边缘清晰，有大块相同颜色区域的图像，PNG格式的压缩效果就要比JPEG好很多，并且不会出现JPEG那样的高对比度区域的图像有损。如果图像既有清晰边缘，又有照片图像的特点，就需要在这两种格式之间权衡一下了。JPEG不支持透明度。<br>PNG格式有8位、24位、32位三种形式,其中8位PNG支持两种不同 的透明形式（索引透明和alpha透明）,24位PNG不支持透明,32位 PNG 在24位基础上增加了8位透明通道（32-24&#x3D;&#x3D;&#x3D;8）,因此可展现256级透明程度。</li></ul><h3 id="PNG8"><a href="#PNG8" class="headerlink" title="PNG8"></a>PNG8</h3><p>PNG8是<strong>无损的、使用索引色的、点阵图</strong>,支持不透明、索引透明、Alpha透明，都最多只能展示256（2的8次方）种颜色，所以“PNG8”格式更适合那些颜色比较单一的图像，例如纯色、logo、图标等；因为颜色数量少，所以图片的体积也会更小；</p><ul><li><p>PNG8(不透明),默认PNG8</p></li><li><p>PNG8(索引色透明),简单说可以理解为静态的GIF<br>指定一个像素点是不是透明<br>但是PNG由于算法的优势,体积比较少<br>所以,静态GIF完全可用PNG8取代</p></li><li><p>PNG8(Alpha透明),牛逼在可指定像素点的透明度,例如50%透明度<br>这种优点在于比PNG24&#x2F;32体积小,因为也只有256色嘛<br>缺点在于IE6支持不好,会把半透明的像素点显示成全透明</p></li></ul><h3 id="PNG24"><a href="#PNG24" class="headerlink" title="PNG24"></a>PNG24</h3><p>是PNG的直接色版本。PNG24是<strong>无损的、使用直接色的、点阵图</strong>,支持2的24次方种颜色，表现为不透明。用三个8bits分别去表示 R（红）、G（绿）、B（蓝）。R(0255),G(0255),B(0~255)，可以表达256乘以256乘以256&#x3D;16777216种颜色的图片，这样PNG24就能比PNG8表示色彩更丰富的图片,图片的清晰度也会更好，图片质量更高，当然图片的大小也会相应增加，所以“PNG24”的图片比较适合像摄影作品之类颜色比较丰富的图片<br>PNG24与JPG一样能表达丰富的图片细节，但并不能替代JPG。图片存储为PNG24比存储为JPG，文件大小至少是JPG的5倍，但在图片品质上的提升却微乎其微。所以除非对品质的要求极高，否则色彩丰富的网络图片还是推荐使用JPG</p><h3 id="PNG32"><a href="#PNG32" class="headerlink" title="PNG32"></a>PNG32</h3><p>支持2的32次方种颜色，32位是我们最常使用的格式，它是在PNG在24位的PNG基础上增加了8位的透明信息，支持不同程度的半透效果</p><h3 id="PNG8-PNG24-PNG32三者的区别在于："><a href="#PNG8-PNG24-PNG32三者的区别在于：" class="headerlink" title="PNG8\PNG24\PNG32三者的区别在于："></a>PNG8\PNG24\PNG32三者的区别在于：</h3><ul><li>PNG-32每个像素的深度为32bits，其中RGBA四个通道各占8bits。所谓的RGBA四个通道，就是红，绿，蓝，透明 这四种色值各自的大小，都用8bits来表示（0～255）。</li><li>PNG-24的像素深度为24bits，其中RGB三个通道各占8bits。</li><li>PNG-8则是使用8位的索引色。</li></ul><h2 id="GIF"><a href="#GIF" class="headerlink" title="GIF"></a>GIF</h2><p>GIF是一种<strong>无损、使用于索引色的、位图</strong>。由于采用了无损压缩，相比古老的bmp格式，尺寸较小，而且支持透明和动画。缺点是由于gif只存储8位索引（也就是最多能表达2^8&#x3D;256种颜色），色彩复杂、细节丰富的图片不适合保存为gif格式。色彩简单的logo、icon、线框图适合采用gif格式。</p><p>静态GIF完全可用PNG8取代</p><h2 id="WEBP"><a href="#WEBP" class="headerlink" title="WEBP"></a>WEBP</h2><p>WebP图片是一种同时提供了<strong>有损压缩与无损压缩、使用直接色的、位图</strong>，由Google开发。与png、jpg相比，相同的视觉体验下，WebP图像的尺寸缩小了大约30％。另外，WebP图像格式还支持有损压缩、无损压缩、透明和动画。理论上完全可以替代png、jpg、gif等图片格式，当然目前webp的还没有得到全面的支持。</p><p>WEBP与PNG压缩对比</p><p><img src="/2022/bc4a75ff/formatpng.png" alt="img"></p><p>可以得出结论：</p><blockquote><p>  PNG 转 WebP 的压缩率要高于 PNG 原图压缩率，同样支持有损与无损压缩<br>  转换后的 WebP 体积大幅减少，图片质量也得到保障（同时肉眼几乎无法看出差异）<br>  转换后的 WebP 支持 Alpha 透明和 24-bit 颜色数，不存在 PNG8 色彩不够丰富和在浏览器中可能会出现毛边的问题</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jpeg</tag>
      
      <tag>webp</tag>
      
      <tag>jpeg2000</tag>
      
      <tag>image</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件后缀与文件</title>
    <link href="/2022/631793c8/"/>
    <url>/2022/631793c8/</url>
    
    <content type="html"><![CDATA[<h1 id="文件后缀与文件"><a href="#文件后缀与文件" class="headerlink" title="文件后缀与文件"></a>文件后缀与文件</h1><table><thead><tr><th>后缀</th><th>名称描述</th><th>简述</th></tr></thead><tbody><tr><td><code>.DS_Store</code></td><td>Desktop Services Store</td><td>Mac OS X操作系统所创造的隐藏文件，类似<code>desktop.ini</code></td></tr></tbody></table><h2 id="编辑历史"><a href="#编辑历史" class="headerlink" title="编辑历史"></a>编辑历史</h2><table><thead><tr><th>date</th><th>note</th></tr></thead><tbody><tr><td>2022.9.15</td><td>First Version</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h2 id="DS-Store"><a href="#DS-Store" class="headerlink" title=".DS_Store"></a>.DS_Store</h2><blockquote><p>  DS_Store，英文全称是 Desktop Services Store（桌面服务存储），开头的 DS 是 Desktop Services（桌面服务） 的缩写。它是一种由macOS系统自动创建的隐藏文件，存在于每一个用「Finder」打开过的文件夹下面。</p><p>  <code>.DS_Store</code> 是一种由苹果公司的Mac OS X操作系统所创造的隐藏文件，目的在于存贮目录的自定义属性，例如文件们的图标位置或者是背景色的选择。该文件由<code>Finder</code>创建并维护，类似于<code>Microsoft Windows</code>中的<code>desktop.ini</code>文件。</p></blockquote><h2 id="RTF"><a href="#RTF" class="headerlink" title=".RTF"></a>.RTF</h2><blockquote><p>  <strong>富文本格式</strong>（<strong>Rich Text Format</strong>）即<strong>RTF格式</strong>，又称<strong>多文本格式</strong>，是由<a href="https://zh.wikipedia.org/wiki/%E5%BE%AE%E8%BD%AF">微软</a>公司开发的跨平台<a href="https://zh.wikipedia.org/wiki/%E6%96%87%E6%A1%A3">文档</a>格式。大多数的<a href="https://zh.wikipedia.org/wiki/%E6%96%87%E5%AD%97%E5%A4%84%E7%90%86">文字处理</a>软件都能读取和保存RTF文档。</p><h2 id="支持软件"><a href="#支持软件" class="headerlink" title="支持软件"></a>支持软件</h2><ul><li><a href="https://zh.wikipedia.org/wiki/WordPad">WordPad</a>（<a href="https://zh.wikipedia.org/wiki/Microsoft_Windows">Microsoft Windows</a>）&#x2F; <a href="https://zh.wikipedia.org/wiki/%E6%96%87%E5%AD%97%E7%B7%A8%E8%BC%AF_(%E6%87%89%E7%94%A8%E7%A8%8B%E5%BC%8F)">文本编辑</a>（<a href="https://zh.wikipedia.org/wiki/Mac_OS">Mac OS</a>）</li><li><a href="https://zh.wikipedia.org/wiki/Microsoft_Word">Microsoft Word</a></li><li><a href="https://zh.wikipedia.org/wiki/Apache_OpenOffice">Apache OpenOffice</a> &#x2F; <a href="https://zh.wikipedia.org/wiki/LibreOffice">LibreOffice</a></li><li><a href="https://zh.wikipedia.org/zh-cn/WPS_Office">WPS Office</a></li><li><a href="https://zh.wikipedia.org/wiki/EIOffice">EIOffice</a></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DS_Store</tag>
      
      <tag>rtf</tag>
      
      <tag>后缀</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zip Gzip Bzip2 Tar 的区别和差异</title>
    <link href="/2022/613d8edd/"/>
    <url>/2022/613d8edd/</url>
    
    <content type="html"><![CDATA[<h1 id="zip-gzip-bzip2-tar-命令的区别和差异"><a href="#zip-gzip-bzip2-tar-命令的区别和差异" class="headerlink" title="zip gzip bzip2 tar 命令的区别和差异"></a>zip gzip bzip2 tar 命令的区别和差异</h1><ul><li><code>gzip</code> 和 <code>bzip2</code>用于压缩单个文件。bzip2 比 gzip 具有更高的压缩率，同样的也会需要<strong>更多更多更多</strong>时间来进行压缩。</li><li><code>tar</code>格式的包只是将文件归档在一起, 并不会有任何压缩。</li><li><code>zip</code> 和 <code>tar</code> 命令用于压缩和归档文件夹。</li></ul><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>zip</td><td><code>.zip</code></td><td>可以压缩目录</td><td>源文件会保留</td><td>专门的压缩命令</td></tr><tr><td>gzip</td><td><code>.gz</code></td><td>只能压缩文件</td><td>压缩后源文件会被删除</td><td></td></tr><tr><td>bzip2</td><td><code>.bz2</code></td><td>只能压缩文件</td><td>加<code>-k</code>参数源文件可以保留</td><td></td></tr><tr><td>tar</td><td><code>.tar</code></td><td>可以压缩目录</td><td>源文件会保留</td><td>linux包大多是这形态<br>将目录打包成一个文件<code>Tape archive</code></td></tr><tr><td>xz</td><td><code>.xz</code></td><td></td><td></td><td></td></tr></tbody></table><h2 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h2><h2 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h2><p>该<code>gzip</code>程序用于压缩一个或多个文件。执行时，它将原始文件替换为原始文件的压缩版本。使用 gzip 压缩的文件具有扩展名<code>.gz</code></p><h2 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h2><p>该<code>bzip2</code>命令类似于 gzip，但使用不同的压缩算法，以牺牲压缩速度为代价归档更高级别的压缩。使用 bzip2 压缩的文件具有扩展名<code>.bz2</code></p><h2 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h2><p><code>tar</code>命令，首字母缩略词<em><strong>Tape archive</strong></em>用于创建存档文件。tar 存档可以由单独的文件、一个或多个目录层次结构或两者的混合组成。tar 文件有扩展名<code>.tar</code></p><h2 id="xz"><a href="#xz" class="headerlink" title="xz"></a>xz</h2><p><code>xz</code>是一个通用的数据压缩工具，命令行语法类似于 gzip 和 bzip2 。它根据选择的操作模式压缩或解压缩每个文件。用 xz 压缩的文件具有扩展名<code>.xz</code></p><h1 id="Zip-和-Unzip"><a href="#Zip-和-Unzip" class="headerlink" title="Zip 和 Unzip"></a>Zip 和 Unzip</h1><h2 id="zip-1"><a href="#zip-1" class="headerlink" title="zip"></a>zip</h2><p><strong>命令格式</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">zip [-r] [压缩后文件名] [文件或目录]<br></code></pre></td></tr></table></figure><p><strong>命令描述</strong></p><ul><li><code>zip</code>命令用来对文件进行打包操作。zip是个使用广泛的压缩程序，文件经它压缩后会另外产生具有“.zip”扩展名的压缩文件；</li><li>在linux压缩后的文件，基本都可以在Windows系统中解压；Windows中压缩的文件，在Linux中不一定可用，但是zip格式的压缩文件，可以做到可用；</li><li>zip的压缩比不是很高；</li></ul><p><strong>示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 压缩文件</span><br>$ zip a.zip a.txt<br><span class="hljs-comment"># 查看压缩后的文件</span><br>$ <span class="hljs-built_in">ls</span><br>a.txt  a.zip  <br><br><span class="hljs-comment"># 2. -r：压缩文件夹</span><br>$ zip -r test.zip testDir/<br>$ <span class="hljs-built_in">ls</span><br>testDir  test.zip<br><br><span class="hljs-comment"># 3. -x 排除文件</span><br>$ zip -r test2.zip testDir/ -x <span class="hljs-string">&quot;testDir/hello*&quot;</span> -x <span class="hljs-string">&quot;testDir/dir/*&quot;</span><br></code></pre></td></tr></table></figure><h2 id="unzip-解压"><a href="#unzip-解压" class="headerlink" title="unzip 解压"></a>unzip 解压</h2><p><strong>命令格式</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">unzip [选项] 文件名<br></code></pre></td></tr></table></figure><p><strong>命令描述</strong></p><p><code>unzip</code>命令用于解压缩由zip命令压缩的“.zip”压缩包。</p><p><strong>选项</strong></p><ul><li>-n：解压缩时不要覆盖原有的文件；</li><li>-o：不必先询问用户，unzip执行后覆盖原有的文件；</li><li>-d &lt;目录&gt;：指定文件解压缩后所要存储的目录(不指定目录，默认解压到当前目录)</li></ul><p><strong>示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 解压文件到家目录</span><br>$ unzip test.zip -d ~<br></code></pre></td></tr></table></figure><h1 id="Gzip-和-Gunzip"><a href="#Gzip-和-Gunzip" class="headerlink" title="Gzip 和 Gunzip"></a>Gzip 和 Gunzip</h1><h2 id="gzip-1"><a href="#gzip-1" class="headerlink" title="gzip"></a><strong>gzip</strong></h2><p><strong>命令格式</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">gzip [文件]<br></code></pre></td></tr></table></figure><p><strong>命令描述</strong></p><p><code>gzip</code>命令 用来压缩文件。gzip是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多处“<code>.gz</code>”扩展名。<code>gzip</code>只能压缩文件，不能压缩文件夹，压缩后原文件会被删除</p><p><code>gzip</code>是在Linux系统中经常使用的一个对文件进行压缩和解压缩的命令，既方便又好用。gzip不仅可以用来压缩大的、较少使用的文件以节省磁盘空间，还可以和tar命令一起构成Linux操作系统中比较流行的压缩文件格式。据统计，gzip命令对文本文件有60%～70%的压缩率。减少文件大小有两个明显的好处，一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间。</p><p><strong>示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 压缩文件</span><br>$ gzip a.txt<br><span class="hljs-comment"># 查看压缩后的文件，源文件被删除</span><br>$ <span class="hljs-built_in">ls</span><br>a.txt.gz<br></code></pre></td></tr></table></figure><h2 id="gunzip-解压"><a href="#gunzip-解压" class="headerlink" title="gunzip 解压"></a>gunzip 解压</h2><p><strong>命令格式</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">gzip [文件]<br></code></pre></td></tr></table></figure><p><strong>命令描述</strong></p><p><code>gunzip</code>命令用来解压缩文件。gunzip是个使用广泛的解压缩程序，它用于解开被gzip压缩过的文件，这些压缩文件预设最后的扩展名为<code>.gz</code>。</p><p><strong>示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 解压文件，解压后压缩文件被删除</span><br>$ gunzip a.txt.gz<br>$ <span class="hljs-built_in">ls</span><br>a.txt <br></code></pre></td></tr></table></figure><h1 id="Bzip2"><a href="#Bzip2" class="headerlink" title="Bzip2"></a>Bzip2</h1><h2 id="bzip2-1"><a href="#bzip2-1" class="headerlink" title="bzip2"></a>bzip2</h2><p><strong>命令格式</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">bzip2 [选项] [文件]<br></code></pre></td></tr></table></figure><p><strong>命令描述</strong></p><ul><li>bzip2命令用于压缩“<code>.bz2</code>”格式的压缩包，是<code>gzip</code>的升级版本，可以保留原文件；</li><li>bzip2的压缩比比较高，可用于压缩较大文件的压缩；</li><li>bzip2也是只对文件进行压缩，如果相对目录进行压缩的话，可以配合 <code>tar</code>命令使用，使用 <code>tar -jcvf</code> 文件名 完成打包压缩。</li></ul><p><strong>选项</strong></p><p>-k（keep）：保留原文件（不删除原文件）</p><p><strong>示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># bzip2 压缩文件</span><br>$ bzip2 -k a.txt<br>$ <span class="hljs-built_in">ls</span><br>a.txt  a.txt.bz2<br><br><span class="hljs-comment"># 配合使用tar 命令，完成打包压缩</span><br>$ <span class="hljs-built_in">mkdir</span> music<br>$ tar -jcvf music.tar.bz2 music/<br>$ <span class="hljs-built_in">ls</span><br>music  music.tar.bz2<br></code></pre></td></tr></table></figure><h2 id="bunzip2-解压"><a href="#bunzip2-解压" class="headerlink" title="bunzip2 解压"></a>bunzip2 解压</h2><p><strong>命令格式</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">bunzip2 [选项] [文件]<br></code></pre></td></tr></table></figure><p><strong>命令描述</strong></p><ul><li>解压缩“<code>.bz2</code>”格式的压缩文件；</li><li>gunzip的升级版，可以使用<code>-k</code>保留原文件；</li><li>可以配合使用tar命令，完成解压缩解包： <code>tar -jxvf 文件名</code></li></ul><p><strong>选项</strong></p><p>-k（keep）：保留原文件（不删除原文件）</p><p><strong>示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">ls</span><br>a.txt.bz2  music.tar.bz2<br><br><span class="hljs-comment"># 解压缩文件</span><br>$ bunzip2 -k a.txt.bz2<br>$ <span class="hljs-built_in">ls</span><br>a.txt  a.txt.bz2  music.tar.bz2<br><br><span class="hljs-comment"># 使用tar完成解压解包</span><br>$ tar -jxvf music.tar.bz2<br>$ <span class="hljs-built_in">ls</span><br>a.txt  a.txt.bz2  music  music.tar.bz2<br></code></pre></td></tr></table></figure><h1 id="tar-1"><a href="#tar-1" class="headerlink" title="tar"></a>tar</h1><h2 id="tar-2"><a href="#tar-2" class="headerlink" title="tar"></a>tar</h2><p><strong>命令格式</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">tar [选项] [压缩后文件名] [目录]<br></code></pre></td></tr></table></figure><p><strong>命令描述</strong></p><p>打包目录，将目录打包成一个文件，同时可以压缩，压缩后的拓展名为<code>.tar.gz</code>，这个拓展名在下载Linux相关安装包时很常见。</p><p>使用<code>tar</code>命令时，如果想要打包并压缩一个目录，可以有两种方法进行：</p><ol><li>先利用tar命令打包目录为一个文件，然后使用gzip压缩</li><li>直接利用tar命令打包并压缩 (简单方便，推荐使用)</li></ol><p>解压时也有两种方式：</p><ol><li>先使用gunzip解压缩，再使用tar解包</li><li>直接利用tar命令解压缩并解包 (简单方便，推荐使用)</li></ol><p><strong>选项</strong></p><ul><li>-c：打包(将所有文件变成一个文件 Create  a new archive)</li><li>-x：解包</li><li>-v：显示详细信息</li><li>-f：指定文件名</li><li>-z：打包同时压缩&#x2F;解压缩  ，gzip压缩</li><li>-j：生成压缩文件 ，bzip2压缩</li></ul><p><strong>示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 压缩</span><br>tar -zcvf movie2.tar.gz movie<br><span class="hljs-comment"># 解压</span><br>tar -zxvf movie2.tar.gz<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1、2为    打包压缩    的两种方法</span><br><span class="hljs-comment"># 1. 使用 tar -cvf 打包，然后使用gzip压缩</span><br>$ tar -cvf movie.tar movie/<br>$ <span class="hljs-built_in">ls</span><br>movie  movie.tar<br>$ gzip movie.tar<br>$ <span class="hljs-built_in">ls</span><br>movie  movie.tar.gz<br><br><span class="hljs-comment"># 2. 使用 tar -zcvf 打包并压缩</span><br>$ tar -zcvf movie2.tar.gz movie<br>$ <span class="hljs-built_in">ls</span><br>movie  movie2.tar.gz<br><br><span class="hljs-comment"># 3、4为     解压缩并解包     的两种方法</span><br><span class="hljs-comment"># 3. 先使用gunzip解压缩，然后 tar -xvf解包</span><br>$ gunzip movie.tar.gz<br>$ <span class="hljs-built_in">ls</span><br>movie2.tar.gz  movie.tar<br>$ tar -xvf movie.tar<br>movie/<br>$ <span class="hljs-built_in">ls</span><br>movie  movie2.tar.gz  movie.tar<br><br><span class="hljs-comment"># 4. 使用tar -zxvf 解压缩并解包</span><br>$ tar -zxvf movie2.tar.gz<br>$ <span class="hljs-built_in">ls</span><br>movie  movie2.tar.gz  movie.tar<br></code></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://techviewleo.com/compress-uncompress-files-tar-gzip-bzip2-xz-linux/">LPIC 101 – Compress and Uncompress Files Using tar, gzip, bzip2 and xz on Linux</a></p><p><a href="https://en.wikipedia.org/wiki/List_of_archive_formats#Comparison">List of archive formats</a></p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>zip</tag>
      
      <tag>gzip</tag>
      
      <tag>bzip</tag>
      
      <tag>tar</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MD5</title>
    <link href="/2022/45a589a3/"/>
    <url>/2022/45a589a3/</url>
    
    <content type="html"><![CDATA[<h1 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h1><p><strong>MD5消息摘要算法</strong>（英语：MD5 Message-Digest Algorithm），一种被广泛使用的<a href="https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A2%BC%E9%9B%9C%E6%B9%8A%E5%87%BD%E6%95%B8">密码散列函数</a>，可以产生出一个128位（16个字符(BYTES)）的散列值（hash value），用于确保信息传输完整一致。将<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE">数据</a>（如一段文字）运算变为另一固定长度值，是散列算法的基础原理。</p><p><strong>参考</strong></p><p><a href="https://zhuanlan.zhihu.com/p/121492822">MD5破解的几种方法</a></p><p><a href="https://en.wikipedia.org/wiki/MD5">Wiki MD5</a></p><h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><ul><li><p>不可逆向的</p><blockquote><p>  我们没办法把MD5码还原对应的原文。道理很简单，任意长度的数据经过MD5处理后，所包含的信息量已经大大减少，那是不可能再次还原成为原始信息的。</p></blockquote></li><li><p>原文中作一个小变化其散列也会发生巨大的变化</p><blockquote>  <figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-symbol">MD5</span>(<span class="hljs-string">&quot;The quick brown fox jumps over the lazy dog&quot;</span>)<br>= <span class="hljs-number">9</span>e107d9d372bb6826bd81d3542a419d6<br></code></pre></td></tr></table></figure><p>  比如用c取代d, 其MD5值发生了巨大的变化</p>  <figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-symbol">MD5</span>(<span class="hljs-string">&quot;The quick brown fox jumps over the lazy cog&quot;</span>)<br>= <span class="hljs-number">1055</span>d3e698d289f2af8663725127bd4b<br></code></pre></td></tr></table></figure></blockquote></li><li><p>已被破解</p><blockquote><p>  通俗点讲就是，可以找到一个A和一个B，使hash（A）&#x3D;hash（B），而真正有用的是给定一个A能得到B，使hash（A）&#x3D;hash（B），而王小云能做到这样</p></blockquote></li></ul><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>MD5 摘要已在<a href="https://en.wikipedia.org/wiki/Software">软件</a>世界中广泛使用，以确保传输的文件已完好无损地到达。例如，文件服务器通常会为文件提供预先计算的 MD5（称为<a href="https://en.wikipedia.org/wiki/Md5sum">md5sum</a>）<a href="https://en.wikipedia.org/wiki/Checksum">校验和</a>，以便用户可以将下载文件的校验和与其进行比较。</p><p><img src="/2022/45a589a3/350px-CPT-Hashing-File-Transmission.png" alt="350px-CPT-Hashing-File-Transmission.svg"></p><p>由于很容易产生 MD5 冲突，因此创建文件的人可能会创建具有相同校验和的第二个文件，因此该技术无法防止某些形式的恶意篡改。</p><p>在某些情况下，校验和是不可信的（例如，如果它是通过与下载文件相同的渠道获得的，他人可能修改了文件后再次修改了MD5，使得MD5并不可信），在这种情况下，MD5 只能提供错误检查功能：“它会识别损坏或不完整的下载，这变成下载较大文件时更有可能。”</p><h1 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h1><h2 id="穷举法-amp-字典法"><a href="#穷举法-amp-字典法" class="headerlink" title="穷举法&amp;字典法"></a>穷举法&amp;字典法</h2><p><strong>穷举法非常简单，就是不停地尝试各种字符的排列组合，看哪一个组合的MD5码能对上。</strong>可惜缺点是太耗费时间了。我们举个栗子，假设我们要破解一个6位大小写字母和数字混合的密码，那么一共有(26+26+10)<sup>6</sup> 种组合。这个数的大小超过500亿。</p><p>既然计算如此费时，能不能考虑<strong>把计算结果以映射表的形式存放起来，一个萝卜一个坑</strong>，一个原文对应着一个MD5码呢？可以呀！这就是传说中的“字典法”。将已知的MD5码查表，直接反查出原文。<strong>字典法体现了算法设计的“以空间换时间”的思想。</strong>缺点是比较耗费空间。不过现在硬盘的价格变得白菜价了，空间开销不算什么。</p><p><a href="https://www.cmd5.com/password.aspx">CMD5 反查网站</a></p><p><a href="https://www.somd5.com/">SMD5 反查网站</a></p><h2 id="哈希链表-amp-彩虹表法"><a href="#哈希链表-amp-彩虹表法" class="headerlink" title="哈希链表&amp;彩虹表法"></a>哈希链表&amp;彩虹表法</h2><blockquote><p>  如果说穷举法太耗费时间，字典法太耗费存储空间的话，我们能不能考虑在时间消耗和空间消耗之间折中呢？我们可以考虑用链表将一系列有意义的原文和MD5码串起来。</p><p>  要构造这样的链表，我们需要两个函数：哈希函数H(x)和衰减函数（reduction function）R(x)。哈希函数可以是MD5，也可以是其他的消息摘要算法。H(x)的值域是R(x)的定义域，R(x)的值域是H(x)的定义域。<strong>R(x)不是H(x)的反函数。</strong></p><p>  将一个原文不停地使用H(x)和R(x)交替进行运算k次，再将原文本身和运算结果以链表的形式串接起来，就可以得到结点个数为2k+1的链表。实际存放的时候只存放首端和末端两个原文即可。<strong>这种链表叫做“哈希链表”，体现了算法设计的“时空权衡”（Space and Time Tradeoffs）。</strong></p><p>  举个栗子，假设原文s&#x3D;abcabc，经过2次交替运算，得到以下的链表：</p><p>  abcabc-&gt;H(x)-&gt;3C8B0D7A-&gt;R(x)-&gt;eopmca-&gt;H(x)-&gt;7E9F216C-&gt;R(x)-&gt;rapper</p><p>  以上数据均为举例编造的，仅为说明原理使用。那我们存放这个链表的时候，只需要记录abcabc和rapper两个原文即可。</p><p>  假设我们要破解的摘要值（哈希链表的H(x)不一定是MD5算法，这里用更准确的说法代替MD5码）是7E9F216C，经过R(x)运算得到rapper，说明我们要寻找的原文就在以rapper为末端的哈希链表中。从首端开始经过多次运算，我们发现eopmca的摘要值就是7E9F216C。于是就反查出7E9F216C对应的原文是eopmca。</p><p>  <strong>如果在生成哈希链表的时候依次使用多个不一样的R(x)，此时的哈希链表就是“彩虹表”。</strong></p><p>  这里有已经计算好的彩虹表：<a href="https://link.zhihu.com/?target=http://project-rainbowcrack.com/table.htm">http://project-rainbowcrack.com</a></p></blockquote><h2 id="差分攻击"><a href="#差分攻击" class="headerlink" title="差分攻击"></a>差分攻击</h2><p>上面介绍的穷举法、字典法和彩虹表法都是暴力破解，适用于任何的消息摘要算法。</p><p>真正意义上MD5算法的破解，是2004年山东大学王小云教授提出的MD5碰撞方法。她所用到的方法正是差分攻击。</p><p><a href="https://www.sohu.com/a/501560600_121106869">她是这样的“中国密码女神”！</a> </p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>md5</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpaceDesk手机用作电脑屏幕</title>
    <link href="/2022/471570a6/"/>
    <url>/2022/471570a6/</url>
    
    <content type="html"><![CDATA[<h1 id="SpaceDesk"><a href="#SpaceDesk" class="headerlink" title="SpaceDesk"></a>SpaceDesk</h1><p>在windows主机上虚拟出一块屏幕, 通过网络传输到其他带屏设备上.</p><ul><li>投屏到手机支持触摸</li></ul><h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p><a href="https://www.spacedesk.net/">https://www.spacedesk.net/</a></p><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><h2 id="软件没有验证功能-不安全"><a href="#软件没有验证功能-不安全" class="headerlink" title="软件没有验证功能(不安全)"></a>软件没有验证功能(不安全)</h2><p>有一次在公司用手机客户端, 直接连接上了公司其他同事的电脑屏幕.</p><p>公司的网络ip是dhcp的无法固定, 而且网络质量并不好, 所以我选择电脑开热点 手机连电脑热点.</p><p>防火墙加规则,只允许热点网段的IP入站.</p><p><img src="/2022/471570a6/image-20220811195054454.png" alt="image-20220811195054454"></p><p><img src="/2022/471570a6/image-20220811194925793.png" alt="image-20220811194925793"></p>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>spacedesk</tag>
      
      <tag>投屏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Jlink 烧写SPI Flash存储芯片</title>
    <link href="/2022/fd90dc4c/"/>
    <url>/2022/fd90dc4c/</url>
    
    <content type="html"><![CDATA[<h1 id="使用Jlink-烧写SPI-Flash存储芯片"><a href="#使用Jlink-烧写SPI-Flash存储芯片" class="headerlink" title="使用Jlink 烧写SPI Flash存储芯片"></a>使用Jlink 烧写SPI Flash存储芯片</h1><p>参考:</p><p><a href="https://www.segger.com/products/debug-probes/j-link/tools/j-flash-spi/">https://www.segger.com/products/debug-probes/j-link/tools/j-flash-spi/</a></p><h1 id="硬件连接"><a href="#硬件连接" class="headerlink" title="硬件连接"></a>硬件连接</h1><h2 id="SPI-amp-Single"><a href="#SPI-amp-Single" class="headerlink" title="SPI &amp; Single"></a>SPI &amp; Single</h2><p><img src="/2022/fd90dc4c/formatpng.png" alt="img"></p><p><img src="/2022/fd90dc4c/pinout-spi-20-pin.gif" alt="引出线 spi 20 针"></p><h2 id="QSPI-amp-Quad"><a href="#QSPI-amp-Quad" class="headerlink" title="QSPI &amp; Quad"></a>QSPI &amp; Quad</h2><p><img src="/2022/fd90dc4c/pinout-qspi-20-pin.png" alt="img"></p><blockquote><p>  注意:</p><p>  这里要注意的一点，正版的Jlink仿真器1脚是输入引脚，是外部提供参考电平的，但由于现在大部分的JLink仿真器都是学习(dao)版的，1脚不是输入，而是3.3v的输出(并不确定也有可能是5V的, 盗版的Jlink真的是什么乱七八糟的都有)，所以正常情况下可以直接用这个管教来给SPI Flash供电。</p><p>  <strong>关于 nRESET 的注意事项</strong>：如果有另一个设备&#x2F;外围设备也控制 SPI 闪存（例如闪存连接到的 CPU），则 J-Link 的 nRESET 应连接到目标系统的复位或 CPU 的复位引脚确保 J-Link 可以在对 SPI 闪存进行编程时保持 CPU 处于复位状态。</p><p>  <strong>一开始没注意到这个功能, 现在回过头来再看, 有这个功能之后烧芯片简直不要太简单, 根本不需要拆芯片了, 直接用芯片夹就可以烧录了.</strong></p></blockquote><h1 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h1><p>安装Jlink套件的时候会自带<code>JFlashSPI.exe</code>在开始菜单名称应该类似<code>J-Flash SPI</code>, 这是J-Flash的GUI程序,还有一个命令行的不多做介绍.</p><blockquote><p>  如果没有找到自带的, 请更新Jlink套件, 旧版确实不带这个东西.</p><p>  Segger Jlink套件下载链接 <a href="https://www.segger.com/downloads/jlink/">https://www.segger.com/downloads/jlink/</a></p></blockquote><p><img src="/2022/fd90dc4c/image-20220826224742256.png" alt="image-20220826224742256"></p><p>点击<code>target -&gt; connet</code>连接到Jlink, 它会自动检测大部分SPI闪存, </p><blockquote><p>  有时候识别的具体型号并不准确, 但是这不重要他们参数类似, 可以正常完成编程的工作.</p><p>  Jlink支持的SPI Flash型号可以在<a href="https://www.segger.com/products/debug-probes/j-link/technology/cpus-and-devices/supported-spi-flashes/">点击这里</a>找到.</p></blockquote><p>点击<code>file -&gt; open data file </code>我们打开要烧录的文件.</p><blockquote><p>  bin 文件需要设定起始地址</p><p>  hex文件自带了位置信息</p></blockquote><p>点击<code>target -&gt; auto</code>可以自动将文件烧录进去 还会进行读回校验.</p><p>至此烧录完成.</p><p><strong>Tips:</strong></p><blockquote><p>  点击<code>target -&gt; read back</code> 可以将SPI Flash内的数据读取出来<br>  点击<code>options -&gt; settings -&gt; setup -&gt; interface speed</code>可以修改时钟速度. </p></blockquote><p><strong>Other:</strong></p><p>Jlink真的是超级牛的工具, J-Scope, RTT这些都很好用, 还有很多高级功能我还没用上.<br>我前面有写过RTT的笔记, 在调试一个项目的时候没法使用串口, 当时就是用RTT搭建了一个log平台.</p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="winbood-W25Q128封装"><a href="#winbood-W25Q128封装" class="headerlink" title="winbood W25Q128封装"></a>winbood W25Q128封装</h2><p><img src="/2022/fd90dc4c/image-20220826104542006.png" alt="image-20220826104542006"></p><p><img src="/2022/fd90dc4c/20210622091839750557.png" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spi</tag>
      
      <tag>j-link</tag>
      
      <tag>flash</tag>
      
      <tag>j-tag</tag>
      
      <tag>jlink</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tags Label Category</title>
    <link href="/2022/c65e1067/"/>
    <url>/2022/c65e1067/</url>
    
    <content type="html"><![CDATA[<p>知乎  <a href="https://www.zhihu.com/people/songvision">千鸟</a></p><blockquote><p>  这问题要分两个层面来解读：</p><p>  <strong>首先是Tag与Category的区别。</strong>Category往往限制在一个维度里，当树状结构复杂到不可调和时，出现瓶颈是迟早的事。Category的问题在于，既不能完全满足用户需求，也不能完全表达创建者对内容属性的认知。而Tag反之都成立，完全互补。</p><p>  <strong>其次是Label与Tag的区别。</strong>于对内容的概括出现偏差，但显然这种问题不是tag，在内容组织范畴那应该是什么？答案就是label，除产品描述，其应用范畴还涉及功能名称、模块名称、导航名称、引导文字等等场景。我认为tag与label之间有三个显著差异：</p><ol><li>label是本身的，tag是附加的；</li><li>label强调是一种标志，tag强调是一种记号；</li><li>label标明信息之间的归属，tag区别信息之间的差异。</li></ol></blockquote><p>知乎 郑讯</p><blockquote><p>  Tag，标签，一般包含一段内容的属性，可以是分类，可以是话题，也可以是作者，地理信息等。</p><p>  Label，标记，是网页框架中一个区域的功能概括。比如知乎首页上的“浏览”、“问题”、“通知”就是label。选择不同的标记，相应区域的功能就会发生变化。</p><p>  category，分类，可以理解为种属概念。一段内容有且只有一个种属的分类。和Tag不同的是一段内容可以有多个tag，并且tag是未预先设定的，一段内容可以有多个Tag，也可以没有Tag。但caterory在一个分类标准下只有一个。</p></blockquote><p>知乎 李楠</p><blockquote><p>  <strong>Category</strong></p><p>  Category 是非常理想化和一根筋的分类方式。图书馆这种死板到头的地方用的多。但是他们也遇到了问题：“苏菲的世界”到底是“哲学”，还是“文学”？</p><p>  物理世界无力从根本上解决这种问题（但似乎不少讨论）。问过我们学校的图书馆，似乎他们方式还比较靠谱：<strong>买两本，两处放。</strong></p><p>  分类对象数字化之后， Category 的影响还在（早期的门户找点跨界的东西就很悲剧）。直到 Web2.0 ， Tag 竟然才开始流行。</p><p>  <strong>Tag</strong></p><p>  Tag 是更好的分类方式的原因是：</p><p>  1</p><p>  “类别”本来就不应该事先定义：人不是上帝。</p><p>  从一个个具体对象的“属性”中，总结出“类别”是最自然的模式。也是“人”可以做到的事情。</p><p>  2</p><p>  “属性”本来就应该可以自然的表现为多个。</p><p>  苏菲的世界终于可以自然的打上“哲学”和“文学”的 Tag 了，或者再加个“少儿读物”。这种思考方式比 Category 优雅太多。</p><p>  Tag 最终普及，背后恐怕有<a href="https://www.zhihu.com/search?q=%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:12226710%7D">软件工程</a>上 OO 普及（面向对象）的因素。<strong>“面向对象”不仅仅是的程序构建方式，更是认识世界的方法论的进步。</strong></p><p>  “属性”跟随“对象”，比“对象”属于“类别”更自然，不机械。 。</p><p>  <strong>Tag 的改进</strong></p><p>  Tag 本身也可以看作“对象”。</p><p>  那么就有针对 Tag 的操作，比如“搜索”，“排序”，“关联对象”。也有 Tag 本身的属性，比如“使用次数”，“关注人数”等等。</p><p>  如何能在使用 Tag 的系统中，根据这些数据，计算出最适合的对象，就要靠算法的优化和运营的调整了。</p></blockquote><p>知乎 <a href="https://www.zhihu.com/people/zheng-wei-42-9">榆木脑袋</a></p><blockquote><p>  Catagory是逻辑清晰的。Tag是随意自由的。在看到一个信息的时候我们需要自由捕获自己头脑中的闪光。在重新审视或再利用我们收集的信息时，就需要清晰的逻辑条理。</p><p>  以文件管理为例：</p><p>  在标记Tag时需求有二：一是能够方便增加新的Tag，二是能够很方便的看到已有的Tag，并能同时把已有标签赋予当前信息。</p><p>  在查找文件时个人觉得需要有的功能是：一是有固定的几个入口，也就是根目录；二是可以增加根节点；三是根目录可以指定某几个Tag，也可以不是；三如果根目录不是Tag，需要定义关联到此根目录（分类）下的Tag；四（重点功能）根目录下不直接列出信息或文件（时间长了，某一Tag下文件会相当多），而是列出关联Tag的所有文件的其它Tag，显示为子目录，并标识出此子目录中的文件数量。五（作为管理功能）此时可以定义哪些Tag不在此根目录下出现。六设置某个Tag或某类Tag(文件数量大过一个数量)下仍不列出文件而是继续列出Tag；七子目录（Tag）下，上级目录Tag不再出现。</p><p>  我个人非常偏好使用树形目录结构，但苦恼于文件的多重分类和文件进行多重分类时的繁琐。经过多方搜索只找到三个比较符合的软件，一个是PinKM，一个是蓝码动力图片管理软件，一个是国外的Tabbles。但都因标签管理和整理的繁琐而放弃。</p></blockquote><p><strong>个人理解</strong></p><ul><li>Catagory 是属于严格的分类方法, 一个东西应当只属于一个Catagory内, 而且它是有层级关系的</li><li>Tags 是可有可无的, 一个东西可以有很多的Tags, 它是无层级关系的,</li></ul>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tags</tag>
      
      <tag>label</tag>
      
      <tag>category</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>静态网页 静态博客</title>
    <link href="/2022/f96c3c41/"/>
    <url>/2022/f96c3c41/</url>
    
    <content type="html"><![CDATA[<h1 id="静态网页"><a href="#静态网页" class="headerlink" title="静态网页"></a>静态网页</h1><h1 id="静态网页生成器"><a href="#静态网页生成器" class="headerlink" title="静态网页生成器"></a>静态网页生成器</h1><p><a href="https://jekyllrb.com/">Jekyll</a>（由 Github 构建的用于为其 Github 页面提供支持的 Ruby 生成器）、</p><p><a href="https://gohugo.io/">Hugo</a>（构建在 Go 编程之上的极快静态生成器）语言）和</p><p><a href="https://hexo.io/">Hexo</a>（基于 Node.js 的快速网站生成器）。</p><p><strong>参考</strong></p><p><a href="https://www.techiediaries.com/jekyll-hugo-hexo/">How to Choose the Right Static Generator: Jekyll vs. Hugo vs. Hexo</a></p><p><a href="https://stackshare.io/stackups/hexo-vs-hugo-vs-jekyll">StackShare</a></p><h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><p>TBD</p><h2 id="Jekyll"><a href="#Jekyll" class="headerlink" title="Jekyll"></a>Jekyll</h2><p>TBD</p><h2 id="Hugo"><a href="#Hugo" class="headerlink" title="Hugo"></a>Hugo</h2><p>TBD</p><h1 id="Hexo-1"><a href="#Hexo-1" class="headerlink" title="Hexo"></a>Hexo</h1><h2 id="Hexo-部署"><a href="#Hexo-部署" class="headerlink" title="Hexo 部署"></a>Hexo 部署</h2><p><a href="https://hexo.io/zh-cn/docs/">HEXO文档_参考链接</a></p><p><strong>要求:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">Node.js (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)<br>Git<br></code></pre></td></tr></table></figure><p><strong>部署:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-cli -g<br>hexo init blog<br><span class="hljs-built_in">cd</span> blog<br>npm install<br>hexo server<br></code></pre></td></tr></table></figure><h2 id="Hexo-CMD"><a href="#Hexo-CMD" class="headerlink" title="Hexo CMD"></a>Hexo CMD</h2><h3 id="Init-初始化"><a href="#Init-初始化" class="headerlink" title="Init 初始化"></a>Init 初始化</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init [folder]<br></code></pre></td></tr></table></figure><p>新建一个网站。如果没有设置 <code>folder</code> ，Hexo 默认在目前的文件夹建立网站。</p><h3 id="new-新建"><a href="#new-新建" class="headerlink" title="new 新建"></a>new 新建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new [layout] &lt;title&gt;<br>hexo new <span class="hljs-string">&quot;post title with whitespace&quot;</span><br>hexo new page --path about/me <span class="hljs-string">&quot;About me&quot;</span><br>hexo new page -p     about/me <span class="hljs-string">&quot;About me&quot;</span><br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>, <code>--path</code></td><td align="left">自定义新文章的路径</td></tr><tr><td align="left"><code>-r</code>, <code>--replace</code></td><td align="left">如果存在同名文章，将其替换</td></tr><tr><td align="left"><code>-s</code>, <code>--slug</code></td><td align="left">文章的 Slug，作为新文章的文件名和发布后的 URL</td></tr></tbody></table><h3 id="generate-生成"><a href="#generate-生成" class="headerlink" title="generate 生成"></a>generate 生成</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 生成静态文件。</span><br>hexo generate<br><span class="hljs-comment"># 该命令可以简写为</span><br>hexo g<br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">选项</th><th></th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">-d</td><td>–deploy</td><td align="left"><strong>文件生成后立即部署网站</strong></td></tr><tr><td align="left">-w</td><td>–watch</td><td align="left"><strong>监视文件变动</strong></td></tr><tr><td align="left">-b</td><td>–bail</td><td align="left">生成过程中如果发生任何未处理的异常则抛出异常</td></tr><tr><td align="left">-f</td><td>–force</td><td align="left">强制重新生成文件 Hexo 引入了差分机制，<br>如果 <code>public</code> 目录存在，那么 <code>hexo g</code> 只会重新生成改动的文件。<br/>使用该参数的效果接近 <code>hexo clean &amp;&amp; hexo generate</code></td></tr><tr><td align="left">-c</td><td>–concurrency</td><td align="left">最大同时生成文件的数量，默认无限制</td></tr></tbody></table><h3 id="publish-草稿"><a href="#publish-草稿" class="headerlink" title="publish 草稿"></a>publish 草稿</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">hexo publish [layout] <span class="hljs-tag">&lt;<span class="hljs-name">filename</span>&gt;</span><br></code></pre></td></tr></table></figure><p>发表草稿。</p><h3 id="server-服务器"><a href="#server-服务器" class="headerlink" title="server 服务器"></a>server 服务器</h3><p>在服务器启动期间，Hexo 会监视文件变动并自动更新，您无须重启服务器。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta">hexo <span class="hljs-keyword">server</span><br>hexo s<br></code></pre></td></tr></table></figure><p>启动服务器。默认情况下，访问网址为： <code>http://localhost:4000/</code>。</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>, <code>--port</code></td><td align="left">重设端口</td></tr><tr><td align="left"><code>-s</code>, <code>--static</code></td><td align="left">只使用静态文件(不会更新)</td></tr><tr><td align="left"><code>-l</code>, <code>--log</code></td><td align="left">启动日记记录，使用覆盖记录格式</td></tr><tr><td align="left"><code>-i</code></td><td align="left"><code>hexo server -i 192.168.1.1</code> 指定监听的IP</td></tr></tbody></table><h3 id="deploy-部署"><a href="#deploy-部署" class="headerlink" title="deploy 部署"></a>deploy 部署</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment"># 部署网站。</span><br>hexo <span class="hljs-keyword">deploy</span><br><span class="hljs-comment"># 该命令可以简写为：</span><br>hexo d<br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-g</code>, <code>--generate</code></td><td align="left">部署之前预先生成静态文件</td></tr></tbody></table><h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prolog">hexo render &lt;file1&gt; [file2] ...<br></code></pre></td></tr></table></figure><p>渲染文件。</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-o</code>, <code>--output</code></td><td align="left">设置输出路径</td></tr></tbody></table><h3 id="migrate"><a href="#migrate" class="headerlink" title="migrate"></a>migrate</h3><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">hexo</span> migrate &lt;<span class="hljs-keyword">type</span>&gt;<br></code></pre></td></tr></table></figure><p>从其他博客系统 <a href="https://hexo.io/zh-cn/docs/migration">迁移内容</a>。</p><h3 id="clean-清理"><a href="#clean-清理" class="headerlink" title="clean 清理"></a>clean 清理</h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>hexo clean<br></code></pre></td></tr></table></figure><p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p><p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>hexo list &lt;<span class="hljs-keyword">type</span>&gt;<br></code></pre></td></tr></table></figure><p>列出网站资料。</p><h2 id="Hexo-Config-yml"><a href="#Hexo-Config-yml" class="headerlink" title="Hexo _Config.yml"></a>Hexo _Config.yml</h2><blockquote><h3 id="Home-page-setting"><a href="#Home-page-setting" class="headerlink" title="Home page setting"></a>Home page setting</h3><p>  <code>index_generator.order_by</code>  文章的顺序</p><ul><li><code>-date</code> 默认情况下按日期降序排序(从新到旧)。</li><li><code>-update</code> 按更新时间排序(<code>-</code> &#x3D; 从新到旧)。</li></ul></blockquote><h1 id="Hexo-Theme"><a href="#Hexo-Theme" class="headerlink" title="Hexo Theme"></a>Hexo Theme</h1><p>我是直接在github搜索 <code>hexo theme</code>看到了几个 star 比较多而且比较活跃的 repository </p><ul><li><p><strong><a href="https://github.com/ppoffice/hexo-theme-icarus">icarus</a></strong> 5.5K star</p><p><img src="/2022/f96c3c41/68747470733a2f2f70706f66666963652e6769746875622e696f2f6865786f2d7468656d652d6963617275732f67616c6c6572792f707265766965772e706e673f31.png" alt="img"></p></li><li><p><strong><a href="https://github.com/fluid-dev/hexo-theme-fluid">fluid</a></strong> 4.8K star</p><p><img src="/2022/f96c3c41/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666c7569642d6465762f737461746963406d61737465722f6865786f2d7468656d652d666c7569642f73637265656e73686f74732f696e6465782e706e67.png" alt="ScreenShot"></p></li><li><p><a href="https://github.com/blinkfox/hexo-theme-matery">matery</a>(blinkfox) 4.5K star</p><p><img src="/2022/f96c3c41/687474703a2f2f7374617469632e626c696e6b666f782e636f6d2f6d61746572792d32303138313230322d312e706e67.png" alt="首页"></p><p><img src="/2022/f96c3c41/687474703a2f2f7374617469632e626c696e6b666f782e636f6d2f6d61746572792d32303138313230322d332e706e67.png" alt="首页文章列表"></p></li><li><p><strong><a href="https://github.com/jerryc127/hexo-theme-butterfly">butterfly</a></strong> 4.3K star</p><p><img src="/2022/f96c3c41/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f6a65727279633132372f43444e406d322f696d672f7468656d652d627574746572666c792d726561646d652e706e67.png" alt="img"></p></li><li><p><a href="https://github.com/volantis-x/hexo-theme-volantis">volantis</a> 1.5k star</p><p><img src="/2022/f96c3c41/68747470733a2f2f692e6c6f6c692e6e65742f323032302f30332f31382f663550516c576973766d397a62674b2e6a7067.jpeg" alt="img"></p><p><img src="/2022/f96c3c41/68747470733a2f2f692e6c6f6c692e6e65742f323032302f30332f31382f585742476639354532743162646e6c2e6a7067.jpeg" alt="img"></p></li></ul><p>其中 <code>fluid</code> 和 <code>volantis</code> 最对我胃口, 最后选择的 <code>fluid</code>, 后期可能会改成<code>volantis</code>或者<code>icarus</code>试试看, 主要是喜欢简洁些, 又能有一定的观赏性的.</p><h2 id="Fluid"><a href="#Fluid" class="headerlink" title="Fluid"></a>Fluid</h2><p>参考文档</p><p><a href="https://hexo.fluid-dev.com/docs/guide/">https://hexo.fluid-dev.com/docs/guide/</a></p><p>theme 的 Github</p><p><a href="https://github.com/fluid-dev/hexo-theme-fluid">https://github.com/fluid-dev/hexo-theme-fluid</a></p><h3 id="自带的内置图标库"><a href="#自带的内置图标库" class="headerlink" title="自带的内置图标库"></a>自带的内置图标库</h3><p><a href="https://hexo.fluid-dev.com/docs/icon/#%E5%86%85%E7%BD%AE%E7%A4%BE%E4%BA%A4%E5%9B%BE%E6%A0%87">内置社交图标</a> </p><p><img src="/2022/f96c3c41/iconfont.f8319467.png" alt="内置图标"></p><h1 id="Hexo-Note"><a href="#Hexo-Note" class="headerlink" title="Hexo Note"></a>Hexo Note</h1><h2 id="Hexo-Permalink简化"><a href="#Hexo-Permalink简化" class="headerlink" title="Hexo Permalink简化"></a>Hexo Permalink简化</h2><p>参考:</p><p><a href="https://blog.csdn.net/Galahadzhou/article/details/105355733">Hexo Permalink简化</a></p><p>Note:</p><p>使用<code>hexo-abbrlink</code>插件实现</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># install</span><br>npm install hexo-abbrlink --save<br><span class="hljs-comment"># setting edit _config.yml</span><br>permalink: posts/:abbrlink.html<br>abbrlink:<br>  alg: crc32  <span class="hljs-comment"># 算法：crc16(default) and crc32</span><br>  rep: hex    <span class="hljs-comment"># 进制：dec(default) and hex</span><br><br></code></pre></td></tr></table></figure><h2 id="hexo-图片链接问题"><a href="#hexo-图片链接问题" class="headerlink" title="hexo 图片链接问题"></a>hexo 图片链接问题</h2><p><strong><code>hexo</code>本地图片显示问题</strong></p><p>使用<code>hexo</code>生成静态资源后,由于<code>url</code>的问题会出现图片加载的问题,现在网上的文章及官方的解决方案大概分为三种:</p><ol><li>将图片放入<code>source/images</code>目录下,每次<code>generate</code>都会生成图片,在使用相对或绝对路径进行引用</li><li>配置<code>hexo</code>的<code>_config.yml</code>文件, 将 <code>post_asset_folder</code> 设置为<code>true</code>, 这样每次new 生成一个文章时都会同步生成一个同名的文件夹,然后设置相对或绝对路径. </li><li>使用<code>hexo</code>官方的解决方案,使用模版变量, <code>&#123;% asset_img slug [title] %&#125; </code> </li><li>!new!. <code>hexo init</code>的时候会自动copy一个插件 <code>hexo-renderer-marked</code> 这个插件可以开启相对路径的支持,但是需要改一些代码</li></ol><p>但是在配置过程中发现这三种方式都多多少少存在一些问题,前两中首页跟内容页会有一个加载失败的问题,而第三种则失去了<code>markdown</code>的意义.</p><p><strong>方法四:</strong></p><p>官方手册上提到过, <a href="https://github.com/hexojs/hexo-renderer-marked">hexo-renderer-marked</a> 3.1.0已经开始支持相对路径了.但是可以看到它支持的路径似乎并不合理, 其他的md阅读器是不能识别这样的路径的.</p><p><img src="/2022/f96c3c41/image-20220815153651988.png" alt="image-20220815153651988"></p><p>参考: <a href="https://github.com/hexojs/hexo-renderer-marked/issues/216">https://github.com/hexojs/hexo-renderer-marked/issues/216</a></p><ol><li><p>修改<code>_config.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">marked:</span><br>  <span class="hljs-attr">prependRoot:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">postAsset:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li><li><p>修改文件<code>node_modules\hexo-renderer-marked\lib\renderer.js</code></p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (!<span class="hljs-regexp">/^(#|\/\/|http(s)?:)/</span>.<span class="hljs-title function_">test</span>(href) &amp;&amp; !relative_link &amp;&amp; prependRoot) &#123;<br>  <span class="hljs-keyword">if</span> (!href.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;/&#x27;</span>) &amp;&amp; !href.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;\\&#x27;</span>) &amp;&amp; postPath) &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title class_">PostAsset</span> = hexo.<span class="hljs-title function_">model</span>(<span class="hljs-string">&#x27;PostAsset&#x27;</span>);<br>    <span class="hljs-comment">// findById requires forward slash</span><br>    <span class="hljs-comment">// ***************** Add the following code *******************</span><br>    <span class="hljs-keyword">const</span> fixPostPath = <span class="hljs-title function_">join</span>(postPath, <span class="hljs-string">&#x27;../&#x27;</span>);<br>    <span class="hljs-keyword">const</span> asset = <span class="hljs-title class_">PostAsset</span>.<span class="hljs-title function_">findById</span>(<span class="hljs-title function_">join</span>(fixPostPath, href.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\\/g</span>, <span class="hljs-string">&#x27;/&#x27;</span>)));<br>    <span class="hljs-comment">// const asset = PostAsset.findById(join(postPath, href.replace(/\\/g, &#x27;/&#x27;)));</span><br>    <span class="hljs-comment">// ************************** End *****************************</span><br>    <span class="hljs-comment">// asset.path is backward slash in Windows</span><br>    <span class="hljs-keyword">if</span> (asset) href = asset.<span class="hljs-property">path</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\\/g</span>, <span class="hljs-string">&#x27;/&#x27;</span>);<br>  &#125;<br>  href = url_for.<span class="hljs-title function_">call</span>(hexo, href);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>enjoy it</li></ol><p><strong>方法二:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"># 设置<br><span class="hljs-attr">post_asset_folder</span>:<span class="hljs-literal">true</span><br># 安装插件 asset-image<br>npm install <span class="hljs-attr">https</span>:<span class="hljs-comment">//github.com/CodeFalling/hexo-asset-image  --save</span><br># typora中设置图片为相对路径 看下图<br>./$&#123;filename&#125;<br># 运行查看<br>hexo clean &amp;&amp; hexo generate &amp;&amp; hexo s <br></code></pre></td></tr></table></figure><p><img src="/2022/f96c3c41/image-20220815133503275.png" alt="image-20220815133503275"></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><blockquote><p>   Env:使用方法四</p><ul><li>文件名不能带有空格, title 可以带空格 (<code>hexo new</code>的时候需要注意这一点)<ul><li>修改 <code>node_modules\hexo-renderer-marked\lib\renderer.js</code>文件可能可以改善这点. -&gt; TBD</li></ul></li><li>md文件名要和图片等等资源文件夹同名 -&gt; 注定了不能使用 <code>./$&#123;filename&#125;.assets</code>这种方案, 一定要改成<code>./$&#123;filename&#125;</code>才行</li></ul></blockquote><h2 id="Hexo-跳过一些文件-不渲染某些文件"><a href="#Hexo-跳过一些文件-不渲染某些文件" class="headerlink" title="Hexo 跳过一些文件,不渲染某些文件"></a>Hexo 跳过一些文件,不渲染某些文件</h2><p>搜索引擎确认网站所有权时往往会提供一个html文件来进行验证，要是这个文件被渲染了，验证自然就会失败了。或者，有时候会写一些简单的html示例页面或<code>README.md</code>，这也是不希望Hexo渲染的。因此有必要针对某个文件或者目录进行排除。</p><p>Hexo博客的基本内容是一些Markdown文件，放在<code>source/_post</code>文件夹下，每个文件对应一篇文章。除此之外，放在<code>source</code>文件夹下的所有开头不是下划线的文件，在<code>hexo generate</code>的时候，都会被拷贝到<code>public</code>文件夹下。但是，Hexo默认会渲染所有的HTML和Markdown文件，导致我的README.md直接转成html格式了。。。</p><p>怎么样避开这个坑呢？如果只有一个HTML文件的话，可以简单地在文件开头加上<code>layout: false</code>一行即可：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">layout:</span> <span class="hljs-literal">false</span><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-string">&lt;html&gt;</span><br><span class="hljs-string">...</span><br></code></pre></td></tr></table></figure><p>如果有多个要避开渲染的md文件，显然是不可能使用这种方法的。这时候需要使用<code>skip_render</code>配置。根据<a href="https://hexo.io/zh-cn/docs/configuration.html">Hexo文档</a>中的说明，通过在<code>_config.yml</code>配置文件中使用<code>skip_render</code>参数，可以跳过指定文件的渲染。使用方式如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">skip_render: [games<span class="hljs-regexp">/**, depview/</span>**, knowledge/**]<br></code></pre></td></tr></table></figure><p>这里的路径匹配可以使用正则表达式。</p><p><strong>注意：<code>skip_render</code>参数设置的路径是相对于<code>source</code>目录的路径。</strong>例如，需要跳过渲染source&#x2F;README.md，只需要设置 <code>skip_render:README.md</code>。</p><p>在设置了跳过渲染之后，最好使用<code>hexo clean</code>清除以前的编译结果，保证配置生效。</p><h2 id="hexo-开启RSS订阅-feed-atom"><a href="#hexo-开启RSS订阅-feed-atom" class="headerlink" title="hexo 开启RSS订阅 feed atom"></a>hexo 开启RSS订阅 feed atom</h2><p>基于<code>hexo-generator-feed</code></p><p>先安装这个包:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-generator-feed<br></code></pre></td></tr></table></figure><p>然后在在<code>_config.yml</code>文件中配置该插件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feed:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">atom</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">atom.xml</span><br>    <span class="hljs-attr">limit:</span> <span class="hljs-number">20</span><br>    <span class="hljs-attr">hub:</span><br>    <span class="hljs-attr">content:</span><br>    <span class="hljs-attr">content_limit:</span><br>    <span class="hljs-attr">content_limit_delim:</span> <span class="hljs-string">&#x27; &#x27;</span><br>    <span class="hljs-attr">order_by:</span> <span class="hljs-string">-date</span><br>    <span class="hljs-attr">icon:</span> <span class="hljs-string">/images/favicon.png</span><br></code></pre></td></tr></table></figure><blockquote><p>  参数的含义：</p><ul><li><code>type</code>: <code>RSS</code>的类型(<code>atom/rss2</code>)</li><li><code>path</code>: 文件路径,默认是<code>atom.xml/rss2.xml</code></li><li><code>limit</code>: 展示文章的数量,使用<strong>0</strong>或则<strong>false</strong>代表展示全部</li><li><code>hub</code>:</li><li><code>content</code>: 在<code>RSS</code>文件中是否包含内容 ,有3个值 <code>true/false</code>默认不填为<code>false</code></li><li><code>content_limit</code>: 指定内容的长度作为摘要,仅仅在上面<code>content</code>设置为<code>false</code>和<code>没有自定义的描述出现</code></li><li><code>content_limit_delim</code>: 上面截取描述的分隔符,截取内容是以指定的这个分隔符作为截取结束的标志.在达到规定的内容长度之前最后出现的这个分隔符之前的内容,，防止从中间截断.</li><li><code>order_by</code>: 顺序排列方式</li><li><code>icon</code>: 图标路径</li></ul></blockquote><p>配置好之后运行<code>hexo clean &amp; hexo g</code>就可以找到你博客的<code>pubilc</code> 文件夹下发现<code>atom.xml</code>文件了</p><p>我们可以在<code>关于(about)</code>页面添加RSS源, 有些主题可以在头像下面自动开启, 这些都是后话了.</p><p>配置RSS的时候发现还有一些其他的推送方式, 比如邮件推送, 浏览器通知推送等等.</p><h3 id="RSS阅读器"><a href="#RSS阅读器" class="headerlink" title="RSS阅读器"></a>RSS阅读器</h3><p><a href="https://feedly.com/">Feedly.com</a> 这个比较满意, 文章显示和界面都不错</p><p><a href="https://www.inoreader.com/">inoreader</a>: 订阅的文章展示效果也还不错(卡片形式).</p><p><a href="https://theoldreader.com/">the old reader</a>: 这个是比较老牌的RSS阅读器了</p><p>参考链接:</p><p><a href="https://segmentfault.com/a/1190000012647294">为hexo博客添加RSS订阅功能</a></p><p><a href="https://sean10.github.io/2020/06/27/hexo%E5%BC%80%E5%90%AFatom%E8%AE%A2%E9%98%85/">hexo开启atom订阅</a></p><h2 id="hexo-静态网页压缩"><a href="#hexo-静态网页压缩" class="headerlink" title="hexo 静态网页压缩"></a>hexo 静态网页压缩</h2><p>了解到有三个插件可以做到这个功能(<code>hexo-neat</code>, <code>gulp</code>, <code>Hexo-all-minifier</code>)</p><p><code>gulp</code>存在各种乱七八糟的依赖关系, 推荐直接用<code>Hexo-all-minifier</code>一套走.</p><h3 id="1-hexo-neat"><a href="#1-hexo-neat" class="headerlink" title="1. hexo-neat"></a>1. hexo-neat</h3><blockquote><h2 id="集成插件-hexo-neat"><a href="#集成插件-hexo-neat" class="headerlink" title="集成插件 hexo-neat"></a>集成插件 hexo-neat</h2><p>  首先时所说集成压缩 HTML JS CSS 为一体的 <code>hexo-neat</code> 插件，该插件有以下几个问题：</p><ol><li>各种打印信息输出一大串，并且还不能去掉打印信息，而且还向编译后的文件加入私有注释 <code>rebuild by neat</code>，不太爽！</li><li><a href="https://www.npmjs.com/package/hexo-neat">npm包</a> 跟 <a href="https://github.com/rozbo/hexo-neat">github 包</a> 不统一，github 的 README 有 logger 配置选项，npm 包却没有这配置。</li><li>每次执行 <code>npm run build</code> html 都被重新构建，不能启用 hexo 缓存优化，看不到最新的 html 构建信息。</li><li>包长久不维护。</li></ol></blockquote><p>基于以上放弃了这个插件</p><h3 id="2-gulp"><a href="#2-gulp" class="headerlink" title="2. gulp"></a>2. gulp</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装gulp</span><br>npm install gulp --save<br><span class="hljs-comment"># 安装gulp依赖</span><br>npm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp-imagemin --save<br></code></pre></td></tr></table></figure><p><strong>创建 gulpfile.js 文件</strong></p><p>在<code>Hexo</code>站点根目录下创建<code>gulpfile.js</code>文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-keyword">var</span> gulp = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gulp&#x27;</span>);<br><span class="hljs-keyword">var</span> minifycss = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gulp-minify-css&#x27;</span>);<br><span class="hljs-keyword">var</span> uglify = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gulp-uglify&#x27;</span>);<br><span class="hljs-keyword">var</span> htmlmin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gulp-htmlmin&#x27;</span>);<br><span class="hljs-keyword">var</span> htmlclean = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gulp-htmlclean&#x27;</span>);<br><span class="hljs-keyword">var</span> imagemin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gulp-imagemin&#x27;</span>);<br><span class="hljs-comment">// 压缩css文件</span><br>gulp.<span class="hljs-title function_">task</span>(<span class="hljs-string">&#x27;minify-css&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> gulp.<span class="hljs-title function_">src</span>(<span class="hljs-string">&#x27;./public/**/*.css&#x27;</span>)<br>  .<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">minifycss</span>())<br>  .<span class="hljs-title function_">pipe</span>(gulp.<span class="hljs-title function_">dest</span>(<span class="hljs-string">&#x27;./public&#x27;</span>));<br>&#125;);<br><span class="hljs-comment">// 压缩html文件</span><br>gulp.<span class="hljs-title function_">task</span>(<span class="hljs-string">&#x27;minify-html&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> gulp.<span class="hljs-title function_">src</span>(<span class="hljs-string">&#x27;./public/**/*.html&#x27;</span>)<br>  .<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">htmlclean</span>())<br>  .<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">htmlmin</span>(&#123;<br>    <span class="hljs-attr">removeComments</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">minifyJS</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">minifyCSS</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">minifyURLs</span>: <span class="hljs-literal">true</span>,<br>  &#125;))<br>  .<span class="hljs-title function_">pipe</span>(gulp.<span class="hljs-title function_">dest</span>(<span class="hljs-string">&#x27;./public&#x27;</span>))<br>&#125;);<br><span class="hljs-comment">// 压缩js文件</span><br>gulp.<span class="hljs-title function_">task</span>(<span class="hljs-string">&#x27;minify-js&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> gulp.<span class="hljs-title function_">src</span>([<span class="hljs-string">&#x27;./public/**/.js&#x27;</span>,<span class="hljs-string">&#x27;!./public/js/**/*min.js&#x27;</span>])<br>        .<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">uglify</span>())<br>        .<span class="hljs-title function_">pipe</span>(gulp.<span class="hljs-title function_">dest</span>(<span class="hljs-string">&#x27;./public&#x27;</span>));<br>&#125;);<br><span class="hljs-comment">// 压缩 public/demo 目录内图片</span><br>gulp.<span class="hljs-title function_">task</span>(<span class="hljs-string">&#x27;minify-images&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    gulp.<span class="hljs-title function_">src</span>(<span class="hljs-string">&#x27;./public/demo/**/*.*&#x27;</span>)<br>        .<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">imagemin</span>(&#123;<br>           <span class="hljs-attr">optimizationLevel</span>: <span class="hljs-number">5</span>, <span class="hljs-comment">//类型：Number  默认：3  取值范围：0-7（优化等级）</span><br>           <span class="hljs-attr">progressive</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">//类型：Boolean 默认：false 无损压缩jpg图片</span><br>           <span class="hljs-attr">interlaced</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">//类型：Boolean 默认：false 隔行扫描gif进行渲染</span><br>           <span class="hljs-attr">multipass</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">//类型：Boolean 默认：false 多次优化svg直到完全优化</span><br>        &#125;))<br>        .<span class="hljs-title function_">pipe</span>(gulp.<span class="hljs-title function_">dest</span>(<span class="hljs-string">&#x27;./public/uploads&#x27;</span>));<br>&#125;);<br><span class="hljs-comment">// 默认任务 gulp 4.0 适用的方式</span><br>gulp.<span class="hljs-title function_">task</span>(<span class="hljs-string">&#x27;default&#x27;</span>, gulp.<span class="hljs-title function_">parallel</span>(<span class="hljs-string">&#x27;minify-html&#x27;</span>, <span class="hljs-string">&#x27;minify-css&#x27;</span>, <span class="hljs-string">&#x27;minify-js&#x27;</span><br> <span class="hljs-comment">//build the website</span><br>));<br></code></pre></td></tr></table></figure><p>只要每次在执行<code>hexo g</code>命令后执行<code>gulp</code>就可以进行静态资源压缩，压缩后再同步到github上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo cl &amp; hexo g &amp; gulp<br>hexo d<br></code></pre></td></tr></table></figure><h4 id="注意-这里部署的时候出了一个问题"><a href="#注意-这里部署的时候出了一个问题" class="headerlink" title="注意: 这里部署的时候出了一个问题"></a><strong>注意: 这里部署的时候出了一个问题</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">Error [ERR_REQUIRE_ESM]: require() of ES Module xxx\hexo\node_modules\gulp-imagemin\index.js from xxx\hexo\gulpfile.js not supported.<br>Instead change the require of index.js <span class="hljs-keyword">in</span> xxx\hexo\gulpfile.js to a dynamic import() <span class="hljs-built_in">which</span> is available <span class="hljs-keyword">in</span> all CommonJS modules.<br>    at Object.&lt;anonymous&gt; (xxx\hexo\gulpfile.js:6:16)<br>    at async Promise.all (index 0) &#123;<br>  code: <span class="hljs-string">&#x27;ERR_REQUIRE_ESM&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>  gulp-imagemin 8.0.0 and above are now ESM only. You can downgrade gulp-imagemin to 7.1.0 which is commonjs and it should work fine.</p><blockquote><p>  This package is now pure ESM. Please read this.</p></blockquote><p>  <a href="https://github.com/sindresorhus/gulp-imagemin/releases/tag/v8.0.0">https://github.com/sindresorhus/gulp-imagemin/releases/tag/v8.0.0</a></p></blockquote><p><strong>最终找到说是包的版本太高导致的</strong></p><p>重新安装特定版本的包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 先卸载掉这些包</span><br>npm uninstall gulp<br>npm uninstall gulp-htmlclean gulp-htmlmin gulp-clean-css gulp-uglify gulp-imagemin<br>npm uninstall gulp-minify-css <br><br><span class="hljs-comment"># 重新安装</span><br>npm install gulp@4.0.2 --save<br>npm install gulp-htmlclean@4.0.2 gulp-htmlmin@5.0.1 gulp-clean-css@4.2.0 gulp-uglify@3.0.2 gulp-imagemin@7.1.0 --save<br>npm install gulp-babel@8.0.0 babel-preset-env@1.7.0 babel-preset-mobx@2.0.0 --save<br>npm install gulp-miniify-css@1.2.4 -save<br></code></pre></td></tr></table></figure><blockquote><p>  包的版本可以参考这个<br>  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;babel-preset-env&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^1.7.0&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;babel-preset-mobx&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^2.0.0&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;gulp&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^4.0.2&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;gulp-babel&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^8.0.0&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;gulp-clean-css&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^4.2.0&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;gulp-htmlclean&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^2.7.22&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;gulp-htmlmin&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^5.0.1&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;gulp-imagemin&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^7.1.0&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;gulp-uglify&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^3.0.2&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;gulp-minify-css&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^1.2.4&quot;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure></p></blockquote><p>把<code>gulpfile.js</code>也改动了一下, </p><p>在<code>minify-images</code>项里面我的图片是随文章存放的, 并不是全部存放在<code>img</code>等文件夹下面, 所以只能用全文件匹配去做图片压缩, 代价就是速度很忙, 希望有大佬来指点一下如何更好的修改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> gulp      = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gulp&#x27;</span>)<br><span class="hljs-keyword">let</span> htmlmin   = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gulp-htmlmin&#x27;</span>)<br><span class="hljs-keyword">let</span> htmlclean = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gulp-htmlclean&#x27;</span>)<br><span class="hljs-keyword">let</span> uglify    = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gulp-uglify&#x27;</span>)<br><span class="hljs-keyword">let</span> imagemin  = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gulp-imagemin&#x27;</span>)<br><span class="hljs-keyword">var</span> minifycss = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gulp-minify-css&#x27;</span>);<br><br><span class="hljs-comment">// 压缩html</span><br>gulp.<span class="hljs-title function_">task</span>(<span class="hljs-string">&#x27;minify-html&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 匹配所有 .html结尾的文件</span><br>    <span class="hljs-keyword">return</span> gulp.<span class="hljs-title function_">src</span>(<span class="hljs-string">&#x27;./public/**/*.html&#x27;</span>)<br>        .<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">htmlclean</span>())<br>        .<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">htmlmin</span>(&#123;<br>            <span class="hljs-attr">removeComments</span>: <span class="hljs-literal">true</span>,<br>            <span class="hljs-attr">minifyJS</span>: <span class="hljs-literal">true</span>,<br>            <span class="hljs-attr">minifyCSS</span>: <span class="hljs-literal">true</span>,<br>            <span class="hljs-attr">minifyURLs</span>: <span class="hljs-literal">true</span>,<br>        &#125;))<br>        .<span class="hljs-title function_">pipe</span>(gulp.<span class="hljs-title function_">dest</span>(<span class="hljs-string">&#x27;./public&#x27;</span>))<br>&#125;);<br><br><span class="hljs-comment">// 压缩css</span><br>gulp.<span class="hljs-title function_">task</span>(<span class="hljs-string">&#x27;minify-css&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> gulp.<span class="hljs-title function_">src</span>(<span class="hljs-string">&#x27;./public/**/*.css&#x27;</span>)<br>        .<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">minifycss</span>())<br>        .<span class="hljs-title function_">pipe</span>(gulp.<span class="hljs-title function_">dest</span>(<span class="hljs-string">&#x27;./public&#x27;</span>));<br>&#125;);<br><br><span class="hljs-comment">// 压缩js</span><br>gulp.<span class="hljs-title function_">task</span>(<span class="hljs-string">&#x27;minify-js&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> gulp.<span class="hljs-title function_">src</span>([<span class="hljs-string">&#x27;./public/**/.js&#x27;</span>, <span class="hljs-string">&#x27;!./public/js/**/*min.js&#x27;</span>])<br>        .<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">uglify</span>())<br>        .<span class="hljs-title function_">pipe</span>(gulp.<span class="hljs-title function_">dest</span>(<span class="hljs-string">&#x27;./public&#x27;</span>));<br>&#125;)<br><br><span class="hljs-comment">// 压缩图片</span><br>gulp.<span class="hljs-title function_">task</span>(<span class="hljs-string">&#x27;minify-images&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> gulp.<span class="hljs-title function_">src</span>(<span class="hljs-string">&#x27;./public/**/*.*&#x27;</span>)<br>        .<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">imagemin</span>(&#123;<br>            <span class="hljs-attr">optimizationLevel</span>: <span class="hljs-number">5</span>, <span class="hljs-comment">//类型：Number  默认：3  取值范围：0-7（优化等级）</span><br>            <span class="hljs-attr">progressive</span>: <span class="hljs-literal">true</span>,    <span class="hljs-comment">//类型：Boolean 默认：false 无损压缩jpg图片</span><br>            <span class="hljs-attr">interlaced</span>: <span class="hljs-literal">false</span>,    <span class="hljs-comment">//类型：Boolean 默认：false 隔行扫描gif进行渲染</span><br>            <span class="hljs-attr">multipass</span>: <span class="hljs-literal">false</span>,     <span class="hljs-comment">//类型：Boolean 默认：false 多次优化svg直到完全优化</span><br>        &#125;))<br>        .<span class="hljs-title function_">pipe</span>(gulp.<span class="hljs-title function_">dest</span>(<span class="hljs-string">&#x27;./public&#x27;</span>));<br>&#125;)<br><br>gulp.<span class="hljs-title function_">task</span>(<span class="hljs-string">&#x27;default&#x27;</span>, gulp.<span class="hljs-title function_">series</span>(<span class="hljs-string">&#x27;minify-html&#x27;</span>, <span class="hljs-string">&#x27;minify-css&#x27;</span>, <span class="hljs-string">&#x27;minify-js&#x27;</span>, <span class="hljs-string">&#x27;minify-images&#x27;</span>))<br></code></pre></td></tr></table></figure><h3 id="3-Hexo-all-minifier"><a href="#3-Hexo-all-minifier" class="headerlink" title="3. Hexo-all-minifier"></a>3. Hexo-all-minifier</h3><blockquote><p>  <a href="https://github.com/chenzhutian/hexo-all-minifier">https://github.com/chenzhutian/hexo-all-minifier</a></p><p>  <a href="https://archive.vincent0700.com/2019/12/31/034_Usage_of_hexo-all-minifier_copy/">Hexo 资源压缩 | hexo-all-minifier</a></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装</span><br>npm install hexo-all-minifier --save<br><br><span class="hljs-comment"># 在_config.yml文件添加配置</span><br>all_minifier: <span class="hljs-literal">true</span><br><br><span class="hljs-comment"># </span><br>hexo cl &amp; hexo g <br></code></pre></td></tr></table></figure><h2 id="Hexo-Sitemap"><a href="#Hexo-Sitemap" class="headerlink" title="Hexo Sitemap"></a>Hexo Sitemap</h2><blockquote><p>   据网友所言: 谷歌就xx乱爬, 百度就xx乱删, 必应就xx不收录</p></blockquote><p>为了让博文能够被google或百度检索，需要先将网站收录到他们的库里面，我们可以在谷歌的站长平台里面提交我们的sitemap文件，告诉浏览器应该我们的站点有哪些页面，这样他就会去爬取收录了。</p><blockquote><p>  站点地图是一种文件，您可以在其中提供与您网站中的网页、视频或其他文件有关的信息，还可以说明这些内容之间的关系。Google 等搜索引擎会读取此文件，以便更高效地抓取您的网站。站点地图会告诉 Google 您认为网站中的哪些网页和文件比较重要，还会提供与这些文件有关的重要信息。例如，网页上次更新的时间和网页是否有任何备用的语言版本。</p><p>  您可以使用站点地图提供与特定类型的网页内容（包括<a href="https://developers.google.com/search/docs/advanced/sitemaps/video-sitemaps">视频</a>、<a href="https://developers.google.com/search/docs/advanced/sitemaps/image-sitemaps">图片</a>和<a href="https://developers.google.com/search/docs/advanced/sitemaps/news-sitemap">新闻</a>内容）有关的信息。例如：</p><ul><li>站点地图视频条目可以指定视频的时长、评分以及适合哪些年龄段的受众。</li><li>站点地图图片条目中可包含网页中所含图片的位置。</li><li>站点地图新闻条目中可包含报道标题和发布日期。</li></ul><p>  <strong>我需要站点地图吗？</strong></p><p>  如果您网站上的网页链接得当，那么 Google 通常能够发现其中的大多数网页。链接得当是指您认为重要的所有网页都可以通过某些形式的导航（例如您网站的菜单，或您放入网页中的链接）抵达。即便如此，站点地图仍有助于我们更加高效地抓取规模更大、更复杂的网站或更特殊的文件。</p></blockquote><h3 id="生成sitemap-xml"><a href="#生成sitemap-xml" class="headerlink" title="生成sitemap.xml"></a>生成<code>sitemap.xml</code></h3><p>首先我们安装生成sitemao的插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 谷歌的</span><br>npm install hexo-generator-sitemap --save<br><span class="hljs-comment"># 百度的</span><br>npm install hexo-generator-baidu-sitemap --save<br></code></pre></td></tr></table></figure><p>修改配置文件<code>_config.yml</code>增加下面这些内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">Plugins:<br>- hexo-generator-sitemap<br>- hexo-generator-baidu-sitemap<br><br>baidusitemap:<br>  path: baidusitemap.xml<br>sitemap:<br>  path: sitemap.xml<br></code></pre></td></tr></table></figure><p>生成<code>sitemap.xml</code>文件, 重新生成网站, 在网站根目录就可以看到<code>sitemap.xml</code>文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo cl &amp; hexo g <br></code></pre></td></tr></table></figure><h3 id="提交sitemap-xml"><a href="#提交sitemap-xml" class="headerlink" title="提交sitemap.xml"></a>提交<code>sitemap.xml</code></h3><p><a href="https://www.google.com/webmasters/tools">GoogleSearchConsole</a></p><p><a href="https://www.bing.com/webmasters/">BingWebMaster</a></p><p><a href="https://ziyuan.baidu.com/site/index">百度资源平台</a></p><p><strong>下面讲一下谷歌的</strong></p><p>登录<a href="https://www.google.com/webmasters/tools">GoogleSearchConsole</a>, 按照提示验证站点的所有权</p><p>打开谷歌控制台选择-&gt;<strong>索引</strong>-&gt;<strong>站点地图</strong>，在添加新的站点地图中填入你的<code>sitemap.xml</code>的路径, 这里直接写<code>sitemap.xml</code>即可。</p><p><img src="/2022/f96c3c41/image-20220918004138059.png" alt="image-20220918004138059"></p><blockquote><p>   这个谷歌真是让我大无语, 一直显示无法获取, 一直没法解决这个问题, 网址检查显示没什么问题, 但是一直显示无法获取真是麻了.</p><p>  求助群友后他们推荐使用 Hexo-SEO-AutoPush</p></blockquote><h3 id="收录查询"><a href="#收录查询" class="headerlink" title="收录查询"></a>收录查询</h3><ol><li><p>通过网站管理平台的控制台去看数据</p></li><li><p>搜索引擎直接搜索</p></li></ol><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">site:</span>oikiou.top<br></code></pre></td></tr></table></figure><h3 id="手动生成Sitemap文件"><a href="#手动生成Sitemap文件" class="headerlink" title="手动生成Sitemap文件"></a>手动生成Sitemap文件</h3><p><a href="https://www.xml-sitemaps.com/">https://www.xml-sitemaps.com/</a></p><h2 id="Hexo-SEO-AutoPush的使用"><a href="#Hexo-SEO-AutoPush的使用" class="headerlink" title="Hexo-SEO-AutoPush的使用"></a>Hexo-SEO-AutoPush的使用</h2><p><a href="https://github.com/Lete114/Hexo-SEO-AutoPush">https://github.com/Lete114/Hexo-SEO-AutoPush</a></p><blockquote><p>  注意以下几点: </p><ol><li>由于生成的 actions 是在<code>.github/workflows/HexoSeoAutoPush.yml</code>，点开头的文件或文件夹都会被视为隐藏文件，所以 hexo 不会将隐藏文件部署到 pages，需要新增配置<code>ignore_hidden</code></li></ol><pre><code class="hljs"> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">deploy:<br> ignore_hidden: <span class="hljs-literal">false</span> <span class="hljs-comment"># 忽略隐藏文件及文件夹(目录)</span><br></code></pre></td></tr></table></figure> </code></pre><ol start="2"><li><p>Bing的<code>API</code>在登录控制台后的<em>右上角齿轮上</em>可以找到, 如果找不到可能是界面更新导致的, 请参考官方文档</p></li><li><p>注意google的信息填写方式</p><p><code>google_private_key</code>是填写Json内的 <code>private_key </code> 不是<code>private_key_id </code>注意区分. </p><p>而且<code>google_private_key </code> 是带双引号的需要注意, 而<code>google_client_email</code>填写的时候是不带双引号的.</p><table><thead><tr><th>名称</th><th>形似</th><th>说明</th></tr></thead><tbody><tr><td>google_client_email</td><td><a href="mailto:&#x78;&#x78;&#x78;&#64;&#x78;&#x78;&#120;&#x2e;&#x78;&#120;&#120;&#46;&#103;&#x73;&#x65;&#x72;&#x76;&#x69;&#99;&#101;&#x61;&#x63;&#99;&#x6f;&#117;&#110;&#x74;&#x2e;&#x63;&#x6f;&#x6d;">&#x78;&#x78;&#x78;&#64;&#x78;&#x78;&#120;&#x2e;&#x78;&#120;&#120;&#46;&#103;&#x73;&#x65;&#x72;&#x76;&#x69;&#99;&#101;&#x61;&#x63;&#99;&#x6f;&#117;&#110;&#x74;&#x2e;&#x63;&#x6f;&#x6d;</a></td><td>【必填】Value 输入谷歌的 client_email</td></tr><tr><td>google_private_key</td><td>“—–BEGIN PRIVATE KEY—–\nxxxxxx\n—–END PRIVATE KEY—–\n”</td><td>【必填】Value 输入谷歌的 private_key （注意：填写的时候需要使用<strong>双引号</strong>包起来，如: <code>&quot;private_key&quot;</code>）</td></tr></tbody></table></li></ol></blockquote><p>在Github内点击Action-&gt;Hexo SEO Auto Push -&gt; 查看执行情况 没有报错就是执行的没问题, 稍等片刻刷新控制台就可以看到提交的信息.</p><p>打开<a href="https://www.bing.com/webmasters/">Home - Bing Webmaster Tools</a>, <code>URL提交</code>标签</p><p>在<a href="https://console.cloud.google.com/apis/dashboard">Google Cloud Platform</a> 中查看.</p><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意:"></a><strong>注意:</strong></h3><p>部署的时候报了下面这个错误, 当时弄这个东西的时候是半夜, 脑子不清醒(各位同学注意早睡早起, 熬夜效率是极其低下的), <code>private_key</code>填写错了发生了这个错误, 有相似错误的同学可以看看是不是<code>private_key</code>有问题.</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs awk">Run npx hexoautopush *** ***<br>Error: error:<span class="hljs-number">0909006</span>C:PEM routines:get_name:no start line<br>    at Sign.sign (internal<span class="hljs-regexp">/crypto/</span>sig.js:<span class="hljs-number">110</span>:<span class="hljs-number">29</span>)<br>    at Object.sign (<span class="hljs-regexp">/xxx/</span>node_modules<span class="hljs-regexp">/jwa/i</span>ndex.js:<span class="hljs-number">152</span>:<span class="hljs-number">45</span>)<br>    at Object.jwsSign [as sign] (<span class="hljs-regexp">/xxx/</span>node_modules<span class="hljs-regexp">/jws/</span>lib/sign-stream.js:<span class="hljs-number">32</span>:<span class="hljs-number">24</span>)<br>    at GoogleToken.requestToken (<span class="hljs-regexp">/xxx/</span>node_modules<span class="hljs-regexp">/gtoken/</span>build<span class="hljs-regexp">/src/i</span>ndex.js:<span class="hljs-number">225</span>:<span class="hljs-number">31</span>)<br>    at GoogleToken.getTokenAsyncInner (<span class="hljs-regexp">/xxx/</span>node_modules<span class="hljs-regexp">/gtoken/</span>build<span class="hljs-regexp">/src/i</span>ndex.js:<span class="hljs-number">163</span>:<span class="hljs-number">21</span>)<br>    at GoogleToken.getTokenAsync (<span class="hljs-regexp">/xxx/</span>node_modules<span class="hljs-regexp">/gtoken/</span>build<span class="hljs-regexp">/src/i</span>ndex.js:<span class="hljs-number">142</span>:<span class="hljs-number">55</span>)<br>    at GoogleToken.getToken (<span class="hljs-regexp">/xxx/</span>node_modules<span class="hljs-regexp">/gtoken/</span>build<span class="hljs-regexp">/src/i</span>ndex.js:<span class="hljs-number">94</span>:<span class="hljs-number">21</span>)<br>    at JWT.refreshTokenNoCache (<span class="hljs-regexp">/xxx/</span>node_modules<span class="hljs-regexp">/google-auth-library/</span>build<span class="hljs-regexp">/src/</span>auth/jwtclient.js:<span class="hljs-number">171</span>:<span class="hljs-number">36</span>)<br>    at JWT.refreshToken (<span class="hljs-regexp">/xxx/</span>node_modules<span class="hljs-regexp">/google-auth-library/</span>build<span class="hljs-regexp">/src/</span>auth/oauth2client.js:<span class="hljs-number">145</span>:<span class="hljs-number">25</span>)<br>    at JWT.authorizeAsync (<span class="hljs-regexp">/xxx/</span>node_modules<span class="hljs-regexp">/google-auth-library/</span>build<span class="hljs-regexp">/src/</span>auth/jwtclient.js:<span class="hljs-number">152</span>:<span class="hljs-number">35</span>) &#123;<br>  library: <span class="hljs-string">&#x27;PEM routines&#x27;</span>,<br>  <span class="hljs-keyword">function</span>: <span class="hljs-string">&#x27;get_name&#x27;</span>,<br>  reason: <span class="hljs-string">&#x27;no start line&#x27;</span>,<br>  code: <span class="hljs-string">&#x27;ERR_OSSL_PEM_NO_START_LINE&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Hexo博客修改Archive页面显示文章数量"><a href="#Hexo博客修改Archive页面显示文章数量" class="headerlink" title="Hexo博客修改Archive页面显示文章数量"></a>Hexo博客修改Archive页面显示文章数量</h2><p>默认情况下，Hexo无法对主页、Archive页面、标签页面每页显示文章数量进行单独设置</p><p>这里我们借助<code>hexo-generator-archive</code>来实现这个功能, 因为Archive分页的话看起来贼难受, 如果能将所有的文章全部显示那就舒服了.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 先安装包</span><br>npm install hexo-generator-archive --save<br></code></pre></td></tr></table></figure><p>编辑<code>_config.yml</code>新增以下内容</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Pagination</span><br><span class="hljs-comment">## Set per_page to 0 to disable pagination</span><br><span class="hljs-attr">index_generator:</span><br>  <span class="hljs-attr">per_page:</span> <span class="hljs-number">32</span><br><br><span class="hljs-attr">index_generator:</span><br>  <span class="hljs-attr">per_page:</span> <span class="hljs-number">5</span><br><br><span class="hljs-attr">archive_generator:</span><br>  <span class="hljs-attr">per_page:</span> <span class="hljs-number">20</span>  <span class="hljs-comment">#为0时表示不分页全展示</span><br>  <span class="hljs-attr">yearly:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment">#按年生成归档</span><br>  <span class="hljs-attr">monthly:</span> <span class="hljs-literal">false</span> <span class="hljs-comment">#按月生成归档</span><br><br><span class="hljs-attr">tag_generator:</span><br>  <span class="hljs-attr">per_page:</span> <span class="hljs-number">10</span><br><br><span class="hljs-attr">category_generator:</span><br>  <span class="hljs-attr">per_page:</span> <span class="hljs-number">50</span><br></code></pre></td></tr></table></figure><blockquote><p>  注意:上面归档设置中的按年或者按月，需要修改模板给出对应的链接入口，对于没有兴趣修改模板的同学，可以将此处设为false，减少生成页面时的工作量。</p></blockquote><h1 id="Comment-评论系统"><a href="#Comment-评论系统" class="headerlink" title="Comment 评论系统"></a>Comment 评论系统</h1><h2 id="cusdis-系统"><a href="#cusdis-系统" class="headerlink" title="cusdis 系统"></a>cusdis 系统</h2><p>功能较少,看起来非常轻量, 也可以私有部署,正打算私有部署的时候看到了<code>twikoo</code>所以就转入<code>twikoo</code>了,因为cusdis现阶段功能确实有些少.</p><h2 id="twikoo-系统"><a href="#twikoo-系统" class="headerlink" title="twikoo 系统"></a>twikoo 系统</h2><p><a href="https://twikoo.js.org/">https://twikoo.js.org/</a></p><p>私有docker部署部署半天还是不成功, 看起来像是需要HTTPS才行.</p><p>功能挺丰富的,<del>就是半天没部署成功</del></p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">部署后没有启用HTTPS<br>fluid 配置里面又启动了强行使用hTTPS, <br><span class="hljs-built_in">F12,</span>看consel发现,ERR_SSL_PROTOCOL_ERROR,被重定向到了HTTPS去了<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css">头像风格类型<br><span class="hljs-number">404</span>：如果没有任何图像与电子邮件哈希无关，则不加载任何图像，而是返回HTTP <span class="hljs-number">404</span>（找不到文件）响应<br>mp：（神秘人物）一个人的简单卡通风格的轮廓（不随电子邮件哈希值而变化）<br>identicon：基于电子邮件哈希的几何图案<br>monsterid：生成的具有不同颜色，面孔等的“怪物”<br>wavatar：生成的具有不同特征和背景的面孔<br>retro：生成的令人敬畏的<span class="hljs-number">8</span>位街机风格像素化面孔<br>robohash：具有不同颜色，面部等的生成的机器人<br>blank：透明的PNG图像（以下为演示目的添加到<span class="hljs-selector-tag">HTML</span>的边框）<br></code></pre></td></tr></table></figure><ul><li><p>Twikoo我是用的docker,nginx和ssl配置可以参考<a href="https://hub.docker.com/r/imaegoo/twikoo">DockerHub</a>, https的端口是可以更改的, 默认的443占用了换成别的就好.</p></li><li><p>twikoo的即时推送尝试了几个譬如 Qmsq, server酱等等发现又一系列的问题 都不尽如人意  最后选择的是最简单的邮件通知.</p></li></ul><h2 id="remark42"><a href="#remark42" class="headerlink" title="remark42"></a>remark42</h2><h1 id="部署平台-托管平台"><a href="#部署平台-托管平台" class="headerlink" title="部署平台(托管平台)"></a>部署平台(托管平台)</h1><p><a href="https://i.vince.pub/p/hexo-static/">常见静态网站托管平台使用及多节点部署方案</a></p><p><img src="/2022/f96c3c41/2fc062cb2.svg" alt="节点"></p><p>现阶段比较好的方案是<code>coding</code>和<code>github+netlify</code>.</p><h1 id="一些资源"><a href="#一些资源" class="headerlink" title="一些资源"></a>一些资源</h1><p><strong>字体族（<code>font-family</code>）</strong></p><blockquote><p>   <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-family">https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-family</a></p></blockquote><p><strong>调色板灵感</strong></p><blockquote><p>   <a href="https://www.webdesignrankings.com/resources/lolcolors/">https://www.webdesignrankings.com/resources/lolcolors/</a></p></blockquote><p><strong>ISO-8601 日期</strong></p><blockquote><p>  <a href="http://momentjs.cn/docs/#/parsing/string-format/">http://momentjs.cn/docs/#/parsing/string-format/</a></p></blockquote><p><strong>代码高亮风格</strong></p><blockquote><p>  highlightjs:  <a href="https://highlightjs.org/static/demo/">https://highlightjs.org/static/demo/</a></p><p>  prismjs:  <a href="https://prismjs.com/">https://prismjs.com/</a></p></blockquote><p><strong>Logo生成器</strong></p><blockquote><p>  adobe: <a href="https://www.adobe.com/express/create/logo">https://www.adobe.com/express/create/logo</a></p></blockquote><p><strong>图床</strong></p><blockquote><p>  <a href="https://postimg.cc/">https://postimg.cc/</a></p></blockquote><p><strong>壁纸</strong></p><blockquote><p>  <a href="https://wallpapercrafter.com/">https://wallpapercrafter.com/</a></p></blockquote><p><strong>实时获取网站的<code>Favicon.ion</code>文件</strong></p><blockquote><p>  <a href="https://tools.ly522.com/ico/">https://tools.ly522.com/ico/</a></p><p>  远程实时获取并显示网站的Favicon.ico文件，美化网站外链显示效果。</p></blockquote><h1 id="一些知识"><a href="#一些知识" class="headerlink" title="一些知识"></a>一些知识</h1><h2 id="Creative-Commons-licenses"><a href="#Creative-Commons-licenses" class="headerlink" title="Creative Commons licenses"></a>Creative Commons licenses</h2><p><a href="https://www.wur.nl/en/article/What-are-Creative-Commons-licenses.htm">What are Creative Commons licenses?</a></p><p><img src="/2022/f96c3c41/licences_3bf0e9af_670x502.jpg" alt="知识共享许可.jpg"></p><h2 id="Gravatar-amp-Cravatar"><a href="#Gravatar-amp-Cravatar" class="headerlink" title="Gravatar &amp; Cravatar"></a>Gravatar &amp; Cravatar</h2><p><a href="https://en.gravatar.com/">Gravatar</a> &amp; <a href="https://cravatar.cn/">Cravatar</a>的差异</p><h3 id="Gravatar"><a href="#Gravatar" class="headerlink" title="Gravatar"></a>Gravatar</h3><p>Gravatar是一项用于提供在全球范围内使用的头像服务。只要你在Gravatar的服务器上上传了你自己的头像，你便可以在其他任何支持Gravatar的博客、论坛等地方使用它。</p><h3 id="Cravatar-cn"><a href="#Cravatar-cn" class="headerlink" title="Cravatar  (cn)"></a>Cravatar  (cn)</h3><p>Cravatar 是 Gravatar 在中国的完美替代方案,从此你可以自由的上传和分享头像。</p><p><strong>与 Gravatar API 兼容</strong></p><p>为了降低你的使用成本，我们的 API 规范始终保持与 Gravatar 100% 兼容</p><p><strong>独有的三级头像匹配机制</strong></p><p>当访客请求自己的头像时，我们会按此顺序分三级匹配头像：<strong>Cravatar-&gt;Gravatar-&gt;QQ 头像</strong>，对于博客站，这平均可以为 70% 的访客提供准确的头像</p>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>jekyll</tag>
      
      <tag>fluid</tag>
      
      <tag>cusdis</tag>
      
      <tag>twikoo</tag>
      
      <tag>blog</tag>
      
      <tag>gravatar</tag>
      
      <tag>cravatar</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符集和字符编码</title>
    <link href="/2022/438d1de3/"/>
    <url>/2022/438d1de3/</url>
    
    <content type="html"><![CDATA[<h1 id="字符集和字符编码"><a href="#字符集和字符编码" class="headerlink" title="字符集和字符编码"></a>字符集和字符编码</h1><p><a href="https://www.cnblogs.com/skynet/archive/2011/05/03/2035105.html">字符集和字符编码 (Charset &amp; Encoding)</a></p><p><a href="http://www.knowsky.com/resource/gb2312tbl.htm">GB2312简体中文编码表</a></p><p><a href="http://tools.jb51.net/table/gb2312">GB2312简体中文编码表</a></p><p><a href="https://www.unicode.org/charts/">Unicode码查询</a></p><p><a href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84">Unicode字符平面映射</a></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>字符集（Charset）</strong>：是一个系统支持的所有抽象字符的集合。字符是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等。</p><p>常见字符集：ASCII字符集、GB2312字符集、BIG5字符集、GB18030字符集、Unicode字符集等。计算机要准确的处理各种字符集文字，需要进行字符编码，以便计算机能够识别和存储各种文字。</p><p><strong>字符编码（Character Encoding）</strong>：是一套法则，使用该法则能够对自然语言的字符的一个集合（如字母表或音节表），与其他东西的一个集合（如号码、数字或电脉冲）进行配对。即在符号集合与数字系统之间建立对应关系，它是信息处理的一项基本技术。通常人们用符号集合（一般情况下就是文字）来表达信息。而以计算机为基础的信息处理系统则是利用元件（硬件）不同状态的组合来存储和处理信息的。元件不同状态的组合能代表数字系统的数字，因此字符编码就是将符号转换为计算机可以接受的数字系统的数，称为数字代码。</p><h2 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h2><p><strong>ASCII字符集</strong>：主要包括控制字符（回车键、退格、换行键等）；可显示字符（英文大小写字符、阿拉伯数字和西文符号）。</p><p><strong>ASCII编码</strong>：将ASCII字符集转换为计算机可以接受的数字系统的数的规则。使用7位（bits）表示一个字符，共128字符；但是7位编码的字符集只能支持128个字符，为了表示更多的常用字符欧洲对ASCII进行了扩展，ASCII扩展字符集使用8位（bits）表示一个字符，共256字符。ASCII字符集映射到数字编码规则如下图所示：</p><p><img src="/2022/438d1de3/2011050311372042.png" alt="img"></p><p><img src="/2022/438d1de3/201105031137219627.png" alt="img"></p><h2 id="GBxxx"><a href="#GBxxx" class="headerlink" title="GBxxx"></a>GBxxx</h2><p>中国把那些127号之后的奇异符号们（即EASCII、扩充ASCII）取消掉，规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字。前面的一个字节（他称之为高字节）从0xA1用到 0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。在这些编码里，还把数学符号、罗马希腊的 字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。</p><p>上述编码规则就是<strong>GB2312</strong>。<strong>GB2312</strong>或<strong>GB2312-80</strong>是<a href="http://zh.wikipedia.org/wiki/%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E5%9B%BD%E5%AE%B6%E6%A0%87%E5%87%86">中国国家标准</a><a href="http://zh.wikipedia.org/wiki/%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87">简体中文</a><a href="http://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E9%9B%86">字符集</a>，全称《<strong>信息交换用汉字编码字符集·基本集</strong>》，又称<a href="http://zh.wikipedia.org/wiki/%E5%9B%BD%E5%AE%B6%E6%A0%87%E5%87%86%E4%BB%A3%E7%A0%81"><strong>GB0</strong></a>，由<a href="http://zh.wikipedia.org/w/index.php?title=%E4%B8%AD%E5%9B%BD%E5%9B%BD%E5%AE%B6%E6%A0%87%E5%87%86%E6%80%BB%E5%B1%80&action=edit&redlink=1">中国国家标准总局</a>发布，<a href="http://zh.wikipedia.org/wiki/1981%E5%B9%B4">1981年</a><a href="http://zh.wikipedia.org/wiki/5%E6%9C%881%E6%97%A5">5月1日</a>实施。GB2312编码通行于中国大陆；<a href="http://zh.wikipedia.org/wiki/%E6%96%B0%E5%8A%A0%E5%9D%A1">新加坡</a>等地也采用此编码。GB2312的出现，基本满足了汉字的计算机处理需要，它所收录的汉字已经覆盖中国大陆99.75%的使用频率。对于<a href="http://zh.wikipedia.org/wiki/%E4%BA%BA%E5%90%8D">人名</a>、<a href="http://zh.wikipedia.org/wiki/%E5%8F%A4%E6%B1%89%E8%AF%AD">古汉语</a>等方面出现的<a href="http://zh.wikipedia.org/wiki/%E7%BD%95%E7%94%A8%E5%AD%97">罕用字</a>，GB2312不能处理，这导致了后来<a href="http://zh.wikipedia.org/wiki/GBK">GBK</a>及<a href="http://zh.wikipedia.org/wiki/GB_18030">GB 18030</a>汉字字符集的出现。</p><p><a href="http://www.knowsky.com/resource/gb2312tbl.htm">GB2312简体中文编码表</a></p><p><a href="http://tools.jb51.net/table/gb2312">GB2312简体中文编码表</a></p><h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p>Unicode编码系统为表达任意语言的任意字符而设计。它使用4字节的数字来表达每个字母、符号，或者表意文字(ideograph)。每个字符对应一个数字，每个数字对应一个字符，即不存在二义性，不再需要记录”模式”了。U+0041总是代表’A’，即使这种语言没有’A’这个字符。</p><p>在计算机科学领域中，<strong>Unicode</strong>（<strong>统一码</strong>、<strong>万国码</strong>、<strong>单一码</strong>、<strong>标准万国码</strong>）是业界的一种标准，它可以使电脑得以体现世界上数十种文字的系统。</p><p>（<strong>可以这样理解：Unicode是字符集，UTF-32&#x2F; UTF-16&#x2F; UTF-8是三种字符编码方案。</strong>）</p><p><a href="https://www.unicode.org/charts/">Unicode码查询</a></p><p><a href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84">Unicode字符平面映射</a></p><h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h3><p>EF BB BF　　　 UTF-8<br>FE FF　　　　　UTF-16&#x2F;UCS-2, little endian<br>FF FE　　　　　UTF-16&#x2F;UCS-2, big endian<br>FF FE 00 00　　UTF-32&#x2F;UCS-4, little endian.<br>00 00 FE FF　　UTF-32&#x2F;UCS-4, big-endian.</p><ul><li><strong>字符集和字符编码</strong></li></ul><p><img src="/2022/438d1de3/v2-aee5ae604328ab912b285d03b6c62273_720w.jpg" alt="img"></p><h3 id="UTF-32"><a href="#UTF-32" class="headerlink" title="UTF-32"></a>UTF-32</h3><p>上述使用4字节的数字来表达每个字母、符号，或者表意文字(ideograph)，每个数字代表唯一的至少在某种语言中使用的符号的编码方案，称为UTF-32。UTF-32又称<strong>UCS-4</strong>是一种将<a href="http://zh.wikipedia.org/wiki/Unicode">Unicode</a>字符编码的协定，对每个字符都使用4字节。就空间而言，是非常没有效率的。</p><p>这种方法有其优点，最重要的一点就是可以在常数时间内定位字符串里的第N个字符，因为第N个字符从第4×Nth个字节开始。虽然每一个码位使用固定长定的字节看似方便，它并不如其它Unicode编码使用得广泛。</p><h3 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h3><p>对于UTF-32和UTF-16编码方式还有一些其他不明显的缺点。不同的计算机系统会以不同的顺序保存字节。这意味着字符U+4E2D在UTF-16编码方式下可能被保存为4E 2D或者2D 4E，这取决于该系统使用的是大尾端(big-endian)还是小尾端(little-endian)。为了解决这个问题，多字节的Unicode编码方式定义了一个”字节顺序标记(Byte Order Mark)”，它是一个特殊的非打印字符，你可以把它包含在文档的开头来指示你所使用的字节顺序。对于UTF-16，字节顺序标记是U+FEFF。如果收到一个以字节FFFE开头的UTF-16编码的文档，你就能确定它的字节顺序是单向的(one way)的了；如果它以FEFF开头，则可以确定字节顺序反向了。</p><p><strong>具体编码方式</strong></p><p>Unicode范围<code>U+10000</code><del><code>U+10FFFF</code>：将Unicode值减去（0x10000），得到20bit长的值。再将Unicode分为高10位和低10位。<a href="https://www.zhihu.com/search?q=UTF-16%E7%BC%96%E7%A0%81&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:106379925%7D">UTF-16编码</a>的高位是2 Byte，高10位Unicode范围为<code>0</code>-<code>0x3FF</code>，将Unicode值加上<code>0XD800</code>，得到高位代理（或称为前导代理，存储高位）；低位也是2 Byte，低十位Unicode范围一样为<code>0</code></del><code>0x3FF</code>，将Unicode值加上<code>0xDC00</code>,得到低位代理（或称为后尾代理，存储低位）</p><p>根据上面的转换方式，我们就能够将Unicode码根据UTF-16的编码方式进行转换。下面我们仍然通过两个例子来看下：</p><ul><li><code>U+0020</code>，这个值的范围在第一部分，即经过UTF-16编码后，结果仍然为<code>U+0020</code>，在内存中的顺序为<code>00 20</code>。</li><li><code>U+12345</code>, 这个值的范围在第二部分，因此需要先减去<code>0x10000</code>，得到<code>0x02345</code>，拆分成高10位<code>00 0000 1000</code>和低10位<code>11 0100 0101</code>。根据上面规则加上特定值后，高位代理值为<code>D808</code>，低位代理值为<code>DF45</code>，最终内存中的顺序为<code>D8 08 DF 45</code>。</li></ul><h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><p><strong>UTF-8</strong>（8-bit Unicode Transformation Format）是一种针对<a href="http://zh.wikipedia.org/wiki/Unicode">Unicode</a>的可变长度<a href="http://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81">字符编码</a>（<a href="http://zh.wikipedia.org/w/index.php?title=%E5%AE%9A%E9%95%BF%E7%A0%81&action=edit&redlink=1">定长码</a>），也是一种<a href="http://zh.wikipedia.org/w/index.php?title=%E5%89%8D%E7%BC%80%E7%A0%81&action=edit&redlink=1">前缀码</a>。它可以用来表示Unicode标准中的任何字符，且其编码中的第一个<a href="http://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82">字节</a>仍与<a href="http://zh.wikipedia.org/wiki/ASCII">ASCII</a>兼容，这使得原来处理ASCII字符的<a href="http://zh.wikipedia.org/wiki/%E8%BB%9F%E9%AB%94">软件</a>无须或只须做少部份修改，即可继续使用。因此，它逐渐成为<a href="http://zh.wikipedia.org/wiki/%E9%9B%BB%E5%AD%90%E9%83%B5%E4%BB%B6">电子邮件</a>、<a href="http://zh.wikipedia.org/wiki/%E7%B6%B2%E9%A0%81">网页</a>及其他<a href="http://zh.wikipedia.org/wiki/%E5%84%B2%E5%AD%98%E8%A3%9D%E7%BD%AE">存储</a>或传送文字的应用中，优先采用的编码。<a href="http://zh.wikipedia.org/wiki/%E7%B6%B2%E9%9A%9B%E7%B6%B2%E8%B7%AF%E5%B7%A5%E7%A8%8B%E5%B7%A5%E4%BD%9C%E5%B0%8F%E7%B5%84">互联网工程工作小组</a>（IETF）要求所有<a href="http://zh.wikipedia.org/wiki/%E7%B6%B2%E9%9A%9B%E7%B6%B2%E8%B7%AF">互联网</a><a href="http://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE">协议</a>都必须支持UTF-8编码。</p><p>UTF-8使用一至四个<a href="http://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82">字节</a>为每个字符编码</p><p><strong>具体编码方式</strong></p><p><img src="/2022/438d1de3/v2-121a14291638f0b28e1dde7c95d2d379_720w.jpg" alt="img"></p><p>根据上表，解读 UTF-8 编码非常简单。如果一个字节的第一位是<code>0</code>，则这个字节单独就是一个字符；如果第一位是<code>1</code>，则连续有多少个<code>1</code>，就表示当前字符占用多少个字节。<br>下面，还是以汉字<code>严</code>为例，演示如何实现 <a href="https://www.zhihu.com/search?q=UTF-8+%E7%BC%96%E7%A0%81&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:790551384%7D">UTF-8 编码</a>。<br><code>严</code>的 Unicode 是<code>4E25</code>（<code>100111000100101</code>），根据上表，可以发现<code>4E25</code>处在第三行的范围内（<code>0000 0800 - 0000 FFFF</code>），因此<code>严</code>的 UTF-8 编码需要三个字节，即格式是<code>1110xxxx 10xxxxxx 10xxxxxx</code>。然后，从<code>严</code>的最右边<a href="https://www.zhihu.com/search?q=%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:790551384%7D">二进制位</a>开始，依次从右往左填入上边格式中的<code>x</code>，多出的位补<code>0</code>。这样就得到了，<code>严</code>的 UTF-8 编码是<code>11100100 10111000 10100101</code>，转换成<a href="https://www.zhihu.com/search?q=%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:790551384%7D">十六进制</a>就是<code>E4 B8 A5</code>。</p><p><strong>优点</strong></p><ul><li>UTF-8是ASCII的一个<a href="http://zh.wikipedia.org/wiki/%E8%B6%85%E9%9B%86">超集</a>。因为一个纯ASCII字符串也是一个合法的UTF-8字符串，所以现存的ASCII文本不需要转换。为传统的扩展ASCII字符集设计的软件通常可以不经修改或很少修改就能与UTF-8一起使用。</li><li>使用标准的面向字节的排序例程对UTF-8排序将产生与*于Unicode代码点排序相同的结果。（尽管这只有有限的有用性，因为在任何特定语言或文化下都不太可能有仍可接受的文字排列顺序。）</li><li>UTF-8和UTF-16都是<a href="http://zh.wikipedia.org/wiki/%E5%8F%AF%E6%89%A9%E5%B1%95%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80">可扩展标记语言</a>文档的标准编码。所有其它编码都必须通过显式或文本声明来指定。</li><li>任何<a href="http://zh.wikipedia.org/w/index.php?title=%E9%9D%A2%E5%90%91%E5%AD%97%E8%8A%82&action=edit&redlink=1">面向字节</a>的<a href="http://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95">字符串搜索算法</a>都可以用于UTF-8的数据（只要输入仅由完整的UTF-8字符组成）。但是，对于包含字符记数的正则表达式或其它结构必须小心。</li><li>UTF-8字符串可以由一个简单的算法可靠地识别出来。就是，一个字符串在任何其它编码中表现为合法的UTF-8的可能性很低，并随字符串长度增长而减小。举例说，字符值C0,C1,F5至FF从来没有出现。为了更好的可靠性，可以使用正则表达式来统计非法过长和替代值（可以查看<a href="http://www.w3.org/International/questions/qa-forms-utf-8">W3 FAQ: Multilingual Forms</a>上的验证UTF-8字符串的正则表达式）。</li></ul><p><strong>缺点</strong></p><p>因为每个字符使用不同数量的字节编码，所以寻找串中第N个字符是一个O(N)复杂度的操作 — 即，串越长，则需要更多的时间来定位特定的字符。同时，还需要位变换来把字符编码成字节，把字节解码成字符。</p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>character encoding</tag>
      
      <tag>gb2312</tag>
      
      <tag>utf-8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VScode插件CommentTranslate在WSL内无效</title>
    <link href="/2022/1d3ed0f3/"/>
    <url>/2022/1d3ed0f3/</url>
    
    <content type="html"><![CDATA[<h1 id="VScode插件CommentTranslate在WSL内无效"><a href="#VScode插件CommentTranslate在WSL内无效" class="headerlink" title="VScode插件CommentTranslate在WSL内无效"></a>VScode插件CommentTranslate在WSL内无效</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/intellism/vscode-comment-translate/issues/64">https://github.com/intellism/vscode-comment-translate/issues/64</a></p><ol><li><p>找到相关语言语法规则文件。如C&#x2F;CPP、bat、css、java、python，这些文件都是在Windows版本的VSCode中内置的，文件路径在 <code>C:\Users\ **userNmae** \AppData\Local\Programs\Microsoft VS Code\resources\app\extensions</code>改过安装路径的是<code>Microsoft VS Code\resources\app\extensions</code></p><p><img src="/2022/1d3ed0f3/image-20220811202401467.png" alt="image-20220811202401467"></p></li></ol><p>​</p><ol><li><p>将语法规则的<strong>高亮规则</strong>文件夹拷贝到远程vscode的相关插件目录。以C语言为例，将<code>cpp</code>目录下的高亮规则文件夹<code>syntaxes</code>拷贝到远程C&#x2F;C++插件（<code>ms-vscode.cpptools-x.x.x</code>）目录下。如果你使用SSH远程，远程插件的目录在<code>~/.vscode-server/extensions/ms-vscode.cpptools-x.x.x</code>。</p><p><img src="/2022/1d3ed0f3/image-20220811202845203.png" alt="image-20220811202845203"></p></li><li><p>修改远程插件，添加语法高亮规则。修改远程插件的<code>package.json</code>文件，如C&#x2F;C++插件（<code>ms-vscode.cpptools-x.x.x</code>）目录下的<code>package.json</code>文件，将刚才cpp语法规则文件夹中的<code>package.json</code>文件的”<code>grammars</code>“部分拷贝出来，粘贴到远程插件的<code>package.json</code>的<code>contributes</code>部分中去。</p><p>如果遇到格式难以复制，可以全选内容然后按Shift+Alt+F格式化选定内容。<img src="/2022/1d3ed0f3/image-20220811202944334.png" alt="image-20220811202944334"></p></li></ol><p><img src="/2022/1d3ed0f3/image-20220811203114753.png" alt="image-20220811203114753"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-string">&quot;grammars&quot;</span>: [<br>          &#123;<br>              <span class="hljs-string">&quot;language&quot;</span>: <span class="hljs-string">&quot;c&quot;</span>,<br>              <span class="hljs-string">&quot;scopeName&quot;</span>: <span class="hljs-string">&quot;source.c&quot;</span>,<br>              <span class="hljs-string">&quot;path&quot;</span>: <span class="hljs-string">&quot;./syntaxes/c.tmLanguage.json&quot;</span><br>          &#125;,<br>          &#123;<br>              <span class="hljs-string">&quot;language&quot;</span>: <span class="hljs-string">&quot;cpp&quot;</span>,<br>              <span class="hljs-string">&quot;scopeName&quot;</span>: <span class="hljs-string">&quot;source.cpp.embedded.macro&quot;</span>,<br>              <span class="hljs-string">&quot;path&quot;</span>: <span class="hljs-string">&quot;./syntaxes/cpp.embedded.macro.tmLanguage.json&quot;</span><br>          &#125;,<br>          &#123;<br>              <span class="hljs-string">&quot;language&quot;</span>: <span class="hljs-string">&quot;cpp&quot;</span>,<br>              <span class="hljs-string">&quot;scopeName&quot;</span>: <span class="hljs-string">&quot;source.cpp&quot;</span>,<br>              <span class="hljs-string">&quot;path&quot;</span>: <span class="hljs-string">&quot;./syntaxes/cpp.tmLanguage.json&quot;</span><br>          &#125;,<br>          &#123;<br>              <span class="hljs-string">&quot;scopeName&quot;</span>: <span class="hljs-string">&quot;source.c.platform&quot;</span>,<br>              <span class="hljs-string">&quot;path&quot;</span>: <span class="hljs-string">&quot;./syntaxes/platform.tmLanguage.json&quot;</span><br>          &#125;,<br>          &#123;<br>              <span class="hljs-string">&quot;language&quot;</span>: <span class="hljs-string">&quot;cuda-cpp&quot;</span>,<br>              <span class="hljs-string">&quot;scopeName&quot;</span>: <span class="hljs-string">&quot;source.cuda-cpp&quot;</span>,<br>              <span class="hljs-string">&quot;path&quot;</span>: <span class="hljs-string">&quot;./syntaxes/cuda-cpp.tmLanguage.json&quot;</span><br>          &#125;<br>      ],<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vscode</tag>
      
      <tag>commenttranslate</tag>
      
      <tag>wsl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建KMS</title>
    <link href="/2022/3ef2a47d/"/>
    <url>/2022/3ef2a47d/</url>
    
    <content type="html"><![CDATA[<h1 id="KMS"><a href="#KMS" class="headerlink" title="KMS"></a>KMS</h1><p>KMS（Key Management Service），密钥管理服务</p><p>能够通过KMS进行激活的一般称为VL版,即VOLUME授权版，一般不会单独在零售市场进行发售，一般是直接向企业提供电子ISO映像进行批量授权安装，基于对KMS原理研究成果，我们可以自行搭建KMS激活服务器，实现每180天一次的自动激活，使得系统一直保持激活状态。</p><p>KMS可以激活VOL版本的windows系统和office软件</p><h1 id="Docker-部署KMS服务器"><a href="#Docker-部署KMS服务器" class="headerlink" title="Docker 部署KMS服务器"></a>Docker 部署KMS服务器</h1><p><a href="https://registry.hub.docker.com/r/teddysun/kms">https://registry.hub.docker.com/r/teddysun/kms</a></p><ol><li><p>Pull the image</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull teddysun/kms<br></code></pre></td></tr></table></figure><p>This pulls the latest release of KMS server. It can be found at Docker Hub.</p></li><li><p>Start a container</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d -p 1688:1688 --name kms --restart=always teddysun/kms<br></code></pre></td></tr></table></figure><p>Note: The TCP port number <code>1688</code> must be opened in firewall.</p></li></ol><h1 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h1><h2 id="激活windows"><a href="#激活windows" class="headerlink" title="激活windows"></a>激活windows</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 待激活的主机上指定KMS服务器</span><br>slmgr /skms service_address(你搭建的服务器的地址)<br><br><span class="hljs-comment"># 手动激活</span><br>slmgr /ato<br><br><span class="hljs-comment"># 如果激活失败 尝试更改成GVLK KEY再次激活</span><br><span class="hljs-comment"># 运行以下命令查看系统版本 </span><br>wmic os get caption<br><br><span class="hljs-comment"># 访问下面的网址获取key</span><br><span class="hljs-comment"># https://docs.microsoft.com/zh-cn/windows-server/get-started/kms-client-activation-keys</span><br><span class="hljs-comment"># https://technet.microsoft.com/en-us/library/jj612867.aspx</span><br><span class="hljs-comment"># 得到对应key之后，使用管理员权限运行cmd执行安装key：</span><br>slmgr /ipk xxxxx-xxxxx-xxxxx-xxxxx<br><br><span class="hljs-comment"># 手动激活</span><br>slmgr /ato<br></code></pre></td></tr></table></figure><h2 id="激活office"><a href="#激活office" class="headerlink" title="激活office"></a>激活office</h2><p>首先你的OFFICE必须是VOL版本，否则无法激活。 找到你的office安装目录，比如</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">C:<span class="hljs-string">\Program</span> Files (x86)<span class="hljs-string">\Microsoft</span> Office<span class="hljs-string">\Office16</span><br></code></pre></td></tr></table></figure><p>64位的就是</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">C:<span class="hljs-string">\Program</span> Files<span class="hljs-string">\Microsoft</span> Office<span class="hljs-string">\Office16</span><br></code></pre></td></tr></table></figure><p>office16是office2016，office15就是2013，office14就是2010.</p><p>然后目录对的话，该目录下面应该有个OSPP.VBS。</p><p>直接输入下面的指令去指定KMS服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">cscript <span class="hljs-string">&quot;C:\Program Files (x86)\Microsoft Office\Office16\OSPP.VBS&quot;</span> sethst:service_address(你搭建的服务器的地址)<br><span class="hljs-comment"># or</span><br>cscript <span class="hljs-string">&quot;C:\Program Files\Microsoft Office\Office16\OSPP.VBS&quot;</span> /sethst:service_address(你搭建的服务器的地址)<br></code></pre></td></tr></table></figure><p>一般来说，“一句命令已经完成了”，但一般office不会马上连接kms服务器进行激活，所以我们额外补充一条手动激活命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cscript ospp.vbs /act<br></code></pre></td></tr></table></figure><h1 id="如果遇到报错，请检查："><a href="#如果遇到报错，请检查：" class="headerlink" title="如果遇到报错，请检查："></a>如果遇到报错，请检查：</h1><blockquote><ol><li>你的系统&#x2F;OFFICE是否是批量VL版本</li><li>是否以管理员权限运行CMD</li><li>你的系统&#x2F;OFFICE是否修改过KEY&#x2F;未安装GVLK KEY</li><li>检查你的网络连接</li><li>服务器繁忙，多试试（点击检查KMS服务是否可用）</li><li>根据出错代码自己搜索出错原因</li></ol></blockquote><h2 id="windows没有密钥"><a href="#windows没有密钥" class="headerlink" title="windows没有密钥"></a>windows没有密钥</h2><ul><li>windows VOL KEY</li></ul><p><a href="https://docs.microsoft.com/zh-cn/windows-server/get-started/kmsclientkeys">https://docs.microsoft.com/zh-cn/windows-server/get-started/kmsclientkeys</a></p><h2 id="检查windows版本"><a href="#检查windows版本" class="headerlink" title="检查windows版本"></a>检查windows版本</h2><ul><li>检查office是否是VOL版本</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 命令提示符（管理员）执行：cd “office的安装目录”</span><br><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;C:\Program Files (x86)\Microsoft Office\Office16&quot;</span><br><span class="hljs-comment"># or</span><br><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;C:\Program Files\Microsoft Office\Office16&quot;</span><br><br><span class="hljs-comment"># 执行：</span><br>cscript ospp.vbs /dstatus<br></code></pre></td></tr></table></figure><p>在显示的信息中，如果有“VOLUME”字样就是VOL版，即支持KMS激活</p><h2 id="office-密钥"><a href="#office-密钥" class="headerlink" title="office 密钥"></a>office 密钥</h2><ul><li>卸载office的密钥</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 命令提示符（管理员）执行：cd “office的安装目录”</span><br><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;C:\Program Files (x86)\Microsoft Office\Office16&quot;</span><br><span class="hljs-comment"># or</span><br><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;C:\Program Files\Microsoft Office\Office16&quot;</span><br><br><span class="hljs-comment"># 查看当前状态</span><br>cscript ospp.vbs /dstatus<br><br><span class="hljs-comment"># 找到 Last 5 characters of installed product key:XXXXX 语句</span><br><span class="hljs-comment"># 卸载密钥</span><br>cscript ospp.vbs /unpkey:XXXXX<br></code></pre></td></tr></table></figure><ul><li>查找office的VOL KEY</li></ul><p><a href="https://docs.microsoft.com/zh-cn/DeployOffice/vlactivation/gvlks">https://docs.microsoft.com/zh-cn/DeployOffice/vlactivation/gvlks</a></p><ul><li><p>安装密钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Office 专业增强版 2016</span><br>cscript ospp.vbs /inpkey:XQNVK-8JYDB-WJ9W3-YJ8YR-WFG99<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kms</tag>
      
      <tag>office</tag>
      
      <tag>volume</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nintendo Switch</title>
    <link href="/2022/f15ac6f4/"/>
    <url>/2022/f15ac6f4/</url>
    
    <content type="html"><![CDATA[<h1 id="TX-转-大气层"><a href="#TX-转-大气层" class="headerlink" title="TX 转 大气层"></a>TX 转 大气层</h1><p><a href="https://www.bilibili.com/video/BV1DZ4y1B777/?spm_id_from=333.788">https://www.bilibili.com/video/BV1DZ4y1B777/?spm_id_from=333.788</a></p><h1 id="SD卡内文件结构"><a href="#SD卡内文件结构" class="headerlink" title="SD卡内文件结构"></a>SD卡内文件结构</h1><p><img src="/2022/f15ac6f4/image-20221103090149675.png" alt="image-20221103090149675"></p><ul><li><ul><li></li></ul></li></ul><h1 id="OS相关"><a href="#OS相关" class="headerlink" title="OS相关"></a>OS相关</h1><h2 id="三种不同的OS"><a href="#三种不同的OS" class="headerlink" title="三种不同的OS"></a>三种不同的OS</h2><p><img src="/2022/f15ac6f4/image-20221103092334424.png" alt="image-20221103092334424"></p><ul><li>大气层-真实系统<ul><li>使用的是机身的正版系统, 插件是使用的是大气层的插件</li></ul></li><li>大气层-虚拟系统<ul><li>使用的是SD卡内全虚拟的系统</li></ul></li></ul><h2 id="查看当前OS版本和环境"><a href="#查看当前OS版本和环境" class="headerlink" title="查看当前OS版本和环境"></a>查看当前OS版本和环境</h2><p><img src="/2022/f15ac6f4/image-20221103090700699.png" alt="image-20221103090700699"></p><h2 id="系统升级"><a href="#系统升级" class="headerlink" title="系统升级"></a>系统升级</h2><p><img src="/2022/f15ac6f4/image-20221103090149675.png" alt="image-20221103090149675"></p><ul><li>系统升级相关<ul><li>一般来说<code>Nintendo</code>和<code>emuMMC</code>是需要保留的文件, 其他文件是大气层系统相关的文件</li><li>小版本升级可以直接在相册内用<code>daybreak</code>升级<code>14.1.1-&gt;14.1.2</code>, 大版本升级<code>14.1.2-&gt;15.0.0</code>因为可能需要升级大气层系统(atmosphere)所以需要把SD卡拆下来, 删掉除了<code>Nintendo</code>和<code>emuMMC</code>之外的全部文件, 然后找升级包去覆盖掉.</li></ul></li></ul><h2 id="资源及参考链接"><a href="#资源及参考链接" class="headerlink" title="资源及参考链接"></a>资源及参考链接</h2><p><a href="https://darthsternie.net/switch-firmwares/">Switch 离线升级固件(分为 大陆版 和 全球版)</a></p><p><a href="https://shipengliang.com/games/switch-%E5%A4%A7%E6%B0%94%E5%B1%82-atmosphere-%E5%A6%82%E4%BD%95%E7%A6%BB%E7%BA%BF%E5%8D%87%E7%BA%A7%E7%B3%BB%E7%BB%9F.html">Switch 大气层 Atmosphere 如何离线升降级系统</a></p><p><a href="https://shipengliang.com/games/switch-firmware-%e5%9b%ba%e4%bb%b6%e4%b8%8b%e8%bd%bd.html">Switch Firmware固件最新版、NS 历史版本下载列表：</a></p><h1 id="安装游戏"><a href="#安装游戏" class="headerlink" title="安装游戏"></a>安装游戏</h1><ul><li>需要准备的工具<ul><li>游戏资源</li><li>NS-Usbloader PC端程序</li><li>Awoo NS端</li><li>USB-C 线缆</li></ul></li></ul><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><ul><li>优先点击广告, 请勿白嫖, 为众人抱薪者，不可使其冻毙于风雪</li></ul><p><a href="https://xxxxx520.com/27637.html">https://xxxxx520.com/27637.html</a></p><p><a href="https://xxxxx520.net/3892.html">https://xxxxx520.net/3892.html</a></p><h2 id="NS-Usbloader-PC端"><a href="#NS-Usbloader-PC端" class="headerlink" title="NS-Usbloader PC端"></a>NS-Usbloader PC端</h2><ul><li>通过USB安装游戏, 以及电脑端开机注入都可用</li><li>这个需要java环境, 安装JRE(Java Runtime Environment)即可.</li></ul><p><a href="https://github.com/developersu/ns-usbloader/">https://github.com/developersu/ns-usbloader/</a></p><h2 id="Awoo-NS端"><a href="#Awoo-NS端" class="headerlink" title="Awoo NS端"></a>Awoo NS端</h2><ul><li>NS端安装游戏</li></ul><p><a href="https://github.com/Huntereb/Awoo-Installer">https://github.com/Huntereb/Awoo-Installer</a></p><h1 id="特斯拉插件-Tesla-Menu-类似快捷菜单"><a href="#特斯拉插件-Tesla-Menu-类似快捷菜单" class="headerlink" title="特斯拉插件(Tesla-Menu) 类似快捷菜单"></a>特斯拉插件(Tesla-Menu) 类似快捷菜单</h1><blockquote><p>  <strong>Switch特斯拉插件</strong>(Tesla-Menu)是一个很实用的功能插件的集合。可以直接在switch系统的任何界面通过组合按键调取左屏幕弹窗打开各种功能的快捷开关！目前已经实现的，开关switch硬件信息显示，开关FPS显示，<strong>开关超频</strong>，切换TV模式，这个平台就好比是简洁版相册，相册里面的各种软件就是完整版，这个Tesla-Menu平台提供的功能就相当于缩减版！不用复杂的操作，只是简单的开关，好处就是精简不占用太多资源！不用来返相册去开关软件！</p></blockquote><p>调出菜单: <code>L + ↓</code></p><p>FPS界面调出: 同时按下 <code>左右摇杆</code></p><h1 id="金手指-作弊器"><a href="#金手指-作弊器" class="headerlink" title="金手指(作弊器)"></a>金手指(作弊器)</h1><p>进入NS的相册, 将NS作为U盘挂载到电脑, <code>DBI -&gt; Run MTP responder</code>, 找到这个目录<code>此电脑\Switch\1: External SD Card\atmosphere\contents</code>这个目录就是NS的金手指存放位置.</p><p>目录下64位16进制的文件夹名, 这个序号就代表着不同的游戏.</p><p>我们找到对应游戏, 打开文件夹后, 里面会有一个<code>cheats</code>的文件夹, 我们打开它, 里面有一个<code>*.txt</code>文件, 这个文件应该记录的就是内存地址, 我们去网络上找到别人保存好的内存地址信息(<code>cheats</code>文件), 放到这个<code>atmosphere\contents</code>目录下, 在NS端就能看到对应的金手指修改选项了, 注意可能需要关掉游戏重新开一下.</p><h2 id="64位游戏ID-对应-游戏名查询"><a href="#64位游戏ID-对应-游戏名查询" class="headerlink" title="64位游戏ID 对应 游戏名查询"></a>64位游戏ID 对应 游戏名查询</h2><p>调出特斯拉界面选择金手指, 即可查到游戏ID</p><p><a href="https://github.com/ibnux/switch-cheat/blob/master/GAMES.md">https://github.com/ibnux/switch-cheat/blob/master/GAMES.md</a></p><p><a href="https://switchbrew.org/w/index.php?title=Title_list/Games">https://switchbrew.org/w/index.php?title=Title_list/Games</a></p><h2 id="cheats-金手指"><a href="#cheats-金手指" class="headerlink" title="cheats 金手指"></a>cheats 金手指</h2><p><a href="https://github.com/ibnux/switch-cheat">https://github.com/ibnux/switch-cheat</a></p>]]></content>
    
    
    <categories>
      
      <category>more_interest</category>
      
    </categories>
    
    
    <tags>
      
      <tag>switch</tag>
      
      <tag>nintendo</tag>
      
      <tag>game</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSL证书的申请和自动续期</title>
    <link href="/2022/82aca4fc/"/>
    <url>/2022/82aca4fc/</url>
    
    <content type="html"><![CDATA[<h1 id="SSL证书的申请和自动续期"><a href="#SSL证书的申请和自动续期" class="headerlink" title="SSL证书的申请和自动续期"></a>SSL证书的申请和自动续期</h1><p>Let’s Encrypt 证书续期</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/a2d0209fa3f5">https://www.jianshu.com/p/a2d0209fa3f5</a></p><p><a href="https://www.cnblogs.com/esofar/p/9291685.html">快速签发 Let’s Encrypt 证书指南</a></p><p><a href="https://certbot.eff.org/">https://certbot.eff.org/</a></p><h1 id="acme-sh-申请"><a href="#acme-sh-申请" class="headerlink" title="acme.sh 申请"></a>acme.sh 申请</h1><p>用 acme.sh申请来自动续期ssl证书<br> acme说明：<a href="https://links.jianshu.com/go?to=https://github.com/Neilpang/acme.sh/wiki/%E8%AF%B4%E6%98%8E">https://github.com/Neilpang/acme.sh/wiki/说明</a></p><ol><li>下载acme<code>curl https://get.acme.sh | sh</code>  安装完成后必须关闭当前终端，重新开启一个以使acme.sh命令生效</li><li>执行生成和自动更新命令：<code>acme.sh --issue -d mydomain.com -d www.mydomain.com --webroot /var/www/mydomain.com/</code></li><li>安装证书 <code>cd /etc/nginx; mkdir ssl</code></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">acme.sh  --installcert  -d  <span class="hljs-tag">&lt;<span class="hljs-name">domain</span>&gt;</span>.com   \<br>        --key-file   /etc/nginx/ssl/<span class="hljs-tag">&lt;<span class="hljs-name">domain</span>&gt;</span>.key \<br>        --fullchain-file /etc/nginx/ssl/fullchain.cer \<br>        --reloadcmd  &quot;service nginx force-reload&quot;<br></code></pre></td></tr></table></figure><ol start="4"><li>配置nginx使用ssl</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash">server &#123;<br>    listen 80 default_server;<br>    listen 443 http2 ssl;<br>    listen [::]:80 default_server;<br><br>    ssl_certificate /etc/nginx/ssl/fullchain.cer;<br>    ssl_certificate_key /etc/nginx/ssl/domain.key;<br>    <span class="hljs-comment">#http转https</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable">$scheme</span> = http ) &#123;<span class="hljs-built_in">return</span> 301 https://$host<span class="hljs-variable">$request_uri</span>;&#125;<br>    root /var/www/html;<br><br>    index index.html index.htm index.nginx-debian.html;<br>    server_name _;<br><br>    ssl_certificate /etc/nginx/ssl/fullchain.cer;<br>    ssl_certificate_key /etc/nginx/ssl/domain.key;<br><br>    location /test &#123;<br>          proxy_pass       http://127.0.0.1:3000;<br>          proxy_http_version 1.1;<br>          proxy_set_header Upgrade <span class="hljs-variable">$http_upgrade</span>;<br>          proxy_set_header Connection <span class="hljs-string">&quot;upgrade&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>前端的Upgrade请求发送给后端服务器，Upgrade和Connection的头信息必须被显式的设置。一旦我们完成以上设置，NGINX就可以处理WebSocket连接了。查看配置在哪里<code>ps -ef|grep nginx</code><br> 多个域名的话，配多个nginx.conf配置。</p><ol start="5"><li>查看是否有每日任务<br> <code>crontab -l #查看你的任务</code><br> 手动更新证书<code>acme.sh --renew -d domain.com</code></li></ol><h1 id="certbot"><a href="#certbot" class="headerlink" title="certbot"></a>certbot</h1><p><a href="https://certbot.eff.org/">文档</a></p><p>Ubuntu + nginx <a href="https://certbot.eff.org/instructions?ws=nginx&amp;os=ubuntufocal">https://certbot.eff.org/instructions?ws=nginx&amp;os=ubuntufocal</a></p><p>用certbot来自动续期ssl证书</p><ul><li>需要注意的是安装证书的时候最好把nginx关掉先</li></ul>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ssl</tag>
      
      <tag>https</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker</title>
    <link href="/2022/f5f9fa9b/"/>
    <url>/2022/f5f9fa9b/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h1 id="Docker是什么-amp-如何理解Docker"><a href="#Docker是什么-amp-如何理解Docker" class="headerlink" title="Docker是什么&amp;如何理解Docker"></a>Docker是什么&amp;如何理解Docker</h1><p>Docker的底层原理</p><p>cgroup</p><p>namespace</p><p>容器(container)有不同的状态, 停止状态</p><p>镜像(image)是docker生命周期中的构建或打包阶段, 而容器(container)则是启动或执行阶段.</p><p>docker hub</p><p>!!ADD ME!!</p><p><img src="/2022/f5f9fa9b/architecture.svg" alt="Docker Architecture Diagram"></p><p><img src="/2022/f5f9fa9b/mark4536000.image" alt="img"></p><p><img src="/2022/f5f9fa9b/watermark16682557597978.png" alt="x"></p><p><img src="/2022/f5f9fa9b/watermark.png" alt="xx"></p><p><img src="/2022/f5f9fa9b/202111041612065293278565.png" alt="何種應用適合PaaS平台容器/微服務架構釋疑| 網管人"></p><h2 id="Docker-和-VM-的区别"><a href="#Docker-和-VM-的区别" class="headerlink" title="Docker 和 VM 的区别"></a>Docker 和 VM 的区别</h2><p>二者的不同：</p><ul><li>VM(VMware)在宿主机器、宿主机器操作系统的基础上创建虚拟层、虚拟化的操作系统、虚拟化的仓库，然后再安装应用；</li><li>Container(Docker容器)，在宿主机器、宿主机器操作系统上创建Docker引擎，在引擎的基础上再安装应用。</li></ul><p><img src="/2022/f5f9fa9b/9114e4a753de14a7531e867b908e6660.png" alt="img"></p><p><strong>与传统VM特性对比：</strong><br>作为一种轻量级的虚拟化方式，Docker在运行应用上跟传统的虚拟机方式相比具有显著优势：</p><ul><li>Docker 容器很快，启动和停止可以在秒级实现，这相比传统的虚拟机方式要快得多。</li><li>Docker 容器对系统资源需求很少，一台主机上可以同时运行数千个Docker容器。</li><li>Docker 通过类似Git的操作来方便用户获取、分发和更新应用镜像，指令简明，学习成本较低。</li><li>Docker 通过Dockerfile配置文件来支持灵活的自动化创建和部署机制，提高工作效率。</li><li>Docker 容器除了运行其中的应用之外，基本不消耗额外的系统资源，保证应用性能的同时，尽量减小系统开销。</li><li>Docker 利用Linux系统上的多种防护机制实现了严格可靠的隔离。从1.3版本开始，Docker引入了安全选项和镜像签名机制，极大地提高了使用Docker的安全性。</li></ul><table><thead><tr><th>特性</th><th>Docker</th><th>VM</th></tr></thead><tbody><tr><td>启动速度</td><td>秒级</td><td>分钟级</td></tr><tr><td>硬盘使用</td><td>一般为MB</td><td>一般为GB</td></tr><tr><td>性能</td><td>接近原生</td><td>弱于原生</td></tr><tr><td>系统支持量</td><td>单机支持上千个容器</td><td>一般几十个</td></tr></tbody></table><h1 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h1><p>参考官方的安装<a href="https://docs.docker.com/get-docker/">文档</a></p><p>Ubuntu的安装参考<a href="https://docs.docker.com/desktop/install/ubuntu/">文档</a></p><h1 id="Docker入门-amp-命令"><a href="#Docker入门-amp-命令" class="headerlink" title="Docker入门&amp;命令"></a>Docker入门&amp;命令</h1><h2 id="☆-docker-run"><a href="#☆-docker-run" class="headerlink" title="☆ docker run"></a>☆ docker run</h2><p><strong>docker run ：</strong>创建一个新的容器并运行一个命令</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><code>-a stdin</code>: 指定标准输入输出内容类型，可选 STDIN&#x2F;STDOUT&#x2F;STDERR 三项；</li><li><code>-d</code>: 后台运行容器，并返回容器ID；</li><li>☆<code>-i</code>: 以交互模式运行容器，通常与 -t 同时使用；</li><li><code>-P</code>: 随机端口映射，容器内部端口<strong>随机</strong>映射到主机的端口</li><li><code>-p</code>: 指定端口映射，格式为：<strong>主机(宿主)端口:容器端口</strong></li><li>☆<code>-t</code>: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</li><li>☆<code>--name=&quot;nginx-lb&quot;</code>: 为容器指定一个名称；</li><li><code>--dns 8.8.8.8</code>: 指定容器使用的DNS服务器，默认和宿主一致；</li><li><code>--dns-search example.com</code>: 指定容器DNS搜索域名，默认和宿主一致；</li><li><code>-h &quot;mars&quot;</code>: 指定容器的hostname；</li><li>☆<code>-e username=&quot;ritchie&quot;</code>: 设置环境变量；</li><li><code>--env-file=[]</code>: 从指定文件读入环境变量；</li><li><code>--cpuset=&quot;0-2&quot; or --cpuset=&quot;0,1,2&quot;</code>: 绑定容器到指定CPU运行；</li><li><code>-m</code>:设置容器使用内存最大值；</li><li><code>--net=&quot;bridge&quot;</code>: 指定容器的网络连接类型，支持 bridge&#x2F;host&#x2F;none&#x2F;container: 四种类型；</li><li><code>--link=[]</code>: 添加链接到另一个容器；</li><li><code>--expose=[]</code>: 开放一个端口或一组端口；</li><li>☆<code>--volume , -v</code>: 绑定一个卷, (或者称作<strong>映射文件夹</strong>，将特定文件夹映射到特定目录)</li></ul><h3 id="设置工作目录-w"><a href="#设置工作目录-w" class="headerlink" title="设置工作目录 (-w)"></a>设置工作目录 (-w)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker  run -w /path/to/dir/ -i -t  ubuntu <span class="hljs-built_in">pwd</span><br>/path/to/dir<br></code></pre></td></tr></table></figure><p><code>-w</code> 允许命令在给定的目录中执行，这里是 <code>/path/to/dir/</code>。 如果路径不存在，则在容器内创建。</p><h3 id="挂载卷-v-–read-only"><a href="#挂载卷-v-–read-only" class="headerlink" title="挂载卷 (-v, –read-only)"></a>挂载卷 (-v, –read-only)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker  run  -v `<span class="hljs-built_in">pwd</span>`:`<span class="hljs-built_in">pwd</span>` -w `<span class="hljs-built_in">pwd</span>` -i -t  ubuntu <span class="hljs-built_in">pwd</span><br><br><span class="hljs-comment"># 只读(ro)和读写(rw)权限</span><br>docker run -v <span class="hljs-variable">$PWD</span>/web:var/www/html/web:ro<br></code></pre></td></tr></table></figure><p><code>-v</code>标志将当前工作目录挂载到容器中。 <code>-w</code> 让命令在当前工作目录中执行，方法是将工作目录更改为pwd返回的值。所以这个组合使用容器执行命令，但在当前工作目录中。</p><h3 id="发布或者暴露端口-p-–expose"><a href="#发布或者暴露端口-p-–expose" class="headerlink" title="发布或者暴露端口 (-p, –expose)"></a>发布或者暴露端口 (-p, –expose)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -p 127.0.0.1:80:8080/tcp ubuntu bash<br></code></pre></td></tr></table></figure><p>这将容器的端口8080绑定到主机的127.0.0.1上的TCP端口80。还可以指定udp和sctp端口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run --expose 80 ubuntu bash<br></code></pre></td></tr></table></figure><p>这会暴露容器的端口80，而不会将端口发布到主机系统接口。</p><h3 id="设置环境变量-e-–env-–env-file"><a href="#设置环境变量-e-–env-–env-file" class="headerlink" title="设置环境变量(-e, –env, –env-file)"></a>设置环境变量(-e, –env, –env-file)</h3><p>可以通过<code>-e, --env, --env-file</code> 设置容器的环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -e MYVAR1 --<span class="hljs-built_in">env</span> MYVAR2=foo --env-file ./env.list ubuntu bash<br></code></pre></td></tr></table></figure><p>本地已经export的环境变量，可以不用&#x3D;号和值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> VAR1=value1<br><span class="hljs-built_in">export</span> VAR2=value2<br><br>$ docker run --<span class="hljs-built_in">env</span> VAR1 --<span class="hljs-built_in">env</span> VAR2 ubuntu <span class="hljs-built_in">env</span> | grep VAR<br>VAR1=value1<br>VAR2=value2<br></code></pre></td></tr></table></figure><h3 id="在容器上设置元数据-l-–label-–label-file"><a href="#在容器上设置元数据-l-–label-–label-file" class="headerlink" title="在容器上设置元数据(-l, –label, –label-file)"></a>在容器上设置元数据(-l, –label, –label-file)</h3><p>可以通过<code>-l, --label, --label-file</code> 设置容器的label：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -l my-label --label com.example.foo=bar ubuntu bash<br></code></pre></td></tr></table></figure><h3 id="将容器连接到网络-–network"><a href="#将容器连接到网络-–network" class="headerlink" title="将容器连接到网络(–network)"></a>将容器连接到网络(–network)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -itd --network=my-net busybox<br>docker run -itd --network=my-net --ip=10.10.9.75 busybox<br></code></pre></td></tr></table></figure><p>也可以使用 <code>docker connect</code> 命令</p><h3 id="从容器挂载卷-–volumes-from"><a href="#从容器挂载卷-–volumes-from" class="headerlink" title="从容器挂载卷(–volumes-from)"></a>从容器挂载卷(–volumes-from)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run --volumes-from 777f7dc92da7 --volumes-from ba8c0c54f0f2:ro -i -t ubuntu <span class="hljs-built_in">pwd</span><br></code></pre></td></tr></table></figure><h2 id="☆-docker-start-x2F-stop-x2F-restart"><a href="#☆-docker-start-x2F-stop-x2F-restart" class="headerlink" title="☆ docker start&#x2F;stop&#x2F;restart"></a>☆ docker start&#x2F;stop&#x2F;restart</h2><p><strong>docker start</strong> :启动一个或多个已经被停止的容器</p><p><strong>docker stop</strong> :停止一个运行中的容器</p><p><strong>docker restart</strong> :重启容器</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker start [OPTIONS] CONTAINER [CONTAINER...]<br>docker stop [OPTIONS] CONTAINER [CONTAINER...]<br>docker restart [OPTIONS] CONTAINER [CONTAINER...]<br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><p>启动已被停止的容器myrunoob</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker start myrunoob<br></code></pre></td></tr></table></figure><p>停止运行中的容器myrunoob</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker stop myrunoob<br></code></pre></td></tr></table></figure><p>重启容器myrunoob</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker restart myrunoob<br></code></pre></td></tr></table></figure><h2 id="docker-kill"><a href="#docker-kill" class="headerlink" title="docker kill"></a>docker kill</h2><p><strong>docker kill</strong> :杀掉一个运行中的容器。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker kill [OPTIONS] CONTAINER [CONTAINER...]<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><code>-s</code>:向容器发送一个信号</li></ul><p><strong>实例</strong></p><p>杀掉运行中的容器“docker_ubuntu”</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">kill</span> -s KILL docker_ubuntu</span><br>docker_ubuntu<br></code></pre></td></tr></table></figure><h2 id="☆-docker-rm"><a href="#☆-docker-rm" class="headerlink" title="☆ docker rm"></a>☆ docker rm</h2><p><strong>docker rm ：</strong>删除一个或多个容器。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rm [OPTIONS] CONTAINER [CONTAINER...]<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><code>-f</code> :通过 SIGKILL 信号强制删除一个运行中的容器。</li><li><code>-l</code>:移除容器间的网络连接，而非容器本身。</li><li><code>-v</code>:删除与容器关联的卷。</li></ul><p><strong>实例</strong></p><p>强制删除容器 db01、db02：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rm -f db01 db02<br></code></pre></td></tr></table></figure><p>移除容器 nginx01 对容器 db01 的连接，连接名 db：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rm -l db <br></code></pre></td></tr></table></figure><p>删除容器 nginx01, 并删除容器挂载的数据卷：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rm -v nginx01<br></code></pre></td></tr></table></figure><p>删除所有已经停止的容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rm $(docker ps -a -q)<br></code></pre></td></tr></table></figure><h2 id="docker-pause-x2F-unpause"><a href="#docker-pause-x2F-unpause" class="headerlink" title="docker pause&#x2F;unpause"></a>docker pause&#x2F;unpause</h2><p><strong>docker pause</strong> :暂停容器中所有的进程。</p><p><strong>docker unpause</strong> :恢复容器中所有的进程。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pause CONTAINER [CONTAINER...]<br>docker unpause CONTAINER [CONTAINER...]<br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><p>暂停数据库容器db01提供服务。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pause db01<br></code></pre></td></tr></table></figure><p>恢复数据库容器 db01 提供服务。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker unpause db01<br></code></pre></td></tr></table></figure><h2 id="docker-create"><a href="#docker-create" class="headerlink" title="docker create"></a>docker create</h2><p><strong>docker create ：</strong>创建一个新的容器但不启动它</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker create [OPTIONS] IMAGE [COMMAND] [ARG...]<br></code></pre></td></tr></table></figure><p>语法同 <code>docker run</code></p><p><strong>实例</strong></p><p>使用docker镜像nginx:latest创建一个容器,并将容器命名为myrunoob</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker create  --name myrunoob  nginx:latest      <br>09b93464c2f75b7b69f83d56a9cfc23ceb50a48a9db7652ee4c27e3e2cb1961f<br></code></pre></td></tr></table></figure><h2 id="☆-docker-exec"><a href="#☆-docker-exec" class="headerlink" title="☆ docker exec"></a>☆ docker exec</h2><p><strong>docker exec ：</strong>在运行的容器中执行命令</p><ul><li>典型的使用, 在docker中运行<code>bash</code>, 所使用的命令就是<code>docker exec -ti my_container /bin/bash</code></li></ul><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec [OPTIONS] CONTAINER COMMAND [ARG...]<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><code>-d</code>:分离模式: 在后台运行</li><li><code>-i</code>:即使没有附加也保持STDIN 打开</li><li><code>-t</code>:分配一个伪终端</li></ul><p><strong>实例</strong></p><p>在容器 mynginx 中以交互模式执行容器内 &#x2F;root&#x2F;runoob.sh 脚本:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker exec -it mynginx /bin/sh /root/runoob.sh<br>http://www.runoob.com/<br></code></pre></td></tr></table></figure><p>在容器 mynginx 中开启一个交互模式的终端:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker exec -i -t  mynginx /bin/bash<br>root@b1a0703e41e7:/#<br></code></pre></td></tr></table></figure><p>也可以通过 <strong>docker ps -a</strong> 命令查看已经在运行的容器，然后使用容器 ID 进入容器。</p><p>查看已经在运行的容器 ID：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">docker ps -a</span> <br>...<br>9df70f9a0714        openjdk             &quot;/usercode/script.sh…&quot; <br>...<br></code></pre></td></tr></table></figure><p>第一列的 9df70f9a0714 就是容器 ID。</p><p>通过 exec 命令对指定的容器执行 bash:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">docker <span class="hljs-built_in">exec</span> -it 9df70f9a0714 /bin/bash</span><br></code></pre></td></tr></table></figure><h2 id="↓-容器管理-container-↓"><a href="#↓-容器管理-container-↓" class="headerlink" title="↓ 容器管理 container ↓"></a>↓ 容器管理 container ↓</h2><h2 id="☆-docker-ps"><a href="#☆-docker-ps" class="headerlink" title="☆ docker ps"></a>☆ docker ps</h2><p><strong>docker ps :</strong> 列出容器</p><ul><li>典型使用方法, 列出所有的容器(container), <code>docker ps -a</code></li></ul><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker ps [OPTIONS]<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><code>-a</code> :显示所有的容器，包括未运行的。</li><li><code>-f</code> :根据条件过滤显示的内容。</li><li><code>--format</code> :指定返回值的模板文件。</li><li><code>-l</code>:显示最近创建的容器。</li><li><code>-n</code>:列出最近创建的n个容器。</li><li><code>--no-trunc</code> :不截断输出。</li><li><code>-q</code> :静默模式，只显示容器编号。</li><li><code>-s</code>:显示总的文件大小。</li></ul><p><strong>实例</strong></p><p>列出所有在运行的容器信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker ps<br>CONTAINER ID   IMAGE          COMMAND                ...  PORTS                    NAMES<br>09b93464c2f7   nginx:latest   &quot;nginx -g &#x27;daemon off&quot; ...  80/tcp, 443/tcp          myrunoob<br>96f7f14e99ab   mysql:5.6      &quot;docker-entrypoint.sh&quot; ...  0.0.0.0:3306-&gt;3306/tcp   mymysql<br></code></pre></td></tr></table></figure><p>输出详情介绍：</p><p><strong>CONTAINER ID:</strong> 容器 ID。</p><p><strong>IMAGE:</strong> 使用的镜像。</p><p><strong>COMMAND:</strong> 启动容器时运行的命令。</p><p><strong>CREATED:</strong> 容器的创建时间。</p><p><strong>STATUS:</strong> 容器状态。</p><p>状态有7种：</p><ul><li>created（已创建）</li><li>restarting（重启中）</li><li>running（运行中）</li><li>removing（迁移中）</li><li>paused（暂停）</li><li>exited（停止）</li><li>dead（死亡）</li></ul><p><strong>PORTS:</strong> 容器的端口信息和使用的连接类型（tcp\udp）。</p><p><strong>NAMES:</strong> 自动分配的容器名称。</p><p>列出最近创建的5个容器信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker ps -n 5<br>CONTAINER ID        IMAGE               COMMAND                   CREATED           <br>09b93464c2f7        nginx:latest        &quot;nginx -g &#x27;daemon off&quot;    2 days ago   ...     <br>b8573233d675        nginx:latest        &quot;/bin/bash&quot;               2 days ago   ...     <br>b1a0703e41e7        nginx:latest        &quot;nginx -g &#x27;daemon off&quot;    2 days ago   ...    <br>f46fb1dec520        5c6e1090e771        &quot;/bin/sh -c &#x27;set -x \t&quot;   2 days ago   ...   <br>a63b4a5597de        860c279d2fec        &quot;bash&quot;                    2 days ago   ...<br></code></pre></td></tr></table></figure><p>列出所有创建的容器ID。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker ps -a -q<br>09b93464c2f7<br>b8573233d675<br>b1a0703e41e7<br>f46fb1dec520<br>a63b4a5597de<br>6a4aa42e947b<br>de7bb36e7968<br>43a432b73776<br>664a8ab1a585<br>ba52eb632bbd<br>...<br></code></pre></td></tr></table></figure><h2 id="docker-inspect-获取容器信息"><a href="#docker-inspect-获取容器信息" class="headerlink" title="docker inspect 获取容器信息"></a>docker inspect 获取容器信息</h2><p><strong>docker inspect :</strong> 获取容器&#x2F;镜像的元数据。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker inspect [OPTIONS] NAME|ID [NAME|ID...]<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><code>-f</code> :指定返回值的模板文件。</li><li><code>-s</code>显示总的文件大小。</li><li><code>--type</code>为指定类型返回JSON。</li></ul><p><strong>实例</strong></p><p>获取镜像mysql:5.6的元信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker inspect mysql:5.6<br>[<br>    &#123;<br>        &quot;Id&quot;: &quot;sha256:2c0964ec182ae9a045f866bbc2553087f6e42bfc16074a74fb820af235f070ec&quot;,<br>        &quot;RepoTags&quot;: [<br>            &quot;mysql:5.6&quot;<br>        ],<br>        &quot;RepoDigests&quot;: [],<br>        &quot;Parent&quot;: &quot;&quot;,<br>        &quot;Comment&quot;: &quot;&quot;,<br>        &quot;Created&quot;: &quot;2016-05-24T04:01:41.168371815Z&quot;,<br>        &quot;Container&quot;: &quot;e0924bc460ff97787f34610115e9363e6363b30b8efa406e28eb495ab199ca54&quot;,<br>        &quot;ContainerConfig&quot;: &#123;<br>            &quot;Hostname&quot;: &quot;b0cf605c7757&quot;,<br>            &quot;Domainname&quot;: &quot;&quot;,<br>            &quot;User&quot;: &quot;&quot;,<br>            &quot;AttachStdin&quot;: false,<br>            &quot;AttachStdout&quot;: false,<br>            &quot;AttachStderr&quot;: false,<br>            &quot;ExposedPorts&quot;: &#123;<br>                &quot;3306/tcp&quot;: &#123;&#125;<br>            &#125;,<br>...<br></code></pre></td></tr></table></figure><p>获取正在运行的容器mymysql的 IP。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker inspect --format=&#x27;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27; mymysql<br>172.17.0.3<br></code></pre></td></tr></table></figure><h2 id="☆-docker-top-查看容器内进程信息"><a href="#☆-docker-top-查看容器内进程信息" class="headerlink" title="☆ docker top 查看容器内进程信息"></a>☆ docker top 查看容器内进程信息</h2><p>**docker top :**查看容器中运行的进程信息，支持 ps 命令参数。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker top [OPTIONS] CONTAINER [ps OPTIONS]<br></code></pre></td></tr></table></figure><p>容器运行时不一定有&#x2F;bin&#x2F;bash终端来交互执行top命令，而且容器还不一定有top命令，可以使用docker top来实现查看container中正在运行的进程。</p><p><strong>实例</strong></p><p>查看容器mymysql的进程信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~/mysql$ docker top mymysql<br>UID    PID    PPID    C      STIME   TTY  TIME       CMD<br>999    40347  40331   18     00:58   ?    00:00:02   mysqld<br></code></pre></td></tr></table></figure><p>查看所有运行容器的进程信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span>  `docker ps |grep Up|awk <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span>`;<span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span> \ &amp;&amp;docker top <span class="hljs-variable">$i</span>; <span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><h2 id="docker-attach-附着容器"><a href="#docker-attach-附着容器" class="headerlink" title="docker attach 附着容器"></a>docker attach 附着容器</h2><p>**docker attach :**附着到正在运行中的容器。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker attach [OPTIONS] CONTAINER<br></code></pre></td></tr></table></figure><p><code>--no-stdin=false</code> 不连接标准输入</p><p><code>--sig-proxy=true</code> 将所有信号传递给进程（非TTY模式时也一样）但不传送SIGCHLD、SIGKILL、SIGSTOP信号。经常使用的信号如下：</p><h4 id="detach"><a href="#detach" class="headerlink" title="detach"></a><strong>detach</strong></h4><p>要在不退出 shell 的情况下分离 tty，请使用转义序列<code>Ctrl+P</code>后跟<code>Ctrl+ Q</code>。更多细节<a href="https://docs.docker.com/engine/reference/commandline/attach/">在这里</a>。</p><ul><li>docker run -t -i → 可以<code>^P^Q</code>使用 docker attach 分离和重新附加</li><li>docker run -i → 不能用<code>^P^Q</code>;分离 会破坏标准输入</li><li>docker run → 不能用<code>^P^Q</code>;分离 可以 SIGKILL 客户端；可以使用 docker attach 重新附加</li><li><code>docker attach --sig-proxy=false</code> 可以使用 <code>^C</code>来进行detach, <code>CTRL+c</code></li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a><strong>注意</strong></h3><p>要attach上去的容器必须正在运行，可以同时连接上同一个container来共享屏幕（与screen命令的attach类似）。</p><blockquote><p>  官方文档中说attach后可以通过CTRL-C来detach，但实际上经过我的测试，如果container当前在运行bash，CTRL-C自然是当前行的输入，没有退出；如果container当前正在前台运行进程，如输出nginx的access.log日志，CTRL-C不仅会导致退出容器，而且还stop了。这不是我们想要的，detach的意思按理应该是脱离容器终端，但容器依然运行。好在attach是可以带上–sig-proxy&#x3D;false来确保CTRL-D或CTRL-C不会关闭容器。</p></blockquote><p><strong>实例</strong></p><p>容器mynginx将访问日志指到标准输出，连接到容器查看访问信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker attach --sig-proxy=false mynginx<br>192.168.239.1 - - [10/Jul/2016:16:54:26 +0000] &quot;GET / HTTP/1.1&quot; 304 0 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36&quot; &quot;-&quot;<br></code></pre></td></tr></table></figure><h2 id="docker-events"><a href="#docker-events" class="headerlink" title="docker events"></a>docker events</h2><p><strong>docker events :</strong> 从服务器获取实时事件</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker events [OPTIONS]<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><strong>-f ：</strong>根据条件过滤事件；</li><li><strong>–since ：</strong>从指定的时间戳后显示所有事件;</li><li><strong>–until ：</strong>流水时间显示到指定的时间为止；</li></ul><p><strong>实例</strong></p><p>显示docker 2016年7月1日后的所有事件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~/mysql$ docker events  --since=&quot;1467302400&quot;<br>2016-07-08T19:44:54.501277677+08:00 network connect 66f958fd13dc4314ad20034e576d5c5eba72e0849dcc38ad9e8436314a4149d4 (container=b8573233d675705df8c89796a2c2687cd8e36e03646457a15fb51022db440e64, name=bridge, type=bridge)<br>2016-07-08T19:44:54.723876221+08:00 container start b8573233d675705df8c89796a2c2687cd8e36e03646457a15fb51022db440e64 (image=nginx:latest, name=elegant_albattani)<br>2016-07-08T19:44:54.726110498+08:00 container resize b8573233d675705df8c89796a2c2687cd8e36e03646457a15fb51022db440e64 (height=39, image=nginx:latest, name=elegant_albattani, width=167)<br>2016-07-08T19:46:22.137250899+08:00 container die b8573233d675705df8c89796a2c2687cd8e36e03646457a15fb51022db440e64 (exitCode=0, image=nginx:latest, name=elegant_albattani)<br>...<br></code></pre></td></tr></table></figure><p>显示docker 镜像为mysql:5.6 2016年7月1日后的相关事件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~/mysql$ docker events -f &quot;image&quot;=&quot;mysql:5.6&quot; --since=&quot;1467302400&quot; <br>2016-07-11T00:38:53.975174837+08:00 container start 96f7f14e99ab9d2f60943a50be23035eda1623782cc5f930411bbea407a2bb10 (image=mysql:5.6, name=mymysql)<br>2016-07-11T00:51:17.022572452+08:00 container kill 96f7f14e99ab9d2f60943a50be23035eda1623782cc5f930411bbea407a2bb10 (image=mysql:5.6, name=mymysql, signal=9)<br>2016-07-11T00:51:17.132532080+08:00 container die 96f7f14e99ab9d2f60943a50be23035eda1623782cc5f930411bbea407a2bb10 (exitCode=137, image=mysql:5.6, name=mymysql)<br>2016-07-11T00:51:17.514661357+08:00 container destroy 96f7f14e99ab9d2f60943a50be23035eda1623782cc5f930411bbea407a2bb10 (image=mysql:5.6, name=mymysql)<br>2016-07-11T00:57:18.551984549+08:00 container create c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (image=mysql:5.6, name=mymysql)<br>2016-07-11T00:57:18.557405864+08:00 container attach c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (image=mysql:5.6, name=mymysql)<br>2016-07-11T00:57:18.844134112+08:00 container start c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (image=mysql:5.6, name=mymysql)<br>2016-07-11T00:57:19.140141428+08:00 container die c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (exitCode=1, image=mysql:5.6, name=mymysql)<br>2016-07-11T00:58:05.941019136+08:00 container destroy c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (image=mysql:5.6, name=mymysql)<br>2016-07-11T00:58:07.965128417+08:00 container create a404c6c174a21c52f199cfce476e041074ab020453c7df2a13a7869b48f2f37e (image=mysql:5.6, name=mymysql)<br>2016-07-11T00:58:08.188734598+08:00 container start a404c6c174a21c52f199cfce476e041074ab020453c7df2a13a7869b48f2f37e (image=mysql:5.6, name=mymysql)<br>2016-07-11T00:58:20.010876777+08:00 container top a404c6c174a21c52f199cfce476e041074ab020453c7df2a13a7869b48f2f37e (image=mysql:5.6, name=mymysql)<br>2016-07-11T01:06:01.395365098+08:00 container top a404c6c174a21c52f199cfce476e041074ab020453c7df2a13a7869b48f2f37e (image=mysql:5.6, name=mymysql)<br></code></pre></td></tr></table></figure><p>如果指定的时间是到秒级的，需要将时间转成时间戳。如果时间为日期的话，可以直接使用，如–since&#x3D;”2016-07-01”。</p><h2 id="☆-docker-logs"><a href="#☆-docker-logs" class="headerlink" title="☆ docker logs"></a>☆ docker logs</h2><p><strong>docker logs :</strong> 获取容器的日志</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker logs [OPTIONS] CONTAINER<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><code>-f</code> : 跟踪日志输出</li><li><code>--since</code>显示某个开始时间的所有日志</li><li><code>-t</code> 显示时间戳</li><li><code>--tail</code>仅列出最新N条容器日志</li></ul><p><strong>实例</strong></p><p>跟踪查看容器mynginx的日志输出。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker logs -f mynginx<br>192.168.239.1 - - [10/Jul/2016:16:53:33 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36&quot; &quot;-&quot;<br>2016/07/10 16:53:33 [error] 5#5: *1 open() &quot;/usr/share/nginx/html/favicon.ico&quot; failed (2: No such file or directory), client: 192.168.239.1, server: localhost, request: &quot;GET /favicon.ico HTTP/1.1&quot;, host: &quot;192.168.239.130&quot;, referrer: &quot;http://192.168.239.130/&quot;<br>192.168.239.1 - - [10/Jul/2016:16:53:33 +0000] &quot;GET /favicon.ico HTTP/1.1&quot; 404 571 &quot;http://192.168.239.130/&quot; &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36&quot; &quot;-&quot;<br>192.168.239.1 - - [10/Jul/2016:16:53:59 +0000] &quot;GET / HTTP/1.1&quot; 304 0 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36&quot; &quot;-&quot;<br>...<br></code></pre></td></tr></table></figure><p>查看容器mynginx从2016年7月1日后的最新10条日志。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker logs --since=&quot;2016-07-01&quot; --tail=10 mynginx<br></code></pre></td></tr></table></figure><h2 id="docker-wait"><a href="#docker-wait" class="headerlink" title="docker wait"></a>docker wait</h2><p><strong>docker wait :</strong> 阻塞运行直到容器停止，然后打印出它的退出代码。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker wait [OPTIONS] CONTAINER [CONTAINER...]<br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker wait CONTAINER<br></code></pre></td></tr></table></figure><h2 id="docker-export-导出"><a href="#docker-export-导出" class="headerlink" title="docker export 导出"></a>docker export 导出</h2><p>**docker export :**将文件系统作为一个tar归档文件导出到STDOUT。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker export [OPTIONS] CONTAINER<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><code>-o</code>将输入内容写到文件。</li></ul><p><strong>实例</strong></p><p>将id为a404c6c174a2的容器按日期保存为tar文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker export -o mysql-`date +%Y%m%d`.tar a404c6c174a2<br>runoob@runoob:~$ ls mysql-`date +%Y%m%d`.tar<br>mysql-20160711.tar<br></code></pre></td></tr></table></figure><h2 id="docker-port"><a href="#docker-port" class="headerlink" title="docker port"></a>docker port</h2><p><strong>docker port :</strong> 列出指定的容器的端口映射，或者查找将PRIVATE_PORT NAT到面向公众的端口。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker port [OPTIONS] CONTAINER [PRIVATE_PORT[/PROTO]]<br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><p>查看容器mynginx的端口映射情况。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker port mymysql<br>3306/tcp -&gt; 0.0.0.0:3306<br></code></pre></td></tr></table></figure><h2 id="docker-stats-统计"><a href="#docker-stats-统计" class="headerlink" title="docker stats 统计"></a>docker stats 统计</h2><p><strong>docker stats :</strong> 统计显示容器资源的使用情况，包括：CPU、内存、网络 I&#x2F;O 等。</p><p>stats: abbr. 统计（statistics）；</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker stats [OPTIONS] [CONTAINER...]<br></code></pre></td></tr></table></figure><p>OPTIONS 说明：</p><ul><li><code>--all , -a</code> :显示所有的容器，包括未运行的。</li><li><code>format</code> :指定返回值的模板文件。</li><li><code>--no-stream</code> :展示当前状态就直接退出了，不再实时更新。</li><li><code>--no-trunc</code> :不截断输出。</li></ul><p><strong>实例</strong></p><p>列出所有在运行的容器信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$  docker stats<br>CONTAINER ID        NAME                                    CPU %               MEM USAGE / LIMIT     MEM %               NET I/O             BLOCK I/O           PIDS<br>b95a83497c91        awesome_brattain                        0.28%               5.629MiB / 1.952GiB   0.28%               916B / 0B           147kB / 0B          9<br>67b2525d8ad1        foobar                                  0.00%               1.727MiB / 1.952GiB   0.09%               2.48kB / 0B         4.11MB / 0B         2<br>e5c383697914        test-1951.1.kay7x1lh1twk9c0oig50sd5tr   0.00%               196KiB / 1.952GiB     0.01%               71.2kB / 0B         770kB / 0B          1<br>4bda148efbc0        random.1.vnc8on831idyr42slu578u3cr      0.00%               1.672MiB / 1.952GiB   0.08%               110kB / 0B          578kB / 0B          2<br></code></pre></td></tr></table></figure><p>输出详情介绍：</p><p><strong>CONTAINER ID 与 NAME:</strong> 容器 ID 与名称。</p><p><strong>CPU % 与 MEM %:</strong> 容器使用的 CPU 和内存的百分比。</p><p><strong>MEM USAGE &#x2F; LIMIT:</strong> 容器正在使用的总内存，以及允许使用的内存总量。</p><p><strong>NET I&#x2F;O:</strong> 容器通过其网络接口发送和接收的数据量。</p><p><strong>BLOCK I&#x2F;O:</strong> 容器从主机上的块设备读取和写入的数据量。</p><p><strong>PIDs:</strong> 容器创建的进程或线程数。</p><p>根据容器等 ID 或名称现实信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker stats awesome_brattain 67b2525d8ad1<br><br>CONTAINER ID        NAME                CPU %               MEM USAGE / LIMIT     MEM %               NET I/O             BLOCK I/O           PIDS<br>b95a83497c91        awesome_brattain    0.28%               5.629MiB / 1.952GiB   0.28%               916B / 0B           147kB / 0B          9<br>67b2525d8ad1        foobar              0.00%               1.727MiB / 1.952GiB   0.09%               2.48kB / 0B         4.11MB / 0B         2<br></code></pre></td></tr></table></figure><p>以 JSON 格式输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker stats nginx --no-stream --format &quot;&#123;&#123; json . &#125;&#125;&quot;<br>  &#123;&quot;BlockIO&quot;:&quot;0B / 13.3kB&quot;,&quot;CPUPerc&quot;:&quot;0.03%&quot;,&quot;Container&quot;:&quot;nginx&quot;,&quot;ID&quot;:&quot;ed37317fbf42&quot;,&quot;MemPerc&quot;:&quot;0.24%&quot;,&quot;MemUsage&quot;:&quot;2.352MiB / 982.5MiB&quot;,&quot;Name&quot;:&quot;nginx&quot;,&quot;NetIO&quot;:&quot;539kB / 606kB&quot;,&quot;PIDs&quot;:&quot;2&quot;&#125;<br></code></pre></td></tr></table></figure><p>输出指定的信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker stats --all --format &quot;table &#123;&#123;.Container&#125;&#125;\t&#123;&#123;.CPUPerc&#125;&#125;\t&#123;&#123;.MemUsage&#125;&#125;&quot; fervent_panini 5acfcb1b4fd1 drunk_visvesvaraya big_heisenberg<br>  &#123;&quot;BlockIO&quot;:&quot;0B / 13.3kB&quot;,&quot;CPUPerc&quot;:&quot;0.03%&quot;,&quot;Container&quot;:&quot;nginx&quot;,&quot;ID&quot;:&quot;ed37317fbf42&quot;,&quot;MemPerc&quot;:&quot;0.24%&quot;,&quot;MemUsage&quot;:&quot;2.352MiB / 982.5MiB&quot;,&quot;Name&quot;:&quot;nginx&quot;,&quot;NetIO&quot;:&quot;539kB / 606kB&quot;,&quot;PIDs&quot;:&quot;2&quot;&#125;<br><br>CONTAINER                CPU %               MEM USAGE / LIMIT<br>fervent_panini           0.00%               56KiB / 15.57GiB<br>5acfcb1b4fd1             0.07%               32.86MiB / 15.57GiB<br>drunk_visvesvaraya       0.00%               0B / 0B<br>big_heisenberg           0.00%               0B / 0B<br></code></pre></td></tr></table></figure><h2 id="↓-镜像管理-image-↓"><a href="#↓-镜像管理-image-↓" class="headerlink" title="↓ 镜像管理 image ↓"></a>↓ 镜像管理 image ↓</h2><h2 id="Docker-commit"><a href="#Docker-commit" class="headerlink" title="Docker commit"></a>Docker commit</h2><p><a href="https://yeasy.gitbook.io/docker_practice/image/commit">参考链接: 利用 commit 理解镜像构成</a></p><p>**docker commit :**从容器创建一个新的镜像。</p><blockquote><p>  我们并不推荐使用这个命令构建image, 我们会推荐使用更加强大的Dockerfile来进行构建</p></blockquote><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><p><code>-a</code> :提交的镜像作者；</p></li><li><p><code>-c</code>使用Dockerfile指令来创建镜像；</p></li><li><p><code>-m</code>提交时的说明文字；</p></li><li><p><code>-p</code> :在commit时，将容器暂停。</p></li></ul><p><strong>实例</strong></p><p>将容器a404c6c174a2 保存为新的镜像,并添加提交人信息和说明信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker commit -a &quot;runoob.com&quot; -m &quot;my apache&quot; a404c6c174a2  mymysql:v1 <br>sha256:37af1236adef1544e8886be23010b66577647a40bc02c0885a6600b33ee28057<br>runoob@runoob:~$ docker images mymysql:v1<br>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br>mymysql             v1                  37af1236adef        15 seconds ago      329 MB<br></code></pre></td></tr></table></figure><blockquote><p>  <strong><code>Docker commit</code>释义</strong></p><p>  要知道，当我们运行一个容器的时候（如果不使用卷的话），我们做的任何文件修改都会被记录于容器存储层里。而 Docker 提供了一个 <code>docker commit</code> 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。</p><p>  <strong>慎用 <code>docker commit</code></strong></p><p>  使用 <code>docker commit</code> 命令虽然可以比较直观的帮助理解镜像分层存储的概念，但是实际环境中并不会这样使用。</p><p>  首先，如果仔细观察之前的 <code>docker diff webserver</code> 的结果，你会发现除了真正想要修改的 <code>/usr/share/nginx/html/index.html</code> 文件外，由于命令的执行，还有很多文件被改动或添加了。这还仅仅是最简单的操作，如果是安装软件包、编译构建，那会有大量的无关内容被添加进来，将会导致镜像极为臃肿。</p><p>  此外，使用 <code>docker commit</code> 意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为 <strong>黑箱镜像</strong>，换句话说，就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知。而且，即使是这个制作镜像的人，过一段时间后也无法记清具体的操作。这种黑箱镜像的维护工作是非常痛苦的。</p><p>  而且，回顾之前提及的镜像所使用的分层存储的概念，除当前层外，之前的每一层都是不会发生改变的，换句话说，任何修改的结果仅仅是在当前层进行标记、添加、修改，而不会改动上一层。如果使用 <code>docker commit</code> 制作镜像，以及后期修改的话，每一次修改都会让镜像更加臃肿一次，所删除的上一层的东西并不会丢失，会一直如影随形的跟着这个镜像，即使根本无法访问到。这会让镜像更加臃肿。</p></blockquote><h2 id="☆-docker-cp-Copy-Data"><a href="#☆-docker-cp-Copy-Data" class="headerlink" title="☆ docker cp (Copy Data)"></a>☆ docker cp (Copy Data)</h2><p><code>docker cp</code> :用于容器与主机之间的数据拷贝。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-<br>docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><code>-L</code>保持源目标中的链接</li></ul><p><strong>实例</strong></p><p>将主机&#x2F;www&#x2F;runoob目录拷贝到容器96f7f14e99ab的&#x2F;www目录下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker cp /www/runoob 96f7f14e99ab:/www/<br></code></pre></td></tr></table></figure><p>将主机&#x2F;www&#x2F;runoob目录拷贝到容器96f7f14e99ab中，目录重命名为www。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker cp /www/runoob 96f7f14e99ab:/www<br></code></pre></td></tr></table></figure><p>将容器96f7f14e99ab的&#x2F;www目录拷贝到主机的&#x2F;tmp目录中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker cp  96f7f14e99ab:/www /tmp/<br></code></pre></td></tr></table></figure><h2 id="docker-diff"><a href="#docker-diff" class="headerlink" title="docker diff"></a>docker diff</h2><p><code>docker diff</code> : 检查容器里文件结构的更改。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker diff [OPTIONS] CONTAINER<br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><p>查看容器mymysql的文件结构更改。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker diff mymysql<br>A /logs<br>A /mysql_data<br>C /run<br>C /run/mysqld<br>A /run/mysqld/mysqld.pid<br>A /run/mysqld/mysqld.sock<br>C /tmp<br></code></pre></td></tr></table></figure><h2 id="↓-镜像仓库管理-↓"><a href="#↓-镜像仓库管理-↓" class="headerlink" title="↓ 镜像仓库管理 ↓"></a>↓ 镜像仓库管理 ↓</h2><h2 id="docker-login-x2F-logout"><a href="#docker-login-x2F-logout" class="headerlink" title="docker login&#x2F;logout"></a>docker login&#x2F;logout</h2><p><strong>docker login :</strong> 登陆到一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub</p><p><strong>docker logout :</strong> 登出一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker login [OPTIONS] [SERVER]<br>docker logout [OPTIONS] [SERVER]<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><code>-u</code> :登陆的用户名</li><li><code>-p</code> :登陆的密码</li></ul><p><strong>实例</strong></p><p>登陆到Docker Hub</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker login -u 用户名 -p 密码<br></code></pre></td></tr></table></figure><p>登出Docker Hub</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker logout<br></code></pre></td></tr></table></figure><h2 id="docker-pull"><a href="#docker-pull" class="headerlink" title="docker pull"></a>docker pull</h2><p><strong>docker pull :</strong> 从镜像仓库中拉取或者更新指定镜像</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull [OPTIONS] NAME[:TAG|@DIGEST]<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><p><code>-a</code> :拉取所有 tagged 镜像</p></li><li><p><code>--disable-content-trust</code>忽略镜像的校验,默认开启</p></li></ul><p><strong>实例</strong></p><p>从Docker Hub下载java最新版镜像。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull java<br></code></pre></td></tr></table></figure><p>从Docker Hub下载REPOSITORY为java的所有镜像。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull -a java<br></code></pre></td></tr></table></figure><h2 id="docker-push"><a href="#docker-push" class="headerlink" title="docker push"></a>docker push</h2><p><strong>docker push :</strong> 将本地的镜像上传到镜像仓库,要先登陆到镜像仓库</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker push [OPTIONS] NAME[:TAG]<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><code>--disable-content-trust</code> :忽略镜像的校验,默认开启</li></ul><p><strong>实例</strong></p><p>上传本地镜像myapache:v1到镜像仓库中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker push myapache:v1<br></code></pre></td></tr></table></figure><h2 id="☆-docker-search"><a href="#☆-docker-search" class="headerlink" title="☆ docker search"></a>☆ docker search</h2><p><strong>docker search :</strong> 从Docker Hub查找镜像</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker search [OPTIONS] TERM<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><code>--automated</code> :只列出 automated build类型的镜像；</li><li><code>--no-trunc</code> :显示完整的镜像描述；</li><li><code>-f &lt;过滤条件&gt;</code>:列出收藏数不小于指定值的镜像。</li></ul><p><strong>实例</strong></p><p>从 Docker Hub 查找所有镜像名包含 java，并且收藏数大于 10 的镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker search -f stars=10 java<br>NAME                  DESCRIPTION                           STARS   OFFICIAL   AUTOMATED<br>java                  Java is a concurrent, class-based...   1037    [OK]       <br>anapsix/alpine-java   Oracle Java 8 (and 7) with GLIBC ...   115                [OK]<br>develar/java                                                 46                 [OK]<br>isuper/java-oracle    This repository contains all java...   38                 [OK]<br>lwieske/java-8        Oracle Java 8 Container - Full + ...   27                 [OK]<br>nimmis/java-centos    This is docker images of CentOS 7...   13                 [OK]<br></code></pre></td></tr></table></figure><p>参数说明：</p><p><strong>NAME:</strong> 镜像仓库源的名称</p><p><strong>DESCRIPTION:</strong> 镜像的描述</p><p><strong>OFFICIAL:</strong> 是否 docker 官方发布</p><p><strong>stars:</strong> 类似 Github 里面的 star，表示点赞、喜欢的意思。</p><p><strong>AUTOMATED:</strong> 自动构建。</p><h2 id="↓-本地镜像管理-↓"><a href="#↓-本地镜像管理-↓" class="headerlink" title="↓ 本地镜像管理 ↓"></a>↓ 本地镜像管理 ↓</h2><h2 id="☆-docker-images"><a href="#☆-docker-images" class="headerlink" title="☆ docker images"></a>☆ docker images</h2><p><strong>docker images :</strong> 列出本地镜像。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker images [OPTIONS] [REPOSITORY[:TAG]]<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><p><code>-a</code> :列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；</p></li><li><p><code>--digests</code> :显示镜像的摘要信息；</p></li><li><p><code>-f</code> :显示满足条件的镜像；</p></li><li><p><code>--format</code> :指定返回值的模板文件；</p></li><li><p><code>--no-trunc</code> :显示完整的镜像信息；</p></li><li><p><code>-q</code> :只显示镜像ID。</p></li></ul><p><strong>实例</strong></p><p>查看本地镜像列表。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker images<br>REPOSITORY              TAG                 IMAGE ID            CREATED             SIZE<br>mymysql                 v1                  37af1236adef        5 minutes ago       329 MB<br>runoob/ubuntu           v4                  1c06aa18edee        2 days ago          142.1 MB<br>&lt;none&gt;                  &lt;none&gt;              5c6e1090e771        2 days ago          165.9 MB<br>httpd                   latest              ed38aaffef30        11 days ago         195.1 MB<br>alpine                  latest              4e38e38c8ce0        2 weeks ago         4.799 MB<br>mongo                   3.2                 282fd552add6        3 weeks ago         336.1 MB<br>redis                   latest              4465e4bcad80        3 weeks ago         185.7 MB<br>php                     5.6-fpm             025041cd3aa5        3 weeks ago         456.3 MB<br>python                  3.5                 045767ddf24a        3 weeks ago         684.1 MB<br>...<br></code></pre></td></tr></table></figure><p>列出本地镜像中REPOSITORY为ubuntu的镜像列表。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@runoob:~# docker images  ubuntu<br>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br>ubuntu              14.04               90d5884b1ee0        9 weeks ago         188 MB<br>ubuntu              15.10               4e3b13c8a266        3 months ago        136.3 MB<br></code></pre></td></tr></table></figure><h2 id="docker-rmi"><a href="#docker-rmi" class="headerlink" title="docker rmi"></a>docker rmi</h2><p><strong>docker rmi :</strong> 删除本地一个或多个镜像。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rmi [OPTIONS] IMAGE [IMAGE...]<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><p><code>-f</code> :强制删除；</p></li><li><p><code>--no-prune</code>不移除该镜像的过程镜像，默认移除；</p></li></ul><p><strong>实例</strong></p><p>强制删除本地镜像 runoob&#x2F;ubuntu:v4。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@runoob:~# docker rmi -f runoob/ubuntu:v4<br>Untagged: runoob/ubuntu:v4<br>Deleted: sha256:1c06aa18edee44230f93a90a7d88139235de12cd4c089d41eed8419b503072be<br>Deleted: sha256:85feb446e89a28d58ee7d80ea5ce367eebb7cec70f0ec18aa4faa874cbd97c73<br></code></pre></td></tr></table></figure><h2 id="docker-tag"><a href="#docker-tag" class="headerlink" title="docker tag"></a>docker tag</h2><p><strong>docker tag :</strong> 标记本地镜像，将其归入某一仓库。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker tag [OPTIONS] IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG]<br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><p>将镜像ubuntu:15.10标记为 runoob&#x2F;ubuntu:v3 镜像。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@runoob:~# docker tag ubuntu:15.10 runoob/ubuntu:v3<br>root@runoob:~# docker images   runoob/ubuntu:v3<br>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br>runoob/ubuntu       v3                  4e3b13c8a266        3 months ago        136.3 MB<br></code></pre></td></tr></table></figure><h2 id="☆-docker-build"><a href="#☆-docker-build" class="headerlink" title="☆ docker build"></a>☆ docker build</h2><p><strong>docker build</strong> 命令用于使用 Dockerfile 创建镜像。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build [OPTIONS] PATH | URL | -<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><code>--build-arg=[]</code>设置镜像创建时的变量；</li><li><code>--cpu-shares</code>设置 cpu 使用权重；</li><li><code>--cpu-period</code>限制 CPU CFS周期；</li><li><code>--cpu-quota</code>限制 CPU CFS配额；</li><li><code>--cpuset-cpus</code>指定使用的CPU id；</li><li><code>--cpuset-mems</code>指定使用的内存 id；</li><li><code>--disable-content-trust</code>忽略校验，默认开启；</li><li><code>-f</code> :指定要使用的Dockerfile路径；</li><li><code>--force-rm</code>设置镜像过程中删除中间容器；</li><li><code>--isolation</code>使用容器隔离技术；</li><li><code>--label=[]</code>设置镜像使用的元数据；</li><li><code>-m</code>设置内存最大值；</li><li><code>--memory-swap</code>:设置Swap的最大值为内存+swap，”-1”表示不限swap；</li><li><code>--no-cache</code>:创建镜像的过程不使用缓存；</li><li><code>--pull</code>:尝试去更新镜像的新版本；</li><li><code>--quiet, -q</code>:安静模式，成功后只输出镜像 ID；</li><li><code>--rm</code>:设置镜像成功后删除中间容器；</li><li><code>--shm-size</code>:设置&#x2F;dev&#x2F;shm的大小，默认值是64M；</li><li><code>--ulimit</code>:Ulimit配置。</li><li><code>--squash</code>:将 Dockerfile 中所有的操作压缩为一层。</li><li><strong>–tag, -t:</strong> 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。</li><li><strong>–network:</strong> 默认 default。在构建期间设置RUN指令的网络模式</li></ul><p><strong>实例</strong></p><p>使用当前目录的 Dockerfile 创建镜像，标签为 runoob&#x2F;ubuntu:v1。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build -t runoob/ubuntu:v1 . <br></code></pre></td></tr></table></figure><p>使用URL <strong>github.com&#x2F;creack&#x2F;docker-firefox</strong> 的 Dockerfile 创建镜像。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build github.com/creack/docker-firefox<br></code></pre></td></tr></table></figure><p>也可以通过 -f Dockerfile 文件的位置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker build -f /path/to/a/Dockerfile .</span><br></code></pre></td></tr></table></figure><p>在 Docker 守护进程执行 Dockerfile 中的指令前，首先会对 Dockerfile 进行语法检查，有语法错误时会返回：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker build -t <span class="hljs-built_in">test</span>/myapp .</span><br>Sending build context to Docker daemon 2.048 kB<br>Error response from daemon: Unknown instruction: RUNCMD<br></code></pre></td></tr></table></figure><h2 id="docker-history"><a href="#docker-history" class="headerlink" title="docker history"></a>docker history</h2><p><strong>docker history :</strong> 查看指定镜像的创建历史。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker history [OPTIONS] IMAGE<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><p><code>-H</code>:以可读的格式打印镜像大小和日期，默认为true；</p></li><li><p><code>--no-trunc</code> :显示完整的提交记录；</p></li><li><p><code>-q</code> :仅列出提交记录ID。</p></li></ul><p><strong>实例</strong></p><p>查看本地镜像runoob&#x2F;ubuntu:v3的创建历史。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@runoob:~# docker history runoob/ubuntu:v3<br>IMAGE             CREATED           CREATED BY                                      SIZE      COMMENT<br>4e3b13c8a266      3 months ago      /bin/sh -c #(nop) CMD [&quot;/bin/bash&quot;]             0 B                 <br>&lt;missing&gt;         3 months ago      /bin/sh -c sed -i &#x27;s/^#\s*\(deb.*universe\)$/   1.863 kB            <br>&lt;missing&gt;         3 months ago      /bin/sh -c set -xe   &amp;&amp; echo &#x27;#!/bin/sh&#x27; &gt; /u   701 B               <br>&lt;missing&gt;         3 months ago      /bin/sh -c #(nop) ADD file:43cb048516c6b80f22   136.3 MB<br></code></pre></td></tr></table></figure><h2 id="docker-save"><a href="#docker-save" class="headerlink" title="docker save"></a>docker save</h2><p><strong>docker save :</strong> 将指定镜像保存成 tar 归档文件。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker save [OPTIONS] IMAGE [IMAGE...]<br></code></pre></td></tr></table></figure><p>OPTIONS 说明：</p><ul><li><code>-o</code>:输出到的文件。</li></ul><p><strong>实例</strong></p><p>将镜像 runoob&#x2F;ubuntu:v3 生成 my_ubuntu_v3.tar 文档</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker save -o my_ubuntu_v3.tar runoob/ubuntu:v3<br>runoob@runoob:~$ ll my_ubuntu_v3.tar<br>-rw------- 1 runoob runoob 142102016 Jul 11 01:37 my_ubuntu_v3.ta<br></code></pre></td></tr></table></figure><h2 id="docker-load"><a href="#docker-load" class="headerlink" title="docker load"></a>docker load</h2><p><strong>docker load :</strong> 导入使用 <a href="https://www.runoob.com/docker/docker-save-command.html">docker save</a> 命令导出的镜像。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker load [OPTIONS]<br></code></pre></td></tr></table></figure><p>OPTIONS 说明：</p><ul><li><p><code>--input , -i</code>: 指定导入的文件，代替 STDIN。</p></li><li><p><code>--quiet , -q</code>: 精简输出信息。</p></li></ul><p><strong>实例</strong></p><p>导入镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker image <span class="hljs-built_in">ls</span></span><br><br>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker load &lt; busybox.tar.gz</span><br><br>Loaded image: busybox:latest<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker images</span><br>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br>busybox             latest              769b9341d937        7 weeks ago         2.489 MB<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker load --input fedora.tar</span><br><br>Loaded image: fedora:rawhide<br><br>Loaded image: fedora:20<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker images</span><br><br>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br>busybox             latest              769b9341d937        7 weeks ago         2.489 MB<br>fedora              rawhide             0d20aec6529d        7 weeks ago         387 MB<br>fedora              20                  58394af37342        7 weeks ago         385.5 MB<br>fedora              heisenbug           58394af37342        7 weeks ago         385.5 MB<br>fedora              latest              58394af37342        7 weeks ago         385.5 MB<br></code></pre></td></tr></table></figure><h2 id="docker-import"><a href="#docker-import" class="headerlink" title="docker import"></a>docker import</h2><p><strong>docker import :</strong> 从归档文件中创建镜像。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><p><code>-c</code>:应用docker 指令创建镜像；</p></li><li><p><code>-m</code>:提交时的说明文字；</p></li></ul><p><strong>实例</strong></p><p>从镜像归档文件my_ubuntu_v3.tar创建镜像，命名为runoob&#x2F;ubuntu:v4</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">runoob@runoob:~$ docker import  my_ubuntu_v3.tar runoob/ubuntu:v4  <br>sha256:63ce4a6d6bc3fabb95dbd6c561404a309b7bdfc4e21c1d59fe9fe4299cbfea39<br>runoob@runoob:~$ docker images runoob/ubuntu:v4<br>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br>runoob/ubuntu       v4                  63ce4a6d6bc3        20 seconds ago      142.1 MB<br></code></pre></td></tr></table></figure><h2 id="docker-info"><a href="#docker-info" class="headerlink" title="docker info"></a>docker info</h2><p><code>docker info</code> : 显示 Docker 信息，主机详细系统信息，镜像和容器信息。</p><h2 id="docker-version"><a href="#docker-version" class="headerlink" title="docker version"></a>docker version</h2><p><code>docker version</code> :显示 Docker 版本信息。</p><h1 id="Dockerfile的使用"><a href="#Dockerfile的使用" class="headerlink" title="Dockerfile的使用"></a>Dockerfile的使用</h1><h3 id="什么是-Dockerfile？"><a href="#什么是-Dockerfile？" class="headerlink" title="什么是 Dockerfile？"></a>什么是 Dockerfile？</h3><p>Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。</p><h2 id="构建环境"><a href="#构建环境" class="headerlink" title="构建环境"></a>构建环境</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">❯ mkdir web_docker<br>❯ cd web_docker<br>❯ touch Dockerfile<br>❯ tree .. -f<br>..<br>└── ../web_docker<br>    └── ../web_docker/Dockerfile<br></code></pre></td></tr></table></figure><p>在上面的命令中, 我们创建了 <code>web_docker</code>文件夹, <code>web_docker</code>文件夹就是我们的构建环境(build environment), docker称此环境为上下文(context)，或者构建上下文(context), docker会在构建镜像时构建上下文和该上下文中的文件和目录，上传到docker守护进程，这样docker守护进程就能直接访问你想在镜像中存储的任何代码文件和其他数据。</p><h2 id="dockerfile-示例"><a href="#dockerfile-示例" class="headerlink" title="dockerfile 示例"></a>dockerfile 示例</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># version 0.0.1</span><br><span class="hljs-keyword">FROM</span> ubuntu:<span class="hljs-number">14.04</span><br><span class="hljs-keyword">MAINTAINER</span> James Turnbull <span class="hljs-string">&quot;james@example.com&quot;</span><br><span class="hljs-keyword">ENV</span> REFRESHED_AT <span class="hljs-number">2014</span>-<span class="hljs-number">06</span>-<span class="hljs-number">01</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get update</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get -y -q install nginx</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;Hi i am in you container&#x27;</span> &gt; /usr/share/nginx/html/index.html</span><br><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><blockquote><p>  Dockerfile也支持注释, 使用#开头就是注释了</p></blockquote><hr><h2 id="指令详解"><a href="#指令详解" class="headerlink" title="指令详解"></a>指令详解</h2><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><p>构建镜像基于哪个镜像</p><h3 id="MANTAINER"><a href="#MANTAINER" class="headerlink" title="MANTAINER"></a>MANTAINER</h3><p>镜像维护者 姓名 邮箱地址</p><h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><p>用于执行后面跟着的命令行命令。有以下俩种格式：</p><p>shell 格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">RUN &lt;命令行命令&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;命令行命令&gt; 等同于，在终端操作的 shell 命令。</span><br></code></pre></td></tr></table></figure><p>exec 格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]<br><span class="hljs-meta prompt_"># </span><span class="language-bash">例如：</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">RUN [<span class="hljs-string">&quot;./test.php&quot;</span>, <span class="hljs-string">&quot;dev&quot;</span>, <span class="hljs-string">&quot;offline&quot;</span>] 等价于 RUN ./test.php dev offline</span><br></code></pre></td></tr></table></figure><h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h3><p>复制指令，从上下文目录中复制文件或者目录到容器里指定路径。</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">COPY [--chown=<span class="hljs-tag">&lt;<span class="hljs-name">user</span>&gt;</span>:<span class="hljs-tag">&lt;<span class="hljs-name">group</span>&gt;</span>] <span class="hljs-tag">&lt;<span class="hljs-name">源路径1</span>&gt;</span>...  <span class="hljs-tag">&lt;<span class="hljs-name">目标路径</span>&gt;</span><br>COPY [--chown=<span class="hljs-tag">&lt;<span class="hljs-name">user</span>&gt;</span>:<span class="hljs-tag">&lt;<span class="hljs-name">group</span>&gt;</span>] [&quot;<span class="hljs-tag">&lt;<span class="hljs-name">源路径1</span>&gt;</span>&quot;,...  &quot;<span class="hljs-tag">&lt;<span class="hljs-name">目标路径</span>&gt;</span>&quot;]<br></code></pre></td></tr></table></figure><p>**[–chown&#x3D;<user>:<group>]**：可选参数，用户改变复制到容器内文件的拥有者和属组。</p><p>**&lt;源路径&gt;**：源文件或者源目录，这里可以是通配符表达式，其通配符规则要满足 Go 的 filepath.Match 规则。例如：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">COPY</span> hom* <span class="hljs-regexp">/mydir/</span><br><span class="hljs-keyword">COPY</span> hom?.txt <span class="hljs-regexp">/mydir/</span><br></code></pre></td></tr></table></figure><p>**&lt;目标路径&gt;**：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建。</p><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><p>ADD 指令和 COPY 的使用格类似（同样需求下，官方推荐使用 COPY）。功能也类似，不同之处如下：</p><ul><li>ADD 的优点：在执行 &lt;源文件&gt; 为 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，会自动复制并解压到 &lt;目标路径&gt;。</li><li>ADD 的缺点：在不解压的前提下，无法复制 tar 压缩文件。会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。具体是否使用，可以根据是否需要自动解压来决定。</li></ul><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p>类似于 RUN 指令，用于运行程序，但二者运行的时间点不同:</p><ul><li>CMD 在docker run 时运行。</li><li>RUN 是在 docker build。</li></ul><p><strong>作用</strong>：为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。</p><p><strong>注意</strong>：如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效。</p><p>格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">CMD</span><span class="language-bash"> &lt;shell 命令&gt; </span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;&lt;可执行文件或命令&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param1&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param2&gt;&quot;</span>,...] </span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;&lt;param1&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param2&gt;&quot;</span>,...]  <span class="hljs-comment"># 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数</span></span><br></code></pre></td></tr></table></figure><p>推荐使用第二种格式，执行过程比较明确。第一种格式实际上在运行的过程中也会自动转换成第二种格式运行，并且默认可执行文件是 sh。</p><h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><p>类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。</p><p>但是, 如果运行 docker run 时使用了 –entrypoint 选项，将覆盖 ENTRYPOINT 指令指定的程序。</p><p><strong>优点</strong>：在执行 docker run 的时候可以指定 ENTRYPOINT 运行所需的参数。</p><p><strong>注意</strong>：如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。</p><p>格式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">ENTRYPOINT <span class="hljs-selector-attr">[<span class="hljs-string">&quot;&lt;executeable&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param1&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param2&gt;&quot;</span>,...]</span><br></code></pre></td></tr></table></figure><p>可以搭配 CMD 命令使用：一般是变参才会使用 CMD ，这里的 CMD 等于是在给 ENTRYPOINT 传参，以下示例会提到。</p><p>示例：</p><p>假设已通过 Dockerfile 构建了 nginx:test 镜像：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> nginx<br><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;nginx&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>] <span class="hljs-comment"># 定参</span></span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;/etc/nginx/nginx.conf&quot;</span>] <span class="hljs-comment"># 变参 </span></span><br></code></pre></td></tr></table></figure><p>1、不传参运行</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">$ docker <span class="hljs-keyword">run</span><span class="language-bash">  nginx:<span class="hljs-built_in">test</span></span><br></code></pre></td></tr></table></figure><p>容器内会默认运行以下命令，启动主进程。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">nginx -c <span class="hljs-regexp">/etc/</span>nginx/nginx.conf<br></code></pre></td></tr></table></figure><p>2、传参运行</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">$ docker <span class="hljs-keyword">run</span><span class="language-bash">  nginx:<span class="hljs-built_in">test</span> -c /etc/nginx/new.conf</span><br></code></pre></td></tr></table></figure><p>容器内会默认运行以下命令，启动主进程(&#x2F;etc&#x2F;nginx&#x2F;new.conf:假设容器内已有此文件)</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">nginx -c <span class="hljs-regexp">/etc/</span>nginx/<span class="hljs-keyword">new</span>.conf<br></code></pre></td></tr></table></figure><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p>设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">ENV <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span><br>ENV <span class="hljs-tag">&lt;<span class="hljs-name">key1</span>&gt;</span>=<span class="hljs-tag">&lt;<span class="hljs-name">value1</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">key2</span>&gt;</span>=<span class="hljs-tag">&lt;<span class="hljs-name">value2</span>&gt;</span>...<br></code></pre></td></tr></table></figure><p>以下示例设置 NODE_VERSION &#x3D; 7.2.0 ， 在后续的指令中可以通过 $NODE_VERSION 引用：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENV</span> NODE_VERSION <span class="hljs-number">7.2</span>.<span class="hljs-number">0</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> curl -SLO <span class="hljs-string">&quot;https://nodejs.org/dist/v<span class="hljs-variable">$NODE_VERSION</span>/node-v<span class="hljs-variable">$NODE_VERSION</span>-linux-x64.tar.xz&quot;</span> \</span><br><span class="language-bash">  &amp;&amp; curl -SLO <span class="hljs-string">&quot;https://nodejs.org/dist/v<span class="hljs-variable">$NODE_VERSION</span>/SHASUMS256.txt.asc&quot;</span></span><br></code></pre></td></tr></table></figure><h3 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h3><p>构建参数，与 ENV 作用一致。不过作用域不一样。ARG 设置的环境变量仅对 Dockerfile 内有效，也就是说只有 docker build 的过程中有效，构建好的镜像内不存在此环境变量。</p><p>构建命令 docker build 中可以用 –build-arg &lt;参数名&gt;&#x3D;&lt;值&gt; 来覆盖。</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">ARG <span class="hljs-tag">&lt;<span class="hljs-name">参数名</span>&gt;</span>[=<span class="hljs-tag">&lt;<span class="hljs-name">默认值</span>&gt;</span>]<br></code></pre></td></tr></table></figure><h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><p>定义匿名数据卷。在启动容器时忘记挂载数据卷，会自动挂载到匿名卷。</p><p>作用：</p><ul><li>避免重要的数据，因容器重启而丢失，这是非常致命的。</li><li>避免容器不断变大。</li></ul><p>格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">VOLUME</span><span class="language-bash"> [<span class="hljs-string">&quot;&lt;路径1&gt;&quot;</span>, <span class="hljs-string">&quot;&lt;路径2&gt;&quot;</span>...]</span><br><span class="hljs-keyword">VOLUME</span><span class="language-bash"> &lt;路径&gt;</span><br></code></pre></td></tr></table></figure><p>在启动容器 docker run 的时候，我们可以通过 -v 参数修改挂载点。</p><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><p>仅仅只是声明端口。</p><p>作用：</p><ul><li>帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。</li><li>在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。</li></ul><p>格式：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">EXPOSE</span> &lt;端口<span class="hljs-number">1</span>&gt;<span class="hljs-meta"> [&lt;端口2&gt;...]</span><br></code></pre></td></tr></table></figure><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><p>指定工作目录。用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在。以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR 会帮你建立目录。</p><p>docker build 构建镜像过程中的，每一个 RUN 命令都是新建的一层。只有通过 WORKDIR 创建的目录才会一直存在。</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">WORKDIR <span class="hljs-tag">&lt;<span class="hljs-name">工作目录路径</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h3><p>用于指定执行后续命令的用户和用户组，这边只是切换后续命令执行的用户（用户和用户组必须提前已经存在）。</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">USER <span class="hljs-tag">&lt;<span class="hljs-name">用户名</span>&gt;</span>[:<span class="hljs-tag">&lt;<span class="hljs-name">用户组</span>&gt;</span>]<br></code></pre></td></tr></table></figure><h3 id="HEALTHCHECK"><a href="#HEALTHCHECK" class="headerlink" title="HEALTHCHECK"></a>HEALTHCHECK</h3><p>用于指定某个程序或者指令来监控 docker 容器服务的运行状态。</p><p>格式：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dos">HEALTHCHECK [选项] <span class="hljs-built_in">CMD</span> &lt;命令&gt;：设置检查容器健康状况的命令<br>HEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令<br><br>HEALTHCHECK [选项] <span class="hljs-built_in">CMD</span> &lt;命令&gt; : 这边 <span class="hljs-built_in">CMD</span> 后面跟随的命令使用，可以参考 <span class="hljs-built_in">CMD</span> 的用法。<br></code></pre></td></tr></table></figure><h3 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h3><p>用于延迟构建命令的执行。简单的说，就是 Dockerfile 里用 ONBUILD 指定的命令，在本次构建镜像的过程中不会执行（假设镜像为 test-build）。当有新的 Dockerfile 使用了之前构建的镜像 FROM test-build ，这时执行新镜像的 Dockerfile 构建时候，会执行 test-build 的 Dockerfile 里的 ONBUILD 指定的命令。</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">ONBUILD <span class="hljs-tag">&lt;<span class="hljs-name">其它指令</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h3><p>LABEL 指令用来给镜像添加一些元数据（metadata），以键值对的形式，语法格式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">LABEL <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>=<span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>=<span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>=<span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span> ...<br></code></pre></td></tr></table></figure><p>比如我们可以添加镜像的作者：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">LABEL org<span class="hljs-selector-class">.opencontainers</span><span class="hljs-selector-class">.image</span>.authors=<span class="hljs-string">&quot;runoob&quot;</span><br></code></pre></td></tr></table></figure><h1 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h1>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>dockerfile</tag>
      
      <tag>namespace</tag>
      
      <tag>cgroup</tag>
      
      <tag>dockerhub</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RDPWrap</title>
    <link href="/2022/a8b000ae/"/>
    <url>/2022/a8b000ae/</url>
    
    <content type="html"><![CDATA[<h1 id="RDPWrap"><a href="#RDPWrap" class="headerlink" title="RDPWrap"></a>RDPWrap</h1><ul><li>RDP程序源Github</li></ul><p><a href="https://github.com/stascorp/rdpwrap">https://github.com/stascorp/rdpwrap</a></p><ul><li>新版RDP配置文件</li></ul><p><a href="https://raw.githubusercontent.com/saurav-biswas/rdpwrap-1/master/res/rdpwrap.ini">https://raw.githubusercontent.com/saurav-biswas/rdpwrap-1/master/res/rdpwrap.ini</a></p><p><a href="https://github.com/affinityv/INI-RDPWRAP">https://github.com/affinityv/INI-RDPWRAP</a></p><p>win11可用 <a href="https://raw.githubusercontent.com/sebaxakerhtc/rdpwrap.ini/master/rdpwrap.ini">https://raw.githubusercontent.com/sebaxakerhtc/rdpwrap.ini/master/rdpwrap.ini</a></p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ol><li><p><code>install.bat</code>安装</p></li><li><p><code>RDPConf.exe</code>检查是否成功开启</p><p><img src="/2022/a8b000ae/image-20211209105711309.png" alt="image-20211209105711309"></p></li><li><p>新的操作系统一般来说第三项是红色的,如果是绿色的就表示正常可以使用了</p></li><li><p>如果异常按以下进行操作</p><ol><li>管理员打开<code>PowerShell</code>运行<code>get-service termservice|stop-service -force</code>停掉RDP进程</li><li>从<a href="https://raw.githubusercontent.com/saurav-biswas/rdpwrap-1/master/res/rdpwrap.ini">RDP配置文件</a>下载新的配置文件</li><li>将下载的配置文件复制到<code>C:\Program Files\RDP Wrapper\rdpwrap.ini</code>替换原文件</li><li>管理员打开<code>PowerShell</code>运行<code>get-service termservice|start-service</code>重新运行RDP</li><li><code>RDPConf.exe</code>检查已经成功开启</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>rdpwrap</tag>
      
      <tag>rdp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Typora强制升级解决办法</title>
    <link href="/2022/77d62815/"/>
    <url>/2022/77d62815/</url>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>This beta version of Typora is expired, please download and install a newer version.</p><p>解决typora强制升级问题</p><blockquote><p>This beta version of Typora is expired, please download and install a newer version.</p></blockquote><p>网上一堆的什么改时间改文件只读的办法都不太行, </p><p>最后找到了改<code>buildtime</code>的办法成功解决了这个问题, </p><p>有能力的请支持正版.</p><p>测试环境是 <code>typora:0.11.18</code> 成功</p><h1 id="详细"><a href="#详细" class="headerlink" title="详细"></a>详细</h1><blockquote><p><a href="https://www.52pojie.cn/thread-1646214-1-1.html">https://www.52pojie.cn/thread-1646214-1-1.html</a> (这里可以找到需要换掉的<code>app.asar</code>文件)</p><p><a href="https://blog.51cto.com/liangdongchang/5357264">https://blog.51cto.com/liangdongchang/5357264</a></p></blockquote><p>最简单的操作就是用破解<code>app.asar</code>文件替换掉原来的文件</p><p>注意备份, 替换 <code>C:\Program Files\Typora\resources\app.asar</code>即可</p><h1 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h1><p>感谢先驱<br><a href="https://github.com/fossabot/typoraCracker">https://github.com/fossabot/typoraCracker</a></p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>typora</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MS-DOS</title>
    <link href="/2022/ddff0c71/"/>
    <url>/2022/ddff0c71/</url>
    
    <content type="html"><![CDATA[<h1 id="MS-DOS"><a href="#MS-DOS" class="headerlink" title="MS-DOS"></a>MS-DOS</h1><p><strong>CMD(windows-commands)</strong></p><p><a href="https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/windows-commands">Windowscommands</a></p><p>在cmd内<code>/?</code>即可获得帮助信息</p><h2 id="FOR"><a href="#FOR" class="headerlink" title="FOR"></a>FOR</h2><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs tex">对一组文件中的每一个文件执行某个特定命令。<br><br>FOR <span class="hljs-comment">%variable IN (set) DO command [command-parameters]</span><br><br>  <span class="hljs-comment">%variable  指定一个单一字母可替换的参数。</span><br>  (set)      指定一个或一组文件。可以使用通配符。<br>  command    指定对每个文件执行的命令。<br>  command-parameters <br>             为特定命令指定参数或命令行开关。<br><br>在批处理程序中使用 FOR 命令时，指定变量请使用 <span class="hljs-comment">%%variable</span><br>而不要用 <span class="hljs-comment">%variable。变量名称是区分大小写的，所以 %i 不同于 %I.</span><br><br>如果启用命令扩展，则会支持下列 FOR 命令的其他格式:<br><br>FOR /D <span class="hljs-comment">%variable IN (set) DO command [command-parameters]</span><br><br>    如果集中包含通配符，则指定与目录名匹配，而不与文件名匹配。<br><br>FOR /R [[drive:]path] <span class="hljs-comment">%variable IN (set) DO command [command-parameters]</span><br><br>    检查以 [drive:]path 为根的目录树，指向每个目录中的 FOR 语句。<br>    如果在 /R 后没有指定目录规范，则使用当前目录。如果集仅为一个单点(.)字符，<br>    则枚举该目录树。<br><br>FOR /L <span class="hljs-comment">%variable IN (start,step,end) DO command [command-parameters]</span><br><br>    该集表示以增量形式从开始到结束的一个数字序列。因此，(1,1,5)将产生序列<br>    1 2 3 4 5，(5,-1,1)将产生序列(5 4 3 2 1)<br><br>FOR /F [&quot;options&quot;] <span class="hljs-comment">%variable IN (file-set) DO command [command-parameters]</span><br>FOR /F [&quot;options&quot;] <span class="hljs-comment">%variable IN (&quot;string&quot;) DO command [command-parameters]</span><br>FOR /F [&quot;options&quot;] <span class="hljs-comment">%variable IN (&#x27;command&#x27;) DO command [command-parameters]</span><br><br>    或者，如果有 usebackq 选项:<br><br>FOR /F [&quot;options&quot;] <span class="hljs-comment">%variable IN (file-set) DO command [command-parameters]</span><br>FOR /F [&quot;options&quot;] <span class="hljs-comment">%variable IN (&quot;string&quot;) DO command [command-parameters]</span><br>FOR /F [&quot;options&quot;] <span class="hljs-comment">%variable IN (&#x27;command&#x27;) DO command [command-parameters]</span><br><br>    fileset 为一个或多个文件名。继续到 fileset 中的下一个文件之前，<br>    每份文件都被打开、读取并经过处理。处理包括读取文件，将其分成一行行的文字，<br>    然后将每行解析成零或更多的符号。然后用已找到的符号字符串变量值调用 For 循环。<br>    以默认方式，/F 通过每个文件的每一行中分开的第一个空白符号。跳过空白行。<br>    你可通过指定可选 &quot;options&quot; 参数替代默认解析操作。这个带引号的字符串包括一个<br>    或多个指定不同解析选项的关键字。这些关键字为:<br><br>        eol=c           - 指一个行注释字符的结尾(就一个)<br>        skip=n          - 指在文件开始时忽略的行数。<br>        delims=xxx      - 指分隔符集。这个替换了空格和制表符的<br>                          默认分隔符集。<br>        tokens=x,y,m-n  - 指每行的哪一个符号被传递到每个迭代<br>                          的 for 本身。这会导致额外变量名称的分配。m-n<br>                          格式为一个范围。通过 nth 符号指定 mth。如果<br>                          符号字符串中的最后一个字符星号，<br>                          那么额外的变量将在最后一个符号解析之后<br>                          分配并接受行的保留文本。<br>        usebackq        - 指定新语法已在下类情况中使用:<br>                          在作为命令执行一个后引号的字符串并且一个单<br>                          引号字符为文字字符串命令并允许在 file-set<br>                          中使用双引号扩起文件名称。<br><br>    某些范例可能有助:<br><br>FOR /F &quot;eol=; tokens=2,3* delims=, &quot; <span class="hljs-comment">%i in (myfile.txt) do @echo %i %j %k</span><br><br>    会分析 myfile.txt 中的每一行，忽略以分号打头的那些行，将<br>    每行中的第二个和第三个符号传递给 for 函数体，用逗号和/或<br>    空格分隔符号。请注意，此 for 函数体的语句引用 <span class="hljs-comment">%i 来</span><br>    获得第二个符号，引用 <span class="hljs-comment">%j 来获得第三个符号，引用 %k</span><br>    来获得第三个符号后的所有剩余符号。对于带有空格的文件<br>    名，你需要用双引号将文件名括起来。为了用这种方式来使<br>    用双引号，还需要使用 usebackq 选项，否则，双引号会<br>    被理解成是用作定义某个要分析的字符串的。<br><br>    <span class="hljs-comment">%i 在 for 语句中显式声明，%j 和 %k 是通过</span><br>    tokens= 选项隐式声明的。可以通过 tokens= 一行<br>    指定最多 26 个符号，只要不试图声明一个高于字母 &quot;z&quot; 或<br>    &quot;Z&quot; 的变量。请记住，FOR 变量是单一字母、分大小写和全局的变量；<br>    而且，不能同时使用超过 52 个。<br><br>    还可以在相邻字符串上使用 FOR /F 分析逻辑，方法是，<br>    用单引号将括号之间的 file-set 括起来。这样，该字符<br>    串会被当作一个文件中的一个单一输入行进行解析。<br><br>    最后，可以用 FOR /F 命令来分析命令的输出。方法是，将<br>    括号之间的 file-set 变成一个反括字符串。该字符串会<br>    被当作命令行，传递到一个子 CMD.EXE，其输出会被捕获到<br>    内存中，并被当作文件分析。如以下例子所示:<br><br>      FOR /F &quot;usebackq delims==&quot; <span class="hljs-comment">%i IN (`set`) DO @echo %i</span><br><br>    会枚举当前环境中的环境变量名称。<br><br>另外，FOR 变量参照的替换已被增强。你现在可以使用下列<br>选项语法:<br><br>     <span class="hljs-comment">%~I          - 删除任何引号(&quot;)，扩展 %I</span><br>     <span class="hljs-comment">%~fI        - 将 %I 扩展到一个完全合格的路径名</span><br>     <span class="hljs-comment">%~dI        - 仅将 %I 扩展到一个驱动器号</span><br>     <span class="hljs-comment">%~pI        - 仅将 %I 扩展到一个路径</span><br>     <span class="hljs-comment">%~nI        - 仅将 %I 扩展到一个文件名</span><br>     <span class="hljs-comment">%~xI        - 仅将 %I 扩展到一个文件扩展名</span><br>     <span class="hljs-comment">%~sI        - 扩展的路径只含有短名</span><br>     <span class="hljs-comment">%~aI        - 将 %I 扩展到文件的文件属性</span><br>     <span class="hljs-comment">%~tI        - 将 %I 扩展到文件的日期/时间</span><br>     <span class="hljs-comment">%~zI        - 将 %I 扩展到文件的大小</span><br>     <span class="hljs-comment">%~$PATH:I   - 查找列在路径环境变量的目录，并将 %I 扩展</span><br>                   到找到的第一个完全合格的名称。如果环境变量名<br>                   未被定义，或者没有找到文件，此组合键会扩展到<br>                   空字符串<br><br>可以组合修饰符来得到多重结果:<br><br>     <span class="hljs-comment">%~dpI       - 仅将 %I 扩展到一个驱动器号和路径</span><br>     <span class="hljs-comment">%~nxI       - 仅将 %I 扩展到一个文件名和扩展名</span><br>     <span class="hljs-comment">%~fsI       - 仅将 %I 扩展到一个带有短名的完整路径名</span><br>     <span class="hljs-comment">%~dp$PATH:I - 搜索列在路径环境变量的目录，并将 %I 扩展</span><br>                   到找到的第一个驱动器号和路径。<br>     <span class="hljs-comment">%~ftzaI     - 将 %I 扩展到类似输出线路的 DIR</span><br><br>在以上例子中，<span class="hljs-comment">%I 和 PATH 可用其他有效数值代替。%~ 语法</span><br>用一个有效的 FOR 变量名终止。选取类似 <span class="hljs-comment">%I 的大写变量名</span><br>比较易读，而且避免与不分大小写的组合键混淆。<br></code></pre></td></tr></table></figure><h2 id="dir"><a href="#dir" class="headerlink" title="dir"></a>dir</h2><p>列出文件</p><h2 id="cls"><a href="#cls" class="headerlink" title="cls"></a>cls</h2><p>清屏</p><h1 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE"></a>NOTE</h1><h2 id="mklinkC盘程序搬家"><a href="#mklinkC盘程序搬家" class="headerlink" title="mklinkC盘程序搬家"></a>mklinkC盘程序搬家</h2><p>命令参数</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">mklink<span class="hljs-string">[[/d]|[/h]|[/j]]</span>&lt;Link&gt;&lt;Target&gt;<br></code></pre></td></tr></table></figure><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>&#x2F;d</td><td>创建目录符号链接。默认情况下，mklink会创建文件符号链接。</td></tr><tr><td>&#x2F;H</td><td>创建硬链接而不是符号链接。</td></tr><tr><td>&#x2F;J</td><td>创建目录连接。</td></tr><tr><td>&lt;链接&gt;</td><td>指定正在创建的符号链接的名称。</td></tr><tr><td>&lt;目标&gt;</td><td>指定新符号链接引用的路径（相对或绝对）。</td></tr><tr><td>&#x2F;？</td><td>在命令提示符下显示帮助。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ms-dos</tag>
      
      <tag>windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows下使用Makefile</title>
    <link href="/2022/714f1d49/"/>
    <url>/2022/714f1d49/</url>
    
    <content type="html"><![CDATA[<h1 id="1-安装MinGW"><a href="#1-安装MinGW" class="headerlink" title="1.安装MinGW"></a>1.安装MinGW</h1><p>在MinGW的bin目录下有一个文件叫<code>mingw32-make.exe</code> 运行它就跟<code>make</code>指令类似</p><p><img src="/2022/714f1d49/watermarkpic_center.png" alt="在这里插入图片描述"></p><h1 id="2-CMD-终端运行Makefile-mingw32-make"><a href="#2-CMD-终端运行Makefile-mingw32-make" class="headerlink" title="2. CMD 终端运行Makefile (mingw32-make)"></a>2. CMD 终端运行Makefile (mingw32-make)</h1><p>在cmd终端下直接输入<code>mingw32-make</code>然后回车就可以进行编译了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">Microsoft Windows [版本 10.0.16299.967]<br>(c) 2017 Microsoft Corporation。保留所有权利。<br><br>D:\Project\Code\C++\hello&gt; mingw32-make.exe<br>g++    -c -o main.o main.cpp<br>g++ -std=c++17 -o main main.o<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>makefile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为人处世</title>
    <link href="/2022/d2bd881e/"/>
    <url>/2022/d2bd881e/</url>
    
    <content type="html"><![CDATA[<ul><li>知道自己在某个领域的无知，就不会对那个领域的人指手画脚；<br>知道自己在某项能力上的无知，就不会变得自大妄为；<br><strong>知道自己对恋人某种内心活动的无知，就不会因为误会而说出伤害对方的话语。</strong></li><li>每个人的内心是怎样的，他就将自己内心的感受投射到外部世界，于是他眼中的世界就会是满足自己想象的那个世界，而不是真实的世界。</li><li><strong>“人生究竟如何，取决于我们如何去看它。”</strong><br>当我们戴上黑白的眼镜，人生便是黑白的；反之，如果希望自己的人生是彩色的，最重要的就是要戴上彩色的眼镜。</li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>life</tag>
      
      <tag>人生</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++</title>
    <link href="/2022/5751eea2/"/>
    <url>/2022/5751eea2/</url>
    
    <content type="html"><![CDATA[<h1 id="C-Bref"><a href="#C-Bref" class="headerlink" title="C++ Bref"></a>C++ Bref</h1><p>C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。</p><p>C++ 被认为是一种<strong>中级</strong>语言，它综合了高级语言和低级语言的特点。</p><p>C++ 是由 Bjarne Stroustrup 于 1979 年在新泽西州美利山贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，最初命名为带类的C，后来在 1983 年更名为 C++。</p><p>C++ 是 C 的一个超集，事实上，任何合法的 C 程序都是合法的 C++ 程序。</p><p><strong>注意：</strong>使用静态类型的编程语言是在编译时执行类型检查，而不是在运行时执行类型检查。</p><h2 id="类-Class"><a href="#类-Class" class="headerlink" title="类 Class"></a>类 Class</h2><p>类是虚拟的, 统称, 对象是类的实体</p><h2 id="对象-Objects"><a href="#对象-Objects" class="headerlink" title="对象 Objects"></a>对象 Objects</h2><p>objects &#x3D; attributes + services &#x3D; data + operations</p><p>对象 &#x3D; 属性 + 服务 &#x3D; 数据 + 操作</p><p><img src="/2022/5751eea2/image-20220506211131674.png" alt="image-20220506211131674"></p><ul><li>Data 要避免去直接操作, 应该通过Operations去交互</li></ul><p> 三个特性</p><ul><li>封装</li><li>继承</li><li>多态</li></ul><h2 id="Objects-amp-Class"><a href="#Objects-amp-Class" class="headerlink" title="Objects &amp; Class"></a>Objects &amp; Class</h2><p>类是虚拟的, 统称, 对象是类的实体</p><p>猫 -&gt; 种类 -&gt; Class</p><p>这只猫 -&gt; 实体 -&gt; Objects</p><p><img src="/2022/5751eea2/image-20220506210930554.png" alt="image-20220506210930554"></p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>C++ 完全支持面向对象的程序设计，包括面向对象开发的四大特性：</p><ul><li>封装</li><li>抽象</li><li>继承</li><li>多态</li></ul><p>C++ 程序可以定义为对象的集合，这些对象通过调用彼此的方法进行交互。</p><h2 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h2><p>标准的 C++ 由三个重要部分组成：</p><ul><li>核心语言，提供了所有构件块，包括变量、数据类型和常量，等等。</li><li>C++ 标准库，提供了大量的函数，用于操作文件、字符串等。</li><li>标准模板库（STL），提供了大量的方法，用于操作数据结构等。</li></ul><h1 id="hello-word"><a href="#hello-word" class="headerlink" title="hello word"></a>hello word</h1><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span><span class="hljs-comment">// include io stream 后缀是不必要的是Windows的错觉</span></span><br><span class="hljs-comment">// 如果这里包含的是 iostream.h 则不再需要 using namespace std; 标准库也会有所不同</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-comment">// Standard 标准命名空间</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Hello world!&quot;</span> &lt;&lt; endl;<span class="hljs-comment">// c out   end line</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">g++ -v<br><span class="hljs-comment"># 使用gcc编译</span><br>gcc main.cpp -lstdc++ -o main<br><span class="hljs-comment"># g++ 程序 g++ 是将 gcc 默认语言设为 C++ 的一个特殊的版本</span><br>g++ main.cpp -o main<br><span class="hljs-comment"># 运行它</span><br>./main<br></code></pre></td></tr></table></figure><h3 id="g-编译器"><a href="#g-编译器" class="headerlink" title="g++编译器"></a>g++编译器</h3><p>g++ 有些系统默认是使用 C++98，我们可以指定使用 C++11 来编译 main.cpp 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">g++ -g -Wall -std=c++11 main.cpp<br></code></pre></td></tr></table></figure><h4 id="g-常用命令选项"><a href="#g-常用命令选项" class="headerlink" title="g++ 常用命令选项"></a>g++ 常用命令选项</h4><table><thead><tr><th align="left">选项</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">-ansi</td><td align="left">只支持 ANSI 标准的 C 语法。这一选项将禁止 GNU C 的某些特色， 例如 asm 或 typeof 关键词。</td></tr><tr><td align="left">-c</td><td align="left">只编译并生成目标文件。</td></tr><tr><td align="left">-DMACRO</td><td align="left">以字符串”1”定义 MACRO 宏。</td></tr><tr><td align="left">-DMACRO&#x3D;DEFN</td><td align="left">以字符串”DEFN”定义 MACRO 宏。</td></tr><tr><td align="left">-E</td><td align="left">只运行 C 预编译器。</td></tr><tr><td align="left">-g</td><td align="left">生成调试信息。GNU 调试器可利用该信息。</td></tr><tr><td align="left">-IDIRECTORY</td><td align="left">指定额外的头文件搜索路径DIRECTORY。</td></tr><tr><td align="left">-LDIRECTORY</td><td align="left">指定额外的函数库搜索路径DIRECTORY。</td></tr><tr><td align="left">-lLIBRARY</td><td align="left">连接时搜索指定的函数库LIBRARY。</td></tr><tr><td align="left">-m486</td><td align="left">针对 486 进行代码优化。</td></tr><tr><td align="left">-o</td><td align="left">FILE 生成指定的输出文件。用在生成可执行文件时。</td></tr><tr><td align="left">-O0</td><td align="left">不进行优化处理。</td></tr><tr><td align="left">-O</td><td align="left">或 -O1 优化生成代码。</td></tr><tr><td align="left">-O2</td><td align="left">进一步优化。</td></tr><tr><td align="left">-O3</td><td align="left">比 -O2 更进一步优化，包括 inline 函数。</td></tr><tr><td align="left">-shared</td><td align="left">生成共享目标文件。通常用在建立共享库时。</td></tr><tr><td align="left">-static</td><td align="left">禁止使用共享连接。</td></tr><tr><td align="left">-UMACRO</td><td align="left">取消对 MACRO 宏的定义。</td></tr><tr><td align="left">-w</td><td align="left">不生成任何警告信息。</td></tr><tr><td align="left">-Wall</td><td align="left">生成所有警告信息。</td></tr></tbody></table><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h2><p>基本语法和c非常类似,   ;   结尾等等</p><h2 id="三字符组-x3D-etc"><a href="#三字符组-x3D-etc" class="headerlink" title="三字符组(??&#x3D; etc.)"></a>三字符组(??&#x3D; etc.)</h2><p><strong>一种古老的语法</strong></p><p>三字符组就是用于表示另一个字符的三个字符序列，又称为三字符序列。三字符序列总是以两个问号开头。</p><table><thead><tr><th align="left">三字符组</th><th align="left">替换</th></tr></thead><tbody><tr><td align="left">??&#x3D;</td><td align="left">#</td></tr><tr><td align="left">…..</td><td align="left">….</td></tr></tbody></table><h2 id="数据类型-bool-etc"><a href="#数据类型-bool-etc" class="headerlink" title="数据类型(bool etc.)"></a>数据类型(bool etc.)</h2><p>C++ 就是在以前的c拓展了一个 bool</p><p>C++ 为程序员提供了种类丰富的内置数据类型和用户自定义的数据类型。下表列出了七种基本的 C++ 数据类型：</p><table><thead><tr><th align="left">类型</th><th align="left">关键字</th></tr></thead><tbody><tr><td align="left">布尔型</td><td align="left">bool</td></tr><tr><td align="left">字符型</td><td align="left">char</td></tr><tr><td align="left">整型</td><td align="left">int</td></tr><tr><td align="left">浮点型</td><td align="left">float</td></tr><tr><td align="left">双浮点型</td><td align="left">double</td></tr><tr><td align="left">无类型</td><td align="left">void</td></tr><tr><td align="left">宽字符型</td><td align="left">wchar_t</td></tr></tbody></table><p>其实 wchar_t 是这样来的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> <span class="hljs-type">wchar_t</span>;<br></code></pre></td></tr></table></figure><h2 id="存储类-auto-register-etc"><a href="#存储类-auto-register-etc" class="headerlink" title="存储类(auto register etc.)"></a>存储类(auto register etc.)</h2><p>存储类定义 C++ 程序中变量&#x2F;函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C++ 程序中可用的存储类：</p><ul><li>auto</li><li>register</li><li>static</li><li>extern</li><li>mutable</li><li>thread_local (C++11)</li></ul><p>从 C++ 17 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用。</p><h3 id="auto-存储类"><a href="#auto-存储类" class="headerlink" title="auto 存储类"></a>auto 存储类</h3><p>自 C++ 11 以来，<strong>auto</strong> 关键字用于两种情况：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。</p><p>C++98标准中auto关键字用于自动变量的声明，但由于使用极少且多余，在 C++17 中已删除这一用法。</p><p>根据初始化表达式自动推断被声明的变量的类型，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">auto</span> f=<span class="hljs-number">3.14</span>;      <span class="hljs-comment">//double </span><br><span class="hljs-keyword">auto</span> <span class="hljs-title function_">s</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>)</span>;  <span class="hljs-comment">//const char* </span><br><span class="hljs-keyword">auto</span> z = new <span class="hljs-keyword">auto</span>(<span class="hljs-number">9</span>); <span class="hljs-comment">// int* </span><br><span class="hljs-keyword">auto</span> x1 = <span class="hljs-number">5</span>, x2 = <span class="hljs-number">5.0</span>, x3=<span class="hljs-string">&#x27;r&#x27;</span>;<span class="hljs-comment">//错误，必须是初始化为同一类型</span><br></code></pre></td></tr></table></figure><h3 id="register-存储类"><a href="#register-存储类" class="headerlink" title="register 存储类"></a>register 存储类</h3><p><strong>register</strong> 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 ‘&amp;’ 运算符（因为它没有内存位置）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">&#123;   <br><span class="hljs-keyword">register</span> <span class="hljs-type">int</span>  miles; <br>&#125;<br></code></pre></td></tr></table></figure><p>寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 ‘register’ 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。</p><h3 id="mutable-存储类"><a href="#mutable-存储类" class="headerlink" title="mutable 存储类"></a>mutable 存储类</h3><p><strong>mutable</strong> 说明符仅适用于类的对象，这将在本教程的最后进行讲解。它允许对象的成员替代常量。也就是说，mutable 成员可以通过 const 成员函数修改。</p><h3 id="thread-local-存储类"><a href="#thread-local-存储类" class="headerlink" title="thread_local 存储类"></a>thread_local 存储类</h3><p>使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。</p><p>thread_local 说明符可以与 static 或 extern 合并。</p><p>可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。</p><p>以下演示了可以被声明为 thread_local 的变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">thread_local</span> <span class="hljs-type">int</span> x;  <span class="hljs-comment">// 命名空间下的全局变量 </span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span> &#123;</span>    <br>    <span class="hljs-type">static</span> <span class="hljs-keyword">thread_local</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s; <span class="hljs-comment">// 类的static成员变量 </span><br>&#125;; <br><span class="hljs-type">static</span> <span class="hljs-keyword">thread_local</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> X::s;  <span class="hljs-comment">// X::s 是需要定义的  </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123;    <br>    <span class="hljs-keyword">thread_local</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; v;  <span class="hljs-comment">// 本地变量 </span><br>&#125;<br><br><br></code></pre></td></tr></table></figure><h2 id="数学运算-cos-sin-etc"><a href="#数学运算-cos-sin-etc" class="headerlink" title="数学运算(cos sin etc.)"></a>数学运算(cos sin etc.)</h2><p>C++ 内置了丰富的数学函数，可对各种数字进行运算。下表列出了 C++ 中一些有用的内置的数学函数。</p><p>为了利用这些函数，您需要引用数学头文件 **<cmath>**。</p><table><thead><tr><th align="left">序号</th><th align="left">函数 &amp; 描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>double cos(double);</strong> 该函数返回弧度角（double 型）的余弦。</td></tr><tr><td align="left">2</td><td align="left"><strong>double sin(double);</strong> 该函数返回弧度角（double 型）的正弦。</td></tr><tr><td align="left">3</td><td align="left"><strong>double tan(double);</strong> 该函数返回弧度角（double 型）的正切。</td></tr><tr><td align="left">4</td><td align="left"><strong>double log(double);</strong> 该函数返回参数的自然对数。</td></tr><tr><td align="left">5</td><td align="left"><strong>double pow(double, double);</strong> 假设第一个参数为 x，第二个参数为 y，则该函数返回 x 的 y 次方。</td></tr><tr><td align="left">6</td><td align="left"><strong>double hypot(double, double);</strong> 该函数返回两个参数的平方总和的平方根，也就是说，参数为一个直角三角形的两个直角边，函数会返回斜边的长度。</td></tr><tr><td align="left">7</td><td align="left"><strong>double sqrt(double);</strong> 该函数返回参数的平方根。</td></tr><tr><td align="left">8</td><td align="left"><strong>int abs(int);</strong> 该函数返回整数的绝对值。</td></tr><tr><td align="left">9</td><td align="left"><strong>double fabs(double);</strong> 该函数返回任意一个浮点数的绝对值。</td></tr><tr><td align="left">10</td><td align="left"><strong>double floor(double);</strong> 该函数返回一个小于或等于传入参数的最大整数。</td></tr></tbody></table><h2 id="随机数-rand-etc"><a href="#随机数-rand-etc" class="headerlink" title="随机数(rand etc.)"></a>随机数(rand etc.)</h2><p>在许多情况下，需要生成随机数。关于随机数生成器，有两个相关的函数。一个是 **rand()**，该函数只返回一个伪随机数。生成随机数之前必须先调用 <strong>srand()</strong> 函数。</p><p>下面是一个关于生成随机数的简单实例。实例中使用了 <strong>time()</strong> 函数来获取系统时间的秒数，通过调用 rand() 函数来生成随机数</p><h2 id="字符串-string-etc"><a href="#字符串-string-etc" class="headerlink" title="字符串(string etc.)"></a>字符串(string etc.)</h2><p>C++ 提供了以下两种类型的字符串表示形式：</p><ul><li>C 风格字符串</li><li><strong>C++ 引入的 string 类类型</strong></li></ul><p>C++ 标准库提供了 <strong>string</strong> 类类型，支持上述所有的操作，另外还增加了其他更多的功能。我们将学习 C++ 标准库中的这个类，现在让我们先来看看下面这个实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string str1 = <span class="hljs-string">&quot;str1&quot;</span>;<br>    string str2 = <span class="hljs-string">&quot;str2&quot;</span>;<br>    string str3 = <span class="hljs-string">&quot;str3&quot;</span>;<br>    <span class="hljs-comment">// 无法实现 string str3 = &quot;str3&quot; + &quot;str3949499&quot;;  两个静态的string无法相加</span><br><br>    <span class="hljs-comment">// 字符串可以 直接相加</span><br>    str3 = str1 + str2;<br>    cout &lt;&lt; <span class="hljs-string">&quot;str3 : &quot;</span> &lt;&lt; str3 &lt;&lt; endl;<br>    <span class="hljs-comment">// 字符串可以 追加</span><br>    str3 += str1;<br>    cout &lt;&lt; <span class="hljs-string">&quot;str3 : &quot;</span> &lt;&lt; str3 &lt;&lt; endl;<br>    <span class="hljs-comment">// 从cin中直接获取</span><br>    cin &gt;&gt; str3;<br>    cout &lt;&lt; <span class="hljs-string">&quot;str3 : &quot;</span> &lt;&lt; str3 &lt;&lt; endl;<br>    <span class="hljs-comment">// 直接get到size</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;str3.size() : &quot;</span> &lt;&lt; str3.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="基本输入输出-cin-cout-cerr-clog"><a href="#基本输入输出-cin-cout-cerr-clog" class="headerlink" title="基本输入输出(cin cout cerr clog)"></a>基本输入输出(cin cout cerr clog)</h2><h3 id="I-x2F-O-库头文件"><a href="#I-x2F-O-库头文件" class="headerlink" title="I&#x2F;O 库头文件"></a>I&#x2F;O 库头文件</h3><table><thead><tr><th align="left">头文件</th><th align="left">函数和描述</th></tr></thead><tbody><tr><td align="left"><iostream></td><td align="left">该文件定义了 <strong>cin、cout、cerr</strong> 和 <strong>clog</strong> 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。</td></tr><tr><td align="left"><iomanip></td><td align="left">该文件通过所谓的参数化的流操纵器（比如 <strong>setw</strong> 和 <strong>setprecision</strong>），来声明对执行标准化 I&#x2F;O 有用的服务。</td></tr><tr><td align="left"><fstream></td><td align="left">该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。</td></tr></tbody></table><h3 id="标准输出流（cout）"><a href="#标准输出流（cout）" class="headerlink" title="标准输出流（cout）"></a>标准输出流（cout）</h3><p>预定义的对象 <strong>cout</strong> 是 <strong>iostream</strong> 类的一个实例。cout 对象”连接”到标准输出设备，通常是显示屏。<strong>cout</strong> 是与流插入运算符 &lt;&lt; 结合使用的，C++ 编译器根据要输出变量的数据类型，选择合适的流插入运算符来显示值。&lt;&lt; 运算符被重载来输出内置类型（整型、浮点型、double 型、字符串和指针）的数据项。</p><p>流插入运算符 &lt;&lt; 在一个语句中可以多次使用，如上面实例中所示，<strong>endl</strong> 用于在行末添加一个换行符。</p><p><code>cout &lt;&lt; str_cin &lt;&lt; endl;</code></p><h4 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h4><h5 id="ostream-类的成员方法"><a href="#ostream-类的成员方法" class="headerlink" title="ostream 类的成员方法"></a>ostream 类的成员方法</h5><table><thead><tr><th>成员函数</th><th>说明</th></tr></thead><tbody><tr><td>flags(fmtfl)</td><td>当前格式状态全部替换为 fmtfl。注意，fmtfl 可以表示一种格式，也可以表示多种格式。</td></tr><tr><td>precision(n)</td><td>设置输出浮点数的精度为 n。</td></tr><tr><td>width(w)</td><td>指定输出宽度为 w 个字符。</td></tr><tr><td>fill(c)</td><td>在指定输出宽度的情况下，输出的宽度不足时用字符 c 填充（默认情况是用空格填充）。</td></tr><tr><td>setf(fmtfl, mask)</td><td>在当前格式的基础上，追加 fmtfl 格式，并删除 mask 格式。其中，mask 参数可以省略。</td></tr><tr><td>unsetf(mask)</td><td>在当前格式的基础上，删除 mask 格式。</td></tr></tbody></table><h5 id="fmtfl-和-mask-参数可选值"><a href="#fmtfl-和-mask-参数可选值" class="headerlink" title="fmtfl 和 mask 参数可选值"></a>fmtfl 和 mask 参数可选值</h5><table><thead><tr><th>标 志</th><th>作 用</th></tr></thead><tbody><tr><td>ios::boolapha</td><td>把 true 和 false 输出为字符串</td></tr><tr><td>ios::left</td><td>输出数据在本域宽范围内向左对齐</td></tr><tr><td>ios::right</td><td>输出数据在本域宽范围内向右对齐</td></tr><tr><td>ios::internal</td><td>数值的符号位在域宽内左对齐，数值右对齐，中间由填充字符填充</td></tr><tr><td>ios::dec</td><td>设置整数的基数为 10</td></tr><tr><td>ios::oct</td><td>设置整数的基数为 8</td></tr><tr><td>ios::hex</td><td>设置整数的基数为 16</td></tr><tr><td>ios::showbase</td><td>强制输出整数的基数（八进制数以 0 开头，十六进制数以 0x 打头）</td></tr><tr><td>ios::showpoint</td><td>强制输出浮点数的小点和尾数 0</td></tr><tr><td>ios::uppercase</td><td>在以科学记数法格式 E 和以十六进制输出字母时以大写表示</td></tr><tr><td>ios::showpos</td><td>对正数显示“+”号</td></tr><tr><td>ios::scientific</td><td>浮点数以科学记数法格式输出</td></tr><tr><td>ios::fixed</td><td>浮点数以定点格式（小数形式）输出</td></tr><tr><td>ios::unitbuf</td><td>每次输出之后刷新所有的流</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">double</span> a = <span class="hljs-number">1.23</span>;<br>    <span class="hljs-comment">//设定后续输出的浮点数的精度为 4</span><br>    <span class="hljs-built_in">cout</span>.precision(<span class="hljs-number">4</span>);<br>    <span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-string">&quot;precision: &quot;</span>&lt;&lt; a &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-comment">//设定后续以科学计数法的方式输出浮点数</span><br>    <span class="hljs-built_in">cout</span>.setf(ios::scientific);<br>    <span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-string">&quot;scientific：&quot;</span>&lt;&lt; a &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="iomanip-格式化输出"><a href="#iomanip-格式化输出" class="headerlink" title="iomanip 格式化输出"></a>iomanip 格式化输出</h4><table><thead><tr><th>流操纵算子</th><th>作  用</th><th></th></tr></thead><tbody><tr><td>*dec</td><td>以十进制形式输出整数</td><td></td></tr><tr><td>hex</td><td>以十六进制形式输出整数</td><td></td></tr><tr><td>oct</td><td>以八进制形式输出整数</td><td></td></tr><tr><td>fixed</td><td>以普通小数形式输出浮点数</td><td></td></tr><tr><td>scientific</td><td>以科学计数法形式输出浮点数</td><td></td></tr><tr><td>left</td><td>左对齐，即在宽度不足时将填充字符添加到右边</td><td></td></tr><tr><td>*right</td><td>右对齐，即在宽度不足时将填充字符添加到左边</td><td></td></tr><tr><td>setbase(b)</td><td>设置输出整数时的进制，b&#x3D;8、10 或 16</td><td></td></tr><tr><td>setw(w)</td><td>指定输出宽度为 w 个字符，或输入字符串时读入 w 个字符。注意，该函数所起的作用是一次性的，即只影响下一次 cout 输出。</td><td></td></tr><tr><td>setfill(c)</td><td>在指定输出宽度的情况下，输出的宽度不足时用字符 c 填充（默认情况是用空格填充）</td><td></td></tr><tr><td>setprecision(n)</td><td>设置输出浮点数的精度为 n。  在使用非 fixed 且非 scientific 方式输出的情况下，n 即为有效数字最多的位数，如果有效数字位数超过 n，则小数部分四舍五人，或自动变为科学计 数法输出并保留一共 n 位有效数字。  在使用 fixed 方式和 scientific 方式输出的情况下，n 是小数点后面应保留的位数。</td><td></td></tr><tr><td>setiosflags(mask)</td><td>在当前格式状态下，追加 mask 格式，mask 参数可选择表 2 中的所有值。</td><td></td></tr><tr><td>resetiosflags(mask)</td><td>在当前格式状态下，删除 mask 格式，mask 参数可选择表 2 中的所有值。</td><td></td></tr><tr><td>boolapha</td><td>把 true 和 false 输出为字符串</td><td></td></tr><tr><td>*noboolalpha</td><td>把 true 和 false 输出为 0、1</td><td></td></tr><tr><td>showbase</td><td>输出表示数值的进制的前缀</td><td></td></tr><tr><td>*noshowbase</td><td>不输出表示数值的进制.的前缀</td><td></td></tr><tr><td>showpoint</td><td>总是输出小数点</td><td></td></tr><tr><td>*noshowpoint</td><td>只有当小数部分存在时才显示小数点</td><td></td></tr><tr><td>showpos</td><td>在非负数值中显示 +</td><td></td></tr><tr><td>*noshowpos</td><td>在非负数值中不显示 +</td><td></td></tr><tr><td>uppercase</td><td>十六进制数中使用 A~E。若输出前缀，则前缀输出 0X，科学计数法中输出 E</td><td></td></tr><tr><td>*nouppercase</td><td>十六进制数中使用 a~e。若输出前缀，则前缀输出 0x，科学计数法中输出 e。</td><td></td></tr><tr><td>internal</td><td>数值的符号（正负号）在指定宽度内左对齐，数值右对 齐，中间由填充字符填充。</td><td></td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">//以十六进制输出整数</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; hex &lt;&lt; <span class="hljs-number">16</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-comment">//删除之前设定的进制格式，以默认的 10 进制输出整数</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; resetiosflags(ios::basefield)&lt;&lt; <span class="hljs-number">16</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-type">double</span> a = <span class="hljs-number">123</span>;<br>    <span class="hljs-comment">//以科学计数法的方式输出浮点数</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; scientific &lt;&lt; a &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-comment">//删除之前设定的科学计数法的方法</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; resetiosflags(ios::scientific) &lt;&lt; a &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="标准输入流（cin）"><a href="#标准输入流（cin）" class="headerlink" title="标准输入流（cin）"></a>标准输入流（cin）</h3><p>预定义的对象 <strong>cin</strong> 是 <strong>iostream</strong> 类的一个实例。cin 对象附属到标准输入设备，通常是键盘。<strong>cin</strong> 是与流提取运算符 &gt;&gt; 结合使用的，</p><p><code>cin &gt;&gt; str_cin;</code></p><h3 id="标准错误流（cerr）"><a href="#标准错误流（cerr）" class="headerlink" title="标准错误流（cerr）"></a>标准错误流（cerr）</h3><p>预定义的对象 <strong>cerr</strong> 是 <strong>iostream</strong> 类的一个实例。cerr 对象附属到标准输出设备，通常也是显示屏，但是 <strong>cerr</strong> 对象是非缓冲的，且每个流插入到 cerr 都会立即输出。</p><h3 id="标准日志流（clog）"><a href="#标准日志流（clog）" class="headerlink" title="标准日志流（clog）"></a>标准日志流（clog）</h3><p>预定义的对象 <strong>clog</strong> 是 <strong>iostream</strong> 类的一个实例。clog 对象附属到标准输出设备，通常也是显示屏，但是 <strong>clog</strong> 对象是缓冲的。这意味着每个流插入到 clog 都会先存储在缓冲区，直到缓冲填满或者缓冲区刷新时才会输出。</p><h2 id="引用-amp-注意区别于指针"><a href="#引用-amp-注意区别于指针" class="headerlink" title="引用&amp; (注意区别于指针)"></a>引用&amp; (注意区别于指针)</h2><h4 id="C-引用-vs-指针"><a href="#C-引用-vs-指针" class="headerlink" title="C++ 引用 vs 指针"></a>C++ 引用 vs 指针</h4><p>引用很容易与指针混淆，它们之间有三个主要的不同：</p><ul><li>不存在空引用。引用必须连接到一块合法的内存。</li><li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。</li><li>引用必须在创建时被初始化。指针可以在任何时间被初始化。</li></ul><p><strong>引用符号:&amp;</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span>&amp; j=i;<span class="hljs-comment">//引用</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Max</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; a, <span class="hljs-type">int</span>&amp; b)</span></span>;<span class="hljs-comment">//引用传参</span><br></code></pre></td></tr></table></figure><h2 id="new-delete-动态内存分配"><a href="#new-delete-动态内存分配" class="headerlink" title="new delete 动态内存分配"></a>new delete 动态内存分配</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> * pi = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">225</span>); <span class="hljs-comment">//分配的同时 初始化值</span><br><br><span class="hljs-type">int</span> * pia = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>]; <span class="hljs-comment">//数据的new和delete</span><br><span class="hljs-keyword">delete</span> []pia;<span class="hljs-comment">// 带方括号释放</span><br></code></pre></td></tr></table></figure><p>具体差别可以参考</p><p>[new delete malloc free]: ..\embedded!Main\嵌入式编程学习笔记.md#C类##newdeletemallocfree“new delete malloc free”</p><p>[new delete malloc free](..\embedded!Main\嵌入式编程学习笔记.md##new delete malloc free)</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的<strong>形式参数</strong>。</p><p>形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。</p><p>当调用函数时，有三种向函数传递参数的方式：</p><table><thead><tr><th align="left">调用类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/cplusplus/cpp-function-call-by-value.html">传值调用</a></td><td align="left">该方法把参数的实际值赋值给函数的形式参数。<br>在这种情况下，修改函数内的形式参数对实际参数没有影响。</td></tr><tr><td align="left"><a href="https://www.runoob.com/cplusplus/cpp-function-call-by-pointer.html">指针调用</a></td><td align="left">该方法把参数的地址赋值给形式参数。<br/>在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。</td></tr><tr><td align="left"><a href="https://www.runoob.com/cplusplus/cpp-function-call-by-reference.html">引用调用</a></td><td align="left">该方法把参数的引用赋值给形式参数。<br/>在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。</td></tr></tbody></table><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>当您定义一个函数，您可以为参数列表中后边的每一个参数指定默认值。当调用函数时，如果实际参数的值留空，则使用这个默认值。</p><p>这是通过在函数定义中使用赋值运算符来为参数赋值的。调用函数时，如果未传递参数的值，则会使用默认值，如果指定了值，则会忽略默认值，使用传递的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> a=<span class="hljs-number">1</span>, <span class="hljs-type">int</span> b=<span class="hljs-number">2</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//do thing</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Lambda函数-匿名函数"><a href="#Lambda函数-匿名函数" class="headerlink" title="Lambda函数 匿名函数"></a>Lambda函数 匿名函数</h3><p>C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。</p><p>Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。</p><p>Lambda 表达式本质上与函数声明非常类似。Lambda 表达式具体形式如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 有返回值</span><br>[capture](parameters)-&gt;<span class="hljs-keyword">return</span>-type&#123;body&#125;<br><span class="hljs-comment">// 无返回值</span><br>[capture](parameters)&#123;body&#125;<br><br><span class="hljs-comment">// 例子</span><br>[](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)&#123; <span class="hljs-keyword">return</span> x &lt; y ; &#125;<br><span class="hljs-comment">// 如果没有参数,空的圆括号()可以省略。</span><br>[]&#123; ++global_x; &#125; <br><span class="hljs-comment">// 在一个更为复杂的例子中，返回类型可以被明确的指定</span><br>[](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) -&gt; <span class="hljs-type">int</span> &#123; <span class="hljs-type">int</span> z = x + y; <span class="hljs-keyword">return</span> z + x; &#125;<br></code></pre></td></tr></table></figure><p>关于capture里面的值如何获取：</p><blockquote><p>  []      &#x2F;&#x2F; 沒有定义任何变量。使用未定义变量会引发错误。<br>  [x, &amp;y] &#x2F;&#x2F; x以传值方式传入（默认），y以引用方式传入。<br>  [&amp;]     &#x2F;&#x2F; 任何被使用到的外部变量都隐式地以引用方式加以引用。<br>  [&#x3D;]     &#x2F;&#x2F; 任何被使用到的外部变量都隐式地以传值方式加以引用。<br>  [&amp;, x]  &#x2F;&#x2F; x显式地以传值方式加以引用。其余变量以引用方式加以引用。<br>  [&#x3D;, &amp;z] &#x2F;&#x2F; z显式地以引用方式加以引用。其余变量以传值方式加以引用。</p></blockquote><ul><li><p>值捕获 与函数中的值传递类似。lambda表达式捕获的是变量的一个拷贝，因此我们如果在lambda表达式后面改变该变量值的话，不会影响捕获前的该变量值，这就是所谓的值捕获</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br>[a]()&#123;<span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, a;);&#125;<br></code></pre></td></tr></table></figure></li><li><p>引用捕获 引用捕获和值捕获形式完全一样，只是在捕获列表中传的是变量的引用，类似于函数中的引用传递，变成下面这个样子</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br>[&amp;a]()&#123;<span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, a;);&#125;<br></code></pre></td></tr></table></figure></li><li><p>隐式捕获的方式，就是捕获的列表可以用<code>=</code>和<code>&amp;</code>代替，让编译器隐式的推断你使用的是哪个变量，然后这两个字符表示捕获的类型<code>=</code>表示值捕获，<code>&amp;</code>是引用捕获；写出来之后就变成了如下的形式：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br>[=]()&#123;<span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, a);&#125;;<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 捕获</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string str1 = <span class="hljs-string">&quot;str1&quot;</span>;<br>    string str2 = <span class="hljs-string">&quot;str2&quot;</span>;<br>    string str3 = <span class="hljs-string">&quot;str3&quot;</span>;<br>    <br>    <span class="hljs-comment">// 这是传值捕获</span><br>    <span class="hljs-keyword">auto</span> fun = [str1, str2]() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;5 str1 : &quot;</span> &lt;&lt; str1 &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;5 str2 : &quot;</span> &lt;&lt; str2 &lt;&lt; endl;<br>    &#125;;<br>    cout &lt;&lt; <span class="hljs-string">&quot;1 str1 : &quot;</span> &lt;&lt; str1 &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;1 str2 : &quot;</span> &lt;&lt; str2 &lt;&lt; endl;<br>    str1 += str2;<br>    str2 += str1;<br>    <span class="hljs-built_in">fun</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;2 str1 : &quot;</span> &lt;&lt; str1 &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;2 str2 : &quot;</span> &lt;&lt; str2 &lt;&lt; endl;<br>    <br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 输出</span><br><span class="hljs-number">1</span> str1 : str1<br><span class="hljs-number">1</span> str2 : str2<br><span class="hljs-number">5</span> str1 : str1<br><span class="hljs-number">5</span> str2 : str2<br><span class="hljs-number">2</span> str1 : str1str2<br><span class="hljs-number">2</span> str2 : str2str1str2<br><br><span class="hljs-comment">// 被当成普通函数使用了</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string str1 = <span class="hljs-string">&quot;str1&quot;</span>;<br>    string str2 = <span class="hljs-string">&quot;str2&quot;</span>;<br>    string str3 = <span class="hljs-string">&quot;str3&quot;</span>;<br>    <br>    <span class="hljs-keyword">auto</span> stradd = [&amp;](string&amp; stra,string&amp; strb) &#123;<br>        cout &lt;&lt; stra &lt;&lt; endl;<br>        cout &lt;&lt; strb &lt;&lt; endl;<br>        stra += strb;<br>        strb += stra;<br>    &#125;;<br>    <br>    cout &lt;&lt; <span class="hljs-string">&quot;1 str1 : &quot;</span> &lt;&lt; str1 &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;1 str2 : &quot;</span> &lt;&lt; str2 &lt;&lt; endl;<br>    <span class="hljs-built_in">stradd</span>(str1, str2);<br>    cout &lt;&lt; <span class="hljs-string">&quot;2 str1 : &quot;</span> &lt;&lt; str1 &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;2 str2 : &quot;</span> &lt;&lt; str2 &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//输出</span><br><span class="hljs-number">1</span> str1 : str1<br><span class="hljs-number">1</span> str2 : str2<br>str1<br>str2<br><span class="hljs-number">2</span> str1 : str1str2<br><span class="hljs-number">2</span> str2 : str2str1str2<br></code></pre></td></tr></table></figure><ul><li>这个知识点没看懂是匿了什么名, 不知所云, 难道和匿名没关系?只是捕获的功能?</li></ul><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><ul><li>确保函数名一致，在调用时根据参数来判断调用那个函数。</li><li>其参数个数或类型有所不同。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Max</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Max</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span></span>;<br><br><br><span class="hljs-built_in">Max</span>(<span class="hljs-number">112</span>, <span class="hljs-number">223</span>)<br><span class="hljs-built_in">Max</span>(<span class="hljs-number">1.2</span>, <span class="hljs-number">2.3</span>)<br></code></pre></td></tr></table></figure><h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><ul><li>对象是类的实例</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>;<span class="hljs-comment">//类的声明，在被引用前声明，被其他类引用相互引用</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span><br>&#123;<br>    <span class="hljs-type">int</span> a;<span class="hljs-comment">//默认私有属性，数据成员不能初始化 //int a(20);错误</span><br><span class="hljs-keyword">public</span>:<span class="hljs-comment">//公有成员</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Fun</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<span class="hljs-comment">//这里放声明，或者直接定义在类里面(直接定义在类里面默认内联)</span><br><span class="hljs-keyword">private</span>:<span class="hljs-comment">//私有成员</span><br><span class="hljs-keyword">protected</span>:<span class="hljs-comment">//保护成员</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MyClass::Fun</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><span class="hljs-comment">//可以定义在类里面，也可以定义在外面</span></span><br><span class="hljs-function"></span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ul><li><strong>与类同名</strong></li><li>(有但不指定)返回值</li><li><strong>可重载</strong></li><li>可以有传入参数</li><li>创建对象时自动调用</li><li>初始化由类中声明顺序决定，与初始化列表顺序无关</li><li>初始化列表优先于构造函数内的赋值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Line</span><br>&#123;<br>   <span class="hljs-keyword">public</span>:<br>      <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setLength</span><span class="hljs-params">( <span class="hljs-type">double</span> len )</span></span>;<br>      <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getLength</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span></span>;<br>      <span class="hljs-built_in">Line</span>(<span class="hljs-type">double</span> len);  <span class="hljs-comment">// 这是构造函数</span><br> <br>   <span class="hljs-keyword">private</span>:<br>      <span class="hljs-type">double</span> length;<br>&#125;;<br><span class="hljs-comment">// 成员函数定义，包括构造函数</span><br>Line::<span class="hljs-built_in">Line</span>( <span class="hljs-type">double</span> len)<br>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Object is being created, length = &quot;</span> &lt;&lt; len &lt;&lt; endl;<br>    length = len;<br>&#125;<br> <br></code></pre></td></tr></table></figure><h4 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h4><p>使用初始化列表来初始化字段：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">Line::<span class="hljs-built_in">Line</span>( <span class="hljs-type">double</span> len): <span class="hljs-built_in">length</span>(len)<br>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Object is being created, length = &quot;</span> &lt;&lt; len &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的语法等同于如下语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">Line::<span class="hljs-built_in">Line</span>( <span class="hljs-type">double</span> len)<br>&#123;<br>    length = len;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Object is being created, length = &quot;</span> &lt;&lt; len &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>假设有一个类 C，具有多个字段 X、Y、Z 等需要进行初始化，同理地，您可以使用上面的语法，只需要在不同的字段使用逗号进行分隔，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">C::<span class="hljs-built_in">C</span>( <span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b, <span class="hljs-type">double</span> c): <span class="hljs-built_in">X</span>(a), <span class="hljs-built_in">Y</span>(b), <span class="hljs-built_in">Z</span>(c)<br>&#123;<br>  ....<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><ul><li>类名前加 ~</li><li>不能有返回值</li><li>无参数，不重载</li><li>销毁系统自动调用</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">~<span class="hljs-built_in">MyClass</span>()<br>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Delete MyClass:&quot;</span> &lt;&lt; name &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h3><ul><li>与类同名</li><li>只有一个参数即对同类引用</li></ul><p><strong>被调用的情况</strong></p><ul><li>用类的已知对象初始化另一个正在创建的对象</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">MyClass</span>( <span class="hljs-type">const</span> MyClass&amp; cIn )<br>&#123;<br>    x = cIn.x;<br>    y = cIn.y;<br>    name = cIn.name;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Copy MyClass&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h2><p>this指针指向类对象的地址</p><p><strong>以下两函数等价</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MyClass::Fun</span><span class="hljs-params">( <span class="hljs-type">int</span> in )</span></span><br><span class="hljs-function"></span>&#123;<br>x = in;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MyClass::Fun</span><span class="hljs-params">( <span class="hljs-type">int</span> in )</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">this</span>-&gt;x = in;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="静态成员-static"><a href="#静态成员-static" class="headerlink" title="静态成员 static"></a>静态成员 static</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>所有类的对象有一个相同唯一的  数据成员 (共同点)</p><ul><li><p>static 声明的 数据成员(初始化不加static)</p></li><li><p>作用域是类范围类</p></li><li><p>必须要进行初始化，文件作用域进行初始化</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<span class="hljs-comment">//公有成员</span><br>    <span class="hljs-built_in">MyClass</span>( xxx ):xxx <span class="hljs-comment">//构造函数</span><br>&#123;<br>cont++;<span class="hljs-comment">//静态与非静态 数据成员访问方式一致，每构造一个类就会++</span><br>&#125;<br><span class="hljs-keyword">private</span>:<span class="hljs-comment">//私有成员</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> cont;<br>&#125;<br><br><span class="hljs-type">int</span> MyClass::cont = <span class="hljs-number">0</span>;<span class="hljs-comment">//文件作用范围 初始化</span><br><br></code></pre></td></tr></table></figure><h3 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h3><p>所有类的对象有一个相同唯一的   函数 (操作)，该函数不能直接访问非静态成员(static 变量)。</p><ul><li>static 声明的函数(类外定义不能加static)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<span class="hljs-comment">//公有成员</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span></span>;<br><span class="hljs-keyword">private</span>:<span class="hljs-comment">//私有成员</span><br><span class="hljs-type">int</span> x, y;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> cont;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyClass::Print</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><span class="hljs-comment">//不加static</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Print1&quot;</span> &lt;&lt; cont &lt;&lt; endl;<span class="hljs-comment">//不能使用 this ，不能引用 x、y</span><br>&#125;<br><br><br>MyClass A,B;<br><br>MyClass.<span class="hljs-built_in">Print</span>();<span class="hljs-comment">//建议访问方式 (表明该成员属于类，而不是对象)</span><br>A.<span class="hljs-built_in">Print</span>();<span class="hljs-comment">//效果一致不建议使用</span><br>B.<span class="hljs-built_in">Print</span>();<span class="hljs-comment">//效果一致不建议使用</span><br></code></pre></td></tr></table></figure><h2 id="常成员-const"><a href="#常成员-const" class="headerlink" title="常成员 const"></a>常成员 const</h2><h3 id="常对象"><a href="#常对象" class="headerlink" title="常对象"></a>常对象</h3><ul><li>不可更改</li><li>定义时必须初始化</li><li>只能调用 常成员函数(有const)，不能调用一般的成员函数(没有const的一般函数)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">&lt;类名&gt; <span class="hljs-type">const</span> &lt;对象名&gt;<br><span class="hljs-type">const</span> &lt;类名&gt; &lt;对象名&gt;<br><br><span class="hljs-function"><span class="hljs-type">const</span> MyClass <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="常数据成员"><a href="#常数据成员" class="headerlink" title="常数据成员"></a>常数据成员</h3><ul><li>只能通过构造函数成员初始化列表显式初始化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<span class="hljs-comment">//公有成员</span><br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> i):<span class="hljs-built_in">a</span>(i) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetCont</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">private</span>:<span class="hljs-comment">//私有成员</span><br><span class="hljs-type">int</span> x, y;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> a;<br>&#125;;<br><br><span class="hljs-type">int</span> MyClass::a = <span class="hljs-number">9</span>;<span class="hljs-comment">//初始化</span><br></code></pre></td></tr></table></figure><h3 id="常成员函数"><a href="#常成员函数" class="headerlink" title="常成员函数"></a>常成员函数</h3><ul><li>声明 定义都需要const</li><li>常成员函数 不能更改对象的数据成员</li><li>可重载</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++">&lt;返回类型&gt; &lt;成员函数名&gt; (&lt;参数表&gt;) <span class="hljs-type">const</span>;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<span class="hljs-comment">//公有成员</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetCont</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">private</span>:<span class="hljs-comment">//私有成员</span><br><span class="hljs-type">int</span> x, y;<br>    <span class="hljs-type">int</span> cont;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MyClass::GetCont</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span> <span class="hljs-type">const</span><span class="hljs-comment">//需要加const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//return cont++;//不允许更改 数据成员</span><br>    <span class="hljs-keyword">return</span> cont;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h1 id="Lib"><a href="#Lib" class="headerlink" title="Lib"></a>Lib</h1><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><ul><li>每个头文件只声明一个类</li><li>#ifndef 防止重复包含</li><li>cpp 和 h 文件应该同名</li></ul><h2 id="读取文件发现数据长度不对"><a href="#读取文件发现数据长度不对" class="headerlink" title="读取文件发现数据长度不对"></a>读取文件发现数据长度不对</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 方法一</span><br>InLogFile.<span class="hljs-built_in">seekg</span>(<span class="hljs-number">0</span>, ios::end);<br>streampos pos = InLogFile.<span class="hljs-built_in">tellg</span>();<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> length = pos;<br><br>InLogFile.<span class="hljs-built_in">seekg</span>(<span class="hljs-number">0</span>, ios::beg);<br><span class="hljs-type">char</span> * pBuffer = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[length];<br><span class="hljs-built_in">memset</span>(pBuffer, <span class="hljs-number">0</span>, length);<br>InLogFile.<span class="hljs-built_in">read</span>(pBuffer, length);<br><br><br><span class="hljs-comment">// 方法二</span><br>std::string strr;<br>&#123; <span class="hljs-comment">// 读出全部文件</span><br>    <span class="hljs-function">std::ifstream <span class="hljs-title">in</span><span class="hljs-params">(InFilePath)</span></span>;<br>    std::ostringstream tmp;<br>    tmp &lt;&lt; in.<span class="hljs-built_in">rdbuf</span>();<br>    strr = tmp.<span class="hljs-built_in">str</span>();<br>&#125;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;length&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; length &lt;&lt; endl;<br>cout &lt;&lt; strr.<span class="hljs-built_in">length</span>() &lt;&lt; endl;<br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">12552<br>12352<br></code></pre></td></tr></table></figure><p>他们的输出结果似乎不太一样, 好像是对 <code>0D 0A</code> 的数量计算方法不太一致导致的.</p><h2 id="读取文件全部内容"><a href="#读取文件全部内容" class="headerlink" title="读取文件全部内容"></a>读取文件全部内容</h2><p>iostream著名专家Dietmar Kuehl给出了两个读取方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::ifstream <span class="hljs-title">in</span><span class="hljs-params">(<span class="hljs-string">&quot;some.file&quot;</span>)</span></span>;<br><span class="hljs-function">std::isreambuf_iterator&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title">begin</span><span class="hljs-params">(in)</span></span>;<br>std::isreambuf_iterator&lt;<span class="hljs-type">char</span>&gt; end;<br><span class="hljs-function">std::string <span class="hljs-title">some_str</span><span class="hljs-params">(begin, end)</span></span>;<span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::ifstream <span class="hljs-title">in</span><span class="hljs-params">(<span class="hljs-string">&quot;some.file&quot;</span>)</span></span>;<br>std::ostringstream tmp;<br>tmp &lt;&lt; in.<span class="hljs-built_in">rdbuf</span>();<br>std::string str = tmp.<span class="hljs-built_in">str</span>();<br></code></pre></td></tr></table></figure><h2 id="C-x2F-C-调用exe文件"><a href="#C-x2F-C-调用exe文件" class="headerlink" title="C&#x2F;C++调用exe文件"></a>C&#x2F;C++调用exe文件</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C 此为命令行控制台方法</span><br><span class="hljs-type">char</span>* a1 = (<span class="hljs-type">char</span>*)<span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-type">char</span>* a2 = (<span class="hljs-type">char</span>*)<span class="hljs-string">&quot;world&quot;</span>;<br><span class="hljs-type">char</span>* a3 = (<span class="hljs-type">char</span>*)<span class="hljs-string">&quot;!&quot;</span>;<br><span class="hljs-type">char</span> s[<span class="hljs-number">100</span>];<br>sprintf_s(s,<span class="hljs-string">&quot;%s %s %s %s &quot;</span>,<span class="hljs-string">&quot;./ceshi.exe&quot;</span>,a1,a2,a3);<br>system(s);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c/c++</tag>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>让人帮忙实际上根本不需要什么理由？</title>
    <link href="/2022/9f326461/"/>
    <url>/2022/9f326461/</url>
    
    <content type="html"><![CDATA[<p>有没有过这样的经历：<br>你在复印机前排队，前面还有好几个人在等着，正在复印的那个人已经印了好几十页还没结束……<br>你心里的想法一定和我一样，<br>这个人怎么还没弄好啊？<br>他有那么多要印吗？<br>我就印一张身份证啊！<br>这可能是上班时候最让人烦心和焦虑的一个场景。</p><p>接下来让我做一个假设，如果你此时不再等待，而是插队走到最前面，跟正在复印的人说，</p><ul><li>A：能不能让我先复印一下？</li><li>B：能不能让我先复印一下，因为我就只有一张要印，老板正在开会要我现在就给他……可以吗？</li></ul><p>你觉得A和B的措辞，哪一个会更可能让正在复印的人答应你的要求？<br>我相信大部分人都会认为：<br>B更有可能说服对方，因为它的结构是“请求+理由”；而A只有请求。</p><p>说得没错。<br>事实上，美国纽约城市大学的社会心理学家们，真的就做了这样一个实验；<br>他们在纽约城市大学校园的一台复印机旁，对120个正在打印的人做了这样的尝试。</p><p>实验人员分别用A和B的措辞，去请求对方允许自己插队；<br>结果很明显，</p><ul><li>在A措辞的样本里，60%的人答应了请求；</li><li>而B措辞的样本里，94%的人答应了请求。</li></ul><p>好吧，接下来更有意思的来了；<br>他们还加入了C措辞，是这样描述的：</p><ul><li>C：能不能让我先复印一下，因为我需要复印，我现在就需要…可以吗？</li></ul><p>嗯，如果你仔细读一下，C和B的区别在于，<br>实际上C根本没有说出任何理由，只是一个敷衍的“因为…所以…”</p><p>本质上，C和A没啥区别，什么理由都没说。</p><p>那么你来猜一下，措辞C的表现会是怎样？<br>照理说，C应该和A差不多，对吗？</p><p>并非如此，结果甚至让人大跌眼镜。<br>实验结果，C措辞的样本里，93%的人答应了请求！</p><p>What？！<br>这…如何解释？<br>这是不是意味着，<br>求人帮忙，实际上根本不需要什么理由？</p>]]></content>
    
    
    <categories>
      
      <category>life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>life</tag>
      
      <tag>心理学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年04月27日_理想和生活</title>
    <link href="/2022/53be8632/"/>
    <url>/2022/53be8632/</url>
    
    <content type="html"><![CDATA[<table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><img src="/2022/53be8632/processed-76ea8cde-4d50-44d1-a50f-8cbef6eb224d_b4aef09e-6e94-4de0-8e36-4cc658c2fbb3.jpeg" alt="processed-76ea8cde-4d50-44d1-a50f-8cbef6eb224d_b4aef09e-6e94-4de0-8e36-4cc658c2fbb3"></td><td><img src="/2022/53be8632/processed-bc6161eb-5013-4e56-b688-7617a098fb80_e21c86c7-2498-4a46-ba87-b1388333522a.jpeg" alt="processed-bc6161eb-5013-4e56-b688-7617a098fb80_e21c86c7-2498-4a46-ba87-b1388333522a"></td></tr></tbody></table><blockquote><p>   上海封城封了一个月了，这段时间也不知是怎么样过来的，也不知道什么时候能够结束，似乎不能出户门已经成为很正常的一件事了?</p></blockquote><p>一面生活(葱花)，一面浪漫(烛光)，😀</p><p>突然想起来一句话，“理想主义化，最终会盛开在浪漫主义的土壤里。我的热情 永远不会熄灭在现实的平凡之中”</p>]]></content>
    
    
    <categories>
      
      <category>life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>life</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Wordpress</title>
    <link href="/2022/aa858de8/"/>
    <url>/2022/aa858de8/</url>
    
    <content type="html"><![CDATA[<h1 id="Wordpress"><a href="#Wordpress" class="headerlink" title="Wordpress"></a>Wordpress</h1><h2 id="LNMP安装"><a href="#LNMP安装" class="headerlink" title="LNMP安装"></a>LNMP安装</h2><p><a href="https://lnmp.org/">https://lnmp.org/</a></p><p><strong>LNMP一键安装包是什么?</strong></p><p>LNMP一键安装包是一个用Linux Shell编写的可以为CentOS&#x2F;RHEL&#x2F;Fedora&#x2F;Aliyun&#x2F;Amazon、Debian&#x2F;Ubuntu&#x2F;Raspbian&#x2F;Deepin&#x2F;Mint Linux VPS或独立主机安装LNMP(Nginx&#x2F;MySQL&#x2F;PHP)、LNMPA(Nginx&#x2F;MySQL&#x2F;PHP&#x2F;Apache)、LAMP(Apache&#x2F;MySQL&#x2F;PHP)生产环境的Shell程序。</p><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 登录</span><br>mysql -u root -p<br><br><span class="hljs-comment"># 如果报找不到命令 cd到对应目录去登录</span><br><span class="hljs-built_in">cd</span> /usr/local/mariadb10/bin/<br>./mysql -u root -p<br><br><span class="hljs-comment"># 切换到mysql数据库</span><br>use mysql<br><br><span class="hljs-comment"># 执行以下命令，创建 MariaDB 数据库。例如 “wordpress”。</span><br>CREATE DATABASE IF NOT EXISTS wordpress;<br><br><span class="hljs-comment"># 执行以下命令，创建一个新用户。例如 “user”，登录密码为 123456。</span><br>CREATE USER <span class="hljs-string">&#x27;user&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> IDENTIFIED BY <span class="hljs-string">&#x27;123456&#x27;</span>;<br><br><span class="hljs-comment"># 执行以下命令，赋予用户对 “wordpress” 数据库的全部权限。</span><br>GRANT ALL PRIVILEGES ON wordpress.* TO <span class="hljs-string">&#x27;user&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> IDENTIFIED BY <span class="hljs-string">&#x27;123456&#x27;</span>;<br><br><span class="hljs-comment"># 执行以下命令，设置 root 帐户密码</span><br>ALTER USER root@localhost IDENTIFIED VIA mysql_native_password USING PASSWORD(<span class="hljs-string">&#x27;输入您的密码&#x27;</span>);<br><br><span class="hljs-comment"># 执行以下命令，使所有配置生效。</span><br>FLUSH PRIVILEGES;<br><br><span class="hljs-comment"># 退出</span><br>\q<br></code></pre></td></tr></table></figure><h2 id="Wordpress-1"><a href="#Wordpress-1" class="headerlink" title="Wordpress"></a>Wordpress</h2><h4 id="修改-WordPress-配置文件"><a href="#修改-WordPress-配置文件" class="headerlink" title="修改 WordPress 配置文件"></a>修改 WordPress 配置文件</h4><ol><li><p>依次执行以下命令，进入 WordPress 安装目录，将<code>wp-config-sample.php</code>文件复制到<code>wp-config.php</code>文件中，并将原先的示例配置文件保留作为备份。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd <span class="hljs-regexp">/home/</span>wwwroot/wordpress<br></code></pre></td></tr></table></figure><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">cp</span> <span class="hljs-keyword">wp</span>-config-sample.php <span class="hljs-keyword">wp</span>-config.php<br></code></pre></td></tr></table></figure></li><li><p>执行以下命令，打开并编辑新创建的配置文件。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">vim</span> <span class="hljs-keyword">wp</span>-config.php<br></code></pre></td></tr></table></figure></li><li><p>按 <strong>i</strong> 切换至编辑模式，找到文件中 MySQL 的部分，并将相关配置信息修改为 <a href="https://cloud.tencent.com/document/product/213/8044#database">配置 WordPress 数据库</a> 中的内容。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-comment">// ** MySQL settings - You can get this info from your web host ** //</span><br><span class="hljs-comment">/** The name of the database for WordPress */</span><br><span class="hljs-class"><span class="hljs-keyword">define</span></span>(<span class="hljs-string">&#x27;DB_NAME&#x27;</span>, <span class="hljs-string">&#x27;wordpress&#x27;</span>);<br>    <br><span class="hljs-comment">/** MySQL database username */</span><br><span class="hljs-class"><span class="hljs-keyword">define</span></span>(<span class="hljs-string">&#x27;DB_USER&#x27;</span>, <span class="hljs-string">&#x27;user&#x27;</span>);<br>    <br><span class="hljs-comment">/** MySQL database password */</span><br><span class="hljs-class"><span class="hljs-keyword">define</span></span>(<span class="hljs-string">&#x27;DB_PASSWORD&#x27;</span>, <span class="hljs-string">&#x27;123456&#x27;</span>);<br>    <br><span class="hljs-comment">/** MySQL hostname */</span><br><span class="hljs-class"><span class="hljs-keyword">define</span></span>(<span class="hljs-string">&#x27;DB_HOST&#x27;</span>, <span class="hljs-string">&#x27;localhost&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>修改完成后，按 <strong>Esc</strong>，输入 <strong>:wq</strong>，保存文件返回。</p></li></ol><h3 id="开启HTTPS支持"><a href="#开启HTTPS支持" class="headerlink" title="开启HTTPS支持"></a>开启HTTPS支持</h3><h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><h2 id="获取域名"><a href="#获取域名" class="headerlink" title="获取域名"></a>获取域名</h2><p>这里有一个免费的域名, 先凑合用着吧</p><p><a href="https://www.freenom.com/">https://www.freenom.com/</a></p><blockquote><p>  freenom 注册方法</p><p>  <a href="https://zhuanlan.zhihu.com/p/115535965">https://zhuanlan.zhihu.com/p/115535965</a></p><p>  Freenom常见问题解决方法</p><p>  <a href="http://www.360doc.com/content/21/0124/00/30583588_958609144.shtml">http://www.360doc.com/content/21/0124/00/30583588_958609144.shtml</a></p></blockquote><ul><li><p>注册的时候搜索要加上后缀不然会显示  不可用</p></li><li><p>checkout 到购物车改成 12月 free</p></li><li><p>谷歌邮箱直接登录 登录后要更改自己的个人信息里面的地址(改成ip所在地) 不然无法成功注册</p></li><li><p>菜单栏 servers -&gt; my domains 就可以看到地址了</p></li><li><p>最后再修改一下NS服务器</p><ul><li><p>Manage Domain -&gt; Management Tools -&gt; nameserver -&gt; Use custom nameservers (enter below)</p></li><li><p>这里填写cloudflare 或者 dnspod 给出来的 Nameservers 就好了</p></li><li><p>类似于</p></li><li><table><thead><tr><th align="left">Type</th><th align="left">Value</th></tr></thead><tbody><tr><td align="left">NS</td><td align="left">katja.ns.cloudflare.com</td></tr><tr><td align="left">NS</td><td align="left">kirk.ns.cloudflare.com</td></tr></tbody></table></li></ul></li></ul><h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><p>域名的<a href="https://www.vpsgo.com/tag/ns%E8%AE%B0%E5%BD%95">NS记录</a>（<a href="https://www.vpsgo.com/tag/name-server">Name Server</a>）是指处理域名解析的服务器，说白点就是你的域名由谁家来解析。一般购买了域名后，默认的NS记录就是指向域名提供商的（例如NameSilo的默认就由它自己解析）。你可以修改域名的NS记录，让它由不同的解析服务商来解析，例如可以指向<a href="https://www.vpsgo.com/tag/cloudflare">Cloudflare</a>或者<a href="https://www.vpsgo.com/tag/dnspod">DNSPod</a>。</p><p>之后DNS（Domain Name System），常用的<a href="https://www.vpsgo.com/tag/dns%E8%AE%B0%E5%BD%95">DNS记录</a>包括域名解析中A记录、CNAME、MX记录。<a href="https://www.vpsgo.com/tag/%E5%9F%9F%E5%90%8Da%E8%AE%B0%E5%BD%95">域名A记录</a>又称为IP指向，就是说你这个域名代表什么IP；域名CNAME是指别名指向，就是说指向另一个域名，例如可以设置test.vpsgo.com指向<a href="http://www.vpsgo.com;域名的mx记录就是邮件交换记录,是做邮件服务器需要设置的.本文主要介绍域名a记录解析./">www.vpsgo.com；域名的MX记录就是邮件交换记录，是做邮件服务器需要设置的。本文主要介绍域名A记录解析。</a></p><blockquote><p>  cloudflare 解析</p><p>  <a href="https://zhuanlan.zhihu.com/p/56423186">https://zhuanlan.zhihu.com/p/56423186</a></p><p>  <a href="https://www.vpsgo.com/domain-ns-cloudflare-dnspod.html#NS">https://www.vpsgo.com/domain-ns-cloudflare-dnspod.html#NS</a></p></blockquote><h1 id="HTTPS-SSL-x2F-TLS"><a href="#HTTPS-SSL-x2F-TLS" class="headerlink" title="HTTPS SSL&#x2F;TLS"></a>HTTPS SSL&#x2F;TLS</h1><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><h3 id="acme-sh"><a href="#acme-sh" class="headerlink" title="acme.sh"></a>acme.sh</h3><p><a href="https://ruby-china.org/topics/31983">https://ruby-china.org/topics/31983</a></p><p><a href="https://ruby-china.org/topics/28471">https://ruby-china.org/topics/28471</a></p><p><a href="https://ruby-china.org/topics/25543">https://ruby-china.org/topics/25543</a></p><p><a href="https://ruby-china.org/topics/31942">https://ruby-china.org/topics/31942</a></p><h3 id="caddy"><a href="#caddy" class="headerlink" title="caddy"></a>caddy</h3><p><a href="https://caddyserver.com/docs/quick-starts/https">https://caddyserver.com/docs/quick-starts/https</a></p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装 acme.sh</span><br>curl https://get.acme.sh | sh<br><br><span class="hljs-comment"># 然后重新载入一下 .bashrc</span><br><span class="hljs-built_in">source</span> ~/.bashrc <br><br><span class="hljs-comment"># 至此acme安装完成</span><br>acme.sh<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 注册账号</span><br>sudo ~/.acme.sh/acme.sh --register-account -m jackliuworkemail@gmail.com  --server zerossl<br><br><span class="hljs-comment"># 为lager.cf创建密钥</span><br><span class="hljs-comment"># -k 表示密钥长度，后面的值可以是 ec-256 、ec-384、2048、3072、4096、8192，带有 ec 表示生成的是 ECC 证书，没有则是 RSA 证书。在安全性上 256 位的 ECC 证书等同于 3072 位的 RSA 证书。</span><br>sudo ~/.acme.sh/acme.sh --issue -d lager.cf --standalone -k ec-256<br><br><span class="hljs-comment"># 由于 Let&#x27;s Encrypt 的证书有效期只有 3 个月，因此需要 90 天至少要更新一次证书，acme.sh 脚本会每 60 天自动更新证书。也可以手动更新。</span><br><span class="hljs-comment"># 查看计划任务</span><br> crontab -l<br><span class="hljs-comment"># 手动更新 ECC 证书，执行：</span><br>sudo ~/.acme.sh/acme.sh --renew -d lager.cf --force --ecc<br><br><span class="hljs-comment"># 请注意：reloadcmd非常重要。证书可以自动续订，但是，如果没有正确的“reloadcmd”，证书可能无法刷新到您的服务器（如nginx或apache），那么您的网站将无法在60天内显示续订证书。</span><br><span class="hljs-comment"># 注意：无论什么情况，密钥(即上面的lager.cf.key)都不能泄漏，如果你不幸泄漏了密钥，可以使用 acme.sh 将原证书吊销，再生成新的证书，吊销方法请自行参考 acme.sh 的手册</span><br>acme.sh --installcert -d lager.cf \<br>--keypath       /usr/local/nginx/ssl/lager.cf.key \<br>--fullchainpath /usr/local/nginx/ssl/lager.cf.cer \<br>--reloadcmd     <span class="hljs-string">&quot;sudo service nginx force-reload&quot;</span>  --force --ecc<br><br><span class="hljs-comment"># 生成 dhparam.pem 文件</span><br>openssl dhparam -out /usr/local/nginx/ssl/lager.cf.pem 2048<br><br><br><span class="hljs-comment"># 配置nginx 启用 https</span><br>vim /usr/local/nginx/conf/nginx.conf<br><br><span class="hljs-comment"># 检查配置</span><br>sudo service nginx configtest<br><span class="hljs-comment"># 重启服务</span><br>sudo service nginx restart<br><br><br><span class="hljs-comment">#验证 SSL</span><br><span class="hljs-comment">#访问 ssllabs.com 输入你的域名，检查 SSL 的配置是否都正常：</span><br>https://ssllabs.com/ssltest/analyze.html?d=ruby-china.org<br></code></pre></td></tr></table></figure><h3 id="一些注意事项"><a href="#一些注意事项" class="headerlink" title="一些注意事项"></a>一些注意事项</h3><ul><li><code>ssl_dhparam</code> 未配置，将导致 ssllabs.com 的评分降到 B，并给 <code>This server supports weak Diffie-Hellman (DH) key exchange parameters. Grade capped to B.</code> 的警告。</li><li><code>ssl_prefer_server_ciphers on</code> 也是一个必要的配置，否则会 A+ 变成 A-;</li><li>如果你需要兼容老系统或老浏览器的话，你需要配置 <code>ssl_ciphers</code>，详见 <a href="https://wiki.mozilla.org/Security/Server_Side_TLS">Mozilla Server_Side_TLS 的介绍</a>，Nginx 里面 <code>ssl_ciphers</code> 默认值是 <code>HIGH:!aNULL:!MD5;</code> <a href="https://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_ciphers">ref</a></li></ul><h2 id="acme-sh-1"><a href="#acme-sh-1" class="headerlink" title="acme.sh"></a>acme.sh</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看证书列表</span><br>acme.sh --list<br><br><span class="hljs-comment"># 删除证书</span><br>acme.sh remove Main_Domain (证书的主域名，上述证书列表中可看见)<br><br><span class="hljs-comment"># 升级 acme.sh 到最新版 :</span><br>acme.sh --upgrade<br><br><span class="hljs-comment"># 如果你不想手动升级, 可以开启自动升级:</span><br>acme.sh --upgrade --auto-upgrade<br><br><span class="hljs-comment">#你也可以随时关闭自动更新:</span><br>acme.sh --upgrade --auto-upgrade 0 <br><br><span class="hljs-comment"># 如果出错, 请添加 debug log：</span><br>acme.sh --issue ..... --debug <br><span class="hljs-comment"># 或者：</span><br>acme.sh --issue ..... --debug 2<br></code></pre></td></tr></table></figure><h2 id="ngix"><a href="#ngix" class="headerlink" title="ngix"></a>ngix</h2><h3 id="nginx-config-1"><a href="#nginx-config-1" class="headerlink" title="nginx config 1"></a>nginx config 1</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">server &#123;<br>    listen 80; <span class="hljs-comment">#如果硬性要求全部走https协议，这一行去除</span><br>    listen 443 ssl http2; <span class="hljs-comment">#如果硬性要求全部走https协议，这里去除ssl</span><br>    server_name chandao.test.com;<br><br>    ssl_certificate /usr/local/nginx/ssl_cert/test.com/chandao.test.com.cer;<br>    ssl_certificate_key /usr/local/nginx/ssl_cert/test.com/chandao.test.com.key;<br>    ssl_dhparam /usr/local/nginx/ssl/lager.cf.pem;<br><br>    <span class="hljs-comment">#ssl性能调优</span><br>    <span class="hljs-comment">#nginx 1.13.0支持了TLSv1.3,TLSv1.3相比之前的TLSv1.2、TLSv1.1等性能大幅提升</span><br>    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;<br>    <span class="hljs-comment"># ssl_ciphers EECDH+CHACHA20:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5;</span><br>    <span class="hljs-comment"># ssl_prefer_server_ciphers on|off 作用：是否由服务器决定采用哪种加密算法</span><br>    <span class="hljs-comment"># 如果ssl协议支持tlsv1 tls1.1这种老协议，设置为 on ，并配合ssl_ciphers使用</span><br>    <span class="hljs-comment"># 如果ssl协议只支持tlsv1.2 tlsv1.3新协议，设置为 off （nginx默认为off），因为新协议不再采纳此参数</span><br>    ssl_prefer_server_ciphers on;<br>    ssl_session_timeout 10m;<br>    <span class="hljs-comment">#使用ssl_session_cache优化https下Nginx的性能</span><br>    ssl_session_cache <span class="hljs-built_in">builtin</span>:1000 shared:SSL:10m;<br>    <span class="hljs-comment">#OCSP Stapling 开启。OCSP是用于在线查询证书吊销情况的服务，使用OCSP Stapling能将证书有效状态的信息缓存到服务器，提高 TLS 握手速度</span><br>    ssl_stapling on;<br>    <span class="hljs-comment">#OCSP Stapling 验证开启</span><br>    ssl_stapling_verify on;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="nginx-config-2"><a href="#nginx-config-2" class="headerlink" title="nginx config 2"></a>nginx config 2</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs awk">http &#123;<br>  <span class="hljs-comment"># 新增</span><br>  ssl_protocols TLSv1 TLSv1.<span class="hljs-number">1</span> TLSv1.<span class="hljs-number">2</span>;<br>  ssl_prefer_server_ciphers on;<br>  <span class="hljs-comment"># 兼容其他老浏览器的 ssl_ciphers 设置请访问 https://wiki.mozilla.org/Security/Server_Side_TLS</span><br><br>  server &#123;<br>    listen <span class="hljs-number">80</span> default_server;<br>    <span class="hljs-comment"># 新增</span><br>    listen <span class="hljs-number">443</span> ssl;<br>    ssl_certificate         <span class="hljs-regexp">/home/u</span>buntu<span class="hljs-regexp">/www/</span>ssl/www.your-app.com.key.pem;<br>    ssl_certificate_key     <span class="hljs-regexp">/home/u</span>buntu<span class="hljs-regexp">/www/</span>ssl/www.your-app.com.key;<br>    <span class="hljs-comment"># ssl_dhparam </span><br>    ssl_dhparam             <span class="hljs-regexp">/home/u</span>buntu<span class="hljs-regexp">/www/</span>ssl/dhparam.pem;<br><br>    <span class="hljs-comment"># 其他省略</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>80 重定向到 443</p><p>这些办法试了好多次都不太行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">server &#123;<br>  listen       80 default_server;<br>  server_name  www.lager.cf;<br>  <span class="hljs-built_in">return</span> 301 https://$server_name<span class="hljs-variable">$request_uri</span>;<br>&#125;<br><br><br>server &#123;<br>    listen      80;<br>    server_name    www.awesomes.cn,awesomes.cn;<br>    rewrite ^(.*)$  https://$host<span class="hljs-variable">$1</span> permanent;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="v2ray-tls-websocket-流量伪装"><a href="#v2ray-tls-websocket-流量伪装" class="headerlink" title="v2ray + tls + websocket 流量伪装"></a>v2ray + tls + websocket 流量伪装</h1><p><a href="https://www.bwgss.org/616.html">https://www.bwgss.org/616.html</a></p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><ol><li><p>证书(Certificate) – *.cer *.crt</p></li><li><p>私钥(Private Key) – *.key</p></li><li><p>证书签名请求(Certificate signing request) – *.csr</p></li><li><p>编码方式: 1. pem - base64编码 2. der - 二进制编码(少见), cer,key,csr 均可用这两种编码方式</p></li><li><p>证书吊销列表(Certificate Revocation List) – *.crl</p></li><li><p>jks（javakeystone）— 是JAVA的keytools证书工具支持的证书私钥格式，javakeystone 里面存放着key和信任的CA，key和CA可以有多个。</p></li></ol><p><img src="/2022/aa858de8/1606053801673.png" alt="Wordpress"></p>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ssl</tag>
      
      <tag>https</tag>
      
      <tag>wordpress</tag>
      
      <tag>web</tag>
      
      <tag>mysql</tag>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式</title>
    <link href="/2022/2f57a694/"/>
    <url>/2022/2f57a694/</url>
    
    <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h1 id="正则表达式-语法"><a href="#正则表达式-语法" class="headerlink" title="正则表达式 - 语法"></a>正则表达式 - 语法</h1><h2 id="可打印普通字符匹配"><a href="#可打印普通字符匹配" class="headerlink" title="可打印普通字符匹配"></a>可打印普通字符匹配</h2><p>普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。</p><table><thead><tr><th align="left">字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>.</code></td><td align="left">匹配除换行符（\n、\r）之外的任何单个字符，相等于 <code>[^\n\r]</code>。</td></tr><tr><td align="left"><code>\w</code></td><td align="left">匹配字母、数字、下划线。等价于 [A-Za-z0-9_]<br><code>\W 匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。</code></td></tr><tr><td align="left"><code>[\s\S]</code></td><td align="left">匹配所有。<code>\s</code> 是匹配所有空白符，包括换行，<code>\S</code> 非空白符，不包括换行。</td></tr><tr><td align="left"><code>[ABC]</code></td><td align="left">匹配 <code>[...]</code> 中的所有字符，<br/>例如 <code>[aeiou]</code> 匹配字符串 “google runoob taobao” 中所有的 e o u a 字母。</td></tr><tr><td align="left"><code>[^ABC]</code></td><td align="left">匹配除了 <code>[...]</code> 中字符的所有字符，<br/>例如 <code>[^aeiou]</code> 匹配字符串 “google runoob taobao” 中除了 e o u a 字母的所有字母。</td></tr><tr><td align="left"><code>[A-Z]</code></td><td align="left"><code>[A-Z]</code> 表示一个区间，匹配所有大写字母，[a-z] 表示所有小写字母。</td></tr><tr><td align="left"><code>\d</code></td><td align="left">匹配一个数字字符。等价于<code>[0-9]</code>。</td></tr><tr><td align="left"><code>\D</code></td><td align="left">匹配一个非数字字符。等价于<code>[^0-9]</code>。</td></tr><tr><td align="left"><code>\xnn</code></td><td align="left">十六进制转义字符序列。匹配两个十六进制数字<em>nn</em>表示的字符。<br/>例如，“<code>\x41</code>”匹配“<code>A</code>”。“<code>\x041</code>”则等价于“<code>\x04&amp;1</code>”。正则表达式中可以使用ASCII编码。</td></tr><tr><td align="left"><code>\num</code></td><td align="left">向后引用（back-reference）一个子字符串（substring），该子字符串与正则表达式的第<em>num</em>个用括号围起来的捕捉群（capture group）子表达式（subexpression）匹配。<br/>其中<code>num</code>是从1开始的十进制正整数，其上限可能是9[<a href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F#cite_note-3">注 2]</a>、31[<a href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F#cite_note-4">注 3]</a>、99甚至无限[<a href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F#cite_note-5">注 4]</a>。<br/>例如：“<code>(.)\1</code>”匹配两个连续的相同字符。</td></tr><tr><td align="left"><code>\n</code></td><td align="left">标识一个八进制转义值或一个向后引用。<br/>如果<code>\n</code>之前至少<code>n</code>个获取的子表达式，则<code>n</code>为向后引用。<br/>否则，如果<code>n</code>为八进制数字（0-7），则<code>n</code>为一个八进制转义值。</td></tr><tr><td align="left"><code>\nm</code></td><td align="left">3位八进制数字，标识一个八进制转义值或一个向后引用。<br/>如果<code>\nm</code>之前至少有<code>nm</code>个获得子表达式，则<em>nm</em>为向后引用。<br/>如果<code>\nm</code>之前至少有<code>n</code>个获取，则<em>n</em>为一个后跟文字<em>m</em>的向后引用。<br/>如果前面的条件都不满足，若<code>n</code>和<code>m</code>均为八进制数字（0-7），则<code>\nm</code>将匹配八进制转义值<em>nm</em>。</td></tr><tr><td align="left"><code>\nml</code></td><td align="left">如果<code>n</code>为八进制数字（0-3），且<code>m</code>和<code>l</code>均为八进制数字（0-7），则匹配八进制转义值<code>nml</code>。</td></tr><tr><td align="left"><code>\un</code></td><td align="left">Unicode转义字符序列。其中<code>n</code>是一个用四个十六进制数字表示的Unicode字符。<br/>例如，<code>\u00A9</code>匹配著作权符号（©）。</td></tr></tbody></table><h2 id="非打印字符匹配"><a href="#非打印字符匹配" class="headerlink" title="非打印字符匹配"></a>非打印字符匹配</h2><p>非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列：</p><table><thead><tr><th align="left">字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>\cx</code></td><td align="left">匹配由x指明的控制字符。<br/>例如， <code>\cM</code> 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td></tr><tr><td align="left"><code>\f</code></td><td align="left">匹配一个换页符。等价于 \x0c 和 \cL。</td></tr><tr><td align="left"><code>\n</code></td><td align="left">匹配一个换行符。等价于 \x0a 和 \cJ。</td></tr><tr><td align="left"><code>\r</code></td><td align="left">匹配一个回车符。等价于 \x0d 和 \cM。</td></tr><tr><td align="left"><code>\s</code></td><td align="left">匹配任何空白字符，包括空格、制表符、换页符等等。<br/>等价于<code> [\f\n\r\t\v]</code>。注意 Unicode 正则表达式会匹配全角空格符。</td></tr><tr><td align="left"><code>\S</code></td><td align="left">匹配任何非空白字符。等价于 <code>[^ \f\n\r\t\v]</code>。</td></tr><tr><td align="left"><code>\t</code></td><td align="left">匹配一个制表符。等价于 \x09 和 \cI。</td></tr><tr><td align="left"><code>\v</code></td><td align="left">匹配一个垂直制表符。等价于 \x0b 和 \cK。</td></tr><tr><td align="left"><code>\W</code></td><td align="left">匹配任何非单词字符。等价于“<code>[^A-Za-z0-9_]</code>”。</td></tr></tbody></table><h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><table><thead><tr><th align="left">特别字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>\</code></td><td align="left">将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。<br>例如， ‘n’ 匹配字符 ‘n’。’\n’ 匹配换行符。序列 <code>&#39;\\&#39;</code> 匹配 <code>&quot;\&quot;</code></td></tr><tr><td align="left"><code>^</code></td><td align="left">匹配输入字符串的开始位置，<br>当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。<br>要匹配 ^ 字符本身，请使用 <code>\^</code>。</td></tr><tr><td align="left"><code>$</code></td><td align="left">匹配输入字符串的结尾位置。<br>如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\n’ 或 ‘\r’。要匹配 $ 字符本身，请使用<code> \$</code>。</td></tr><tr><td align="left"><code>( )</code></td><td align="left">标记一个子表达式的开始和结束位置。<br>子表达式可以获取供以后使用。要匹配这些字符，请使用<code>\(</code>和<code> \)</code>。</td></tr><tr><td align="left"><code>*</code></td><td align="left">匹配前面的子表达式零次或多次。要匹配 <code>* </code>字符，请使用<code> \*</code>。</td></tr><tr><td align="left"><code>+</code></td><td align="left">匹配前面的子表达式一次或多次。要匹配 <code>+</code> 字符，请使用 <code>\+</code>。</td></tr><tr><td align="left"><code>?</code></td><td align="left">匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 ?。</td></tr><tr><td align="left"><code>.</code></td><td align="left">匹配除换行符 <code>\n</code> 之外的任何单字符。要匹配<code> .</code> ，请使用 <code>\.</code> 。</td></tr><tr><td align="left"><code>[</code></td><td align="left">标记一个中括号表达式的开始。要匹配 <code>[</code>，请使用 <code>\[</code>。</td></tr><tr><td align="left"><code>&#123;</code></td><td align="left">标记限定符表达式的开始。要匹配<code> &#123;</code>，请使用<code> \&#123;</code>。</td></tr><tr><td align="left">&#96;</td><td align="left">&#96;</td></tr></tbody></table><h2 id="限定符-表达式匹配次数"><a href="#限定符-表达式匹配次数" class="headerlink" title="限定符(表达式匹配次数)"></a>限定符(表达式匹配次数)</h2><p>限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。</p><p>请注意，限定符出现在范围表达式之后。</p><table><thead><tr><th align="left">字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>*</code></td><td align="left">匹配前面的子表达式零次或多次。<br/>例如，<strong>zo*</strong> 能匹配 <strong>“z”</strong> 以及 <strong>“zoo”<strong>。</strong></strong>* 等价于 **{0,}**。</td></tr><tr><td align="left"><code>+</code></td><td align="left">匹配前面的子表达式一次或多次。<br/>例如，<strong>zo+</strong> 能匹配 <strong>“zo”</strong> 以及 “**zoo”**，但不能匹配 <strong>“z”<strong>。</strong>+</strong> 等价于 **{1,}**。</td></tr><tr><td align="left"><code>? </code></td><td align="left">匹配前面的子表达式零次或一次。<br>例如，<strong>do(es)?</strong> 可以匹配 <strong>“do”</strong> 、 <strong>“does”<strong>、 <strong>“doxy”</strong> 中的 <strong>“do”</strong> 。</strong>?</strong> 等价于 **{0,1}**。</td></tr><tr><td align="left"><code>&#123;n&#125;</code></td><td align="left">n 是一个非负整数。匹配确定的 <strong>n</strong> 次。<br/>例如，<strong>o{2}</strong> 不能匹配 <strong>“Bob”</strong> 中的 <strong>o</strong>，但是能匹配 <strong>“food”</strong> 中的两个 <strong>o</strong>。</td></tr><tr><td align="left"><code>&#123;n,&#125; </code></td><td align="left">n 是一个非负整数。至少匹配n 次。<br/>例如，<strong>o{2,}</strong> 不能匹配 <strong>“Bob”</strong> 中的 <strong>o</strong>，但能匹配 <strong>“foooood”</strong> 中的所有 <strong>o</strong>。<strong>o{1,}</strong> 等价于 <strong>o+<strong>。</strong>o{0,}</strong> 则等价于 **o***。</td></tr><tr><td align="left"><code>&#123;n,m&#125;</code></td><td align="left">m 和 n 均为非负整数，其中 n &lt;&#x3D; m。最少匹配 n 次且最多匹配 m 次。<br/>例如，<strong>o{1,3}</strong> 将匹配 <strong>“fooooood”</strong> 中的前三个 <strong>o</strong>。<strong>o{0,1}</strong> 等价于 **o?**。<br/>请注意在逗号和两个数之间不能有空格。</td></tr></tbody></table><h2 id="定位符-确定-固定位置"><a href="#定位符-确定-固定位置" class="headerlink" title="定位符(确定 固定位置)"></a>定位符(确定 固定位置)</h2><p>定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。</p><table><thead><tr><th align="left">字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>^</code></td><td align="left">匹配输入字符串<strong>开始</strong>的位置。<br>如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。</td></tr><tr><td align="left"><code>$</code></td><td align="left">匹配输入字符串<strong>结尾</strong>的位置。<br/>如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。</td></tr><tr><td align="left"><code>\b</code></td><td align="left">匹配一个<strong>单词边界</strong>，即字与空格间的位置。</td></tr><tr><td align="left"><code>\B</code></td><td align="left">非单词边界匹配。</td></tr></tbody></table><h2 id="选择-捕获-保存"><a href="#选择-捕获-保存" class="headerlink" title="选择(捕获 保存)"></a>选择(捕获 保存)</h2><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td><code>(pattern)</code></td><td>匹配pattern并获取这一匹配的子字符串。该子字符串用于向后引用。</td></tr></tbody></table><ul><li><p><strong>()</strong> 表示捕获分组，**()** 会把每个分组里的匹配的值保存起来， 多个匹配值可以通过数字 n 来查看(<strong>n</strong> 是一个数字，表示第 n 个捕获组的内容)。</p></li><li><p>缓冲区编号从 1 开始。</p></li><li><p>每个缓冲区都可以使用 <strong><code>$n</code></strong> 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。例如 <code>$1</code>,<code>$2</code> 等等</p><ul><li>需要注意的是菜鸟教程里面写这里是用<code>/n</code>匹配, 在notepad++里面这个没问题, 但是VSCode并不能识别这个</li></ul></li><li><p>可以使用非捕获元字符 <code> ?:</code> 、<code>?=</code> 或 <code>?!</code> 来重写捕获，忽略对相关匹配的保存。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 原始串</span><br>https://en.wikipedia.org/wiki/Regular_expression<br>$ (\w+)://(.+?)/(.+)<br>$  <span class="hljs-variable">$1</span> \n <span class="hljs-variable">$2</span> \n <span class="hljs-variable">$3</span><br><span class="hljs-comment"># 替换后</span><br> https <br> en.wikipedia.org <br> wiki/Regular_expression<br></code></pre></td></tr></table></figure><h3 id="非捕获元-lt-lt"><a href="#非捕获元-lt-lt" class="headerlink" title="非捕获元 ?: ?= ?&lt;= ?! ?&lt;!"></a>非捕获元 <code>?: ?= ?&lt;= ?! ?&lt;!</code></h3><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td><code>(pattern)</code></td><td>匹配pattern并获取这一匹配的子字符串。该子字符串用于向后引用。</td></tr><tr><td></td><td></td></tr><tr><td><code>(?:pattern)</code></td><td>匹配pattern<strong>但不获取</strong>匹配的子字符串(shy groups)<br>也就是说这是一个非获取匹配，不存储匹配的子字符串用于向后引用。<br>这在使用或字符“&#96;(</td></tr><tr><td></td><td></td></tr><tr><td><code>(?=pattern)</code></td><td><strong>正向肯定预查</strong>（look ahead positive assert），在任何<strong>匹配</strong>pattern的字符串开始处匹配查找字符串。<br>这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。<br/>例如，“&#96;Windows(?&#x3D;95</td></tr><tr><td><code>(?!pattern)</code></td><td><strong>正向否定预查</strong>（negative assert），在任何<strong>不匹配</strong>pattern的字符串开始处匹配查找字符串。<br/>这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。<br/>例如“&#96;Windows(?!95</td></tr><tr><td></td><td></td></tr><tr><td><code>(?&lt;=pattern)</code></td><td><strong>反向肯定预查</strong>（look behind positive assert），与正向肯定预查类似，只是方向相反。<br/>例如，“&#96;(?&lt;&#x3D;95</td></tr><tr><td><code>(?&lt;!pattern)</code></td><td><strong>反向否定预查</strong>，与正向否定预查类似，只是方向相反。<br/>例如“&#96;(?&lt;!95</td></tr></tbody></table><h1 id="正则表达式-修饰符"><a href="#正则表达式-修饰符" class="headerlink" title="正则表达式 - 修饰符"></a>正则表达式 - 修饰符</h1><p>标记也称为修饰符，正则表达式的标记用于指定额外的匹配策略。</p><p>标记不写在正则表达式里，标记位于表达式之外，格式如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/pattern/</span>flags<br></code></pre></td></tr></table></figure><p>下表列出了正则表达式常用的修饰符：</p><table><thead><tr><th align="left">修饰符</th><th align="left">含义</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>i</code></td><td align="left">ignore - 不区分大小写</td><td align="left">将匹配设置为不区分大小写，搜索时不区分大小写: A 和 a 没有区别。</td></tr><tr><td align="left"><code>g</code></td><td align="left">global - 全局匹配</td><td align="left">查找所有的匹配项。</td></tr><tr><td align="left"><code>m</code></td><td align="left">multi line - 多行匹配</td><td align="left">使边界字符 <strong>^</strong> 和 <strong>$</strong> 匹配每一行的开头和结尾，记住是多行，而不是整个字符串的开头和结尾。</td></tr><tr><td align="left"><code>s</code></td><td align="left">特殊字符圆点 <strong>.</strong> 中包含换行符 <strong>\n</strong></td><td align="left">默认情况下的圆点 <strong>.</strong> 是匹配除换行符 <strong>\n</strong> 之外的任何字符，加上 <strong>s</strong> 修饰符之后, <strong>.</strong> 中包含换行符 \n。</td></tr></tbody></table><h1 id="正则表达式-优先级"><a href="#正则表达式-优先级" class="headerlink" title="正则表达式 - 优先级"></a>正则表达式 - 优先级</h1><table><thead><tr><th align="center">优先权</th><th align="center">符号</th></tr></thead><tbody><tr><td align="center">最高</td><td align="center"><code>\</code></td></tr><tr><td align="center">高</td><td align="center"><code>()</code>、<code>(?:)</code>、<code>(?=)</code>、<code>[]</code></td></tr><tr><td align="center">中</td><td align="center"><code>*</code>、<code>+</code>、<code>?</code>、<code>&#123;n&#125;</code>、<code>&#123;n,&#125;</code>、<code>&#123;n,m&#125;</code></td></tr><tr><td align="center">低</td><td align="center"><code>^</code>、<code>$</code>、中介字符</td></tr><tr><td align="center">次最低</td><td align="center">串接，即相邻字符连接在一起</td></tr><tr><td align="center">最低</td><td align="center">&#96;</td></tr></tbody></table><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><h2 id="贪婪匹配-非贪婪匹配"><a href="#贪婪匹配-非贪婪匹配" class="headerlink" title="贪婪匹配 非贪婪匹配"></a>贪婪匹配 非贪婪匹配</h2><p><strong>贪婪：</strong>下面的表达式匹配从开始小于符号 (&lt;) 到关闭 h1 标记的大于符号 (&gt;) 之间的所有内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 原字符串</span><br>&lt;h1&gt;贪婪匹配 非贪婪匹配&lt;/h1&gt;<br><span class="hljs-comment"># 贪婪匹配</span><br>$ &lt;.*&gt;<br><span class="hljs-comment"># 匹配到的字符串</span><br>&lt;h1&gt;贪婪匹配 非贪婪匹配&lt;/h1&gt;<br></code></pre></td></tr></table></figure><p><strong>非贪婪：</strong>如果您只需要匹配开始和结束 <code>h1 </code>标签，下面的非贪婪表达式只匹配<code> &lt;h1&gt;</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 原字符串</span><br>&lt;h1&gt;贪婪匹配 非贪婪匹配&lt;/h1&gt;<br><span class="hljs-comment"># 贪婪匹配</span><br>$ &lt;.*?&gt;<br><span class="hljs-comment"># 匹配到的字符串</span><br>&lt;h1&gt;<br></code></pre></td></tr></table></figure><p>通过在 *<strong><strong>、</strong>+</strong> 或 <strong>?</strong> 限定符之后放置 **?**，该表达式从”贪婪”表达式转换为”非贪婪”表达式或者最小匹配。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">正则表达式 Wiki</a></p><p><a href="https://www.runoob.com/regexp/regexp-syntax.html">正则表达式 菜鸟教程</a></p><h1 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h1><h2 id="常用正则表达式匹配"><a href="#常用正则表达式匹配" class="headerlink" title="常用正则表达式匹配"></a>常用正则表达式匹配</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#用户名</span><br>/^[a-z0-9_-]&#123;3,16&#125;$/<br><span class="hljs-comment">#密码</span><br>/^[a-z0-9_-]&#123;6,18&#125;$/<br><span class="hljs-comment">#十六进制值颜色 #ff02ff etc.</span><br>/^<span class="hljs-comment">#?([a-f0-9]&#123;6&#125;|[a-f0-9]&#123;3&#125;)$/</span><br><span class="hljs-comment">#电子邮箱</span><br>/^([a-z0-9_\.-]+)@([\da-z\.-]+)\.([a-z\.]&#123;2,6&#125;)$/<br>/^[a-z\d]+(\.[a-z\d]+)*@([\da-z](-[\da-z])?)+(\.&#123;1,2&#125;[a-z]+)+$/<br><span class="hljs-comment">#URL</span><br>/^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]&#123;2,6&#125;)([\/\w \.-]*)*\/?$/<br><span class="hljs-comment">#IP 地址</span><br>/((2[0-4]\d|25[0-5]|[01]?\d\d?)\.)&#123;3&#125;(2[0-4]\d|25[0-5]|[01]?\d\d?)/<br>/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/<br><span class="hljs-comment">#HTML 标签</span><br>/^&lt;([a-z]+)([^&lt;]+)*(?:&gt;(.*)&lt;\/\1&gt;|\s+\/&gt;)$/<br><span class="hljs-comment">#删除代码\\注释</span><br>(?&lt;!http:|\S)//.*$<br><span class="hljs-comment">#Unicode编码中的汉字范围</span><br>/^[\u2E80-\u9FFF]+$/<br></code></pre></td></tr></table></figure><h2 id="正则表达式替换"><a href="#正则表达式替换" class="headerlink" title="正则表达式替换"></a>正则表达式替换</h2><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs inform7">原始串 <br>str<span class="hljs-comment">[1]</span>abc<span class="hljs-comment">[991]</span>; <br>str<span class="hljs-comment">[2]</span>abc<span class="hljs-comment">[992]</span>; <br>str<span class="hljs-comment">[11]</span>abc<span class="hljs-comment">[993]</span>; <br>str<span class="hljs-comment">[22]</span>abc<span class="hljs-comment">[994]</span>; <br>str<span class="hljs-comment">[111]</span>abc<span class="hljs-comment">[995]</span>; <br>str<span class="hljs-comment">[222]</span>abc<span class="hljs-comment">[996]</span>; <br>str<span class="hljs-comment">[1111]</span>abc<span class="hljs-comment">[997]</span>; <br>str<span class="hljs-comment">[2222]</span>abc<span class="hljs-comment">[999]</span>; <br><br>目标串： <br>abc<span class="hljs-comment">[1]</span>; <br>abc<span class="hljs-comment">[2]</span>; <br>abc<span class="hljs-comment">[11]</span>; <br>abc<span class="hljs-comment">[22]</span>; <br>abc<span class="hljs-comment">[111]</span>; <br>abc<span class="hljs-comment">[222]</span>; <br>abc<span class="hljs-comment">[1111]</span>; <br>abc<span class="hljs-comment">[2222]</span>; <br><br>处理： <br>查找串：str/<span class="hljs-comment">[(<span class="hljs-comment">[0-9]</span>+)/]</span>abc/<span class="hljs-comment">[<span class="hljs-comment">[0-9]</span>+/]</span> <br>替换串：abc<span class="hljs-comment">[/1]</span> <br></code></pre></td></tr></table></figure><h2 id="正则表达式示例"><a href="#正则表达式示例" class="headerlink" title="正则表达式示例"></a>正则表达式示例</h2><p>下面列出一些正则表达式示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br><span class="hljs-comment"># 一个单词连续出现的位置。</span><br>/\b([a-z]+) \1\b/gi<br><span class="hljs-comment"># 匹配一个 URL 解析为协议、域、端口及相对路径。</span><br>/(\w+):\/\/([^/:]+)(:\d*)?([^<span class="hljs-comment"># ]*)/</span><br><span class="hljs-comment"># 定位章节的位置。</span><br>/^(?:Chapter|Section) [1-9][0-9]&#123;0,1&#125;$/<br><span class="hljs-comment"># a 至 z 共 26个 字母再加一个 - 号。</span><br>/[-a-z]/<br><span class="hljs-comment"># 可匹配 chapter，而不能匹配 terminal。</span><br>/ter\b/<br><span class="hljs-comment"># 可匹配 chapter，而不能匹配 aptitude。</span><br>/\Bapt/<br><span class="hljs-comment"># 可匹配 Windows95 或 Windows98 或 WindowsNT，当找到一个匹配后，从 Windows 后面开始进行下一次的检索匹配。</span><br>/Windows(?=95 |98 |NT )/<br><span class="hljs-comment"># 匹配空行。</span><br>/^\s*$/<br><span class="hljs-comment"># 验证由两位数字、一个连字符再加 5 位数字组成的 ID 号。</span><br>/\d&#123;2&#125;-\d&#123;5&#125;/<br><span class="hljs-comment"># 匹配 HTML 标签</span><br>&lt;[a-zA-Z]+.*?&gt;([\s\S]*?)&lt;/[a-zA-Z]*?&gt;<br><br><span class="hljs-comment"># 匹配 &#123;hello&#125;</span><br>hello<br><span class="hljs-comment"># 匹配 &#123;gray, grey&#125;</span><br>gray|grey<br><span class="hljs-comment"># 匹配 &#123;gray, grey&#125;</span><br>gr(a|e)y<br><span class="hljs-comment">#  匹配 &#123;gray, grey&#125;</span><br>gr[ae]y<br><span class="hljs-comment">#  匹配 &#123;babble, bebble, bibble, bobble, bubble&#125;</span><br>b[aeiou]bble<br><span class="hljs-comment">#  匹配 &#123;bat, cat, hat, mat, nat, oat, pat, Pat, ot&#125;</span><br>[b-chm-pP]at|ot<br><span class="hljs-comment">#  匹配 &#123;color, colour&#125;</span><br>colou?r<br><span class="hljs-comment">#  匹配 &#123;regex, regexes, regexp, regexps&#125;</span><br>rege(x(es)?|xps?)<br><span class="hljs-comment">#  匹配 &#123;ggle, gogle, google, gooogle, goooogle, ...&#125;</span><br>go*gle<br><span class="hljs-comment">#  匹配 &#123;gogle, google, gooogle, goooogle, ...&#125;</span><br>go+gle<br><span class="hljs-comment">#  匹配 &#123;google, googoogle, googoogoogle, googoogoogoogle, ...&#125;</span><br>g(oog)+le<br><span class="hljs-comment">#  匹配 &#123;zzz&#125;</span><br>z&#123;3&#125;<br><span class="hljs-comment">#  匹配 &#123;zzz, zzzz, zzzzz, zzzzzz&#125;</span><br>z&#123;3,6&#125;<br><span class="hljs-comment">#  匹配 &#123;zzz, zzzz, zzzzz, ...&#125;</span><br>z&#123;3,&#125;<br><span class="hljs-comment">#  匹配 &#123;Brainf**k, brainf**k&#125;</span><br>[Bb]rainf\*\*k<br><span class="hljs-comment">#  匹配 &#123;0,1,2,3,4,5,6,7,8,9&#125;</span><br>\d<br><span class="hljs-comment">#  匹配 11 个数字，以 1 开头</span><br>1\d&#123;10&#125;<br><span class="hljs-comment">#  匹配 2 到 36 范围内的整数</span><br>[2-9]|[12]\d|3[0-6]<br><span class="hljs-comment">#  匹配 Hello 后跟换行符，后跟 world</span><br>Hello\nworld<br><span class="hljs-comment"># 包含一个正整数或包含两位小数位的浮点数。</span><br>\d+(\.\d\d)?<br><span class="hljs-comment"># 排除 *、@ 、# 三个特色符号</span><br>[^*@<span class="hljs-comment">#]</span><br><span class="hljs-comment">#  匹配 // 开头的注释</span><br>//[^\r\n]*[\r\n]<br><span class="hljs-comment">#  匹配以 &quot;dog&quot; 开始</span><br>^dog<br><span class="hljs-comment">#  匹配以 &quot;dog&quot; 结尾</span><br>dog$<br><span class="hljs-comment"># is exactly &quot;dog&quot;</span><br>^dog$<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>正则表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CatDrive猫盘</title>
    <link href="/2022/eae787f0/"/>
    <url>/2022/eae787f0/</url>
    
    <content type="html"><![CDATA[<h1 id="刷机"><a href="#刷机" class="headerlink" title="刷机"></a>刷机</h1><p>刷机教程很多很多，这边就不赘述了</p><p><a href="https://www.jianshu.com/p/77e529fb35f9">https://www.jianshu.com/p/77e529fb35f9</a></p><p><a href="https://www.huakings.cn/post/283.html">https://www.huakings.cn/post/283.html</a></p><ul><li>建议备好串口刷砖必备</li><li>猫盘ssh 用户名 <strong>root</strong> 密码 <strong>Etech12</strong></li></ul><h1 id="变砖刷机"><a href="#变砖刷机" class="headerlink" title="变砖刷机"></a>变砖刷机</h1><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.bilibili.com/video/av73492887">https://www.bilibili.com/video/av73492887</a></p><p><a href="https://www.huakings.cn/post/186.html">https://www.huakings.cn/post/186.html</a></p><p><a href="http://wiki.espressobin.net/tiki-index.php?page=Bootloader+recovery+via+UART">http://wiki.espressobin.net/tiki-index.php?page=Bootloader+recovery+via+UART</a></p><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p><strong>猫盘引导过程</strong></p><p><img src="/2022/eae787f0/image-20211225204417854.png" alt="image-20211225204417854"></p><p>从 A3720 机器引导，再到SPI FLASH引导，再到SATA硬盘或者EMMC启动</p><p>出现<code>&gt;E</code>就是SPI引导没了，需要用厂商工具把SPI引导刷一遍。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p><img src="/2022/eae787f0/image-20211225203501999.png" alt="image-20211225203501999"></p><p>发现出现<code>&gt;E</code>，这就说明猫盘SPI引导没了，需要重新刷入uboot，进行救砖。</p><p>首先，需要预装VM启用厂商的Linux环境(ezremaster.iso)，安装VM这步跳过。</p><blockquote><p>创建虚拟机的时候操作系统可以选择Linux 2.2.x内核，</p></blockquote><p>串口的USB设备加到VM内，然后开机。</p><p>输入如下代码，回车运行后会让输入port，<code>/dev/ttyUSB0</code>一般是<code>0</code>输入0回车就会开始刷SPI，然后会出现++++++++，在此期间可以按几下回车。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo sh /wtpd/shua.sh<br></code></pre></td></tr></table></figure><p><img src="/2022/eae787f0/image-20211225204613427.png" alt="image-20211225204613427"></p><p>等一段时间就会出现<code>marvell&gt;&gt;</code>，至此就已经救砖成功。</p><p><img src="/2022/eae787f0/image-20211225205017895.png" alt="image-20211225205017895"></p><p>接下来就可以用<code>bubt</code>命令正常刷SPI引导了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">bubt full.bin spi usb<br></code></pre></td></tr></table></figure><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><h2 id="LED-FAN-控制脚本"><a href="#LED-FAN-控制脚本" class="headerlink" title="LED FAN 控制脚本"></a>LED FAN 控制脚本</h2><p>参考: <a href="https://bbs.nas66.com/thread-9007-1-1.html">https://bbs.nas66.com/thread-9007-1-1.html</a></p><p>参考: <a href="https://bbs.nas66.com/thread-13810-1-1.html">https://bbs.nas66.com/thread-13810-1-1.html</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir -p /a_usr<br>cat &gt; /a_usr/ledfan.sh &lt;&lt;EOF<br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/sh</span><br>if [ ! -d /sys/class/gpio/gpio450 ] ; then<br>echo 450 &gt; /sys/class/gpio/export<br>fi<br>echo out &gt; /sys/class/gpio/gpio450/direction<br>i2cset -y -f 0 0x45 0x00 0x55<br>i2cset -y -f 0 0x45 0x01 0x01<br>i2cset -y -f 0 0x45 0x30 0x07 <br>rm -r /tmp/led/<br>mkdir /tmp/led/<br>echo 1 &gt; /tmp/led/leds.flag<br>while true<br>do<br>sata_temp=&quot;\$(smartctl -a /dev/hda -d ata | sed -n &#x27;/Temperature_Celsius/p&#x27; | awk &#x27;&#123;print $10&#125;&#x27;)&quot;<br>sata=&quot;\$(hdparm -C /dev/sda |grep &#x27;drive&#x27;|awk &#x27;&#123;print \$4&#125;&#x27;)&quot;<br>ledss=&quot;\$(cat /tmp/led/leds.flag)&quot;<br>if [ \$sata = standby ];then<br>led=&quot;0x03&quot;<br>leds=&quot;0&quot;<br>fi<br>if [ \$sata = active/idle ];then<br>led=&quot;0x73&quot;<br>leds=&quot;1&quot;<br>fi<br>if [ \$sata_temp -ge 55 ];then<br>if [ -f &quot;/tmp/led/led31.flag&quot; ] &amp;&amp; [ \$ledss = \$leds ];then <br>sleep 15<br>continue<br>fi<br>i2cset -y -f 0 0x45 0x32 0x00<br>i2cset -y -f 0 0x45 0x33 0x00<br>i2cset -y -f 0 0x45 0x31 \$&#123;led&#125;<br>i2cset -y -f 0 0x45 0x34 255<br>echo 1 &gt; /sys/class/gpio/gpio450/value<br>rm -rf /tmp/led/led*.flag<br>touch /tmp/led/led31.flag<br>echo \$&#123;leds&#125; &gt; /tmp/led/leds.flag<br>fi<br>if [ \$sata_temp -ge 45 ] &amp;&amp; [ \$sata_temp -lt 55 ];then<br>if [ -f &quot;/tmp/led/led33.flag&quot; ] &amp;&amp; [ \$ledss = \$leds ];then<br>sleep 15 <br>continue<br>fi<br>i2cset -y -f 0 0x45 0x31 0x00<br>i2cset -y -f 0 0x45 0x32 0x00<br>i2cset -y -f 0 0x45 0x33 \$&#123;led&#125;<br>i2cset -y -f 0 0x45 0x36 255<br>echo 1 &gt; /sys/class/gpio/gpio450/value<br>rm -rf /tmp/led/led*.flag<br>touch /tmp/led/led33.flag<br>echo \$&#123;leds&#125; &gt; /tmp/led/leds.flag<br>fi<br>if [ \$sata_temp -lt 45 ];then<br>if [ -f &quot;/tmp/led/led32.flag&quot; ] &amp;&amp; [ \$ledss = \$leds ];then<br>sleep 15 <br>continue<br>fi<br>i2cset -y -f 0 0x45 0x31 0x00<br>i2cset -y -f 0 0x45 0x33 0x00<br>i2cset -y -f 0 0x45 0x32 \$&#123;led&#125;<br>i2cset -y -f 0 0x45 0x35 255<br>echo 0 &gt; /sys/class/gpio/gpio450/value<br>rm -rf /tmp/led/led*.flag<br>touch /tmp/led/led32.flag<br>echo \$&#123;leds&#125; &gt; /tmp/led/leds.flag<br>fi<br>sleep 15<br>done<br>EOF<br>bash /a_usr/ledfan.sh<br></code></pre></td></tr></table></figure><h2 id="修改SN半白脚本"><a href="#修改SN半白脚本" class="headerlink" title="修改SN半白脚本"></a>修改SN半白脚本</h2><p>下面的<code>00:11:32:12:34:56</code>最好改成壳子上自己的MAC</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd ~ &amp;&amp; wget -N --no-check-certificate https://www.huakings.cn/mp202003/macsn.sh &amp;&amp; chmod +x macsn.sh &amp;&amp; bash macsn.sh 00:11:32:12:34:56 1860ABCDE1860 &amp;&amp; rm -f /root/macsn.sh<br></code></pre></td></tr></table></figure><p>macsn.sh脚本详细内容如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs shell">macstr=$1<br>sn=$2<br>mac=($&#123;macstr//:/ &#125;)<br>if [ $&#123;#mac[@]&#125; != 6 ];<br>then<br>echo mac address error!<br>exit<br>fi<br>for var in $&#123;mac[@]&#125;<br>do<br>if echo $var | grep -q &#x27;[^0-9A-F]&#x27;<br>then <br>echo mac address error!<br>exit<br>fi <br>if  [[ $&#123;#var&#125; != 2  ]] <br>then<br>echo mac address error!!<br>exit<br>fi<br>done<br>if  [[ $&#123;#sn&#125; != 13  ]] <br>then<br>echo sn error:The SN Length must be 13<br>exit<br>fi<br><br>for((i=0;i&lt;6;i++));<br>do <br>declare -i macchecksum+=0x$&#123;mac[i]&#125;<br>done<br>declare -i macchecksum=$macchecksum%256<br>for((i=0;i&lt;13;i++));<br>do <br>declare -i checksum+=$(printf &#x27;%d&#x27; &quot;&#x27;$&#123;sn:$i:1&#125;&quot;)<br>done<br>if [ $&#123;#checksum&#125; == 3 ];<br>then<br>echo -e -n &quot;\x$&#123;mac[0]&#125;\x$&#123;mac[1]&#125;\x$&#123;mac[2]&#125;\x$&#123;mac[3]&#125;\x$&#123;mac[4]&#125;\x$&#123;mac[5]&#125;\<br>\x$(printf &#x27;%x&#x27; $macchecksum)\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0&quot;\<br>\SN=$sn&quot;,CHK=&quot;$checksum\<br>&quot;\x0\x0\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x3C\x0\x0\x0\<br>\x0\x0\x0\x0\x1\x1\x0\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x1\x1\x1\x1\<br>\x0\x1\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x1\x1\x1\x1\<br>\x1\x0\x1\x1\x1\x1\x1\x0\<br>\x1\x1\x1\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x1\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0&quot; &gt; vender.bin<br>else<br>echo -e -n &quot;\x$&#123;mac[0]&#125;\x$&#123;mac[1]&#125;\x$&#123;mac[2]&#125;\x$&#123;mac[3]&#125;\x$&#123;mac[4]&#125;\x$&#123;mac[5]&#125;\<br>\x$(printf &#x27;%x&#x27; $macchecksum)\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0&quot;\<br>\SN=$sn&quot;,CHK=&quot;$checksum\<br>&quot;\x0\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x3C\x0\x0\x0\<br>\x0\x0\x0\x0\x1\x1\x0\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x1\x1\x1\x1\<br>\x0\x1\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x1\x1\x1\x1\<br>\x1\x0\x1\x1\x1\x1\x1\x0\<br>\x1\x1\x1\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x1\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0\<br>\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0&quot; &gt; vender.bin<br>fi<br>dd if=vender.bin of=/dev/mtdblock3<br>rm vender.bin<br>echo Update Success! MAC:$macstr SN:$sn<br></code></pre></td></tr></table></figure><h2 id="解决猫盘掉ip问题"><a href="#解决猫盘掉ip问题" class="headerlink" title="解决猫盘掉ip问题"></a>解决猫盘掉ip问题</h2><h3 id="最蠢的办法，检查无IP重启"><a href="#最蠢的办法，检查无IP重启" class="headerlink" title="最蠢的办法，检查无IP重启"></a>最蠢的办法，检查无IP重启</h3><p>将下面脚本添加到，群晖的开机启动</p><p>控制面板-任务计划-新增-触发的任务-用户自定义脚本-开机启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>dt=`date &#x27;+%d/%m/%Y %H:%M:%S&#x27;`<br>echo &quot;$dt&quot;<br>sleep 60<br>num=`ping -c20 223.5.5.5 | tail -2 | head -1 | cut -f 3 -d&quot;,&quot; | cut -f 1 -d&quot;%&quot; | cut -f 2 -d&quot; &quot;`<br>echo $num<br>echo $?<br>if [ $? -eq 0 -a $num -eq 0 ]; then<br>echo &quot;$dt ok&quot; &gt;&gt; /result.txt<br>else<br>echo &quot;$dt noip loss $num reboot&quot; &gt;&gt; /result.txt<br>reboot<br>fi<br></code></pre></td></tr></table></figure><h3 id="其它办法"><a href="#其它办法" class="headerlink" title="其它办法"></a>其它办法</h3><p><a href="https://bbs.nas66.com/thread-17505-1-1.html">https://bbs.nas66.com/thread-17505-1-1.html</a></p><p><a href="https://bbs.nas66.com/thread-16639-1-1.html">https://bbs.nas66.com/thread-16639-1-1.html</a></p><p><a href="https://bbs.nas66.com/thread-7843-1-1.html">https://bbs.nas66.com/thread-7843-1-1.html</a></p><p><a href="https://bbs.nas66.com/thread-9350-1-1.html">https://bbs.nas66.com/thread-9350-1-1.html</a></p><p><a href="https://bbs.nas66.com/thread-4593-5-3.html">https://bbs.nas66.com/thread-4593-5-3.html</a></p><h2 id="群晖回退x3p"><a href="#群晖回退x3p" class="headerlink" title="群晖回退x3p"></a>群晖回退x3p</h2><p><a href="https://bbs.nas66.com/forum.php?mod=viewthread&amp;tid=2661">https://bbs.nas66.com/forum.php?mod=viewthread&amp;tid=2661</a></p><p>主要就是刷x3p的UBOOT，插U盘，U盘放x3p的自动安装镜像</p>]]></content>
    
    
    <categories>
      
      <category>more_interest</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CatDrive</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PC Software</title>
    <link href="/2022/fc18738/"/>
    <url>/2022/fc18738/</url>
    
    <content type="html"><![CDATA[<h1 id="PC-Windows"><a href="#PC-Windows" class="headerlink" title="PC Windows"></a>PC Windows</h1><h1 id="扫描修复系统"><a href="#扫描修复系统" class="headerlink" title="扫描修复系统"></a>扫描修复系统</h1><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">sfc <span class="hljs-string">/SCANNOW</span><br></code></pre></td></tr></table></figure><h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><h3 id="刷新DNS"><a href="#刷新DNS" class="headerlink" title="刷新DNS"></a>刷新DNS</h3><p><code>ipconfig /flushdns</code></p><h3 id="nslookup"><a href="#nslookup" class="headerlink" title="nslookup"></a>nslookup</h3><p><img src="/2022/fc18738/image-20220402175405670.png" alt="image-20220402175405670"></p><p><img src="/2022/fc18738/image-20220402175432533.png" alt="image-20220402175432533"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs bash">nslookup<br><br><span class="hljs-comment"># 设置查询类型 name server</span><br><span class="hljs-built_in">set</span> <span class="hljs-built_in">type</span>=ns<br><br><span class="hljs-comment"># 查询根服务器</span><br>.<br><br><span class="hljs-comment"># Non-authoritative 代表非权威应答 一般是缓存来的</span><br><span class="hljs-comment"># authoritative 表权威应答 根服务器直接返回的</span><br><br><span class="hljs-comment"># 设置查询类型 a ipv4地址</span><br><span class="hljs-built_in">set</span> <span class="hljs-built_in">type</span>=a<br><br><span class="hljs-comment"># 查询根服务器的ipv4地址</span><br>.<br><br><span class="hljs-comment"># 设置dns服务器地址</span><br>server 198.41.0.4<br><br><span class="hljs-comment"># 设置查询类型 name server</span><br><span class="hljs-built_in">set</span> <span class="hljs-built_in">type</span>=ns<br><br><span class="hljs-comment"># 查询cf域名服务器</span><br>cf.<br><br><span class="hljs-comment"># 设置查询类型 a ipv4地址</span><br><span class="hljs-built_in">set</span> <span class="hljs-built_in">type</span>=a<br><br><span class="hljs-comment"># 查询cf域名服务器的ipv4地址</span><br>cf.<br><br>..........<br><br><br>lager.cf.<br></code></pre></td></tr></table></figure><h1 id="硬链接-amp-符号链接"><a href="#硬链接-amp-符号链接" class="headerlink" title="硬链接&amp;符号链接"></a>硬链接&amp;符号链接</h1><blockquote><p>  mklink<br>  创建符号链接。</p><p>  MKLINK [[&#x2F;D] | [&#x2F;H] | [&#x2F;J]] Link Target</p><pre><code class="hljs">      /D      创建目录符号链接。默认为文件              符号链接。      /H      创建硬链接而非符号链接。      /J      创建目录联接。      Link    指定新的符号链接名称。      Target  指定新链接引用的路径              (相对或绝对)。</code></pre></blockquote><table><thead><tr><th></th><th>硬链接（Hard Link）</th><th>目录联接（Junction Point）</th><th>符号链接（Symbolic Link）</th></tr></thead><tbody><tr><td>命令</td><td><code>mklink /H Link Target</code></td><td><code>mklink /J Link Target</code></td><td><code>mklink /D Link Target</code></td></tr><tr><td>作用</td><td>为某文件创建别名，可让不同的路径对应同一个文件的数据。</td><td></td><td></td></tr><tr><td>链接到文件</td><td>✔️</td><td>❌</td><td>❌</td></tr><tr><td>链接到文件夹</td><td>❌</td><td>✔️</td><td>✔️</td></tr><tr><td>需要提升为管理员权限</td><td>需要</td><td>不需要</td><td>通常需要 <code>[坑1]</code></td></tr><tr><td>跨驱动器卷（盘符）</td><td>❌</td><td>✔️（仅本地计算机）</td><td>✔️（包括 SMB 文件或路径）</td></tr><tr><td>操作系统支持</td><td>Windows NT 3.1 开始支持 Windows 2000 开始有 API <code>CreateHardLink()</code> Windows NT 6.0 开始能使用 <code>mklink /H</code></td><td>Windows 2000+</td><td>Windows Vista+</td></tr><tr><td>可链接到不存在的目标</td><td>❌</td><td>✔️</td><td>✔️</td></tr><tr><td>可链接到相对目录</td><td>❌</td><td>❌（可以使用相对路径创建，但创建完即变绝对路径）</td><td>✔️</td></tr><tr><td>删除方法</td><td>del</td><td>rd</td><td>rd &#x2F; del</td></tr><tr><td>当链接被单独删除后</td><td>只有所有指向原始文件的硬链接和原始文件全部删除后文件数据才会被删除。</td><td>Windows Vista 之后原始文件夹不受影响；Windows 2000&#x2F;XP&#x2F;2003 会导致原始子文件夹被删除。</td><td>原始文件夹不受影响。</td></tr><tr><td>当原始文件被单独删除后</td><td>硬链接依然能正常访问到文件的数据。</td><td>目录联接失效，指向不存在的目录。</td><td>符号链接失效，指向不存在的目录</td></tr></tbody></table><p>比较 Windows 上四种不同的文件（夹）链接方式（NTFS 的硬链接、目录联接、符号链接，和大家熟知的快捷方式）</p><p><a href="https://blog.walterlv.com/post/ntfs-link-comparisons.html">https://blog.walterlv.com/post/ntfs-link-comparisons.html</a></p><p>Windows中的硬链接和软链接（hard link 和 Symbolic link）</p><p><a href="https://www.cnblogs.com/Naylor/p/7597869.html">https://www.cnblogs.com/Naylor/p/7597869.html</a></p><p>Windows下mklink使用, 硬链接, 软链接和快捷方式的区别</p><p><a href="https://blog.csdn.net/guyue35/article/details/49761347">https://blog.csdn.net/guyue35/article/details/49761347</a></p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dos">创建链接:<br>mklink /j D:\System\Desktop\Project  D:\Project<br><br><br><br>删除的命令：<br><span class="hljs-built_in">rmdir</span> 链接名称<br>例如：<span class="hljs-built_in">rmdir</span> d:\recivefiles <span class="hljs-built_in">rmdir</span> d:\develop<br>删除虚拟链接目录，并不会删除真实文件，注意，不能使用<span class="hljs-built_in">del</span>命令，<span class="hljs-built_in">del</span>命令会删除真实文件<br></code></pre></td></tr></table></figure><p>拓展 :  linux下的软链接和硬链接</p><blockquote><p>  同样，在Windows下，链接的功能也是被实现了的（虽然我们不会经常发现）。在Linux下，我们都知道链接有两种形式：硬链接和软链接。所谓硬链接，我们可以理解为硬链接持有的是文件本身（而不是路径）的引用。也就是说，当我们给一个名为a.txt的文件建立硬链接（b.txt）后，那么b.txt指向的位置就是a.txt这个文件本身，而此时，a.txt和b.txt是同级平行的，这个文本文件此时同时拥有两个文件名。当我们删除a.txt时，只是删除了a.txt这个文件名，这个文件仍然被b.txt所引用，所以我们还能够通过b.txt访问。而软链接，持有的则是原链接路径。比如a.txt位于 <del>&#x2F;Document&#x2F;a.txt ，那么为其建立软链接b.txt的内容就是”</del>&#x2F;Document&#x2F;a.txt”，此时，我们访问b.txt，其实是在按照a.txt的路径去访问a.txt。如果我们这时删除a.txt这个文件，那么b.txt也会无效，因为路径已经断掉。</p></blockquote><h1 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE"></a>NOTE</h1><h2 id="窗口主题色-活动和非活动窗口"><a href="#窗口主题色-活动和非活动窗口" class="headerlink" title="窗口主题色 活动和非活动窗口"></a>窗口主题色 活动和非活动窗口</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">regedit 编辑<br>计算机\HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\DWM<br><br><span class="hljs-comment"># 活动窗口颜色 </span><br><span class="hljs-comment"># 32位值就是 颜色的RGB 注意的是这里不知道是大小端的问题还是其他什么问题需要RGB数值转换成BGR样式</span><br>AccentColor <br><br><span class="hljs-comment"># 非活动窗口颜色 </span><br>AccentColorInactive <br></code></pre></td></tr></table></figure><h2 id="添加永久路由"><a href="#添加永久路由" class="headerlink" title="添加永久路由"></a>添加永久路由</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">route -p add <br><br>route ADD 157.0.0.0 MASK 255.0.0.0  157.55.80.1 METRIC 3 IF 2<br>       destination^      ^mask      ^gateway     metric^    ^<br>                                                   Interface^<br></code></pre></td></tr></table></figure><h2 id="各类特定文件夹"><a href="#各类特定文件夹" class="headerlink" title="各类特定文件夹"></a>各类特定文件夹</h2><p><code>win+r</code>输入对应内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">启动文件夹</span><br>shell:startup<br><span class="hljs-meta prompt_"># </span><span class="language-bash">发送到右键菜单</span><br>shell:sendto<br></code></pre></td></tr></table></figure><h2 id="修改WIFI位置"><a href="#修改WIFI位置" class="headerlink" title="修改WIFI位置"></a>修改WIFI位置</h2><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\NetworkList\Profiles<br></code></pre></td></tr></table></figure><ul><li>展开“Profiles”项，其下面的子项是都是一个网络连接，可以通过查看“ProfilesName”来分辨，双击打开“<code>Category</code>”，</li><li>打开编辑窗口后，修改“数值数据”，这里数值0代表公用网络，1代表专用网络，2代表域网络，设置完后点击确定即可。</li></ul><h2 id="填加开机启动"><a href="#填加开机启动" class="headerlink" title="填加开机启动"></a>填加开机启动</h2><ol><li>添加<code>Windows</code>开机自动执行<code>init-wsl.bat</code>脚本</li></ol><p><code>Windows</code>键+<code>R</code>，输入<code>regedit</code>打开注册列表，在地址栏输入<code>计算机\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run</code>定位到对应注册表位置，右键新建一个字符串值，键入<code>init-wsl.bat</code>脚本绝对路径即可，如下图！</p><p><img src="/2022/fc18738/regedit-add-init-wsl.png" alt="set regedit service"></p><p>重启计算机即可发现，<code>WSL</code>中的<code>Docker</code>服务已经被启动，通过<code>192.168.33.10</code>可以直接访问到<code>WSL</code>内部的网络！</p>]]></content>
    
    
    <categories>
      
      <category>more_interest</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>pc</tag>
      
      <tag>software</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决 Chrome由贵单位管理 惠普 谷歌浏览器 HP</title>
    <link href="/2021/320cfc33/"/>
    <url>/2021/320cfc33/</url>
    
    <content type="html"><![CDATA[<p>关键词:<br>Chrome由贵单位管理 惠普 HP 谷歌浏览器 浏览器由所属组织管理</p><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>惠普 HP ProBook 450 G8 Notebook PC<br>WIndows10 19042.1415<br>谷歌浏览器 版本 96.0.4664.45（正式版本） （64 位）</p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ol><li>网上说了很多删除注册表的答案,删除完了只是临时解决,重启后问题依旧,注册表被恢复<br> <code>\HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Google\Chrome</code></li><li>思路是找出谁访问修改了这一段注册表, 然后找到了 Process Monitor 软件, 发现注册表的修改是在开机的时候被修改的, 这个软件我也还不太会用, 不知道怎么样才能让他捕获到开机的修改, 随搜索相关文章, 最后发现居然是惠普的锅,简直离了个大谱.</li><li>把这个服务关掉, 就可以解决问题, 我当时把它文件也删掉了!<br><img src="/2021/320cfc33/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Li05rW355qE5Z-O,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"></li><li>批处理方案<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs dos">@<span class="hljs-built_in">echo</span> off<br><span class="hljs-comment">rem Automates instructions from google found here https://support.google.com/chrome/a/answer/9844476?hl=en</span><br><span class="hljs-comment">rem Removes the &#x27;Managed by your organization&#x27; from Google Chrome and prevents persistence</span><br><span class="hljs-built_in">echo</span> Make sure you have backed up your registry. Ready to go ahead?<br><span class="hljs-built_in">pause</span><br><span class="hljs-built_in">cls</span><br><span class="hljs-built_in">echo</span> Working...<br><span class="hljs-built_in">echo</span> Exiting Chrome (<span class="hljs-keyword">if</span> running)<br><span class="hljs-built_in">taskkill</span> /f /im chrome.exe<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">exist</span> &quot;C:\Program Files (x86)\Google\Policies&quot; <span class="hljs-built_in">RMDIR</span> /S /Q &quot;C:\Program Files (x86)\Google\Policies&quot;<br>reg delete HKEY_CURRENT_USER\SOFTWARE\Google\Chrome /f /va <br>reg delete HKEY_LOCAL_MACHINE\SOFTWARE\Google\Chrome /f /va <br>reg delete HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Google\Chrome /f /va <br>reg delete HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Google\Update\ClientState\&#123;<span class="hljs-number">430</span>FD4D0-B729-<span class="hljs-number">4</span>F61-AA34-<span class="hljs-number">91526481799</span>D&#125; /f /va <br>reg delete HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Google\Chrome\ExtensionInstallForcelist /f<br><span class="hljs-built_in">echo</span> Stopping and Disabling Sound Research Service<br>sc stop SECOMNService<br>sc config SECOMNService <span class="hljs-built_in">start</span>= disabled<br><span class="hljs-built_in">echo</span> Complete!<br><span class="hljs-built_in">pause</span><br></code></pre></td></tr></table></figure></li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://cihansol.com/blog/index.php/2021/07/17/uncovering-hps-potentially-unwanted-applications">Uncovering HP’s Potentially Unwanted Applications(主要参考)</a><br><a href="https://support.google.com/chrome/a/answer/9844476?hl=en#zippy=,windows">Stop managing Chrome browser</a><br><a href="https://meta.appinn.net/t/topic/26165">https://meta.appinn.net/t/topic/26165</a></p><h1 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h1><p><del>吐槽CSDN的Markdown好难用啊,为什么一删除换行把前面的也删除了? 写个github还被审核未通过? 是时候考虑一些别的方案了</del> </p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hp</tag>
      
      <tag>chrome</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VSCode多行编辑被占用</title>
    <link href="/2021/9f39ed86/"/>
    <url>/2021/9f39ed86/</url>
    
    <content type="html"><![CDATA[<p>关键词:</p><p>查看 Windows 10 快捷键 占用 VSCode 多行编辑 ctrl alt uparrow</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>VSCode 的多行编辑 ctrl + alt +uparrow 失效.<br>电脑环境:win10 19042.1387</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol><li><p>检查VSCode的快捷键设置,<img src="https://img-blog.csdnimg.cn/c85c8402840543d4a4b7afcf26e04bc0.png" alt="VSCode1"><br>看起来是没有问题的,</p></li><li><p>以前也遇到过这个情况当时是把VSCode重装后就好了看,这次试了试似乎并不行.</p></li><li><p>检查是不是其他软件占用了全局快捷键,搜索发现很多相关软件都失效不能用.</p><ul><li>PChunter <strong>很久没更新了不支持我的电脑的当前版本</strong></li><li>FindGlobalHotkey  <strong>无效</strong></li><li>spy++ <strong>太复杂,可能我不太会用也是没找到是不是什么按键占用了</strong></li><li><a href="https://www.zhihu.com/question/288316686/answer/1656650885">win10怎么查看快捷键是被什么占用了？</a></li><li><a href="https://github.com/BlackINT3/OpenArk">OpenArk </a> <strong>(最终解决方案)</strong></li></ul></li><li><p>github下载OpenArk后打开就能看到快捷键占用, 输入对应快捷键就可以筛选,<br><strong>最终找到万恶之源, 电脑插着耳机没有发现在播歌, 网易云关掉全局快捷键, 问题消失</strong><br><img src="/2021/9f39ed86/9b96c314b5994739a4db98c7d00c834b.png" alt="VSCode2"></p></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/BlackINT3/OpenArk">https://github.com/BlackINT3/OpenArk</a><br><img src="/2021/9f39ed86/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Li05rW355qE5Z-O,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="VSCode3"></p><h1 id="其他冲突的快捷键"><a href="#其他冲突的快捷键" class="headerlink" title="其他冲突的快捷键"></a>其他冲突的快捷键</h1><p>ctrl + shift + f 和微软的拼音输入法有冲突</p>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>vscode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021年12月6日_屠龙者终成恶龙</title>
    <link href="/2021/2d3de033/"/>
    <url>/2021/2d3de033/</url>
    
    <content type="html"><![CDATA[<p><img src="/2021/2d3de033/image-20220918233723182.png" alt="image-20220918233723182"></p><p>图：浦东张江晚上的雾霾</p><p>今晚从公司回家比较晚，已经有十点半了，回来的路上在天桥下看到一个阿姨推着电动车，上海冬天室外还是比较冷的，电动车自然续航也大打折扣了，待我走近看她骑得是专门载货的大号电动车，车上载着一个大纸壳箱子，看起来像是载着货物去哪儿，我从她身边经过的时候才看清她的脸，甚是忧愁，她还嘀咕了一句什么，估计发牢骚吧，靠近她之后我不知怎么的放慢了速度，尽量骑得慢一些了，我在犹豫要不要上去帮帮她的时候，我已经走出去好远，等我回头后面就只有她一个人推着车，奋力前行，载着货的电动车很大只，她看起来就显得有些弱小了，当我回过头的时候，就这样离开了，如果是以前的我肯定会上去帮忙的吧。屠龙少年终成恶龙。</p>]]></content>
    
    
    <categories>
      
      <category>life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>life</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WSL</title>
    <link href="/2021/784ee20b/"/>
    <url>/2021/784ee20b/</url>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>若要检查 Windows 版本及内部版本号，选择 Windows 徽标键 + R，然后键入“winver”，选择“确定”。更新到“设置”菜单中的<a href="ms-settings:windowsupdate">最新 Windows 版本</a>。</p><p><em><strong>IF</strong></em> (Windows 10 版本 2004 及更高版本（内部版本 19041 及更高版本）或 Windows 11)</p><p><a href="https://docs.microsoft.com/zh-cn/windows/wsl/install">一键自动安装 WSL</a></p><p><em><strong>ELSE</strong></em></p><p><a href="https://docs.microsoft.com/zh-cn/windows/wsl/install-manual">旧版 WSL 的手动安装步骤(可以更改WSL系统的存放位置)</a></p><h2 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h2><blockquote><p>   手动安装的优点是避免Linux的镜像文件(<code>ext4.vhdx</code>)存放在C盘, 存放<code>ext4.vhdx</code>的位置可以自定义.</p></blockquote><p>以下指令需要在<strong>管理员</strong>下的 powershell 运行</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 1 开启Microsoft-Windows-Subsystem-Linux</span><br>dism.exe <span class="hljs-regexp">/online /</span>enable-feature <span class="hljs-regexp">/featurename:Microsoft-Windows-Subsystem-Linux /</span>all /norestart<br><br><span class="hljs-comment"># 2 开启VirtualMachinePlatform</span><br>dism.exe <span class="hljs-regexp">/online /</span>enable-feature <span class="hljs-regexp">/featurename:VirtualMachinePlatform /</span>all /norestart<br><br><span class="hljs-comment"># 3 重启</span><br><span class="hljs-comment"># reboot</span><br><br><span class="hljs-comment"># 4 安装WLS2内核更新包</span><br>https:<span class="hljs-regexp">//</span>wslstorestorage.blob.core.windows.net<span class="hljs-regexp">/wslblob/</span>wsl_update_x64.msi<br><br><span class="hljs-comment"># 5 将WSL2设为默认</span><br>wsl --set-default-version <span class="hljs-number">2</span><br><br><span class="hljs-comment"># 6 下载离线包(可以避免将WSL的系统装在C盘)</span><br>https:<span class="hljs-regexp">//</span>docs.microsoft.com<span class="hljs-regexp">/zh-cn/</span>windows<span class="hljs-regexp">/wsl/i</span>nstall-manual<br><span class="hljs-comment"># example</span><br>https:<span class="hljs-regexp">//</span>aka.ms/wslubuntu2004<br>https:<span class="hljs-regexp">//</span>aka.ms/wsl-ubuntu-<span class="hljs-number">1804</span><br>https:<span class="hljs-regexp">//</span>aka.ms/wsl-debian-gnulinux<br><span class="hljs-comment"># 离线包下载完成后解压缩 运行目录内的ubuntu.exe</span><br><span class="hljs-comment"># 会提示输入用户名和密码</span><br><br><span class="hljs-comment"># 7 (可选)安装 windows终端</span><br>https:<span class="hljs-regexp">//</span>docs.microsoft.com<span class="hljs-regexp">/en-us/</span>windows<span class="hljs-regexp">/terminal/g</span>et-started 可选 <br></code></pre></td></tr></table></figure><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><h2 id="U盘挂载"><a href="#U盘挂载" class="headerlink" title="U盘挂载"></a>U盘挂载</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1 新建文件夹g</span><br>sudo mkdir /mnt/g<br><span class="hljs-meta prompt_"># </span><span class="language-bash">2 挂载盘符g</span><br>sudo mount -t drvfs g: /mnt/g<br><span class="hljs-meta prompt_"># </span><span class="language-bash">大功告成。进入/mnt/g即可操作</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">弹出移动硬盘，这样才能在windows下正常弹出，否则是会一直占用的。</span><br>sudo umount /mnt/g<br></code></pre></td></tr></table></figure><h2 id="映射wsl文件系统"><a href="#映射wsl文件系统" class="headerlink" title="映射wsl文件系统"></a>映射wsl文件系统</h2><p><img src="/2021/784ee20b/image-20211129131237501.png" alt="image-20211129131237501"></p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">\\wsl<span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure><p>通过 <code>\\wsl$</code> 访问 Linux 文件时将使用 WSL 分发版的默认用户。 因此，任何访问 Linux 文件的 Windows 应用都具有与默认用户相同的权限。</p><h2 id="wsl关机"><a href="#wsl关机" class="headerlink" title="wsl关机"></a>wsl关机</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wsl --shutdown<br></code></pre></td></tr></table></figure><h2 id="wsl-配置文件"><a href="#wsl-配置文件" class="headerlink" title="wsl 配置文件"></a>wsl 配置文件</h2><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># Settings apply across all Linux distros running on WSL 2</span><br><span class="hljs-section">[wsl2]</span><br><br><span class="hljs-comment"># Limits VM memory to use no more than 4 GB, this can be set as whole numbers using GB or MB</span><br><span class="hljs-attr">memory</span>=<span class="hljs-number">4</span>GB <br><br><span class="hljs-comment"># Sets the VM to use two virtual processors</span><br><span class="hljs-attr">processors</span>=<span class="hljs-number">2</span><br><br><span class="hljs-comment"># Specify a custom Linux kernel to use with your installed distros. The default kernel used can be found at https://github.com/microsoft/WSL2-Linux-Kernel</span><br><span class="hljs-attr">kernel</span>=C:\\temp\\myCustomKernel<br><br><span class="hljs-comment"># Sets additional kernel parameters, in this case enabling older Linux base images such as Centos 6</span><br><span class="hljs-attr">kernelCommandLine</span> = vsyscall=emulate<br><br><span class="hljs-comment"># Sets amount of swap storage space to 8GB, default is 25% of available RAM</span><br><span class="hljs-comment"># 虚拟内存</span><br><span class="hljs-attr">swap</span>=<span class="hljs-number">8</span>GB<br><br><span class="hljs-comment"># Sets swapfile path location, default is %USERPROFILE%\AppData\Local\Temp\swap.vhdx</span><br><span class="hljs-attr">swapfile</span>=C:\\temp\\wsl-swap.vhdx<br><br><span class="hljs-comment"># Disable page reporting so WSL retains all allocated memory claimed from Windows and releases none back when free</span><br><span class="hljs-attr">pageReporting</span>=<span class="hljs-literal">false</span><br><br><span class="hljs-comment"># Turn off default connection to bind WSL 2 localhost to Windows localhost</span><br><span class="hljs-attr">localhostforwarding</span>=<span class="hljs-literal">true</span><br><br><span class="hljs-comment"># Disables nested virtualization</span><br><span class="hljs-attr">nestedVirtualization</span>=<span class="hljs-literal">false</span><br><br><span class="hljs-comment"># Turns on output console showing contents of dmesg when opening a WSL 2 distro for debugging</span><br><span class="hljs-attr">debugConsole</span>=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>打开powershell输入<code>~</code>切换目录</p><p><code>code .wslconfig</code>编辑配置</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[wsl2]</span><br><span class="hljs-attr">memory</span>=<span class="hljs-number">2</span>GB<br><span class="hljs-attr">swap</span>=<span class="hljs-number">2</span>GB<br><span class="hljs-attr">localhostForwarding</span>=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h2 id="WSL-配置代理"><a href="#WSL-配置代理" class="headerlink" title="WSL 配置代理"></a>WSL 配置代理</h2><p><strong>获取主机 IP      主机 IP 保存在 &#x2F;etc&#x2F;resolv.conf 中</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> hostip=$(<span class="hljs-built_in">cat</span> /etc/resolv.conf |grep -oP <span class="hljs-string">&#x27;(?&lt;=nameserver\ ).*&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> https_proxy=<span class="hljs-string">&quot;http://<span class="hljs-variable">$&#123;hostip&#125;</span>:10881&quot;</span><br><span class="hljs-built_in">export</span> http_proxy=<span class="hljs-string">&quot;http://<span class="hljs-variable">$&#123;hostip&#125;</span>:10881&quot;</span><br><br><span class="hljs-built_in">export</span> http_proxy=<span class="hljs-string">&quot;socks5://<span class="hljs-variable">$&#123;hostip&#125;</span>:7890&quot;</span><br><span class="hljs-built_in">export</span> https_proxy=<span class="hljs-string">&quot;socks5://<span class="hljs-variable">$&#123;hostip&#125;</span>:7890&quot;</span><br><br><span class="hljs-built_in">export</span> all_proxy=<span class="hljs-string">&quot;socks5://<span class="hljs-variable">$&#123;hostip&#125;</span>:10880&quot;</span><br><span class="hljs-built_in">export</span> all_proxy=<span class="hljs-string">&quot;http://<span class="hljs-variable">$&#123;hostip&#125;</span>:10881&quot;</span><br></code></pre></td></tr></table></figure><ul><li>在wsl尝试用<code>export all_proxy</code>socks5做代理感觉总是调不通, 换成http就好了  不知道是为啥</li></ul><h2 id="wsl-conf-wslconfig配置文件"><a href="#wsl-conf-wslconfig配置文件" class="headerlink" title="wsl.conf .wslconfig配置文件"></a>wsl.conf .wslconfig配置文件</h2><p>参考文档:</p><p><a href="https://docs.microsoft.com/zh-cn/windows/wsl/wsl-config">WSL 中的高级设置配置</a></p><blockquote><h2 id="wsl-conf"><a href="#wsl-conf" class="headerlink" title="wsl.conf"></a>wsl.conf</h2><ul><li>以 <code>/etc</code> unix 文件的形式存储在分发目录中。</li><li>用于按分布配置设置。 此文件中配置的设置将仅应用于包含存储此文件的目录的特定 Linux 分发版。</li><li>可用于版本、WSL 1 或 WSL 2 运行的分发版。</li><li>若要访问已安装的发行版的 <code>/etc</code> 目录，请使用发行版的命令行和 <code>cd /</code> 访问根目录，然后使用 <code>ls</code> 列出文件或使用 <code>explorer.exe .</code> 在 Windows 文件资源管理器中查看。 目录路径应如下所示： <code>/etc/wsl.conf</code></li></ul><h2 id="wslconfig"><a href="#wslconfig" class="headerlink" title=".wslconfig"></a>.wslconfig</h2><ul><li>存储在目录中 <code>%UserProfile%</code> 。</li><li>用于跨作为 WSL 2 版本运行的所有已安装 Linux 分发版全局配置设置。</li><li><strong>只能用于 WSL 2 运行的分发</strong>版。 作为 WSL 1 运行的分发版不会受到此配置的影响，因为它们未作为虚拟机运行。</li><li>要访问 <code>%UserProfile%</code> 目录，请在 PowerShell 中使用 <code>cd ~</code> 访问主目录（通常是用户配置文件 <code>C:\Users\&lt;UserName&gt;</code>），或者可以打开 Windows 文件资源管理器并在地址栏中输入 <code>%UserProfile%</code>。 目录路径应如下所示： <code>C:\Users\&lt;UserName&gt;\.wslconfig</code></li></ul></blockquote><h3 id="wsl-conf-的配置-unix"><a href="#wsl-conf-的配置-unix" class="headerlink" title="wsl.conf 的配置 (unix )"></a>wsl.conf 的配置 (unix )</h3><p>wsl.conf 文件支持四个部分：<code>automount</code>、<code>network</code>、<code>interop</code>、<code>user</code> 、<code>[boot]</code>。 </p><p><strong>配置文件示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Automatically mount Windows drive when the distribution is launched</span><br>[automount]<br><br><span class="hljs-comment"># Set to true will automount fixed drives (C:/ or D:/) with DrvFs under the root directory set above. Set to false means drives won&#x27;t be mounted automatically, but need to be mounted manually or with fstab.</span><br>enabled = <span class="hljs-literal">true</span><br><br><span class="hljs-comment"># Sets the directory where fixed drives will be automatically mounted. This example changes the mount location, so your C-drive would be /c, rather than the default /mnt/c. </span><br>root = /<br><br><span class="hljs-comment"># DrvFs-specific options can be specified.  </span><br>options = <span class="hljs-string">&quot;metadata,uid=1003,gid=1003,umask=077,fmask=11,case=off&quot;</span><br><br><span class="hljs-comment"># Sets the `/etc/fstab` file to be processed when a WSL distribution is launched.</span><br>mountFsTab = <span class="hljs-literal">true</span><br><br><span class="hljs-comment"># Network host settings that enable the DNS server used by WSL 2. This example changes the hostname, sets generateHosts to false, preventing WSL from the default behavior of auto-generating /etc/hosts, and sets generateResolvConf to false, preventing WSL from auto-generating /etc/resolv.conf, so that you can create your own (ie. nameserver 1.1.1.1).</span><br>[network]<br>hostname = DemoHost<br>generateHosts = <span class="hljs-literal">false</span><br>generateResolvConf = <span class="hljs-literal">false</span><br><br><span class="hljs-comment"># Set whether WSL supports interop process like launching Windows apps and adding path variables. Setting these to false will block the launch of Windows processes and block adding $PATH environment variables.</span><br>[interop]<br>enabled = <span class="hljs-literal">false</span><br>appendWindowsPath = <span class="hljs-literal">false</span><br><br><span class="hljs-comment"># Set the user when launching a distribution with WSL.</span><br>[user]<br>default = DemoUser<br><br><span class="hljs-comment"># Set a command to run when a new WSL instance launches. This example starts the Docker container service.</span><br>[boot]<br><span class="hljs-built_in">command</span> = service docker start<br></code></pre></td></tr></table></figure><h4 id="自动装载设置-automount"><a href="#自动装载设置-automount" class="headerlink" title="自动装载设置 automount"></a>自动装载设置 automount</h4><p>节标签：<code>[automount]</code></p><table><thead><tr><th align="left">key</th><th align="left">值</th><th align="left">default</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">enabled</td><td align="left">boolean</td><td align="left">是</td><td align="left"><code>true</code> 导致固定驱动器（即 <code>C:/</code> 或 <code>D:/</code>）自动装载到 DrvFs 中的 <code>/mnt</code> 下。 <code>false</code> 表示驱动器不会自动装载，但你仍可以手动或通过 <code>fstab</code> 装载驱动器。</td></tr><tr><td align="left">mountFsTab</td><td align="left">boolean</td><td align="left">是</td><td align="left"><code>true</code> 设置启动 WSL 时要处理的 <code>/etc/fstab</code>。 &#x2F;etc&#x2F;fstab 是可在其中声明其他文件系统的文件，类似于 SMB 共享。 因此，在启动时，可以在 WSL 中自动装载这些文件系统。</td></tr><tr><td align="left">root</td><td align="left">string</td><td align="left"><code>/mnt/</code></td><td align="left">设置固定驱动器要自动装载到的目录。 默认情况下，此设置设置为 <code>/mnt/</code>，因此 Windows 文件系统 C 驱动器已装载到 <code>/mnt/c/</code>。 如果更改为<code>/mnt/``/windir/</code>，应会看到已装载到<code>/windir/c</code>的固定 C 驱动器。</td></tr><tr><td align="left">选项</td><td align="left">逗号分隔的值列表，例如 uid、gid 等，请参阅下面的自动装载选项</td><td align="left">空字符串</td><td align="left">下面列出了自动装载选项值，并追加到默认 DrvFs 装载选项字符串。 <strong>只能指定特定于 DrvFs 的选项。</strong></td></tr></tbody></table><h4 id="网络设置-network"><a href="#网络设置-network" class="headerlink" title="网络设置 network"></a>网络设置 network</h4><p>节标签：<code>[network]</code></p><table><thead><tr><th align="left">key</th><th align="left">值</th><th align="left">default</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">generateHosts</td><td align="left">boolean</td><td align="left"><code>true</code></td><td align="left"><code>true</code> 将 WSL 设置为生成 <code>/etc/hosts</code>。 <code>hosts</code> 文件包含主机名对应的 IP 地址的静态映射。</td></tr><tr><td align="left">generateResolvConf</td><td align="left">boolean</td><td align="left"><code>true</code></td><td align="left"><code>true</code> 将 WSL 设置为生成 <code>/etc/resolv.conf</code>。 <code>resolv.conf</code> 包含能够将给定主机名解析为其 IP 地址的 DNS 列表。</td></tr><tr><td align="left">hostname</td><td align="left">string</td><td align="left">Windows 主机名</td><td align="left">设置要用于 WSL 分发的主机名。</td></tr></tbody></table><h4 id="互操作设置-interop"><a href="#互操作设置-interop" class="headerlink" title="互操作设置 interop"></a>互操作设置 interop</h4><p>节标签：<code>[interop]</code></p><p>这些选项在预览体验成员内部版本 17713 和更高版本中可用。</p><table><thead><tr><th align="left">key</th><th align="left">值</th><th align="left">default</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">enabled</td><td align="left">boolean</td><td align="left"><code>true</code></td><td align="left">设置此键可确定 WSL 是否支持启动 Windows 进程。</td></tr><tr><td align="left">appendWindowsPath</td><td align="left">boolean</td><td align="left"><code>true</code></td><td align="left">设置此键可确定 WSL 是否会将 Windows 路径元素添加到 $PATH 环境变量。</td></tr></tbody></table><h4 id="用户设置-user"><a href="#用户设置-user" class="headerlink" title="用户设置 user"></a>用户设置 user</h4><p>节标签：<code>[user]</code></p><p>这些选项在版本 18980 及更高版本中可用。</p><table><thead><tr><th align="left">key</th><th align="left">值</th><th align="left">default</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">default</td><td align="left">字符串</td><td align="left">首次运行时创建的初始用户名</td><td align="left">设置此键指定在首次启动 WSL 会话时以哪个用户身份运行。</td></tr></tbody></table><h4 id="启动设置-boot"><a href="#启动设置-boot" class="headerlink" title="启动设置 boot"></a>启动设置 boot</h4><p>启动设置仅适用于 Windows 11 和 Server 2022。</p><p>节标签：<code>[boot]</code></p><table><thead><tr><th align="left">key</th><th align="left">值</th><th align="left">default</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">命令</td><td align="left">string</td><td align="left">“”</td><td align="left">你希望在 WSL 实例启动时运行的命令字符串。 此命令以根用户身份运行。 例如： <code>service docker start</code></td></tr></tbody></table><h3 id="wslconfig-的配置-windows"><a href="#wslconfig-的配置-windows" class="headerlink" title=".wslconfig 的配置 (windows)"></a>.wslconfig 的配置 (windows)</h3><blockquote><p>  全局 <code>.wslconfig</code> 配置选项仅适用于在 Windows 内部版本 19041 及更高版本中作为 WSL 2 运行的分发版。 请记住，可能需要运行 <code>wsl --shutdown</code> 来关闭 WSL 2 VM，然后重启 WSL 实例以使这些更改生效。</p></blockquote><p><strong>配置文件示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Settings apply across all Linux distros running on WSL 2</span><br>[wsl2]<br><br><span class="hljs-comment"># Limits VM memory to use no more than 4 GB, this can be set as whole numbers using GB or MB</span><br>memory=4GB <br><br><span class="hljs-comment"># Sets the VM to use two virtual processors</span><br>processors=2<br><br><span class="hljs-comment"># Specify a custom Linux kernel to use with your installed distros. The default kernel used can be found at https://github.com/microsoft/WSL2-Linux-Kernel</span><br>kernel=C:\\temp\\myCustomKernel<br><br><span class="hljs-comment"># Sets additional kernel parameters, in this case enabling older Linux base images such as Centos 6</span><br>kernelCommandLine = vsyscall=<span class="hljs-built_in">emulate</span><br><br><span class="hljs-comment"># Sets amount of swap storage space to 8GB, default is 25% of available RAM</span><br>swap=8GB<br><br><span class="hljs-comment"># Sets swapfile path location, default is %USERPROFILE%\AppData\Local\Temp\swap.vhdx</span><br>swapfile=C:\\temp\\wsl-swap.vhdx<br><br><span class="hljs-comment"># Disable page reporting so WSL retains all allocated memory claimed from Windows and releases none back when free</span><br>pageReporting=<span class="hljs-literal">false</span><br><br><span class="hljs-comment"># Turn off default connection to bind WSL 2 localhost to Windows localhost</span><br>localhostforwarding=<span class="hljs-literal">true</span><br><br><span class="hljs-comment"># Disables nested virtualization</span><br>nestedVirtualization=<span class="hljs-literal">false</span><br><br><span class="hljs-comment"># Turns on output console showing contents of dmesg when opening a WSL 2 distro for debugging</span><br>debugConsole=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>节标签：<code>[wsl2]</code></p><table><thead><tr><th align="left">key</th><th align="left">值</th><th align="left">default</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">内核 (kernel)</td><td align="left">字符串</td><td align="left">Microsoft 内置内核提供的收件箱</td><td align="left">自定义 Linux 内核的绝对 Windows 路径。</td></tr><tr><td align="left">内存</td><td align="left">大小</td><td align="left">Windows 上总内存的 50% 或 8GB，以较小者为准；在 20175 之前的版本上：Windows 上总内存的 80%</td><td align="left">要分配给 WSL 2 VM 的内存量。</td></tr><tr><td align="left">处理器</td><td align="left">数字</td><td align="left">Windows 上相同数量的处理器</td><td align="left">要分配给 WSL 2 VM 的处理器数量。</td></tr><tr><td align="left">localhostForwarding</td><td align="left">boolean</td><td align="left"><code>true</code></td><td align="left">一个布尔值，用于指定绑定到 WSL 2 VM 中的通配符或 localhost 的端口是否应可通过 <code>localhost:port</code> 从主机连接。</td></tr><tr><td align="left">kernelCommandLine</td><td align="left">字符串</td><td align="left">空白</td><td align="left">其他内核命令行参数。</td></tr><tr><td align="left">swap</td><td align="left">大小</td><td align="left">Windows 上 25% 的内存大小四舍五入到最接近的 GB</td><td align="left">要向 WSL 2 VM 添加的交换空间量，0 表示无交换文件。 交换存储是基于磁盘的 RAM，当内存需求超过硬件设备的限制时使用。</td></tr><tr><td align="left">swapFile</td><td align="left">字符串</td><td align="left"><code>%USERPROFILE%\AppData\Local\Temp\swap.vhdx</code></td><td align="left">交换虚拟硬盘的绝对 Windows 路径。</td></tr><tr><td align="left">pageReporting</td><td align="left">boolean</td><td align="left"><code>true</code></td><td align="left">默认设置 <code>true</code> 使 Windows 能够回收分配给 WSL 2 虚拟机的未使用的内存。</td></tr><tr><td align="left">guiApplications</td><td align="left">boolean*</td><td align="left"><code>true</code></td><td align="left">一个布尔值，用于在 WSL 中打开或关闭对 GUI 应用程序 (<a href="https://github.com/microsoft/wslg">WSLg</a>) 的支持。 仅适用于Windows 11。</td></tr><tr><td align="left">debugConsole</td><td align="left">boolean*</td><td align="left"><code>false</code></td><td align="left">一个布尔值，用于在 WSL 2 发行版实例启动时打开显示 <code>dmesg</code> 内容的输出控制台窗口。 仅适用于Windows 11。</td></tr><tr><td align="left">nestedVirtualization</td><td align="left">boolean*</td><td align="left"><code>true</code></td><td align="left">用于打开或关闭嵌套虚拟化的布尔值，使其他嵌套 VM 能够在 WSL 2 中运行。 仅适用于Windows 11。</td></tr><tr><td align="left">vmIdleTimeout</td><td align="left">number*</td><td align="left"><code>60000</code></td><td align="left">VM 在关闭之前处于空闲状态的毫秒数。 仅适用于Windows 11。</td></tr></tbody></table><p>具有 <code>path</code> 值的条目必须是带有转义反斜杠的 Windows 路径，例如：<code>C:\\Temp\\myCustomKernel</code></p><p>具有 <code>size</code> 值的条目必须是后跟单位的大小，例如 <code>8GB</code> 或 <code>512MB</code>。</p><p>值类型后具有 * 的条目仅在Windows 11可用。</p><h2 id="WSL导出与迁移"><a href="#WSL导出与迁移" class="headerlink" title="WSL导出与迁移"></a>WSL导出与迁移</h2><blockquote><p>   我们可以选择手动安装wsl, 这样我们可以避免将wsl安装在c盘, 手动安装的时候, 将下载下来的<code>&lt;distro&gt;.appx</code>文件直接解压, 例如将<code>Ubuntu_1604.2019.523.0_x64.appx</code>解压, 解压出来的文件夹内就包含了<code>ubuntu1604.exe</code>, 运行他就可以启动wsl, 这样可以避免wsl的迁移.</p></blockquote><p><strong>查看WSL分发版本</strong></p><p>在<code>Windows PowerShell</code>中输入如下命令, 查看当前子系统的状态和版本信息.</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">wsl -l <span class="hljs-comment">--all  -v</span><br></code></pre></td></tr></table></figure><p>结果如下:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">  NAME      STATE           <span class="hljs-keyword">VERSION</span><br>* Ubuntu    Running         <span class="hljs-number">2</span><br>  Debian    <span class="hljs-literal">Stopped</span>         <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>导出分发版为tar文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">递归创建文件夹</span><br>mkdir -p d:\system\wsl\ubuntu20.04\<br><span class="hljs-meta prompt_"># </span><span class="language-bash">进入文件夹</span><br>cd d:\system\wsl\ubuntu20.04\<br><span class="hljs-meta prompt_"># </span><span class="language-bash">导出tar包 到当前目录</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">(如果显示的子系统的`NAME`是带有版本号的话需要注意的是这里第二个参数就要带上参数, 例如`Ubuntu-20.04`)</span><br>wsl --export Ubuntu .\ubuntu20.04.tar<br></code></pre></td></tr></table></figure><blockquote>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">--export &lt;发行版&gt; &lt;FileName&gt; [选项]<br>        将发行版导出为 tar 文件。<br>        对于标准输出，文件名可以为 -。<br><br>        选项:<br>            --vhd<br>                指定该发行版应导出为 .vhdx 文件。<br></code></pre></td></tr></table></figure></blockquote><p><strong>注销当前分发版</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wsl --unregister Ubuntu<br></code></pre></td></tr></table></figure><p><strong>重新导入并安装WSL</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wsl --import Ubuntu .\ .\ubuntu20.04.tar --version 2<br></code></pre></td></tr></table></figure><blockquote>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">--import &lt;发行版&gt; &lt;InstallLocation&gt; &lt;FileName&gt; [选项]<br>        将指定的 tar 文件作为新发行版导入。<br>        对于标准输入，文件名可以为 -。<br><br>        选项:<br>            --version &lt;版本&gt;<br>                指定新发行版要使用的版本。<br><br>            --vhd<br>                指定提供的文件是 .vhdx 文件，而不是 tar 文件。<br>                此操作会在指定的安装位置复制 .vhdx 文件。<br></code></pre></td></tr></table></figure></blockquote><p><strong>设置默认登陆用户为安装时用户名</strong></p><blockquote><p>  (如果显示的子系统的<code>NAME</code>是带有版本号的话需要注意的是这里第二个参数就要带上参数, 例如<code>Ubuntu-20.04</code>)</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ubuntu config --default-user Username<br></code></pre></td></tr></table></figure><p><strong>删除tar文件(可选)</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm .\ubuntu20.04.tar<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>linux</tag>
      
      <tag>wsl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手动添加JLink不支持的芯片</title>
    <link href="/2021/30f8332a/"/>
    <url>/2021/30f8332a/</url>
    
    <content type="html"><![CDATA[<h1 id="手动添加JLink不支持的芯片"><a href="#手动添加JLink不支持的芯片" class="headerlink" title="手动添加JLink不支持的芯片"></a>手动添加JLink不支持的芯片</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>市场上的新芯片层出不穷，JLink的官方支持不可能完全跟得上，这就尴尬了。但是好在Segger在设计时就想到了这一点，允许用户自己添加新芯片或扩展官方已经支持的芯片。本文只讲如何添加新芯片，参考的资料为<code>UM08001_JLink.pdf</code>中的第12章——<code>Open Flashloader</code>。</p><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p>在添加前，JFlash里找不到BARROT的任何型号，</p><p>添加后如下图</p><p><img src="/2021/30f8332a/image-20211019164827957.png" alt="image-20211019164827957"></p><h2 id="添加方法"><a href="#添加方法" class="headerlink" title="添加方法"></a>添加方法</h2><ul><li><p>找到Jlink安装目录下的<code>JLinkDevices.xml</code>并打开；</p></li><li><p>默认位置<code>C:\Program Files\SEGGER\JLink</code></p><p>在打开的文件添加如下内容，因为这个文件里没有任何BARROT的芯片，所以我添加到文件末尾，如果文件已经有同厂家的其它芯片，建议还是放一起，方便维护。效果和代码放下面了，代码的解释在后面！</p><p><img src="/2021/30f8332a/image-20211019164859196.png" alt="image-20211019164859196"></p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--                  --&gt;</span><br><span class="hljs-comment">&lt;!-- BARROT (BR8551) --&gt;</span><br><span class="hljs-comment">&lt;!--                  --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Device</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">ChipInfo</span> <span class="hljs-attr">Vendor</span>=<span class="hljs-string">&quot;BARROT&quot;</span> <span class="hljs-attr">Name</span>=<span class="hljs-string">&quot;BR8551&quot;</span> <span class="hljs-attr">Core</span>=<span class="hljs-string">&quot;JLINK_CORE_CORTEX_M3&quot;</span> <span class="hljs-attr">WorkRAMAddr</span>=<span class="hljs-string">&quot;0x2000C000&quot;</span> <span class="hljs-attr">WorkRAMSize</span>=<span class="hljs-string">&quot;0x00004000&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">FlashBankInfo</span> <span class="hljs-attr">Name</span>=<span class="hljs-string">&quot;ROM&quot;</span> <span class="hljs-attr">BaseAddr</span>=<span class="hljs-string">&quot;0x00000000&quot;</span> <span class="hljs-attr">MaxSize</span>=<span class="hljs-string">&quot;0x00060000&quot;</span> <span class="hljs-attr">Loader</span>=<span class="hljs-string">&quot;D:\\Project\\Panda\\Code\\bamboo\\panda\\tools\\Keil\\VFlash.FLM&quot;</span> <span class="hljs-attr">LoaderType</span>=<span class="hljs-string">&quot;FLASH_ALGO_TYPE_OPEN&quot;</span> <span class="hljs-attr">AlwaysPresent</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">FlashBankInfo</span> <span class="hljs-attr">Name</span>=<span class="hljs-string">&quot;LR_IROM1&quot;</span> <span class="hljs-attr">BaseAddr</span>=<span class="hljs-string">&quot;0x10000000&quot;</span> <span class="hljs-attr">MaxSize</span>=<span class="hljs-string">&quot;0x00080000&quot;</span> <span class="hljs-attr">Loader</span>=<span class="hljs-string">&quot;D:\\Project\\Panda\\Code\\bamboo\\panda\\tools\\Keil\\VFlash.FLM&quot;</span> <span class="hljs-attr">LoaderType</span>=<span class="hljs-string">&quot;FLASH_ALGO_TYPE_OPEN&quot;</span> <span class="hljs-attr">AlwaysPresent</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Device</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>保存文件就添加完了，可以验证是否如文章开头的效果一样</li></ul></li></ul><h2 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h2><ul><li>最开始的三行是注释，注释嘛，随便写了，清晰明了就行；</li><li><code>&lt;Device&gt;</code>和<code>&lt;/Device&gt;</code>必须成对出现，而且没有属性表。每个（系列）芯片都对应着这么一对。</li><li><code>ChipInfo</code>是描述芯片的信息，必须在 <code>&lt;Device&gt;</code>和<code>&lt;/Device&gt;</code>内。</li></ul><table><thead><tr><th align="center">参数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Vendor</td><td align="center">芯片厂家的名字，比如这里的”BARROT”</td></tr><tr><td align="center">Name</td><td align="center">芯片的具体型号，我用的就是BR8551</td></tr><tr><td align="center">Core</td><td align="center">芯片的内核，这个必须是JLink支持的内核之一，具体的名字可以在文档里的12.5.3.1    Attribute values - Core章节找到。</td></tr><tr><td align="center">WorkRAMAddr</td><td align="center">芯片RAM的起始地址，这个可以在用户手册里找到，也可以打开SDK里的官方例程，然后在工程配置里找到</td></tr><tr><td align="center">WorkRAMSize</td><td align="center">芯片RAM的大小，同样可以在用户手册里找到，也可以打开SDK里的官方例程，然后在工程配置里找到</td></tr><tr><td align="center">Aliases</td><td align="center">同系列的相同RAM和FLASH的型号</td></tr><tr><td align="center">JLinkScriptFile</td><td align="center">高级用法，有些芯片操作比较特殊，可以通过脚本去实现，这里我用不上</td></tr></tbody></table><hr><ul><li><code>FlashBankInfo</code>描述芯片的Flash信息，有多块flash的话，每块对应一个<code>FlashBankInfo</code>。</li></ul><table><thead><tr><th align="center">参数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Name</td><td align="center">flash的名字，名字可以随便起</td></tr><tr><td align="center">BaseAddr</td><td align="center">flash的起始地址，可以在用户手册里找到</td></tr><tr><td align="center">MaxSize</td><td align="center">flash的大小，可以在用户手册里找到</td></tr><tr><td align="center">Loader</td><td align="center">烧录的算法，segger官方的是*.elf格式，*.flm是ARM的格式，keil里就用这个。这个路径可以是绝对地址也可以是相对地址，相对地址的话是从<code>JLinkDevices.xml</code>所在的路径为起始地址。</td></tr><tr><td align="center">LoaderType</td><td align="center">必须是12.5.4.1    Attribute values - LoaderType中列出的类型之一，目前只有FLASH_ALGO_TYPE_OPEN一个类型，而*.flm是支持这个类型的</td></tr><tr><td align="center">AlwaysPresent</td><td align="center">指示这个块flash是不是一直存在，本文是内部flash，当然一直存在</td></tr></tbody></table><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/d7fae221ac47">工欲善其事，必先利其器：动手给JLink添加官方不支持的芯片</a></p>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>j-link</tag>
      
      <tag>jlink</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CAD</title>
    <link href="/2021/154e1146/"/>
    <url>/2021/154e1146/</url>
    
    <content type="html"><![CDATA[<h1 id="CAD"><a href="#CAD" class="headerlink" title="CAD"></a>CAD</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul><li><p>对象捕捉：端点、中点、圆心、、、、、</p></li><li></li><li><p>shift正交</p></li><li><p>shift按住，取消选择</p></li><li><p>连续画直线，空格取消</p></li><li><p>画直线，c键闭合</p></li></ul><h1 id="形状"><a href="#形状" class="headerlink" title="形状"></a>形状</h1><h2 id="直线"><a href="#直线" class="headerlink" title="直线"></a>直线</h2><p>L键</p><h2 id="圆"><a href="#圆" class="headerlink" title="圆"></a>圆</h2><p>C键</p><h3 id="圆心-半径"><a href="#圆心-半径" class="headerlink" title="圆心 半径"></a>圆心 半径</h3><p>D键切换成直径</p><h3 id="两点"><a href="#两点" class="headerlink" title="两点"></a>两点</h3><h3 id="三点"><a href="#三点" class="headerlink" title="三点"></a>三点</h3><h3 id="相切-相切-半径"><a href="#相切-相切-半径" class="headerlink" title="相切 相切 半径"></a>相切 相切 半径</h3><h3 id="相切-相切-相切"><a href="#相切-相切-相切" class="headerlink" title="相切 相切 相切"></a>相切 相切 相切</h3><p>快捷键不详</p><h2 id="圆弧"><a href="#圆弧" class="headerlink" title="圆弧"></a>圆弧</h2><p>ARC键</p><p>逆时针画圆弧</p><h2 id="多段线"><a href="#多段线" class="headerlink" title="多段线"></a>多段线</h2><p>PLI键</p><ul><li>可以赋予宽度</li></ul><h3 id="合并多段线"><a href="#合并多段线" class="headerlink" title="合并多段线"></a>合并多段线</h3><ol><li>PE (pedit 多段线编辑)</li><li>m 选择多段线</li><li>选中后空格确认</li><li>y 转换</li><li>j 合并</li><li></li></ol><h2 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h2><h2 id="多边形"><a href="#多边形" class="headerlink" title="多边形"></a>多边形</h2><p>POL 键</p><h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><h2 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h2><p>m 键 move</p><h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>co </p><h2 id="拉伸"><a href="#拉伸" class="headerlink" title="拉伸"></a>拉伸</h2><p>s</p><h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>ro </p><ul><li>起点开始 逆时针</li><li>c 复制，原来的保留并复制</li><li>r 参照，参照线旋转</li></ul><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p>mi</p><h2 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h2><p>sc</p><ul><li>r参照，参照边长缩放</li></ul><h2 id="对齐缩放"><a href="#对齐缩放" class="headerlink" title="对齐缩放"></a>对齐缩放</h2><p>al</p><ul><li>根据边对齐，根据边长缩放</li></ul><h2 id="修剪"><a href="#修剪" class="headerlink" title="修剪"></a>修剪</h2><p>tr</p><ul><li>不选基线默认修剪</li></ul><h2 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h2><p>ex</p><ul><li>不选基线默认延伸</li></ul><h2 id="倒角"><a href="#倒角" class="headerlink" title="倒角"></a>倒角</h2><p>cha</p><h2 id="圆角"><a href="#圆角" class="headerlink" title="圆角"></a>圆角</h2><p>f</p><h2 id="光顺曲线"><a href="#光顺曲线" class="headerlink" title="光顺曲线"></a>光顺曲线</h2><p>两个曲线光滑连接</p><h2 id="矩形阵列"><a href="#矩形阵列" class="headerlink" title="矩形阵列"></a>矩形阵列</h2><h2 id="路径阵列"><a href="#路径阵列" class="headerlink" title="路径阵列"></a>路径阵列</h2><h2 id="圆形阵列"><a href="#圆形阵列" class="headerlink" title="圆形阵列"></a>圆形阵列</h2><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><h2 id="修改注释标准-gt"><a href="#修改注释标准-gt" class="headerlink" title="修改注释标准 (,-&gt;.)"></a>修改注释标准 (,-&gt;.)</h2><p>标注样式-&gt;修改-&gt;主单位-&gt;逗号改成点号</p><h2 id="空心字-文字转换成线"><a href="#空心字-文字转换成线" class="headerlink" title="空心字 文字转换成线"></a>空心字 文字转换成线</h2><p><strong>注意：</strong>安装默认不安装拓展工具，如果txtexp找不到命令，需要重装，安装的时候选择组件的时候选上Express Tools。</p><ol><li>mt 创建文字</li><li>txtexp 将文字分解成文字轮廓</li></ol>]]></content>
    
    
    <categories>
      
      <category>more_interest</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cad</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PC Hardware</title>
    <link href="/2021/86880617/"/>
    <url>/2021/86880617/</url>
    
    <content type="html"><![CDATA[<h1 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h1><h2 id="ITX-主板的孔位图"><a href="#ITX-主板的孔位图" class="headerlink" title="ITX 主板的孔位图"></a>ITX 主板的孔位图</h2><p>括号中的数值单位是mm，下面的数值单位是inch。</p><p><img src="/2021/86880617/v2-adfa6cb86a379f8ea31c62416c3a9b93_720w.jpg" alt="img"></p><h2 id="ATX-孔位图"><a href="#ATX-孔位图" class="headerlink" title="ATX 孔位图"></a>ATX 孔位图</h2><p>数值单位是inch</p><p><img src="/2021/86880617/v2-19cb957be912ef88b779a7ed04de4eaf_720w.jpg" alt="img"></p><h1 id="DISK"><a href="#DISK" class="headerlink" title="DISK"></a>DISK</h1><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.snia.org/technology-communities/sff/specifications">SNIA协会定义</a></li><li>SFF-8301 (3.5” Form Factor Drive Dimensions)</li><li>SFF-8201 (2.5” Form Factor Drive Dimensions)</li></ul><h2 id="2-5”"><a href="#2-5”" class="headerlink" title="2.5”"></a>2.5”</h2><p>定义于SFF-8201, 长度为101.85mm (max), 宽度为69.85，厚度有不同规格，从5mm到19.05mm不等。常用的笔记本硬盘是7mm厚度，企业级硬盘是15mm，螺丝孔为公制M3标准。</p><p><img src="/2021/86880617/image-20211026113925717.png" alt="image-20211026113925717"></p><p><img src="/2021/86880617/image-20211026113951361.png" alt="image-20211026113951361"></p><p><img src="/2021/86880617/image-20211026114009000.png" alt="image-20211026114009000"></p><p><img src="/2021/86880617/image-20211026114023653.png" alt="image-20211026114023653"></p><h2 id="3-5”"><a href="#3-5”" class="headerlink" title="3.5”"></a>3.5”</h2><p>定义于SFF-8301,长度为147.00mm, 宽度为101.60mm，厚度有不同规格：17.80-42.00mm。通常硬盘的厚度都是小于26.10mm，螺丝孔为6-32 UNC-2B英制标准，公制M3.5也能凑合用。</p><p><img src="/2021/86880617/image-20211026114433027.png" alt="image-20211026114433027"></p><p><img src="/2021/86880617/image-20211026114447507.png" alt="image-20211026114447507"></p><h1 id="Lenovo-私有定义"><a href="#Lenovo-私有定义" class="headerlink" title="Lenovo 私有定义"></a>Lenovo 私有定义</h1><h2 id="主板-1"><a href="#主板-1" class="headerlink" title="主板"></a>主板</h2><h3 id="USB2-0-接口"><a href="#USB2-0-接口" class="headerlink" title="USB2.0 接口"></a>USB2.0 接口</h3><p><img src="/2021/86880617/image-20211026120339401.png" alt="image-20211026120339401"></p><p><img src="/2021/86880617/image-20211026120205476.png" alt="image-20211026120205476"></p><h3 id="F-PANEL"><a href="#F-PANEL" class="headerlink" title="F_PANEL"></a>F_PANEL</h3><p><img src="/2021/86880617/image-20211026120411691.png" alt="image-20211026120411691"></p><p><img src="/2021/86880617/image-20211026120130016.png" alt="image-20211026120130016"></p>]]></content>
    
    
    <categories>
      
      <category>more_interest</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hardware</tag>
      
      <tag>pc</tag>
      
      <tag>lenovo</tag>
      
      <tag>disk</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Synology 群晖</title>
    <link href="/2021/ee60585b/"/>
    <url>/2021/ee60585b/</url>
    
    <content type="html"><![CDATA[<h1 id="群晖"><a href="#群晖" class="headerlink" title="群晖"></a>群晖</h1><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="资源及参考链接"><a href="#资源及参考链接" class="headerlink" title="资源及参考链接"></a>资源及参考链接</h2><p><a href="https://www.openos.org/threads/dsm-6-2-3-2020-12-27.29/">https://www.openos.org/threads/dsm-6-2-3-2020-12-27.29/</a></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li><p><strong>引导系统装哪里？</strong><br>非常关键的问题，DSM采用系统和数据相分离的结构，也就是说引导系统需要独立安装在一个设备上，通常是U盘&#x2F;SD&#x2F;TF卡、或者SSD硬盘上。数据需要额外安装独立的硬盘上。</p></li><li><p><strong>引导系统安装盘 (U盘&#x2F;USB flash drive&#x2F;随身碟)</strong><br>无论是U盘还是TF卡，其实128MB或以上就足够了，USB 2.0&#x2F;3.0都可以。</p></li><li><p><strong>数据存储硬盘 (硬盘)</strong><br>机械硬盘或者固态硬盘都可以，这个没有限制，容量当然越大越好。</p></li><li><p>一般来说安装黑群晖至少需要两个文件, 一个是黑群晖的引导文件, 一个是群晖DSM的系统文件.</p></li></ul><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><blockquote><p>  黑群晖系统: DSM 6.2.0–6.2.3<br>  引导版本: 1.04b (首选推荐版本)<br>  针对机型: DS918+<br>  引导方式: 传统BIOS和UEFI<br>  引导下载地址<br>  <a href="https://www.openos.org/downloads/synology-dsm-6-2-1-loader-v1-04b.15/">https://www.openos.org/downloads/synology-dsm-6-2-1-loader-v1-04b.15/</a></p><p>  DS918+ DSM 6.2.3-25426 Update2 系统<br>  <a href="https://global.download.synology.com/download/DSM/release/6.2.3/25426/DSM_DS918+_25426.pat">https://global.download.synology.com/download/DSM/release/6.2.3/25426/DSM_DS918+_25426.pat</a></p><p>  其他DSM系统版本请看这里<br>  <a href="https://archive.synology.com/download">https://archive.synology.com/download</a></p></blockquote><ol><li><p>下载群晖的引导文件, 推荐下载<code>v1.04b.for.dms.6.2.1.synoboot-ds918.zip</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">http://down.nas2x.com/synology/dsm/6.2/synoboot/<br><span class="hljs-comment"># 里面有三个文件</span><br>dsm.6.2.synoboot_ds3615xs.1.03b.zip                02-Aug-2018 10:43     17M<br>dsm.6.2.synoboot_ds3617xs.1.03b.zip                02-Aug-2018 10:42     20M<br>v1.04b.for.dms.6.2.1.synoboot-ds918.zip            25-Jan-2019 18:30     21M<br></code></pre></td></tr></table></figure></li><li><p>下载群晖的系统, 根据上面的引导下载系统, 上面选的是<code>DS918+</code>的话, 这里下载<code>DS918+</code>就好.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># DS918+</span><br>https://global.download.synology.com/download/DSM/release/6.2.3/25426/DSM_DS918+_25426.pat<br><span class="hljs-comment"># 其他DSM系统</span><br>https://archive.synology.com/download<br></code></pre></td></tr></table></figure></li><li><p>修改引导程序配置文件,</p><p>使用<code>ChipEasy</code>或者<code>ChipGenius</code>查找到U盘的VID和PID。</p><p>以下图为例，这个U盘的VID是0930，PID是6544。</p><p><strong>请记录好这两个值。下面修改配置文件需要用到。</strong></p><p><img src="/2021/ee60585b/07.png" alt="[IMG]"></p></li><li><p>编辑配置文件grub.cfg.</p><p>打开DiskGenius, 在顶部选择硬盘-打开虚拟硬盘文件, 选择刚刚下载的<code>.img</code>引导文件并打开.</p><p><img src="/2021/ee60585b/kc6jjxmd.png" alt="[IMG]"></p><p>在左边找到刚刚打开的img文件, 点击展开<code>ESP-&gt;grub</code>, 在右边找到<code>grub.cfg</code>, 选择复制到桌面.</p><p><img src="/2021/ee60585b/kccTMt.md.png" alt="[IMG]"></p><p>使用文本编辑器修改<code>line22-line25</code>的数据,</p><p>需要注意的是<code>VID</code>和<code>PID</code>必须要和U盘的数值匹配好.</p><p><code>SN</code>和<code>MAC1</code>是在洗半白的时候需要修改的数值, 是非必须修改的.</p><blockquote><p>set vid&#x3D;0x058f U盘的VID 实体机必须修改，虚拟机无需修改<br>set pid&#x3D;0x6387 U盘的PID 实体机必须修改，虚拟机无需修改<br>set sn&#x3D;A8ODN02468 序列号 可以不修改<br>set mac1&#x3D;0011322CA603 mac地址 可以不修改</p></blockquote><p>注意:vid和pid的0x是十六进制的意思是不要删除掉的，只需要修改后面的4位.</p><p><img src="/2021/ee60585b/06.png" alt="[IMG]"></p><p>回到DiskGenius内将原来的<code>grub.cfg</code>文件替换掉, 我这里是先将<code>img</code>镜像里面的<code>grub.cfg</code>文件删除, 再右键选择新增文件将编辑好的<code>grub.cfg</code>文件放入其中.</p><p>关闭DiskGenius完成<code>img</code>引导的修改.</p></li><li><p><strong>制作引导U盘</strong></p><p>使用<code>Win32 Disk Imager</code>磁盘映像工具将<code>img</code>引导文件写入U盘内.</p><blockquote><p>  下载地址:<a href="https://sourceforge.net/projects/win32diskimager/">https://sourceforge.net/projects/win32diskimager/</a><br>  中文版:<a href="https://www.openos.org/downloads/win32-disk-imager.2/">https://www.openos.org/downloads/win32-disk-imager.2/</a></p></blockquote><ul><li><p>先在软件界面右侧设备(Device) 部分选择U盘的盘符。<br>（建议在操作前移除所有其他的USB存储设备，以防选择错误导致其他U盘或移动硬盘数据丢失）。</p></li><li><p>再点击软件界面 映像文件(Image File)右侧蓝色文件夹图标，选择之前下载的synoboot.img文件。</p></li><li><p>最后再点击写入(Write)。</p></li></ul><p><img src="/2021/ee60585b/w11.png" alt="[IMG]"></p></li><li><p>安装群晖系统</p><p>插入U盘，并且在主板上设置默认从U盘启动</p><p>默认选择从U盘启动后选择第1个选项<code>DS3617xs 6.1 Baremetal with Jun&#39;s Mod v1.02-alpha</code>按回车。</p><p><img src="/2021/ee60585b/2017041711.png" alt="[IMG]"></p></li><li><p>找到设备IP地址</p><p>这里需要稍微等一等提示<code>Please open [http://find.synology.com](http://find.synology.com/) to continue</code>后等个1-2分钟在浏览器里面输入<a href="http://find.synology.com/">http://find.synology.com/</a> ，搜索DSM，如果没有找到，那么使用SynologyAssistant查找. <a href="https://cndl.synology.cn/download/Tools/Assistant/6.1-15030/Windows/synology-assistant-6.1-15030.exe">点击下载Windows版本</a> </p><p>能进路由器管理页面的, 较好的方案是看一下群晖获取的IP是多少, 浏览器直接进去这个<code>IP:5000</code>的网页即可, 免去搜寻的麻烦.</p><blockquote><p>  若多次测试还是无法搜索到群晖，那可能是网卡不支持,<br>  详情请查看DSM黑群晖网卡支持列表<br>  <a href="https://www.openos.org/threads/dsm-6-1-supported-drivers.42/">https://www.openos.org/threads/dsm-6-1-supported-drivers.42/</a></p></blockquote><p><img src="/2021/ee60585b/201704zoz.png" alt="[IMG]"></p></li><li><p>上传系统文件.</p><p>根据提示继续，点击<code>手动安装</code>后选择之前下载的pat文件，然后再点击<code>立即安装</code>。</p><p><img src="/2021/ee60585b/201704opo.png" alt="[IMG]"></p><p><img src="/2021/ee60585b/201704ada.png" alt="[IMG]"></p></li><li><p>安装之后完成一些配置后就可以进入系统界面了.</p></li></ol><h2 id="安装后的注意事项"><a href="#安装后的注意事项" class="headerlink" title="安装后的注意事项"></a>安装后的注意事项</h2><blockquote><p>  <strong>安装完成后的基本设置和注意事项</strong><br>  1,不要升级，不要升级，不要升级。可以去控制面板下面的-更新和还原里面设置。<br>  2,还是不要升级，去计划任何里面关闭DSM自动更新选项。<br>  3,在存储空间管理员里面设置存储空间后才可以进行其他的操作，如共享文件夹或安装其他套件。<br>  4,DSM 6.x配置文件grub.cfg修改: <a href="https://www.openos.org/threads/dsm-6-x-grub-cfg-mac-sn.36/">https://www.openos.org/threads/dsm-6-x-grub-cfg-mac-sn.36/</a></p><p>  群辉Synology DSM 添加硬盘&#x2F;存储空间的方法<br>  <a href="https://www.openos.org/threads/synology-dsm-hdd.30/">https://www.openos.org/threads/synology-dsm-hdd.30/</a></p><p>  6.1驱动支持列表<br>  <a href="https://www.openos.org/threads/dsm-6-1-supported-drivers.42/">https://www.openos.org/threads/dsm-6-1-supported-drivers.42/</a></p><p>  经过测试，引导文件支持DSM 6.1.1-15101<br>  但是不支持从老版本升级升级，仅限全新安装<br>  安装后更新到update 2没有问题<br>  <a href="https://www.openos.org/downloads/xpenology-dsm-6-1-1.8/history">https://www.openos.org/downloads/xpenology-dsm-6-1-1.8/history</a></p></blockquote><blockquote><p>  安装完成后可以下载一些相关的手机端应用<br>  DS Finder<br>  DS File<br>  DS photo</p></blockquote><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><h2 id="SSH访问启动盘"><a href="#SSH访问启动盘" class="headerlink" title="SSH访问启动盘"></a>SSH访问启动盘</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir /mnt/boot<br>cd /dev<br>sudo mount -t vfat synoboot1 /mnt/boot<br>cd /mnt/boot<br></code></pre></td></tr></table></figure><h2 id="半洗白-SN"><a href="#半洗白-SN" class="headerlink" title="半洗白 SN"></a>半洗白 SN</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li>全黑版本的群晖VideoStation不能离线转码，PhotoStation和Moments的略缩图和人像识别也会有问题</li><li>半洗白就是转码和缩略图一类的可用</li><li>全白就是多了QC，这个就没必要了(白嫖个系统就好了,就不要去嫖别人的服务器了)</li><li>主要通过Docker+DDSM来获得SN</li><li>群辉新版的Docker 18.09.0-0506已经关闭了DDSM安装，可下载17.05.0版本的Docker</li></ul><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><ol><li><p>下载17.05.0的Docker，可以在<a href="https://archive.synology.com/download/Package/Docker/17.05.0-0401">群晖官网下载</a>。</p></li><li><p>下载DDSM，可在<a href="https://archive.synology.com/download/Os/DSM/6.2.3-25426">群晖官网下载</a>，注意要对应自己DSM的版本。</p></li><li><p>首先在套件中心点手动安装把第一步下载的17.05.0的Docker放进去。</p></li><li><p>打开Docker-左侧DSM-点击新增-下一步-下一步-下一步-手动上传，把刚刚下载的DDSM放进去，等待他安装完成。</p></li><li><p>安装完成后，进入DDSM群晖的控制面板。</p></li><li><p>在信息栏可看到SN和MAC，复制DDSM的SN和MAC保存下来。</p></li><li><p>SSH接入DSM群晖，挂载启动盘BOOT，修改<code>/grub/grub.cfg</code>文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">挂载启动盘BOOT</span><br>mkdir /mnt/boot<br>cd /dev<br>sudo mount -t vfat synoboot1 /mnt/boot<br>cd /mnt/boot<br></code></pre></td></tr></table></figure></li><li><p>重启。</p></li></ol><p><img src="/2021/ee60585b/image-20211018141146176.png" alt="image-20211018141146176"></p><h2 id="半洗白后moments人脸识别不出来"><a href="#半洗白后moments人脸识别不出来" class="headerlink" title="半洗白后moments人脸识别不出来"></a>半洗白后moments人脸识别不出来</h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>当群晖系统升级到6.22-24922以后，Moments也升级到了1.3.X，新的bug也随着版本升级来了”人物或者主题经常识别不出来“，经查日志后发现是Moments1.3插件有bug引导的，有问题的插件为“<strong>libsynophoto-plugin-detection.so</strong>”，经测试该插件在Moments1.2版本中是正常的。</p><h3 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h3><ol><li><p>群晖上启用SSH，并将moments停用</p></li><li><p>MobaXterm连接群晖，启用root登录</p><ol><li><code>sudo -i</code></li><li><code>vi /etc/ssh/sshd_config</code></li><li>找到#PermitRootLogin prohibit password，这一行最后，按回车，然后输入 <code>PermitRootLogin yes</code></li><li>修改root密码<code>synouser --setpw root 你的密码</code></li><li>重启</li></ol></li><li><p>用root重新登录，将libsynophoto-plugin-detection.so插件替换掉</p><ol><li>找到目录：&#x2F;var&#x2F;packages&#x2F;SynologyMoments&#x2F;target&#x2F;usr&#x2F;lib&#x2F;libsynophoto-plugin-detection.so</li><li>将原文件先备份一下</li><li>用现有新文件将他替换掉</li><li>新文件权限修改一下</li></ol></li><li><p>将moments启用，问题解决</p></li></ol><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.zhihu.com/question/428454266/answer/1681110862?ivk_sa=1024320u">https://www.zhihu.com/question/428454266/answer/1681110862?ivk_sa=1024320u</a></p><p><a href="https://blog.csdn.net/weixin_36059505/article/details/112766321">https://blog.csdn.net/weixin_36059505/article/details/112766321</a></p><h2 id="群晖安装-ipkg-包管理"><a href="#群晖安装-ipkg-包管理" class="headerlink" title="群晖安装 ipkg 包管理"></a>群晖安装 ipkg 包管理</h2><p><strong>仅适用于x86平台，ARM平台需要修改链接</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">以 root 用户执行</span><br>sudo -i<br>cd /volume1/@tmp<br>wget http://ipkg.nslu2-linux.org/feeds/optware/syno-i686/cross/unstable/syno-i686-bootstrap_1.2-7_i686.xsh<br>chmod +x syno-i686-bootstrap_1.2-7_i686.xsh<br>sh syno-i686-bootstrap_1.2-7_i686.xsh<br>rm syno-i686-bootstrap_1.2-7_i686.xsh<br>ipkg update<br>reboot<br></code></pre></td></tr></table></figure><h2 id="CPU频率调整"><a href="#CPU频率调整" class="headerlink" title="CPU频率调整"></a>CPU频率调整</h2><ol><li><p>Linux的&#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpu*&#x2F;cpufreq目录存储着第*个CPU的一些参数，例如最小最大平均频率，bios限制频率。</p></li><li><p>使用如下命令可以查看支持的工作模式：</p> <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/sys/</span>devices<span class="hljs-regexp">/system/</span>cpu<span class="hljs-regexp">/cpu0/</span>cpufreq/scaling_available_governors<br></code></pre></td></tr></table></figure><table><thead><tr><th>模式</th><th>介绍</th></tr></thead><tbody><tr><td>powersave</td><td>只会保持最低频率，节能省电</td></tr><tr><td>userspace</td><td>自定义频率</td></tr><tr><td>ondemand</td><td>一有cpu计算量的任务，就会立即达到最大频率运行，等执行完毕就立即回到最低频率</td></tr><tr><td>conservative</td><td>根据负载状态自动在频率上下限调整</td></tr><tr><td>performance</td><td>保持以最大频率运行</td></tr></tbody></table></li><li><p>通过下面指令可以看第*个CPU核心的工作状态，</p> <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/sys/</span>devices<span class="hljs-regexp">/system/</span>cpu<span class="hljs-regexp">/cpu*/</span>cpufreq/scaling_governor<br></code></pre></td></tr></table></figure></li></ol><p>安装cpufreq-info：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">ipkg update<br>ipkg <span class="hljs-keyword">install</span> cpufrequtils<br></code></pre></td></tr></table></figure><p>查看CPU频率和模式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cpufreq-info<br></code></pre></td></tr></table></figure><p>修改模式：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">cpufreq-<span class="hljs-built_in">set</span> -c * -g <span class="hljs-built_in">MODE</span><br></code></pre></td></tr></table></figure><p>例如将四个核心全部ondemand：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gams">cpufreq-<span class="hljs-keyword">set</span> -c <span class="hljs-comment">0 -g ondemand</span><br>cpufreq-<span class="hljs-keyword">set</span> <span class="hljs-comment">-c 1 -g ondemand</span><br>cpufreq-<span class="hljs-keyword">set</span> <span class="hljs-comment">-c 2 -g ondemand</span><br>cpufreq-<span class="hljs-keyword">set</span> <span class="hljs-comment">-c 3 -g ondemand</span><br></code></pre></td></tr></table></figure><p>为了下次开机也自动生效，可以手动添加启动脚本。将其存成.sh，开启启动即可</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle">#<span class="hljs-regexp">/bin/</span>bash<br><span class="hljs-regexp">/opt/</span>bin/cpufreq-set -c <span class="hljs-number">0</span> -g ondemand<br><span class="hljs-regexp">/opt/</span>bin/cpufreq-set -c <span class="hljs-number">1</span> -g ondemand<br><span class="hljs-regexp">/opt/</span>bin/cpufreq-set -c <span class="hljs-number">2</span> -g ondemand<br><span class="hljs-regexp">/opt/</span>bin/cpufreq-set -c <span class="hljs-number">3</span> -g ondemand<br></code></pre></td></tr></table></figure><h2 id="lm-sensors-风扇控制"><a href="#lm-sensors-风扇控制" class="headerlink" title="lm-sensors 风扇控制"></a>lm-sensors 风扇控制</h2><p>执行安装命令</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">ipkg <span class="hljs-keyword">install</span> lm-sensors<br></code></pre></td></tr></table></figure><p>查看温度</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sensors</span><br></code></pre></td></tr></table></figure><p>配置风扇控制，这块主要的目的只检测风扇在那一路，一般主板会涉及到多个风扇，但不一定都会安装，所以通过pwmconfig来检测与测试风扇的转速控制。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo pwmconfig</span><br></code></pre></td></tr></table></figure><p>使用fancontrol自动控制风扇转速，他的原理就是定时执行脚本，监控CPU温度、根据不同的温度区间控制PWM值，从而改变风扇的转速。<br>当转速降低了后，噪音自然就解决了。</p><p>fancontrol会依赖pwmconfig命令生成的配置文件。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/etc/</span>fancontrol<br><br>-----------配置内容如下--------------<br><span class="hljs-comment"># Configuration file generated by pwmconfig, changes will be lost</span><br>INTERVAL=<span class="hljs-number">10</span><br>DEVPATH=hwmon0=devices<span class="hljs-regexp">/platform/</span>coretemp.<span class="hljs-number">0</span> hwmon1=devices<span class="hljs-regexp">/platform/i</span>t87.<span class="hljs-number">2624</span><br>DEVNAME=hwmon0=coretemp hwmon1=it8772<br>FCTEMPS=hwmon1<span class="hljs-regexp">/device/</span>pwm2=hwmon0<span class="hljs-regexp">/device/</span>temp3_input<br>FCFANS= hwmon1<span class="hljs-regexp">/device/</span>pwm2=hwmon1<span class="hljs-regexp">/device/</span>fan2_input<br>MINTEMP=hwmon1<span class="hljs-regexp">/device/</span>pwm2=<span class="hljs-number">20</span><br>MAXTEMP=hwmon1<span class="hljs-regexp">/device/</span>pwm2=<span class="hljs-number">60</span><br>MINSTART=hwmon1<span class="hljs-regexp">/device/</span>pwm2=<span class="hljs-number">150</span><br>MINSTOP=hwmon1<span class="hljs-regexp">/device/</span>pwm2=<span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p>默认生成的配置基本能够满足需求，经过测试风扇在2000转左右噪音相对能够接受。</p><h2 id="VideoStation"><a href="#VideoStation" class="headerlink" title="VideoStation"></a>VideoStation</h2><p>参考：</p><p><a href="https://zhuanlan.zhihu.com/p/357332211">关于群晖NAS video station TMDB连接测试失败及搜刮结果下载失败的解决方案</a></p><p><a href="https://zhuanlan.zhihu.com/p/152351243">（群晖）关于Video Station内电影及电视剧封面简介为空白的处理方法</a></p><h3 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤"></a>步骤</h3><ul><li><p>TMDB的图片服务器被屏蔽需要修改hosts 加上 api.themoviedb.org 的ip</p></li><li><p>修改hosts后即可测试，已经连通</p></li><li><p>搜刮信息会出现下载失败，主要是下载图片的url需要切换一下</p><p>  编辑 util_themoviedb.php 文件</p>  <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">cd /var/packages/VideoStation/target/plugins<br>vi util_themoviedb.php<br></code></pre></td></tr></table></figure>  <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text"># 找到下面的语句<br>define(&#x27;API_URL&#x27;, &#x27;https://api.themoviedb.org/3/&#x27;);<br>define(&#x27;BANNER_URL&#x27;, &#x27;https://image.tmdb.org/t/p/w500&#x27;);<br>define(&#x27;BACKDROUP_URL&#x27;, &#x27;https://image.tmdb.org/t/p/original&#x27;);<br><br># 我们只需要把改为<br>image.tmdb.org<br># 改为<br>www.themoviedb.org<br></code></pre></td></tr></table></figure></li></ul><h2 id="Gogs"><a href="#Gogs" class="headerlink" title="Gogs"></a>Gogs</h2><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/cfan927/article/details/100862989">【工具】群晖利用docker安装Gogs代码管理平台</a></p><h3 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤"></a>步骤</h3><ol><li><p>打开“Docker”-&gt;”注册表”，搜索Gogs并“右键”-&gt;“下载此映像”</p><p><img src="/2021/ee60585b/watermark.png" alt="在这里插入图片描述"></p></li><li><p>在”映像“页面中安装Gogs容器后，切换到”容器“页面，然后双击打开Gogs详情页</p><ol><li>设定容器的本地端口</li><li>设定桌面快捷方式</li></ol></li><li><p>Gogs配置</p><ol><li><p>Windows中用ssh登录群晖服务器，cd到mariaDB目录下：</p><p><code>cd /volume1/@appstore/MariaDB10/usr/local/mariadb10/bin/</code></p></li><li><p>输入命令 <code>./mysql -u root -p</code>，然后输入密码，连接数据库</p></li><li><p>输入命令 <code>use mysql</code>切换到mysql数据库</p></li><li><p>创建数据库gogs<br> <code>CREATE DATABASE IF NOT EXISTS gogs;</code></p></li><li><p>输入下面的命令获取数据库远程访问权限 ：</p><p><code>GRANT ALL PRIVILEGES ON gogs.* TO &#39;user&#39;@&#39;%&#39; IDENTIFIED BY &#39;password&#39; WITH GRANT OPTION;</code><br>其中user为用户名<br>password为用户密码</p></li><li><p>然后用<code>show databases;</code>命令查看一下结果</p></li></ol></li><li><p>gogs:port 设定相关参数即可</p></li><li><p>着重需要说明的是：</p></li><li><p>tips</p><ol><li>删除数据库  <code>DROP DATABASE gogs;</code></li></ol></li></ol><h3 id="Note-1"><a href="#Note-1" class="headerlink" title="Note"></a>Note</h3><ul><li>gogs 的配置保存在<code>/data/gogs/conf/app.ini</code> 参考下图</li></ul><p><img src="/2021/ee60585b/image-20211103161058734.png" alt="image-20211103161058734"></p><ul><li><strong>注意</strong> MariaDB的port默认是不开的，需要去套件里面打开。</li></ul><blockquote><ol><li><strong>Domain</strong> 填写Docker宿主机的物理IP地址，或者域名地址,注意这里是不带 http的 如： 192.168.137.140 或 git.mydomain.com</li><li><strong>SSH port</strong> 假如Docker映射的端口是 10022:22 那么这里就填写宿主机开放的端口 10022</li><li><strong>HTTP port</strong> 假如Docker映射的端口是 10080:3000 这里要填容器内的监听端口 3000</li><li><strong>Application URL</strong> 这里要填写的格式为 http(s)?&#x2F; + Domain + HTTP port ，比如：<a href="http://git.mydomain.com/10080">http://git.mydomain.com/10080</a> 。还需要注意的一点是，如果你用了nginx来映射宿主机的 10080 端口，这里要去掉后面的端口，即 <a href="http://git.mydomain.com/%EF%BC%8C%E8%AF%B4%E7%99%BD%E4%BA%86%E5%B0%B1%E6%98%AF%E4%BD%A0%E5%9C%A8%E5%A4%96%E9%83%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8A%E8%AE%BF%E9%97%AE%E7%9A%84%E5%9C%B0%E5%9D%80%E3%80%82">http://git.mydomain.com/，说白了就是你在外部浏览器上访问的地址。</a></li></ol></blockquote><ul><li><strong>注意</strong>非标准port的ssh需要注意clone地址是否正确</li></ul><h4 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h4><p><a href="https://github.com/gogs/gogs/discussions/6876">https://github.com/gogs/gogs/discussions/6876</a></p><ul><li><p><strong>数据备份</strong></p></li><li><p>因为容器内的 <code>/data</code> 目录是直接挂载到宿主机的，我们把容器内备份目录设置为 <code>/data</code> ， 方便宿主机将备份文件同步到远程备份服务器。</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker container exec gogs su - git -s /bin/ash \<br>-c &quot;/app/gogs/gogs backup \<br>--config=/data/gogs/conf/app.ini \<br>--target=/gogs&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">注意挂载目录的权限</span><br></code></pre></td></tr></table></figure><ul><li><p><strong>数据恢复</strong></p></li><li><p>用docker完成gogs部署之后，进入容器，执行下面命令</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker container exec -it gogs su - git -s /bin/ash \<br>-c &quot;/app/gogs/gogs restore \<br>--config=/data/gogs/conf/app.ini \<br>--tempdir=/data \<br>--from=/data/gogs-backup-20211230091744.zip&quot;<br><br></code></pre></td></tr></table></figure><ul><li><p><strong>注意：</strong></p></li><li><p>备份和恢复时，使用的 gogs 版本必须是一致的</p></li><li><p>备份和恢复时，使用的 mysql 版本必须是一致的</p></li></ul><h4 id="自述文档"><a href="#自述文档" class="headerlink" title="自述文档"></a>自述文档</h4><p>Create a plain text file then move to directory <code>custom/conf/readme/README</code> and <strong>restart Gogs.</strong></p><ul><li><code>&#123;Name&#125;</code>: Repository name</li><li><code>&#123;Description&#125;</code>: Repository description</li><li><code>&#123;CloneURL.SSH&#125;</code>: Repository SSH clone address</li><li><code>&#123;CloneURL.HTTPS&#125;</code>: Repository HTTP&#x2F;HTTPS clone address</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">&#123;Name&#125;</span><br>&#123;Name&#125; Repository<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># Tip</span></span><br>You can get the development version of this repo via<br>**git clone &#123;CloneURL.SSH&#125;**<br>or<br>**git clone &#123;CloneURL.HTTPS&#125;**<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># Bref</span></span><br>&#123;Description&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># Details</span></span><br><br></code></pre></td></tr></table></figure><h2 id="zerotier"><a href="#zerotier" class="headerlink" title="zerotier"></a>zerotier</h2><table><thead><tr><th>img name</th><th>last version</th><th>notes</th></tr></thead><tbody><tr><td>henrist-zerotier-one1</td><td>1.6.6</td><td>没有自动配置路由</td></tr><tr><td>bltavares zerotier</td><td>1.6.6</td><td>网络不通</td></tr><tr><td>zyclonite&#x2F;zerotier&#x2F;</td><td>1.8.4</td><td>没有自动配置路由 配置路由后正常</td></tr><tr><td>spikhalskiy-zerotier1</td><td>1.8.2</td><td>运行会报错<code>zerotier-cli: /usr/lib/libstdc++.so.6: no version information available (required by zerotier-cli)</code>, 没有自动配置路由 配置路由后正常</td></tr><tr><td>zerotier-zerotier-synology</td><td>1.8.4</td><td>没有自动配置路由 配置路由后正常</td></tr></tbody></table><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs livescript">docker run <span class="hljs-string">\</span><br>  -d <span class="hljs-string">\</span><br>  --restart always <span class="hljs-string">\</span><br>  --name zerotier-one <span class="hljs-string">\</span><br>  --device /dev/net/tun <span class="hljs-string">\</span><br>  --net host <span class="hljs-string">\</span><br>  --cap-add NET_ADMIN <span class="hljs-string">\</span><br>  --cap-add SYS_ADMIN <span class="hljs-string">\</span><br>  -v /<span class="hljs-keyword">var</span>/lib/zerotier-one:/<span class="hljs-keyword">var</span>/lib/zerotier-one <span class="hljs-string">\</span><br>  zerotier/zerotier-synology<br></code></pre></td></tr></table></figure><h2 id="第三方套件"><a href="#第三方套件" class="headerlink" title="第三方套件"></a>第三方套件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">矿神</span><br>https://spk.imnks.com/<br></code></pre></td></tr></table></figure><h2 id="群晖的备份-还原"><a href="#群晖的备份-还原" class="headerlink" title="群晖的备份 还原"></a>群晖的备份 还原</h2><p>晖硬盘接到电脑上使用diskgenius查看，有三个分区：系统、swap交换分区、数据存储区，所有的硬盘都有这三个分区。</p><blockquote><p>  交换分区，英文是swap，意思是“交换”、“实物交易”。 它的功能就是在内存不够的情况下，操作系统先把内存中暂时不用的数据，存到硬盘的交换空间，腾出内存来让别的程序运行，和Windows的虚拟内存（pagefile.sys）的作用是一样的。</p></blockquote><p><img src="/2021/ee60585b/image-20220918161100014.png" alt="image-20220918161100014"></p><p>弄清楚这三个分区是做什么的就很简单了, 我们备份和还原自然也就是备份和还原第一个系统分区了.</p><p>需要注意的是群晖的系统存在于任何一块硬盘内, <strong>所以还原分区的时候需要将分区还原到每一块硬盘内才行</strong>.</p><blockquote><p>  如果只还原一块后，开机进入系统，系统会提示修复，虽然也能成功但是并不建议这么做</p></blockquote><h2 id="群晖-硬盘扩容-硬盘升级"><a href="#群晖-硬盘扩容-硬盘升级" class="headerlink" title="群晖 硬盘扩容 硬盘升级"></a>群晖 硬盘扩容 硬盘升级</h2><p>紧跟上面, 如果我们需要进行硬盘扩容, 比如原来的硬盘128G, 现在购入一块新硬盘256G, 我们需要用256去替换原来的硬盘, 但是现有设备上盘位已经插满了或者是属于单盘位的机器, 这时候就要把硬盘拆下来手动将数据进行转移.</p><blockquote><p>  我的大致思路是使用DG全盘拷贝到256G硬盘上(当时尝试的时候没有找到这方面的文章, 不知道该怎么样操作, 担心数据出问题所以就用了全盘拷贝), 然后上电开机SSH登录上去扩容一下分区就好.</p></blockquote><p><strong>克隆数据</strong></p><p>首先打开<code>DiskGenius</code>软件 选择 -&gt; <code>工具</code> -&gt; <code>克隆磁盘</code> 我这里选的是按扇区全盘克隆.</p><p>讲道理来说将<code>系统区</code>、<code>数据存储区</code>拷贝过去, 再划分出<code>swap交换分区</code>应该也是可以的.</p><p>等待克隆完成.</p><p><strong>扩容分区</strong></p><p>磁盘克隆完成后, 旧的硬盘先不能格式化掉, 需要先留着以防万一.</p><p>将新的硬盘安装回群晖, 并上电开机, 开机一切正常, 查看存储管理器会发现, 256的磁盘只显示了128G, 这个时候我们就需要登录SSH进行下一步操作了.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 首先查看一下新放进去的盘的挂载位置</span><br>$ fdisk -l<br>Disk /dev/sda: 232.9 GiB, 250059350016 bytes, 488397168 sectors<br>Units: sectors of 1 * 512 = 512 bytes<br>Sector size (logical/physical): 512 bytes / 512 bytes<br>I/O size (minimum/optimal): 512 bytes / 512 bytes<br>Disklabel <span class="hljs-built_in">type</span>: dos<br><br><span class="hljs-comment"># 上面可以看到 设备在`/dev/sda` 这里的sda里面的a是按顺序来的 第二个第三个盘就是sdb sdc 类推</span><br><span class="hljs-comment"># 输入命令后它会让我们输入结束地址, 我们这里直接回车, 设定地址为最末尾</span><br>$ parted /dev/sda resizepart 3<br>End?  [250GB]?<br>Information: You may need to update /etc/fstab.<br><br><span class="hljs-comment"># 这里运行的时候报错了, 但是时间有点久没有记录下来给忘记了, 哎这些东西还是不能拖, 要立刻记录下来才行</span><br>$ resize2fs -f /dev/sda3 <br>resize2fs 1.42.6 (21-Sep-2012)<br>.....<br><br><span class="hljs-comment"># 再次查看扩容完成</span><br>$ fdisk -l<br></code></pre></td></tr></table></figure><p><strong>参考:</strong></p><p><a href="https://imnks.com/389.html">群晖升级硬盘 磁盘克隆后的简单扩容教程</a></p><h2 id="群晖安装USB网卡驱动-AX88179A-6-2-3"><a href="#群晖安装USB网卡驱动-AX88179A-6-2-3" class="headerlink" title="群晖安装USB网卡驱动 AX88179A 6.2.3"></a>群晖安装USB网卡驱动 AX88179A 6.2.3</h2><p><img src="/2021/ee60585b/image-20220926214605083.png" alt="image-20220926214605083"></p><ol><li><p>将USB网卡插入群晖</p></li><li><p>下载驱动程序 <a href="%E7%BE%A4%E6%99%96/ax88179_178a.ko.zip">ax88179_178a.ko.zip</a></p></li><li><p>解压后将<code>ax88179_178a.ko</code>文件复制到群晖的<code>/lib/modules/</code>目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> /volume......./ax88179_178a.ko /lib/modules<br></code></pre></td></tr></table></figure></li><li><p>使用命令 <code>chmod 644 ax88179_178a.ko</code>修改文件权限为<code>-rw-r--r--</code></p></li><li><p>加载驱动<code>insmod /lib/modules/ax88179_178a.ko </code> </p><ol><li><p>我这里当时报错了, 但是似乎并没有什么影响</p></li><li><p><code>insmod: ERROR: could not insert module /lib/modules/ax88179_178a.ko: Invalid module format</code></p></li><li><p>拓展一下</p><blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 获取已加载的驱动列表</span><br>lsmod<br><span class="hljs-comment"># 卸载驱动</span><br><span class="hljs-comment"># 参数为lsmod获取到的驱动名称，而不是路径</span><br>rmmod ax88179_178a<br></code></pre></td></tr></table></figure></blockquote></li></ol></li><li><p>启用网卡 <code>ifconfig eth1 up</code></p></li><li><p>重新启动</p></li></ol><blockquote><p>  网上很多blog写需要添加启动项, 但是我这里并没有添加 看起来也没有什么问题.</p><p>  添加启动项的操作是在群晖的<code>设置</code>里面 添加一个<code>任务计划</code>开机触发执行下面这个脚本</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">insmod /lib/modules/ax88179_178a.ko<br>ifconfig eth1 up<br></code></pre></td></tr></table></figure></blockquote><h2 id="PC通过群晖的网卡桥接上网"><a href="#PC通过群晖的网卡桥接上网" class="headerlink" title="PC通过群晖的网卡桥接上网"></a>PC通过群晖的网卡桥接上网</h2><p><strong>注意</strong>:首先需要确定Open vSwitch是开启的. 控制面板-&gt;网络-&gt;网络界面-&gt;管理，打开Open vSwitch（如果使用了VMM套件会自动开启，而且提示无法禁用）.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 路径图</span><br>网关(路由器) &lt;-eth0-&gt; 群晖 &lt;-eth1-&gt; PC<br></code></pre></td></tr></table></figure><p>装了群晖的Virtual Machine Manager后一个接口会多出来一块网卡, 其中<code>eth0</code>是物理网卡, <code>ovs_eth0</code>是Open vSwitch这个网络管理工具虚拟出来的网卡.</p><p>一般来说<code>eth0</code>会空闲, 流量都是通过<code>ovs_eth0</code>这个虚拟网卡, 其中<code>eth0</code>会被配置成与<code>ovs_eth0</code>桥接</p><hr><p><strong>修改配置文件</strong></p><p>如你的电脑接在群晖的第一个网口<code>eth0</code>就修改<code>ifcfg-eth0</code>，接的是第二个网口<code>eth1</code>就修改<code>ifcfg-eth1</code>(本例)。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 编辑</span><br>vim /etc/sysconfig/network-scripts/ifcfg-eth1<br><span class="hljs-comment"># 将BRIDGE 改成ovs_eth0</span><br><span class="hljs-comment"># 原BRIDGE=ovs_eth1</span><br>BRIDGE=ovs_eth0<br><br></code></pre></td></tr></table></figure><blockquote><p>   <code>/etc/sysconfig/network-scripts/ifcfg-eth1</code>文件参数简介</p><p>  <img src="/2021/ee60585b/1841273-20191019215624473-1921771223.png" alt="img"></p></blockquote><p><strong>命令修改</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看当前网桥 可以看到有两个网桥 ovs_eth0 和 ovs_eth1</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">ovs-vsctl show</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">我们将网桥 ovs_eth1 删除, 并将 eth1 加入到 网桥ovs_eth0</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">ovs-vsctl del-br ovs_eth1</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">ovs-vsctl add-port ovs_eth0 eth1</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">再次查看网桥状态</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">ovs-vsctl show</span><br>Bridge &quot;ovs_eth0&quot;<br>        Port &quot;eth1&quot;<br>            Interface &quot;eth1&quot;<br>        Port &quot;eth0&quot;<br>            Interface &quot;eth0&quot;<br>        Port &quot;ovs_eth0&quot;<br>            Interface &quot;ovs_eth0&quot;<br>                type: internal<br><span class="hljs-meta prompt_"># </span><span class="language-bash">此时eth0和eth1全部在ovs_eth0内，即两个网口处于同一个交换机内。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将eth1和电脑相连，发现电脑可以正常从路由器获取IP地址，并正常上网</span><br></code></pre></td></tr></table></figure><h2 id="PC通过群晖的网卡NAT上网"><a href="#PC通过群晖的网卡NAT上网" class="headerlink" title="PC通过群晖的网卡NAT上网"></a>PC通过群晖的网卡NAT上网</h2><p>这里主要是利用<code>iptable</code>路由流量.</p><p>首先补个<code>iptable</code>的教程</p><p><a href="https://wooyun.js.org/drops/Iptables%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B.html">Iptables入门教程</a></p><ol><li>我们需要先给<code>局域网2 eth1</code>设置一个静态ip <code>192.168.88.1/24 gw 192.168.88.1</code></li><li>然后在DHCP服务器端开启<code>局域网2 eth1</code>的DHCP服务, 网关填<code>192.168.88.1</code></li><li>然后配置<code>iptable</code>开启网口转发</li></ol><p><img src="/2021/ee60585b/image-20221121215936519.png" alt="image-20221121215936519"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">开启群晖的转发功能</span><br>echo &quot;1&quot; &gt; /proc/sys/net/ipv4/ip_forward<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">为PC添加 去往群晖的 路由表 群晖开了对应接口的DHCP就不需要了</span><br>route add -net 192.168.88.0/24 gw 192.168.88.1<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在群晖中添加iptable 策略</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">配置 NAT 服务器，执行命令</span><br>iptables -t nat -A POSTROUTING -s 192.168.88.0/24 -o ovs_eth0 -j MASQUERADE<br><span class="hljs-meta prompt_"># </span><span class="language-bash">-t 表名</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-A 在指定链的末尾添加（--append）一条新的规则</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-s 指定数据包的源地址参数，可以使IP地址、网络地址、主机名</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">   192.168.88.0 表示 192.168.88.x 的整个网络。</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">-o 输出接口</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">-j 目标动作或跳转</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">   MASQUERADE 则表示从 NAT 服务器的网卡上自动获取当前的 IP 地址来做端口转发。否则，基于目标的网络地址转换模式（即 DNAT）需要在每次 NAT 服务器连接外网的 IP 地址变更的时候重新配置端口转发。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">也可以使用源地址目标转换模式（即 SNAT），命令是</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">** 这里和上面选其一即可 **</span><br>iptables -t nat -A POSTROUTING -s 192.168.88.0/24 -o ovs_eth0 -j SNAT --to-source 192.168.20.2<br><span class="hljs-meta prompt_"># </span><span class="language-bash">显然这种方式也会依赖命令中指定的通向外网的 IP 地址，所以仍然不够灵活。推荐使用第一种方式。</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">允许端口转发</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">此命令将允许经过 eth1 网卡（连接内网）的所有数据包通向外网的转发。</span><br>iptables -A FORWARD -i eth1 -j ACCEPT<br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者 仅允许转发192.168.88.0/24段的报文</span><br>iptables -A FORWARD -s 192.168.88.0/24 -j ACCEPT<br></code></pre></td></tr></table></figure><p><strong>参考</strong></p><p><a href="https://blog.csdn.net/liuzhanchun/article/details/106819839">Linux 内部路由实现及网口转发之理论篇</a></p><p><a href="https://blog.csdn.net/luozhen07/article/details/48051005">Linux 系统双网卡实现内网端口转发</a></p>]]></content>
    
    
    <categories>
      
      <category>more_interest</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>synology</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决 Github 无法打开</title>
    <link href="/2021/db5fa6fe/"/>
    <url>/2021/db5fa6fe/</url>
    
    <content type="html"><![CDATA[<h1 id="解决-Github-无法打开"><a href="#解决-Github-无法打开" class="headerlink" title="解决 Github 无法打开"></a>解决 Github 无法打开</h1><h2 id="SwitchHosts"><a href="#SwitchHosts" class="headerlink" title="SwitchHosts"></a>SwitchHosts</h2><ol><li><p>下载 SwitchHosts <a href="https://github.com/oldj/SwitchHosts">Github</a> 下载要是太慢可以 用gitee镜像一下github的库 这里放一个别人镜像过的 <a href="https://gitee.com/itas109/SwitchHosts?_from=gitee_search">Gitee</a></p></li><li><p>安装后新建一个配置</p><ul><li>Title: 随意  Type: Remote  URL:   Auto Refresh: 最好选 1 hour</li></ul><p><img src="/2021/db5fa6fe/image-20211015220230835.png" alt="image-20211015220230835"></p><ul><li>可选的URL：<ul><li>520Github <a href="https://raw.hellogithub.com/hosts">https://raw.hellogithub.com/hosts</a></li><li>ineo6 <a href="https://gitee.com/ineo6/hosts/raw/master/hosts">https://gitee.com/ineo6/hosts/raw/master/hosts</a></li><li>有看到网上还有多个网站同时更新的，但是看到更新速度不够快，也就放弃了。</li></ul></li></ul></li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://github.com/ineo6/hosts">https://github.com/ineo6/hosts</a></p><p><a href="https://github.com/521xueweihan/GitHub520">https://github.com/521xueweihan/GitHub520</a></p><h2 id="Chrome-插件方式"><a href="#Chrome-插件方式" class="headerlink" title="Chrome 插件方式"></a>Chrome 插件方式</h2><p><a href="https://github.com/gauseen/faster-hosts">FasterHosts</a> 是个 Chrome 插件，主要原理是拦截浏览器的某些请求，将 <code>domain</code> 替换成访问速度较快的那个。hosts 资源来自 <a href="https://github.com/521xueweihan/GitHub520">GitHub520</a>，每 1 小时更新一次。</p><blockquote><ol><li>下载 <a href="https://github.com/gauseen/faster-hosts/archive/master.zip">FasterHosts</a> 然后解压，找到 <code>extension</code> 子目录</li><li>打开 Chrome，输入: <code>chrome://extensions/</code></li><li>打开「开发者模式」</li><li>选择「加载已解压的扩展程序」，然后定位到刚才解压的文件夹里面的 <code>extension</code> 目录，确定</li><li>这就安装好了，关闭「开发者模式」</li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github</tag>
      
      <tag>hosts</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派连上手机热点如何查看它的IP</title>
    <link href="/2021/6561f7ab/"/>
    <url>/2021/6561f7ab/</url>
    
    <content type="html"><![CDATA[<p>关键词:</p><p>手机 热点 查看 接入 热点 IP 树莓派连上手机热点如何查看它的IP</p><h1 id="树莓派连上手机热点如何查看它的IP"><a href="#树莓派连上手机热点如何查看它的IP" class="headerlink" title="树莓派连上手机热点如何查看它的IP"></a>树莓派连上手机热点如何查看它的IP</h1><h1 id="序："><a href="#序：" class="headerlink" title="序："></a>序：</h1><h4 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h4><p>原来都是通过网线连接树莓派的，当时设置过wifi，这次把树莓派带出去用，就没有带网线，手机上显示已经连接上了，但是不知道怎么查看树莓派的ip。相信点进来的都是小米手机把，点名批评小米，隔壁华为荣耀都能直接看到。</p><h4 id="通过阅读本文你能知道什么？"><a href="#通过阅读本文你能知道什么？" class="headerlink" title="通过阅读本文你能知道什么？"></a>通过阅读本文你能知道什么？</h4><ul><li>如何通过app查看连上热点的ip</li></ul><p>如果本文对你有帮助，请不要吝啬你的点赞，让别人也能看到，如果你有更好的见解，非常希望你能提出指导意见！</p><p>@[toc]</p><h1 id="软件："><a href="#软件：" class="headerlink" title="软件："></a>软件：</h1><p><strong>终端</strong> or <strong>Terminal Emulator</strong><br>各大应用商店可下，实在不行可以从<a href="https://jackpal.github.io/Android-Terminal-Emulator/">这个页面</a>下载</p><h1 id="详细："><a href="#详细：" class="headerlink" title="详细："></a>详细：</h1><p>输入指令 <strong>ip neigh</strong> 就能获得相关的ip地址信息<br><img src="/2021/6561f7ab/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Li05rW355qE5Z-O,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="树莓派"></p>]]></content>
    
    
    <categories>
      
      <category>raspberry</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ip</tag>
      
      <tag>raspberry</tag>
      
      <tag>ap</tag>
      
      <tag>wifi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>J-Link RTT的使用方法</title>
    <link href="/2021/18d811b/"/>
    <url>/2021/18d811b/</url>
    
    <content type="html"><![CDATA[<h1 id="J-Link-RTT-amp-JTrace"><a href="#J-Link-RTT-amp-JTrace" class="headerlink" title="J-Link RTT &amp; JTrace"></a>J-Link RTT &amp; JTrace</h1><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>Jlink可用直接输出调试信息，省去串口工具（配置麻烦+硬件接线乱+占用IO）</p><p>Jlink输出调试信息有两种</p><ul><li>Jlink的Trace</li><li>Jlink的RTT (Real Time Transfer)</li></ul><h2 id="Jlink-Trace"><a href="#Jlink-Trace" class="headerlink" title="Jlink Trace"></a>Jlink Trace</h2><hr><p>！！！待完善！！！</p><hr><p>MDK 环境下：</p><p><img src="/2021/18d811b/132307095276873.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ITM_Port8(n)    (*((volatile unsigned char *)(0xE0000000+4*n)))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ITM_Port16(n)   (*((volatile unsigned short*)(0xE0000000+4*n)))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ITM_Port32(n)   (*((volatile unsigned long *)(0xE0000000+4*n)))</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEMCR           (*((volatile unsigned long *)(0xE000EDFC)))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TRCENA          0x01000000</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fputc</span><span class="hljs-params">(<span class="hljs-type">int</span> ch, FILE *f)</span> <br>&#123;<br>  <span class="hljs-keyword">if</span> (DEMCR &amp; TRCENA) &#123;<br>    <span class="hljs-keyword">while</span> (ITM_Port32(<span class="hljs-number">0</span>) == <span class="hljs-number">0</span>);<br>    ITM_Port8(<span class="hljs-number">0</span>) = ch;<br>  &#125;<br>  <span class="hljs-keyword">return</span>(ch);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="RTT"><a href="#RTT" class="headerlink" title="RTT"></a>RTT</h2><p><a href="https://www.segger.com/products/debug-probes/j-link/technology/about-real-time-transfer/">Jlink RTT 官网资料</a></p><p>RTT其实原理就是读取RAM上某个Buff的数据，这个Buff可以通过RTT的CB(control block)找到。</p><h3 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h3><p>下载Jlink的工具后，安装后程序目录有Samples文件夹(default: C:\Program Files\SEGGER\JLink\Samples)，文件夹内就有RTT的源码。</p><ol><li>将源码的<code>RTT/</code>目录下 <code>SEGGER_RTT_Printf.c</code>  <code>SEGGER_RTT.c</code> 两个文件添加到工程里，并解决头文件包含问题。</li><li>看 <code>Examples/</code>目录下就有使用历程，移植到你的工程就好。可以参考<code>Main_RTT_InputEchoApp.c</code>和<code>Main_RTT_PrintfTest.c</code>。</li><li>打开 <code>J-Link RTT Viewer</code>软件，选择<code>Device</code>，输入<code>RTT Control Block</code>的地址connect即可。<ol><li><code>RTT Control Block</code>的地址可以输入RAM的范围让<code>J-Link RTT Viewer</code>软件自己去搜索。</li><li>也可手动输入，而RTT_V754a的<code>RTT Control Block</code>是<code>_SEGGER_RTT</code> 在<code> file:SEGGER_RTT.c line:279</code>。<img src="/2021/18d811b/image-20210917214218565.png" alt="image-20210917214218565"></li></ol></li><li>一顿操作下来正常就可以收到数据了。</li></ol><h3 id="RTT-源码"><a href="#RTT-源码" class="headerlink" title="RTT 源码"></a>RTT 源码</h3><h4 id="Included-files"><a href="#Included-files" class="headerlink" title="Included files"></a>Included files</h4><ul><li><code>RTT/</code><ul><li><code>SEGGER_RTT.c</code>               - RTT的主要模块。</li><li><code>SEGGER_RTT.h</code>               - RTT的主要模块。</li><li><code>SEGGER_RTT_ASM_ARMv7M.S</code>    - ARMv7M 的优化实现</li><li><code>SEGGER_RTT_Printf.c</code>        - (‘ SEGGER_RTT_Printf() ‘)的简单实现。</li></ul></li><li><code>Syscalls/</code><ul><li><code>SEGGER_RTT_Syscalls_*.c</code>    - <code>printf()</code> 重定向</li></ul></li><li><code>Config/</code><ul><li><code>SEGGER_RTT_Conf.h</code>          - RTT配置文件。</li></ul></li><li><code>Examples/</code><ul><li><code>Main_RTT_InputEchoApp.c</code>    - Example application which echoes input on Channel 0.</li><li><code>Main_RTT_MenuApp.c</code>         - Example application to demonstrate RTT bi-directional functionality.</li><li><code>Main_RTT_PrintfTest.c</code>      - Example application to test RTT’s simple printf implementation.</li><li><code>Main_RTT_SpeedTestApp.c</code>    - Example application to measure RTT performance. (Requires embOS)</li></ul></li></ul><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><table><thead><tr><th align="center">函数名称</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">SEGGER_RTT_Read()</td><td align="center">从输入缓冲区读取数据。</td></tr><tr><td align="center">SEGGER_RTT_Write()</td><td align="center">将数据写入输出缓冲区。</td></tr><tr><td align="center">SEGGER_RTT_WriteString()</td><td align="center">将\0结尾字符串写入输出缓冲区。</td></tr><tr><td align="center">SEGGER_RTT_printf()</td><td align="center">将格式化的字符串写入输出缓冲区。</td></tr><tr><td align="center">SEGGER_RTT_GetKey()</td><td align="center">从输入缓冲区 0 中获取一个字符。</td></tr><tr><td align="center">SEGGER_RTT_HasKey()</td><td align="center">检查输入缓冲区 0 中是否有字符可用。</td></tr><tr><td align="center">SEGGER_RTT_WaitKey()</td><td align="center">等待输入缓冲区 0 中的字符可用并获取它。</td></tr><tr><td align="center">SEGGER_RTT_ConfigUpBuffer()</td><td align="center">配置向上（输出）缓冲区。</td></tr><tr><td align="center">SEGGER_RTT_ConfigDownBuffer()</td><td align="center">配置向下（输入）缓冲区。</td></tr><tr><td align="center">SEGGER_RTT_Init()</td><td align="center">仅使用 RAM 目标时初始化 RTT 控制块结构。</td></tr><tr><td align="center">SEGGER_RTT_SetTerminal()</td><td align="center">将“虚拟”终端设置为通过 Write 和 WriteString 用于通道 0 上的输出。</td></tr><tr><td align="center">SEGGER_RTT_TerminalOut()</td><td align="center">通过“虚拟”终端发送以\0结尾的字符串。</td></tr></tbody></table><h3 id="RTT-软件"><a href="#RTT-软件" class="headerlink" title="RTT 软件"></a>RTT 软件</h3><p><img src="/2021/18d811b/image-20210918101414512.png" alt="image-20210918101414512"></p><ul><li><p><code>J-Link RTT Viewer</code>软件用的比较多</p></li><li><p><code>J-Link RTT Logger</code>软件可以将输出的数据保存到文件，并显示通信速率和通信数据量。</p></li><li><p><code>J-Link RTT Client</code>可以在调试的时候，充当客户端，输出数据。据说支持中文</p></li></ul><h3 id="note："><a href="#note：" class="headerlink" title="note："></a>note：</h3><ul><li>程序如果跑在RAM中，J-Link可能会错误地识别出init部分中的块，而不是数据部分中的实际块。为了防止这种情况，将SEGGER_RTT_IN_RAM的定义设置为1。现在，J-Link将在应用程序中调用第一个SEGGER_RTT函数之后找到正确的RTT缓冲区。建议在应用程序开始时调用SEGGER_RTT_Init()。</li></ul><h4 id="不同通道输出数据"><a href="#不同通道输出数据" class="headerlink" title="不同通道输出数据"></a>不同通道输出数据</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">SEGGER_RTT_TerminalOut(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;SEGGER_RTT_TerminalOut 0\r\n&quot;</span>);<br>SEGGER_RTT_TerminalOut(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;SEGGER_RTT_TerminalOut 1\r\n&quot;</span>);<br>SEGGER_RTT_TerminalOut(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;SEGGER_RTT_TerminalOut 2\r\n&quot;</span>);<br><br><br><br>SEGGER_RTT_SetTerminal(<span class="hljs-number">0</span>);<br>SEGGER_RTT_printf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;SEGGER_RTT_printf 0\r\n&quot;</span>);<br>SEGGER_RTT_SetTerminal(<span class="hljs-number">1</span>);<br>SEGGER_RTT_printf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;SEGGER_RTT_printf 1\r\n&quot;</span>);<br>SEGGER_RTT_SetTerminal(<span class="hljs-number">2</span>);<br>SEGGER_RTT_printf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;SEGGER_RTT_printf 2\r\n&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="输出带颜色的字符"><a href="#输出带颜色的字符" class="headerlink" title="输出带颜色的字符"></a>输出带颜色的字符</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Control sequences, based on ANSI.</span><br><span class="hljs-comment">// Can be used to control color, and clear the screen</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_RESET                <span class="hljs-string">&quot;\x1B[0m&quot;</span>         <span class="hljs-comment">// Reset to default colors</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_CLEAR                <span class="hljs-string">&quot;\x1B[2J&quot;</span>         <span class="hljs-comment">// Clear screen, reposition cursor to top left</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_BLACK           <span class="hljs-string">&quot;\x1B[2;30m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_RED             <span class="hljs-string">&quot;\x1B[2;31m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_GREEN           <span class="hljs-string">&quot;\x1B[2;32m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_YELLOW          <span class="hljs-string">&quot;\x1B[2;33m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_BLUE            <span class="hljs-string">&quot;\x1B[2;34m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_MAGENTA         <span class="hljs-string">&quot;\x1B[2;35m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_CYAN            <span class="hljs-string">&quot;\x1B[2;36m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_WHITE           <span class="hljs-string">&quot;\x1B[2;37m&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_BRIGHT_BLACK    <span class="hljs-string">&quot;\x1B[1;30m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_BRIGHT_RED      <span class="hljs-string">&quot;\x1B[1;31m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_BRIGHT_GREEN    <span class="hljs-string">&quot;\x1B[1;32m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_BRIGHT_YELLOW   <span class="hljs-string">&quot;\x1B[1;33m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_BRIGHT_BLUE     <span class="hljs-string">&quot;\x1B[1;34m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_BRIGHT_MAGENTA  <span class="hljs-string">&quot;\x1B[1;35m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_BRIGHT_CYAN     <span class="hljs-string">&quot;\x1B[1;36m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_TEXT_BRIGHT_WHITE    <span class="hljs-string">&quot;\x1B[1;37m&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_BLACK             <span class="hljs-string">&quot;\x1B[24;40m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_RED               <span class="hljs-string">&quot;\x1B[24;41m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_GREEN             <span class="hljs-string">&quot;\x1B[24;42m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_YELLOW            <span class="hljs-string">&quot;\x1B[24;43m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_BLUE              <span class="hljs-string">&quot;\x1B[24;44m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_MAGENTA           <span class="hljs-string">&quot;\x1B[24;45m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_CYAN              <span class="hljs-string">&quot;\x1B[24;46m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_WHITE             <span class="hljs-string">&quot;\x1B[24;47m&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_BRIGHT_BLACK      <span class="hljs-string">&quot;\x1B[4;40m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_BRIGHT_RED        <span class="hljs-string">&quot;\x1B[4;41m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_BRIGHT_GREEN      <span class="hljs-string">&quot;\x1B[4;42m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_BRIGHT_YELLOW     <span class="hljs-string">&quot;\x1B[4;43m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_BRIGHT_BLUE       <span class="hljs-string">&quot;\x1B[4;44m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_BRIGHT_MAGENTA    <span class="hljs-string">&quot;\x1B[4;45m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_BRIGHT_CYAN       <span class="hljs-string">&quot;\x1B[4;46m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTT_CTRL_BG_BRIGHT_WHITE      <span class="hljs-string">&quot;\x1B[4;47m&quot;</span></span><br><br><br>SEGGER_RTT_WriteString(<span class="hljs-number">0</span>,RTT_CTRL_RESET<span class="hljs-string">&quot;Red: &quot;</span>\<br>                       RTT_CTRL_TEXT_RED<span class="hljs-string">&quot;This text is red.&quot;</span>\<br>                       RTT_CTRL_BG_BRIGHT_GREEN<span class="hljs-string">&quot;This background is green.\r\n&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="输入字符"><a href="#输入字符" class="headerlink" title="输入字符"></a>输入字符</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(SEGGER_RTT_HasKey())<br>&#123;<br>    <span class="hljs-type">char</span> r = SEGGER_RTT_GetKey();<br>    SEGGER_RTT_WriteString(<span class="hljs-number">0</span>,<span class="hljs-string">&quot;input:%c\r\n&quot;</span>, r);<br>&#125;<br><br><br><span class="hljs-keyword">if</span>(SEGGER_RTT_HasKey())<br>&#123;<br>    ReadNum = SEGGER_RTT_Read(<span class="hljs-number">0</span>,&amp;acIn[<span class="hljs-number">0</span>], <span class="hljs-keyword">sizeof</span>(acIn));<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">20</span>;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">0x0A</span> != acIn[i])<br>        &#123;<br>            ReadNum++;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    SEGGER_RTT_Write(<span class="hljs-number">0</span>,acIn,ReadNum);<br>    ReadNum=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(acIn,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(acIn));<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>j-link</tag>
      
      <tag>jlink</tag>
      
      <tag>rtt</tag>
      
      <tag>serial</tag>
      
      <tag>debug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hex 文件格式解析</title>
    <link href="/2021/d3f98b78/"/>
    <url>/2021/d3f98b78/</url>
    
    <content type="html"><![CDATA[<h1 id="Hex-文件格式解析"><a href="#Hex-文件格式解析" class="headerlink" title="Hex 文件格式解析"></a>Hex 文件格式解析</h1><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://developer.arm.com/documentation/ka003292/1-0">Intel HEX File Format Keil</a></p><p><a href="https://en.wikipedia.org/wiki/Intel_HEX">Intel HEX Wiki</a></p><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><ul><li>以行为单位，每行以冒号开头，内容全部为16进制码（以ASCII码形式显示）</li><li>在HEX文件里面，每一行代表一个记录。记录的基本格式为如表所示</li></ul><table><thead><tr><th><strong>冒号</strong></th><th><strong>本行数据长度</strong></th><th><strong>本行数据起始地址</strong></th><th><strong>数据类型</strong></th><th><strong>数据</strong></th><th><strong>校验码</strong></th></tr></thead><tbody><tr><td></td><td>1 byte</td><td>2 bytes</td><td>1 byte</td><td>n byte</td><td>1 byte</td></tr></tbody></table><p><img src="/2021/d3f98b78/hex_format.jpg" alt="Hex文件格式解析"></p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Start code</td><td>one character, an ASCII colon ‘:’</td></tr><tr><td>Byte count</td><td>两个十六进制数字（一个十六进制数字对），表示数据字段中的字节数（十六进制数字对）。最大字节数为 255 (0xFF)。16 (0x10) 和 32 (0x20) 是常用的字节数。</td></tr><tr><td>Address</td><td>四位十六进制数字，表示数据的 16 位起始内存地址偏移量。数据的物理地址是通过将此偏移量添加到先前建立的基地址来计算的，从而允许内存寻址超出 16 位地址的 64 KB 限制。默认为零的基地址可以通过各种类型的记录进行更改。基地址和地址偏移量始终表示为<a href="https://en.wikipedia.org/wiki/Big_endian">大端</a>值。</td></tr><tr><td>Record type</td><td>两个十六进制数字，<em>00</em>到<em>05</em>，定义数据字段的含义。参考下文</td></tr><tr><td>Data</td><td>一个由<em>n</em>个字节组成的数据序列，由 <em>2n</em> 个十六进制数字表示。一些记录省略了这个字段（<em>n</em>等于零）。数据字节的含义和解释取决于应用程序。</td></tr><tr><td>Checksum</td><td>two hex digits, a computed value that can be used to verify the record has no errors.计算校验和前所有16进制码的累加和。</td></tr></tbody></table><h3 id="指令类型-Record-type"><a href="#指令类型-Record-type" class="headerlink" title="指令类型 Record type"></a>指令类型 Record type</h3><p>指令类型<code>Record type</code>的值一般是<code>00~05</code>，这表示了，当前这行<code>hex</code>格式的数据，所代表的含义：</p><table><thead><tr><th>十六进制代码</th><th>记录类型</th><th align="center">描述</th><th align="center">Example</th></tr></thead><tbody><tr><td><strong>00</strong></td><td>数据</td><td align="center">包含数据和该数据的16位起始地址。字节计数指定记录中的数据字节数。右侧显示的示例为0B （十一）个数据字节（61， 64， 64， 72， 65， 73， 73， 20， 67， 61， 70）位于以地址开头的连续地址 0010。</td><td align="center"><code>:0B 0010 00 6164647265737320676170 A7</code></td></tr><tr><td><strong>01</strong></td><td>文件结束</td><td align="center">每个文件在文件的最后一行必须恰好发生一次。数据字段为空（因此字节数为00），并且地址字段通常为 0000。</td><td align="center"><code>:00 0000 01 FF</code></td></tr><tr><td><strong>02</strong></td><td>扩展段地址</td><td align="center">数据字段包含一个16位的段基址（因此字节数始终为02）与80x86实模式寻址兼容。地址字段（通常为0000）被忽略。最近的段地址02记录乘以16，然后加到每个后续数据记录地址，以形成数据的物理起始地址。这允许寻址多达1 MB的地址空间。</td><td align="center"><code>:02 0000 02 1200 EA</code></td></tr><tr><td><strong>03</strong></td><td>起始段地址</td><td align="center">对于80x86处理器，请指定CS：IP寄存器的初始内容（即起始执行地址）。地址字段是0000，字节数始终为04，前两个数据字节是CS值，后两个是IP值。</td><td align="center"><code>:04 0000 03 00003800 C1</code></td></tr><tr><td><strong>04</strong></td><td>扩展线性地址</td><td align="center">允许32位寻址（最大4GiB）。记录的地址字段将被忽略（通常是0000），其字节数始终为02。两个数据字节（大字节序）为所有后续类型指定32位绝对地址的高16位00记录; 这些高位地址位适用于下一个04记录。类型的绝对地址00 通过组合最近的高16位地址位形成记录 04 用低16位的地址记录 00记录。如果是类型00 记录之前没有任何类型 04 记录，然后其高16位地址位默认为0000。</td><td align="center"><code>:02 0000 04 FFFF FC</code></td></tr><tr><td><strong>05</strong></td><td>起始线性地址</td><td align="center">地址字段是 0000（未使用），字节数始终为04。四个数据字节代表一个32位地址值（big-endian）。对于80386和更高版本的CPU，此地址将加载到EIP寄存器中。<br/><strong>（仅限 MDK-ARM）</strong>起始线性地址记录指定应用程序的起始地址。这些记录包含完整的线性 32 位地址。</td><td align="center"><code>:04 0000 05 000000CD 2A</code></td></tr></tbody></table><h5 id="扩展线性地址记录-HEX386"><a href="#扩展线性地址记录-HEX386" class="headerlink" title="扩展线性地址记录 (HEX386)"></a>扩展线性地址记录 (HEX386)</h5><p>扩展线性地址记录也称为 32 位地址记录和 HEX386 记录。这些记录包含数据地址的高 16 位（位 16-31）。扩展线性地址记录总是有两个数据字节，如下所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">:02000004FFFFFC<br></code></pre></td></tr></table></figure><p>在哪里：</p><ul><li><strong>02</strong>是记录中的数据字节数。</li><li><strong>0000</strong>是地址字段。对于扩展线性地址记录，此字段始终为 0000。</li><li><strong>04</strong>是记录类型 04（扩展的线性地址记录）。</li><li><strong>FFFF</strong>是地址的高 16 位。</li><li><strong>FC</strong>是记录的校验和，计算方式为<br>01h + NOT(02h + 00h + 00h + 04h + FFh + FFh)。</li></ul><p>读取扩展线性地址记录时，存储在数据字段中的扩展线性地址将被保存并应用于从 Intel HEX 文件读取的后续记录。线性地址保持有效，直到被另一个扩展地址记录改变。</p><p>数据记录的绝对内存地址是通过将记录中的地址字段与扩展线性地址记录的移位地址数据相加得到的。下面的例子说明了这个过程。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-type">Address</span> from the <span class="hljs-class"><span class="hljs-keyword">data</span> record&#x27;s address field      2462</span><br><span class="hljs-type">Extended</span> linear address record <span class="hljs-class"><span class="hljs-keyword">data</span> field     <span class="hljs-type">FFFF</span></span><br>                                              <span class="hljs-comment">--------</span><br><span class="hljs-type">Absolute</span>-memory address                       <span class="hljs-type">FFFF2462</span><br></code></pre></td></tr></table></figure><h5 id="扩展段地址记录-HEX86"><a href="#扩展段地址记录-HEX86" class="headerlink" title="扩展段地址记录 (HEX86)"></a>扩展段地址记录 (HEX86)</h5><p>扩展段地址记录（也称为 HEX86 记录）包含数据地址段的第 4-19 位。扩展段地址记录总是有两个数据字节，如下所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">:020000021200EA<br></code></pre></td></tr></table></figure><p>在哪里：</p><ul><li><strong>02</strong>是记录中的数据字节数。</li><li><strong>0000</strong>是地址字段。对于扩展段地址记录，该字段始终为 0000。</li><li><strong>02</strong>是记录类型 02（扩展段地址记录）。</li><li><strong>1200</strong>是地址段。</li><li><strong>EA</strong>是记录的校验和，计算方式为<br>01h + NOT(02h + 00h + 00h + 02h + 12h + 00h)。</li></ul><p>当读取扩展段地址记录时，存储在数据字段中的扩展段地址被保存并应用于从 Intel HEX 文件读取的后续记录。段地址保持有效，直到被另一个扩展地址记录改变。</p><p>数据记录的绝对内存地址是通过将记录中的地址字段添加到来自扩展段地址记录的移位地址数据中获得的。以下示例说明了此过程。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-type">Address</span> from the <span class="hljs-class"><span class="hljs-keyword">data</span> record&#x27;s address field     2462</span><br><span class="hljs-type">Extended</span> segment address record <span class="hljs-class"><span class="hljs-keyword">data</span> field      1200</span><br>                                             <span class="hljs-comment">--------</span><br><span class="hljs-type">Absolute</span> memory address                      <span class="hljs-number">00014462</span><br></code></pre></td></tr></table></figure><h5 id="起始线性地址记录（仅限-MDK-ARM）"><a href="#起始线性地址记录（仅限-MDK-ARM）" class="headerlink" title="起始线性地址记录（仅限 MDK-ARM）"></a>起始线性地址记录（仅限 MDK-ARM）</h5><p>起始线性地址记录指定应用程序的起始地址。这些记录包含完整的线性 32 位地址。起始线性地址记录总是有四个数据字节，如下所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">:04000005000000CD2A<br></code></pre></td></tr></table></figure><p>在哪里：</p><ul><li><strong>04</strong>是记录中的数据字节数。</li><li><strong>0000</strong>是地址字段。对于起始线性地址记录，该字段始终为 0000。</li><li><strong>05</strong>是记录类型 05（起始线性地址记录）。</li><li><strong>000000CD</strong>是应用程序的 4 字节线性起始地址。</li><li><strong>2A</strong>是记录的校验和，计算方式为<br>01h + NOT(04h + 00h + 00h + 05h + 00h + 00h + 00h + CDh)。</li></ul><p>Start Linear Address 指定了 __main（pre-main）函数的地址，而不是通常在调用 SystemInit() 之后调用 __main 的启动代码的地址。奇数线性起始地址指定 __main 是为 Thumb 指令集编译的。</p><p>起始线性地址记录可以出现在 hex 文件中的任何位置。在大多数情况下，可以忽略此记录，因为它不包含对闪存进行编程所需的信息。</p><h5 id="文件结束-EOF-记录"><a href="#文件结束-EOF-记录" class="headerlink" title="文件结束 (EOF) 记录"></a>文件结束 (EOF) 记录</h5><p>英特尔 HEX 文件必须以文件结束 (EOF) 记录结尾。此记录在记录类型字段中必须具有值 01。EOF 记录始终如下所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">:00000001FF<br></code></pre></td></tr></table></figure><p>在哪里：</p><ul><li><strong>00</strong>是记录中的数据字节数。</li><li><strong>0000</strong>是数据在内存中的位置。文件尾记录中的地址是无意义的并且被忽略。地址 0000h 是典型的。</li><li><strong>01</strong>是记录类型 01（文件结束记录）。</li><li><strong>FF</strong>是记录的校验和，计算方式为<br>01h + NOT(00h + 00h + 00h + 01h)。</li></ul><h2 id="tip"><a href="#tip" class="headerlink" title="tip"></a>tip</h2><ul><li><strong>用Notepad++打开hex文件，会自动上色、换行</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>XIP 片内执行 eXecute in Place</title>
    <link href="/2021/2c1a46d6/"/>
    <url>/2021/2c1a46d6/</url>
    
    <content type="html"><![CDATA[<h1 id="XIP-eXecute-In-Place"><a href="#XIP-eXecute-In-Place" class="headerlink" title="XIP   eXecute In Place"></a>XIP   eXecute In Place</h1><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><p>eXecute In Place，即芯片内执行，是指CPU直接从存储器中读取程序代码执行。</p><p>应用程序可以直接在flash闪存内运行，不必再把代码读到系统RAM中。flash内执行是指nor flash不需要初始化，可以直接在flash内执行代码。但往往<strong>只执行部分代码</strong>，比如<strong>初始化RAM</strong>。好处即是程序代码无需占用内存，减少内存的要求。</p><p><strong>所谓片内执行不是说程序在存储器内执行，CPU的基本功能是取指、译码、运行。Nor Flash能在芯片内执行，指的是CPU能够直接从Nor flash中取指令，供后面的译码器和执行器来使用。</strong></p><p>为实现XIP，必须满足几个条件：</p><ol><li><p>存储器必须提供与内存相似的接口给CPU。</p></li><li><p>该接口必须提供足够快的读取操作，并具有随机访问模式。</p></li><li><p>如有文件系统，则需要提供合适的映射功能</p></li><li><p>程序链接时需要知道存储器的地址或地址与位置无关。</p></li><li><p>程序不能修改已加载映像中的数据。</p></li></ol><p>NOR Flash和EEPROM通常能满足上述要求。</p><h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p><strong>nandflash也可以实现XIP</strong></p><p>“所谓XIP,就是CODE是在FLASH上直接运行. NANDFLASH只是不适合做XIP,但并不是不能做XIP“要一段CODE能够正确的运行,要保证它的CODE是连续的,正确的.由于一些电气特性的原因,NOR FLASH能够做到这一点,不存在坏道或坏块,所以能够做XIP.</p><p><strong>NOR Flash 和 NAND Flash</strong></p><p>NOR Flash具备随机读取给一个地址就能读一个数据，NAND Flash是一次读一块数据，一个地址读出一块数据。</p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xip</tag>
      
      <tag>nor</tag>
      
      <tag>nand</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>碎句杂字摘录</title>
    <link href="/2021/1ee3369/"/>
    <url>/2021/1ee3369/</url>
    
    <content type="html"><![CDATA[<ul><li><p>不论你的生活如何卑微，面对它，活下去，不要逃避，也不要恶语相向。<br>However mean your life is, meet it and live it; do not shun it and call it hard times.</p></li><li><p>i love you as who you are<br>我爱你如你所是</p></li><li><p>“I…I…admire and love you.<br>（我仰慕你并爱你）</p></li><li><p><strong>花有重开日，人无再少年</strong></p></li><li><p><strong>“你来到这里不是为了做选择，你早已选择了。你来到这里的目的，是为了了解你为什么这样选择”</strong></p></li><li><p><strong>”你要想通，这一切并不重要。有人提交了烂代码，网站下线了，又怎么样？工作并不是你的整个生活。它们不是真正的问题，只是工作上的问题。真正重要的事情都发生在工作以外。我回到家，家里人正在等我，这才重要啊。“</strong></p></li><li><p>寒塘渡鹤影，冷月葬花魂<br>意思：鹤的影儿从寒气氤氲的池塘上面掠过，高挂在天月儿发出清冷的光辉，淹没了月下吟诗人的灵魂。</p></li><li><p>纪念我过去 为人如此风趣,</p></li><li><p>活得精彩 结尾切勿流眼泪,</p></li><li><p>友情爱情两边都发现 亏欠,</p></li><li><p>没求过你 你就当我骄傲,</p></li><li><p>离时代远远 无人间烟火,</p></li><li><p>从今天开始 相识当做别离,</p></li><li><p>做喜欢的工作和享受游戏 一死了 怎细味</p></li><li><p><strong>理想主义化，最终会盛开在浪漫主义的土壤里。我的热情 永远不会熄灭在现实的平凡之中</strong></p></li><li><p><strong>欲望众生皆有，克制方能为人</strong></p></li><li><p><strong>玄鸟归：</strong><br>后五日“玄鸟归”，玄鸟就是燕子，燕子是春分而来，秋分而去，它是北方之鸟，南飞带来生机，玄鸟空巢语，飞花入户香，燕昵呼唤燕好，燕舞莺啼，生机勃勃。<br>如今北飞为归，红花半落燕归去，秋风萧瑟，要白露满山叶飞坠了。</p></li><li><p>过一个美妙的人生并不难，你选一个公认的世界难题，最好是只用一张纸和一只铅笔的数学难题，比如歌德巴赫猜想或费尔马大定理什么的，或连纸笔都不要的纯自然哲学难题，比如宇宙的本源之类，投入全部身心钻研，只问耕耘不问收获，不知不觉的专注中，一辈子也就过去了。<br>人们常说的寄托，也就是这么回事。或是相反，把挣钱作为惟一的目标，所有的时间都想着怎么挣，也不问挣来干什么用，到死的时候像葛朗台一样抱者一堆金币说：啊，真暖和啊……所以，美妙人生的关键在于你能迷上什么东西。 ———— <strong>刘慈欣《球状闪电》</strong></p></li><li><p>你是砍柴的, 他是放羊的, 你和他聊了一天, 他的羊吃饱了, 你的柴呢?</p></li><li><p><strong>后来才发现，人在踏入社会的时候，哪有什么退路，父母不是，婚姻不是，唯有自己的能力和手中的钱，才是活在这个世上最大的底气。</strong></p></li><li><p><strong>相识于人海，最后还是要归还于人海的。</strong></p></li><li><p><strong>当我们爱上一个人，就像有一百只蝴蝶在肚中翩翩起舞。然后飞着飞着，飞到了心里，就像心花怒放的感觉。</strong></p></li><li><p>我们常说时间是一个小偷，但事实却是时间先给予我们，然后再让我们失去。</p></li><li><p>谁也承担不起另一个人的感情寄托，这件事我明白得太晚了。</p></li><li><p>所谓骑士总能救出公主，是因为恶龙从没伤害过她。</p></li><li><p>有些人就是拿来错过的，有些事仅仅只为了回忆。</p></li><li><p>不要蠢到用认识的时间长短来衡量感情。</p></li><li><p>也许合适真的比喜欢更重要吧。</p></li><li><p>当着心爱男人的面，每个女人都有返老还童的绝技。</p></li><li><p>其实不用在乎别人的生活方式的。说到底谁也不知道生活是怎么回事，即使你的答案和别人不一样，也算不上是什么错误，索性轻松点，就像之前说的：喜欢独自慢走的人，从来都不需要跟着人群跑。</p></li><li><p>人这一辈子，你得信这一条：留得住的不需用力，留不住的不必费力，来去随缘，强求不得。</p></li><li><p>有些话不是说出来就有用的，要看听话的人愿不愿意听。</p></li><li><p><strong>失望和生气是不一样的，生气只不过是想被人哄哄，而失望就是你说什么我都听不进去，开始理性思考这段感情存在的意义。</strong></p></li><li><p>尽管有时候日子很难，感到疲惫的时刻很多，但结束一天，洗完澡躲进被窝的时候，还是下定决心好好爱这个世界。</p></li><li><p>我们甘于平凡，却又不甘平凡的腐烂。</p></li><li><p><strong>不必纠结于遗失的美好，过好当下每一天！我们永远都是自己赛道的唯一。</strong></p></li><li><p><strong>在这个社会，凡是你想控制的，其实都控制了你。</strong></p></li><li><p>世上的事情都经不起推敲，一推敲，哪一件都藏着委屈。</p></li><li><p>相爱容易，因为五官，相处不易，因为三观。</p></li><li><p><strong>这世上最孤独的事，不是孤身一人，而是漫长的一生，没有人能理解你说的。</strong></p></li><li><p>没在一起也没关系，可能那不是我的月亮，但的确有一刻月光照在了我身上。</p></li><li><p>放下他人的最好方法，就是拾起自己。</p></li><li><p><strong>拼命工作的人最懒惰, 因为他从不思考如何工作.</strong></p></li><li><p><strong>当你做一件事第一反应是没空，并不代表你真的没空，你只是没有把它放在首要位置上。–《要忙就忙的有意义》</strong></p><ul><li>如果让你今天做一件需要花费2小时的事，你可能会回答你没空，但是当你电脑坏了你需要花2小时修电脑，你生活的一切并不会因为这两个小时而改变。（在某些计划机枪，排期很满的人身上这可能不是一个恰当的例子，但是我们很多人都不是这样的人）</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>life</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VSCode</title>
    <link href="/2021/9be43835/"/>
    <url>/2021/9be43835/</url>
    
    <content type="html"><![CDATA[<h1 id="VSCode"><a href="#VSCode" class="headerlink" title="VSCode"></a>VSCode</h1><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul><li>格式化代码 【Shift】+【Alt】+F</li></ul><h2 id="多行编辑"><a href="#多行编辑" class="headerlink" title="多行编辑"></a>多行编辑</h2><ul><li><p><code>Ctrl+Alt+UpArrow</code> <code>Ctrl+Alt+DownArrow</code></p></li><li><p><code>Alt+Click</code> 鼠标点击多行编辑</p></li><li><p><code>Ctrl+Shift+L</code> 对应文本多行编辑</p></li></ul><h2 id="行操作"><a href="#行操作" class="headerlink" title="行操作"></a>行操作</h2><ul><li><code>Shift+Alt+UpArrow</code> <code>Shift+Alt+DownArrow</code> 复制当前行</li><li><code>Alt+UpArrow</code> <code>Alt+DownArrow</code> 移动当前行</li></ul><h2 id="工作区配置"><a href="#工作区配置" class="headerlink" title="工作区配置"></a>工作区配置</h2><h3 id="setting-json"><a href="#setting-json" class="headerlink" title="setting.json"></a>setting.json</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;files.exclude&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;**/out/**&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>    <span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="c-cpp-properties-json"><a href="#c-cpp-properties-json" class="headerlink" title="c_cpp_properties.json"></a>c_cpp_properties.json</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;configurations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Linux&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;includePath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;browse&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;limitSymbolsToIncludedHeaders&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;databaseFilename&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceRoot&#125;/.vscode/.browse.c_cpp.db&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;path&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                    <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span><br>                <span class="hljs-punctuation">]</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;defines&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;xxx&quot;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;compilerPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/usr/bin/gcc&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;cStandard&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;gnu17&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;cppStandard&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;gnu++14&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;intelliSenseMode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;linux-gcc-x64&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;configurationProvider&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ms-vscode.makefile-tools&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">4</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><h2 id="无法goto-define"><a href="#无法goto-define" class="headerlink" title="无法goto define"></a>无法goto define</h2><p>VSCode 不知道是什么设置问题，在使用跳转功能时，经常只能跳转到头文件，使用 <code>Go to References</code> 也找不到定义位置，搞得索引起来很麻烦。</p><p>切换成 <code>C++ Intellisense</code> 后，发现可以得到不错的效果。<br><img src="/2021/9be43835/watermark.png" alt="在这里插入图片描述"><br>在安装过程中，需要注意以下事项：<br>【1】 需要 <code>GNU Global</code>(&gt;&#x3D;6.5) 的依赖项并添加进路径中。可以通过以下方式安装：</p><blockquote><p>  sudo apt install global</p></blockquote><p>安装之后可使用以下命令确认是否成功：</p><blockquote><p>  global –version<br>  <img src="/2021/9be43835/11f3ab43797b44d9a9746b0676881339.png" alt="在这里插入图片描述"></p></blockquote><p>【2】在 C&#x2F;C++ 项目的工作空间文件夹，运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">gtags<br><span class="hljs-comment"># --statistics 显示统计数据</span><br></code></pre></td></tr></table></figure><blockquote><p>  忽略一些文件 在代码工程的一级目录下新建文件 <code>gtags.conf</code>，按照如下格式编辑其内容：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">default:\<br>common:\<br>:skip=/arch/m68k/: \<br>:skip=/tools/:<br></code></pre></td></tr></table></figure></blockquote><p>这将会产生下列三个文件：<code>GTAGS</code>, <code>GRTAGS</code>, <code>GPATHS</code>。 如果代码有修改，再次运行 <code>gtags</code> 来更新这些 tag 文件。</p>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ide</tag>
      
      <tag>vscode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2021/69c3279c/"/>
    <url>/2021/69c3279c/</url>
    
    <content type="html"><![CDATA[<h1 id="Git-Bref"><a href="#Git-Bref" class="headerlink" title="Git Bref"></a>Git Bref</h1><p><img src="/2021/69c3279c/1352126739_7909.jpg" alt="img"></p><ul><li><p><strong>工作区：</strong>就是你在电脑里能看到的目录。</p></li><li><p><strong>暂存区：</strong>英文叫 stage 或 index。一般存放在 <strong>.git</strong> 目录下的 index 文件（.git&#x2F;index）中，所以我们把暂存区有时也叫作索引（index）。</p></li><li><p><strong>版本库：</strong>工作区有一个隐藏目录 <strong>.git</strong>，这个不算工作区，而是 Git 的版本库。</p></li></ul><p><img src="/2021/69c3279c/git-command.jpg" alt="img"></p><ul><li>workspace：工作区</li><li>staging area：暂存区&#x2F;缓存区</li><li>local repository：版本库或本地仓库</li><li>remote repository：远程仓库</li></ul><h2 id="Git-Workflows"><a href="#Git-Workflows" class="headerlink" title="Git Workflows"></a>Git Workflows</h2><p><a href="https://www.atlassian.com/git/tutorials/comparing-workflows">https://www.atlassian.com/git/tutorials/comparing-workflows</a></p><h3 id="Centralized-集中工作流"><a href="#Centralized-集中工作流" class="headerlink" title="Centralized 集中工作流"></a>Centralized 集中工作流</h3><p><img src="/2021/69c3279c/01.svg" alt="git workflow | Central and local repositories"></p><h3 id="Feature-Branch-功能分支"><a href="#Feature-Branch-功能分支" class="headerlink" title="Feature Branch 功能分支"></a>Feature Branch 功能分支</h3><p><a href="https://www.atlassian.com/git/tutorials/comparing-workflows/feature-branch-workflow">https://www.atlassian.com/git/tutorials/comparing-workflows/feature-branch-workflow</a></p><h3 id="Gitflow"><a href="#Gitflow" class="headerlink" title="Gitflow"></a>Gitflow</h3><p><a href="https://nvie.com/posts/a-successful-git-branching-model/">https://nvie.com/posts/a-successful-git-branching-model/</a></p><p><img src="/2021/69c3279c/git-model@2x.png" alt="img"></p><p><img src="/2021/69c3279c/04-Hotfix-branches.svg" alt="Git 流程工作流 - 修补程序分支"></p><h3 id="Forking-分叉"><a href="#Forking-分叉" class="headerlink" title="Forking 分叉"></a>Forking 分叉</h3><p><a href="https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow">Forking Workflow</a>通常遵循基于<a href="https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow">Gitflow Workflow</a>的分支模型。这意味着完整的功能分支将用于合并到原始项目维护者的存储库中。结果是一个分布式工作流，它为大型有机团队（包括不受信任的第三方）安全地协作提供了一种灵活的方式。这也使其成为开源项目的理想工作流程。</p><h2 id="基本命令list"><a href="#基本命令list" class="headerlink" title="基本命令list"></a>基本命令list</h2><h3 id="创建仓库命令"><a href="#创建仓库命令" class="headerlink" title="创建仓库命令"></a>创建仓库命令</h3><p>下表列出了 git 创建仓库的命令：</p><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git init</code></td><td align="left">初始化仓库</td></tr><tr><td align="left"><code>git clone</code></td><td align="left">拷贝一份远程仓库，也就是下载一个项目。</td></tr></tbody></table><hr><h3 id="提交与修改"><a href="#提交与修改" class="headerlink" title="提交与修改"></a>提交与修改</h3><p>Git 的工作就是创建和保存你的项目的快照及与之后的快照进行对比。</p><p>下表列出了有关创建与提交你的项目的快照的命令：</p><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git add</code></td><td align="left">添加文件到仓库</td></tr><tr><td align="left"><code>git status</code></td><td align="left">查看仓库当前的状态，显示有变更的文件。</td></tr><tr><td align="left"><code>git diff</code></td><td align="left">比较文件的不同，即暂存区和工作区的差异。</td></tr><tr><td align="left"><code>git commit</code></td><td align="left">提交暂存区到本地仓库。</td></tr><tr><td align="left"><code>git reset</code></td><td align="left">回退版本。</td></tr><tr><td align="left"><code>git rm</code></td><td align="left">删除工作区文件。</td></tr><tr><td align="left"><code>git mv</code></td><td align="left">移动或重命名工作区文件。</td></tr></tbody></table><h3 id="提交日志"><a href="#提交日志" class="headerlink" title="提交日志"></a>提交日志</h3><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git log</code></td><td align="left">查看历史提交记录</td></tr><tr><td align="left"><code>git blame &lt;file&gt;</code></td><td align="left">以列表形式查看指定文件的历史修改记录</td></tr></tbody></table><h3 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h3><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git remote</code></td><td align="left">远程仓库操作</td></tr><tr><td align="left"><code>git fetch</code></td><td align="left">从远程获取代码库</td></tr><tr><td align="left"><code>git pull</code></td><td align="left">下载远程代码并合并</td></tr><tr><td align="left"><code>git push</code></td><td align="left">上传远程代码并合并</td></tr></tbody></table><h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><p><img src="/2021/69c3279c/Honeyview_Ey7f6ftXIAEOd8M.jpg" alt="Honeyview_Ey7f6ftXIAEOd8M"></p><h2 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h2><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>-d</td><td>–delete：删除</td></tr><tr><td>-D</td><td>–delete –force的快捷键</td></tr><tr><td>-f</td><td>–force：强制</td></tr><tr><td>-m</td><td>–move：移动或重命名</td></tr><tr><td>-M</td><td>–move –force的快捷键</td></tr><tr><td>-r</td><td>–remote：远程</td></tr><tr><td>-a</td><td>–all：所有</td></tr></tbody></table><h2 id="Git-配置"><a href="#Git-配置" class="headerlink" title="Git 配置"></a>Git 配置</h2><h3 id="查看配置"><a href="#查看配置" class="headerlink" title="查看配置"></a>查看配置</h3><p>列出当前配置：<code>git config --list</code></p><p>列出repository配置：<code>git config --local --list</code></p><p>列出全局配置：<code>git config --global --list</code></p><p>列出系统配置：<code>git config --system --list</code></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>配置用户名：<code>git config --global user.name &quot;your name&quot;</code></p><p>配置用户邮箱：<code>git config --global user.email &quot;youremail@github.com&quot;</code></p><p>修改默认branch名: <code>git config --global init.defaultBranch main</code></p><p>git走代理: <code>git config --global http.proxy &#39;socks5://127.0.0.1:1080&#39;</code></p><h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs \">ssh-keygen -t rsa -C &quot;youremail@github.com&quot;<br></code></pre></td></tr></table></figure><p>执行命令后需要进行3次或4次确认：</p><ol><li>确认秘钥的保存路径（如果不需要改路径则直接回车）；</li><li>如果上一步置顶的保存路径下已经有秘钥文件，则需要确认是否覆盖（如果之前的秘钥不再需要则直接回车覆盖，如需要则手动拷贝到其他目录后再覆盖）；</li><li>创建密码（如果不需要密码则直接回车）；</li><li>确认密码；</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> ~/.ssh/id_rsa.pub<br></code></pre></td></tr></table></figure><h2 id="Git命令"><a href="#Git命令" class="headerlink" title="Git命令"></a>Git命令</h2><h3 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h3><p>初始化版本库</p><h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> [--template=&lt;template_directory&gt;]<br>          [-l] [-s] [--no-hardlinks] [-q] [-n] [--bare] [--mirror]<br>          [-o &lt;name&gt;] [-b &lt;name&gt;] [-u &lt;upload-pack&gt;] [--reference &lt;repository&gt;]<br>          [--dissociate] [--separate-git-dir &lt;git <span class="hljs-built_in">dir</span>&gt;]<br>          [--depth &lt;depth&gt;] [--[no-]single-branch] [--no-tags]<br>          [--recurse-submodules[=&lt;pathspec&gt;]] [--[no-]shallow-submodules]<br>          [--[no-]remote-submodules] [--<span class="hljs-built_in">jobs</span> &lt;n&gt;] [--sparse] [--[no-]reject-shallow]<br>          [--filter=&lt;filter&gt;] [--] &lt;repository&gt;<br>          [&lt;directory&gt;]<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># git clone 后面接文件夹名可以修改clone到本地的文件夹名称</span><br>git <span class="hljs-built_in">clone</span> &lt;url&gt; directory<br><br>git <span class="hljs-built_in">clone</span> --single-branch --branch &lt;branch-name&gt; &lt;remote-repo-url&gt;<br></code></pre></td></tr></table></figure><h3 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h3><p><code>git log --graph --pretty=oneline --abbrev-commit</code>可以看到分支的合并情况，包括分支合并图(–graph)、一行显示(–pretty&#x3D;oneline)、提交校验码缩略(–abbrev-commit)显示：</p><table><thead><tr><th align="left">选项</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>-&lt;n&gt;</code></td><td align="left">仅显示最近的 n 条提交。</td></tr><tr><td align="left"><code>--since</code>, <code>--after</code></td><td align="left">仅显示指定时间之后的提交。</td></tr><tr><td align="left"><code>--until</code>, <code>--before</code></td><td align="left">仅显示指定时间之前的提交。</td></tr><tr><td align="left"><code>--author</code></td><td align="left">仅显示作者匹配指定字符串的提交。</td></tr><tr><td align="left"><code>--committer</code></td><td align="left">仅显示提交者匹配指定字符串的提交。</td></tr><tr><td align="left"><code>--grep</code></td><td align="left">仅显示提交说明中包含指定字符串的提交。</td></tr><tr><td align="left"><code>-S</code></td><td align="left">仅显示添加或删除内容匹配指定字符串的提交。</td></tr></tbody></table><h3 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h3><h3 id="git-blame"><a href="#git-blame" class="headerlink" title="git blame"></a>git blame</h3><p>如果要查看指定文件的修改记录可以使用 git blame 命令，格式如下：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">git blame &lt;<span class="hljs-built_in">file</span>&gt;<br></code></pre></td></tr></table></figure><p>git blame用来追溯一个指定文件的历史修改记录。它能显示任何文件中每行最后一次修改的提交记录。 所以，如果你在代码中看到一个有 bug 的方法，你可以使用 git blame 标注这个文件，查看哪一次提交引入了这行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">可以使用 -L 指定文件的行数范围：</span><br>git blame -L n1,n2 filename<br></code></pre></td></tr></table></figure><h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><p><strong>git pull</strong> 命令用于从远程获取代码并合并本地的版本。</p><p><strong>git pull</strong> 其实就是 <strong>git fetch</strong> 和 <strong>git merge FETCH_HEAD</strong> 的简写。 命令格式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">git pull <span class="hljs-tag">&lt;<span class="hljs-name">远程主机名</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">远程分支名</span>&gt;</span>:<span class="hljs-tag">&lt;<span class="hljs-name">本地分支名</span>&gt;</span><br></code></pre></td></tr></table></figure><p>更新操作：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git pull</span><br><span class="hljs-attribute">git pull origin</span><br></code></pre></td></tr></table></figure><p>将远程主机 origin 的 master 分支拉取过来，与本地的 brantest 分支合并。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git pull origin <span class="hljs-literal">master</span>:brantest<br></code></pre></td></tr></table></figure><h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><p><strong>git push</strong> 命用于从将本地的分支版本上传到远程并合并。</p><p>命令格式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">git push <span class="hljs-tag">&lt;<span class="hljs-name">远程主机名</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">本地分支名</span>&gt;</span>:<span class="hljs-tag">&lt;<span class="hljs-name">远程分支名</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果本地分支名与远程分支名相同，则可以省略冒号：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">git push <span class="hljs-tag">&lt;<span class="hljs-name">远程主机名</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">本地分支名</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果本地版本与远程版本有差异，但又要强制推送可以使用 –force 参数：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> --force <span class="hljs-built_in">origin</span> master<br></code></pre></td></tr></table></figure><p>删除主机的分支可以使用 –delete 参数，以下命令表示删除 origin 主机的 master 分支，(慎用)：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> --<span class="hljs-built_in">delete</span> master<br></code></pre></td></tr></table></figure><h3 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h3><table><thead><tr><th>参数</th><th></th></tr></thead><tbody><tr><td><code>-v</code></td><td><strong>verbose</strong>显示详细一些的内容</td></tr><tr><td></td><td></td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote add origin your_first_git_address //将第一个git address命名为origin<br></code></pre></td></tr></table></figure><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><table><thead><tr><th>参数</th><th></th></tr></thead><tbody><tr><td>\–-all</td><td>把所有文件添加到版本控制里面</td></tr><tr><td>.</td><td>--all 同</td></tr></tbody></table><h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><p>git commit </p><table><thead><tr><th>参数</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>-a</td><td>all</td><td>受版本控制的所有文件<br>注意，新加的文件（即没有被git系统管理的文件）是不能被提交到本地仓库的</td><td></td></tr><tr><td>-m</td><td>message</td><td>提交的注释</td><td>git commit -m “this first commit”</td></tr><tr><td>- - amend</td><td></td><td>修改上次提交的注释</td><td></td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -m <span class="hljs-string">&#x27;    // 在这里直接输入回车即可</span><br><span class="hljs-string">1、第一项改动      // 以下的这些真正的comment可以在其他文本编辑器中写好粘贴过来</span><br><span class="hljs-string">2、第二项</span><br><span class="hljs-string">&#x27;</span>                // 输入这个结尾单引号后，再输入回车即可完成本次commit的提交<br></code></pre></td></tr></table></figure><h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h3><table><thead><tr><th>argv</th><th></th><th></th></tr></thead><tbody><tr><td>-u</td><td>mode</td><td></td></tr><tr><td>-uno</td><td>- 不显示未跟踪的文件。</td><td></td></tr><tr><td>-unormal</td><td>- 显示未跟踪的文件和目录。</td><td></td></tr><tr><td>-uall</td><td>- 还显示未跟踪目录中的单个文件。</td><td></td></tr></tbody></table><p>查看那些被修改那些没被修改</p><h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><p>查看与版本差异</p><h3 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h3><table><thead><tr><th>参数</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>git checkout &lt;branch&gt;</td><td></td><td>切换分支</td><td></td></tr><tr><td>git checkou -b &lt;branch&gt;</td><td>build</td><td>创建并切换分支</td><td></td></tr><tr><td>git checkout –orphan &lt;branch&gt;</td><td></td><td>创建切换到孤立的分支</td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>git checkout – &lt;file&gt;</td><td></td><td>从Staged恢复文件<br>重置全部文件用<code>-- .</code></td><td></td></tr><tr><td>git checkout HEAD – &lt;file&gt;</td><td></td><td>从HEAD恢复文件<br>重置全部文件用<code>-- .</code></td><td></td></tr></tbody></table><h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h3><table><thead><tr><th>参数</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>git branch &lt;branch&gt;</td><td></td><td>创建分支</td><td></td></tr><tr><td>git branch -d &lt;branch&gt;</td><td>delete</td><td>删除分支</td><td></td></tr><tr><td>git branch -D &lt;branch&gt;</td><td></td><td>强制删除</td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>git branch (-m | -M) &lt;oldbranch&gt; &lt;newbranch&gt;</td><td></td><td>重命名分支</td><td></td></tr><tr><td>git branch</td><td></td><td>查看当前分支</td><td></td></tr></tbody></table><h3 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h3><table><thead><tr><th>参数</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>git tag</td><td></td><td>查看标签</td><td></td></tr><tr><td>git show</td><td></td><td>查看指定标签的信息</td><td></td></tr><tr><td>git tag &lt;tag name&gt; &lt;commit id&gt;</td><td></td><td>创建 tag</td><td></td></tr><tr><td>-a</td><td></td><td>指定标签名</td><td></td></tr><tr><td>-m</td><td></td><td>指定说明文字</td><td></td></tr><tr><td>-l</td><td></td><td>列出特定版本 git tag -l “v1.4.2.*”</td><td></td></tr><tr><td>-d</td><td></td><td>删除</td><td></td></tr><tr><td>git push origin &lt;tag name&gt;</td><td></td><td>推送某个标签到远程</td><td></td></tr><tr><td>git push origin –tags</td><td></td><td>推送全部尚未推送到远程的本地标签</td><td></td></tr></tbody></table><h3 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h3><p>变基 </p><p>注: 需要切换到分支的后面, 再完成变基</p><p>git checkout &lt;branch&gt;</p><p>git rebae -d &lt;master branch&gt;</p><h3 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h3><p><img src="/2021/69c3279c/1102222-20171213190644254-2099705216.png" alt="img"></p><table><thead><tr><th>参数</th><th></th></tr></thead><tbody><tr><td>git merge &lt;branch&gt;</td><td>将分支合并到当前分支</td></tr><tr><td>git merge –no-ff  &lt;branch&gt;</td><td>禁用 快速合并模式（Fast forward）</td></tr><tr><td>git merge –ff-only  &lt;branch&gt;</td><td>快速合并(快进)</td></tr><tr><td><code>git merge --abort</code></td><td>中止这一次提交的合并(当遇到冲突时)</td></tr></tbody></table><h3 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h3><table><thead><tr><th>参数</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>git stash</td><td></td><td>将当前未提交内容藏匿</td><td></td></tr><tr><td>git stash list</td><td></td><td>藏匿 list</td><td></td></tr><tr><td>git stash drop</td><td></td><td>删除 藏匿</td><td></td></tr><tr><td>git stash apply</td><td></td><td>恢复 藏匿</td><td></td></tr><tr><td>git stash pop</td><td></td><td>恢复并删除 藏匿</td><td></td></tr></tbody></table><h3 id="git-restore-重置文件"><a href="#git-restore-重置文件" class="headerlink" title="git restore 重置文件"></a>git restore 重置文件</h3><p>类似 git checkout – &lt;file&gt;     重置文件</p><p>git restore &lt;file&gt;撤销工作区的修改，从暂存区恢复至工作区，如果工作区没有则从版本库恢复至工作区。</p><p>git restore –staged &lt;file&gt;用作清除暂存区的文件，不影响工作区以及版本库中的文件</p><p><img src="/2021/69c3279c/542.png" alt="img"></p><h3 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h3><p><strong>原理：</strong> git revert是用于“反做”某一个版本，以达到撤销该版本的修改的目的。比如，我们 commit 了三个版本（版本一、版本二、 版本三），突然发现版本二不行（如：有bug），想要撤销版本二，但又不想影响撤销版本三的提交，就可以用 git revert 命令来反做版本二，生成新的版本四，这个版本四里会保留版本三的东西，但撤销了版本二的东西。如下图所示：</p><p><img src="/2021/69c3279c/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwNDE0MjA1ODE2MTg4.png" alt="这里写图片描述"></p><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><p><strong>原理：</strong> git reset的作用是修改HEAD的位置，即将HEAD指向的位置改变为之前存在的某个版本，如下图所示，假设我们要回退到版本一</p><p><img src="/2021/69c3279c/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwNDE0MjEyMjIxMDMz.png" alt="这里写图片描述"></p><p>在Git中，用<code>HEAD</code>表示当前版本</p><p>版本回退 HEAD往前回退一个版本(同理这里可以写对应的版本号) <code>git reset -–hard HEAD^</code></p><table><thead><tr><th>参数</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>–- hard</td><td></td><td>硬重置</td><td></td></tr><tr><td>–- soft</td><td></td><td></td><td></td></tr><tr><td>–- mixed</td><td></td><td></td><td></td></tr><tr><td>–- merge</td><td></td><td></td><td></td></tr><tr><td>–- keep</td><td></td><td></td><td></td></tr></tbody></table><h3 id="git-ignore"><a href="#git-ignore" class="headerlink" title="git - .ignore"></a>git - .ignore</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">此为注释 – 将被 Git 忽略</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">忽略所有 .a 结尾的文件</span><br>*.a<br><span class="hljs-meta prompt_"># </span><span class="language-bash">但 lib.a 除外</span><br>!lib.a<br><span class="hljs-meta prompt_"># </span><span class="language-bash">仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span><br>/TODO<br><span class="hljs-meta prompt_"># </span><span class="language-bash">忽略 build/ 目录下的所有文件</span><br>build/<br><span class="hljs-meta prompt_"># </span><span class="language-bash">会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span><br>doc/*.txt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">忽略 doc/ 目录下所有扩展名为 txt 的文件</span><br>doc/**/*.txt<br></code></pre></td></tr></table></figure><h3 id="git-switch"><a href="#git-switch" class="headerlink" title="git switch"></a>git switch</h3><p>git switch 切换分支 远程有而本地没有的分支，而如果要从远程分支建一个同名的本地分支，并且关联远程分支</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xquery">git <span class="hljs-keyword">switch</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">branchName</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>git switch 创建一个新分支并切换到该新分支 </p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">git <span class="hljs-keyword">switch</span> -<span class="hljs-keyword">c</span> &lt;branchName&gt;<br></code></pre></td></tr></table></figure><p>git switch 以一个提交commit来创建一个分支</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">git <span class="hljs-keyword">switch</span> -<span class="hljs-keyword">c</span> test<span class="hljs-number">3</span> e<span class="hljs-number">053</span>cf<span class="hljs-number">128</span>d<span class="hljs-number">2</span>ad<span class="hljs-number">9</span>d<span class="hljs-number">35e2</span>f<span class="hljs-number">94878569596</span>fb<span class="hljs-number">32</span>f<span class="hljs-number">4306</span><br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">操作</th><th align="left">2.23-</th><th align="left">2.23+</th></tr></thead><tbody><tr><td align="left">管理分支</td><td align="left">git branch</td><td align="left">git branch</td></tr><tr><td align="left">切换分支</td><td align="left">git checkout</td><td align="left">git switch</td></tr><tr><td align="left">新建+切换分支</td><td align="left">git checkout -b</td><td align="left">git switch -c</td></tr><tr><td align="left">切换到commit id</td><td align="left">git checkout</td><td align="left">git checkout</td></tr></tbody></table><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><h2 id="修改分支指针"><a href="#修改分支指针" class="headerlink" title="修改分支指针"></a>修改分支指针</h2><p>git branch -f 分支名 commitID</p><p>作用是将其他分支上的本地代码硬重置到某个commitId下，不能重置本分支。比如我dev分支上某个节点的commitId叫 devID1</p><p>然后 git branch -f master devID1<br>那么master上的代码就会和dev一样，并且历史记录也会一样，只是dev分支上的代码可能会比master上的新一点，因为是重置的commitId</p><h2 id="git-status-显示不了汉字"><a href="#git-status-显示不了汉字" class="headerlink" title="git status 显示不了汉字"></a>git status 显示不了汉字</h2><p>git bash 终端输入命令：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">git config --global core.quotepath <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>在git仓库文件夹内打开git bash，在git branch的界面中右击空白处，弹出菜单，选择option，编码设定为 gb2312。</p><h2 id="git-ssh-非标端口"><a href="#git-ssh-非标端口" class="headerlink" title="git ssh 非标端口"></a>git ssh 非标端口</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone ssh://git@hostname:port/…/xxx.git<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">e.g.</span><br>git clone ssh://git@192.168.1.220:10022/frank/tools.git<br></code></pre></td></tr></table></figure><h2 id="验证ssh链接"><a href="#验证ssh链接" class="headerlink" title="验证ssh链接"></a>验证ssh链接</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh -T git@github.com<br>ssh -T ssh://git@192.168.1.220:10022<br></code></pre></td></tr></table></figure><h2 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push origin --delete branch_name<br></code></pre></td></tr></table></figure><h2 id="删除全部历史提交记录"><a href="#删除全部历史提交记录" class="headerlink" title="删除全部历史提交记录"></a>删除全部历史提交记录</h2><ol><li>尝试  运行 <code> git checkout --orphan latest_branch</code></li><li>添加所有文件<code>git add -A</code></li><li>提交更改<code>git commit -am &quot;commit message&quot;</code></li><li>删除分支<code>git branch -D main</code></li><li>将当前分支重命名<code>git branch -m main</code></li><li>最后，强制更新存储库。<code>git push -f origin main</code></li></ol><h2 id="清理仓库"><a href="#清理仓库" class="headerlink" title="!清理仓库!"></a>!清理仓库!</h2><p>!谨慎操作! !谨慎操作! !谨慎操作! !谨慎操作! !谨慎操作!</p><ol start="0"><li>可以先查看一下本地仓库的大小</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">du</span> -sh .git<br></code></pre></td></tr></table></figure><ol><li>移除本地仓库中指向旧提交的剩余refs，<code>git for-each-ref</code> 会打印仓库中匹配<code>refs/original</code>的所有refs，并使用<code>delete</code>作为前缀，此命令通过管道传送到 <code>git update-ref</code> 命令，该命令会移除所有指向旧commit的引用。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git for-each-ref --format=<span class="hljs-string">&#x27;delete %(refname)&#x27;</span> refs/original | git update-ref --stdin<br></code></pre></td></tr></table></figure><ol start="2"><li>以下命令会使reflog到期，因为它依然包含着对旧commit的引用。使用<code>--expire=now</code> 参数，确保它在目前为止到期了。如果没有该参数，只会移除超过90天的reflog。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reflog expire --expire=now --all<br></code></pre></td></tr></table></figure><ol start="3"><li>现在本地仓库依然包含着所有旧commit的对象，但已经没有引用指向它们了，这些对象需要被删除掉。此时可以使用 <code>git gc</code> 命令，Git的垃圾回收器会删除这些没有引用指向的对象。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git gc --prune=now<br></code></pre></td></tr></table></figure><p>​<code>gc</code>使用<code>--prune</code> 参数来清理特定时期的对象，默认情况下为2周，指定<code>now</code>将删除所有这些对象而没有时期限制。</p><ol start="4"><li><code>du -sh .git</code>此时，.git文件的大小只有104k了。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">du</span> -sh .git<br><span class="hljs-comment"># 104K    .git</span><br></code></pre></td></tr></table></figure><ol start="5"><li>如果确认所做的删除大文件操作没有问题，就可以提交到远程仓库了，一旦提交，再也没有办法恢复到原来的状态，一定要小心谨慎！一定要小心谨慎！一定要小心谨慎！</li><li>先进行备份工作，以免出现问题：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/Desktop/<br><span class="hljs-built_in">mkdir</span> gitthin_mirror &amp;&amp; <span class="hljs-built_in">cd</span> gitthin_mirror<br>git <span class="hljs-built_in">clone</span> --mirror git@gitee.com:coderhony/gitthin.git<br></code></pre></td></tr></table></figure><ol start="7"><li>再回到刚才做的已经瘦身的Git仓库</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/Desktop/gitthin/gitthin<br></code></pre></td></tr></table></figure><ol start="8"><li>把已瘦身的仓库同步到远程仓库，使用<code>—mirror</code>参数：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push --mirror &lt;url&gt;<br></code></pre></td></tr></table></figure><ol start="9"><li>为了确保都已同步，再执行以下命令：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push --all --force<br><span class="hljs-comment"># Everything up-to-date</span><br>git push --tags --force<br><span class="hljs-comment"># Everything up-to-date</span><br></code></pre></td></tr></table></figure><h2 id="一台电脑两个Github账号"><a href="#一台电脑两个Github账号" class="headerlink" title="一台电脑两个Github账号"></a>一台电脑两个Github账号</h2><ul><li><p>生成两个ssh key</p></li><li><p>编辑config文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Default GitHub</span><br>Host github.com<br>HostName github.com<br>User git<br>IdentityFile ~/.ssh/id_rsa<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"> Jack-InGitHub!</span> <br>Host pq.github.com<br>HostName github.com<br>User git<br>IdentityFile ~/.ssh/id_rsa_a<br></code></pre></td></tr></table></figure><ul><li>github.com 用id_rsa密钥</li><li>pq.github.com 用id_rsa_a密钥</li></ul></li></ul><ul><li><p>原来<code>git@github.com:Jack-InGitHub/test.git</code></p><p>现在<code>git@pq.github.com:Jack-InGitHub/test.git</code></p></li><li><p>记得再配置不同的邮箱名</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --<span class="hljs-built_in">local</span> user.name <span class="hljs-string">&quot;username&quot;</span><br>git config --<span class="hljs-built_in">local</span> user.email user@email.com<br></code></pre></td></tr></table></figure><h2 id="利用管道删除全部本地分支"><a href="#利用管道删除全部本地分支" class="headerlink" title="利用管道删除全部本地分支"></a>利用管道删除全部本地分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout master<br>git branch | grep -v <span class="hljs-string">&#x27;master&#x27;</span> | xargs git branch -D<br></code></pre></td></tr></table></figure><h2 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h2><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment"># 把旧仓库被分成本地git文件目录</span><br>git <span class="hljs-keyword">clone</span> <span class="hljs-title">--mirror</span> 旧的git地址<br><br><span class="hljs-comment"># 推动本地目录到新的地址</span><br>cd xxx.git<br>git push --mirror 新的git地址<br><br><span class="hljs-comment"># 以上就完成了单个仓库的迁移</span><br></code></pre></td></tr></table></figure><h2 id="删除未追踪的文件"><a href="#删除未追踪的文件" class="headerlink" title="删除未追踪的文件"></a>删除未追踪的文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">git clean -f -d<br><span class="hljs-comment"># -d 递归清理</span><br><span class="hljs-comment"># -f = --force 强制清理</span><br>-d<br>    Normally, when no &lt;path&gt; is specified, git clean will not recurse into untracked directories to avoid removing too much. Specify -d to have it recurse into such directories as well. If any paths are specified, -d is irrelevant; all untracked files matching the specified paths (with exceptions <span class="hljs-keyword">for</span> nested git directories mentioned under --force) will be removed.<br><br>-f<br>    --force<br>    If the Git configuration variable clean.requireForce is not <span class="hljs-built_in">set</span> to <span class="hljs-literal">false</span>, git clean will refuse to delete files or directories unless given -f or -i. Git will refuse to modify untracked nested git repositories (directories with a .git subdirectory) unless a second -f is given.<br></code></pre></td></tr></table></figure><h2 id="子模块-子仓库"><a href="#子模块-子仓库" class="headerlink" title="子模块 子仓库"></a>子模块 子仓库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git submodule <span class="hljs-built_in">help</span><br>usage: git submodule [--quiet] [--cached]<br>   or: git submodule [--quiet] add [-b &lt;branch&gt;] [-f|--force] [--name &lt;name&gt;] [--reference &lt;repository&gt;] [--] &lt;repository&gt; [&lt;path&gt;]<br>   or: git submodule [--quiet] status [--cached] [--recursive] [--] [&lt;path&gt;...]<br>   or: git submodule [--quiet] init [--] [&lt;path&gt;...]<br>   or: git submodule [--quiet] deinit [-f|--force] (--all| [--] &lt;path&gt;...)<br>   or: git submodule [--quiet] update [--init] [--remote] [-N|--no-fetch] [-f|--force] [--checkout|--merge|--rebase] [--[no-]recommend-shallow] [--reference &lt;repository&gt;] [--recursive] [--[no-]single-branch] [--] [&lt;path&gt;...]<br>   or: git submodule [--quiet] set-branch (--default|--branch &lt;branch&gt;) [--] &lt;path&gt;<br>   or: git submodule [--quiet] set-url [--] &lt;path&gt; &lt;newurl&gt;<br>   or: git submodule [--quiet] summary [--cached|--files] [--summary-limit &lt;n&gt;] [commit] [--] [&lt;path&gt;...]<br>   or: git submodule [--quiet] foreach [--recursive] &lt;<span class="hljs-built_in">command</span>&gt;<br>   or: git submodule [--quiet] <span class="hljs-built_in">sync</span> [--recursive] [--] [&lt;path&gt;...]<br>   or: git submodule [--quiet] absorbgitdirs [--] [&lt;path&gt;...]<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 子模块的添加</span><br>git submodule add [-b branch] &lt;url&gt; &lt;path&gt;<br><span class="hljs-comment"># 子模块的初始化&amp;更新下载</span><br>git submodule init<br>git submodule update<br><span class="hljs-comment"># </span><br></code></pre></td></tr></table></figure><ul><li>还有更简单一点的方式。 如果给 <code>git clone</code> 命令传递 <code>--recurse-submodules</code> 选项，它就会自动初始化并更新仓库中的每一个子模块， 包括可能存在的嵌套子模块。</li></ul><h2 id="合并没有相关历史的提交"><a href="#合并没有相关历史的提交" class="headerlink" title="合并没有相关历史的提交"></a>合并没有相关历史的提交</h2><p>将test2分支合并到master分支中 <code>git merge test2 --allow-unrelated-histories </code></p><h4 id="合并两个没有相同历史的Git仓库"><a href="#合并两个没有相同历史的Git仓库" class="headerlink" title="合并两个没有相同历史的Git仓库"></a><a href="https://www.cnblogs.com/masahiro/p/12155758.html">合并两个没有相同历史的Git仓库</a></h4><p>首先在需要合并的仓库中增加另外一个远程仓库 <code>git remote add test2 http://git.xxx.xxx/test2 </code></p><p>然后将test2的仓库拉取到本地 <code>git fetch test2 </code></p><p>创建本地分支 <code>git checkout -b test2 test2/master </code></p><p>切换到目标分区 <code>git checkout master </code></p><p>将test2分支合并到master分支中<code>git merge test2 --allow-unrelated-histories</code></p><p>至此分支合并完成,只需将分支提交到服务器即可</p><h2 id="将init后默认branch设定成为main"><a href="#将init后默认branch设定成为main" class="headerlink" title="将init后默认branch设定成为main"></a>将init后默认branch设定成为main</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global init.defaultBranch main<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 把当前master分支改名为main 其中-M的意思是移动或者重命名当前分支</span><br>git branch -M main<br></code></pre></td></tr></table></figure><h2 id="让git流量走代理-SSH的代理"><a href="#让git流量走代理-SSH的代理" class="headerlink" title="让git流量走代理 SSH的代理"></a>让git流量走代理 SSH的代理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># socks代理</span><br>git config --global http.proxy <span class="hljs-string">&#x27;socks5://127.0.0.1:1080&#x27;</span><br>git config --global https.proxy <span class="hljs-string">&#x27;socks5://127.0.0.1:1080&#x27;</span><br><span class="hljs-comment"># http/https代理</span><br>git config --global http.proxy http://127.0.0.1:8080<br>git config --global https.proxy https://127.0.0.1:8080<br></code></pre></td></tr></table></figure><p>也可以直接修改~&#x2F;.gitconfig文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi ~/.gitconfig<br></code></pre></td></tr></table></figure><p>新建或修改这两项配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">[http]<br>proxy = socks5://127.0.0.1:1080<br><br>[https]<br>proxy = socks5://127.0.0.1:1080<br></code></pre></td></tr></table></figure><p>如果要取消代理：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global --<span class="hljs-built_in">unset</span> http.proxy<br>git config --global --<span class="hljs-built_in">unset</span> https.proxy<br></code></pre></td></tr></table></figure><p>带参数是临时的，修改配置文件是永久变更，修改后最好重启git 设置生效。</p><p>查看配置信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config -l --global<br></code></pre></td></tr></table></figure><p>执行查看代理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config -l<br></code></pre></td></tr></table></figure><h3 id="SSH流量"><a href="#SSH流量" class="headerlink" title="SSH流量"></a>SSH流量</h3><p>上面的方法只代理了http和https的流量, 我们用ssh协议的较多这就需要去代理ssh流量了</p><p>配置ssh走代理我们就需要去配置 ssh 程序(而不是git), 我们需要在 <code>~/.ssh/config</code> 文件中设置 <code>ProxyCommand</code> 选项。</p><ul><li><p>Linux 和 macOS 是通过 <code>nc</code> 来执行 <code>ProxyCommand</code> 的，</p></li><li><p>Windows 下则是通过 <code>connect</code>。</p></li></ul><h4 id="Linux-SSH-配置"><a href="#Linux-SSH-配置" class="headerlink" title="Linux SSH 配置"></a>Linux SSH 配置</h4><p>编辑 <code>~/.ssh/config</code> 文件,给文件加上如下对应内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Host 后面 接的 github.com 是指定要走代理的仓库域名。</span><br><span class="hljs-comment"># 在 ProxyCommand 中，Linux 和 macOS 用户用的是 nc。</span><br><span class="hljs-comment"># -X 选项后面接的是 connect. 意思是 HTTPS 代理。</span><br><span class="hljs-comment"># -x 选项后面加上代理地址和端口号。</span><br><span class="hljs-comment"># 在调用 ProxyCommand 时，%h 和 %p 将会被自动替换为目标主机名和 SSH 命令指定的端口（%h 和 %p 不要修改，保留原样即可）。</span><br>Host github.com<br>    User git<br>    ProxyCommand nc -X connect -x 127.0.0.1:7890 %h %p<br><span class="hljs-comment"># -X 选项后面接的是 5. 意思是 socks5 代理。</span><br>Host github.com<br>    User git<br>    ProxyCommand nc -X 5 -x 127.0.0.1:7891 %h %p<br></code></pre></td></tr></table></figure><h4 id="Windows-SSH-配置"><a href="#Windows-SSH-配置" class="headerlink" title="Windows SSH 配置"></a>Windows SSH 配置</h4><p>编辑 <code>~/.ssh/config</code> 文件，然后增加如下内容：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment"># Host 后面 接的 github.com 是指定要走代理的仓库域名。</span><br><span class="hljs-comment"># 在 ProxyCommand 中，Windows 用户用的是 connect。</span><br><span class="hljs-comment"># -S代表的是socks5 -H 选项的意思是 HTTP 代理 </span><br><span class="hljs-comment"># 在调用 ProxyCommand 时，%h 和 %p 将会被自动替换为目标主机名和 SSH 命令指定的端口（%h 和 %p 不要修改，保留原样即可）。</span><br>Host github.com<br>ProxyCommand <span class="hljs-keyword">connect</span> -S <span class="hljs-number">127.0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">1080</span> %h %p<br>Host github.com<br>ProxyCommand <span class="hljs-keyword">connect</span> -H <span class="hljs-number">127.0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">1080</span> %h %p<br></code></pre></td></tr></table></figure><h2 id="patch的使用"><a href="#patch的使用" class="headerlink" title="patch的使用"></a>patch的使用</h2><p>patch文件其实就是运行<code>git diff</code>控制台输出的信息并保存的文件.</p><p><strong>patch的创建</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git diff &gt; my_custom_patch_file.patch<br></code></pre></td></tr></table></figure><p><strong>patch的应用</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git apply patch_file.patch <br></code></pre></td></tr></table></figure><p><strong>patch出现一些提示, 这个提示的意思</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">patch:19: trailing whitespace.<br>warning: 1 line adds whitespace errors.<br><br><span class="hljs-comment"># 告警的含义是提示有空格在行尾出现。</span><br><span class="hljs-comment"># 不用太担心这个问题并不大</span><br><span class="hljs-comment"># 可以使用 --no-verify 开关绕过此问题</span><br></code></pre></td></tr></table></figure><h2 id="git-branch-不单独输出在控制台-而是像新开页面一样"><a href="#git-branch-不单独输出在控制台-而是像新开页面一样" class="headerlink" title="git branch 不单独输出在控制台 而是像新开页面一样"></a>git branch 不单独输出在控制台 而是像新开页面一样</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global pager.branch <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h2 id="一次推送多个远程仓库"><a href="#一次推送多个远程仓库" class="headerlink" title="一次推送多个远程仓库"></a>一次推送多个远程仓库</h2><hr><p><strong>使用 <code>git remote set-url</code> 命令</strong></p><p>2.1# 删除方法一的 <code>oschina</code> 远程仓库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote <span class="hljs-built_in">rm</span> oschina<br></code></pre></td></tr></table></figure><p>2.2# 使用如下命令添加远程仓库。</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">git</span> <span class="hljs-string">remote</span> <span class="hljs-built_in">set-url</span> <span class="hljs-built_in">--add</span> <span class="hljs-string">github</span> <span class="hljs-string">https</span>://<span class="hljs-string">git</span>.<span class="hljs-string">oschina</span>.<span class="hljs-string">net</span>/<span class="hljs-string">zxbetter</span>/<span class="hljs-string">test</span>.<span class="hljs-string">git</span><br></code></pre></td></tr></table></figure><p>2.3# 查看远程仓库情况。可以看到 <code>github</code> 远程仓库有两个 <code>push</code> 地址。<em>这种方法的好处是每次只需要 <code>push</code> 一次就行了。</em></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">git remote -v<br>github  https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/zxbetter/</span>test.git (fetch)<br>github  https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/zxbetter/</span>test.git (push)<br>github  https:<span class="hljs-regexp">//gi</span>t.oschina.net<span class="hljs-regexp">/zxbetter/</span>test.git (push)<br></code></pre></td></tr></table></figure><hr><p><strong>修改配置文件</strong></p><p>打开 <code>.git/config</code> 找到 <code>[remote &quot;github&quot;]</code>，添加对应的 <code>url</code> 即可，效果如下。这种方法其实和方法二是一样的。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">[remote <span class="hljs-string">&quot;github&quot;</span>]<br>    url = https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/zxbetter/</span>test.git<br>    fetch = +refs<span class="hljs-regexp">/heads/</span>*:refs<span class="hljs-regexp">/remotes/gi</span>thub/*<br>    url = https:<span class="hljs-regexp">//gi</span>t.oschina.net<span class="hljs-regexp">/zxbetter/</span>test.git<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派4B GPIO库 Wiringpi Oops -  Unable to Determine Board Type</title>
    <link href="/2021/d8eac117/"/>
    <url>/2021/d8eac117/</url>
    
    <content type="html"><![CDATA[<p>关键词:<br>树莓派4B GPIO库 wiringpi Oops - unable to determine board type… model_ 17</p><h1 id="先说解决方案"><a href="#先说解决方案" class="headerlink" title="先说解决方案"></a>先说解决方案</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /tmp<br>wget https://project-downloads.drogon.net/wiringpi-latest.deb<br>sudo dpkg -i wiringpi-latest.deb<br></code></pre></td></tr></table></figure><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p><a href="http://wiringpi.com/wiringpi-updated-to-2-52-for-the-raspberry-pi-4b/">官网给的解释</a> <a href="http://wiringpi.com/wiringpi-updated-to-2-52-for-the-raspberry-pi-4b/">http://wiringpi.com/wiringpi-updated-to-2-52-for-the-raspberry-pi-4b/</a></p><p>树莓派4B 用wiringpi这个GPIO库的时候无法正常使用，我是在用作树莓派pwm风扇调速的时候发现一直输出不了pwm，示波器抓波形发现也不对，检查原因的时候发现 <code>gpio readall</code>输出报错，最后官方文档说到<strong>树莓派4B</strong>需要保证<strong>2.52版本</strong>及以上才能适配(<code>gpio -v</code>查看版本)，apt直接安装的似乎还没更新最新版本只到2.50，不太清楚为什么一年了这源都还没更新</p>]]></content>
    
    
    <categories>
      
      <category>raspberry</category>
      
    </categories>
    
    
    <tags>
      
      <tag>raspberry</tag>
      
      <tag>wiringpi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派4B PWM温控风扇 Wiringpi库 PWM调整频率 54M PWM频率不对</title>
    <link href="/2021/b0f7a103/"/>
    <url>/2021/b0f7a103/</url>
    
    <content type="html"><![CDATA[<p>关键词:<br>树莓派4B PWM温控风扇 wiringpi库 PWM调整频率 54M PWM频率不对</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>很多博客文章都是说树莓派PWM是按<strong>19.2M</strong>基频率来算的，今天用逻辑分析仪抓了一下波形后发现频率有问题，然后按测得的频率反推，算出来我这里好像是按<strong>54M</strong>的时钟频率来的，不清楚是什么情况。我这里的环境是<code>wiringpi=2.52</code> + <code>树莓派4B</code> + <code>Linux raspberrypi 5.10.52-v7l+ #1440 SMP Tue Jul 27 09:55:21 BST 2021 armv7l GNU/Linux</code></p><p><a href="https://www.cnblogs.com/miaoxiong/p/10556072.html">PWM 19.2M时钟的原文</a> <a href="https://www.cnblogs.com/miaoxiong/p/10556072.html">https://www.cnblogs.com/miaoxiong/p/10556072.html</a></p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>思路就是读取cpu温度的文件，根据不同温度来控制PWM控制风扇转停，这个编译下来跑起来<code>htop</code>看cpu占用一直等于0，对比原来python写的温控风扇2% 3%的cpu占用在跳，没想到差距这么大。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;wiringPi.h&gt;</span></span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FAN_PIN         1</span><br><span class="hljs-comment">// Hz</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PWM_FRQ         (200ul)</span><br><span class="hljs-comment">// frq = 54M / PWM_RANG / divisor</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PWM_RANG        (100ul)</span><br><span class="hljs-comment">// temperature</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TEMP_PATH <span class="hljs-string">&quot;/sys/class/thermal/thermal_zone0/temp&quot;</span></span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFF_MAX_SIZE   32u</span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DBG_LOG(format, ...)      do&#123; printf(format, ##__VA_ARGS__ ); &#125;while(0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DBG_LOG(format, ...)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">GetTemperature</span><span class="hljs-params">(<span class="hljs-type">int</span> *temp)</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">GetDuty</span><span class="hljs-params">(<span class="hljs-type">int</span> temp)</span>;<br><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> Duty = <span class="hljs-number">0</span>;<br>FILE *pFile = <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">char</span> buff[BUFF_MAX_SIZE] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">float</span> fTemperature = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> Temperature = <span class="hljs-number">0</span>;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    DBG_LOG(<span class="hljs-string">&quot;Raspberry Pi wiringPi PWM test program\n&quot;</span>);<br>    <span class="hljs-keyword">if</span> (wiringPiSetup() == <span class="hljs-number">-1</span>)<br>    &#123;<br>        DBG_LOG(<span class="hljs-string">&quot;GPIO setup error!\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">2</span>);<br>    &#125;<br>    pinMode(FAN_PIN, PWM_OUTPUT);<br>    pwmSetMode(PWM_MODE_MS);<br>    pwmSetRange(PWM_RANG);                       <span class="hljs-comment">//base frq 54M</span><br>    pwmSetClock(<span class="hljs-number">54000000</span>/PWM_RANG/PWM_FRQ);<br>    pwmWrite(FAN_PIN, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        GetTemperature(&amp;Temperature);<br>        Duty = GetDuty(Temperature);<br><br>        pwmWrite(FAN_PIN, Duty);<br>        DBG_LOG(<span class="hljs-string">&quot;Temp=%d Duty=%d\n&quot;</span>, Temperature, Duty);<br>        delay(<span class="hljs-number">1000</span>*<span class="hljs-number">10</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">GetTemperature</span><span class="hljs-params">(<span class="hljs-type">int</span> *temp)</span><br>&#123;<br>    pFile = fopen(TEMP_PATH, <span class="hljs-string">&quot;r&quot;</span>);<br>    <span class="hljs-keyword">if</span>(pFile == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        DBG_LOG(<span class="hljs-string">&quot;file can&#x27;t open PATH=%s p=%p\n&quot;</span>, TEMP_PATH, pFile);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    fgets(buff, BUFF_MAX_SIZE, pFile);<br>    *temp = (<span class="hljs-type">int</span>)(atoi(buff)/<span class="hljs-number">1000.0</span>+<span class="hljs-number">0.5</span>);<br>    fclose(pFile);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">GetDuty</span><span class="hljs-params">(<span class="hljs-type">int</span> temp)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(temp &gt;= <span class="hljs-number">60</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(temp &gt;= <span class="hljs-number">55</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">80</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(temp &gt;= <span class="hljs-number">53</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">70</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(temp &gt;= <span class="hljs-number">50</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">60</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(temp &gt;= <span class="hljs-number">49</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">50</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后编译一下<br><code>gcc -Wall -O -o fan fan.c   -lwiringPi </code></p><p>再加个开机启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo nano /etc/rc.local<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在文件<span class="hljs-built_in">exit</span>前加上 fan程序</span><br>sudo ./path/fan &amp;<br></code></pre></td></tr></table></figure><p>这个温度控制不是很好，转转停停的(<em>估计是PWM值太小风扇转的不好, 尝试加电容电感应该会好些</em>)</p>]]></content>
    
    
    <categories>
      
      <category>raspberry</category>
      
    </categories>
    
    
    <tags>
      
      <tag>raspberry</tag>
      
      <tag>wiringpi</tag>
      
      <tag>pwm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RT-Thread</title>
    <link href="/2021/42e53028/"/>
    <url>/2021/42e53028/</url>
    
    <content type="html"><![CDATA[<h1 id="RT-Thread-目录"><a href="#RT-Thread-目录" class="headerlink" title="RT-Thread 目录"></a>RT-Thread 目录</h1><p>[TOC]</p><h1 id="内核简介"><a href="#内核简介" class="headerlink" title="内核简介"></a>内核简介</h1><h2 id="自动初始化机制"><a href="#自动初始化机制" class="headerlink" title="自动初始化机制"></a>自动初始化机制</h2><table><thead><tr><th><strong>初始化顺序</strong></th><th><strong>宏接口</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>1</td><td>INIT_BOARD_EXPORT(fn)</td><td>非常早期的初始化，此时调度器还未启动</td></tr><tr><td>2</td><td>INIT_PREV_EXPORT(fn)</td><td>主要是用于纯软件的初始化、没有太多依赖的函数</td></tr><tr><td>3</td><td>INIT_DEVICE_EXPORT(fn)</td><td>外设驱动初始化相关，比如网卡设备</td></tr><tr><td>4</td><td>INIT_COMPONENT_EXPORT(fn)</td><td>组件初始化，比如文件系统或者 LWIP</td></tr><tr><td>5</td><td>INIT_ENV_EXPORT(fn)</td><td>系统环境初始化，比如挂载文件系统</td></tr><tr><td>6</td><td>INIT_APP_EXPORT(fn)</td><td>应用初始化，比如 GUI 应用</td></tr></tbody></table><h2 id="内核对象管理架构"><a href="#内核对象管理架构" class="headerlink" title="内核对象管理架构"></a>内核对象管理架构</h2><p>派生和继承</p><p><img src="/2021/42e53028/03kernel_object-1608970713169.png" alt="RT-Thread 的内核对象容器及链表"></p><p><img src="/2021/42e53028/03kernel_object2-1608970663476.png" alt="03kernel_object2"></p><h2 id="内核rtconfig-h配置"><a href="#内核rtconfig-h配置" class="headerlink" title="内核rtconfig.h配置"></a>内核rtconfig.h配置</h2><p>（1）RT-Thread 内核部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 表示内核对象的名称的最大长度，若代码中对象名称的最大长度大于宏定义的长度，</span><br><span class="hljs-comment"> * 多余的部分将被截掉。*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_NAME_MAX 8</span><br><br><span class="hljs-comment">/* 字节对齐时设定对齐的字节个数。常使用 ALIGN(RT_ALIGN_SIZE) 进行字节对齐。*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_ALIGN_SIZE 4</span><br><br><span class="hljs-comment">/* 定义系统线程优先级数；通常用 RT_THREAD_PRIORITY_MAX-1 定义空闲线程的优先级 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_THREAD_PRIORITY_MAX 32</span><br><br><span class="hljs-comment">/* 定义时钟节拍，为 100 时表示 100 个 tick 每秒，一个 tick 为 10ms */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_TICK_PER_SECOND 100</span><br><br><span class="hljs-comment">/* 检查栈是否溢出，未定义则关闭 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USING_OVERFLOW_CHECK</span><br><br><span class="hljs-comment">/* 定义该宏开启 debug 模式，未定义则关闭 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_DEBUG</span><br><span class="hljs-comment">/* 开启 debug 模式时：该宏定义为 0 时表示关闭打印组件初始化信息，定义为 1 时表示启用 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_DEBUG_INIT 0</span><br><span class="hljs-comment">/* 开启 debug 模式时：该宏定义为 0 时表示关闭打印线程切换信息，定义为 1 时表示启用 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_DEBUG_THREAD 0</span><br><br><span class="hljs-comment">/* 定义该宏表示开启钩子函数的使用，未定义则关闭 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USING_HOOK</span><br><br><span class="hljs-comment">/* 定义了空闲线程的栈大小 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IDLE_THREAD_STACK_SIZE 256</span><br></code></pre></td></tr></table></figure><p>（2）线程间同步与通信部分，该部分会使用到的对象有信号量、互斥量、事件、邮箱、消息队列、信号等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 定义该宏可开启信号量的使用，未定义则关闭 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USING_SEMAPHORE</span><br><br><span class="hljs-comment">/* 定义该宏可开启互斥量的使用，未定义则关闭 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USING_MUTEX</span><br><br><span class="hljs-comment">/* 定义该宏可开启事件集的使用，未定义则关闭 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USING_EVENT</span><br><br><span class="hljs-comment">/* 定义该宏可开启邮箱的使用，未定义则关闭 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USING_MAILBOX</span><br><br><span class="hljs-comment">/* 定义该宏可开启消息队列的使用，未定义则关闭 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USING_MESSAGEQUEUE</span><br><br><span class="hljs-comment">/* 定义该宏可开启信号的使用，未定义则关闭 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USING_SIGNALS</span><br></code></pre></td></tr></table></figure><p>（3）内存管理部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 开启静态内存池的使用 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USING_MEMPOOL</span><br><br><span class="hljs-comment">/* 定义该宏可开启两个或以上内存堆拼接的使用，未定义则关闭 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USING_MEMHEAP</span><br><br><span class="hljs-comment">/* 开启小内存管理算法 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USING_SMALL_MEM</span><br><br><span class="hljs-comment">/* 关闭 SLAB 内存管理算法 */</span><br><span class="hljs-comment">/* #define RT_USING_SLAB */</span><br><br><span class="hljs-comment">/* 开启堆的使用 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USING_HEAP</span><br></code></pre></td></tr></table></figure><p>（4）内核设备对象</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 表示开启了系统设备的使用 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USING_DEVICE</span><br><br><span class="hljs-comment">/* 定义该宏可开启系统控制台设备的使用，未定义则关闭 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USING_CONSOLE</span><br><span class="hljs-comment">/* 定义控制台设备的缓冲区大小 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_CONSOLEBUF_SIZE 128</span><br><span class="hljs-comment">/* 控制台设备的名称 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_CONSOLE_DEVICE_NAME <span class="hljs-string">&quot;uart1&quot;</span></span><br></code></pre></td></tr></table></figure><p>（5）自动初始化方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 定义该宏开启自动初始化机制，未定义则关闭 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USING_COMPONENTS_INIT</span><br><br><span class="hljs-comment">/* 定义该宏开启设置应用入口为 main 函数 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USING_USER_MAIN</span><br><span class="hljs-comment">/* 定义 main 线程的栈大小 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_MAIN_THREAD_STACK_SIZE 2048</span><br></code></pre></td></tr></table></figure><p>（6）FinSH</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 定义该宏可开启系统 FinSH 调试工具的使用，未定义则关闭 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USING_FINSH</span><br><br><span class="hljs-comment">/* 开启系统 FinSH 时：将该线程名称定义为 tshell */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FINSH_THREAD_NAME <span class="hljs-string">&quot;tshell&quot;</span></span><br><br><span class="hljs-comment">/* 开启系统 FinSH 时：使用历史命令 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FINSH_USING_HISTORY</span><br><span class="hljs-comment">/* 开启系统 FinSH 时：对历史命令行数的定义 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FINSH_HISTORY_LINES 5</span><br><br><span class="hljs-comment">/* 开启系统 FinSH 时：定义该宏开启使用 Tab 键，未定义则关闭 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FINSH_USING_SYMTAB</span><br><br><span class="hljs-comment">/* 开启系统 FinSH 时：定义该线程的优先级 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FINSH_THREAD_PRIORITY 20</span><br><span class="hljs-comment">/* 开启系统 FinSH 时：定义该线程的栈大小 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FINSH_THREAD_STACK_SIZE 4096</span><br><span class="hljs-comment">/* 开启系统 FinSH 时：定义命令字符长度 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FINSH_CMD_SIZE 80</span><br><br><span class="hljs-comment">/* 开启系统 FinSH 时：定义该宏开启 MSH 功能 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FINSH_USING_MSH</span><br><span class="hljs-comment">/* 开启系统 FinSH 时：开启 MSH 功能时，定义该宏默认使用 MSH 功能 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FINSH_USING_MSH_DEFAULT</span><br><span class="hljs-comment">/* 开启系统 FinSH 时：定义该宏，仅使用 MSH 功能 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FINSH_USING_MSH_ONLY</span><br></code></pre></td></tr></table></figure><p>（7）关于 MCU</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 定义该工程使用的 MCU 为 STM32F103ZE；系统通过对芯片类型的定义，来定义芯片的管脚 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STM32F103ZE</span><br><br><span class="hljs-comment">/* 定义时钟源频率 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_HSE_VALUE 8000000</span><br><br><span class="hljs-comment">/* 定义该宏开启 UART1 的使用 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USING_UART1</span><br></code></pre></td></tr></table></figure><h2 id="常见宏定义说明"><a href="#常见宏定义说明" class="headerlink" title="常见宏定义说明"></a>常见宏定义说明</h2><p>1）rt_inline，定义如下，static 关键字的作用是令函数只能在当前的文件中使用；inline 表示内联，用 static 修饰后在调用函数时会建议编译器进行内联展开。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> rt_inline                   static __inline</span><br></code></pre></td></tr></table></figure><p>2）RT_USED，定义如下，该宏的作用是向编译器说明这段代码有用，即使函数中没有调用也要保留编译。例如 RT-Thread 自动初始化功能使用了自定义的段，使用 RT_USED 会将自定义的代码段保留。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_USED                     __attribute__((used))</span><br></code></pre></td></tr></table></figure><p>3）RT_UNUSED，定义如下，表示函数或变量可能不使用，这个属性可以避免编译器产生警告信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_UNUSED                   __attribute__((unused))</span><br></code></pre></td></tr></table></figure><p>4）RT_WEAK，定义如下，常用于定义函数，编译器在链接函数时会优先链接没有该关键字前缀的函数，如果找不到则再链接由 weak 修饰的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_WEAK                     __weak</span><br></code></pre></td></tr></table></figure><p>5）ALIGN(n)，定义如下，作用是在给某对象分配地址空间时，将其存放的地址按照 n 字节对齐，这里 n 可取 2 的幂次方。字节对齐的作用不仅是便于 CPU 快速访问，同时合理的利用字节对齐可以有效地节省存储空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ALIGN(n)                    __attribute__((aligned(n)))</span><br></code></pre></td></tr></table></figure><p>6）RT_ALIGN(size,align)，定义如下，作用是将 size 提升为 align 定义的整数的倍数，例如，RT_ALIGN(13,4) 将返回 16。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_ALIGN(size, align)      (((size) + (align) - 1) &amp; ~((align) - 1))</span><br></code></pre></td></tr></table></figure><h1 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h1><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><table><thead><tr><th><strong>状态</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>初始状态</td><td>当线程刚开始创建还没开始运行时就处于初始状态；<br/>在初始状态下，线程不参与调度。<br/>此状态在 RT-Thread 中的宏定义为 RT_THREAD_INIT</td></tr><tr><td>就绪状态</td><td>在就绪状态下，线程按照优先级排队，等待被执行；<br/>一旦当前线程运行完毕让出处理器，操作系统会马上寻找最高优先级的就绪态线程运行。<br/>此状态在 RT-Thread 中的宏定义为 RT_THREAD_READY</td></tr><tr><td>运行状态</td><td>线程当前正在运行。在单核系统中，只有 rt_thread_self() 函数返回的线程处于运行状态；<br/>在多核系统中，可能就不止这一个线程处于运行状态。<br/>此状态在 RT-Thread 中的宏定义为 RT_THREAD_RUNNING</td></tr><tr><td>挂起状态</td><td>也称阻塞态。它可能因为资源不可用而挂起等待，或线程主动延时一段时间而挂起。<br/>在挂起状态下，线程不参与调度。<br/>此状态在 RT-Thread 中的宏定义为 RT_THREAD_SUSPEND</td></tr><tr><td>关闭状态</td><td>当线程运行结束时将处于关闭状态。<br/>关闭状态的线程不参与线程的调度。<br/>此状态在 RT-Thread 中的宏定义为 RT_THREAD_CLOSE</td></tr></tbody></table><h2 id="线程状态的切换"><a href="#线程状态的切换" class="headerlink" title="线程状态的切换"></a>线程状态的切换</h2><p><img src="/2021/42e53028/04thread_sta.png" alt="线程状态转换图"></p><h2 id="线程的管理API"><a href="#线程的管理API" class="headerlink" title="线程的管理API"></a>线程的管理API</h2><p><img src="/2021/42e53028/04thread_ops.png" alt="线程相关操作"></p><h3 id="创建删除-create"><a href="#创建删除-create" class="headerlink" title="创建删除-create"></a>创建删除-create</h3><p>系统会从动态堆内存中分配一个线程句柄以及按照参数中指定的栈大小从动态堆内存中分配相应的空间。分配出来的栈空间是按照 rtconfig.h 中配置的 <strong>RT_ALIGN_SIZE</strong> 方式对齐</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_thread_t</span> <span class="hljs-title function_">rt_thread_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name,</span><br><span class="hljs-params">                            <span class="hljs-type">void</span> (*entry)(<span class="hljs-type">void</span>* parameter),</span><br><span class="hljs-params">                            <span class="hljs-type">void</span>* parameter,</span><br><span class="hljs-params">                            <span class="hljs-type">rt_uint32_t</span> stack_size,</span><br><span class="hljs-params">                            <span class="hljs-type">rt_uint8_t</span> priority,</span><br><span class="hljs-params">                            <span class="hljs-type">rt_uint32_t</span> tick)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>name</td><td>线程的名称；<br/>线程名称的最大长度由 rtconfig.h 中的宏 RT_NAME_MAX 指定，多余部分会被自动截掉</td></tr><tr><td>entry</td><td>线程入口函数</td></tr><tr><td>parameter</td><td>线程入口函数参数</td></tr><tr><td>stack_size</td><td>线程栈大小，单位是字节</td></tr><tr><td>priority</td><td>线程的优先级。<br/>优先级范围根据系统配置情况（rtconfig.h 中的 RT_THREAD_PRIORITY_MAX 宏定义），如果支持的是 256 级优先级，那么范围是从 0~255，数值越小优先级越高，0 代表最高优先级</td></tr><tr><td>tick</td><td>线程的时间片大小。<br/>时间片（tick）的单位是操作系统的时钟节拍。当系统中存在相同优先级线程时，这个参数指定线程一次调度能够运行的最大时间长度。这个时间片运行结束时，调度器自动选择下一个就绪态的同优先级线程进行运行</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>thread</td><td>线程创建成功，返回线程句柄</td></tr><tr><td>RT_NULL</td><td>线程创建失败</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_delete</span><span class="hljs-params">(<span class="hljs-type">rt_thread_t</span> thread)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>thread</td><td>要删除的线程句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>删除线程成功</td></tr><tr><td>-RT_ERROR</td><td>删除线程失败</td></tr></tbody></table><h3 id="初始化和脱离-init"><a href="#初始化和脱离-init" class="headerlink" title="初始化和脱离-init"></a>初始化和脱离-init</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_init</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> rt_thread* thread,</span><br><span class="hljs-params">                        <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name,</span><br><span class="hljs-params">                        <span class="hljs-type">void</span> (*entry)(<span class="hljs-type">void</span>* parameter), <span class="hljs-type">void</span>* parameter,</span><br><span class="hljs-params">                        <span class="hljs-type">void</span>* stack_start, <span class="hljs-type">rt_uint32_t</span> stack_size,</span><br><span class="hljs-params">                        <span class="hljs-type">rt_uint8_t</span> priority, <span class="hljs-type">rt_uint32_t</span> tick)</span>;<br></code></pre></td></tr></table></figure><p>静态线程的线程句柄（或者说线程控制块指针）、线程栈由用户提供。静态线程是指线程控制块、线程运行栈一般都设置为全局变量，在编译时就被确定、被分配处理，内核不负责动态分配内存空间。需要注意的是，用户提供的栈首地址需做<strong>系统对齐</strong>（例如 ARM 上需要做 4 字节对齐）。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>thread</td><td>线程句柄。线程句柄由用户提供出来，并指向对应的线程控制块内存地址</td></tr><tr><td>name</td><td>线程的名称；线程名称的最大长度由 rtconfig.h 中定义的 RT_NAME_MAX 宏指定，多余部分会被自动截掉</td></tr><tr><td>entry</td><td>线程入口函数</td></tr><tr><td>parameter</td><td>线程入口函数参数</td></tr><tr><td>stack_start</td><td>线程栈起始地址</td></tr><tr><td>stack_size</td><td>线程栈大小，单位是字节。在大多数系统中需要做栈空间地址对齐（例如 ARM 体系结构中需要向 4 字节地址对齐）</td></tr><tr><td>priority</td><td>线程的优先级。优先级范围根据系统配置情况（rtconfig.h 中的 RT_THREAD_PRIORITY_MAX 宏定义），如果支持的是 256 级优先级，那么范围是从 0 ～ 255，数值越小优先级越高，0 代表最高优先级</td></tr><tr><td>tick</td><td>线程的时间片大小。时间片（tick）的单位是操作系统的时钟节拍。当系统中存在相同优先级线程时，这个参数指定线程一次调度能够运行的最大时间长度。这个时间片运行结束时，调度器自动选择下一个就绪态的同优先级线程进行运行</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>线程创建成功</td></tr><tr><td>-RT_ERROR</td><td>线程创建失败</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_detach</span> <span class="hljs-params">(<span class="hljs-type">rt_thread_t</span> thread)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>thread</td><td>线程句柄，它应该是由 rt_thread_init 进行初始化的线程句柄。</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>线程脱离成功</td></tr><tr><td>-RT_ERROR</td><td>线程脱离失败</td></tr></tbody></table><h3 id="线程启动-startup"><a href="#线程启动-startup" class="headerlink" title="线程启动-startup"></a>线程启动-startup</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_startup</span><span class="hljs-params">(<span class="hljs-type">rt_thread_t</span> thread)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>thread</td><td>线程句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>线程启动成功</td></tr><tr><td>-RT_ERROR</td><td>线程起动失败</td></tr></tbody></table><h3 id="获取当前线程-self"><a href="#获取当前线程-self" class="headerlink" title="获取当前线程-self"></a>获取当前线程-self</h3><p>在程序的运行过程中，相同的一段代码可能会被多个线程执行，在执行的时候可以通过下面的函数接口获得当前执行的线程句柄：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_thread_t</span> <span class="hljs-title function_">rt_thread_self</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>返回</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>thread</td><td>当前运行的线程句柄</td></tr><tr><td>RT_NULL</td><td>失败，调度器还未启动</td></tr></tbody></table><h3 id="使线程让出处理器资源-yield"><a href="#使线程让出处理器资源-yield" class="headerlink" title="使线程让出处理器资源-yield"></a>使线程让出处理器资源-yield</h3><p>（如果当前优先级只有这一个线程，则这个线程继续执行，不进行上下文切换动作）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_yield</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><p>rt_thread_yield() 和 rt_schedule() 比较相像，有相同优先级的其他就绪态线程存在时其行为<strong>有所差异</strong>。</p><h3 id="使线程睡眠-延时-sleep"><a href="#使线程睡眠-延时-sleep" class="headerlink" title="使线程睡眠(延时)-sleep"></a>使线程睡眠(延时)-sleep</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_sleep</span><span class="hljs-params">(<span class="hljs-type">rt_tick_t</span> tick)</span>;<br><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_delay</span><span class="hljs-params">(<span class="hljs-type">rt_tick_t</span> tick)</span>;<br><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_mdelay</span><span class="hljs-params">(<span class="hljs-type">rt_int32_t</span> ms)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>tick&#x2F;ms</td><td>线程睡眠的时间： sleep&#x2F;delay 的传入参数 tick 以 1 个 OS Tick 为单位 ； mdelay 的传入参数 ms 以 1ms 为单位；</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>操作成功</td></tr></tbody></table><h3 id="挂起和恢复线程-suspend"><a href="#挂起和恢复线程-suspend" class="headerlink" title="挂起和恢复线程-suspend"></a>挂起和恢复线程-suspend</h3><blockquote><p>通常不应该使用这个函数来挂起线程本身，如果确实需要采用 rt_thread_suspend() 函数挂起当前任务，需要在调用 rt_thread_suspend() 函数后立刻调用 rt_schedule() 函数进行手动的线程上下文切换。用户只需要了解该接口的作用，不推荐使用该接口。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_suspend</span> <span class="hljs-params">(<span class="hljs-type">rt_thread_t</span> thread)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>thread</td><td>线程句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>线程挂起成功</td></tr><tr><td>-RT_ERROR</td><td>线程挂起失败，因为该线程的状态并不是就绪状态</td></tr></tbody></table><p>恢复线程就是让挂起的线程重新进入就绪状态，并将线程放入系统的就绪队列中；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_resume</span> <span class="hljs-params">(<span class="hljs-type">rt_thread_t</span> thread)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>thread</td><td>线程句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>线程恢复成功</td></tr><tr><td>-RT_ERROR</td><td>线程恢复失败，因为该个线程的状态并不是 RT_THREAD_SUSPEND 状态</td></tr></tbody></table><h3 id="控制线程-control"><a href="#控制线程-control" class="headerlink" title="控制线程-control"></a>控制线程-control</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_control</span><span class="hljs-params">(<span class="hljs-type">rt_thread_t</span> thread, <span class="hljs-type">rt_uint8_t</span> cmd, <span class="hljs-type">void</span>* arg)</span>;<br></code></pre></td></tr></table></figure><p>线程控制接口 rt_thread_control() 的参数和返回值见下表：</p><table><thead><tr><th><strong>函数参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>thread</td><td>线程句柄</td></tr><tr><td>cmd</td><td>指示控制命令</td></tr><tr><td>arg</td><td>控制参数</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>控制执行正确</td></tr><tr><td>-RT_ERROR</td><td>失败</td></tr></tbody></table><blockquote><p>指示控制命令 cmd 当前支持的命令包括：</p><p>RT_THREAD_CTRL_CHANGE_PRIORITY：动态更改线程的优先级；</p><p>RT_THREAD_CTRL_STARTUP：开始运行一个线程，等同于 rt_thread_startup() 函数调用；</p><p>RT_THREAD_CTRL_CLOSE：关闭一个线程，等同于 rt_thread_delete() 函数调用。</p></blockquote><h3 id="设置和删除空闲钩子-idle"><a href="#设置和删除空闲钩子-idle" class="headerlink" title="设置和删除空闲钩子-idle"></a>设置和删除空闲钩子-idle</h3><p>空闲钩子函数是空闲线程的钩子函数，如果设置了空闲钩子函数，就可以在系统执行空闲线程时，自动执行空闲钩子函数来做一些其他事情，比如系统指示灯。<strong>钩子函数必须保证空闲线程在任何时刻都不会处于挂起状态。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_idle_sethook</span><span class="hljs-params">(<span class="hljs-type">void</span> (*hook)(<span class="hljs-type">void</span>))</span>;<br><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_idle_delhook</span><span class="hljs-params">(<span class="hljs-type">void</span> (*hook)(<span class="hljs-type">void</span>))</span>;<br></code></pre></td></tr></table></figure><p>设置空闲钩子函数 rt_thread_idle_sethook() </p><table><thead><tr><th><strong>函数参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>hook</td><td>设置的钩子函数</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>设置成功</td></tr><tr><td>-RT_EFULL</td><td>设置失败</td></tr></tbody></table><p>删除空闲钩子函数 rt_thread_idle_delhook() </p><table><thead><tr><th><strong>函数参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>hook</td><td>删除的钩子函数</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>删除成功</td></tr><tr><td>-RT_ENOSYS</td><td>删除失败</td></tr></tbody></table><h3 id="设置调度器钩子-scheduler"><a href="#设置调度器钩子-scheduler" class="headerlink" title="设置调度器钩子-scheduler"></a>设置调度器钩子-scheduler</h3><p>有时用户可能会想知道在一个时刻发生了什么样的线程切换，可以通过调用下面的函数接口设置一个相应的钩子函数。在系统线程切换时，这个钩子函数将被调用：<strong>请仔细编写你的钩子函数，稍有不慎将很可能导致整个系统运行不正常（在这个钩子函数中，基本上不允许调用系统 API，更不应该导致当前运行的上下文挂起）。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">rt_scheduler_sethook</span><span class="hljs-params">(<span class="hljs-type">void</span> (*hook)(<span class="hljs-keyword">struct</span> rt_thread* from, <span class="hljs-keyword">struct</span> rt_thread* to))</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>函数参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>hook</td><td>表示用户定义的钩子函数指针</td></tr></tbody></table><p>钩子函数 hook() 的声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">hook</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> rt_thread* from, <span class="hljs-keyword">struct</span> rt_thread* to)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>函数参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>from</td><td>表示系统所要切换出的线程控制块指针</td></tr><tr><td>to</td><td>表示系统所要切换到的线程控制块指针</td></tr></tbody></table><h2 id="API应用示例"><a href="#API应用示例" class="headerlink" title="API应用示例"></a>API应用示例</h2><p>线程 2 计数到一定值会执行完毕，线程 2 被系统自动删除，计数停止。线程 1 一直打印计数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;rtthread.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_PRIORITY         25</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_STACK_SIZE       512</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_TIMESLICE        5</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">rt_thread_t</span> tid1 = RT_NULL;<br><br><span class="hljs-comment">/* 线程 1 的入口函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">thread1_entry</span><span class="hljs-params">(<span class="hljs-type">void</span> *parameter)</span><br>&#123;<br>    <span class="hljs-type">rt_uint32_t</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">/* 线程 1 采用低优先级运行，一直打印计数值 */</span><br>        rt_kprintf(<span class="hljs-string">&quot;thread1 count: %d\n&quot;</span>, count ++);<br>        rt_thread_mdelay(<span class="hljs-number">500</span>);<br>    &#125;<br>&#125;<br><br>ALIGN(RT_ALIGN_SIZE)<br><span class="hljs-type">static</span> <span class="hljs-type">char</span> thread2_stack[<span class="hljs-number">1024</span>];<br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_thread</span> <span class="hljs-title">thread2</span>;</span><br><span class="hljs-comment">/* 线程 2 入口 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">thread2_entry</span><span class="hljs-params">(<span class="hljs-type">void</span> *param)</span><br>&#123;<br>    <span class="hljs-type">rt_uint32_t</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* 线程 2 拥有较高的优先级，以抢占线程 1 而获得执行 */</span><br>    <span class="hljs-keyword">for</span> (count = <span class="hljs-number">0</span>; count &lt; <span class="hljs-number">10</span> ; count++)<br>    &#123;<br>        <span class="hljs-comment">/* 线程 2 打印计数值 */</span><br>        rt_kprintf(<span class="hljs-string">&quot;thread2 count: %d\n&quot;</span>, count);<br>    &#125;<br>    rt_kprintf(<span class="hljs-string">&quot;thread2 exit\n&quot;</span>);<br>    <span class="hljs-comment">/* 线程 2 运行结束后也将自动被系统脱离 */</span><br>&#125;<br><br><span class="hljs-comment">/* 线程示例 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">thread_sample</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/* 创建线程 1，名称是 thread1，入口是 thread1_entry*/</span><br>    tid1 = rt_thread_create(<span class="hljs-string">&quot;thread1&quot;</span>,<br>                            thread1_entry, RT_NULL,<br>                            THREAD_STACK_SIZE,<br>                            THREAD_PRIORITY, THREAD_TIMESLICE);<br><br>    <span class="hljs-comment">/* 如果获得线程控制块，启动这个线程 */</span><br>    <span class="hljs-keyword">if</span> (tid1 != RT_NULL)<br>        rt_thread_startup(tid1);<br><br>    <span class="hljs-comment">/* 初始化线程 2，名称是 thread2，入口是 thread2_entry */</span><br>    rt_thread_init(&amp;thread2,<br>                   <span class="hljs-string">&quot;thread2&quot;</span>,<br>                   thread2_entry,<br>                   RT_NULL,<br>                   &amp;thread2_stack[<span class="hljs-number">0</span>],<br>                   <span class="hljs-keyword">sizeof</span>(thread2_stack),<br>                   THREAD_PRIORITY - <span class="hljs-number">1</span>, THREAD_TIMESLICE);<br>    rt_thread_startup(&amp;thread2);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 导出到 msh 命令列表中 */</span><br>MSH_CMD_EXPORT(thread_sample, thread sample);<br></code></pre></td></tr></table></figure><p>仿真运行结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c">\ | /<br>- RT -     Thread Operating System<br> / | \     <span class="hljs-number">3.1</span><span class="hljs-number">.0</span> build Aug <span class="hljs-number">24</span> <span class="hljs-number">2018</span><br> <span class="hljs-number">2006</span> - <span class="hljs-number">2018</span> Copyright by rt-thread team<br>msh &gt;thread_sample<br>msh &gt;thread2 count: <span class="hljs-number">0</span><br>thread2 count: <span class="hljs-number">1</span><br>thread2 count: <span class="hljs-number">2</span><br>thread2 count: <span class="hljs-number">3</span><br>thread2 count: <span class="hljs-number">4</span><br>thread2 count: <span class="hljs-number">5</span><br>thread2 count: <span class="hljs-number">6</span><br>thread2 count: <span class="hljs-number">7</span><br>thread2 count: <span class="hljs-number">8</span><br>thread2 count: <span class="hljs-number">9</span><br>thread2 <span class="hljs-built_in">exit</span><br>thread1 count: <span class="hljs-number">0</span><br>thread1 count: <span class="hljs-number">1</span><br>thread1 count: <span class="hljs-number">2</span><br>thread1 count: <span class="hljs-number">3</span><br>…<br></code></pre></td></tr></table></figure><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><ul><li>若某线程运行完毕，系统将自动删除线程：自动执行 rt_thread_exit() 函数，先将该线程从系统就绪队列中删除，再将该线程的状态更改为关闭状态，不再参与系统调度，然后挂入 rt_thread_defunct 僵尸队列（资源未回收、处于关闭状态的线程队列）中，最后空闲线程会回收被删除线程的资源。</li><li></li></ul><h1 id="时钟管理"><a href="#时钟管理" class="headerlink" title="时钟管理"></a>时钟管理</h1><h2 id="获取时钟节拍API"><a href="#获取时钟节拍API" class="headerlink" title="获取时钟节拍API"></a>获取时钟节拍API</h2><p>由于全局变量 rt_tick 在每经过一个时钟节拍时，值就会加 1，通过调用 rt_tick_get 会返回当前 rt_tick 的值，即可以获取到当前的时钟节拍值。此接口可用于记录系统的运行时间长短，或者测量某任务运行的时间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_tick_t</span> <span class="hljs-title function_">rt_tick_get</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>返回</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>rt_tick</td><td>当前时钟节拍值</td></tr></tbody></table><h2 id="软件定时器管理"><a href="#软件定时器管理" class="headerlink" title="软件定时器管理"></a>软件定时器管理</h2><p>RT-Thread 操作系统提供软件实现的定时器，以时钟节拍（OS Tick）的时间长度为单位，即定时数值必须是 OS Tick 的整数倍。它构建在硬件定时器基础之上，使系统能够提供不受数目限制的定时器服务。</p><p>RT-Thread 的定时器提供两类定时器机制：</p><ul><li>第一类是单次触发定时器，这类定时器在启动后只会触发一次定时器事件，然后定时器自动停止。</li><li>第二类是周期触发定时器，这类定时器会周期性的触发定时器事件，直到用户手动的停止，否则将永远持续执行下去。</li></ul><p>另外，根据超时函数执行时所处的上下文环境，RT-Thread 的定时器可以分为 <strong>HARD_TIMER</strong> 模式与 <strong>SOFT_TIMER</strong> 模式，如下图。使用<strong>RT_TIMER_FLAG_HARD_TIMER</strong> 和 **RT_TIMER_FLAG_SOFT_TIMER ** 来决定使用的模式</p><p><img src="/2021/42e53028/05timer_env.png" alt="定时器上下文环境"></p><p>系统新创建并激活的定时器都会按照以超时时间排序的方式插入到 rt_timer_list 链表中。</p><p><img src="/2021/42e53028/05timer_linked_list.png" alt="定时器链表示意图"></p><p>rt_tick(当前系统tick) 从 20 增长到 70，与 Timer1 的 timeout 值相等，这时会触发与 Timer1 定时器相关联的超时函数，同时将 Timer1 从 rt_timer_list 链表上删除。</p><p>如果系统当前定时器状态在 10 个 tick 以后（rt_tick&#x3D;30）有一个任务新创建了一个 tick 值为 300 的 Timer4 定时器，由于 Timer4 定时器的 timeout&#x3D;rt_tick+300&#x3D;330, 因此它将被插入到 Timer2 和 Timer3 定时器中间如下图,所示：</p><p><img src="/2021/42e53028/05timer_linked_list2.png" alt="定时器链表插入示意图"></p><h2 id="定时器API"><a href="#定时器API" class="headerlink" title="定时器API"></a>定时器API</h2><p><img src="/2021/42e53028/05timer_ops.png" alt="定时器相关操作"></p><p>在系统启动时需要初始化定时器管理系统。可以通过下面的函数接口完成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">rt_system_timer_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><p>如果需要使用 SOFT_TIMER，则系统初始化时，应该调用下面这个函数接口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">rt_system_timer_thread_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><h3 id="创建和删除-create"><a href="#创建和删除-create" class="headerlink" title="创建和删除-create"></a>创建和删除-create</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_timer_t</span> <span class="hljs-title function_">rt_timer_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name,</span><br><span class="hljs-params">                           <span class="hljs-type">void</span> (*timeout)(<span class="hljs-type">void</span>* parameter),</span><br><span class="hljs-params">                           <span class="hljs-type">void</span>* parameter,</span><br><span class="hljs-params">                           <span class="hljs-type">rt_tick_t</span> time,</span><br><span class="hljs-params">                           <span class="hljs-type">rt_uint8_t</span> flag)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>name</td><td>定时器的名称</td></tr><tr><td>void (timeout) (void parameter)</td><td>定时器超时函数指针（当定时器超时时，系统会调用这个函数）</td></tr><tr><td>parameter</td><td>定时器超时函数的入口参数（当定时器超时时，调用超时回调函数会把这个参数做为入口参数传递给超时函数）</td></tr><tr><td>time</td><td>定时器的超时时间，单位是时钟节拍</td></tr><tr><td>flag</td><td>定时器创建时的参数，支持的值包括单次定时、周期定时、硬件定时器、软件定时器等（可以用 “或” 关系取多个值）</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_NULL</td><td>创建失败（通常会由于系统内存不够用而返回 RT_NULL）</td></tr><tr><td>定时器的句柄</td><td>定时器创建成功</td></tr></tbody></table><p>如下2 组值可以以 “或” 逻辑的方式赋给 flag。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_TIMER_FLAG_ONE_SHOT      0x0     <span class="hljs-comment">/* 单次定时     */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_TIMER_FLAG_PERIODIC      0x2     <span class="hljs-comment">/* 周期定时     */</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_TIMER_FLAG_HARD_TIMER    0x0     <span class="hljs-comment">/* 时钟中断的服务例程上下文中被调用 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_TIMER_FLAG_SOFT_TIMER    0x4     <span class="hljs-comment">/* timer 线程的上下文中被调用 */</span></span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_timer_delete</span><span class="hljs-params">(<span class="hljs-type">rt_timer_t</span> timer)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>timer</td><td>定时器句柄，指向要删除的定时器</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>删除成功（如果参数 timer 句柄是一个 RT_NULL，将会导致一个 ASSERT 断言）</td></tr></tbody></table><h3 id="初始化和脱离定时器-init"><a href="#初始化和脱离定时器-init" class="headerlink" title="初始化和脱离定时器-init"></a>初始化和脱离定时器-init</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">rt_timer_init</span><span class="hljs-params">(<span class="hljs-type">rt_timer_t</span> timer,</span><br><span class="hljs-params">                   <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name,</span><br><span class="hljs-params">                   <span class="hljs-type">void</span> (*timeout)(<span class="hljs-type">void</span>* parameter),</span><br><span class="hljs-params">                   <span class="hljs-type">void</span>* parameter,</span><br><span class="hljs-params">                   <span class="hljs-type">rt_tick_t</span> time, <span class="hljs-type">rt_uint8_t</span> flag)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>timer</td><td>定时器句柄，指向要初始化的定时器控制块</td></tr><tr><td>name</td><td>定时器的名称</td></tr><tr><td>void (timeout) (void parameter)</td><td>定时器超时函数指针（当定时器超时时，系统会调用这个函数）</td></tr><tr><td>parameter</td><td>定时器超时函数的入口参数（当定时器超时时，调用超时回调函数会把这个参数做为入口参数传递给超时函数）</td></tr><tr><td>time</td><td>定时器的超时时间，单位是时钟节拍</td></tr><tr><td>flag</td><td>定时器创建时的参数，支持的值包括单次定时、周期定时、硬件定时器、软件定时器（可以用 “或” 关系取多个值），详见上面 <strong>创建和删除</strong></td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_timer_detach</span><span class="hljs-params">(<span class="hljs-type">rt_timer_t</span> timer)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>timer</td><td>定时器句柄，指向要脱离的定时器控制块</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>脱离成功</td></tr></tbody></table><h3 id="启动和停止定时器-start"><a href="#启动和停止定时器-start" class="headerlink" title="启动和停止定时器-start"></a>启动和停止定时器-start</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_timer_start</span><span class="hljs-params">(<span class="hljs-type">rt_timer_t</span> timer)</span>;<br></code></pre></td></tr></table></figure><p>调用接口后，定时器的状态将更改为激活状态（RT_TIMER_FLAG_ACTIVATED），并按照超时顺序插入到 rt_timer_list 队列链表中。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>timer</td><td>定时器句柄，指向要启动的定时器控制块</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>启动成功</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_timer_stop</span><span class="hljs-params">(<span class="hljs-type">rt_timer_t</span> timer)</span>;<br></code></pre></td></tr></table></figure><p>当一个（周期性）定时器超时时，可以调用这个函数接口停止这个（周期性）定时器本身。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>timer</td><td>定时器句柄，指向要停止的定时器控制块</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功停止定时器</td></tr><tr><td>- RT_ERROR</td><td>timer 已经处于停止状态</td></tr></tbody></table><h3 id="控制定时器-control"><a href="#控制定时器-control" class="headerlink" title="控制定时器-control"></a>控制定时器-control</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_timer_control</span><span class="hljs-params">(<span class="hljs-type">rt_timer_t</span> timer, <span class="hljs-type">rt_uint8_t</span> cmd, <span class="hljs-type">void</span>* arg)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>timer</td><td>定时器句柄，指向要停止的定时器控制块</td></tr><tr><td>cmd</td><td>用于控制定时器的命令，当前支持四个命令，分别是设置定时时间，查看定时时间，设置单次触发，设置周期触发</td></tr><tr><td>arg</td><td>与 cmd 相对应的控制命令参数 比如，cmd 为设定超时时间时，就可以将超时时间参数通过 arg 进行设定</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr></tbody></table><p>函数参数 cmd 支持的命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_TIMER_CTRL_SET_TIME      0x0     <span class="hljs-comment">/* 设置定时器超时时间       */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_TIMER_CTRL_GET_TIME      0x1     <span class="hljs-comment">/* 获得定时器超时时间       */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_TIMER_CTRL_SET_ONESHOT   0x2     <span class="hljs-comment">/* 设置定时器为单次定时器   */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_TIMER_CTRL_SET_PERIODIC  0x3     <span class="hljs-comment">/* 设置定时器为周期型定时器 */</span></span><br></code></pre></td></tr></table></figure><h2 id="API应用示例-1"><a href="#API应用示例-1" class="headerlink" title="API应用示例"></a>API应用示例</h2><p>这是一个创建定时器的例子，这个例程会创建两个动态定时器，一个是单次定时，一个是周期性定时并让周期定时器运行一段时间后停止运行，如下所示：周期性定时器 1 的超时函数，每 10 个 OS Tick 运行 1 次，共运行 10 次（10 次后调用 rt_timer_stop 使定时器 1 停止运行）；单次定时器 2 的超时函数在第 30 个 OS Tick 时运行一次。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;rtthread.h&gt;</span></span><br><br><span class="hljs-comment">/* 定时器的控制块 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">rt_timer_t</span> timer1;<br><span class="hljs-type">static</span> <span class="hljs-type">rt_timer_t</span> timer2;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/* 定时器 1 超时函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">timeout1</span><span class="hljs-params">(<span class="hljs-type">void</span> *parameter)</span><br>&#123;<br>    rt_kprintf(<span class="hljs-string">&quot;periodic timer is timeout %d\n&quot;</span>, cnt);<br><br>    <span class="hljs-comment">/* 运行第 10 次，停止周期定时器 */</span><br>    <span class="hljs-keyword">if</span> (cnt++&gt;= <span class="hljs-number">9</span>)<br>    &#123;<br>        rt_timer_stop(timer1);<br>        rt_kprintf(<span class="hljs-string">&quot;periodic timer was stopped! \n&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* 定时器 2 超时函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">timeout2</span><span class="hljs-params">(<span class="hljs-type">void</span> *parameter)</span><br>&#123;<br>    rt_kprintf(<span class="hljs-string">&quot;one shot timer is timeout\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">timer_sample</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/* 创建定时器 1  周期定时器 */</span><br>    timer1 = rt_timer_create(<span class="hljs-string">&quot;timer1&quot;</span>, timeout1,<br>                             RT_NULL, <span class="hljs-number">10</span>,<br>                             RT_TIMER_FLAG_PERIODIC);<br><br>    <span class="hljs-comment">/* 启动定时器 1 */</span><br>    <span class="hljs-keyword">if</span> (timer1 != RT_NULL) rt_timer_start(timer1);<br><br>    <span class="hljs-comment">/* 创建定时器 2 单次定时器 */</span><br>    timer2 = rt_timer_create(<span class="hljs-string">&quot;timer2&quot;</span>, timeout2,<br>                             RT_NULL,  <span class="hljs-number">30</span>,<br>                             RT_TIMER_FLAG_ONE_SHOT);<br><br>    <span class="hljs-comment">/* 启动定时器 2 */</span><br>    <span class="hljs-keyword">if</span> (timer2 != RT_NULL) rt_timer_start(timer2);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 导出到 msh 命令列表中 */</span><br>MSH_CMD_EXPORT(timer_sample, timer sample);<br></code></pre></td></tr></table></figure><p>仿真运行结果如下：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs applescript"> \ | /<br>- RT -     Thread Operating System<br> / | \     <span class="hljs-number">3.1</span><span class="hljs-number">.0</span> build Aug <span class="hljs-number">24</span> <span class="hljs-number">2018</span><br> <span class="hljs-number">2006</span> - <span class="hljs-number">2018</span> Copyright <span class="hljs-keyword">by</span> rt-thread team<br>msh &gt;timer_sample<br>msh &gt;periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span> <span class="hljs-number">0</span><br>periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span> <span class="hljs-number">1</span><br>one shot timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span><br>periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span> <span class="hljs-number">2</span><br>periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span> <span class="hljs-number">3</span><br>periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span> <span class="hljs-number">4</span><br>periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span> <span class="hljs-number">5</span><br>periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span> <span class="hljs-number">6</span><br>periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span> <span class="hljs-number">7</span><br>periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span> <span class="hljs-number">8</span><br>periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span> <span class="hljs-number">9</span><br>periodic timer was stopped!<br></code></pre></td></tr></table></figure><p>初始化定时器的例子与创建定时器的例子类似，这个程序会初始化 2 个静态定时器，一个是单次定时，一个是周期性的定时，如下代码所示：周期性定时器 1 的超时函数，每 10 个 OS Tick 运行 1 次，共运行 10 次（10 次后调用 rt_timer_stop 使定时器 1 停止运行）；单次定时器 2 的超时函数在第 30 个 OS Tick 时运行一次。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;rtthread.h&gt;</span></span><br><br><span class="hljs-comment">/* 定时器的控制块 */</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_timer</span> <span class="hljs-title">timer1</span>;</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_timer</span> <span class="hljs-title">timer2</span>;</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/* 定时器 1 超时函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">timeout1</span><span class="hljs-params">(<span class="hljs-type">void</span>* parameter)</span><br>&#123;<br>    rt_kprintf(<span class="hljs-string">&quot;periodic timer is timeout\n&quot;</span>);<br>    <span class="hljs-comment">/* 运行 10 次 */</span><br>    <span class="hljs-keyword">if</span> (cnt++&gt;= <span class="hljs-number">9</span>)<br>    &#123;<br>        rt_timer_stop(&amp;timer1);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* 定时器 2 超时函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">timeout2</span><span class="hljs-params">(<span class="hljs-type">void</span>* parameter)</span><br>&#123;<br>    rt_kprintf(<span class="hljs-string">&quot;one shot timer is timeout\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">timer_static_sample</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/* 初始化定时器 */</span><br>    rt_timer_init(&amp;timer1, <span class="hljs-string">&quot;timer1&quot;</span>,  <span class="hljs-comment">/* 定时器名字是 timer1 */</span><br>                    timeout1, <span class="hljs-comment">/* 超时时回调的处理函数 */</span><br>                    RT_NULL, <span class="hljs-comment">/* 超时函数的入口参数 */</span><br>                    <span class="hljs-number">10</span>, <span class="hljs-comment">/* 定时长度，以 OS Tick 为单位，即 10 个 OS Tick */</span><br>                    RT_TIMER_FLAG_PERIODIC); <span class="hljs-comment">/* 周期性定时器 */</span><br>    rt_timer_init(&amp;timer2, <span class="hljs-string">&quot;timer2&quot;</span>,   <span class="hljs-comment">/* 定时器名字是 timer2 */</span><br>                    timeout2, <span class="hljs-comment">/* 超时时回调的处理函数 */</span><br>                      RT_NULL, <span class="hljs-comment">/* 超时函数的入口参数 */</span><br>                      <span class="hljs-number">30</span>, <span class="hljs-comment">/* 定时长度为 30 个 OS Tick */</span><br>                    RT_TIMER_FLAG_ONE_SHOT); <span class="hljs-comment">/* 单次定时器 */</span><br><br>    <span class="hljs-comment">/* 启动定时器 */</span><br>    rt_timer_start(&amp;timer1);<br>    rt_timer_start(&amp;timer2);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/* 导出到 msh 命令列表中 */</span><br>MSH_CMD_EXPORT(timer_static_sample, timer_static sample);<br></code></pre></td></tr></table></figure><p>仿真运行结果如下：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs applescript">\ | /<br>- RT -     Thread Operating System<br> / | \     <span class="hljs-number">3.1</span><span class="hljs-number">.0</span> build Aug <span class="hljs-number">24</span> <span class="hljs-number">2018</span><br> <span class="hljs-number">2006</span> - <span class="hljs-number">2018</span> Copyright <span class="hljs-keyword">by</span> rt-thread team<br>msh &gt;timer_static_sample<br>msh &gt;periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span><br>periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span><br>one shot timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span><br>periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span><br>periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span><br>periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span><br>periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span><br>periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span><br>periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span><br>periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span><br>periodic timer <span class="hljs-keyword">is</span> <span class="hljs-keyword">timeout</span><br></code></pre></td></tr></table></figure><h2 id="低于一个Tick的延时"><a href="#低于一个Tick的延时" class="headerlink" title="低于一个Tick的延时"></a>低于一个Tick的延时</h2><p>入口参数 us 指示出需要延时的微秒数目，这个函数只能支持低于 1 OS Tick 的延时，否则 SysTick 会出现溢出而不能够获得指定的延时时间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;board.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">rt_hw_us_delay</span><span class="hljs-params">(<span class="hljs-type">rt_uint32_t</span> us)</span><br>&#123;<br>    <span class="hljs-type">rt_uint32_t</span> delta;<br>    <span class="hljs-comment">/* 获得延时经过的 tick 数 */</span><br>    us = us * (SysTick-&gt;LOAD/(<span class="hljs-number">1000000</span>/RT_TICK_PER_SECOND));<br>    <span class="hljs-comment">/* 获得当前时间 */</span><br>    delta = SysTick-&gt;VAL;<br>    <span class="hljs-comment">/* 循环获得当前时间，直到达到指定的时间后退出循环 */</span><br>    <span class="hljs-keyword">while</span> (delta - SysTick-&gt;VAL&lt; us);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="笔记-1"><a href="#笔记-1" class="headerlink" title="笔记"></a>笔记</h2><ul><li>时钟节拍是特定的周期性中断，这个中断可以看做是系统心跳，中断之间的时间间隔取决于不同的应用，一般是 1ms–100ms，时钟节拍率越快，系统的额外开销就越大，从系统启动开始计数的时钟节拍数称为系统时间。</li><li></li></ul><h1 id="线程间同步"><a href="#线程间同步" class="headerlink" title="线程间同步"></a>线程间同步</h1><p>线程的同步方式有很多种，其核心思想都是：<strong>在访问临界区的时候只允许一个 (或一类) 线程运行。</strong>进入 &#x2F; 退出临界区的方式有很多种：</p><p>1）调用 rt_hw_interrupt_disable() 进入临界区，调用 rt_hw_interrupt_enable() 退出临界区；详见《中断管理》的全局中断开关内容。</p><p>2）调用 rt_enter_critical() 进入临界区，调用 rt_exit_critical() 退出临界区。</p><h2 id="信号量Semaphore"><a href="#信号量Semaphore" class="headerlink" title="信号量Semaphore"></a>信号量Semaphore</h2><p>信号量的值对应了信号量对象的实例数目、资源数目，假如信号量值为 5，则表示共有 5 个信号量实例（资源）可以被使用，当信号量实例数目为零时，再申请该信号量的线程就会被挂起在该信号量的等待队列上，等待可用的信号量实例（资源）。</p><p>可以形成<strong>锁</strong>、<strong>同步</strong>、<strong>资源计数</strong>等关系，也能方便的用于<strong>线程与线程</strong>、<strong>中断与线程</strong>间的同步中。</p><p><img src="/2021/42e53028/06sem_work.png" alt="信号量工作示意图"></p><h3 id="Semaphore-API"><a href="#Semaphore-API" class="headerlink" title="Semaphore API"></a>Semaphore API</h3><p><img src="/2021/42e53028/06sem_ops.png" alt="信号量相关接口"></p><h3 id="创建和删除信号量-create"><a href="#创建和删除信号量-create" class="headerlink" title="创建和删除信号量-create"></a>创建和删除信号量-create</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_sem_t</span> <span class="hljs-title function_">rt_sem_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name,</span><br><span class="hljs-params">                       <span class="hljs-type">rt_uint32_t</span> value,</span><br><span class="hljs-params">                       <span class="hljs-type">rt_uint8_t</span> flag)</span>;<br></code></pre></td></tr></table></figure><p>当选择 RT_IPC_FLAG_FIFO（先进先出）方式时，那么等待线程队列将按照先进先出的方式排队，先进入的线程将先获得等待的信号量；</p><p>当选择 RT_IPC_FLAG_PRIO（优先级等待）方式时，等待线程队列将按照优先级进行排队，优先级高的等待线程将先获得等待的信号量。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>name</td><td>信号量名称</td></tr><tr><td>value</td><td>信号量初始值</td></tr><tr><td>flag</td><td>信号量标志，它可以取如下数值： RT_IPC_FLAG_FIFO 或 RT_IPC_FLAG_PRIO</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_NULL</td><td>创建失败</td></tr><tr><td>信号量的控制块指针</td><td>创建成功</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_sem_delete</span><span class="hljs-params">(<span class="hljs-type">rt_sem_t</span> sem)</span>;<br></code></pre></td></tr></table></figure><p>如果删除该信号量时，有线程正在等待该信号量，那么删除操作会先唤醒等待在该信号量上的线程（等待线程的返回值是 - RT_ERROR），然后再释放信号量的内存资源。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>sem</td><td>rt_sem_create() 创建的信号量对象</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>删除成功</td></tr></tbody></table><h3 id="初始化和脱离信号量-init"><a href="#初始化和脱离信号量-init" class="headerlink" title="初始化和脱离信号量-init"></a>初始化和脱离信号量-init</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_sem_init</span><span class="hljs-params">(<span class="hljs-type">rt_sem_t</span>       sem,</span><br><span class="hljs-params">                    <span class="hljs-type">const</span> <span class="hljs-type">char</span>     *name,</span><br><span class="hljs-params">                    <span class="hljs-type">rt_uint32_t</span>    value,</span><br><span class="hljs-params">                    <span class="hljs-type">rt_uint8_t</span>     flag)</span><br></code></pre></td></tr></table></figure><p>flag见上↑</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>sem</td><td>信号量对象的句柄</td></tr><tr><td>name</td><td>信号量名称</td></tr><tr><td>value</td><td>信号量初始值</td></tr><tr><td>flag</td><td>信号量标志，它可以取如下数值： RT_IPC_FLAG_FIFO 或 RT_IPC_FLAG_PRIO</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>初始化成功</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_sem_detach</span><span class="hljs-params">(<span class="hljs-type">rt_sem_t</span> sem)</span>;<br></code></pre></td></tr></table></figure><p>使用该函数后，内核先唤醒所有挂在该信号量等待队列上的线程，然后将该信号量从内核对象管理器中脱离。原来挂起在信号量上的等待线程将获得 - RT_ERROR 的返回值。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>sem</td><td>信号量对象的句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>脱离成功</td></tr></tbody></table><h3 id="获取信号量-take"><a href="#获取信号量-take" class="headerlink" title="获取信号量-take"></a>获取信号量-take</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_sem_take</span> <span class="hljs-params">(<span class="hljs-type">rt_sem_t</span> sem, <span class="hljs-type">rt_int32_t</span> time)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>sem</td><td>信号量对象的句柄</td></tr><tr><td>time</td><td>指定的等待时间，单位是操作系统时钟节拍（OS Tick），或者RT_WAITING_FOREVER永远等待</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功获得信号量</td></tr><tr><td>-RT_ETIMEOUT</td><td>超时依然未获得信号量</td></tr><tr><td>-RT_ERROR</td><td>其他错误</td></tr></tbody></table><h3 id="无等待获取信号量-trytake"><a href="#无等待获取信号量-trytake" class="headerlink" title="无等待获取信号量-trytake"></a>无等待获取信号量-trytake</h3><p>当用户不想在申请的信号量上挂起线程进行等待时，可以使用无等待方式获取信号量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_sem_trytake</span><span class="hljs-params">(<span class="hljs-type">rt_sem_t</span> sem)</span>;<br></code></pre></td></tr></table></figure><p>这个函数与 rt_sem_take(sem, 0) 的作用相同，即当线程申请的信号量资源实例不可用的时候，它不会等待在该信号量上，而是直接返回 - RT_ETIMEOUT。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>sem</td><td>信号量对象的句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功获得信号量</td></tr><tr><td>-RT_ETIMEOUT</td><td>获取失败</td></tr></tbody></table><h3 id="释放信号量-release"><a href="#释放信号量-release" class="headerlink" title="释放信号量-release"></a>释放信号量-release</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_sem_release</span><span class="hljs-params">(<span class="hljs-type">rt_sem_t</span> sem)</span>;<br></code></pre></td></tr></table></figure><p>例如当信号量的值等于零时，并且有线程等待这个信号量时，释放信号量将唤醒等待在该信号量线程队列中的第一个线程，由它获取信号量；否则将把信号量的值加 1。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>sem</td><td>信号量对象的句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功释放信号量</td></tr></tbody></table><h2 id="信号量应用示例"><a href="#信号量应用示例" class="headerlink" title="信号量应用示例"></a>信号量应用示例</h2><p><strong>动态信号量的使用</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;rtthread.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_PRIORITY         25</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_TIMESLICE        5</span><br><br><span class="hljs-comment">/* 指向信号量的指针 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">rt_sem_t</span> dynamic_sem = RT_NULL;<br><br>ALIGN(RT_ALIGN_SIZE)<br><span class="hljs-type">static</span> <span class="hljs-type">char</span> thread1_stack[<span class="hljs-number">1024</span>];<br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_thread</span> <span class="hljs-title">thread1</span>;</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">rt_thread1_entry</span><span class="hljs-params">(<span class="hljs-type">void</span> *parameter)</span><br>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">rt_uint8_t</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(count &lt;= <span class="hljs-number">100</span>)<br>        &#123;<br>            count++;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-comment">/* count 每计数 10 次，就释放一次信号量 */</span><br>         <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> == (count % <span class="hljs-number">10</span>))<br>        &#123;<br>            rt_kprintf(<span class="hljs-string">&quot;t1 release a dynamic semaphore.\n&quot;</span>);<br>            rt_sem_release(dynamic_sem);<br>        &#125;<br>    &#125;<br>&#125;<br><br>ALIGN(RT_ALIGN_SIZE)<br><span class="hljs-type">static</span> <span class="hljs-type">char</span> thread2_stack[<span class="hljs-number">1024</span>];<br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_thread</span> <span class="hljs-title">thread2</span>;</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">rt_thread2_entry</span><span class="hljs-params">(<span class="hljs-type">void</span> *parameter)</span><br>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">rt_err_t</span> result;<br>    <span class="hljs-type">static</span> <span class="hljs-type">rt_uint8_t</span> number = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">/* 永久方式等待信号量，获取到信号量，则执行 number 自加的操作 */</span><br>        result = rt_sem_take(dynamic_sem, RT_WAITING_FOREVER);<br>        <span class="hljs-keyword">if</span> (result != RT_EOK)<br>        &#123;<br>            rt_kprintf(<span class="hljs-string">&quot;t2 take a dynamic semaphore, failed.\n&quot;</span>);<br>            rt_sem_delete(dynamic_sem);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            number++;<br>            rt_kprintf(<span class="hljs-string">&quot;t2 take a dynamic semaphore. number = %d\n&quot;</span> ,number);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* 信号量示例的初始化 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">semaphore_sample</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/* 创建一个动态信号量，初始值是 0 */</span><br>    dynamic_sem = rt_sem_create(<span class="hljs-string">&quot;dsem&quot;</span>, <span class="hljs-number">0</span>, RT_IPC_FLAG_FIFO);<br>    <span class="hljs-keyword">if</span> (dynamic_sem == RT_NULL)<br>    &#123;<br>        rt_kprintf(<span class="hljs-string">&quot;create dynamic semaphore failed.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        rt_kprintf(<span class="hljs-string">&quot;create done. dynamic semaphore value = 0.\n&quot;</span>);<br>    &#125;<br><br>    rt_thread_init(&amp;thread1,<br>                   <span class="hljs-string">&quot;thread1&quot;</span>,<br>                   rt_thread1_entry,<br>                   RT_NULL,<br>                   &amp;thread1_stack[<span class="hljs-number">0</span>],<br>                   <span class="hljs-keyword">sizeof</span>(thread1_stack),<br>                   THREAD_PRIORITY, THREAD_TIMESLICE);<br>    rt_thread_startup(&amp;thread1);<br><br>    rt_thread_init(&amp;thread2,<br>                   <span class="hljs-string">&quot;thread2&quot;</span>,<br>                   rt_thread2_entry,<br>                   RT_NULL,<br>                   &amp;thread2_stack[<span class="hljs-number">0</span>],<br>                   <span class="hljs-keyword">sizeof</span>(thread2_stack),<br>                   THREAD_PRIORITY<span class="hljs-number">-1</span>, THREAD_TIMESLICE);<br>    rt_thread_startup(&amp;thread2);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/* 导出到 msh 命令列表中 */</span><br>MSH_CMD_EXPORT(semaphore_sample, semaphore sample);<br></code></pre></td></tr></table></figure><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"> \ | /<br>- RT -     Thread Operating System<br> / | \     <span class="hljs-number">3.1</span><span class="hljs-number">.0</span> build Aug <span class="hljs-number">27</span> <span class="hljs-number">2018</span><br> <span class="hljs-number">2006</span> - <span class="hljs-number">2018</span> Copyright <span class="hljs-keyword">by</span> rt-thread team<br>msh &gt;semaphore_sample<br><span class="hljs-built_in">create</span> done. dynamic semaphore <span class="hljs-built_in">value</span> = <span class="hljs-number">0.</span><br>msh &gt;t1 release <span class="hljs-keyword">a</span> dynamic semaphore.<br>t2 take <span class="hljs-keyword">a</span> dynamic semaphore. <span class="hljs-built_in">number</span> = <span class="hljs-number">1</span><br>t1 release <span class="hljs-keyword">a</span> dynamic semaphore.<br>t2 take <span class="hljs-keyword">a</span> dynamic semaphore. <span class="hljs-built_in">number</span> = <span class="hljs-number">2</span><br>t1 release <span class="hljs-keyword">a</span> dynamic semaphore.<br>t2 take <span class="hljs-keyword">a</span> dynamic semaphore. <span class="hljs-built_in">number</span> = <span class="hljs-number">3</span><br>t1 release <span class="hljs-keyword">a</span> dynamic semaphore.<br>t2 take <span class="hljs-keyword">a</span> dynamic semaphore. <span class="hljs-built_in">number</span> = <span class="hljs-number">4</span><br>t1 release <span class="hljs-keyword">a</span> dynamic semaphore.<br>t2 take <span class="hljs-keyword">a</span> dynamic semaphore. <span class="hljs-built_in">number</span> = <span class="hljs-number">5</span><br>t1 release <span class="hljs-keyword">a</span> dynamic semaphore.<br>t2 take <span class="hljs-keyword">a</span> dynamic semaphore. <span class="hljs-built_in">number</span> = <span class="hljs-number">6</span><br>t1 release <span class="hljs-keyword">a</span> dynamic semaphore.<br>t2 take <span class="hljs-keyword">a</span> dynamic semaphore. <span class="hljs-built_in">number</span> = <span class="hljs-number">7</span><br>t1 release <span class="hljs-keyword">a</span> dynamic semaphore.<br>t2 take <span class="hljs-keyword">a</span> dynamic semaphore. <span class="hljs-built_in">number</span> = <span class="hljs-number">8</span><br>t1 release <span class="hljs-keyword">a</span> dynamic semaphore.<br>t2 take <span class="hljs-keyword">a</span> dynamic semaphore. <span class="hljs-built_in">number</span> = <span class="hljs-number">9</span><br>t1 release <span class="hljs-keyword">a</span> dynamic semaphore.<br>t2 take <span class="hljs-keyword">a</span> dynamic semaphore. <span class="hljs-built_in">number</span> = <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p><strong>信号量锁的作用，生产者消费者例程</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;rtthread.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_PRIORITY       6</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_STACK_SIZE     512</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_TIMESLICE      5</span><br><br><span class="hljs-comment">/* 定义最大 5 个元素能够被产生 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSEM 5</span><br><br><span class="hljs-comment">/* 用于放置生产的整数数组 */</span><br><span class="hljs-type">rt_uint32_t</span> <span class="hljs-built_in">array</span>[MAXSEM];<br><br><span class="hljs-comment">/* 指向生产者、消费者在 array 数组中的读写位置 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">rt_uint32_t</span> <span class="hljs-built_in">set</span>, get;<br><br><span class="hljs-comment">/* 指向线程控制块的指针 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">rt_thread_t</span> producer_tid = RT_NULL;<br><span class="hljs-type">static</span> <span class="hljs-type">rt_thread_t</span> consumer_tid = RT_NULL;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_semaphore</span> <span class="hljs-title">sem_lock</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_semaphore</span> <span class="hljs-title">sem_empty</span>, <span class="hljs-title">sem_full</span>;</span><br><br><span class="hljs-comment">/* 生产者线程入口 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">producer_thread_entry</span><span class="hljs-params">(<span class="hljs-type">void</span> *parameter)</span><br>&#123;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* 运行 10 次 */</span><br>    <span class="hljs-keyword">while</span> (cnt &lt; <span class="hljs-number">10</span>)<br>    &#123;<br>        <span class="hljs-comment">/* 获取一个空位 */</span><br>        rt_sem_take(&amp;sem_empty, RT_WAITING_FOREVER);<br><br>        <span class="hljs-comment">/* 修改 array 内容，上锁 */</span><br>        rt_sem_take(&amp;sem_lock, RT_WAITING_FOREVER);<br>        <span class="hljs-built_in">array</span>[<span class="hljs-built_in">set</span> % MAXSEM] = cnt + <span class="hljs-number">1</span>;<br>        rt_kprintf(<span class="hljs-string">&quot;the producer generates a number: %d\n&quot;</span>, <span class="hljs-built_in">array</span>[<span class="hljs-built_in">set</span> % MAXSEM]);<br>        <span class="hljs-built_in">set</span>++;<br>        rt_sem_release(&amp;sem_lock);<br><br>        <span class="hljs-comment">/* 发布一个满位 */</span><br>        rt_sem_release(&amp;sem_full);<br>        cnt++;<br><br>        <span class="hljs-comment">/* 暂停一段时间 */</span><br>        rt_thread_mdelay(<span class="hljs-number">20</span>);<br>    &#125;<br><br>    rt_kprintf(<span class="hljs-string">&quot;the producer exit!\n&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">/* 消费者线程入口 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">consumer_thread_entry</span><span class="hljs-params">(<span class="hljs-type">void</span> *parameter)</span><br>&#123;<br>    <span class="hljs-type">rt_uint32_t</span> sum = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">/* 获取一个满位 */</span><br>        rt_sem_take(&amp;sem_full, RT_WAITING_FOREVER);<br><br>        <span class="hljs-comment">/* 临界区，上锁进行操作 */</span><br>        rt_sem_take(&amp;sem_lock, RT_WAITING_FOREVER);<br>        sum += <span class="hljs-built_in">array</span>[get % MAXSEM];<br>        rt_kprintf(<span class="hljs-string">&quot;the consumer[%d] get a number: %d\n&quot;</span>, (get % MAXSEM), <span class="hljs-built_in">array</span>[get % MAXSEM]);<br>        get++;<br>        rt_sem_release(&amp;sem_lock);<br><br>        <span class="hljs-comment">/* 释放一个空位 */</span><br>        rt_sem_release(&amp;sem_empty);<br><br>        <span class="hljs-comment">/* 生产者生产到 10 个数目，停止，消费者线程相应停止 */</span><br>        <span class="hljs-keyword">if</span> (get == <span class="hljs-number">10</span>) <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-comment">/* 暂停一小会时间 */</span><br>        rt_thread_mdelay(<span class="hljs-number">50</span>);<br>    &#125;<br><br>    rt_kprintf(<span class="hljs-string">&quot;the consumer sum is: %d\n&quot;</span>, sum);<br>    rt_kprintf(<span class="hljs-string">&quot;the consumer exit!\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">producer_consumer</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-built_in">set</span> = <span class="hljs-number">0</span>;<br>    get = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* 初始化 3 个信号量 */</span><br>    rt_sem_init(&amp;sem_lock, <span class="hljs-string">&quot;lock&quot;</span>,     <span class="hljs-number">1</span>,      RT_IPC_FLAG_FIFO);<br>    rt_sem_init(&amp;sem_empty, <span class="hljs-string">&quot;empty&quot;</span>,   MAXSEM, RT_IPC_FLAG_FIFO);<br>    rt_sem_init(&amp;sem_full, <span class="hljs-string">&quot;full&quot;</span>,     <span class="hljs-number">0</span>,      RT_IPC_FLAG_FIFO);<br><br>    <span class="hljs-comment">/* 创建生产者线程 */</span><br>    producer_tid = rt_thread_create(<span class="hljs-string">&quot;producer&quot;</span>,<br>                                    producer_thread_entry, RT_NULL,<br>                                    THREAD_STACK_SIZE,<br>                                    THREAD_PRIORITY - <span class="hljs-number">1</span>,<br>                                    THREAD_TIMESLICE);<br>    <span class="hljs-keyword">if</span> (producer_tid != RT_NULL)<br>    &#123;<br>        rt_thread_startup(producer_tid);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        rt_kprintf(<span class="hljs-string">&quot;create thread producer failed&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* 创建消费者线程 */</span><br>    consumer_tid = rt_thread_create(<span class="hljs-string">&quot;consumer&quot;</span>,<br>                                    consumer_thread_entry, RT_NULL,<br>                                    THREAD_STACK_SIZE,<br>                                    THREAD_PRIORITY + <span class="hljs-number">1</span>,<br>                                    THREAD_TIMESLICE);<br>    <span class="hljs-keyword">if</span> (consumer_tid != RT_NULL)<br>    &#123;<br>        rt_thread_startup(consumer_tid);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        rt_kprintf(<span class="hljs-string">&quot;create thread consumer failed&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 导出到 msh 命令列表中 */</span><br>MSH_CMD_EXPORT(producer_consumer, producer_consumer sample);<br></code></pre></td></tr></table></figure><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">\ | /<br>- RT -     Thread Operating System<br> / | \     <span class="hljs-number">3.1</span><span class="hljs-number">.0</span> build Aug <span class="hljs-number">27</span> <span class="hljs-number">2018</span><br> <span class="hljs-number">2006</span> - <span class="hljs-number">2018</span> Copyright <span class="hljs-keyword">by</span> rt-thread team<br>msh &gt;producer_consumer<br><span class="hljs-keyword">the</span> producer generates <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">1</span><br><span class="hljs-keyword">the</span> consumer[<span class="hljs-number">0</span>] <span class="hljs-built_in">get</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">1</span><br>msh &gt;<span class="hljs-keyword">the</span> producer generates <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">2</span><br><span class="hljs-keyword">the</span> producer generates <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">3</span><br><span class="hljs-keyword">the</span> consumer[<span class="hljs-number">1</span>] <span class="hljs-built_in">get</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">2</span><br><span class="hljs-keyword">the</span> producer generates <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">4</span><br><span class="hljs-keyword">the</span> producer generates <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">5</span><br><span class="hljs-keyword">the</span> producer generates <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">6</span><br><span class="hljs-keyword">the</span> consumer[<span class="hljs-number">2</span>] <span class="hljs-built_in">get</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">3</span><br><span class="hljs-keyword">the</span> producer generates <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">7</span><br><span class="hljs-keyword">the</span> producer generates <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">8</span><br><span class="hljs-keyword">the</span> consumer[<span class="hljs-number">3</span>] <span class="hljs-built_in">get</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">4</span><br><span class="hljs-keyword">the</span> producer generates <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">9</span><br><span class="hljs-keyword">the</span> consumer[<span class="hljs-number">4</span>] <span class="hljs-built_in">get</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">5</span><br><span class="hljs-keyword">the</span> producer generates <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">10</span><br><span class="hljs-keyword">the</span> producer exit!<br><span class="hljs-keyword">the</span> consumer[<span class="hljs-number">0</span>] <span class="hljs-built_in">get</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">6</span><br><span class="hljs-keyword">the</span> consumer[<span class="hljs-number">1</span>] <span class="hljs-built_in">get</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">7</span><br><span class="hljs-keyword">the</span> consumer[<span class="hljs-number">2</span>] <span class="hljs-built_in">get</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">8</span><br><span class="hljs-keyword">the</span> consumer[<span class="hljs-number">3</span>] <span class="hljs-built_in">get</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">9</span><br><span class="hljs-keyword">the</span> consumer[<span class="hljs-number">4</span>] <span class="hljs-built_in">get</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span>: <span class="hljs-number">10</span><br><span class="hljs-keyword">the</span> consumer <span class="hljs-built_in">sum</span> is: <span class="hljs-number">55</span><br><span class="hljs-keyword">the</span> consumer exit!<br></code></pre></td></tr></table></figure><h2 id="互斥量-Mutex"><a href="#互斥量-Mutex" class="headerlink" title="互斥量 Mutex"></a>互斥量 Mutex</h2><p>互斥量又叫相互排斥的信号量，是一种特殊的二值信号量。</p><p>互斥量和信号量不同的是：拥有互斥量的线程拥有互斥量的所有权，互斥量支持递归访问且能防止线程优先级翻转；并且互斥量只能由持有线程释放，而信号量则可以由任何线程释放。</p><p><img src="/2021/42e53028/06mutex_work.png" alt="互斥量工作示意图"></p><p>线程优先级翻转如下。</p><p><img src="/2021/42e53028/06priority_inversion.png" alt="优先级反转 (M 为信号量)"></p><p><img src="/2021/42e53028/06priority_inherit.png" alt="优先级继承 (M 为互斥量)"></p><h3 id="互斥量API"><a href="#互斥量API" class="headerlink" title="互斥量API"></a>互斥量API</h3><p><img src="/2021/42e53028/06mutex_ops.png" alt="互斥量相关接口"></p><h3 id="创建和删除互斥量-create"><a href="#创建和删除互斥量-create" class="headerlink" title="创建和删除互斥量-create"></a>创建和删除互斥量-create</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_mutex_t</span> <span class="hljs-title function_">rt_mutex_create</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">rt_uint8_t</span> flag)</span>;<br></code></pre></td></tr></table></figure><p>互斥量的 flag 标志设置为 RT_IPC_FLAG_PRIO，表示在多个线程等待资源时，将由优先级高的线程优先获得资源。flag 设置为 RT_IPC_FLAG_FIFO，表示在多个线程等待资源时，将按照先来先得的顺序获得资源。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>name</td><td>互斥量的名称</td></tr><tr><td>flag</td><td>互斥量标志，它可以取如下数值： RT_IPC_FLAG_FIFO 或 RT_IPC_FLAG_PRIO</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>互斥量句柄</td><td>创建成功</td></tr><tr><td>RT_NULL</td><td>创建失败</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mutex_delete</span> <span class="hljs-params">(<span class="hljs-type">rt_mutex_t</span> mutex)</span>;<br></code></pre></td></tr></table></figure><p>当删除一个互斥量时，所有等待此互斥量的线程都将被唤醒，等待线程获得的返回值是 - RT_ERROR。然后系统将该互斥量从内核对象管理器链表中删除并释放互斥量占用的内存空间。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mutex</td><td>互斥量对象的句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>删除成功</td></tr></tbody></table><h3 id="初始化和脱离互斥量-init"><a href="#初始化和脱离互斥量-init" class="headerlink" title="初始化和脱离互斥量-init"></a>初始化和脱离互斥量-init</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mutex_init</span> <span class="hljs-params">(<span class="hljs-type">rt_mutex_t</span> mutex, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">rt_uint8_t</span> flag)</span>;<br></code></pre></td></tr></table></figure><p>flag见上</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mutex</td><td>互斥量对象的句柄，它由用户提供，并指向互斥量对象的内存块</td></tr><tr><td>name</td><td>互斥量的名称</td></tr><tr><td>flag</td><td>互斥量标志，它可以取如下数值： RT_IPC_FLAG_FIFO 或 RT_IPC_FLAG_PRIO</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>初始化成功</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mutex_detach</span> <span class="hljs-params">(<span class="hljs-type">rt_mutex_t</span> mutex)</span>;<br></code></pre></td></tr></table></figure><p>使用该函数接口后，内核先唤醒所有挂在该互斥量上的线程（线程的返回值是 -RT_ERROR），然后系统将该互斥量从内核对象管理器中脱离。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mutex</td><td>互斥量对象的句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr></tbody></table><h3 id="获取互斥量-take"><a href="#获取互斥量-take" class="headerlink" title="获取互斥量-take"></a>获取互斥量-take</h3><p>线程获取了互斥量，那么线程就有了对该互斥量的所有权，即某一个时刻一个互斥量只能被一个线程持有。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mutex_take</span> <span class="hljs-params">(<span class="hljs-type">rt_mutex_t</span> mutex, <span class="hljs-type">rt_int32_t</span> time)</span>;<br></code></pre></td></tr></table></figure><ul><li><p>如果互斥量没有被其他线程控制，那么申请该互斥量的线程将成功获得该互斥量。</p></li><li><p>如果互斥量已经被当前线程线程控制，则该互斥量的持有计数加 1，当前线程也不会挂起等待。</p></li><li><p>如果互斥量已经被其他线程占有，则当前线程在该互斥量上挂起等待，直到其他线程释放它或者等待时间超过指定的超时时间。</p></li></ul><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mutex</td><td>互斥量对象的句柄</td></tr><tr><td>time</td><td>指定等待的时间</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功获得互斥量</td></tr><tr><td>-RT_ETIMEOUT</td><td>超时</td></tr><tr><td>-RT_ERROR</td><td>获取失败</td></tr></tbody></table><h3 id="释放互斥量-release"><a href="#释放互斥量-release" class="headerlink" title="释放互斥量-release"></a>释放互斥量-release</h3><p>当线程完成互斥资源的访问后，应尽快释放它占据的互斥量，使得其他线程能及时获取该互斥量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mutex_release</span><span class="hljs-params">(<span class="hljs-type">rt_mutex_t</span> mutex)</span>;<br></code></pre></td></tr></table></figure><ul><li>只有已经拥有互斥量控制权的线程才能释放它，每释放一次该互斥量，它的持有计数就减 1。</li><li>当该互斥量的持有计数为零时（即持有线程已经释放所有的持有操作），它变为可用，等待在该信号量上的线程将被唤醒。</li></ul><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mutex</td><td>互斥量对象的句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr></tbody></table><h2 id="互斥量应用示例"><a href="#互斥量应用示例" class="headerlink" title="互斥量应用示例"></a>互斥量应用示例</h2><p>这是一个互斥量的应用例程，互斥锁是一种保护共享资源的方法。当一个线程拥有互斥锁的时候，可以保护共享资源不被其他线程破坏。下面用一个例子来说明，有两个线程：线程 1 和线程 2，线程 1 对 2 个 number 分别进行加 1 操作；线程 2 也对 2 个 number 分别进行加 1 操作，使用互斥量保证线程改变 2 个 number 值的操作不被打断。如下代码所示：</p><p><strong>互斥量例程</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;rtthread.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_PRIORITY         8</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_TIMESLICE        5</span><br><br><span class="hljs-comment">/* 指向互斥量的指针 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">rt_mutex_t</span> dynamic_mutex = RT_NULL;<br><span class="hljs-type">static</span> <span class="hljs-type">rt_uint8_t</span> number1,number2 = <span class="hljs-number">0</span>;<br><br>ALIGN(RT_ALIGN_SIZE)<br><span class="hljs-type">static</span> <span class="hljs-type">char</span> thread1_stack[<span class="hljs-number">1024</span>];<br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_thread</span> <span class="hljs-title">thread1</span>;</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">rt_thread_entry1</span><span class="hljs-params">(<span class="hljs-type">void</span> *parameter)</span><br>&#123;<br>      <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>      &#123;<br>          <span class="hljs-comment">/* 线程 1 获取到互斥量后，先后对 number1、number2 进行加 1 操作，然后释放互斥量 */</span><br>          rt_mutex_take(dynamic_mutex, RT_WAITING_FOREVER);<br>          number1++;<br>          rt_thread_mdelay(<span class="hljs-number">10</span>);<br>          number2++;<br>          rt_mutex_release(dynamic_mutex);<br>       &#125;<br>&#125;<br><br>ALIGN(RT_ALIGN_SIZE)<br><span class="hljs-type">static</span> <span class="hljs-type">char</span> thread2_stack[<span class="hljs-number">1024</span>];<br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_thread</span> <span class="hljs-title">thread2</span>;</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">rt_thread_entry2</span><span class="hljs-params">(<span class="hljs-type">void</span> *parameter)</span><br>&#123;<br>      <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>      &#123;<br>          <span class="hljs-comment">/* 线程 2 获取到互斥量后，检查 number1、number2 的值是否相同，相同则表示 mutex 起到了锁的作用 */</span><br>          rt_mutex_take(dynamic_mutex, RT_WAITING_FOREVER);<br>          <span class="hljs-keyword">if</span>(number1 != number2)<br>          &#123;<br>            rt_kprintf(<span class="hljs-string">&quot;not protect.number1 = %d, mumber2 = %d \n&quot;</span>,number1 ,number2);<br>          &#125;<br>          <span class="hljs-keyword">else</span><br>          &#123;<br>            rt_kprintf(<span class="hljs-string">&quot;mutex protect ,number1 = mumber2 is %d\n&quot;</span>,number1);<br>          &#125;<br><br>           number1++;<br>           number2++;<br>           rt_mutex_release(dynamic_mutex);<br><br>          <span class="hljs-keyword">if</span>(number1&gt;=<span class="hljs-number">50</span>)<br>              <span class="hljs-keyword">return</span>;<br>      &#125;<br>&#125;<br><br><span class="hljs-comment">/* 互斥量示例的初始化 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">mutex_sample</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/* 创建一个动态互斥量 */</span><br>    dynamic_mutex = rt_mutex_create(<span class="hljs-string">&quot;dmutex&quot;</span>, RT_IPC_FLAG_FIFO);<br>    <span class="hljs-keyword">if</span> (dynamic_mutex == RT_NULL)<br>    &#123;<br>        rt_kprintf(<span class="hljs-string">&quot;create dynamic mutex failed.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    rt_thread_init(&amp;thread1,<br>                   <span class="hljs-string">&quot;thread1&quot;</span>,<br>                   rt_thread_entry1,<br>                   RT_NULL,<br>                   &amp;thread1_stack[<span class="hljs-number">0</span>],<br>                   <span class="hljs-keyword">sizeof</span>(thread1_stack),<br>                   THREAD_PRIORITY, THREAD_TIMESLICE);<br>    rt_thread_startup(&amp;thread1);<br><br>    rt_thread_init(&amp;thread2,<br>                   <span class="hljs-string">&quot;thread2&quot;</span>,<br>                   rt_thread_entry2,<br>                   RT_NULL,<br>                   &amp;thread2_stack[<span class="hljs-number">0</span>],<br>                   <span class="hljs-keyword">sizeof</span>(thread2_stack),<br>                   THREAD_PRIORITY<span class="hljs-number">-1</span>, THREAD_TIMESLICE);<br>    rt_thread_startup(&amp;thread2);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 导出到 MSH 命令列表中 */</span><br>MSH_CMD_EXPORT(mutex_sample, mutex sample);<br></code></pre></td></tr></table></figure><p>线程 1 与线程 2 中均使用互斥量保护对 2 个 number 的操作（倘若将线程 1 中的获取、释放互斥量语句注释掉，线程 1 将对 number 不再做保护），仿真运行结果如下：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\</span> | /<br>- RT -     Thread Operating System<br> / | <span class="hljs-string">\</span>     <span class="hljs-number">3.1</span>.<span class="hljs-number">0</span> build Aug <span class="hljs-number">24</span> <span class="hljs-number">2018</span><br> <span class="hljs-number">2006</span> - <span class="hljs-number">2018</span> Copyright <span class="hljs-keyword">by</span> rt-thread team<br>msh &gt;mutex_sample<br>msh &gt;mutex protect ,number1 = mumber2 <span class="hljs-keyword">is</span> <span class="hljs-number">1</span><br>mutex protect ,number1 = mumber2 <span class="hljs-keyword">is</span> <span class="hljs-number">2</span><br>mutex protect ,number1 = mumber2 <span class="hljs-keyword">is</span> <span class="hljs-number">3</span><br>mutex protect ,number1 = mumber2 <span class="hljs-keyword">is</span> <span class="hljs-number">4</span><br>…<br>mutex protect ,number1 = mumber2 <span class="hljs-keyword">is</span> <span class="hljs-number">48</span><br>mutex protect ,number1 = mumber2 <span class="hljs-keyword">is</span> <span class="hljs-number">49</span><br></code></pre></td></tr></table></figure><p>线程使用互斥量保护对两个 number 的操作，使 number 值保持一致。</p><p>互斥量的另一个例子见下面的代码，这个例子将创建 3 个动态线程以检查持有互斥量时，持有的线程优先级是否被调整到等待线程优先级中的最高优先级。</p><p><strong>防止优先级翻转特性例程</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;rtthread.h&gt;</span></span><br><br><span class="hljs-comment">/* 指向线程控制块的指针 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">rt_thread_t</span> tid1 = RT_NULL;<br><span class="hljs-type">static</span> <span class="hljs-type">rt_thread_t</span> tid2 = RT_NULL;<br><span class="hljs-type">static</span> <span class="hljs-type">rt_thread_t</span> tid3 = RT_NULL;<br><span class="hljs-type">static</span> <span class="hljs-type">rt_mutex_t</span> mutex = RT_NULL;<br><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_PRIORITY       10</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_STACK_SIZE     512</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_TIMESLICE    5</span><br><br><span class="hljs-comment">/* 线程 1 入口 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">thread1_entry</span><span class="hljs-params">(<span class="hljs-type">void</span> *parameter)</span><br>&#123;<br>    <span class="hljs-comment">/* 先让低优先级线程运行 */</span><br>    rt_thread_mdelay(<span class="hljs-number">100</span>);<br><br>    <span class="hljs-comment">/* 此时 thread3 持有 mutex，并且 thread2 等待持有 mutex */</span><br><br>    <span class="hljs-comment">/* 检查 thread2 与 thread3 的优先级情况 */</span><br>    <span class="hljs-keyword">if</span> (tid2-&gt;current_priority != tid3-&gt;current_priority)<br>    &#123;<br>        <span class="hljs-comment">/* 优先级不相同，测试失败 */</span><br>        rt_kprintf(<span class="hljs-string">&quot;the priority of thread2 is: %d\n&quot;</span>, tid2-&gt;current_priority);<br>        rt_kprintf(<span class="hljs-string">&quot;the priority of thread3 is: %d\n&quot;</span>, tid3-&gt;current_priority);<br>        rt_kprintf(<span class="hljs-string">&quot;test failed.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        rt_kprintf(<span class="hljs-string">&quot;the priority of thread2 is: %d\n&quot;</span>, tid2-&gt;current_priority);<br>        rt_kprintf(<span class="hljs-string">&quot;the priority of thread3 is: %d\n&quot;</span>, tid3-&gt;current_priority);<br>        rt_kprintf(<span class="hljs-string">&quot;test OK.\n&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* 线程 2 入口 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">thread2_entry</span><span class="hljs-params">(<span class="hljs-type">void</span> *parameter)</span><br>&#123;<br>    <span class="hljs-type">rt_err_t</span> result;<br><br>    rt_kprintf(<span class="hljs-string">&quot;the priority of thread2 is: %d\n&quot;</span>, tid2-&gt;current_priority);<br><br>    <span class="hljs-comment">/* 先让低优先级线程运行 */</span><br>    rt_thread_mdelay(<span class="hljs-number">50</span>);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 试图持有互斥锁，此时 thread3 持有，应把 thread3 的优先级提升</span><br><span class="hljs-comment">     * 到 thread2 相同的优先级</span><br><span class="hljs-comment">     */</span><br>    result = rt_mutex_take(mutex, RT_WAITING_FOREVER);<br><br>    <span class="hljs-keyword">if</span> (result == RT_EOK)<br>    &#123;<br>        <span class="hljs-comment">/* 释放互斥锁 */</span><br>        rt_mutex_release(mutex);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* 线程 3 入口 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">thread3_entry</span><span class="hljs-params">(<span class="hljs-type">void</span> *parameter)</span><br>&#123;<br>    <span class="hljs-type">rt_tick_t</span> tick;<br>    <span class="hljs-type">rt_err_t</span> result;<br><br>    rt_kprintf(<span class="hljs-string">&quot;the priority of thread3 is: %d\n&quot;</span>, tid3-&gt;current_priority);<br><br>    result = rt_mutex_take(mutex, RT_WAITING_FOREVER);<br>    <span class="hljs-keyword">if</span> (result != RT_EOK)<br>    &#123;<br>        rt_kprintf(<span class="hljs-string">&quot;thread3 take a mutex, failed.\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* 做一个长时间的循环，500ms */</span><br>    tick = rt_tick_get();<br>    <span class="hljs-keyword">while</span> (rt_tick_get() - tick &lt; (RT_TICK_PER_SECOND / <span class="hljs-number">2</span>)) ;<br><br>    rt_mutex_release(mutex);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">pri_inversion</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/* 创建互斥锁 */</span><br>    mutex = rt_mutex_create(<span class="hljs-string">&quot;mutex&quot;</span>, RT_IPC_FLAG_FIFO);<br>    <span class="hljs-keyword">if</span> (mutex == RT_NULL)<br>    &#123;<br>        rt_kprintf(<span class="hljs-string">&quot;create dynamic mutex failed.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* 创建线程 1 */</span><br>    tid1 = rt_thread_create(<span class="hljs-string">&quot;thread1&quot;</span>,<br>                            thread1_entry,<br>                            RT_NULL,<br>                            THREAD_STACK_SIZE,<br>                            THREAD_PRIORITY - <span class="hljs-number">1</span>, THREAD_TIMESLICE);<br>    <span class="hljs-keyword">if</span> (tid1 != RT_NULL)<br>         rt_thread_startup(tid1);<br><br>    <span class="hljs-comment">/* 创建线程 2 */</span><br>    tid2 = rt_thread_create(<span class="hljs-string">&quot;thread2&quot;</span>,<br>                            thread2_entry,<br>                            RT_NULL,<br>                            THREAD_STACK_SIZE,<br>                            THREAD_PRIORITY, THREAD_TIMESLICE);<br>    <span class="hljs-keyword">if</span> (tid2 != RT_NULL)<br>        rt_thread_startup(tid2);<br><br>    <span class="hljs-comment">/* 创建线程 3 */</span><br>    tid3 = rt_thread_create(<span class="hljs-string">&quot;thread3&quot;</span>,<br>                            thread3_entry,<br>                            RT_NULL,<br>                            THREAD_STACK_SIZE,<br>                            THREAD_PRIORITY + <span class="hljs-number">1</span>, THREAD_TIMESLICE);<br>    <span class="hljs-keyword">if</span> (tid3 != RT_NULL)<br>        rt_thread_startup(tid3);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 导出到 msh 命令列表中 */</span><br>MSH_CMD_EXPORT(pri_inversion, prio_inversion sample);<br></code></pre></td></tr></table></figure><p>仿真运行结果如下：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs subunit">\ | /<br>- RT -     Thread Operating System<br> / | \     3.1.0 build Aug 27 2018<br> 2006 - 2018 Copyright by rt-thread team<br>msh &gt;pri_inversion<br>the priority of thread2 is: 10<br>the priority of thread3 is: 11<br>the priority of thread2 is: 10<br>the priority of thread3 is: 10<br><span class="hljs-keyword">test </span>OK.<br></code></pre></td></tr></table></figure><h2 id="事件集Event"><a href="#事件集Event" class="headerlink" title="事件集Event"></a>事件集Event</h2><p>一个事件集可以包含多个事件，利用事件集可以完成<strong>一对多</strong>，<strong>多对多</strong>，<strong>多对一</strong>的线程间同步。</p><p>这种多个事件的集合可以用一个 32 位无符号整型变量来表示，变量的每一位代表一个事件，线程通过 “逻辑与” 或“逻辑或”将一个或多个事件关联起来，形成事件组合。</p><ul><li>事件的 “逻辑或” 也称为是独立型同步，指的是线程与任何事件之一发生同步；</li><li>事件 “逻辑与” 也称为是关联型同步，指的是线程与若干事件都发生同步。</li><li>事件只与线程相关，事件间相互独立：每个线程可拥有 32 个事件标志，采用一个 32 bit 无符号整型数进行记录，每一个 bit 代表一个事件；</li><li>事件仅用于同步，不提供数据传输功能；</li><li>事件无排队性，即多次向线程发送同一事件 (如果线程还未来得及读走)，其效果等同于只发送一次。</li></ul><p><img src="/2021/42e53028/06event_work.png" alt="事件集工作示意图"></p><p>线程 #1 的事件标志中第 1 位和第 30 位被置位，如果事件信息标记位设为逻辑与，则表示线程 #1 只有在事件 1 和事件 30 都发生以后才会被触发唤醒，如果事件信息标记位设为逻辑或，则事件 1 或事件 30 中的任意一个发生都会触发唤醒线程 #1。如果信息标记同时设置了清除标记位，则当线程 #1 唤醒后将主动把事件 1 和事件 30 清为零，否则事件标志将依然存在（即置 1）。</p><h3 id="事件集API"><a href="#事件集API" class="headerlink" title="事件集API"></a>事件集API</h3><p><img src="/2021/42e53028/06event_ops.png" alt="事件相关接口"></p><h3 id="创建和删除事件集-create"><a href="#创建和删除事件集-create" class="headerlink" title="创建和删除事件集-create"></a>创建和删除事件集-create</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_event_t</span> <span class="hljs-title function_">rt_event_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">rt_uint8_t</span> flag)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>name</td><td>事件集的名称</td></tr><tr><td>flag</td><td>事件集的标志，它可以取如下数值： RT_IPC_FLAG_FIFO 或 RT_IPC_FLAG_PRIO</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_NULL</td><td>创建失败</td></tr><tr><td>事件对象的句柄</td><td>创建成功</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_event_delete</span><span class="hljs-params">(<span class="hljs-type">rt_event_t</span> event)</span>;<br></code></pre></td></tr></table></figure><p>在删除前会唤醒所有挂起在该事件集上的线程（线程的返回值是 - RT_ERROR），然后释放事件集对象占用的内存块。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>event</td><td>事件集对象的句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr></tbody></table><h3 id="初始化和脱离事件集-init"><a href="#初始化和脱离事件集-init" class="headerlink" title="初始化和脱离事件集-init"></a>初始化和脱离事件集-init</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_event_init</span><span class="hljs-params">(<span class="hljs-type">rt_event_t</span> event, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">rt_uint8_t</span> flag)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>event</td><td>事件集对象的句柄</td></tr><tr><td>name</td><td>事件集的名称</td></tr><tr><td>flag</td><td>事件集的标志，它可以取如下数值： RT_IPC_FLAG_FIFO 或 RT_IPC_FLAG_PRIO</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_event_detach</span><span class="hljs-params">(<span class="hljs-type">rt_event_t</span> event)</span>;<br></code></pre></td></tr></table></figure><p>用户调用这个函数时，系统首先唤醒所有挂在该事件集等待队列上的线程（线程的返回值是 - RT_ERROR），然后将该事件集从内核对象管理器中脱离。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>event</td><td>事件集对象的句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr></tbody></table><h3 id="发送事件-send"><a href="#发送事件-send" class="headerlink" title="发送事件-send"></a>发送事件-send</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_event_send</span><span class="hljs-params">(<span class="hljs-type">rt_event_t</span> event, <span class="hljs-type">rt_uint32_t</span> <span class="hljs-built_in">set</span>)</span>;<br></code></pre></td></tr></table></figure><p>使用该函数接口时，通过参数 set 指定的事件标志来设定 event 事件集对象的事件标志值，然后遍历等待在 event 事件集对象上的等待线程链表，判断是否有线程的事件激活要求与当前 event 对象事件标志值匹配，如果有，则唤醒该线程。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>event</td><td>事件集对象的句柄</td></tr><tr><td>set</td><td>发送的一个或多个事件的标志值,它可以取如下数值： RT_IPC_FLAG_FIFO 或 RT_IPC_FLAG_PRIO</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr></tbody></table><h3 id="接收事件-recv"><a href="#接收事件-recv" class="headerlink" title="接收事件-recv"></a>接收事件-recv</h3><p>内核使用 32 位的无符号整数来标识事件集，它的每一位代表一个事件，因此一个事件集对象可同时等待接收 32 个事件.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_event_recv</span><span class="hljs-params">(<span class="hljs-type">rt_event_t</span> event,</span><br><span class="hljs-params">                           <span class="hljs-type">rt_uint32_t</span> <span class="hljs-built_in">set</span>,</span><br><span class="hljs-params">                           <span class="hljs-type">rt_uint8_t</span> option,</span><br><span class="hljs-params">                           <span class="hljs-type">rt_int32_t</span> timeout,</span><br><span class="hljs-params">                           <span class="hljs-type">rt_uint32_t</span>* recved)</span>;<br></code></pre></td></tr></table></figure><p>当用户调用这个接口时，系统首先根据 set 参数和接收选项 option 来判断它要接收的事件是否发生，如果已经发生，则根据参数 option 上是否设置有 RT_EVENT_FLAG_CLEAR 来决定是否重置事件的相应标志位，然后返回（其中 recved 参数返回接收到的事件）；如果没有发生，则把等待的 set 和 option 参数填入线程本身的结构中，然后把线程挂起在此事件上，直到其等待的事件满足条件或等待时间超过指定的超时时间。如果超时时间设置为零，则表示当线程要接受的事件没有满足其要求时就不等待，而直接返回 - RT_ETIMEOUT。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>event</td><td>事件集对象的句柄</td></tr><tr><td>set</td><td>接收线程感兴趣的事件</td></tr><tr><td>option</td><td>接收选项 <strong>可取值见下</strong></td></tr><tr><td>timeout</td><td>指定超时时间</td></tr><tr><td>recved</td><td>指向接收到的事件</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr><tr><td>-RT_ETIMEOUT</td><td>超时</td></tr><tr><td>-RT_ERROR</td><td>错误</td></tr></tbody></table><p>option 的值可取：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 选择 逻辑与 或 逻辑或 的方式接收事件 */</span><br>RT_EVENT_FLAG_OR<br>RT_EVENT_FLAG_AND<br><br><span class="hljs-comment">/* 选择清除重置事件标志位 */</span><br>RT_EVENT_FLAG_CLEAR<br></code></pre></td></tr></table></figure><h2 id="事件集应用示例"><a href="#事件集应用示例" class="headerlink" title="事件集应用示例"></a>事件集应用示例</h2><p>这是事件集的应用例程，例子中初始化了一个事件集，两个线程。一个线程等待自己关心的事件发生，另外一个线程发送事件，如代码清单 6-5 例所示：</p><p>事件集的使用例程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;rtthread.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_PRIORITY      9</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_TIMESLICE     5</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EVENT_FLAG3 (1 &lt;&lt; 3)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EVENT_FLAG5 (1 &lt;&lt; 5)</span><br><br><span class="hljs-comment">/* 事件控制块 */</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_event</span> <span class="hljs-title">event</span>;</span><br><br>ALIGN(RT_ALIGN_SIZE)<br><span class="hljs-type">static</span> <span class="hljs-type">char</span> thread1_stack[<span class="hljs-number">1024</span>];<br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_thread</span> <span class="hljs-title">thread1</span>;</span><br><br><span class="hljs-comment">/* 线程 1 入口函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">thread1_recv_event</span><span class="hljs-params">(<span class="hljs-type">void</span> *param)</span><br>&#123;<br>    <span class="hljs-type">rt_uint32_t</span> e;<br><br>    <span class="hljs-comment">/* 第一次接收事件，事件 3 或事件 5 任意一个可以触发线程 1，接收完后清除事件标志 */</span><br>    <span class="hljs-keyword">if</span> (rt_event_recv(&amp;event, (EVENT_FLAG3 | EVENT_FLAG5),<br>                      RT_EVENT_FLAG_OR | RT_EVENT_FLAG_CLEAR,<br>                      RT_WAITING_FOREVER, &amp;e) == RT_EOK)<br>    &#123;<br>        rt_kprintf(<span class="hljs-string">&quot;thread1: OR recv event 0x%x\n&quot;</span>, e);<br>    &#125;<br><br>    rt_kprintf(<span class="hljs-string">&quot;thread1: delay 1s to prepare the second event\n&quot;</span>);<br>    rt_thread_mdelay(<span class="hljs-number">1000</span>);<br><br>    <span class="hljs-comment">/* 第二次接收事件，事件 3 和事件 5 均发生时才可以触发线程 1，接收完后清除事件标志 */</span><br>    <span class="hljs-keyword">if</span> (rt_event_recv(&amp;event, (EVENT_FLAG3 | EVENT_FLAG5),<br>                      RT_EVENT_FLAG_AND | RT_EVENT_FLAG_CLEAR,<br>                      RT_WAITING_FOREVER, &amp;e) == RT_EOK)<br>    &#123;<br>        rt_kprintf(<span class="hljs-string">&quot;thread1: AND recv event 0x%x\n&quot;</span>, e);<br>    &#125;<br>    rt_kprintf(<span class="hljs-string">&quot;thread1 leave.\n&quot;</span>);<br>&#125;<br><br><br>ALIGN(RT_ALIGN_SIZE)<br><span class="hljs-type">static</span> <span class="hljs-type">char</span> thread2_stack[<span class="hljs-number">1024</span>];<br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_thread</span> <span class="hljs-title">thread2</span>;</span><br><br><span class="hljs-comment">/* 线程 2 入口 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">thread2_send_event</span><span class="hljs-params">(<span class="hljs-type">void</span> *param)</span><br>&#123;<br>    rt_kprintf(<span class="hljs-string">&quot;thread2: send event3\n&quot;</span>);<br>    rt_event_send(&amp;event, EVENT_FLAG3);<br>    rt_thread_mdelay(<span class="hljs-number">200</span>);<br><br>    rt_kprintf(<span class="hljs-string">&quot;thread2: send event5\n&quot;</span>);<br>    rt_event_send(&amp;event, EVENT_FLAG5);<br>    rt_thread_mdelay(<span class="hljs-number">200</span>);<br><br>    rt_kprintf(<span class="hljs-string">&quot;thread2: send event3\n&quot;</span>);<br>    rt_event_send(&amp;event, EVENT_FLAG3);<br>    rt_kprintf(<span class="hljs-string">&quot;thread2 leave.\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">event_sample</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">rt_err_t</span> result;<br><br>    <span class="hljs-comment">/* 初始化事件对象 */</span><br>    result = rt_event_init(&amp;event, <span class="hljs-string">&quot;event&quot;</span>, RT_IPC_FLAG_FIFO);<br>    <span class="hljs-keyword">if</span> (result != RT_EOK)<br>    &#123;<br>        rt_kprintf(<span class="hljs-string">&quot;init event failed.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    rt_thread_init(&amp;thread1,<br>                   <span class="hljs-string">&quot;thread1&quot;</span>,<br>                   thread1_recv_event,<br>                   RT_NULL,<br>                   &amp;thread1_stack[<span class="hljs-number">0</span>],<br>                   <span class="hljs-keyword">sizeof</span>(thread1_stack),<br>                   THREAD_PRIORITY - <span class="hljs-number">1</span>, THREAD_TIMESLICE);<br>    rt_thread_startup(&amp;thread1);<br><br>    rt_thread_init(&amp;thread2,<br>                   <span class="hljs-string">&quot;thread2&quot;</span>,<br>                   thread2_send_event,<br>                   RT_NULL,<br>                   &amp;thread2_stack[<span class="hljs-number">0</span>],<br>                   <span class="hljs-keyword">sizeof</span>(thread2_stack),<br>                   THREAD_PRIORITY, THREAD_TIMESLICE);<br>    rt_thread_startup(&amp;thread2);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 导出到 msh 命令列表中 */</span><br>MSH_CMD_EXPORT(event_sample, event sample);<br></code></pre></td></tr></table></figure><p>仿真运行结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"> \ | /<br>- RT -     Thread Operating System<br> / | \     <span class="hljs-number">3.1</span><span class="hljs-number">.0</span> build Aug <span class="hljs-number">24</span> <span class="hljs-number">2018</span><br> <span class="hljs-number">2006</span> - <span class="hljs-number">2018</span> Copyright by rt-thread team<br>msh &gt;event_sample<br>thread2: send event3<br>thread1: OR recv event <span class="hljs-number">0x8</span><br>thread1: delay <span class="hljs-number">1</span>s to prepare the second event<br>msh &gt;thread2: send event5<br>thread2: send event3<br>thread2 leave.<br>thread1: AND recv event <span class="hljs-number">0x28</span><br>thread1 leave.<br></code></pre></td></tr></table></figure><h2 id="笔记-2"><a href="#笔记-2" class="headerlink" title="笔记"></a>笔记</h2><p>Semaphore:值、数值</p><p>Mutex:二值性、只能持有进程释放</p><p>Event:32Bit、进行’’或’’和’’与’’操作</p><ul><li>在获得互斥量后，请尽快释放互斥量，并且在持有互斥量的过程中，不得再行更改持有互斥量线程的优先级。</li><li>互斥量不能在中断服务例程中使用。</li></ul><h1 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h1><h2 id="邮箱Mailbox"><a href="#邮箱Mailbox" class="headerlink" title="邮箱Mailbox"></a>邮箱Mailbox</h2><p>邮箱用于线程间通信，特点是开销比较低，效率较高。邮箱中的每一封邮件只能容纳固定的 4 字节内容（针对 32 位处理系统，指针的大小即为 4 个字节，所以一封邮件恰好能够容纳一个指针）。</p><p>如下图所示，线程或中断服务例程把一封 4 字节长度的邮件发送到邮箱中，而一个或多个线程可以从邮箱中接收这些邮件并进行处理。</p><p><img src="/2021/42e53028/07mb_work.png" alt="邮箱工作示意图"></p><h3 id="邮箱API"><a href="#邮箱API" class="headerlink" title="邮箱API"></a>邮箱API</h3><p><img src="/2021/42e53028/07mb_ops.png" alt="邮箱相关接口"></p><h3 id="创建和删除邮箱-create"><a href="#创建和删除邮箱-create" class="headerlink" title="创建和删除邮箱-create"></a>创建和删除邮箱-create</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_mailbox_t</span> <span class="hljs-title function_">rt_mb_create</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">rt_size_t</span> size, <span class="hljs-type">rt_uint8_t</span> flag)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>name</td><td>邮箱名称</td></tr><tr><td>size</td><td>邮箱容量</td></tr><tr><td>flag</td><td>邮箱标志，它可以取如下数值： RT_IPC_FLAG_FIFO 或 RT_IPC_FLAG_PRIO</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_NULL</td><td>创建失败</td></tr><tr><td>邮箱对象的句柄</td><td>创建成功</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mb_delete</span> <span class="hljs-params">(<span class="hljs-type">rt_mailbox_t</span> mb)</span>;<br></code></pre></td></tr></table></figure><p>删除邮箱时，如果有线程被挂起在该邮箱对象上，内核先唤醒挂起在该邮箱上的所有线程（线程返回值是 - RT_ERROR），然后再释放邮箱使用的内存，最后删除邮箱对象。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mb</td><td>邮箱对象的句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr></tbody></table><h3 id="初始化和脱离邮箱-init"><a href="#初始化和脱离邮箱-init" class="headerlink" title="初始化和脱离邮箱-init"></a>初始化和脱离邮箱-init</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mb_init</span><span class="hljs-params">(<span class="hljs-type">rt_mailbox_t</span> mb,</span><br><span class="hljs-params">                  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name,</span><br><span class="hljs-params">                  <span class="hljs-type">void</span>* msgpool,</span><br><span class="hljs-params">                  <span class="hljs-type">rt_size_t</span> size,</span><br><span class="hljs-params">                  <span class="hljs-type">rt_uint8_t</span> flag)</span><br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mb</td><td>邮箱对象的句柄</td></tr><tr><td>name</td><td>邮箱名称</td></tr><tr><td>msgpool</td><td>缓冲区指针</td></tr><tr><td>size</td><td>邮箱容量</td></tr><tr><td>flag</td><td>邮箱标志，它可以取如下数值： RT_IPC_FLAG_FIFO 或 RT_IPC_FLAG_PRIO</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr></tbody></table><p>即如果 msgpool 指向的缓冲区的字节数是 N，那么邮箱容量应该是 N&#x2F;4。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mb_detach</span><span class="hljs-params">(<span class="hljs-type">rt_mailbox_t</span> mb)</span>;<br></code></pre></td></tr></table></figure><p>使用该函数接口后，内核先唤醒所有挂在该邮箱上的线程（线程获得返回值是 - RT_ERROR），然后将该邮箱对象从内核对象管理器中脱离。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mb</td><td>邮箱对象的句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr></tbody></table><h3 id="发送邮件-send"><a href="#发送邮件-send" class="headerlink" title="发送邮件-send"></a>发送邮件-send</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mb_send</span> <span class="hljs-params">(<span class="hljs-type">rt_mailbox_t</span> mb, <span class="hljs-type">rt_uint32_t</span> value)</span>;<br></code></pre></td></tr></table></figure><p>发送的邮件可以是 32 位任意格式的数据，一个整型值或者一个指向缓冲区的指针。当邮箱中的邮件已经满时，发送邮件的线程或者中断程序会收到 -RT_EFULL 的返回值。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mb</td><td>邮箱对象的句柄</td></tr><tr><td>value</td><td>邮件内容</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>发送成功</td></tr><tr><td>-RT_EFULL</td><td>邮箱已经满了</td></tr></tbody></table><h3 id="等待方式发送邮件-wait-send"><a href="#等待方式发送邮件-wait-send" class="headerlink" title="等待方式发送邮件-wait send"></a>等待方式发送邮件-wait send</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mb_send_wait</span> <span class="hljs-params">(<span class="hljs-type">rt_mailbox_t</span> mb,</span><br><span class="hljs-params">                      <span class="hljs-type">rt_uint32_t</span> value,</span><br><span class="hljs-params">                      <span class="hljs-type">rt_int32_t</span> timeout)</span>;<br></code></pre></td></tr></table></figure><p>rt_mb_send_wait() 与 rt_mb_send() 的区别在于有等待时间，如果邮箱已经满了，那么发送线程将根据设定的 timeout 参数等待邮箱中因为收取邮件而空出空间。如果设置的超时时间到达依然没有空出空间，这时发送线程将被唤醒并返回错误码。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mb</td><td>邮箱对象的句柄</td></tr><tr><td>value</td><td>邮件内容</td></tr><tr><td>timeout</td><td>超时时间</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>发送成功</td></tr><tr><td>-RT_ETIMEOUT</td><td>超时</td></tr><tr><td>-RT_ERROR</td><td>失败，返回错误</td></tr></tbody></table><h3 id="接收邮件-recv"><a href="#接收邮件-recv" class="headerlink" title="接收邮件-recv"></a>接收邮件-recv</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mb_recv</span> <span class="hljs-params">(<span class="hljs-type">rt_mailbox_t</span> mb, <span class="hljs-type">rt_uint32_t</span>* value, <span class="hljs-type">rt_int32_t</span> timeout)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mb</td><td>邮箱对象的句柄</td></tr><tr><td>value</td><td>邮件内容</td></tr><tr><td>timeout</td><td>超时时间</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>发送成功</td></tr><tr><td>-RT_ETIMEOUT</td><td>超时</td></tr><tr><td>-RT_ERROR</td><td>失败，返回错误</td></tr></tbody></table><h2 id="邮箱应用示例"><a href="#邮箱应用示例" class="headerlink" title="邮箱应用示例"></a>邮箱应用示例</h2><p>这是一个邮箱的应用例程，初始化 2 个静态线程，一个静态的邮箱对象，其中一个线程往邮箱中发送邮件，一个线程往邮箱中收取邮件。如下代码所示：</p><p>邮箱的使用例程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;rtthread.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_PRIORITY      10</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_TIMESLICE     5</span><br><br><span class="hljs-comment">/* 邮箱控制块 */</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_mailbox</span> <span class="hljs-title">mb</span>;</span><br><span class="hljs-comment">/* 用于放邮件的内存池 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">char</span> mb_pool[<span class="hljs-number">128</span>];<br><br><span class="hljs-type">static</span> <span class="hljs-type">char</span> mb_str1[] = <span class="hljs-string">&quot;I&#x27;m a mail!&quot;</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">char</span> mb_str2[] = <span class="hljs-string">&quot;this is another mail!&quot;</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">char</span> mb_str3[] = <span class="hljs-string">&quot;over&quot;</span>;<br><br>ALIGN(RT_ALIGN_SIZE)<br><span class="hljs-type">static</span> <span class="hljs-type">char</span> thread1_stack[<span class="hljs-number">1024</span>];<br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_thread</span> <span class="hljs-title">thread1</span>;</span><br><br><span class="hljs-comment">/* 线程 1 入口 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">thread1_entry</span><span class="hljs-params">(<span class="hljs-type">void</span> *parameter)</span><br>&#123;<br>    <span class="hljs-type">char</span> *str;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        rt_kprintf(<span class="hljs-string">&quot;thread1: try to recv a mail\n&quot;</span>);<br><br>        <span class="hljs-comment">/* 从邮箱中收取邮件 */</span><br>        <span class="hljs-keyword">if</span> (rt_mb_recv(&amp;mb, (<span class="hljs-type">rt_uint32_t</span> *)&amp;str, RT_WAITING_FOREVER) == RT_EOK)<br>        &#123;<br>            rt_kprintf(<span class="hljs-string">&quot;thread1: get a mail from mailbox, the content:%s\n&quot;</span>, str);<br>            <span class="hljs-keyword">if</span> (str == mb_str3)<br>                <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-comment">/* 延时 100ms */</span><br>            rt_thread_mdelay(<span class="hljs-number">100</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/* 执行邮箱对象脱离 */</span><br>    rt_mb_detach(&amp;mb);<br>&#125;<br><br>ALIGN(RT_ALIGN_SIZE)<br><span class="hljs-type">static</span> <span class="hljs-type">char</span> thread2_stack[<span class="hljs-number">1024</span>];<br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_thread</span> <span class="hljs-title">thread2</span>;</span><br><br><span class="hljs-comment">/* 线程 2 入口 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">thread2_entry</span><span class="hljs-params">(<span class="hljs-type">void</span> *parameter)</span><br>&#123;<br>    <span class="hljs-type">rt_uint8_t</span> count;<br><br>    count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (count &lt; <span class="hljs-number">10</span>)<br>    &#123;<br>        count ++;<br>        <span class="hljs-keyword">if</span> (count &amp; <span class="hljs-number">0x1</span>)<br>        &#123;<br>            <span class="hljs-comment">/* 发送 mb_str1 地址到邮箱中 */</span><br>            rt_mb_send(&amp;mb, (<span class="hljs-type">rt_uint32_t</span>)&amp;mb_str1);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">/* 发送 mb_str2 地址到邮箱中 */</span><br>            rt_mb_send(&amp;mb, (<span class="hljs-type">rt_uint32_t</span>)&amp;mb_str2);<br>        &#125;<br><br>        <span class="hljs-comment">/* 延时 200ms */</span><br>        rt_thread_mdelay(<span class="hljs-number">200</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* 发送邮件告诉线程 1，线程 2 已经运行结束 */</span><br>    rt_mb_send(&amp;mb, (<span class="hljs-type">rt_uint32_t</span>)&amp;mb_str3);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">mailbox_sample</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">rt_err_t</span> result;<br><br>    <span class="hljs-comment">/* 初始化一个 mailbox */</span><br>    result = rt_mb_init(&amp;mb,<br>                        <span class="hljs-string">&quot;mbt&quot;</span>,                      <span class="hljs-comment">/* 名称是 mbt */</span><br>                        &amp;mb_pool[<span class="hljs-number">0</span>],                <span class="hljs-comment">/* 邮箱用到的内存池是 mb_pool */</span><br>                        <span class="hljs-keyword">sizeof</span>(mb_pool) / <span class="hljs-number">4</span>,        <span class="hljs-comment">/* 邮箱中的邮件数目，因为一封邮件占 4 字节 */</span><br>                        RT_IPC_FLAG_FIFO);          <span class="hljs-comment">/* 采用 FIFO 方式进行线程等待 */</span><br>    <span class="hljs-keyword">if</span> (result != RT_EOK)<br>    &#123;<br>        rt_kprintf(<span class="hljs-string">&quot;init mailbox failed.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    rt_thread_init(&amp;thread1,<br>                   <span class="hljs-string">&quot;thread1&quot;</span>,<br>                   thread1_entry,<br>                   RT_NULL,<br>                   &amp;thread1_stack[<span class="hljs-number">0</span>],<br>                   <span class="hljs-keyword">sizeof</span>(thread1_stack),<br>                   THREAD_PRIORITY, THREAD_TIMESLICE);<br>    rt_thread_startup(&amp;thread1);<br><br>    rt_thread_init(&amp;thread2,<br>                   <span class="hljs-string">&quot;thread2&quot;</span>,<br>                   thread2_entry,<br>                   RT_NULL,<br>                   &amp;thread2_stack[<span class="hljs-number">0</span>],<br>                   <span class="hljs-keyword">sizeof</span>(thread2_stack),<br>                   THREAD_PRIORITY, THREAD_TIMESLICE);<br>    rt_thread_startup(&amp;thread2);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 导出到 msh 命令列表中 */</span><br>MSH_CMD_EXPORT(mailbox_sample, mailbox sample);<br></code></pre></td></tr></table></figure><p>仿真运行结果如下：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"> \ | /<br>- RT -     Thread Operating System<br> / | \     <span class="hljs-number">3.1</span>.<span class="hljs-number">0</span> build Aug <span class="hljs-number">27</span> <span class="hljs-number">2018</span><br> <span class="hljs-number">2006</span> - <span class="hljs-number">2018</span> Copyright <span class="hljs-keyword">by</span> rt-thread team<br>msh &gt;mailbox_sample<br><span class="hljs-symbol">thread1:</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">to</span> recv a mail<br><span class="hljs-symbol">thread1:</span> <span class="hljs-keyword">get</span> a mail <span class="hljs-keyword">from</span> mailbox, the content:I<span class="hljs-comment">&#x27;m a mail!</span><br>msh &gt;thread1: <span class="hljs-keyword">try</span> <span class="hljs-keyword">to</span> recv a mail<br><span class="hljs-symbol">thread1:</span> <span class="hljs-keyword">get</span> a mail <span class="hljs-keyword">from</span> mailbox, the content:this <span class="hljs-built_in">is</span> another mail!<br>…<br><span class="hljs-symbol">thread1:</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">to</span> recv a mail<br><span class="hljs-symbol">thread1:</span> <span class="hljs-keyword">get</span> a mail <span class="hljs-keyword">from</span> mailbox, the content:this <span class="hljs-built_in">is</span> another mail!<br><span class="hljs-symbol">thread1:</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">to</span> recv a mail<br><span class="hljs-symbol">thread1:</span> <span class="hljs-keyword">get</span> a mail <span class="hljs-keyword">from</span> mailbox, the content:over<br></code></pre></td></tr></table></figure><h2 id="消息队列Messagequeue"><a href="#消息队列Messagequeue" class="headerlink" title="消息队列Messagequeue"></a>消息队列Messagequeue</h2><p>消息队列是另一种常用的线程间通讯方式，是邮箱的扩展(消息队列：不固定长度的消息)。可以应用在多种场合：线程间的消息交换、使用串口接收不定长数据等。</p><p>线程或中断服务例程可以将一条或多条消息放入消息队列中。同样，一个或多个线程也可以从消息队列中获得消息。当有多个消息发送到消息队列时，通常将先进入消息队列的消息先传给线程，也就是说，线程先得到的是最先进入消息队列的消息，即先进先出原则 (FIFO)。</p><ul><li>消息框含有消息头（用于链表连接）</li></ul><p><img src="/2021/42e53028/07msg_work.png" alt="消息队列工作示意图"></p><p>消息队列和邮箱的明显不同是消息的长度并不限定在 4 个字节以内；另外，消息队列也包括了一个发送紧急消息的函数接口。但是当创建的是一个所有消息的最大长度是 4 字节的消息队列时，消息队列对象将蜕化成邮箱。</p><h3 id="消息队列API"><a href="#消息队列API" class="headerlink" title="消息队列API"></a>消息队列API</h3><p><img src="/2021/42e53028/07msg_ops.png" alt="消息队列相关接口"></p><h3 id="创建和删除消息队列-create"><a href="#创建和删除消息队列-create" class="headerlink" title="创建和删除消息队列-create"></a>创建和删除消息队列-create</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_mq_t</span> <span class="hljs-title function_">rt_mq_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">rt_size_t</span> msg_size,</span><br><span class="hljs-params">            <span class="hljs-type">rt_size_t</span> max_msgs, <span class="hljs-type">rt_uint8_t</span> flag)</span>;<br></code></pre></td></tr></table></figure><p>消息队列内存的大小 &#x3D;[消息大小+消息头（用于链表连接）的大小]X消息队列最大个数</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>name</td><td>消息队列的名称</td></tr><tr><td>msg_size</td><td>消息队列中一条消息的最大长度，单位字节</td></tr><tr><td>max_msgs</td><td>消息队列的最大个数</td></tr><tr><td>flag</td><td>消息队列采用的等待方式，它可以取如下数值： RT_IPC_FLAG_FIFO 或 RT_IPC_FLAG_PRIO</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>发送成功</td></tr><tr><td>消息队列对象的句柄</td><td>成功</td></tr><tr><td>RT_NULL</td><td>失败</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mq_delete</span><span class="hljs-params">(<span class="hljs-type">rt_mq_t</span> mq)</span>;<br></code></pre></td></tr></table></figure><p>删除消息队列时，如果有线程被挂起在该消息队列等待队列上，则内核先唤醒挂起在该消息等待队列上的所有线程（线程返回值是 - RT_ERROR），然后再释放消息队列使用的内存，最后删除消息队列对象。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mq</td><td>消息队列对象的句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr></tbody></table><h3 id="初始化和脱离消息队列-init"><a href="#初始化和脱离消息队列-init" class="headerlink" title="初始化和脱离消息队列-init"></a>初始化和脱离消息队列-init</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mq_init</span><span class="hljs-params">(<span class="hljs-type">rt_mq_t</span> mq, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name,</span><br><span class="hljs-params">                        <span class="hljs-type">void</span> *msgpool, <span class="hljs-type">rt_size_t</span> msg_size,</span><br><span class="hljs-params">                        <span class="hljs-type">rt_size_t</span> pool_size, <span class="hljs-type">rt_uint8_t</span> flag)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mq</td><td>消息队列对象的句柄</td></tr><tr><td>name</td><td>消息队列的名称</td></tr><tr><td>msgpool</td><td>指向存放消息的缓冲区的指针</td></tr><tr><td>msg_size</td><td>消息队列中一条消息的最大长度，单位字节</td></tr><tr><td>pool_size</td><td>存放消息的缓冲区大小</td></tr><tr><td>flag</td><td>消息队列采用的等待方式，它可以取如下数值： RT_IPC_FLAG_FIFO 或 RT_IPC_FLAG_PRIO</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mq_detach</span><span class="hljs-params">(<span class="hljs-type">rt_mq_t</span> mq)</span>;<br></code></pre></td></tr></table></figure><p>使用该函数接口后，内核先唤醒所有挂在该消息等待队列对象上的线程（线程返回值是 -RT_ERROR），然后将该消息队列对象从内核对象管理器中脱离。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mq</td><td>消息队列对象的句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr></tbody></table><h3 id="发送消息-send"><a href="#发送消息-send" class="headerlink" title="发送消息-send"></a>发送消息-send</h3><p><strong>线程</strong>或者<strong>中断服务程序</strong>都可以给消息队列发送消息。当发送消息时，消息队列对象先从空闲消息链表上取下一个空闲消息块，把线程或者中断服务程序发送的消息内容复制到消息块上，然后把该消息块挂到消息队列的尾部。当且仅当空闲消息链表上有可用的空闲消息块时，发送者才能成功发送消息；当空闲消息链表上无可用消息块，说明消息队列已满，此时，发送消息的的线程或者中断程序会收到一个错误码（-RT_EFULL）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mq_send</span> <span class="hljs-params">(<span class="hljs-type">rt_mq_t</span> mq, <span class="hljs-type">void</span>* buffer, <span class="hljs-type">rt_size_t</span> size)</span>;<br></code></pre></td></tr></table></figure><p>发送消息时，发送者需指定发送的消息队列的对象句柄（即指向消息队列控制块的指针），并且指定发送的消息内容以及消息大小。如下图所示，在发送一个普通消息之后，空闲消息链表上的队首消息被转移到了消息队列尾。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mq</td><td>消息队列对象的句柄</td></tr><tr><td>buffer</td><td>消息内容</td></tr><tr><td>size</td><td>消息大小</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr><tr><td>-RT_EFULL</td><td>消息队列已满</td></tr><tr><td>-RT_ERROR</td><td>失败，表示发送的消息长度大于消息队列中消息的最大长度</td></tr></tbody></table><h3 id="等待方式发送消息-wait"><a href="#等待方式发送消息-wait" class="headerlink" title="等待方式发送消息-wait"></a>等待方式发送消息-wait</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mq_send_wait</span><span class="hljs-params">(<span class="hljs-type">rt_mq_t</span>     mq,</span><br><span class="hljs-params">                         <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buffer,</span><br><span class="hljs-params">                         <span class="hljs-type">rt_size_t</span>   size,</span><br><span class="hljs-params">                         <span class="hljs-type">rt_int32_t</span>  timeout)</span>;<br></code></pre></td></tr></table></figure><p>rt_mq_send_wait() 与 rt_mq_send() 的区别在于有等待时间，如果消息队列已经满了，那么发送线程将根据设定的 timeout 参数进行等待。如果设置的超时时间到达依然没有空出空间，这时发送线程将被唤醒并返回错误码。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mq</td><td>消息队列对象的句柄</td></tr><tr><td>buffer</td><td>消息内容</td></tr><tr><td>size</td><td>消息大小</td></tr><tr><td>timeout</td><td>超时时间</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr><tr><td>-RT_EFULL</td><td>消息队列已满</td></tr><tr><td>-RT_ERROR</td><td>失败，表示发送的消息长度大于消息队列中消息的最大长度</td></tr></tbody></table><h3 id="发送紧急消息-urgent"><a href="#发送紧急消息-urgent" class="headerlink" title="发送紧急消息-urgent"></a>发送紧急消息-urgent</h3><p>发送紧急消息的过程与发送消息几乎一样，唯一的不同是，当发送紧急消息时，从空闲消息链表上取下来的消息块不是挂到消息队列的队尾，而是挂到队首，这样，接收者就能够优先接收到紧急消息，从而及时进行消息处理。发送紧急消息的函数接口如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mq_urgent</span><span class="hljs-params">(<span class="hljs-type">rt_mq_t</span> mq, <span class="hljs-type">void</span>* buffer, <span class="hljs-type">rt_size_t</span> size)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mq</td><td>消息队列对象的句柄</td></tr><tr><td>buffer</td><td>消息内容</td></tr><tr><td>size</td><td>消息大小</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr><tr><td>-RT_EFULL</td><td>消息队列已满</td></tr><tr><td>-RT_ERROR</td><td>失败</td></tr></tbody></table><h3 id="接收消息-recv"><a href="#接收消息-recv" class="headerlink" title="接收消息-recv"></a>接收消息-recv</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mq_recv</span> <span class="hljs-params">(<span class="hljs-type">rt_mq_t</span> mq, <span class="hljs-type">void</span>* buffer,</span><br><span class="hljs-params">                    <span class="hljs-type">rt_size_t</span> size, <span class="hljs-type">rt_int32_t</span> timeout)</span>;<br></code></pre></td></tr></table></figure><p>接收消息时，接收者需指定存储消息的消息队列对象句柄，并且指定一个内存缓冲区，接收到的消息内容将被复制到该缓冲区里。此外，还需指定未能及时取到消息时的超时时间。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mq</td><td>消息队列对象的句柄</td></tr><tr><td>buffer</td><td>消息内容</td></tr><tr><td>size</td><td>消息大小</td></tr><tr><td>timeout</td><td>指定的超时时间</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功收到</td></tr><tr><td>-RT_ETIMEOUT</td><td>超时</td></tr><tr><td>-RT_ERROR</td><td>失败，返回错误</td></tr></tbody></table><h2 id="消息队列应用示例"><a href="#消息队列应用示例" class="headerlink" title="消息队列应用示例"></a>消息队列应用示例</h2><p>这是一个消息队列的应用例程，例程中初始化了 2 个静态线程，一个线程会从消息队列中收取消息；另一个线程会定时给消息队列发送普通消息和紧急消息，如下代码所示：</p><p>消息队列的使用例程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;rtthread.h&gt;</span></span><br><br><span class="hljs-comment">/* 消息队列控制块 */</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_messagequeue</span> <span class="hljs-title">mq</span>;</span><br><span class="hljs-comment">/* 消息队列中用到的放置消息的内存池 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">rt_uint8_t</span> msg_pool[<span class="hljs-number">2048</span>];<br><br>ALIGN(RT_ALIGN_SIZE)<br><span class="hljs-type">static</span> <span class="hljs-type">char</span> thread1_stack[<span class="hljs-number">1024</span>];<br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_thread</span> <span class="hljs-title">thread1</span>;</span><br><span class="hljs-comment">/* 线程 1 入口函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">thread1_entry</span><span class="hljs-params">(<span class="hljs-type">void</span> *parameter)</span><br>&#123;<br>    <span class="hljs-type">char</span> buf = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">rt_uint8_t</span> cnt = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">/* 从消息队列中接收消息 */</span><br>        <span class="hljs-keyword">if</span> (rt_mq_recv(&amp;mq, &amp;buf, <span class="hljs-keyword">sizeof</span>(buf), RT_WAITING_FOREVER) == RT_EOK)<br>        &#123;<br>            rt_kprintf(<span class="hljs-string">&quot;thread1: recv msg from msg queue, the content:%c\n&quot;</span>, buf);<br>            <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">19</span>)<br>            &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">/* 延时 50ms */</span><br>        cnt++;<br>        rt_thread_mdelay(<span class="hljs-number">50</span>);<br>    &#125;<br>    rt_kprintf(<span class="hljs-string">&quot;thread1: detach mq \n&quot;</span>);<br>    rt_mq_detach(&amp;mq);<br>&#125;<br><br>ALIGN(RT_ALIGN_SIZE)<br><span class="hljs-type">static</span> <span class="hljs-type">char</span> thread2_stack[<span class="hljs-number">1024</span>];<br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_thread</span> <span class="hljs-title">thread2</span>;</span><br><span class="hljs-comment">/* 线程 2 入口 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">thread2_entry</span><span class="hljs-params">(<span class="hljs-type">void</span> *parameter)</span><br>&#123;<br>    <span class="hljs-type">int</span> result;<br>    <span class="hljs-type">char</span> buf = <span class="hljs-string">&#x27;A&#x27;</span>;<br>    <span class="hljs-type">rt_uint8_t</span> cnt = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">8</span>)<br>        &#123;<br>            <span class="hljs-comment">/* 发送紧急消息到消息队列中 */</span><br>            result = rt_mq_urgent(&amp;mq, &amp;buf, <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (result != RT_EOK)<br>            &#123;<br>                rt_kprintf(<span class="hljs-string">&quot;rt_mq_urgent ERR\n&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                rt_kprintf(<span class="hljs-string">&quot;thread2: send urgent message - %c\n&quot;</span>, buf);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cnt&gt;= <span class="hljs-number">20</span>)<span class="hljs-comment">/* 发送 20 次消息之后退出 */</span><br>        &#123;<br>            rt_kprintf(<span class="hljs-string">&quot;message queue stop send, thread2 quit\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">/* 发送消息到消息队列中 */</span><br>            result = rt_mq_send(&amp;mq, &amp;buf, <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (result != RT_EOK)<br>            &#123;<br>                rt_kprintf(<span class="hljs-string">&quot;rt_mq_send ERR\n&quot;</span>);<br>            &#125;<br><br>            rt_kprintf(<span class="hljs-string">&quot;thread2: send message - %c\n&quot;</span>, buf);<br>        &#125;<br>        buf++;<br>        cnt++;<br>        <span class="hljs-comment">/* 延时 5ms */</span><br>        rt_thread_mdelay(<span class="hljs-number">5</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* 消息队列示例的初始化 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">msgq_sample</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">rt_err_t</span> result;<br><br>    <span class="hljs-comment">/* 初始化消息队列 */</span><br>    result = rt_mq_init(&amp;mq,<br>                        <span class="hljs-string">&quot;mqt&quot;</span>,<br>                        &amp;msg_pool[<span class="hljs-number">0</span>],             <span class="hljs-comment">/* 内存池指向 msg_pool */</span><br>                        <span class="hljs-number">1</span>,                          <span class="hljs-comment">/* 每个消息的大小是 1 字节 */</span><br>                        <span class="hljs-keyword">sizeof</span>(msg_pool),        <span class="hljs-comment">/* 内存池的大小是 msg_pool 的大小 */</span><br>                        RT_IPC_FLAG_FIFO);       <span class="hljs-comment">/* 如果有多个线程等待，按照先来先得到的方法分配消息 */</span><br><br>    <span class="hljs-keyword">if</span> (result != RT_EOK)<br>    &#123;<br>        rt_kprintf(<span class="hljs-string">&quot;init message queue failed.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    rt_thread_init(&amp;thread1,<br>                   <span class="hljs-string">&quot;thread1&quot;</span>,<br>                   thread1_entry,<br>                   RT_NULL,<br>                   &amp;thread1_stack[<span class="hljs-number">0</span>],<br>                   <span class="hljs-keyword">sizeof</span>(thread1_stack), <span class="hljs-number">25</span>, <span class="hljs-number">5</span>);<br>    rt_thread_startup(&amp;thread1);<br><br>    rt_thread_init(&amp;thread2,<br>                   <span class="hljs-string">&quot;thread2&quot;</span>,<br>                   thread2_entry,<br>                   RT_NULL,<br>                   &amp;thread2_stack[<span class="hljs-number">0</span>],<br>                   <span class="hljs-keyword">sizeof</span>(thread2_stack), <span class="hljs-number">25</span>, <span class="hljs-number">5</span>);<br>    rt_thread_startup(&amp;thread2);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 导出到 msh 命令列表中 */</span><br>MSH_CMD_EXPORT(msgq_sample, msgq sample);<br></code></pre></td></tr></table></figure><p>仿真运行结果如下：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">\ | /<br>- RT -     Thread Operating System<br> / | \     <span class="hljs-number">3.1</span>.<span class="hljs-number">0</span> build Aug <span class="hljs-number">24</span> <span class="hljs-number">2018</span><br> <span class="hljs-number">2006</span> - <span class="hljs-number">2018</span> Copyright <span class="hljs-keyword">by</span> rt-thread team<br>msh &gt; msgq_sample<br>msh &gt;thread2: send message - A<br><span class="hljs-symbol">thread1:</span> recv msg <span class="hljs-keyword">from</span> msg queue, the content:A<br><span class="hljs-symbol">thread2:</span> send message - B<br><span class="hljs-symbol">thread2:</span> send message - C<br><span class="hljs-symbol">thread2:</span> send message - D<br><span class="hljs-symbol">thread2:</span> send message - E<br><span class="hljs-symbol">thread1:</span> recv msg <span class="hljs-keyword">from</span> msg queue, the content:B<br><span class="hljs-symbol">thread2:</span> send message - F<br><span class="hljs-symbol">thread2:</span> send message - G<br><span class="hljs-symbol">thread2:</span> send message - H<br><span class="hljs-symbol">thread2:</span> send urgent message - I<br><span class="hljs-symbol">thread2:</span> send message - J<br><span class="hljs-symbol">thread1:</span> recv msg <span class="hljs-keyword">from</span> msg queue, the content:I<br><span class="hljs-symbol">thread2:</span> send message - K<br><span class="hljs-symbol">thread2:</span> send message - L<br><span class="hljs-symbol">thread2:</span> send message - M<br><span class="hljs-symbol">thread2:</span> send message - N<br><span class="hljs-symbol">thread2:</span> send message - O<br><span class="hljs-symbol">thread1:</span> recv msg <span class="hljs-keyword">from</span> msg queue, the content:C<br><span class="hljs-symbol">thread2:</span> send message - P<br><span class="hljs-symbol">thread2:</span> send message - Q<br><span class="hljs-symbol">thread2:</span> send message - R<br><span class="hljs-symbol">thread2:</span> send message - S<br><span class="hljs-symbol">thread2:</span> send message - T<br><span class="hljs-symbol">thread1:</span> recv msg <span class="hljs-keyword">from</span> msg queue, the content:D<br>message queue <span class="hljs-keyword">stop</span> send, thread2 quit<br><span class="hljs-symbol">thread1:</span> recv msg <span class="hljs-keyword">from</span> msg queue, the content:E<br><span class="hljs-symbol">thread1:</span> recv msg <span class="hljs-keyword">from</span> msg queue, the content:F<br><span class="hljs-symbol">thread1:</span> recv msg <span class="hljs-keyword">from</span> msg queue, the content:G<br>…<br><span class="hljs-symbol">thread1:</span> recv msg <span class="hljs-keyword">from</span> msg queue, the content:T<br><span class="hljs-symbol">thread1:</span> detach mq<br></code></pre></td></tr></table></figure><h2 id="信号Sigset"><a href="#信号Sigset" class="headerlink" title="信号Sigset"></a>信号Sigset</h2><p>信号（又称为软中断信号），在软件层次上是对中断机制的一种模拟，在原理上，一个线程收到一个信号与处理器收到一个中断请求可以说是类似的。</p><p>应用程序(用户)能够使用的信号为 SIGUSR1（10）和 SIGUSR2（12）。</p><p>信号本质是<strong>软中断</strong>，用来通知线程发生了异步事件，用做线程之间的异常通知、应急处理。一个线程不必通过任何操作来等待信号的到达，事实上，线程也不知道信号到底什么时候到达，线程之间可以互相通过调用 rt_thread_kill() 发送软中断信号。</p><p>收到信号的线程对各种信号有不同的处理方法，在信号安装时设定 handler 参数，处理方法可以分为三类：</p><ul><li><p>第一种是类似中断的处理程序，对于需要处理的信号，线程可以指定处理函数，由该函数来处理。</p></li><li><p>第二种方法是，参数设为 SIG_IGN，忽略某个信号，对该信号不做任何处理，就像未发生过一样。 </p></li><li><p>第三种方法是，参数设为 SIG_DFL，系统会调用默认的处理函数_signal_default_handler()。</p></li></ul><p>如下图所示，假设线程 1 需要对信号进行处理，首先线程 1 安装一个信号并解除阻塞，并在安装的同时设定了对信号的异常处理方式；然后其他线程可以给线程 1 发送信号，触发线程 1 对该信号的处理。</p><p>当信号被传递给线程 1 时，如果它正处于挂起状态，那会把状态改为就绪状态去处理对应的信号。如果它正处于运行状态，那么会在它当前的线程栈基础上建立新栈帧空间去处理对应的信号，需要注意的是使用的线程栈大小也会相应增加。</p><p><img src="/2021/42e53028/07signal_work.png" alt="信号工作机制"></p><h3 id="信号API"><a href="#信号API" class="headerlink" title="信号API"></a>信号API</h3><p><img src="/2021/42e53028/07signal_ops.png" alt="信号相关接口"></p><h3 id="安装信号-install"><a href="#安装信号-install" class="headerlink" title="安装信号-install"></a>安装信号-install</h3><p>如果线程要处理某一信号，那么就要在线程中安装该信号。安装信号主要用来确定信号值及线程针对该信号值的动作之间的映射关系，即线程将要处理哪个信号，该信号被传递给线程时，将执行何种操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_sighandler_t</span> <span class="hljs-title function_">rt_signal_install</span><span class="hljs-params">(<span class="hljs-type">int</span> signo, <span class="hljs-type">rt_sighandler_t</span>[] handler)</span>;<br></code></pre></td></tr></table></figure><p>其中 rt_sighandler_t 是定义信号处理函数的函数指针类型。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>signo</td><td>信号值（只有 SIGUSR1 和 SIGUSR2 是开放给用户使用的，下同）</td></tr><tr><td>handler</td><td>设置对信号值的处理方式 （函数指针）</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>SIG_ERR</td><td>错误的信号</td></tr><tr><td>安装信号前的 handler 值</td><td>成功</td></tr></tbody></table><h3 id="屏蔽信号-mask"><a href="#屏蔽信号-mask" class="headerlink" title="屏蔽信号-mask"></a>屏蔽信号-mask</h3><p>信号阻塞，也可以理解为屏蔽信号。如果该信号被阻塞，则该信号将不会递达给安装此信号的线程，也不会引发软中断处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">rt_signal_mask</span><span class="hljs-params">(<span class="hljs-type">int</span> signo)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>signo</td><td>信号值</td></tr></tbody></table><h3 id="解除信号屏蔽-unmask"><a href="#解除信号屏蔽-unmask" class="headerlink" title="解除信号屏蔽-unmask"></a>解除信号屏蔽-unmask</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">rt_signal_unmask</span><span class="hljs-params">(<span class="hljs-type">int</span> signo)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>signo</td><td>信号值</td></tr></tbody></table><h3 id="发送信号-kill"><a href="#发送信号-kill" class="headerlink" title="发送信号-kill"></a>发送信号-kill</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">rt_thread_kill</span><span class="hljs-params">(<span class="hljs-type">rt_thread_t</span> tid, <span class="hljs-type">int</span> sig)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>tid</td><td>接收信号的线程</td></tr><tr><td>sig</td><td>信号值</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>发送成功</td></tr><tr><td>-RT_EINVAL</td><td>参数错误</td></tr></tbody></table><h3 id="等待信号-wait"><a href="#等待信号-wait" class="headerlink" title="等待信号-wait"></a>等待信号-wait</h3><p>等待 set 信号的到来，如果没有等到这个信号，则将线程挂起，直到等到这个信号或者等待时间超过指定的超时时间 timeout。如果等到了该信号，则将指向该信号体的指针存入 si，如下是等待信号的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">rt_signal_wait</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">rt_sigset_t</span> *<span class="hljs-built_in">set</span>,</span><br><span class="hljs-params">                        <span class="hljs-type">rt_siginfo_t</span>[] *si, <span class="hljs-type">rt_int32_t</span> timeout)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>set</td><td>指定等待的信号</td></tr><tr><td>si</td><td>指向存储等到信号信息的指针</td></tr><tr><td>timeout</td><td>指定的等待时间</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>等到信号</td></tr><tr><td>-RT_ETIMEOUT</td><td>超时</td></tr><tr><td>-RT_EINVAL</td><td>参数错误</td></tr></tbody></table><h2 id="信号应用示例"><a href="#信号应用示例" class="headerlink" title="信号应用示例"></a>信号应用示例</h2><p>这是一个信号的应用例程，如下代码所示。此例程创建了 1 个线程，在安装信号时，信号处理方式设为自定义处理，定义的信号的处理函数为 thread1_signal_handler()。待此线程运行起来安装好信号之后，给此线程发送信号。此线程将接收到信号，并打印信息。</p><p>信号使用例程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;rtthread.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_PRIORITY         25</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_STACK_SIZE       512</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_TIMESLICE        5</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">rt_thread_t</span> tid1 = RT_NULL;<br><br><span class="hljs-comment">/* 线程 1 的信号处理函数 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">thread1_signal_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span><br>&#123;<br>    rt_kprintf(<span class="hljs-string">&quot;thread1 received signal %d\n&quot;</span>, sig);<br>&#125;<br><br><span class="hljs-comment">/* 线程 1 的入口函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">thread1_entry</span><span class="hljs-params">(<span class="hljs-type">void</span> *parameter)</span><br>&#123;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* 安装信号 */</span><br>    rt_signal_install(SIGUSR1, thread1_signal_handler);<br>    rt_signal_unmask(SIGUSR1);<br><br>    <span class="hljs-comment">/* 运行 10 次 */</span><br>    <span class="hljs-keyword">while</span> (cnt &lt; <span class="hljs-number">10</span>)<br>    &#123;<br>        <span class="hljs-comment">/* 线程 1 采用低优先级运行，一直打印计数值 */</span><br>        rt_kprintf(<span class="hljs-string">&quot;thread1 count : %d\n&quot;</span>, cnt);<br><br>        cnt++;<br>        rt_thread_mdelay(<span class="hljs-number">100</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* 信号示例的初始化 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">signal_sample</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/* 创建线程 1 */</span><br>    tid1 = rt_thread_create(<span class="hljs-string">&quot;thread1&quot;</span>,<br>                            thread1_entry, RT_NULL,<br>                            THREAD_STACK_SIZE,<br>                            THREAD_PRIORITY, THREAD_TIMESLICE);<br><br>    <span class="hljs-keyword">if</span> (tid1 != RT_NULL)<br>        rt_thread_startup(tid1);<br><br>    rt_thread_mdelay(<span class="hljs-number">300</span>);<br><br>    <span class="hljs-comment">/* 发送信号 SIGUSR1 给线程 1 */</span><br>    rt_thread_kill(tid1, SIGUSR1);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 导出到 msh 命令列表中 */</span><br>MSH_CMD_EXPORT(signal_sample, signal sample);<br></code></pre></td></tr></table></figure><p>仿真运行结果如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"> <span class="hljs-string">\</span> <span class="hljs-string">|</span> <span class="hljs-string">/</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">RT</span> <span class="hljs-bullet">-</span>     <span class="hljs-string">Thread</span> <span class="hljs-string">Operating</span> <span class="hljs-string">System</span><br> <span class="hljs-string">/</span> <span class="hljs-string">|</span> <span class="hljs-string">\</span>     <span class="hljs-number">3.1</span><span class="hljs-number">.0</span> <span class="hljs-string">build</span> <span class="hljs-string">Aug</span> <span class="hljs-number">24</span> <span class="hljs-number">2018</span><br> <span class="hljs-number">2006</span> <span class="hljs-bullet">-</span> <span class="hljs-number">2018 </span><span class="hljs-string">Copyright</span> <span class="hljs-string">by</span> <span class="hljs-string">rt-thread</span> <span class="hljs-string">team</span><br><span class="hljs-string">msh</span> <span class="hljs-string">&gt;signal_sample</span><br><span class="hljs-attr">thread1 count :</span> <span class="hljs-number">0</span><br><span class="hljs-attr">thread1 count :</span> <span class="hljs-number">1</span><br><span class="hljs-attr">thread1 count :</span> <span class="hljs-number">2</span><br><span class="hljs-string">msh</span> <span class="hljs-string">&gt;thread1</span> <span class="hljs-string">received</span> <span class="hljs-string">signal</span> <span class="hljs-number">10</span><br><span class="hljs-attr">thread1 count :</span> <span class="hljs-number">3</span><br><span class="hljs-attr">thread1 count :</span> <span class="hljs-number">4</span><br><span class="hljs-attr">thread1 count :</span> <span class="hljs-number">5</span><br><span class="hljs-attr">thread1 count :</span> <span class="hljs-number">6</span><br><span class="hljs-attr">thread1 count :</span> <span class="hljs-number">7</span><br><span class="hljs-attr">thread1 count :</span> <span class="hljs-number">8</span><br><span class="hljs-attr">thread1 count :</span> <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><h2 id="笔记-3"><a href="#笔记-3" class="headerlink" title="笔记"></a>笔记</h2><p>Mailbox:开销较小，4字节内容，</p><p>Message Queue:长度不固定、需要进行内存分配、</p><p>Signal:软件中断</p><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>RT-Thread 操作系统在内存管理上，根据上层应用及系统资源的不同，有针对性地提供了不同的内存分配管理算法。总体上可分为两类：内存堆管理与内存池管理，而内存堆管理又根据具体内存设备划分为三种情况：</p><ul><li><p>第一种是针对小内存块的分配管理（小内存管理算法）；</p></li><li><p>第二种是针对大内存块的分配管理（slab 管理算法）；</p></li><li><p>第三种是针对多内存堆的分配情况（memheap 管理算法）</p></li></ul><h2 id="内存堆Heap"><a href="#内存堆Heap" class="headerlink" title="内存堆Heap"></a>内存堆Heap</h2><p>RT-Thread 将 “ZI 段结尾处” 到内存尾部的空间用作内存堆。</p><p><img src="/2021/42e53028/08Memory_distribution.png" alt="RT-Thread 内存分布"></p><p>内存堆可以在当前资源满足的情况下，根据用户的需求分配任意大小的内存块。而当用户不需要再使用这些内存块时，又可以释放回堆中供其他应用分配使用。RT-Thread 系统为了满足不同的需求，提供了不同的内存管理算法，分别是<strong>小内存管理算法</strong>、<strong>Slab</strong> 管理算法和 <strong>memheap 管理算法</strong>。</p><p><strong>小内存管理算法</strong>主要针对系统资源比较少，一般用于小于 2MB 内存空间的系统；</p><p><strong>slab 内存管理算法</strong>则主要是在系统资源比较丰富时，提供了一种近似多内存池管理算法的快速算法。</p><p> <strong>memheap 管理算法</strong>。memheap 方法适用于系统存在多个内存堆的情况，它可以将多个内存 “粘贴” 在一起，形成一个大的内存堆，用户使用起来会非常方便。</p><h3 id="小内存管理算法"><a href="#小内存管理算法" class="headerlink" title="小内存管理算法"></a>小内存管理算法</h3><p><img src="/2021/42e53028/08smem_work.png" alt="小内存管理工作机制图"></p><p>每个内存块（不管是已分配的内存块还是空闲的内存块）都包含一个数据头，其中包括：</p><p><strong>1）magic</strong>：变数（或称为幻数），它会被初始化成 0x1ea0（即英文单词 heap），用于标记这个内存块是一个内存管理用的内存数据块；变数不仅仅用于标识这个数据块是一个内存管理用的内存数据块，实质也是一个内存保护字：如果这个区域被改写，那么也就意味着这块内存块被非法改写（正常情况下只有内存管理器才会去碰这块内存）。</p><p><strong>2）used</strong>：指示出当前内存块是否已经分配。</p><p><strong>内存管理的表现主要体现在内存的分配与释放上，小型内存管理算法可以用以下例子体现出来。</strong></p><p><strong>如下图所示的内存分配情况，空闲链表指针 lfree 初始指向 32 字节的内存块。当用户线程要再分配一个 64 字节的内存块时，但此 lfree 指针指向的内存块只有 32 字节并不能满足要求，内存管理器会继续寻找下一内存块，当找到再下一块内存块，128 字节时，它满足分配的要求。因为这个内存块比较大，分配器将把此内存块进行拆分，余下的内存块（52 字节）继续留在 lfree 链表中，如下图分配 64 字节后的链表结构所示。</strong></p><p><img src="/2021/42e53028/08smem_work3.png" alt="小内存管理算法链表结构示意图 2"></p><p>另外，在每次分配内存块前，都会留出 12 字节数据头用于 magic、used 信息及链表节点使用。返回给应用的地址实际上是这块内存块 12 字节以后的地址，前面的 12 字节数据头是用户永远不应该碰的部分（注：12 字节数据头长度会与系统对齐差异而有所不同）。</p><p>释放时则是相反的过程，但分配器会查看前后相邻的内存块是否空闲，如果空闲则合并成一个大的空闲内存块。</p><h3 id="Slab管理算法"><a href="#Slab管理算法" class="headerlink" title="Slab管理算法"></a>Slab管理算法</h3><p>slab 分配器会根据对象的大小分成多个区（zone），也可以看成每类对象有一个内存池，如下图所示：</p><p><img src="/2021/42e53028/08slab.png" alt="slab 内存分配结构图"></p><p>一个 zone 的大小在 32K 到 128K 字节之间，分配器会在堆初始化时根据堆的大小自动调整。系统中的 zone 最多包括 72 种对象，一次最大能够分配 16K 的内存空间，如果超出了 16K 那么直接从页分配器中分配。每个 zone 上分配的内存块大小是固定的，能够分配相同大小内存块的 zone 会链接在一个链表中，而 72 种对象的 zone 链表则放在一个数组（zone_array[]）中统一管理。</p><p><strong>（1）内存分配</strong></p><p>假设分配一个 32 字节的内存，slab 内存分配器会先按照 32 字节的值，从 zone array 链表表头数组中找到相应的 zone 链表。如果这个链表是空的，则向页分配器分配一个新的 zone，然后从 zone 中返回第一个空闲内存块。如果链表非空，则这个 zone 链表中的第一个 zone 节点必然有空闲块存在（否则它就不应该放在这个链表中），那么就取相应的空闲块。如果分配完成后，zone 中所有空闲内存块都使用完毕，那么分配器需要把这个 zone 节点从链表中删除。</p><p><strong>（2）内存释放</strong></p><p>分配器需要找到内存块所在的 zone 节点，然后把内存块链接到 zone 的空闲内存块链表中。如果此时 zone 的空闲链表指示出 zone 的所有内存块都已经释放，即 zone 是完全空闲的，那么当 zone 链表中全空闲 zone 达到一定数目后，系统就会把这个全空闲的 zone 释放到页面分配器中去。</p><h3 id="Memheap管理算法"><a href="#Memheap管理算法" class="headerlink" title="Memheap管理算法"></a>Memheap管理算法</h3><p> memheap 功能就可以很方便地把多个 memheap（地址可不连续）粘合起来用于系统的 heap 分配。</p><p>memheap 工作机制如下图所示，首先将多块内存加入 memheap_item 链表进行粘合。当分配内存块时，会先从默认内存堆去分配内存，当分配不到时会查找 memheap_item 链表，尝试从其他的内存堆上分配内存块。应用程序不用关心当前分配的内存块位于哪个内存堆上，就像是在操作一个内存堆。</p><p><img src="/2021/42e53028/08memheap.png" alt="memheap 处理多内存堆"></p><h2 id="内存池Pool"><a href="#内存池Pool" class="headerlink" title="内存池Pool"></a>内存池Pool</h2><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>创建&#x2F;初始化</td><td>rt_mp_create()&#x2F;rt_mp_init()</td></tr><tr><td>分配内存块</td><td>rt_mp_alloc()</td></tr><tr><td>释放内存块</td><td>rt_mp_free()</td></tr><tr><td>删除&#x2F;脱离</td><td>rt_mp_delete()&#x2F;rt_mp_detach()</td></tr></tbody></table><h3 id="创建-x2F-删除-create"><a href="#创建-x2F-删除-create" class="headerlink" title="创建&#x2F;删除-create"></a>创建&#x2F;删除-create</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_mp_t</span> <span class="hljs-title function_">rt_mp_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name,</span><br><span class="hljs-params">                         <span class="hljs-type">rt_size_t</span> block_count,</span><br><span class="hljs-params">                         <span class="hljs-type">rt_size_t</span> block_size)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>name</td><td>内存池名</td></tr><tr><td>block_count</td><td>内存块数量</td></tr><tr><td>block_size</td><td>内存块容量</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>内存池的句柄</td><td>创建内存池对象成功</td></tr><tr><td>RT_NULL</td><td>创建失败</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mp_delete</span><span class="hljs-params">(<span class="hljs-type">rt_mp_t</span> mp)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mp</td><td>rt_mp_create 返回的内存池对象句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>删除成功</td></tr></tbody></table><h3 id="初始化-x2F-剥离-init"><a href="#初始化-x2F-剥离-init" class="headerlink" title="初始化&#x2F;剥离-init"></a>初始化&#x2F;剥离-init</h3><p>内存池块个数 &#x3D; size &#x2F; (block_size + 4 链表指针大小)，计算结果取整数。</p><p>例如：内存池数据区总大小 size 设为 4096 字节，内存块大小 block_size 设为 80 字节；则申请的内存块个数为 4096&#x2F; (80+4)&#x3D; 48 个。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mp_init</span><span class="hljs-params">(<span class="hljs-type">rt_mp_t</span> mp,</span><br><span class="hljs-params">                        <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name,</span><br><span class="hljs-params">                        <span class="hljs-type">void</span> *start, <span class="hljs-type">rt_size_t</span> size,</span><br><span class="hljs-params">                        <span class="hljs-type">rt_size_t</span> block size)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mp</td><td>内存池对象</td></tr><tr><td>name</td><td>内存池名</td></tr><tr><td>start</td><td>内存池的起始位置</td></tr><tr><td>size</td><td>内存池数据区域大小</td></tr><tr><td>block_size</td><td>内存块容量</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>初始化成功</td></tr><tr><td>- RT_ERROR</td><td>失败</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_mp_detach</span><span class="hljs-params">(<span class="hljs-type">rt_mp_t</span> mp)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mp</td><td>内存池对象</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr></tbody></table><h3 id="分配-alloc"><a href="#分配-alloc" class="headerlink" title="分配-alloc"></a>分配-alloc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">rt_mp_alloc</span> <span class="hljs-params">(<span class="hljs-type">rt_mp_t</span> mp, <span class="hljs-type">rt_int32_t</span> time)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mp</td><td>内存池对象</td></tr><tr><td>time</td><td>超时时间</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>分配的内存块地址</td><td>成功</td></tr><tr><td>RT_NULL</td><td>失败</td></tr></tbody></table><h3 id="释放-free"><a href="#释放-free" class="headerlink" title="释放-free"></a>释放-free</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">rt_mp_free</span> <span class="hljs-params">(<span class="hljs-type">void</span> *block)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>block</td><td>内存块指针</td></tr></tbody></table><h2 id="笔记-4"><a href="#笔记-4" class="headerlink" title="笔记"></a>笔记</h2><ul><li>因为内存堆管理器要满足多线程情况下的安全分配，会考虑多线程间的互斥问题，所以请不要在中断服务例程中分配或释放动态内存块。因为它可能会引起当前上下文被挂起等待。</li></ul><h1 id="RT-Thread的中断管理"><a href="#RT-Thread的中断管理" class="headerlink" title="RT-Thread的中断管理"></a>RT-Thread的中断管理</h1><h2 id="中断工作机制"><a href="#中断工作机制" class="headerlink" title="中断工作机制"></a>中断工作机制</h2><h3 id="中断处理过程"><a href="#中断处理过程" class="headerlink" title="中断处理过程"></a>中断处理过程</h3><p>RT-Thread 中断管理中，将中断处理程序分为中断前导程序、用户中断服务程序、中断后续程序三部分<br><img src="/2021/42e53028/09interrupt_work_process.png" alt="中断处理程序的 3 部分"></p><h4 id="中断前导"><a href="#中断前导" class="headerlink" title="中断前导"></a>中断前导</h4><ol><li><p>保存 CPU 中断现场，这部分跟 CPU 架构相关，不同 CPU 架构的实现方式有差异。</p><p>对于 Cortex-M 来说，该工作由硬件自动完成。当一个中断触发并且系统进行响应时，处理器硬件会将当前运行部分的上下文寄存器自动压入中断栈中，这部分的寄存器包括 PSR、PC、LR、R12、R3-R0 寄存器。</p></li><li><p>通知内核进入中断状态，调用 rt_interrupt_enter() 函数，作用是把全局变量 rt_interrupt_nest 加 1，用它来记录中断嵌套的层数，代码如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">rt_interrupt_enter</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">rt_base_t</span> level;<br><br>    level = rt_hw_interrupt_disable();<br>    rt_interrupt_nest ++;<br>    rt_hw_interrupt_enable(level);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h4><ol><li><p>中断完后<strong>不进行</strong>线程切换，这种情况下用户中断服务程序和中断后续程序运行完毕后退出中断模式，返回被中断的线程。</p></li><li><p>中断完后<strong>进行</strong>线程切换，这种情况会调用 rt_hw_context_switch_interrupt() 函数进行上下文切换，该函数跟 CPU 架构相关，不同 CPU 架构的实现方式有差异。</p><p>rt_hw_context_switch_interrupt() 函数会触发PendSV异常，PendSV 异常被触发后，不会立即进行 PendSV 异常中断处理程序，因为此时还在中断处理中，只有当中断后续程序运行完毕，真正退出中断处理后，才进入 PendSV 异常中断处理程序。</p></li></ol><h4 id="中断后续"><a href="#中断后续" class="headerlink" title="中断后续"></a>中断后续</h4><ol><li><p>通知内核离开中断状态，通过调用 rt_interrupt_leave() 函数，将全局变量 rt_interrupt_nest 减 1，代码如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">rt_interrupt_leave</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">rt_base_t</span> level;<br><br>    level = rt_hw_interrupt_disable();<br>    rt_interrupt_nest --;<br>    rt_hw_interrupt_enable(level);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>恢复中断前的 CPU 上下文，中断过程<strong>发生了线程切换</strong>和<strong>没发生线程切换</strong>的CPU上下文是不一样的。</p></li></ol><h3 id="中断嵌套"><a href="#中断嵌套" class="headerlink" title="中断嵌套"></a>中断嵌套</h3><p>如果需要进行线程调度，线程的上下文切换将在所有中断处理程序都运行结束时才发生，如下图所示。</p><p><img src="/2021/42e53028/09ths_switch.png" alt="中断中的线程切换"></p><h3 id="中断栈"><a href="#中断栈" class="headerlink" title="中断栈"></a>中断栈</h3><ol><li>中断栈可以保存在打断线程的栈中，当从中断中退出时，返回相应的线程继续执行。</li><li>中断栈也可以与线程栈完全分离开来，即每次进入中断时，在保存完打断线程上下文后，切换到新的中断栈中独立运行。在中断退出时，再做相应的上下文恢复。</li></ol><p>使用独立中断栈相对来说更容易实现，并且对于线程栈使用情况也比较容易了解和掌握（否则必须要为中断栈预留空间，如果系统支持中断嵌套，还需要考虑应该为嵌套中断预留多大的空间）。</p><h3 id="中断的底半处理"><a href="#中断的底半处理" class="headerlink" title="中断的底半处理"></a>中断的底半处理</h3><p>发生中断后，中断一般读取硬件状态或者数据，然后发送一个通知（信号量、事件、邮箱、消息队列等），接下来的相关线程收到通知对着数据进行进一步处理，这个处理的过程就叫<strong>底半处理</strong>。</p><blockquote><p>当一个中断发生时，中断服务程序需要取得相应的硬件状态或者数据。如果中断服务程序接下来要对状态或者数据进行简单处理，比如 CPU 时钟中断，中断服务程序只需对一个系统时钟变量进行加一操作，然后就结束中断服务程序。这类中断需要的运行时间往往都比较短。但对于另外一些中断，中断服务程序在取得硬件状态或数据以后，还需要进行一系列更耗时的处理过程，通常需要将该中断分割为两部分，即<strong>上半部分</strong>（Top Half）和<strong>底半部分</strong>（Bottom Half）。在上半部分中，取得硬件状态和数据后，打开被屏蔽的中断，给相关线程发送一条通知（可以是 RT-Thread 所提供的信号量、事件、邮箱或消息队列等方式），然后结束中断服务程序；而接下来，相关的线程在接收到通知后，接着对状态或数据进行进一步的处理，这一过程称之为<strong>底半处理</strong>。</p></blockquote><h2 id="中断管理API"><a href="#中断管理API" class="headerlink" title="中断管理API"></a>中断管理API</h2><p><img src="/2021/42e53028/09interrupt_ops.png" alt="中断相关接口"></p><p><strong>请注意！！！装载中断服务例程、中断源管理——的API 并不会出现在每一个移植分支中，例如通常 Cortex-M0&#x2F;M3&#x2F;M4 的移植分支中就没有这些 API。</strong></p><h3 id="装载中断服务例程"><a href="#装载中断服务例程" class="headerlink" title="装载中断服务例程"></a>装载中断服务例程</h3><p>系统把用户的中断服务程序 (handler) 和指定的中断号关联起来，可调用如下的接口挂载一个新的中断服务程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_isr_handler_t</span> <span class="hljs-title function_">rt_hw_interrupt_install</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-built_in">vector</span>,</span><br><span class="hljs-params">                                        <span class="hljs-type">rt_isr_handler_t</span>  handler,</span><br><span class="hljs-params">                                        <span class="hljs-type">void</span> *param,</span><br><span class="hljs-params">                                        <span class="hljs-type">char</span> *name)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>vector</td><td>vector 是挂载的中断号</td></tr><tr><td>handler</td><td>新挂载的中断服务程序</td></tr><tr><td>param</td><td>param 会作为参数传递给中断服务程序</td></tr><tr><td>name</td><td>中断的名称</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>return</td><td>挂载这个中断服务程序之前挂载的中断服务程序的句柄</td></tr></tbody></table><h3 id="中断源管理"><a href="#中断源管理" class="headerlink" title="中断源管理"></a>中断源管理</h3><ol><li>屏蔽中断源</li></ol><p>通常在 ISR 准备处理某个中断信号之前，我们需要先屏蔽该中断源，在 ISR 处理完状态或数据以后，及时的打开之前被屏蔽的中断源。</p><p>屏蔽中断源可以保证在接下来的处理过程中硬件状态或者数据不会受到干扰，可调用下面这个函数接口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">rt_hw_interrupt_mask</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-built_in">vector</span>)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>vector</td><td>要屏蔽的中断号</td></tr></tbody></table><ol start="2"><li>打开被屏蔽的中断源</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">rt_hw_interrupt_umask</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-built_in">vector</span>)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>vector</td><td>要打开屏蔽的中断号</td></tr></tbody></table><h3 id="全局中断开关"><a href="#全局中断开关" class="headerlink" title="全局中断开关"></a>全局中断开关</h3><p><strong>全局中断开关也称为</strong>中断锁，是禁止多线程访问临界区最简单的一种方式，即通过关闭中断的方式，来保证当前线程不会被其他事件打断（因为整个系统已经不再响应那些可以触发线程重新调度的外部事件），也就是当前线程不会被抢占，除非这个线程主动放弃了处理器控制权。</p><ol><li>失能全局中断</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_base_t</span> <span class="hljs-title function_">rt_hw_interrupt_disable</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>返回</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>中断状态</td><td>rt_hw_interrupt_disable 函数运行前的中断状态</td></tr><tr><td>2. 使能全局中断</td><td></td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">rt_hw_interrupt_enable</span><span class="hljs-params">(<span class="hljs-type">rt_base_t</span> level)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>level</td><td>前一次 rt_hw_interrupt_disable 返回的中断状态</td></tr></tbody></table><h3 id="中断通知"><a href="#中断通知" class="headerlink" title="中断通知"></a>中断通知</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">rt_interrupt_enter</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">rt_interrupt_leave</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><p>这两个接口分别用在中断前导程序和中断后续程序中，均会对 rt_interrupt_nest（中断嵌套深度）的值进行修改。</p><p>使用 rt_interrupt_enter&#x2F;leave() 的作用是，在中断中释放了一个信号量，唤醒了某线程，但通过判断发现当前系统处于中断上下文环境中，那么在进行线程切换时应该采取中断中线程切换的策略（等中断结束再切换），而不是立即进行切换（正常情况下立即进行切换）。</p><p><del>（不建议）但如果中断服务程序不会调用内核相关的函数（释放信号量等操作），这个时候，也可以不调用 rt_interrupt_enter&#x2F;leave() 函数。</del></p><p>在上层应用中，在内核需要知道当前已经进入到中断状态或当前<strong>嵌套的中断深度</strong>时，可调用 rt_interrupt_get_nest() 接口，它会返回 rt_interrupt_nest。如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_uint8_t</span> <span class="hljs-title function_">rt_interrupt_get_nest</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>返回</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>0</td><td>当前系统不处于中断上下文环境中</td></tr><tr><td>1</td><td>当前系统处于中断上下文环境中</td></tr><tr><td>大于 1</td><td>当前中断嵌套层次</td></tr></tbody></table><h2 id="中断与轮询"><a href="#中断与轮询" class="headerlink" title="中断与轮询"></a>中断与轮询</h2><p>当驱动外设工作时，其编程模式到底采用中断模式触发还是轮询模式触发往往是驱动开发人员首先要考虑的问题，并且这个问题在实时操作系统与分时操作系统中差异还非常大。</p><p>在实时系统中轮询模式可能会出现非常大问题，因为在实时操作系统中，当一个程序持续地执行时（轮询时），它所在的线程会一直运行，比它优先级低的线程都不会得到运行。而分时系统中，这点恰恰相反，几乎没有优先级之分，可以在一个时间片运行这个程序，然后在另外一段时间片上运行另外一段程序。</p><p>所以通常情况下，实时系统中更多采用的是中断模式来驱动外设。当数据达到时，由中断唤醒相关的处理线程，再继续进行后续的动作。例如一些携带 FIFO（包含一定数据量的先进先出队列）的串口外设，其写入过程可以是这样的，如下图所示：</p><p><img src="/2021/42e53028/09interrupt_reque.png" alt="中断模式驱动外设"></p><p><strong>对于低速设备来说，运用这种模式非常好，而对于高速设备，数据量又小的情况下，线程的切换时间（几个us）会很明显的影响数据吞吐量和带宽利用率。</strong></p><blockquote><p>发送数据量越小，发送速度越快，对于数据吞吐量的影响也将越大。归根结底，取决于系统中产生中断的频度如何。当一个实时系统想要提升数据吞吐量时，可以考虑的几种方式：</p><p>1）增加每次数据量发送的长度，每次尽量让外设尽量多地发送数据；</p><p>2）必要情况下更改中断模式为轮询模式。同时为了解决轮询方式一直抢占处理机，其他低优先级线程得不到运行的情况，可以把轮询线程的优先级适当降低。</p></blockquote><h1 id="内核移植"><a href="#内核移植" class="headerlink" title="内核移植"></a>内核移植</h1><p>参考官方文档</p><h2 id="CPU架构移植"><a href="#CPU架构移植" class="headerlink" title="CPU架构移植"></a>CPU架构移植</h2><h2 id="BSP移植"><a href="#BSP移植" class="headerlink" title="BSP移植"></a>BSP移植</h2>]]></content>
    
    
    <categories>
      
      <category>RTOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rtos</tag>
      
      <tag>rt-thread</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LinuxAlphaMini</title>
    <link href="/2021/9b4105ad/"/>
    <url>/2021/9b4105ad/</url>
    
    <content type="html"><![CDATA[<h1 id="汇编基础"><a href="#汇编基础" class="headerlink" title="汇编基础"></a>汇编基础</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">label</span>： instruction @ comment <br></code></pre></td></tr></table></figure><p><strong>label 即标号</strong>，表示地址位置，有些指令前面可能会有标号，这样就可以通过这个标号得到指令的地址，标号也可以用来表示数据地址。注意 label 后面的“：”，任何以“：”结尾的标识符都会被识别为一个标号。<br><strong>instruction 即指令</strong>，也就是汇编指令或伪指令。<br><strong>@符号</strong>，表示后面的是注释<br><strong>comment</strong> 就是注释内容。</p><p>例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">add:<br>MOVS R0, #0X12 @设置 R0=0X12<br></code></pre></td></tr></table></figure><p><strong>注意！ ARM 中的指令、伪指令、伪操作、寄存器名等可以全部使用大写，也可以全部使用小写，但是不能大小写混用。</strong>  </p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">.section</span> <span class="hljs-string">.testsection</span> @定义一个 testsetcion 段 <br></code></pre></td></tr></table></figure><ul><li>.text 表示代码段。  </li><li>.data 初始化的数据段。</li><li>.bss 未初始化的数据段。</li><li>.rodata 只读数据段。</li></ul><p><strong>伪操作:</strong></p><ul><li>.byte 定义单字节数据，比如.byte 0x12。</li><li>.short 定义双字节数据，比如.short 0x1234。</li><li>.long 定义一个 4 字节数据，比如.long 0x12345678。</li><li>.equ 赋值语句，格式为： .equ 变量名，表达式，比如.equ num, 0x12，表示 num&#x3D;0x12。</li><li>.align 数据字节对齐，比如： .align 4 表示 4 字节对齐。</li><li>.end 表示源文件结束。</li><li>.global 定义一个全局符号，格式为： .global symbol，比如： .global _start(汇编程序的默认入口标号是_start  )。</li></ul><p><strong>函数:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">函数名:</span><br>函数体<br>返回语句<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">/* SVC 中断 */<br>SVC_Handler:<br>    ldr r0, =SVC_Handler<br>    bx r0@跳转<br></code></pre></td></tr></table></figure><h2 id="常用汇编指令"><a href="#常用汇编指令" class="headerlink" title="常用汇编指令"></a>常用汇编指令</h2><h3 id="处理器内部数据传输指令-mov-mrs-msr"><a href="#处理器内部数据传输指令-mov-mrs-msr" class="headerlink" title="处理器内部数据传输指令 mov mrs msr"></a>处理器内部数据传输指令 mov mrs msr</h3><table><thead><tr><th>指令</th><th>目的</th><th>源</th><th></th></tr></thead><tbody><tr><td>MOV</td><td>R0</td><td>R1</td><td>将 R1 里面的数据复制到 R0 中。</td></tr><tr><td>MRS</td><td>R0</td><td>CPSR</td><td>将特殊寄存器 CPSR 里面的数据复制到 R0 中。<br/><strong>(特殊寄存器只能由这个指令 读 )</strong></td></tr><tr><td>MSR</td><td>CPSR</td><td>R1</td><td>将 R1 里面的数据复制到特殊寄存器 CPSR 里中。<br/><strong>(特殊寄存器只能由这个指令 写 )</strong></td></tr></tbody></table><h3 id="存储器访问指令-ldr-str"><a href="#存储器访问指令-ldr-str" class="headerlink" title="存储器访问指令 ldr str"></a>存储器访问指令 ldr str</h3><p>I.MX6UL中的RAM,寄存器都需要这个指令访问。</p><p>LDR和STR是按照字进行读取和写入的，LDRB和STRB是按字节，LDRH和STRH是按半字操作。</p><table><thead><tr><th>指令</th><th></th></tr></thead><tbody><tr><td>LDR Rd, [Rn , #offset]</td><td>从存储器 Rn+offset 的位置读取数据存放到 Rd 中。</td></tr><tr><td>STR Rd, [Rn, #offset]</td><td>将 Rd 中的数据写入到存储器中的 Rn+offset 位置。</td></tr></tbody></table><h4 id="LDR"><a href="#LDR" class="headerlink" title="LDR"></a>LDR</h4><ul><li><p>读取寄存器值</p></li><li><p>加载立即数到寄存器</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">@加载立即数<br>LDR R0, =0X0209C004 @将寄存器地址 0X0209C004 加载到 R0 中，即 R0=0X0209C004<br>@读取寄存器值<br>LDR R1, [R0] @读取地址 0X0209C004 中的数据到 R1 寄存器中<br></code></pre></td></tr></table></figure><h4 id="STR"><a href="#STR" class="headerlink" title="STR"></a>STR</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">LDR R0, =0X0209C004 @将寄存器地址 0X0209C004 加载到 R0 中，即 R0=0X0209C004<br>LDR R1, =0X12345678 @R1 保存要写入到寄存器的值，即 R1=0X12345678<br>STR R1, [R0] @将 R1 中的值写入到 R0 中的地址上<br></code></pre></td></tr></table></figure><h3 id="压栈出栈指令-push-pop"><a href="#压栈出栈指令-push-pop" class="headerlink" title="压栈出栈指令 push pop"></a>压栈出栈指令 push pop</h3><table><thead><tr><th>指令</th><th></th></tr></thead><tbody><tr><td>PUSH &lt;reg list&gt;</td><td>将寄存器列表存入栈中。</td></tr><tr><td>POP &lt;reg list&gt;</td><td>从栈中恢复寄存器列表。</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asm">@处理器的堆栈是向下增长的 见下图<br>PUSH &#123;R0~R3, R12&#125; @将 R0~R3 和 R12 压栈<br>PUSH &#123;LR&#125; @将 LR 进行压栈<br><br>POP &#123;LR&#125; @先恢复 LR<br>POP &#123;R0~R3,R12&#125; @在恢复 R0~R3,R12<br></code></pre></td></tr></table></figure><p><img src="/2021/9b4105ad/image-20210707144653945.png" alt="image-20210707144653945"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs asm">@这个和上面的是等同的<br>STMFD SP!,&#123;R0~R3, R12&#125; @R0~R3,R12 入栈<br>STMFD SP!,&#123;LR&#125; @LR 入栈<br><br>LDMFD SP!, &#123;LR&#125; @先恢复 LR<br>LDMFD SP!, &#123;R0~R3, R12&#125; @再恢复 R0~R3, R12<br><br><br>LDMFD = LDM + FD<br>STMFD = STM + FD<br>LDM(多个) -&gt; LDR(单个)<br>STM(多个) -&gt; STR(单个)<br>FD = Full Descending 即满递减的意思(根据 ATPCS 规则,ARM 使用的 FD 类型的堆栈， SP 指向最后一个入栈的数值，堆栈是由高地址向下增长的，也就是前面说的向下增长的堆栈，)<br></code></pre></td></tr></table></figure><h3 id="跳转指令-b-bx-bl-blx"><a href="#跳转指令-b-bx-bl-blx" class="headerlink" title="跳转指令 b bx bl blx"></a>跳转指令 b bx bl blx</h3><p>跳转操作的方法  </p><ol><li>直接使用跳转指令 B、 BL、 BX 等</li><li>直接向 PC 寄存器里面写入数据。</li></ol><table><thead><tr><th>指令</th><th></th></tr></thead><tbody><tr><td>B &lt;label&gt;</td><td>跳转到 label，如果跳转范围超过了+&#x2F;-2KB，<br/>可以指定 B.W &lt;label&gt;使用 32 位版本的跳转指令， 这样可以得到较大范围的 跳转</td></tr><tr><td>BX &lt;Rm&gt;</td><td>间接跳转，跳转到存放于 Rm 中的地址处，并且切换指令集</td></tr><tr><td>BL &lt;label&gt;</td><td>跳转到标号地址，并将返回地址保存在 LR 中。</td></tr><tr><td>BLX &lt;Rm&gt;</td><td>结合 BX 和 BL 的特点，跳转到 Rm 指定的地址，并将返回地 址保存在 LR 中，切换指令集。</td></tr></tbody></table><h4 id="B指令"><a href="#B指令" class="headerlink" title="B指令"></a>B指令</h4><p>这是最简单的跳转指令， B 指令会将 PC 寄存器的值设置为跳转目标地址， 一旦执行 B 指令， ARM 处理器就会立即跳转到指定的目标地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">_start:<br>    ldr sp,=0X80200000 @设置栈指针<br>    b main @跳转到 main 函数<br></code></pre></td></tr></table></figure><p>上述代码就是典型的在汇编中初始化 C 运行环境，然后跳转到 C 文件的 main 函数中运行 ，上述代码只是初始化了 SP 指针，有些处理器还需要做其他的初始化，比如初始化 DDR 等等。因为跳转到 C 文件以后再也不会回到汇编了，所以在第 4 行使用了 B 指令来完成跳转  。</p><h4 id="BL指令"><a href="#BL指令" class="headerlink" title="BL指令"></a>BL指令</h4><p>BL 指令相比 B 指令，在跳转之前会在寄存器 LR(R14)中保存当前 PC 寄存器值，所以可以通过将 LR 寄存器中的值重新加载到 PC 中来继续从跳转之前的代码处运行，这是子程序调用一个基本但常用的手段。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asm">push &#123;r0, r1&#125; @保存 r0,r1<br>cps #0x13 @进入 SVC 模式，允许其他中断再次进去<br><br>bl system_irqhandler@加载 C 语言中断处理函数到 r2 寄存器中<br><br>cps #0x12 @进入 IRQ 模式<br>pop &#123;r0, r1&#125;<br>str r0, [r1, #0X10] @中断执行完成，写 EOIR<br></code></pre></td></tr></table></figure><p>上述代码中第 5 行就是执行 C 语言版的中断处理函数，当处理完成以后是需要返回来继续执行下面的程序，所以使用了 BL 指令。  </p><h3 id="算术运算指令"><a href="#算术运算指令" class="headerlink" title="算术运算指令"></a>算术运算指令</h3><p>汇编中也可以进行算术运算， 比如加减乘除，常用的运算指令用法如表 7.2.5.1 所示：</p><table><thead><tr><th>指令</th><th>计算公式</th><th></th></tr></thead><tbody><tr><td>ADD Rd, Rn, Rm</td><td>Rd &#x3D; Rn + Rm</td><td>加法运算，指令为 ADD</td></tr><tr><td>ADD Rd, Rn, #immed</td><td>Rd &#x3D; Rn + #immed</td><td>加法运算，指令为 ADD</td></tr><tr><td>ADC Rd, Rn, Rm</td><td>Rd &#x3D; Rn + Rm + 进位</td><td>带进位的加法运算，指令为 ADC</td></tr><tr><td>ADC Rd, Rn, #immed</td><td>Rd &#x3D; Rn + #immed +进位</td><td>带进位的加法运算，指令为 ADC</td></tr><tr><td>SUB Rd, Rn, Rm</td><td>Rd &#x3D; Rn – Rm</td><td>减法</td></tr><tr><td>SUB Rd, #immed</td><td>Rd &#x3D; Rd - #immed</td><td>减法</td></tr><tr><td>SUB Rd, Rn, #immed</td><td>Rd &#x3D; Rn - #immed</td><td>减法</td></tr><tr><td>SBC Rd, Rn, #immed</td><td>Rd &#x3D; Rn - #immed – 借位</td><td>带借位的减法</td></tr><tr><td>SBC Rd, Rn ,Rm</td><td>Rd &#x3D; Rn – Rm – 借位</td><td>带借位的减法</td></tr><tr><td>MUL Rd, Rn, Rm</td><td>Rd &#x3D; Rn * Rm</td><td>乘法(32 位)</td></tr><tr><td>UDIV Rd, Rn, Rm</td><td>Rd &#x3D; Rn &#x2F; Rm</td><td>无符号除法</td></tr><tr><td>SDIV Rd, Rn, Rm</td><td>Rd &#x3D; Rn &#x2F; Rm</td><td>有符号除法</td></tr></tbody></table><h3 id="逻辑运算指令"><a href="#逻辑运算指令" class="headerlink" title="逻辑运算指令"></a>逻辑运算指令</h3><table><thead><tr><th>指令</th><th>计算公式</th><th></th></tr></thead><tbody><tr><td>AND Rd, Rn</td><td>Rd &#x3D; Rd &amp;Rn</td><td>按位与</td></tr><tr><td>AND Rd, Rn, #immed</td><td>Rd &#x3D; Rn &amp;#immed</td><td>按位与</td></tr><tr><td>AND Rd, Rn, Rm</td><td>Rd &#x3D; Rn &amp; Rm</td><td>按位与</td></tr><tr><td>ORR Rd, Rn</td><td>Rd &#x3D; Rd | Rn</td><td>按位或</td></tr><tr><td>ORR Rd, Rn, #immed</td><td>Rd &#x3D; Rn | #immed</td><td>按位或</td></tr><tr><td>ORR Rd, Rn, Rm</td><td>Rd &#x3D; Rn | Rm</td><td>按位或</td></tr><tr><td>BIC Rd, Rn</td><td>Rd &#x3D; Rd &amp; (~Rn)</td><td>位清除</td></tr><tr><td>BIC Rd, Rn, #immed</td><td>Rd &#x3D; Rn &amp; (~#immed)</td><td>位清除</td></tr><tr><td>BIC Rd, Rn , Rm</td><td>Rd &#x3D; Rn &amp; (~Rm)</td><td>位清除</td></tr><tr><td>ORN Rd, Rn, #immed</td><td>Rd &#x3D; Rn | (#immed)</td><td>按位或非</td></tr><tr><td>ORN Rd, Rn, Rm</td><td>Rd &#x3D; Rn | (Rm)</td><td>按位或非</td></tr><tr><td>EOR Rd, Rn</td><td>Rd &#x3D; Rd ^ Rn</td><td>按位异或</td></tr><tr><td>EOR Rd, Rn, #immed</td><td>Rd &#x3D; Rn ^ #immed</td><td>按位异或</td></tr><tr><td>EOR Rd, Rn, Rm</td><td>Rd &#x3D; Rn ^ Rm</td><td>按位异或</td></tr></tbody></table><h1 id="启动方式"><a href="#启动方式" class="headerlink" title="启动方式"></a>启动方式</h1><h2 id="BOOT"><a href="#BOOT" class="headerlink" title="BOOT"></a>BOOT</h2><p>OOT_MODE[1:0]的值是可以改变的，有两种方式，一种是改写 eFUSE(熔丝)，一种是修改相应的 GPIO 高低电平。  </p><ul><li>BOOT_MODE1 和 BOOT_MODE0 在芯片内部是有 100KΩ下拉电阻的 ，所以默认是0。</li></ul><table><thead><tr><th>BOOT_MODE[1:0]</th><th>BOOT 类型</th></tr></thead><tbody><tr><td>00</td><td>从 FUSE 启动</td></tr><tr><td>01</td><td>串行下载</td></tr><tr><td>10</td><td>内部 BOOT 模式</td></tr><tr><td>11</td><td>保留</td></tr></tbody></table><h3 id="串行下载"><a href="#串行下载" class="headerlink" title="串行下载"></a>串行下载</h3><p>串行下载的意思就是可以通过 USB 或者 UART 将代码下载到板子上的外置存储设备中，我们可以使用 OTG1 这个 USB口向开发板上的 SD&#x2F;EMMC、 NAND 等存储设备下载代码。  </p><h3 id="内部-BOOT-模式"><a href="#内部-BOOT-模式" class="headerlink" title="内部 BOOT 模式"></a>内部 BOOT 模式</h3><p>芯片会执行内部的 boot ROM 代码，代码会进行硬件初始化(一部分外设)，然后从 boot 设备(就是存放代码的设备、比如 SD&#x2F;EMMC、 NAND)中<strong>将代码拷贝出来复制到指定的 RAM 中，一般是 DDR。</strong>  </p><h2 id="BOOT模式-启动设备"><a href="#BOOT模式-启动设备" class="headerlink" title="BOOT模式 启动设备"></a>BOOT模式 启动设备</h2><p>当 BOOT_MODE 设置为内部 BOOT 模式以后，可以从以下设备中启动：<br>①、接到 EIM 接口的 CS0 上的 16 位 NOR Flash。<br>②、接到 EIM 接口的 CS0 上的 OneNAND Flash。<br>③、接到 GPMI 接口上的 MLC&#x2F;SLC NAND Flash， NAND Flash 页大小支持 2KByte、 4KByte和 8KByte， 8 位宽。<br>④、 Quad SPI Flash。<br>⑤、接到 USDHC 接口上的 SD&#x2F;MMC&#x2F;eSD&#x2F;SDXC&#x2F;eMMC 等设备。<br>⑥、 SPI 接口的 EEPROM。  </p><p>启动设备是通过  BOOT_CFG1[7:0]、 BOOT_CFG2[7:0]和 BOOT_CFG4[7:0]这 24 个配置 IO配置，这 24 个配置 IO 刚好对应着 LCD 的 24 根数据线 LCD_DATA0~LCDDATA23，<strong>当启动完成以后这 24 个 IO 就可以作为 LCD 的数据线使用。</strong>  </p><table><thead><tr><th>boot1</th><th>boot0</th><th></th><th></th><th></th><th></th><th></th><th></th><th>启动设备</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>x</td><td>x</td><td>x</td><td>x</td><td>x</td><td>x</td><td>串行下载，可以通过 USB 烧写镜像文件。</td></tr><tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>SD 卡启动。</td></tr><tr><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>EMMC 启动。</td></tr><tr><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>NAND FLASH 启动。</td></tr></tbody></table><h2 id="烧写镜像"><a href="#烧写镜像" class="headerlink" title="烧写镜像"></a>烧写镜像</h2><p><strong>imxdownload 会在 led.bin前面添加一些头信息，重新生成一个叫做 load.imx 的文件，头部信息包含以下</strong>  </p><ul><li><p>Image vector table，简称 IVT， IVT 里面包含了一系列的地址信息，这些地址信息在ROM 中按照固定的地址存放着。 </p></li><li><p>Boot data，启动数据，包含了镜像要拷贝到哪个地址，拷贝的大小是多少等等。</p></li><li><p>Device configuration data，简称 DCD，设备配置信息，重点是 DDR3 的初始化配置。</p></li><li><p>用户代码可执行文件，比如 led.bin。</p></li></ul><p>最终烧写到 I.MX6U 中的程序其组成为： IVT+Boot data+DCD+.bin 。(3KByte 的 IVT+Boot Data+DCD)</p><p>.bin是从0x87800000这个地方开始，往前推load.imx就是从0x877FF400开始的。</p><h1 id="点灯"><a href="#点灯" class="headerlink" title="点灯"></a>点灯</h1><p><strong>Makefile</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 定义了一个变量 objs， objs 包含着要生成 ledc.bin 所需的材料： start.o 和 main.o</span><br><span class="hljs-comment"># 这里要注意 start.o 一定要放到最前面！因为在后面链接的时候 start.o 要在最前面，因为 start.o 是最先要执行的文件！</span><br>objs := start.o main.o<br><br><span class="hljs-comment"># 使用依赖文件(objs:=start.o main.o),生成目标可执行文件ledc.bin</span><br><span class="hljs-section">ledc.bin:<span class="hljs-variable">$(objs)</span></span><br><span class="hljs-comment"># 使用编译器 arm-linux-gnueabihf-ld 进行连接,-Ttext指定起始地址是0X87800000</span><br><span class="hljs-comment"># $^ 是所有依赖文件的集合,也就是变量objs的值(start.o main.o)</span><br><span class="hljs-comment"># 展开等价 arm-linux-gnueabihf-ld -Ttext 0X87800000 -o ledc.elf start.o main.o</span><br>arm-linux-gnueabihf-ld -Ttext 0X87800000 -o ledc.elf <span class="hljs-variable">$^</span><br><span class="hljs-comment"># 将ledc.elf转换成ledc.bin文件</span><br><span class="hljs-comment"># $@ 的意思是目标集合，在这里就是 ledc.bin</span><br><span class="hljs-comment"># 展开等价 arm-linux-gnueabihf-objcopy -O binary -S ledc.elf ledc.bin</span><br>arm-linux-gnueabihf-objcopy -O binary -S ledc.elf <span class="hljs-variable">$@</span><br><span class="hljs-comment"># 反汇编，生成 ledc.dis 文件</span><br>arm-linux-gnueabihf-objdump -D -m arm ledc.elf &gt; ledc.dis<br><br><span class="hljs-comment"># 下面规则展开等价 </span><br><span class="hljs-comment"># start.o:start.s</span><br><span class="hljs-comment">#arm-linux-gnueabihf-gcc -Wall -nostdlib -c -O2 -o start.o start.s</span><br><span class="hljs-comment"># %匹配任意字符</span><br><span class="hljs-section">%.o:%.s</span><br><span class="hljs-comment"># $@ 的意思是目标集合，在这里就是 %.o</span><br><span class="hljs-comment"># $&lt; 所有依赖文件的集合，在这就是 %.s</span><br>arm-linux-gnueabihf-gcc -Wall -nostdlib -c -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br><span class="hljs-section">%.o:%.S</span><br>arm-linux-gnueabihf-gcc -Wall -nostdlib -c -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br><span class="hljs-section">%.o:%.c</span><br>arm-linux-gnueabihf-gcc -Wall -nostdlib -c -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br><br><span class="hljs-section">clean:</span><br>rm -rf *.o ledc.bin ledc.elf ledc.dis<br></code></pre></td></tr></table></figure><p><strong>Makefile</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 类似于上面的只是用到了变量</span><br>CROSS_COMPILE?= arm-linux-gnueabihf-<br>NAME ?= ledc<br><br>CC := <span class="hljs-variable">$(CROSS_COMPILE)</span>gcc<br>LD := <span class="hljs-variable">$(CROSS_COMPILE)</span>ld<br>OBJCOPY := <span class="hljs-variable">$(CROSS_COMPILE)</span>objcopy<br>OBJDUMP := <span class="hljs-variable">$(CROSS_COMPILE)</span>objdump<br>OBJS := start.o main.o<br><br><span class="hljs-variable">$(NAME)</span>.bin:<span class="hljs-variable">$(OBJS)</span><br><span class="hljs-variable">$(LD)</span> -Timx6ul.lds -o <span class="hljs-variable">$(NAME)</span>.elf <span class="hljs-variable">$^</span><br><span class="hljs-variable">$(OBJCOPY)</span> -O binary -S <span class="hljs-variable">$(NAME)</span>.elf <span class="hljs-variable">$@</span><br><span class="hljs-variable">$(OBJDUMP)</span> -D -m arm <span class="hljs-variable">$(NAME)</span>.elf &gt; <span class="hljs-variable">$(NAME)</span>.dis<br>    <br><span class="hljs-section">%.o:%.s</span><br><span class="hljs-variable">$(CC)</span> -Wall -nostdlib -c -O2 -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br><span class="hljs-section">%.o:%.S</span><br><span class="hljs-variable">$(CC)</span> -Wall -nostdlib -c -O2 -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br><span class="hljs-section">%.o:%.c</span><br><span class="hljs-variable">$(CC)</span> -Wall -nostdlib -c -O2 -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br><br><span class="hljs-section">clean:</span><br>rm -rf *.o <span class="hljs-variable">$(NAME)</span>.bin <span class="hljs-variable">$(NAME)</span>.elf <span class="hljs-variable">$(NAME)</span>.dis<br></code></pre></td></tr></table></figure><p><strong>Makefile</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs makefile">CROSS_COMPILE?= arm-linux-gnueabihf-<br><span class="hljs-comment"># 编译后 目标名</span><br>TARGET?= bsp<br><br><span class="hljs-comment"># 编译器相关</span><br>CC:= <span class="hljs-variable">$(CROSS_COMPILE)</span>gcc<br>LD:= <span class="hljs-variable">$(CROSS_COMPILE)</span>ld<br>OBJCOPY:= <span class="hljs-variable">$(CROSS_COMPILE)</span>objcopy<br>OBJDUMP:= <span class="hljs-variable">$(CROSS_COMPILE)</span>objdump<br><br><span class="hljs-comment"># include dir</span><br>INCDIRS:=  imx6ul  \<br>bsp/clk \<br>bsp/led \<br>bsp/delay<br><br><span class="hljs-comment"># sourc dir</span><br>SRCDIRS :=  project \<br>bsp/clk \<br>bsp/led \<br>bsp/delay<br><br><span class="hljs-comment"># 这里用到了 patsubst 函数 通过这个函数给 INCDIRS 前面加了一个 -I</span><br><span class="hljs-comment"># 展开 INCLUDE := -I imx6ul -I bsp/clk -I bsp/led -I bsp/delay</span><br>INCLUDE := <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %, -I %, <span class="hljs-variable">$(INCDIRS)</span>)</span><br><br><span class="hljs-comment"># 这里用到了 foreach 和 wildcard 函数</span><br><span class="hljs-comment"># 展开 SFILES := project/start.S</span><br><span class="hljs-comment"># 展开 CFILES := project/main.c bsp/clk/bsp_clk.c bsp/led/bsp_led.c bsp/delay/bsp_delay.c</span><br>SFILES := <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> <span class="hljs-built_in">dir</span>, <span class="hljs-variable">$(SRCDIRS)</span>, $(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(dir)</span>/*.S)</span>)<br>CFILES := <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> <span class="hljs-built_in">dir</span>, <span class="hljs-variable">$(SRCDIRS)</span>, $(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(dir)</span>/*.c)</span>)<br><br><span class="hljs-comment"># 这里用到了 notdir 函数 除去路径函数</span><br><span class="hljs-comment"># 展开 SFILENDIR := start.S</span><br><span class="hljs-comment"># 展开 CFILENDIR := main.c bsp_clk.c bsp_led.c bsp_delay.c</span><br>SFILENDIR := <span class="hljs-variable">$(<span class="hljs-built_in">notdir</span> <span class="hljs-variable">$(SFILES)</span>)</span><br>CFILENDIR := <span class="hljs-variable">$(<span class="hljs-built_in">notdir</span> <span class="hljs-variable">$(CFILES)</span>)</span><br><br><span class="hljs-comment"># 展开 SOBJS := obj/start.o</span><br><span class="hljs-comment"># 展开 COBJS := obj/main.o obj/bsp_clk.o obj/bsp_led.o obj/bsp_delay.o</span><br><span class="hljs-comment"># 展开 OBJS  := obj/start.o obj/main.o obj/bsp_clk.o obj/bsp_led.o obj/bsp_delay.o</span><br>SOBJS := <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %, obj/%, $(SFILENDIR:.S=.o)</span>)<br>COBJS := <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %, obj/%, $(CFILENDIR:.c=.o)</span>)<br>OBJS := <span class="hljs-variable">$(SOBJS)</span> <span class="hljs-variable">$(COBJS)</span><br><br>VPATH := <span class="hljs-variable">$(SRCDIRS)</span><br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: clean</span><br><br><span class="hljs-variable">$(TARGET)</span>.bin : <span class="hljs-variable">$(OBJS)</span><br><span class="hljs-variable">$(LD)</span> -Timx6ul.lds -o <span class="hljs-variable">$(TARGET)</span>.elf <span class="hljs-variable">$^</span><br><span class="hljs-variable">$(OBJCOPY)</span> -O binary -S <span class="hljs-variable">$(TARGET)</span>.elf <span class="hljs-variable">$@</span><br><span class="hljs-variable">$(OBJDUMP)</span> -D -m arm <span class="hljs-variable">$(TARGET)</span>.elf &gt; <span class="hljs-variable">$(TARGET)</span>.dis<br><br><span class="hljs-variable">$(SOBJS)</span> : obj/%.o : %.S<br><span class="hljs-variable">$(CC)</span> -Wall -nostdlib -c -O2 <span class="hljs-variable">$(INCLUDE)</span> -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br><span class="hljs-variable">$(COBJS)</span> : obj/%.o : %.c<br><span class="hljs-variable">$(CC)</span> -Wall -nostdlib -c -O2 <span class="hljs-variable">$(INCLUDE)</span> -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br><br><span class="hljs-section">clean:</span><br>rm -rf <span class="hljs-variable">$(TARGET)</span>.elf <span class="hljs-variable">$(TARGET)</span>.dis <span class="hljs-variable">$(TARGET)</span>.bin <span class="hljs-variable">$(COBJS)</span> <span class="hljs-variable">$(SOBJS)</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>alpha_mini</tag>
      
      <tag>正点原子</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cortex-A7 基础</title>
    <link href="/2021/da01e608/"/>
    <url>/2021/da01e608/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Cortex-A7 MPCore </p><ul><li><p>1-4core</p></li><li><p>Cortex-A15(big)+Cortex-A7(LITTLE)</p></li><li><p>L1 Cache 8,16,32,64KB</p></li><li><p>L2 Choice</p></li></ul><p>Cortex-A7 MPCore 基于 ARMv7-A</p><ul><li>SIMDv2 扩展整形和浮点向量</li><li>VFPv4 高性能单双精度浮点指令</li><li>LPAE 40bit寻址 最大1TB内存</li><li>硬件虚拟化</li><li>NEON 多媒体、信号处理加速</li></ul><h1 id="运行模式"><a href="#运行模式" class="headerlink" title="运行模式"></a>运行模式</h1><p>Cortex-A7处理器有 9种处理模式，除了 User(USR)用户模式以外，其它 8 种运行模式都是特权模式。  </p><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>User(USR)</td><td>用户模式，非特权大部分程序运行的时候就处于此。</td></tr><tr><td>FIQ</td><td>快速中断模式，进入 FIQ 中断异常</td></tr><tr><td>IRQ</td><td>一般中断模式。</td></tr><tr><td>Supervisor(SVC)</td><td>超级管理员模式，特权模式，供操作系统使用。</td></tr><tr><td>Monitor(MON)</td><td>这个模式用于安全扩展模式。</td></tr><tr><td>Abort(ABT)</td><td>数据访问终止模式，用于虚拟存储以及存储保护。</td></tr><tr><td>Hyp(HYP)</td><td>用于虚拟化扩展。</td></tr><tr><td>Undef(UND)</td><td>未定义指令终止模式。</td></tr><tr><td>System(SYS)</td><td>系统模式，用于运行特权级的操作系统任务</td></tr></tbody></table><h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><p><img src="/2021/da01e608/image-20210702163336723.png" alt="image-20210702163336723"></p><ul><li>暗色代表没有物理寄存器</li></ul><p><img src="/2021/da01e608/image-20210702163355713.png" alt="image-20210702163355713"></p><h2 id="CPSR"><a href="#CPSR" class="headerlink" title="CPSR"></a>CPSR</h2><p>CPSR 是当前程序状态寄存器，该寄存器包含了条件标志位、中断禁止位、当前处理器模式标志<br>等一些状态位以及一些控制位。  </p><p>SPSR(备份程序状态寄存器)  备份CPSR的</p><p><img src="/2021/da01e608/image-20210702164501790.png" alt="image-20210702164501790"></p><ul><li><p>N(bit31)：当两个补码表示的 有符号整数运算的时候， N&#x3D;1 表示运算对的结果为负数， N&#x3D;0表示结果为正数。</p></li><li><p>Z(bit30)： Z&#x3D;1 表示运算结果为零， Z&#x3D;0 表示运算结果不为零，对于 CMP 指令， Z&#x3D;1 表示进行比较的两个数大小相等。</p></li><li><p>C(bit29)：在加法指令中，当结果产生了进位，则 C&#x3D;1，表示无符号数运算发生上溢，其它情况下 C&#x3D;0。在减法指令中，当运算中发生借位，则 C&#x3D;0，表示无符号数运算发生下溢，其它情况下 C&#x3D;1。对于包含移位操作的非加&#x2F;减法运算指令， C 中包含最后一次溢出的位的数值，对于其它非加&#x2F;减运算指令， C 位的值通常不受影响。</p></li><li><p>V(bit28)： 对于加&#x2F;减法运算指令，当操作数和运算结果表示为二进制的补码表示的带符号数时， V&#x3D;1 表示符号位溢出，通常其他位不影响 V 位。</p></li><li><p>Q(bit27)： 仅 ARM v5TE_J 架构支持，表示饱和状态， Q&#x3D;1 表示累积饱和， Q&#x3D;0 表示累积不饱和。</p></li><li><p>IT[1:0].(bit26:25)： 和 IT[7:2].(bit15:bit10)一起组成 IT[7:0]，作为 IF-THEN 指令执行状态。</p></li><li><p>J(bit24)： 仅 ARM_v5TE-J 架构支持， J&#x3D;1 表示处于 Jazelle 状态，此位通常和 T(bit5)位一起表示当前所使用的指令集：</p></li></ul><table><thead><tr><th>J</th><th>T</th><th>bref</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>ARM</td></tr><tr><td>0</td><td>1</td><td>Thumb</td></tr><tr><td>1</td><td>1</td><td>ThumbEE</td></tr><tr><td>1</td><td>0</td><td>Jazelle</td></tr></tbody></table><ul><li><p>GE[3:0].(bit19:16)： SIMD 指令有效，大于或等于。</p></li><li><p>IT[7:2].(bit15:10)： 参考 IT[1:0]。</p></li><li><p>E(bit9)： 大小端控制位， E&#x3D;1 表示大端模式， E&#x3D;0 表示小端模式。</p></li><li><p>A(bit8)： 禁止异步中断位， A&#x3D;1 表示禁止异步中断。</p></li><li><p>I(bit7)： I&#x3D;1 禁止 IRQ， I&#x3D;0 使能 IRQ。</p></li><li><p>F(bit6)： F&#x3D;1 禁止 FIQ， F&#x3D;0 使能 FIQ。</p></li><li><p>T(bit5)： 控制指令执行状态，表明本指令是 ARM 指令还是 Thumb 指令，通常和 J(bit24)一起表明指令类型，参考 J(bit24)位。</p></li><li><p>M[4:0]： 处理器模式控制位：</p><table><thead><tr><th>M[4:0]</th><th>CPU Mode</th></tr></thead><tbody><tr><td>10000</td><td>User 模式</td></tr><tr><td>10001</td><td>FIQ 模式</td></tr><tr><td>10010</td><td>IRQ 模式</td></tr><tr><td>10011</td><td>Supervisor(SVC)模式</td></tr><tr><td>10110</td><td>Monitor(MON)模式</td></tr><tr><td>10111</td><td>Abort(ABT)模式</td></tr><tr><td>11010</td><td>Hyp(HYP)模式</td></tr><tr><td>11011</td><td>Undef(UND)模式</td></tr><tr><td>11111</td><td>System(SYS)模式</td></tr></tbody></table></li></ul><p>​    </p>]]></content>
    
    
    <categories>
      
      <category>CortexCore</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cortex-a7</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WS2812驱动 SPI+DMA 无需降频 一个灯占用9Byte的RAM</title>
    <link href="/2021/aaef73f3/"/>
    <url>/2021/aaef73f3/</url>
    
    <content type="html"><![CDATA[<h1 id="WS2812驱动-STM32F103-SPI-DMA-无需降频-一个灯占用9Byte的RAM"><a href="#WS2812驱动-STM32F103-SPI-DMA-无需降频-一个灯占用9Byte的RAM" class="headerlink" title="WS2812驱动 STM32F103 SPI+DMA 无需降频 一个灯占用9Byte的RAM"></a>WS2812驱动 STM32F103 SPI+DMA 无需降频 一个灯占用9Byte的RAM</h1><p>对于WS2812不了解的朋友可以先看一下这些<br>​<a href="https://www.cnblogs.com/PureHeart/p/11349495.html">【STM32】WS2812介绍、使用SPI+DMA发送数据</a><br><img src="/2021/aaef73f3/pic_center.png" alt="ws812"></p><p>WS2812的驱动我想到的主要有三种</p><ul><li>延时</li><li>SPI</li><li>UART<br><strong>三者区分：</strong></li></ul><ol><li>延时，占用资源，需要用到ASM nop不然容易被优化，需要用示波器抓时间。</li><li>UART 起始位低，结束位高，如果要强行实现也是可以但是实现起来过于复杂，不够优美。</li><li>没有片选的功能，会占用一整个硬件SPI，觉得较为优美。</li></ol><p>在网上看了很多SPI例子都是使用 SPI的8bit数据来模拟WS2812的一个bit颜色的数据，但是由于STM32F103主频72M，要凑出来这个SPI的频率我看某些做法是进行降频，吾不喜，要么还有就是和协议时序差异挺大但是有些WS2812能运行，但是考虑到可能有些ws2812会不能兼容，吾不喜。</p><p>STM32F103 设主频72M，SPI分频数设置为32，则SPI的通信频率为2.25M，传输一位数据的时间约为444纳秒（ns）444ns 888ns 符合WS281X芯片的通信时序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//  __</span><br><span class="hljs-comment">// |  |_|   0b110  high level</span><br><span class="hljs-comment">//  _   </span><br><span class="hljs-comment">// | |__|   0b100  low level</span><br></code></pre></td></tr></table></figure><p><strong>这个方式和协议时序更加接近，占用RAM应该是笔者认为最小的了</strong><br>一个灯24bit颜色，只需要24*3&#x2F;8 &#x3D; 9Byte的Buff。</p><p><strong>写代码的时候需要注意一下大小端的问题，尽量保持大小端的兼容性</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 设置某一个WS2812</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param num </span><br><span class="hljs-comment"> * @param RGB </span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">WS2812_OneSet</span><span class="hljs-params">( <span class="hljs-type">uint8_t</span> num, <span class="hljs-type">uint32_t</span> RGB )</span><br>&#123;<br>    <span class="hljs-type">uint8_t</span> i;<br>    <span class="hljs-type">uint32_t</span> TempR = <span class="hljs-number">0</span>, TempG = <span class="hljs-number">0</span>, TempB = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//MSB First</span><br>    <span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; ++i,RGB&gt;&gt;=<span class="hljs-number">1</span> )<br>    &#123;<br>        (RGB &amp; <span class="hljs-number">0x00010000</span>) != <span class="hljs-number">0</span> ? (TempR |= (WS2812_HIG&lt;&lt;(i*<span class="hljs-number">3</span>))) : (TempR |= (WS2812_LOW&lt;&lt;(i*<span class="hljs-number">3</span>)));<br>        (RGB &amp; <span class="hljs-number">0x00000100</span>) != <span class="hljs-number">0</span> ? (TempG |= (WS2812_HIG&lt;&lt;(i*<span class="hljs-number">3</span>))) : (TempG |= (WS2812_LOW&lt;&lt;(i*<span class="hljs-number">3</span>)));<br>        (RGB &amp; <span class="hljs-number">0x00000001</span>) != <span class="hljs-number">0</span> ? (TempB |= (WS2812_HIG&lt;&lt;(i*<span class="hljs-number">3</span>))) : (TempB |= (WS2812_LOW&lt;&lt;(i*<span class="hljs-number">3</span>)));<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i )<br>    &#123;<br>        g_ws2812.Col[num].RGB.R[i] = TempR &gt;&gt; (<span class="hljs-number">16</span><span class="hljs-number">-8</span>*i);<br>        g_ws2812.Col[num].RGB.G[i] = TempG &gt;&gt; (<span class="hljs-number">16</span><span class="hljs-number">-8</span>*i);<br>        g_ws2812.Col[num].RGB.B[i] = TempB &gt;&gt; (<span class="hljs-number">16</span><span class="hljs-number">-8</span>*i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有参考的代码，有积分的给点积分用吧，没积分的可以去Github下。<br><a href="https://github.com/Jack-InGitHub/WS2812">Github</a><br><a href="https://download.csdn.net/download/weixin_42078116/14975868">CSDN下载</a></p><p>参考资料<br><a href="https://www.amobbs.com/thread-5697122-1-1.html?_dsign=01c8809d">stm32和ws2812B相对较好的方案。SPI和UART </a></p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ws2812</tag>
      
      <tag>spi</tag>
      
      <tag>dma</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机智云通信</title>
    <link href="/2021/60aa39b4/"/>
    <url>/2021/60aa39b4/</url>
    
    <content type="html"><![CDATA[<table><thead><tr><th>包头(2B)</th><th>包长度(2B)</th><th>命令(1B)</th><th>包序号(1B)</th></tr></thead><tbody><tr><td>0xFFFF</td><td>(包长度)后面的数据长度</td><td></td><td></td></tr></tbody></table><table><thead><tr><th>Flag(2B)</th><th>xxx</th><th>校验和(1B)</th></tr></thead><tbody><tr><td></td><td></td><td>和校验</td></tr></tbody></table><p>因为包头为固定 0xFFFF，对于发送方，如检测到有出现 0xFF 的数据内容，需要在 0xFF 后添加 0x55。对于接收方，如检测到非包头部分出现 0xFF，需要把紧跟其后的 0x55 移除。</p><table><thead><tr><th>命令</th><th>内容</th></tr></thead><tbody><tr><td>0x01</td><td>设备向MCU请求信息</td></tr><tr><td>0x02</td><td>MCU回复设备</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>embedded</tag>
      
      <tag>机智云</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cortex-M3基础</title>
    <link href="/2020/2651f4ca/"/>
    <url>/2020/2651f4ca/</url>
    
    <content type="html"><![CDATA[<h1 id="Cortex-M3基础"><a href="#Cortex-M3基础" class="headerlink" title="Cortex-M3基础"></a>Cortex-M3基础</h1><h2 id="寄存器组"><a href="#寄存器组" class="headerlink" title="寄存器组"></a>寄存器组</h2><p><img src="/2020/2651f4ca/image-20201030190843098.png" alt="image-20201030190843098"></p><h3 id="堆栈指针"><a href="#堆栈指针" class="headerlink" title="堆栈指针"></a>堆栈指针</h3><ul><li><p>R13在同一时间只有一个可见，这就是所谓的“banked”寄存器。R13 作为堆栈指针寄存器 (Stack Pointer，SP)。</p></li><li><p>主堆栈指针（MSP）：复位后缺省使用的堆栈指针，用于操作系统内核以及异常处理例程（包<br>括中断服务例程）</p></li><li><p>进程堆栈指针（PSP）：由用户的应用程序代码使用。</p></li></ul><h3 id="连接寄存器"><a href="#连接寄存器" class="headerlink" title="连接寄存器"></a>连接寄存器</h3><p>R14 作为连接寄存器 (Link Register，LR)，当呼叫(调用)一个子程序时，由R14 存储返回地址。</p><h3 id="程序计数寄存器"><a href="#程序计数寄存器" class="headerlink" title="程序计数寄存器"></a>程序计数寄存器</h3><p>R15 作为程序计数器 (Program Counter，PC)，指向当前的程序地址。如果修改它的值，就能改变程序的执行流。</p><h2 id="特殊功能寄存器"><a href="#特殊功能寄存器" class="headerlink" title="特殊功能寄存器"></a>特殊功能寄存器</h2><p><img src="/2020/2651f4ca/image-20201030192111032.png" alt="image-20201030192111032"></p><table><thead><tr><th>寄存器</th><th>功能</th></tr></thead><tbody><tr><td>xPSR</td><td>记录ALU 标志（0 标志，进位标志，负数标志，溢出标志），执行状态，<strong>以及当前正服务的中断号</strong>。(保存算术与逻辑标志，例如负数标志，零结果标志，溢出标志等等)</td></tr><tr><td>PRIMASK</td><td>除能所有的中断，不可屏蔽中断（NMI）不受影响。</td></tr><tr><td>FAULTMASK</td><td>除能所有的fault——NMI 依然不受影响，而且被除能的faults 会“上访”，见后续章节的叙述。</td></tr><tr><td>BASEPRI</td><td>除能所有优先级不高于某个具体数值的中断。</td></tr><tr><td>CONTROL</td><td>定义特权状态（见后续章节对特权的叙述），并且决定使用哪一个堆栈指针。(如果是具有浮点单元的 Cortex-M4 或者 Cortex-M7，控制寄存器也用来指示浮点单元当前是否在使用)</td></tr></tbody></table><h3 id="xPSR"><a href="#xPSR" class="headerlink" title="xPSR"></a>xPSR</h3><p>程序状态寄存器在其内部又被分为三个子状态寄存器：</p><ul><li>应用程序 PSR（APSR）</li><li>中断号 PSR（IPSR）</li><li>执行 PSR（EPSR）<br><img src="/2020/2651f4ca/image-20201217154557648.png" alt="image-20201217154557648"></li></ul><h3 id="PRIMASK，FAULTMASK-，BASEPRI"><a href="#PRIMASK，FAULTMASK-，BASEPRI" class="headerlink" title="PRIMASK，FAULTMASK ，BASEPRI"></a>PRIMASK，FAULTMASK ，BASEPRI</h3><p>CM3 page.41</p><h3 id="CONTROL-控制寄存器"><a href="#CONTROL-控制寄存器" class="headerlink" title="CONTROL 控制寄存器"></a>CONTROL 控制寄存器</h3><table><thead><tr><th>位</th><th>功能</th></tr></thead><tbody><tr><td>CONTROL[1]</td><td>堆栈指针选择<br/>0&#x3D;选择主堆栈指针MSP（复位后缺省值）<br/>1&#x3D;选择进程堆栈指针PSP<br/>在线程或基础级（没有在响应异常——译注），可以使用PSP。在handler 模式下，<br/>只允许使用MSP，所以此时不得往该位写1。</td></tr><tr><td>CONTROL[0]</td><td>0&#x3D;特权级的线程模式<br/>1&#x3D;用户级的线程模式<br/>Handler 模式永远都是特权级的。</td></tr></tbody></table><h2 id="操作模式和特权模式"><a href="#操作模式和特权模式" class="headerlink" title="操作模式和特权模式"></a>操作模式和特权模式</h2><p>Cortex-M 引入了操作模式(handler mode、thread mode)和特权级别(特权级和用户级)的概念，如果进入异常或中断处理则进入handler mode，其他情况则为thread mode。</p><p><img src="/2020/2651f4ca/image-20201030193232853.png" alt="image-20201030193232853"></p><p><strong>handler mode总是使用 MSP 作为堆栈</strong>，<strong>thread mode可以选择使用 MSP 或 PSP 作为堆栈</strong>，同样通过CONTROL 特殊寄存器控制。复位后，Cortex-M 默认进入线程模式、特权级、使用 MSP 堆栈。</p><p><img src="/2020/2651f4ca/image-20201030193654568.png" alt="image-20201030193654568"></p><p>这可以提供一种存储器访问的保护机制，使得普通的用户程序代码不能意外地，甚至是恶意地执行涉及到要害的操作。处理器支持两种特权级，这也是一个基本的安全模型。</p><p>举例来说，操作系统的内核通常都在特权级下执行，所有没有被MPU 禁掉的存储器都可以访问。在操作系统开启了一个用户程序后，通常都会让它在用户级下执行，从而使系统不会因某个程序的崩溃或恶意破坏而受损。</p><h2 id="内建的嵌套向量中断控制器-NVIC"><a href="#内建的嵌套向量中断控制器-NVIC" class="headerlink" title="内建的嵌套向量中断控制器(NVIC)"></a>内建的嵌套向量中断控制器(NVIC)</h2><h2 id="SVC和PendSV"><a href="#SVC和PendSV" class="headerlink" title="SVC和PendSV"></a>SVC和PendSV</h2><h3 id="SVC（系统服务调用，系统调用）"><a href="#SVC（系统服务调用，系统调用）" class="headerlink" title="SVC（系统服务调用，系统调用）"></a>SVC（系统服务调用，系统调用）</h3><p>例如，操作系统不让用户程序直接访问硬件，而是通过提供一些系统服务函数，用户程序使用SVC 发出对系统服务函数的呼叫请求，以这种方法调用它们来间接访问硬件。因此，当用户程序想要控制特定的硬件时，它就会产生一个SVC 异常，然后操作系统提供的SVC 异常服务例程得到执行，它再调用相关的操作系统函数，后者完成用户程序请求的服务。</p><p>优势：</p><ul><li>第一，它使用户程序从控制硬件的繁文缛节中解脱出来，而是由OS 负责控制具体的硬件。</li><li>第二，OS 的代码可以经过充分的测试，从而能使系统更加健壮和可靠。</li><li>第三，它使用户程序无需在特权级下执行，用户程序无需承担因误操作而瘫痪整个系统的风险。</li><li>第四，通过SVC 的机制，还让用户程序变得与硬件无关，因此在开发应用程序时无需了解硬件的操作细节，从而简化了开发的难度和繁琐度，并且使应用程序跨硬件平台移植成为可能。</li></ul><h3 id="PendSV（可悬起系统调用）"><a href="#PendSV（可悬起系统调用）" class="headerlink" title="PendSV（可悬起系统调用）"></a>PendSV（可悬起系统调用）</h3><p>PendSV ，它是可以像普通的中断一样被悬起的（不像SVC 那样会上访）。OS 可以利用它“缓期执行”一个异常——直到其它重要的任务完成后才执行动作。悬起PendSV 的方法是：手工往NVIC 的PendSV 悬起寄存器中写1。悬起后，如果优先级不够高，则将缓期等待执行。</p><p>PendSV 的典型使用场合是在上下文切换时（在不同任务之间切换）。例如发生中断时产生线程唤醒，中断会引发一个PendSV，在中断运行结束后，会进入PendSV在里面进行线程唤醒（线程切换）。</p><h1 id="一些总结和个人笔记"><a href="#一些总结和个人笔记" class="headerlink" title="一些总结和个人笔记"></a>一些总结和个人笔记</h1><h2 id="中断的入栈出栈"><a href="#中断的入栈出栈" class="headerlink" title="中断的入栈出栈"></a>中断的入栈出栈</h2><ol><li>进入异常服务例程时，自动压栈R0‐R3, R12, LR, PSR 和PC。</li><li>进入异常服务程序后，LR的值被自动更新为特殊的EXC_RETURN。</li></ol><table><thead><tr><th>数值</th><th>功能</th></tr></thead><tbody><tr><td>0xFFFF_FFF1</td><td>返回handler模式</td></tr><tr><td>0xFFFF_FFF9</td><td>返回线程模式，并使用主堆栈(SP&#x3D;MSP)</td></tr><tr><td>0xFFFF_FFFD</td><td>返回线程模式，并使用线程堆栈(SP&#x3D;PSP)</td></tr></tbody></table><ul><li><p>如果主程序在线程模式下运行， 并且在使用MSP 时被中断， 则在服务例程中LR&#x3D;0xFFFF_FFF9（主程序被打断前的LR已被自动入栈）。</p></li><li><p>如果主程序在线程模式下运行， 并且在使用PSP 时被中断， 则在服务例程中LR&#x3D;0xFFFF_FFFD（主程序被打断前的LR已被自动入栈）。</p></li></ul><ol start="3"><li>进入函数调用时也会压栈Rxxx寄存器作为传入参数。</li><li>R0作为函数的返回值。</li></ol>]]></content>
    
    
    <categories>
      
      <category>CortexCore</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cortex-m3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Modbus</title>
    <link href="/2020/7d358aa2/"/>
    <url>/2020/7d358aa2/</url>
    
    <content type="html"><![CDATA[<h1 id="Modbus"><a href="#Modbus" class="headerlink" title="Modbus"></a>Modbus</h1><p><a href="https://wenku.baidu.com/view/ef2f8bfe81eb6294dd88d0d233d4b14e85243e3a.html">百度文库 MODBUS协议最简单又是最直白的解释</a></p><ul><li><p>分为RTU（发Hex）模式和ASCII（发字符）模式</p></li><li><p>从机地址 0-247 （其中0为广播地址）</p></li><li><p>通信格式</p></li><li><p><strong>ASCII</strong></p><p>起始符+<strong>设备地址(1Byte)+功能码(1Byte)+数据(nByte n&lt;253)+校验(2Byte LRC)</strong>+结束符</p><ul><li>起始符——ASCII的起始符为‘:’一个冒号</li><li>设备地址——0-247</li><li>功能码——见下文</li><li>数据——略</li><li>校验——<strong>起始符 和 校验符</strong>  之间的所有数据        一般用LRC校验</li><li>结束符——Chr$（13）+Chr（10）</li><li>例—— : (起)    02(地址) 03(功能) 0a00(数据) 0004(校验)    Chr$(13)Chr(10)(终)</li><li>设备地址、功能码、数据、校验 都是用的十六进制的字符形式 例如发送0x16就发送“16”</li></ul></li><li><p><strong>RTU</strong></p><p>起始符+<strong>设备地址(1Byte)+功能码(1Byte)+数据(nByte n&lt;253)+校验(2Byte CRC16)</strong>+结束符</p><ul><li>起始符——3.5个字符的时间间隔</li><li>设备地址——0-247</li><li>功能码——见下文</li><li>数据——略</li><li>校验——<strong>起始符 和 校验符</strong>  之间的所有数据        一般用CRC16校验</li><li>结束符——3.5个字符的时间间隔</li></ul></li></ul><h1 id="功能表"><a href="#功能表" class="headerlink" title="功能表"></a>功能表</h1><table><thead><tr><th align="center">功能码</th><th>名称</th><th>作用</th></tr></thead><tbody><tr><td align="center">1</td><td>读取线圈状态</td><td>取得一组逻辑线圈的当前状态（ON&#x2F;OFF)</td></tr><tr><td align="center">2</td><td>读取输入状态</td><td>取得一组开关输入的当前状态（ON&#x2F;OFF)</td></tr><tr><td align="center">3</td><td>读取保持寄存器</td><td>在一个或多个保持寄存器中取得当前的二进制值</td></tr><tr><td align="center">4</td><td>读取输入寄存器</td><td>在一个或多个输入寄存器中取得当前的二进制值</td></tr><tr><td align="center">5</td><td>强置单线圈</td><td>强置一个逻辑线圈的通断状态</td></tr><tr><td align="center">6</td><td>预置单寄存器</td><td>把具体二进值装入一个保持寄存器</td></tr><tr><td align="center">7</td><td>读取异常状态</td><td>取得8个内部线圈的通断状态，这8个线圈的地址由控制器决定</td></tr><tr><td align="center">8</td><td>回送诊断校验</td><td>把诊断校验报文送从机，以对通信处理进行评鉴</td></tr><tr><td align="center">9</td><td>编程（只用于484）</td><td>使主机模拟编程器作用，修改PC从机逻辑</td></tr><tr><td align="center">10</td><td>控询（只用于484）</td><td>可使主机与一台正在执行长程序任务从机通信，探询该从机是否已完成其操作任务，仅在含有功能码9的报文发送后，本功能码才发送</td></tr><tr><td align="center">11</td><td>读取事件计数</td><td>可使主机发出单询问，并随即判定操作是否成功，尤其是该命令或其他应答产生通信错误时</td></tr><tr><td align="center">12</td><td>读取通信事件记录</td><td>可是主机检索每台从机的ModBus事务处理通信事件记录。如果某项事务处理完成，记录会给出有关错误</td></tr><tr><td align="center">13</td><td>编程（184&#x2F;384 484 584）</td><td>可使主机模拟编程器功能修改PC从机逻辑</td></tr><tr><td align="center">14</td><td>探询（184&#x2F;384 484 584）</td><td>可使主机与正在执行任务的从机通信，定期控询该从机是否已完成其程序操作，仅在含有功能13的报文发送后，本功能码才得发送</td></tr><tr><td align="center">15</td><td>强置多线圈</td><td>强置一串连续逻辑线圈的通断</td></tr><tr><td align="center">16</td><td>预置多寄存器</td><td>把具体的二进制值装入一串连续的保持寄存器</td></tr><tr><td align="center">17</td><td>报告从机标识</td><td>可使主机判断编址从机的类型及该从机运行指示灯的状态</td></tr><tr><td align="center">18</td><td>（884和MICRO 84）</td><td>可使主机模拟编程功能，修改PC状态逻辑</td></tr><tr><td align="center">19</td><td>重置通信链路</td><td>发生非可修改错误后，是从机复位于已知状态，可重置顺序字节</td></tr><tr><td align="center">20</td><td>读取通用参数（584L）</td><td>显示扩展存储器文件中的数据信息</td></tr><tr><td align="center">21</td><td>写入通用参数（584L）</td><td>把通用参数写入扩展存储文件，或修改之</td></tr><tr><td align="center">22～64</td><td>保留作扩展功能备用</td><td></td></tr><tr><td align="center">65～72</td><td>保留以备用户功能所用</td><td>留作用户功能的扩展编码</td></tr><tr><td align="center">73～119</td><td>非法功能</td><td></td></tr><tr><td align="center">120～127</td><td>保留</td><td>留作内部作用</td></tr><tr><td align="center">128～255</td><td>保留</td><td>用于异常应答</td></tr></tbody></table><h2 id="0x01-读取线圈状态（数字量）"><a href="#0x01-读取线圈状态（数字量）" class="headerlink" title="0x01 读取线圈状态（数字量）"></a>0x01 读取线圈状态（数字量）</h2><p><strong>0x01号命令，读取一个或多个    可读写数字量寄存器    （读取线圈状态）：</strong></p><table><thead><tr><th>设备地址+功能码</th><th>起始地址高八位+低八位</th><th>读取寄存器数量高八位+低八位</th><th>CRC16</th></tr></thead><tbody><tr><td>0x11+0x01</td><td>0x00+0x13</td><td>0x00+0x25</td><td>高8+低8</td></tr></tbody></table><p><strong>意义如下：</strong></p><ol><li>设备地址与功能码：在一个485总线上可以挂接多个设备，此处的设备地址表示想和哪一个设备通讯。例子中为想和0x11通讯。读取数字量的命令号固定为0x01。</li><li>起始地址高8位、低8位：表示想读取的开关量的起始地址(起始地址为0)。比如例子中的起始地址为0x0013。</li><li>寄存器数高8位、低8位：表示从起始地址开始读多少个开关量。例子中为37(0x0025)个开关量。</li><li>CRC校验：是从开头一直校验到此之前。</li></ol><p><strong>设备响应</strong>：</p><table><thead><tr><th>设备地址+功能码</th><th>返回的字节个数</th><th>返回的数据1+数据2+….+数据n</th><th>CRC16</th></tr></thead><tbody><tr><td>0x11+0x01</td><td>0x05</td><td>0xcd+0x6b+0xb2+0x0e+0x1b</td><td>高8+低8</td></tr></tbody></table><p><strong>意义如下：</strong></p><ol><li><p>设备地址与功能码：上同，0x01。</p></li><li><p>返回的字节个数：表示数据的字节个数，也就是数据的n的值。</p></li><li><p>数据1…n：由于每一个数据是一个8位的数，所以每一个数据表示8个开关量的值，每一位为0表示对应的开关断开，为1表示闭合。</p><p><strong>如果询问的开关量不是8的整倍数，那么最后一个字节的高位部分无意义，置为0。</strong></p></li><li><p>CRC校验同上。</p></li></ol><h2 id="0x05强制单线圈（写一个开关数字量）"><a href="#0x05强制单线圈（写一个开关数字量）" class="headerlink" title="0x05强制单线圈（写一个开关数字量）"></a>0x05强制单线圈（写一个开关数字量）</h2><p><strong>0x05号命令，写一个数字量（强制单线圈） 可广播：</strong></p><table><thead><tr><th>设备地址+功能码</th><th>需操作的寄存器地址高8位+低8位</th><th>需操作的寄存器数据高8位+低8位</th><th>CRC16</th></tr></thead><tbody><tr><td>0x11+0x05</td><td>0x00+0xac</td><td>0xff+0x00</td><td>高8+低8</td></tr></tbody></table><p><strong>意义如下：</strong></p><ol><li><p>设备地址与功能码：上同，0x05。</p></li><li><p>需下置的寄存器地址高8位，低8位：表明了需要置位（操作）的开关的地址。</p></li><li><p>置位（操作）的数据高8位，低8位：表明需要置位的开关量的状态。例子中为把该开关闭合。</p><p><strong>注意，此处只可以是[FF][00]表示ON状态 闭合      [00][00]表示OFF状态 断开，其他数值非法。</strong></p></li><li><p>注意此命令一条只能下置一个开关量的状态。</p></li></ol><p><strong>设备响应：</strong></p><ol><li>如果成功把计算机发送的命令原样返回，否则不响应。</li></ol><h2 id="0x03读取保持寄存器（模拟量）"><a href="#0x03读取保持寄存器（模拟量）" class="headerlink" title="0x03读取保持寄存器（模拟量）"></a>0x03读取保持寄存器（模拟量）</h2><p><strong>0x03号命令，读可读写模拟量寄存器（保持寄存器）：</strong></p><table><thead><tr><th>设备地址+功能码</th><th>起始寄存器地址高8位+低8位</th><th>读取的寄存器数量高8位+低8位</th><th>CRC16</th></tr></thead><tbody><tr><td>0x11+0x03</td><td>0x00+0x6b</td><td>0x00+0x03</td><td>高8+低8</td></tr></tbody></table><p><strong>意义如下：</strong></p><ol><li>设备地址与功能码：上同，0x03。</li><li>起始地址高8位、低8位：表示想读取的模拟量的起始地址(起始地址为0)。比如例子中的起始地址为0x006b。</li><li>寄存器数高8位、低8位：表示从起始地址开始读多少个模拟量。例子中为3个模拟量。注意，在返回的信息中一个模拟量需要返回两个字节。</li></ol><p><strong>设备响应：</strong></p><table><thead><tr><th>设备地址+功能码</th><th>返回的字节个数</th><th>返回的数据1+数据2+….+数据n</th><th>CRC16</th></tr></thead><tbody><tr><td>0x11+0x03</td><td>0x06</td><td>0x02+0x2b+0x00+0x00+0x00+0x64</td><td>高8+低8</td></tr></tbody></table><p><strong>意义如下：</strong></p><ol><li>设备地址与功能码：上同，0x03。</li><li>返回的字节个数：表示数据的字节个数，也就是数据1，2…n中的n的值。例子中返回了3个模拟量的数据，因为一个模拟量需要2个字节所以共6个字节。</li><li>数据1…n：[数据1][数据2]分别是第1个模拟量的高8位和低8位，[数据3][数据4]是第2个模拟量的高8位和低8位，以此类推。例子中返回的值分别是555，0，100。</li></ol><h2 id="0x06预置单寄存器（写一个模拟量）"><a href="#0x06预置单寄存器（写一个模拟量）" class="headerlink" title="0x06预置单寄存器（写一个模拟量）"></a>0x06预置单寄存器（写一个模拟量）</h2><p><strong>0x06号命令，写单个模拟量寄存器（保持寄存器）：</strong></p><table><thead><tr><th>设备地址+功能码</th><th>需操作的寄存器地址高8位+低8位</th><th>需操作的寄存器数据高8位+低8位</th><th>CRC16</th></tr></thead><tbody><tr><td>0x11+0x06</td><td>0x00+0x01</td><td>0x00+0x03</td><td>高8+低8</td></tr></tbody></table><p><strong>意义如下：</strong></p><ol><li>设备地址与功能码：上同，0x06。</li><li>需下置的寄存器地址高8位，低8位：表明了需要下置的模拟量寄存器的地址。</li><li>下置的数据高8位，低8位：表明需要下置的模拟量数据。比如例子中就把1号寄存器的值设为3。</li><li>注意此命令一条只能下置一个模拟量的状态。</li></ol><p><strong>设备响应：</strong></p><p>如果成功把计算机发送的命令原样返回，否则不响应。</p><h2 id="0x16-预置多寄存器（写多个模拟量）"><a href="#0x16-预置多寄存器（写多个模拟量）" class="headerlink" title="0x16 预置多寄存器（写多个模拟量）"></a>0x16 预置多寄存器（写多个模拟量）</h2><p><strong>0x16号命令，写多个模拟量寄存器（保持寄存器）：</strong></p><table><thead><tr><th>设备地址+功能码</th><th>需操作的地址高8位+低8位</th><th>需操作数据的数量高8位+低8位</th><th>操作的数据1 高8位+低8位</th></tr></thead><tbody><tr><td>0x11+0x16</td><td>0x00+0x01</td><td>0x00+0x01</td><td>0x00+0x05</td></tr><tr><td>操作的数据2 高8位+低8位</td><td>………</td><td>操作的数据n 高8位+低8位</td><td>CRC16</td></tr><tr><td></td><td></td><td></td><td>高8+低8</td></tr></tbody></table><p><strong>意义如下：</strong></p><ol><li>设备地址与功能码：上同，0x16。</li><li>需下置的寄存器地址高8位，低8位：表明了需要下置的模拟量寄存器的地址。</li><li>需下置的数据数量高8位，低8位：表明了需要下置的数据数量，这里为1。</li><li>下置的数据高8位，低8位：表明需要下置的模拟量数据。比如例子中就把1号寄存器的值设为5。</li></ol><p><strong>设备响应：</strong></p><p>如果成功把计算机返回的如下命令，否则不响应。</p><table><thead><tr><th>设备地址+功能码</th><th>需操作的寄存器地址高8位+低8位</th><th>需操作的寄存器数量高8位+低8位</th><th>CRC16</th></tr></thead><tbody><tr><td>0x11+0x16</td><td>0x00+0x01</td><td>0x00+0x01</td><td>高8+低8</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Communication</category>
      
    </categories>
    
    
    <tags>
      
      <tag>embedded</tag>
      
      <tag>modbus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UCOS</title>
    <link href="/2020/2ac84091/"/>
    <url>/2020/2ac84091/</url>
    
    <content type="html"><![CDATA[<h2 id="序章"><a href="#序章" class="headerlink" title="序章"></a>序章</h2><h3 id="延时函数"><a href="#延时函数" class="headerlink" title="延时函数"></a>延时函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>  <span class="hljs-title function_">OSTimeDlyHMSM</span> <span class="hljs-params">(CPU_INT16U   hours,</span><br><span class="hljs-params">                     CPU_INT16U   minutes,</span><br><span class="hljs-params">                     CPU_INT16U   seconds,</span><br><span class="hljs-params">                     CPU_INT32U   milli,</span><br><span class="hljs-params">                     OS_OPT       opt,</span><br><span class="hljs-params">                     OS_ERR      *p_err)</span><br><br><span class="hljs-title function_">OSTimeDlyHMSM</span><span class="hljs-params">(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,OS_OPT_TIME_HMSM_STRICT,&amp;err)</span>; <span class="hljs-comment">//延时1s</span><br><span class="hljs-comment">//strick   adj. 严格的；绝对的；精确的；详细的</span><br></code></pre></td></tr></table></figure><h2 id="任务管理"><a href="#任务管理" class="headerlink" title="任务管理"></a>任务管理</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//创建开始任务</span><br>OSTaskCreate((OS_TCB * )&amp;StartTaskTCB,<span class="hljs-comment">//任务控制块</span><br> (CPU_CHAR* )<span class="hljs-string">&quot;start task&quot;</span>, <span class="hljs-comment">//任务名字</span><br>                 (OS_TASK_PTR )start_task, <span class="hljs-comment">//任务函数</span><br>                 (<span class="hljs-type">void</span>* )<span class="hljs-number">0</span>,<span class="hljs-comment">//传递给任务函数的参数</span><br>                 (OS_PRIO  )START_TASK_PRIO,     <span class="hljs-comment">//任务优先级</span><br>                 (CPU_STK   * )&amp;START_TASK_STK[<span class="hljs-number">0</span>],<span class="hljs-comment">//任务堆栈基地址</span><br>                 (CPU_STK_SIZE)START_STK_SIZE/<span class="hljs-number">10</span>,<span class="hljs-comment">//任务堆栈深度限位</span><br>                 (CPU_STK_SIZE)START_STK_SIZE,<span class="hljs-comment">//任务堆栈大小</span><br>                 (OS_MSG_QTY  )<span class="hljs-number">0</span>,<span class="hljs-comment">//任务内部消息队列能够接收的最大消息数目,为0时禁止接收消息</span><br>                 (OS_TICK  )<span class="hljs-number">0</span>,<span class="hljs-comment">//当使能时间片轮转时的时间片长度，为0时为默认长度，</span><br>                 (<span class="hljs-type">void</span>   * )<span class="hljs-number">0</span>,<span class="hljs-comment">//用户补充的存储区</span><br>                 (OS_OPT      )OS_OPT_TASK_STK_CHK|OS_OPT_TASK_STK_CLR, <span class="hljs-comment">//任务选项</span><br>                 (OS_ERR * )&amp;err);<span class="hljs-comment">//存放该函数错误时的返回值</span><br><br><br></code></pre></td></tr></table></figure><ol><li><p><code>(CPU_STK_SIZE)START_STK_SIZE/10,//任务堆栈深度限位</code>    一般设定小于10%即可</p></li><li><p><code>(OS_TCB * )&amp;StartTaskTCB,//任务控制块</code>   <strong>不要访问和更改其中的成员变量</strong></p></li></ol><h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><ul><li><p>数值越小优先级越高</p></li><li><p>os_cfg.h line48   <strong>OS_CFG_PRIO_MAX</strong>  最大优先级数</p></li></ul><h4 id="就绪表"><a href="#就绪表" class="headerlink" title="就绪表"></a>就绪表</h4><ul><li>优先级位映射表**OSPrioTbl[]**：用来记录哪个优先级下有任务就绪</li><li>就绪任务列表**OSRdyList[]**：用来记录每一个优先级下所有就绪的任务</li></ul><h4 id="前导零"><a href="#前导零" class="headerlink" title="前导零"></a>前导零</h4><ul><li>硬件计算  能计算一个值前面有多少零</li></ul><h2 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h2><h4 id="任务调度-1"><a href="#任务调度-1" class="headerlink" title="任务调度"></a>任务调度</h4><ul><li>任务调度器 进入中断   OSIntEnter();  </li><li>任务调度器 退出中断   OSIntExit();</li></ul><h4 id="发生任务调度的调度点"><a href="#发生任务调度的调度点" class="headerlink" title="发生任务调度的调度点"></a>发生任务调度的调度点</h4><ul><li>延时函数OSTimeDly()（按时间延时）或者OSTimeDlyHMSM()（按节拍延时）</li><li>创建、删除任务</li><li>改变优先级</li><li>通过调用OSTaskSuspend()将自身挂起、或解除某个挂起的任务</li><li>OSSched() 用户自行请求调度</li></ul><h4 id="调度器上锁解锁"><a href="#调度器上锁解锁" class="headerlink" title="调度器上锁解锁"></a>调度器上锁解锁</h4><ul><li>OSSchedLock()加锁</li><li>OSSchedUnlock()解锁</li></ul><h4 id="时间片轮转调度"><a href="#时间片轮转调度" class="headerlink" title="时间片轮转调度"></a>时间片轮转调度</h4><ul><li>待补充</li></ul><h2 id="UCOS系统初始化"><a href="#UCOS系统初始化" class="headerlink" title="UCOS系统初始化"></a>UCOS系统初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>   OS_ERR err;<br>   ……<br>   <span class="hljs-comment">//其他函数，一般为外设初始化函数</span><br>   ……<br>   OSInit(&amp;err);<br>   ……<br>   <span class="hljs-comment">//其他函数，一般为创建任务函数</span><br>   ……<br>   OSStart(&amp;err);<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>OSInit()必须先于其他的UCOS函数调用包括OSStart()</li></ul><h2 id="任务创建与管理"><a href="#任务创建与管理" class="headerlink" title="任务创建与管理"></a>任务创建与管理</h2><h4 id="任务的创建"><a href="#任务的创建" class="headerlink" title="任务的创建"></a>任务的创建</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">OSTaskCreate((OS_TCB * )&amp;StartTaskTCB,<span class="hljs-comment">//任务控制块</span><br>             (CPU_CHAR* )<span class="hljs-string">&quot;start task&quot;</span>, <span class="hljs-comment">//任务名字</span><br>             (OS_TASK_PTR )start_task, <span class="hljs-comment">//任务函数</span><br>             (<span class="hljs-type">void</span>* )<span class="hljs-number">0</span>,<span class="hljs-comment">//传递给任务函数的参数</span><br>             (OS_PRIO  )START_TASK_PRIO,     <span class="hljs-comment">//任务优先级</span><br>             (CPU_STK   * )&amp;START_TASK_STK[<span class="hljs-number">0</span>],<span class="hljs-comment">//任务堆栈基地址</span><br>             (CPU_STK_SIZE)START_STK_SIZE/<span class="hljs-number">10</span>,<span class="hljs-comment">//任务堆栈深度限位</span><br>             (CPU_STK_SIZE)START_STK_SIZE,<span class="hljs-comment">//任务堆栈大小</span><br>             (OS_MSG_QTY  )<span class="hljs-number">0</span>,<span class="hljs-comment">//任务内部消息队列能够接收的最大消息数目,为0时禁止接收消息</span><br>             (OS_TICK  )<span class="hljs-number">0</span>,<span class="hljs-comment">//当使能时间片轮转时的时间片长度，为0时为默认长度，</span><br>             (<span class="hljs-type">void</span>   * )<span class="hljs-number">0</span>,<span class="hljs-comment">//用户补充的存储区</span><br>             (OS_OPT      )OS_OPT_TASK_STK_CHK|OS_OPT_TASK_STK_CLR, <span class="hljs-comment">//任务选项</span><br>             (OS_ERR * )&amp;err);<span class="hljs-comment">//存放该函数错误时的返回值</span><br></code></pre></td></tr></table></figure><p>OS_ERR 错误代码</p><h4 id="任务的删除"><a href="#任务的删除" class="headerlink" title="任务的删除"></a>任务的删除</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>  <span class="hljs-title function_">OSTaskDel</span> <span class="hljs-params">(OS_TCB  *p_tcb,</span><br><span class="hljs-params">                 OS_ERR  *p_err)</span>;<br>    <br>OSTaskDel((OS_TCB*)&amp;Task2_TaskTCB,&amp;err);<br></code></pre></td></tr></table></figure><p>不建议在系统运行时删除任务</p><blockquote><p>尽管UCOSIII允许在系统运行中删除任务，但是应该尽量避免这种操作，如果这个任务可能占有与其他任务共享的资源，在删除此任务之前这个被占有的资源没有被释放就有可能导致奇怪的结果。</p></blockquote><h2 id="任务的挂起与恢复"><a href="#任务的挂起与恢复" class="headerlink" title="任务的挂起与恢复"></a>任务的挂起与恢复</h2><h3 id="挂起"><a href="#挂起" class="headerlink" title="挂起"></a>挂起</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>   <span class="hljs-title function_">OSTaskSuspend</span> <span class="hljs-params">(OS_TCB  *p_tcb,</span><br><span class="hljs-params">                      OS_ERR  *p_err)</span>;<br><br>OSTaskSuspend((OS_TCB*)&amp;Task2_TaskTCB,&amp;err);<span class="hljs-comment">//挂起任务2</span><br></code></pre></td></tr></table></figure><p>挂起错误</p><ul><li>任务被加锁</li><li>任务空闲</li></ul><h3 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>  <span class="hljs-title function_">OSTaskResume</span> <span class="hljs-params">(OS_TCB  *p_tcb,</span><br><span class="hljs-params">                    OS_ERR  *p_err)</span><br><br><span class="hljs-title function_">OSTaskResume</span><span class="hljs-params">((OS_TCB*)&amp;Task2_TaskTCB,&amp;err)</span>;<span class="hljs-comment">//恢复任务2</span><br></code></pre></td></tr></table></figure><p>恢复错误</p><ul><li>任务状态无效（错误的状态）、任务不是已经挂起的</li><li>不能恢复自己</li></ul><h2 id="时间片轮转调度-1"><a href="#时间片轮转调度-1" class="headerlink" title="时间片轮转调度"></a>时间片轮转调度</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>  <span class="hljs-title function_">OSSchedRoundRobinCfg</span> <span class="hljs-params">(CPU_BOOLEAN   en,</span><br><span class="hljs-params">                            OS_TICK       dflt_time_quanta,</span><br><span class="hljs-params">                            OS_ERR       *p_err)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span>OS_CFG_SCHED_ROUND_ROBIN_EN  <span class="hljs-comment">//当使用时间片轮转的时候</span></span><br> <span class="hljs-comment">//使能时间片轮转调度功能,时间片长度为1个系统时钟节拍，既1*5=5ms</span><br><span class="hljs-title function_">OSSchedRoundRobinCfg</span><span class="hljs-params">(DEF_ENABLED,<span class="hljs-number">1</span>,&amp;err)</span>;  <br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul><li>设置宏  <strong>OS_CFG_SCHED_ROUND_ROBIN_EN</strong>  为1</li><li>调用函数  <strong>OSSchedRoundRobinCfg()</strong>  开启时间片轮转调度功能</li></ul><h3 id="时间片的放弃"><a href="#时间片的放弃" class="headerlink" title="时间片的放弃"></a>时间片的放弃</h3><p><code>OSSchedRoundRobinYield(&amp;err);</code></p><h3 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h3><p>时间片如果不够执行可能会产生奇怪的效果请注意</p><h2 id="系统内部任务"><a href="#系统内部任务" class="headerlink" title="系统内部任务"></a>系统内部任务</h2><ol><li><p>中断服务管理任务</p></li><li><p>时钟节拍任务</p></li><li><p>定时任务（可选）</p></li><li><p>统计任务（可选）</p></li><li><p>空闲任务</p></li></ol><h3 id="中断服务管理任务"><a href="#中断服务管理任务" class="headerlink" title="中断服务管理任务"></a>中断服务管理任务</h3><ul><li>默认优先级最高，第一，不可更改。</li></ul><h3 id="时钟节拍任务"><a href="#时钟节拍任务" class="headerlink" title="时钟节拍任务"></a>时钟节拍任务</h3><ul><li>优先级较高，第二。</li></ul><h3 id="定时任务（可选）"><a href="#定时任务（可选）" class="headerlink" title="定时任务（可选）"></a>定时任务（可选）</h3><ul><li><p>默认优先级，第三。</p></li><li><p>提供软件定时功能</p></li><li><p>将宏OS_CFG_TMR_EN设置为1就会使能定时任务，在OSInit()中将会调用函数OS_TmrInit()来创建定时任务。</p></li></ul><h3 id="统计任务（可选）"><a href="#统计任务（可选）" class="headerlink" title="统计任务（可选）"></a>统计任务（可选）</h3><ul><li>一般优先级，倒数第二。</li><li>统计CPU使用率，堆栈使用率</li><li>可选创建（将宏<strong>OS_CFG_STAT_TASK_EN</strong>置1）</li><li>必须在main函数创建的以一个任务也是唯一的一个应用任务里面调用函数**OSStatTaskCPUUsageInit()**查询使用情况</li></ul><h3 id="空闲任务"><a href="#空闲任务" class="headerlink" title="空闲任务"></a>空闲任务</h3><ul><li>优先级最低，倒数第一。</li><li>不能调用会使空闲任务进入等待态的函数。</li><li><span style="color:red">可统计CPU使用率</span>（用处）</li></ul><h2 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h2><p>共有8个</p><ol><li>OSIdleTaskHook()，<strong>空闲任务</strong>调用这个函数，可以用来让CPU进入低功耗模式</li><li>OSInitHook()，<strong>系统初始化</strong>函数OSInit()调用此函数</li><li>OSStatTaskHook(), <strong>统计任务每秒</strong>中都会调用这个函数，此函数允许你向统计任务中添加自己的应用函数。</li><li>OSTaskCreateHook(),<strong>任务创建</strong>的钩子函数。</li><li>OSTaskDelHook(),<strong>任务删除</strong>的钩子函数。</li><li>OSTaskReturnHook(),<strong>任务意外返回</strong>时调用的钩子函数，比如删除某个任务</li><li>OSTaskSwHook(),<strong>任务切换</strong>时候调用的钩子函数。</li><li>OSTimeTickHook()，<strong>滴答定时器</strong>调用的钩子函数。</li></ol><h2 id="中断时间管理"><a href="#中断时间管理" class="headerlink" title="中断时间管理"></a>中断时间管理</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">USART1_IRQHandler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>       OSIntEnter();<br>      <span class="hljs-comment">//中断服务程序</span><br>      OSIntExit();<br>&#125;  <br><br><br><br></code></pre></td></tr></table></figure><ul><li>最大250级中断嵌套</li></ul><h2 id="临界区代码保护"><a href="#临界区代码保护" class="headerlink" title="临界区代码保护"></a>临界区代码保护</h2><blockquote><p>临界区：不可被打断的代码段</p></blockquote><p>OS_CFG_ISR_POST_DEFERRED_EN   的值与临界段代码保护方式</p><table><thead><tr><th>0</th><th>关中断</th></tr></thead><tbody><tr><td>1</td><td>调度器上锁（可能会被其它中断打断）</td></tr></tbody></table><ol><li><p>进入临界段</p><ul><li>一个进入函数</li></ul></li><li><p>退出临界段</p><ul><li><p>退出后产生调度——-OS_CRITICAL_EXIT()</p></li><li><p>退出后不产生调度—-OS_CRITICAL_EXIT_NO_SCHED()</p></li><li></li></ul></li></ol><h3 id="CPU-SR-ALLOC"><a href="#CPU-SR-ALLOC" class="headerlink" title="CPU_SR_ALLOC()"></a>CPU_SR_ALLOC()</h3><ol><li>函数CPU_SR_ALLOC()是为CPU_CRITICAL_ENTER()和CPU_CRITICAL_EXIT()申请一个变量：</li></ol><p><code>#define  CPU_SR_ALLOC()           CPU_SR  cpu_sr = (CPU_SR)0</code></p><p>这个是临界代码段，在下面一个小节有详细讲解。</p><ol start="2"><li>这样做是为了防止编译器警告。</li></ol><h2 id="任务延时"><a href="#任务延时" class="headerlink" title="任务延时"></a>任务延时</h2><ul><li>开始延时</li></ul><table><thead><tr><th>OSTimeDly()</th><th>相对延时</th><th>基于时钟节拍</th></tr></thead><tbody><tr><td></td><td>绝对延时</td><td></td></tr><tr><td></td><td>周期延时</td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td>OSTimeDlyHMSM()</td><td>相对延时</td><td>基于时间</td></tr></tbody></table><ul><li><p>取消延时</p><p>延时任务任务可通过在其他任务中调用函数OSTimeDlyResume()取消延时而进入就绪状态，此函数最后会引发一次任务调度。</p></li></ul><h2 id="获取系统时间"><a href="#获取系统时间" class="headerlink" title="获取系统时间"></a>获取系统时间</h2><p>​UCOSIII定义了一个 CPU_INT32U 类型的全局变量 OSTickCtr 来记录系统时钟节拍数，在调用 <strong>OSInit()</strong> 时被初始化为 0，以后每发生1个时钟节拍，OSTickCtr加1。</p><ul><li>OSTimeSet()允许用户改变当前时钟节拍计数器的值</li><li>OSTimeGet()用来获取动迁时钟节拍计数器的值</li></ul><h2 id="软件定时器"><a href="#软件定时器" class="headerlink" title="软件定时器"></a>软件定时器</h2><p>​定时器本质是递减计数器，当计数器减到零时可以执行回调函数。应用程序可以有任意数量的定时器，UCOSIII中定时器的时间分辨率由一个宏 <strong>OS_CFG_TMR_TASK_RATE_HZ</strong> 确定，单位为HZ，默认为100Hz。</p><ul><li>避免在回调函数使用   <strong>阻塞</strong>，<strong>删除</strong>   定时器任务的函数。</li></ul><h3 id="软件定时器的API"><a href="#软件定时器的API" class="headerlink" title="软件定时器的API"></a>软件定时器的API</h3><table><thead><tr><th><strong>OSTmrCreate()</strong></th><th><strong>创建定时器并制定运行模式</strong></th></tr></thead><tbody><tr><td>OSTmrDel()</td><td>删除定时器</td></tr><tr><td>OSTmrRemainGet()</td><td>获取定时器的剩余时间</td></tr><tr><td><strong>OSTmrStart()</strong></td><td><strong>启动定时器计数</strong></td></tr><tr><td>OSTmrStateGet()</td><td>获取当前定时器状态</td></tr><tr><td><strong>OSTmrStop()</strong></td><td><strong>停止计数器倒计时</strong></td></tr></tbody></table><p><strong>OSTmrCreate()有三种模式</strong></p><ul><li>单次模式（通过OSTmrStart()触发）</li><li>周期无延迟模式</li><li>周期有延迟模式</li></ul><h2 id="信号量、互斥信号量、内嵌信号量"><a href="#信号量、互斥信号量、内嵌信号量" class="headerlink" title="信号量、互斥信号量、内嵌信号量"></a>信号量、互斥信号量、内嵌信号量</h2><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量像是一种上锁机制，代码必须获得对应的钥匙才能继续执行，一旦获得了钥匙，也就意味着该任务具有进入被锁部分代码的权限。一旦执行至被锁代码段，则任务一直等待，直到对应被锁部分代码的钥匙被再次释放才能继续执行。</p><ul><li>信号量用于控制对共享资源的保护，但是现在基本用来做任务同步用。</li></ul><h4 id="信号量API"><a href="#信号量API" class="headerlink" title="信号量API"></a>信号量API</h4><table><thead><tr><th>OSSemCreate()</th><th>建立一个信号量</th></tr></thead><tbody><tr><td>OSSemDel()</td><td>删除一个信号量</td></tr><tr><td><strong>OSSemPend()</strong></td><td><strong>等待一个信号量</strong></td></tr><tr><td>OSSemPendAbrot()</td><td>取消等待</td></tr><tr><td><strong>OSSemPost()</strong></td><td><strong>释放或者发出一个信号量</strong></td></tr><tr><td>OSSemSet()</td><td>强制设置一个信号量的值</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>  <span class="hljs-title function_">OSSemCreate</span> <span class="hljs-params">(OS_SEM      *p_sem,<span class="hljs-comment">//OS_SEMMY_SEM;定义一个信号量，用于访问共享资源</span></span><br><span class="hljs-params">                   CPU_CHAR    *p_name,<span class="hljs-comment">//&quot;MY_SEM&quot;名称</span></span><br><span class="hljs-params">                   OS_SEM_CTR   cnt,<span class="hljs-comment">//如果设置成计数型信号量 此处设置成对应数字即可   如果设置成二进制信号量   此处设置成0即可</span></span><br><span class="hljs-params">                   OS_ERR      *p_err)</span><span class="hljs-comment">//</span><br>    <br><span class="hljs-title function_">OSSemCreate</span> <span class="hljs-params">((OS_SEM*)&amp;MY_SEM,</span><br><span class="hljs-params">             (CPU_CHAR*)<span class="hljs-string">&quot;MY_SEM&quot;</span>,</span><br><span class="hljs-params">             (OS_SEM_CTR)<span class="hljs-number">1</span>,</span><br><span class="hljs-params">             (OS_ERR*)&amp;err)</span>;<br></code></pre></td></tr></table></figure><ul><li>OS_SEM_CTR   cnt,<ul><li>如果设置成计数型信号量   此处设置成对应数字即可   </li><li>如果设置成二进制信号量   此处设置成0，指示事件的发生（同步）</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">OS_SEM_CTR  <span class="hljs-title function_">OSSemPend</span> <span class="hljs-params">(OS_SEM   *p_sem,</span><br><span class="hljs-params">                       OS_TICK   timeout,</span><br><span class="hljs-params">                       OS_OPT    opt,</span><br><span class="hljs-params">                       CPU_TS   *p_ts,</span><br><span class="hljs-params">                       OS_ERR   *p_err)</span><br><br><span class="hljs-title function_">OSSemPend</span><span class="hljs-params">(&amp;MY_SEM,<span class="hljs-number">0</span>,OS_OPT_PEND_BLOCKING,<span class="hljs-number">0</span>,&amp;err)</span>; <span class="hljs-comment">//请求信号量</span><br></code></pre></td></tr></table></figure><ul><li>OS_OPT    opt,<ul><li>OS_OPT_PEND_BLOCKING —————-&gt;  阻塞式</li><li>OS_OPT_PEND_NON_BLOCKING ——-&gt; 非阻塞式</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">OS_SEM_CTR  <span class="hljs-title function_">OSSemPost</span> <span class="hljs-params">(OS_SEM  *p_sem,</span><br><span class="hljs-params">                       OS_OPT   opt,</span><br><span class="hljs-params">                       OS_ERR  *p_err)</span><br>    <br><span class="hljs-title function_">OSSemPost</span> <span class="hljs-params">(&amp;MY_SEM,OS_OPT_POST_1,&amp;err)</span>;<span class="hljs-comment">//发送 释放 信号量</span><br></code></pre></td></tr></table></figure><ul><li>OS_OPT    opt，<ul><li>OS_OPT_POST_1 —–&gt;只使能等待信号量的最高优先级任务   (如果任务正在等待)。</li><li>OS_OPT_POST_ALL  ——&gt;发送到所有等待信号量的任务</li><li>OS_OPT_POST_NO_SCHED  ———&gt;不调用调度程序  可以与其他选项之一一起添加。</li></ul></li></ul><h3 id="互斥信号量"><a href="#互斥信号量" class="headerlink" title="互斥信号量"></a>互斥信号量</h3><h4 id="互斥信号量API"><a href="#互斥信号量API" class="headerlink" title="互斥信号量API"></a>互斥信号量API</h4><table><thead><tr><th>OSMutexCreate()</th><th>建立一个互斥信号量</th></tr></thead><tbody><tr><td>OSMutexDel()</td><td>删除一个互斥信号量</td></tr><tr><td><strong>OSMutexPend()</strong></td><td><strong>等待一个互斥信号量</strong></td></tr><tr><td>OSMutexPendAbrot()</td><td>取消等待</td></tr><tr><td><strong>OSMutexPost()</strong></td><td><strong>释放或者发布一个互斥信号量</strong></td></tr></tbody></table><h3 id="内嵌信号量"><a href="#内嵌信号量" class="headerlink" title="内嵌信号量"></a>内嵌信号量</h3><table><thead><tr><th>OSTaskSemPend()</th><th>等待一个任务信号量</th></tr></thead><tbody><tr><td>OSTaskSemPendAbort()</td><td>取消等待任务信号量</td></tr><tr><td><strong>OSTaskSemPost()</strong></td><td><strong>发布任务信号量</strong></td></tr><tr><td>OSTaskSemSet()</td><td>强行设置任务信号量计数</td></tr></tbody></table><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><h3 id="消息队列-1"><a href="#消息队列-1" class="headerlink" title="消息队列"></a>消息队列</h3><table><thead><tr><th><strong>函数名</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><strong>OSQCreate()</strong></td><td><strong>创建一个消息   队列</strong></td></tr><tr><td>OSQDel()</td><td>删除一个消息队列</td></tr><tr><td>OSQFlush()</td><td>清空消息队列</td></tr><tr><td><strong>OSQPend()</strong></td><td><strong>等待消息</strong></td></tr><tr><td>OSQPendAbort()</td><td>取消等待消息</td></tr><tr><td><strong>OSQPost()</strong></td><td><strong>向消息队列发布一则消息</strong></td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>  <span class="hljs-title function_">OSQCreate</span> <span class="hljs-params">(OS_Q        *p_q,</span><br><span class="hljs-params">                 CPU_CHAR    *p_name,</span><br><span class="hljs-params">                 OS_MSG_QTY   max_qty,</span><br><span class="hljs-params">                 OS_ERR      *p_err)</span><br>    <br><span class="hljs-title function_">OSQCreate</span> <span class="hljs-params">((OS_Q*)&amp;KEY_Msg,<span class="hljs-comment">//消息队列</span></span><br><span class="hljs-params">           (CPU_CHAR*)<span class="hljs-string">&quot;KEY Msg&quot;</span>,<span class="hljs-comment">//消息队列名称</span></span><br><span class="hljs-params">           (OS_MSG_QTY)KEYMSG_Q_NUM,<span class="hljs-comment">//消息队列长度，这里设置为1</span></span><br><span class="hljs-params">           (OS_ERR*)&amp;err)</span>;<span class="hljs-comment">//错误码</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//发送消息</span><br>OSQPost((OS_Q*)&amp;DATA_Msg,<br>        (<span class="hljs-type">void</span>*)pbuf,<br>        (OS_MSG_SIZE)<span class="hljs-number">10</span>,<br>        (OS_OPT)OS_OPT_POST_FIFO,<br>        (OS_ERR*)&amp;err);<br><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//请求消息</span><br>p=OSQPend((OS_Q*)&amp;DATA_Msg,   <br>          (OS_TICK)<span class="hljs-number">0</span>,<br>          (OS_OPT)OS_OPT_PEND_BLOCKING,<br>          (OS_MSG_SIZE*)&amp;size,<br>          (CPU_TS*)<span class="hljs-number">0</span>,<br>          (OS_ERR*)&amp;err);<br></code></pre></td></tr></table></figure><h3 id="任务内建消息队列"><a href="#任务内建消息队列" class="headerlink" title="任务内建消息队列"></a>任务内建消息队列</h3><table><thead><tr><th><strong>函数名</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><strong>OSTaskQPend()</strong></td><td><strong>等待消息</strong></td></tr><tr><td>OSTaskQPendAbort()</td><td>取消等待消息</td></tr><tr><td><strong>OSTaskQPost()</strong></td><td><strong>向任务发布一则消息</strong></td></tr><tr><td>OSTaskQFlush()</td><td>清空任务的消息队列</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//创建MSGDIS任务</span><br>OSTaskCreate((OS_TCB * )&amp;Msgdis_TaskTCB,<br>             (CPU_CHAR* )<span class="hljs-string">&quot;Msgdis task&quot;</span>, <br>             (OS_TASK_PTR )msgdis_task, <br>             (<span class="hljs-type">void</span>* )<span class="hljs-number">0</span>,<br>             (OS_PRIO  )MSGDIS_TASK_PRIO,     <br>             (CPU_STK   * )&amp;MSGDIS_TASK_STK[<span class="hljs-number">0</span>],<br>             (CPU_STK_SIZE)MSGDIS_STK_SIZE/<span class="hljs-number">10</span>,<br>             (CPU_STK_SIZE)MSGDIS_STK_SIZE,<br>             (OS_MSG_QTY  )TASK_Q_NUM,<span class="hljs-comment">//任务Msgdis_task需要使用内建消息队列，消息队列长度为4</span><br>             (OS_TICK  )<span class="hljs-number">0</span>,  <br>             (<span class="hljs-type">void</span>   * )<span class="hljs-number">0</span>,<br>             (OS_OPT      )OS_OPT_TASK_STK_CHK|OS_OPT_TASK_STK_CLR,<br>             (OS_ERR * )&amp;err);<br><br></code></pre></td></tr></table></figure><ul><li>注意看 OS_MSG_QTY 正常时其设置为0  使用内建消息队列将之设置成对应的数量即可</li></ul><h2 id="事件标志组"><a href="#事件标志组" class="headerlink" title="事件标志组"></a>事件标志组</h2><p>​       在UCOSIII中事件标志组为OS_FLAG_GRP，如果需要使用事件标志组的时候需要将宏OS_CFG_FLAG_EN置1，</p><table><thead><tr><th><strong>函数名</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><strong>OSFlagCreate()</strong></td><td><strong>创建事件标志组</strong></td></tr><tr><td>OSFlagDel()</td><td>删除事件标志组</td></tr><tr><td><strong>OSFlagPend()</strong></td><td><strong>等待事件标志组</strong></td></tr><tr><td>OSFlagPendAbort()</td><td>取消等待事件标志</td></tr><tr><td>OSFlagPendGetFlagsRdy()</td><td>获取使任务就绪的事件标志</td></tr><tr><td><strong>OSFlagPost()</strong></td><td><strong>向事件标志组发布标志</strong></td></tr></tbody></table><h2 id="同时等待多个内核对象"><a href="#同时等待多个内核对象" class="headerlink" title="同时等待多个内核对象"></a>同时等待多个内核对象</h2><p>​在UCOSIII中允许任务同时等待多个<strong>信号量</strong>和多个<strong>消息队列</strong>，也就是说，UCOSIII不支持同时等待多个事件标志组或互斥信号量。</p><p>​    一个任务可以等待任意数量的信号量和消息队列，第一个信号量或消息队列的发布会导致该任务进入就绪态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">OS_OBJ_QTY  <span class="hljs-title function_">OSPendMulti</span> <span class="hljs-params">(OS_PEND_DATA  *p_pend_data_tbl,</span><br><span class="hljs-params">                         OS_OBJ_QTY     tbl_size,</span><br><span class="hljs-params">                         OS_TICK        timeout,</span><br><span class="hljs-params">                         OS_OPT         opt,</span><br><span class="hljs-params">                         OS_ERR        *p_err)</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">OS_SEMTest_Sem1;<span class="hljs-comment">//信号量1</span><br>OS_SEMTest_Sem2;<span class="hljs-comment">//信号量2</span><br>OS_QTest_Q;<span class="hljs-comment">//消息队列</span><br><br>OS_PEND_DATA pend_multi_tbl[CORE_OBJ_NUM];<br><br>pend_multi_tbl[<span class="hljs-number">0</span>].PendObjPtr=(OS_PEND_OBJ*)&amp;Test_Sem1;<br>pend_multi_tbl[<span class="hljs-number">1</span>].PendObjPtr=(OS_PEND_OBJ*)&amp;Test_Sem2;<br>pend_multi_tbl[<span class="hljs-number">2</span>].PendObjPtr=(OS_PEND_OBJ*)&amp;Test_Q;<br></code></pre></td></tr></table></figure><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2>]]></content>
    
    
    <categories>
      
      <category>RTOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ucos</tag>
      
      <tag>rtos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RTX</title>
    <link href="/2020/2b1e625a/"/>
    <url>/2020/2b1e625a/</url>
    
    <content type="html"><![CDATA[<h1 id="创建一个RTX项目"><a href="#创建一个RTX项目" class="headerlink" title="创建一个RTX项目"></a>创建一个RTX项目</h1><p><strong>Create an RTX5 Project</strong></p><ol><li><p>创建一个新的项目,并选择单片机设备。</p><p>Create a new project and select a microcontroller device.</p></li><li><p>设置 <strong>CMSIS::CORE</strong> 和 <strong>CMSIS::RTOS2 (API)::Keil RTX5</strong>，在下拉框中你可以选择添加RTX库或者添加完整源代码。</p><p>In the Manage Run-Time Environment window, select <strong>CMSIS::CORE</strong> and <strong>CMSIS::RTOS2 (API)::Keil RTX5</strong>. You can choose to either add RTX as a library (Variant: <strong>Library</strong>) or to add the full source code (Variant: <strong>Source</strong> - required if using the <a href="http://www.keil.com/pack/doc/compiler/EventRecorder/html/index.html"><strong>Event Recorder</strong></a>):</p></li><li><p>添加启动文件 <strong>Device::Startup</strong></p></li><li><p>一个示例代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">osKernelInitialize();/ /初始化RTX<br><span class="hljs-title function_">NVIC_SetPriorityGrouping</span> <span class="hljs-params">(<span class="hljs-number">3</span>)</span>;/ /设置优先级分组<br>tread_id =osThreadNew(tread_func,空,空);/ /创建一些线程<br>osKernelStart();/ /开始RTX内核<br></code></pre></td></tr></table></figure><p>注：</p><ol><li><p>添加RTX特定功能的支持</p><p>如果你需要一些的<a href="group__rtx5__specific.html">RTX特定功能</a>在您的应用程序代码中,# include<a href="theory_of_operation.html#rtx_os_h">头文件rtx_os.h</a>。 如使能<a href="theory_of_operation.html#lowPower">低功耗</a>和<a href="theory_of_operation.html#TickLess">tick-less</a>操作模式。</p></li><li><p>添加事件记录器</p><ul><li><p>打开MRTE(Manage Run-Time Environment)窗口</p></li><li><p>确保RTX5使用的是源代码(Source)模式</p></li><li><p>打开 <strong>Compiler::Event Recorder</strong></p></li></ul></li></ol></li></ol><h1 id="中断-Cortex-M"><a href="#中断-Cortex-M" class="headerlink" title="中断 (Cortex-M)"></a>中断 (Cortex-M)</h1><p>Cortex-M处理器,RTX5内核使用以下异常中断。 下面的表格还列出了必须分配给这些中断的优先级。</p><table><thead><tr><th>处理程序</th><th>优先级</th><th>中断&#x2F;异常</th></tr></thead><tbody><tr><td>SysTick</td><td>最低</td><td>内核系统定时器中断产生周期性的计时器滴答声</td></tr><tr><td>PendSV</td><td>最低</td><td>PendSV(系统级服务请求)当调用某些RTX功能<strong>处理程序</strong>模式</td></tr><tr><td>SVC</td><td>最低+ 1</td><td>主管叫用来输入RTOS内核<strong>线程</strong>模式</td></tr></tbody></table><p>可以使用其他设备中断没有限制。 ARM Cortex-M3 &#x2F; M4 &#x2F; M7 &#x2F; M23 &#x2F; M33 &#x2F; M35P处理器,从未被RTX禁用中断内核。</p><p><strong>使用中断的优先级分组</strong></p><ul><li>在调用函数<a href="group__CMSIS__RTOS__KernelCtrl.html#ga9ae2cc00f0d89d7b6a307bba942b5221">osKernelStart（）</a>之前，应使用CMSIS-Core函数NVIC_SetPriorityGrouping配置中断优先级分组。RTX内核使用优先级组值来设置SysTick和PendSV中断的优先级。</li><li>RTX内核为上表中列出的中断&#x2F;异常设置优先级，并使用最低的两个优先级。</li><li>不要更改RTX内核使用的优先级。如果无法避免，请确保SysTick &#x2F; PendSV的抢占优先级低于SVC。</li><li>允许的优先级组值为0到6.优先级组值7将导致RTX失败，因为只有一个可用优先级。</li><li>的<strong>main函数堆叠</strong>被用于运行RTX功能。因此，需要为RTX内核执行配置足够的堆栈。</li></ul>]]></content>
    
    
    <categories>
      
      <category>RTOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rtos</tag>
      
      <tag>rtx</tag>
      
      <tag>keil</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C</title>
    <link href="/2020/3dd7ffa7/"/>
    <url>/2020/3dd7ffa7/</url>
    
    <content type="html"><![CDATA[<h1 id="标准库函数"><a href="#标准库函数" class="headerlink" title="标准库函数"></a>标准库函数</h1><h2 id="fprintf-输出到流中"><a href="#fprintf-输出到流中" class="headerlink" title="fprintf 输出到流中"></a>fprintf 输出到流中</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>C 库函数 <strong>int fprintf(FILE *stream, const char *format, …)</strong> 发送格式化输出到流 stream 中。</p><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>下面是 fprintf() 函数的声明。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fprintf</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span><br></code></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。</li><li><strong>format</strong> – 这是 C 字符串，包含了要被写入到流 stream 中的文本。它可以包含嵌入的 format 标签，format 标签可被随后的附加参数中指定的值替换，并按需求进行格式化。format 标签属性是 <strong>%[flags][width][.precision][length]specifier</strong>，具体讲解如下：</li></ul><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>如果成功，则返回写入的字符总数，否则返回一个负数。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>下面的实例演示了 fprintf() 函数的用法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>   FILE * fp;<br><br>   fp = fopen (<span class="hljs-string">&quot;file.txt&quot;</span>, <span class="hljs-string">&quot;w+&quot;</span>);<br>   <span class="hljs-built_in">fprintf</span>(fp, <span class="hljs-string">&quot;%s %s %s %d&quot;</span>, <span class="hljs-string">&quot;We&quot;</span>, <span class="hljs-string">&quot;are&quot;</span>, <span class="hljs-string">&quot;in&quot;</span>, <span class="hljs-number">2014</span>);<br>   <br>   fclose(fp);<br>   <br>   <span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>让我们编译并运行上面的程序，这将创建文件 <strong>file.txt</strong>，它的内容如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">We</span> are in <span class="hljs-number">2014</span><br></code></pre></td></tr></table></figure><h2 id="atoi-字符串转换成整数"><a href="#atoi-字符串转换成整数" class="headerlink" title="atoi 字符串转换成整数"></a>atoi 字符串转换成整数</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>C 库函数 <strong>int atoi(const char *str)</strong> 把参数 <strong>str</strong> 所指向的字符串转换为一个整数（类型为 int 型）。</p><h3 id="声明-1"><a href="#声明-1" class="headerlink" title="声明"></a>声明</h3><p>下面是 atoi() 函数的声明。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">atoi</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str)</span><br></code></pre></td></tr></table></figure><h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><ul><li><strong>str</strong> – 要转换为整数的字符串。</li></ul><h3 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h3><p>该函数返回转换后的长整数，如果没有执行有效的转换，则返回零。</p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>下面的实例演示了 atoi() 函数的用法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>   <span class="hljs-type">int</span> val;<br>   <span class="hljs-type">char</span> str[<span class="hljs-number">20</span>];<br>   <br>   <span class="hljs-built_in">strcpy</span>(str, <span class="hljs-string">&quot;98993489&quot;</span>);<br>   val = atoi(str);<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;字符串值 = %s, 整型值 = %d\n&quot;</span>, str, val);<br><br>   <span class="hljs-built_in">strcpy</span>(str, <span class="hljs-string">&quot;runoob.com&quot;</span>);<br>   val = atoi(str);<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;字符串值 = %s, 整型值 = %d\n&quot;</span>, str, val);<br><br>   <span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>让我们编译并运行上面的程序，这将产生以下结果：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">字符串值 = <span class="hljs-number">98993489</span>, 整型值 = <span class="hljs-number">98993489</span><br>字符串值 = runoob.com, 整型值 = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">printf</span> <span class="hljs-params">( <span class="hljs-type">const</span> <span class="hljs-type">char</span> * format, ... )</span>;<br></code></pre></td></tr></table></figure><p>将format 指向的 C 字符串写入标准输出 ( stdout )。如果format包含格式说明符（以%开头的子序列），则format后面的附加参数将被格式化并插入到结果字符串中，替换它们各自的说明符。</p><h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">%[flags][width][.precision][length]specifier<br></code></pre></td></tr></table></figure><h4 id="specifier"><a href="#specifier" class="headerlink" title="specifier"></a>specifier</h4><table><thead><tr><th align="left"><em>specifier</em></th><th align="left">Output</th><th align="left">Example</th></tr></thead><tbody><tr><td align="left"><code>d</code> <em>or</em> <code>i</code></td><td align="left">Signed decimal integer(有符号十进制整数)</td><td align="left"><code>392</code></td></tr><tr><td align="left"><code>u</code></td><td align="left">Unsigned decimal integer</td><td align="left"><code>7235</code></td></tr><tr><td align="left"><code>o</code></td><td align="left">Unsigned octal (无符号八进制)</td><td align="left"><code>610</code></td></tr><tr><td align="left"><code>x</code></td><td align="left">Unsigned hexadecimal integer (无符号十六进制整数)</td><td align="left"><code>7fa</code></td></tr><tr><td align="left"><code>X</code></td><td align="left">Unsigned hexadecimal integer (uppercase)</td><td align="left"><code>7FA</code></td></tr><tr><td align="left"><code>f</code></td><td align="left">Decimal floating point, lowercase (十进制浮点数，小写)</td><td align="left"><code>392.65</code></td></tr><tr><td align="left"><code>F</code></td><td align="left">Decimal floating point, uppercase</td><td align="left"><code>392.65</code></td></tr><tr><td align="left"><code>e</code></td><td align="left">Scientific notation (mantissa&#x2F;exponent), lowercase (科学记数法（尾数&#x2F;指数），小写)</td><td align="left"><code>3.9265e+2</code></td></tr><tr><td align="left"><code>E</code></td><td align="left">Scientific notation (mantissa&#x2F;exponent), uppercase</td><td align="left"><code>3.9265E+2</code></td></tr><tr><td align="left"><code>g</code></td><td align="left">Use the shortest representation: <code>%e</code> or <code>%f</code> (使用最短的表示：<code>%e</code>或<code>%f</code>)</td><td align="left"><code>392.65</code></td></tr><tr><td align="left"><code>G</code></td><td align="left">Use the shortest representation: <code>%E</code> or <code>%F</code></td><td align="left"><code>392.65</code></td></tr><tr><td align="left"><code>a</code></td><td align="left">Hexadecimal floating point, lowercase (十六进制浮点数，小写)</td><td align="left"><code>-0xc.90fep-2</code></td></tr><tr><td align="left"><code>A</code></td><td align="left">Hexadecimal floating point, uppercase</td><td align="left"><code>-0XC.90FEP-2</code></td></tr><tr><td align="left"><code>c</code></td><td align="left">Character</td><td align="left"><code>a</code></td></tr><tr><td align="left"><code>s</code></td><td align="left">String of characters</td><td align="left"><code>sample</code></td></tr><tr><td align="left"><code>p</code></td><td align="left">Pointer address</td><td align="left"><code>b8000000</code></td></tr><tr><td align="left"><code>n</code></td><td align="left">Nothing printed. <br/>The corresponding argument must be a pointer to a <code>signed int</code>.<br>The number of characters written so far is stored in the pointed location.</td><td align="left"></td></tr><tr><td align="left"><code>%</code></td><td align="left">A <code>%</code> followed by another <code>%</code> character will write a single <code>%</code> to the stream.</td><td align="left"><code>%</code></td></tr></tbody></table><h4 id="flags"><a href="#flags" class="headerlink" title="flags"></a>flags</h4><p>格式说明符 还可以按顺序包含子说明符：<code>flags</code>、<code>width</code>、<code>.precision</code>和<code>modifiers </code>（这个是什么?），它们是可选的并遵循以下规范：</p><table><thead><tr><th align="left"><em>flags</em></th><th align="left">description</th></tr></thead><tbody><tr><td align="left"><code>-</code></td><td align="left">Left-justify within the given field width; Right justification is the default (see <em>width</em> sub-specifier).<br/>(在给定的字段宽度内左对齐；右对齐是默认设置（请参阅<em>宽度</em>子说明符）。)</td></tr><tr><td align="left"><code>+</code></td><td align="left">Forces to preceed the result with a plus or minus sign (<code>+</code> or <code>-</code>) even for positive numbers. By default, only negative numbers are preceded with a <code>-</code> sign.<br/>(即使对于正数，也强制在结果前面加上加号或减号（<code>+</code>或<code>-</code>)。默认情况下，只有负数前面带有<code>-</code>号。)</td></tr><tr><td align="left"><em>(space)</em></td><td align="left">If no sign is going to be written, a blank space is inserted before the value.<br/>(如果不写入符号，则在值之前插入一个空格。)</td></tr><tr><td align="left"><code>#</code></td><td align="left">Used with <code>o</code>, <code>x</code> or <code>X</code> specifiers the value is preceeded with <code>0</code>, <code>0x</code> or <code>0X</code> respectively for values different than zero. <br/>Used with <code>a</code>, <code>A</code>, <code>e</code>, <code>E</code>, <code>f</code>, <code>F</code>, <code>g</code> or <code>G</code> it forces the written output to contain a decimal point even if no more digits follow. By default, if no digits follow, no decimal point is written.<br/>(与<code>o</code>、<code>x</code>或<code>X</code>说明符一起使用时，该值前面分别带有<code>0</code>、<code>0x</code>或<code>0X</code>，用于表示不同于零的值。<br/>与<code>a</code>、<code>A</code>、<code>e</code>、<code>E</code>、<code>f</code>、<code>F</code>、<code>g</code>或<code>G</code>一起使用，即使后面没有数字，它也会强制书面输出包含小数点。默认情况下，如果后面没有数字，则不写入小数点。)</td></tr><tr><td align="left"><code>0</code></td><td align="left">Left-pads the number with zeroes (<code>0</code>) instead of spaces when padding is specified (see <em>width</em> sub-specifier).<br/>指定填充时，用零（<code>0</code>）而不是空格填充数字（请参阅<em>宽度</em>子说明符）。</td></tr></tbody></table><h4 id="width"><a href="#width" class="headerlink" title="width"></a>width</h4><table><thead><tr><th align="left"><em>width</em></th><th align="left">description</th></tr></thead><tbody><tr><td align="left"><em>(number)</em></td><td align="left">Minimum number of characters to be printed. If the value to be printed is shorter than this number, the result is padded with blank spaces. The value is not truncated even if the result is larger.<br/>(要打印的最小字符数。如果要打印的值比这个数字短，结果用空格填充。即使结果较大，该值也不会被截断。)</td></tr><tr><td align="left"><code>*</code></td><td align="left">The <em>width</em> is not specified in the <em>format</em> string, but as an additional integer value argument preceding the argument that has to be formatted.<br/>(宽度未在格式字符串中指定，而是作为必须格式化的参数之前的附加整数值参数。)</td></tr></tbody></table><h4 id="precision"><a href="#precision" class="headerlink" title=".precision"></a>.precision</h4><table><thead><tr><th align="left"><em>.precision</em></th><th align="left">description</th></tr></thead><tbody><tr><td align="left"><code>.</code><em>number</em></td><td align="left">For integer specifiers (<code>d</code>, <code>i</code>, <code>o</code>, <code>u</code>, <code>x</code>, <code>X</code>): <em>precision</em> specifies the minimum number of digits to be written. If the value to be written is shorter than this number, the result is padded with leading zeros. The value is not truncated even if the result is longer. A <em>precision</em> of <code>0</code> means that no character is written for the value <code>0</code>. For <code>a</code>, <code>A</code>, <code>e</code>, <code>E</code>, <code>f</code> and <code>F</code> specifiers: this is the number of digits to be printed <strong>after</strong> the decimal point (by default, this is 6). For <code>g</code> and <code>G</code> specifiers: This is the maximum number of significant digits to be printed. For <code>s</code>: this is the maximum number of characters to be printed. By default all characters are printed until the ending null character is encountered. If the period is specified without an explicit value for <em>precision</em>, <code>0</code> is assumed.<br/>对于整数说明符（<code>d</code>、<code>i</code>、<code>o</code>、<code>u</code>、<code>x</code>、<code>X</code>）：<em>精度</em>指定要写入的最小位数。如果要写入的值小于此数字，则结果用前导零填充。即使结果更长，该值也不会被截断。<em>精度</em>为<code>0</code>意味着不为值<code>0</code>写入任何字符。<br/>对于<code>a</code>、<code>A</code>、<code>e</code>、<code>E</code>、<code>f</code>和<code>F</code>说明符：这是要打印的位数小数点<strong>后（默认为 6）。</strong><br/>对于<code>g</code>和<code>G</code>说明符：这是要打印的最大有效位数。<br/>对于<code>s</code>：这是要打印的最大字符数。默认情况下，所有字符都会打印，直到遇到结束的空字符。<br/>如果指定了周期而没有明确的<em>精度</em>值，则假定为<code>0 。</code></td></tr><tr><td align="left"><code>.*</code></td><td align="left">The <em>precision</em> is not specified in the <em>format</em> string, but as an additional integer value argument preceding the argument that has to be formatted.<br/><em>精度</em>未在格式字符串中指定，<em>而是</em>作为必须格式化的参数之前的附加整数值参数。</td></tr></tbody></table><p><em>长度</em>子说明符修改数据类型的长度 。这是一个图表，显示了用于解释有和没有<em>长度</em>说明符的相应参数的类型（如果使用不同的类型，则执行适当的类型提升或转换，如果允许）：</p><table><thead><tr><th align="left"></th><th align="left">specifiers</th><th align="left"></th><th align="left"></th><th align="left"></th><th align="left"></th><th align="left"></th><th align="left"></th></tr></thead><tbody><tr><td align="left"><em>length</em></td><td align="left"><code>d i</code></td><td align="left"><code>u o x X</code></td><td align="left"><code>f F e E g G a A</code></td><td align="left"><code>c</code></td><td align="left"><code>s</code></td><td align="left"><code>p</code></td><td align="left"><code>n</code></td></tr><tr><td align="left"><em>(none)</em></td><td align="left"><code>int</code></td><td align="left"><code>unsigned int</code></td><td align="left"><code>double</code></td><td align="left"><code>int</code></td><td align="left"><code>char*</code></td><td align="left"><code>void*</code></td><td align="left"><code>int*</code></td></tr><tr><td align="left"><code>h</code></td><td align="left"><code>short int</code></td><td align="left"><code>unsigned short int</code></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"><code>short int*</code></td></tr><tr><td align="left"><code>l</code></td><td align="left"><code>long int</code></td><td align="left"><code>unsigned long int</code></td><td align="left"></td><td align="left"><code>wint_t</code></td><td align="left"><code>wchar_t*</code></td><td align="left"></td><td align="left"><code>long int*</code></td></tr><tr><td align="left"><code>L</code></td><td align="left"></td><td align="left"></td><td align="left"><code>long double</code></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">↓C99↓</td><td align="left">↓C99↓</td><td align="left">↓C99↓</td><td align="left">↓C99↓</td><td align="left">↓C99↓</td><td align="left">↓C99↓</td><td align="left">↓C99↓</td><td align="left">↓C99↓</td></tr><tr><td align="left"><code>hh</code></td><td align="left"><code>signed char</code></td><td align="left"><code>unsigned char</code></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"><code>signed char*</code></td></tr><tr><td align="left"><code>ll</code></td><td align="left"><code>long long int</code></td><td align="left"><code>unsigned long long int</code></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"><code>long long int*</code></td></tr><tr><td align="left"><code>j</code></td><td align="left"><code>intmax_t</code></td><td align="left"><code>uintmax_t</code></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"><code>intmax_t*</code></td></tr><tr><td align="left"><code>z</code></td><td align="left"><code>size_t</code></td><td align="left"><code>size_t</code></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"><code>size_t*</code></td></tr><tr><td align="left"><code>t</code></td><td align="left"><code>ptrdiff_t</code></td><td align="left"><code>ptrdiff_t</code></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"><code>ptrdiff_t*</code></td></tr></tbody></table><h1 id="杂乱"><a href="#杂乱" class="headerlink" title="杂乱"></a>杂乱</h1><h2 id="stderr-stdout"><a href="#stderr-stdout" class="headerlink" title="stderr stdout"></a>stderr stdout</h2><ul><li><p>stdout – 标准输出设备 stdout。 </p></li><li><p>stderr – 标准错误输出设备</p></li></ul><p>两者默认向屏幕输出。 但如果用转向标准输出到磁盘文件，则可看出两者区别。stdout输出到磁盘文件，stderr在屏幕。 </p><blockquote><p>转向标准输出到磁盘文件tmp.txt<br>my.exe &gt; tmp.txt</p></blockquote><p>在默认情况下，stdout是行缓冲的，他的输出会放在一个buffer里面，只有到换行的时候，才会输出到屏幕。而stderr是无缓冲的，会直接输出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stdout</span>,<span class="hljs-string">&quot;Group&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<span class="hljs-string">&quot;XiyouLinux&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">linux下，第一次会输出XiYouLinuxGroup,是因为stdout将输出的Group放到了缓冲区当中直到程序结束在将缓冲区中的数据刷新出来。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
      <tag>c/c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PyQT</title>
    <link href="/2020/7ecf7a99/"/>
    <url>/2020/7ecf7a99/</url>
    
    <content type="html"><![CDATA[<h1 id="PyQt"><a href="#PyQt" class="headerlink" title="PyQt"></a>PyQt</h1><h2 id="添加图标"><a href="#添加图标" class="headerlink" title="添加图标"></a>添加图标</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WindowGUI</span>(QMainWindow, Ui_MainWindow):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(WindowGUI, self).__init__()<br>        self.setupUi(self)<br>        <span class="hljs-comment">#这里添加了一个图标</span><br>        self.setWindowIcon(QIcon(<span class="hljs-string">&#x27;./Data/SerialBlack.ico&#x27;</span>))<br>        self.pushButton.clicked.connect(self.Butt)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 每一pyqt5应用程序必须创建一个应用程序对象。sys.argv参数是一个列表，从命令行输入参数。</span><br>    app = QApplication(sys.argv)<br>    window = WindowGUI()<br>    window.show()<br>    sys.exit(app.exec_())<br></code></pre></td></tr></table></figure><h2 id="退出确认"><a href="#退出确认" class="headerlink" title="退出确认"></a>退出确认</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WindowGUI</span>(QMainWindow, Ui_MainWindow):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(WindowGUI, self).__init__()<br>        self.setupUi(self)<br>    <span class="hljs-comment">#关闭窗口产生 QCloseEvent</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">closeEvent</span>(<span class="hljs-params">self, event</span>):<br>        reply = QMessageBox.question(self, <span class="hljs-string">&#x27;Message&#x27;</span>,<br>                                     <span class="hljs-string">&quot;Are you sure to quit?&quot;</span>, QMessageBox.Yes |<br>                                     QMessageBox.No, QMessageBox.No)<br>        <span class="hljs-keyword">if</span> reply == QMessageBox.Yes:<br>            event.accept()<br>        <span class="hljs-keyword">else</span>:<br>            event.ignore()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 每一pyqt5应用程序必须创建一个应用程序对象。sys.argv参数是一个列表，从命令行输入参数。</span><br>    app = QApplication(sys.argv)<br>    window = WindowGUI()<br>    window.show()<br>    sys.exit(app.exec_())<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>qt</tag>
      
      <tag>pyqt</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MicroPython</title>
    <link href="/2020/bf76c113/"/>
    <url>/2020/bf76c113/</url>
    
    <content type="html"><![CDATA[<h1 id="MicroPython"><a href="#MicroPython" class="headerlink" title="MicroPython"></a>MicroPython</h1><p><a href="https://www.cirmall.com/articles/301308/p1">简单、方便、快速开发嵌入式实时系统——MicroPytho</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pyb <span class="hljs-keyword">import</span> uart<br><br><span class="hljs-keyword">from</span> pyb <span class="hljs-keyword">import</span> I2C <span class="hljs-comment">#工程师将从pyb库导入I2C</span><br><span class="hljs-comment">#这里的PYB库提供了接入到微控制器外围功能，如SPI，I2C以及UART</span><br><span class="hljs-comment">#在使用任何外设之前，工程师必须实例化外设类以创建可用于控制外设的对象。一旦外设类被初始化，工程师可以执行任何其他操作，例如在进入主应用程序循环之前验证设备是否存在，主要应用程序代码将会每秒采样一次传感器。</span><br><br>GlobalTemp = <span class="hljs-number">0.0</span><br><br>GlobalBarometer = <span class="hljs-number">0.0</span><br><br>＃初始化和实例化I2C外设<span class="hljs-number">2</span><br><br>I2C2 = I2C（<span class="hljs-number">2</span>，I2C.MASTER，波特率= <span class="hljs-number">100000</span>）<br><br>＃配置Uart1进行通信<br><br>Uart1 = pyb.UART（<span class="hljs-number">1</span>,<span class="hljs-number">115200</span>）<br><br>Uart1.init（<span class="hljs-number">115200</span>，bits = <span class="hljs-number">8</span>，parity = <span class="hljs-literal">None</span>，stop = <span class="hljs-number">1</span>）<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br><br>SampleSensor（）<br><br>pyb.delay（<span class="hljs-number">1000</span>）<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">SensorSample</span>（）：<br><br>＃读取温度数据<br><br>TempSample = I2C2.readfrom_mem（<span class="hljs-number">119</span>，<span class="hljs-number">0xFA</span>，<span class="hljs-number">3</span>）<br><br>＃读取压力数据<br><br>PressureSample = I2C2.readfrom_mem（<span class="hljs-number">119</span>，<span class="hljs-number">0xF7</span>,<span class="hljs-number">3</span>）<br><br>将样本数据转换为字符串<br><br>data =“＃，temperature =”<span class="hljs-built_in">str</span>（TempSample）+“，pressure”+ <span class="hljs-built_in">str</span>（PressureSample）+“，＃，\ n \ r”<br><br>＃将数据写入蓝牙<br><br>Uart1.write（data）<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>micropython</tag>
      
      <tag>embedded</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python学习笔记</title>
    <link href="/2020/297a89d9/"/>
    <url>/2020/297a89d9/</url>
    
    <content type="html"><![CDATA[<h1 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h1><p>Python学习笔记</p><h1 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;第一行\n第二行&#x27;</span>)<br><br><br><span class="hljs-built_in">print</span>(a + <span class="hljs-string">&#x27; &#x27;</span> + b + <span class="hljs-string">&#x27; %d %d&#x27;</span>%(c,d))//连字符<br></code></pre></td></tr></table></figure><h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><h3 id="基本格式化"><a href="#基本格式化" class="headerlink" title="基本格式化"></a>基本格式化</h3><p>在Python中，采用的格式化方式和C语言是一致的，用%实现，举例如下</p><ul><li>单个</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;Hello, %s&#x27;</span> % <span class="hljs-string">&#x27;world&#x27;</span><br><span class="hljs-string">&#x27;Hello, world&#x27;</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>k=<span class="hljs-number">2</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;big&#x27;</span>, k)<br><span class="hljs-string">&#x27;big 2&#x27;</span><br></code></pre></td></tr></table></figure><ul><li><p>多个</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;Hi, %s, you have $%d.&#x27;</span> % (<span class="hljs-string">&#x27;Michael&#x27;</span>, <span class="hljs-number">1000000</span>)<br><span class="hljs-string">&#x27;Hi, Michael, you have $1000000.&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>如果你不太确定应该用什么，%s永远起作用，它会把任何数据类型转换为字符串</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;Age: %s. Gender: %s&#x27;</span> % (<span class="hljs-number">25</span>, <span class="hljs-literal">True</span>)<br><span class="hljs-string">&#x27;Age: 25. Gender: True&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="format-格式化"><a href="#format-格式化" class="headerlink" title="format 格式化"></a>format 格式化</h3><p>format()它会用传入的参数依次替换字符串内的占位符{0}、{1}……</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;Hello, &#123;0&#125;, 成绩提升了 &#123;1:.1f&#125;%&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-number">17.125</span>)<br><span class="hljs-string">&#x27;Hello, 小明, 成绩提升了 17.1%&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="字符转义"><a href="#字符转义" class="headerlink" title="字符转义"></a>字符转义</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#如果字符串里面有很多字符都需要转义，就需要加很多\，为了简化，Python还允许用``r&#x27;&#x27;表示&#x27;&#x27;``内部的字符串默认不转义</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\\\t\\&#x27;</span>)<br>\       \<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-string">r&#x27;\\\t\\&#x27;</span>)<br>\\\t\\<br><br><br><span class="hljs-comment">#如果字符串内部有很多换行，用\n写在一行里不好阅读，为了简化，Python允许用&#x27;&#x27;&#x27;...&#x27;&#x27;&#x27;的格式表示多行内容，可以自己试试：</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#x27;&#x27;line1</span><br><span class="hljs-string"><span class="hljs-meta">... </span>line2</span><br><span class="hljs-string"><span class="hljs-meta">... </span>line3&#x27;&#x27;&#x27;</span>)<br>line1<br>line2<br>line3<br></code></pre></td></tr></table></figure><h2 id="显示字符串的前部分长度"><a href="#显示字符串的前部分长度" class="headerlink" title="显示字符串的前部分长度"></a>显示字符串的前部分长度</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(pi_string[:<span class="hljs-number">52</span>] + <span class="hljs-string">&quot;...&quot;</span>)<br><span class="hljs-comment"># 3.14159265358979323846264338327950288419716939937510...</span><br></code></pre></td></tr></table></figure><h1 id="input"><a href="#input" class="headerlink" title="input"></a>input</h1><p>幸好，<code>input()</code>可以让你显示一个字符串来提示用户，于是我们把代码改成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;please enter your name: &#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;hello,&#x27;</span>, name)<br></code></pre></td></tr></table></figure><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 这是一段 行注释</span><br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">这是一段 段注释</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h1 id="数据类型-和-算数运算符"><a href="#数据类型-和-算数运算符" class="headerlink" title="数据类型 和 算数运算符"></a>数据类型 和 算数运算符</h1><p>整数、浮点数、字符串、布尔型（True、False（注意大小写））、空值</p><p>所谓常量就是不能变的变量，比如常用的数学常数π就是一个常量。在Python中，通常用全部大写的变量名表示，但是不能保证其不被改变</p><p>空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">+</td><td align="left">加 - 两个对象相加</td><td align="left">a + b 输出结果 30</td></tr><tr><td align="left">-</td><td align="left">减 - 得到负数或是一个数减去另一个数</td><td align="left">a - b 输出结果 -10</td></tr><tr><td align="left">*</td><td align="left">乘 - 两个数相乘或是返回一个被重复若干次的字符串</td><td align="left">a * b 输出结果 200</td></tr><tr><td align="left">&#x2F;</td><td align="left">除 - x除以y</td><td align="left">b &#x2F; a 输出结果 2</td></tr><tr><td align="left">%</td><td align="left">取模 - 返回除法的余数</td><td align="left">b % a 输出结果 0</td></tr><tr><td align="left">**</td><td align="left">幂 - 返回x的y次幂</td><td align="left">a**b 为10的20次方， 输出结果 100000000000000000000</td></tr><tr><td align="left">&#x2F;&#x2F;</td><td align="left">取整除 - 返回商的整数部分（<strong>向下取整</strong>）</td><td align="left"><code>&gt;&gt;&gt; 9//2 = 4 &gt;&gt;&gt; -9//2 = -5</code></td></tr></tbody></table><p>&#x2F;除法计算结果是浮点数</p><p>&#x2F;&#x2F;称为地板除，两个整数的除法仍然是整数（c整数除法）</p><h1 id="编码（数据转换）"><a href="#编码（数据转换）" class="headerlink" title="编码（数据转换）"></a>编码（数据转换）</h1><p>ord()函数获取字符的整数表示</p><p>&gt;&gt;&gt; ord(‘中’)</p><p>20013</p><p>chr()函数把编码转换为对应的字符</p><p>&gt;&gt;&gt; chr(25991)</p><p>‘文’</p><p>str通过encode()可以编码为bytes</p><p>&gt;&gt;&gt; ‘ABC’.encode(‘ascii’)</p><p>b’ABC’</p><p>&gt;&gt;&gt; ‘中文’.encode(‘utf-8’)</p><p>b’\xe4\xb8\xad\xe6\x96\x87’</p><p>要把bytes变为str，就需要用decode()</p><p>&gt;&gt;&gt; b’ABC’.decode(‘ascii’)</p><p>‘ABC’</p><p>要计算str包含多少个字符，可以用len()函数</p><p>&gt;&gt;&gt; len(‘ABC’)</p><p>3</p><p>&gt;&gt;&gt; len(‘中文’)</p><p>2</p><p>len()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数</p><p>&gt;&gt;&gt; len(b’ABC’)</p><p>3</p><p>&gt;&gt;&gt; len(b’\xe4\xb8\xad\xe6\x96\x87’)</p><p>6</p><p>&gt;&gt;&gt; len(‘中文’.encode(‘utf-8’))</p><p>6</p><hr><p>‘ABC’和b’ABC’，</p><p>前者是str，在内存中以Unicode表示，一个字符对应若干个字节</p><p>后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节</p><h1 id="List列表（类似数组）"><a href="#List列表（类似数组）" class="headerlink" title="List列表（类似数组）"></a>List列表（类似数组）</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">s = [<span class="hljs-number">0</span>]*<span class="hljs-number">10</span><span class="hljs-comment">#10个0</span><br>[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br><br>s = [<span class="hljs-string">&#x27;hello&#x27;</span>]*<span class="hljs-number">3</span>    <span class="hljs-comment">#10个&#x27;hello&#x27;</span><br>[<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-string">&#x27;hello&#x27;</span>]<br><br>s = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>))<span class="hljs-comment">#10个 从0到10</span><br>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]<br><br></code></pre></td></tr></table></figure><hr><p>Python内置的一种数据类型是list。list是一种有序的集合，可以随时添加和删除其中的元素。</p><p>&gt;&gt;&gt; classmates &#x3D; [‘Jack’, 180, 1.69]</p><p>&gt;&gt;&gt; classmates</p><p>[‘Jack’, 180, 1.69]</p><hr><p>如果要取最后一个元素，除了计算索引位置外，还可以用-1做索引，直接获取最后一个元素：</p><p>&gt;&gt;&gt; classmates[-1]</p><p>‘Tracy’</p><hr><p>list是一个可变的有序表，所以，可以往list中追加元素到末尾：</p><p>&gt;&gt;&gt; classmates.append(‘Adam’)</p><p>&gt;&gt;&gt; classmates</p><p>[‘Michael’, ‘Bob’, ‘Tracy’, ‘Adam’]</p><p>也可以把元素插入到指定的位置，比如索引号为1的位置：</p><p>&gt;&gt;&gt; classmates.insert(1, ‘Jack’)</p><p>&gt;&gt;&gt; classmates</p><p>[‘Michael’, ‘Jack’, ‘Bob’, ‘Tracy’, ‘Adam’]</p><p>要删除list末尾的元素，用pop()方法：</p><p>&gt;&gt;&gt; classmates.pop()</p><p>‘Adam’</p><p>&gt;&gt;&gt; classmates</p><p>[‘Michael’, ‘Jack’, ‘Bob’, ‘Tracy’]</p><p>要删除指定位置的元素，用pop(i)方法，其中i是索引位置：</p><p>&gt;&gt;&gt; classmates.pop(1)</p><p>‘Jack’</p><p>&gt;&gt;&gt; classmates</p><p>[‘Michael’, ‘Bob’, ‘Tracy’]</p><hr><p>-———————————————————————————————————————</p><p>list元素也可以是另一个list，比如：</p><p>&gt;&gt;&gt; s &#x3D; [‘python’, ‘java’, [‘asp’, ‘php’], ‘scheme’]</p><p>&gt;&gt;&gt; len(s)</p><p>4</p><p>要注意s只有4个元素，其中s[2]又是一个list，如果拆开写就更容易理解了</p><p>&gt;&gt;&gt; p &#x3D; [‘asp’, ‘php’]</p><p>&gt;&gt;&gt; s &#x3D; [‘python’, ‘java’, p, ‘scheme’]</p><p>要访问’php’可以写p[1]或者s[2][1]，因此s可以看成是一个二维数组</p><h1 id="Tuple元组（静态数组）"><a href="#Tuple元组（静态数组）" class="headerlink" title="Tuple元组（静态数组）"></a>Tuple元组（静态数组）</h1><p>另一种有序列表叫元组：tuple</p><p>。tuple和list非常类似，但是tuple一旦初始化就不能修改</p><p>&gt;&gt;&gt; classmates &#x3D; (‘Michael’, ‘Bob’, ‘Tracy’)</p><p>要定义一个只有1个元素的tuple，如果你这么定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>t = (<span class="hljs-number">1</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>t<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>定义的不是tuple，是<code>1</code>这个数！这是因为括号<code>()</code>既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是<code>1</code>。</p><p>所以，只有1个元素的tuple定义时必须加一个逗号<code>,</code>，来消除歧义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>t = (<span class="hljs-number">1</span>,)<br><span class="hljs-meta">&gt;&gt;&gt; </span>t<br>(<span class="hljs-number">1</span>,)<br></code></pre></td></tr></table></figure><p>Python在显示只有1个元素的tuple时，也会加一个逗号<code>,</code>，以免你误解成数学计算意义上的括号。</p><p>最后来看一个“可变的”tuple：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>t = (<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>])<br><span class="hljs-meta">&gt;&gt;&gt; </span>t[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;X&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>t[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;Y&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>t<br>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, [<span class="hljs-string">&#x27;X&#x27;</span>, <span class="hljs-string">&#x27;Y&#x27;</span>])<br></code></pre></td></tr></table></figure><h2 id="str-replace-替换"><a href="#str-replace-替换" class="headerlink" title="str.replace 替换"></a>str.replace 替换</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>message = <span class="hljs-string">&quot;I really like dogs.&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>message.replace(<span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-string">&#x27;cat&#x27;</span>)<br><span class="hljs-string">&#x27;I really like cats.&#x27;</span><br></code></pre></td></tr></table></figure><h1 id="if-、-for-、-while-、-range"><a href="#if-、-for-、-while-、-range" class="headerlink" title="if 、 for 、 while 、 range"></a>if 、 for 、 while 、 range</h1><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><p><strong>变体</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">ii = <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> ss == <span class="hljs-number">2</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br><br><span class="hljs-comment">#当ss == 2时 ii=1 否则 ii=0</span><br></code></pre></td></tr></table></figure><p>if age &gt;&#x3D; 18:</p><p>​    print(‘adult’)</p><p>else:</p><p>​    print(‘teenager’)</p><p>age &#x3D; 3</p><p>if age &gt;&#x3D; 18:</p><p>​    print(‘adult’)</p><p>elif age &gt;&#x3D; 6:</p><p>​    print(‘teenager’)</p><p>else:</p><p>​    print(‘kid’)</p><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p>所以for x in …循环就是把每个元素代入变量x，然后执行缩进块的语句。</p><p>再比如我们想计算1-10的整数之和，可以用一个sum变量做累加：</p><p>sum &#x3D; 0</p><p>for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]:</p><p>​    sum &#x3D; sum + x</p><p>print(sum)</p><hr><p>sum &#x3D; 0</p><p>for x in  range(101):</p><p>​    sum &#x3D; sum + x</p><p>print(sum)</p><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><p>while循环</p><p>sum &#x3D; 0</p><p>n &#x3D; 99</p><p>while n &gt; 0:</p><p>​    sum &#x3D; sum + n</p><p>​    n &#x3D; n - 2</p><p>print(sum)</p><h2 id="range"><a href="#range" class="headerlink" title="range"></a>range</h2><p>range(start, stop[, step])    可以生成一个整数序列，</p><p>start: 计数从 start 开始。默认是从 0 开始。例如range（5）等价于range（0， 5）;</p><p>stop: 计数到 stop 结束，但不包括 stop。例如：range（0， 5） 是[0, 1, 2, 3, 4]没有5</p><p>step：步长，默认为1。例如：range（0， 5） 等价于 range(0, 5, 1)</p><p>&gt;&gt;&gt; list(range(5))</p><p>[0, 1, 2, 3, 4]</p><p>&gt;&gt;&gt;range(10)        # 从 0 开始到 10</p><p>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</p><p>&gt;&gt;&gt; range(1, 11)     # 从 1 开始到 11</p><p>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</p><p>&gt;&gt;&gt; range(0, 30, 5)  # 步长为 5</p><p>[0, 5, 10, 15, 20, 25]</p><p>&gt;&gt;&gt; range(0, 10, 3)  # 步长为 3</p><p>[0, 3, 6, 9]</p><p>&gt;&gt;&gt; range(0, -10, -1) # 负数</p><p>[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]</p><p>&gt;&gt;&gt; range(0)</p><p>[]</p><p>&gt;&gt;&gt; range(1, 0)</p><p>[]</p><h1 id="Dict（字典）"><a href="#Dict（字典）" class="headerlink" title="Dict（字典）"></a>Dict（字典）</h1><p>Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。</p><p>如果用dict实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用Python写一个dict如下：</p><p>&gt;&gt;&gt; d &#x3D; {‘Michael’: 95, ‘Bob’: 75, ‘Tracy’: 85}</p><p>&gt;&gt;&gt; d[‘Michael’]</p><p>95 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">Kw = &#123;<span class="hljs-string">&#x27;city&#x27;</span>: <span class="hljs-number">22</span>, <span class="hljs-string">&#x27;job&#x27;</span>: <span class="hljs-number">33</span>&#125;: <br><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;city&#x27;</span> <span class="hljs-keyword">in</span> kw:<br><span class="hljs-comment"># 有city参数</span><br>    <span class="hljs-keyword">pass</span><br><br><br>&gt;&gt;&gt;kw.get(<span class="hljs-string">&#x27;city&#x27;</span>)<br><span class="hljs-number">22</span><br>&gt;&gt;&gt;kw.[<span class="hljs-string">&#x27;city&#x27;</span>]<br><span class="hljs-number">22</span><br></code></pre></td></tr></table></figure><h2 id="字典内置函数-amp-方法"><a href="#字典内置函数-amp-方法" class="headerlink" title="字典内置函数&amp;方法"></a>字典内置函数&amp;方法</h2><p>Python字典包含了以下内置函数：</p><table><thead><tr><th align="left">序号</th><th align="left">函数及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-cmp.html">cmp(dict1, dict2)</a> 比较两个字典元素。</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-len.html">len(dict)</a> 计算字典元素个数，即键的总数。</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-str.html">str(dict)</a> 输出字典可打印的字符串表示。</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-type.html">type(variable)</a> 返回输入的变量类型，如果变量是字典就返回字典类型。</td></tr></tbody></table><p>Python字典包含了以下内置方法：</p><table><thead><tr><th align="left">序号</th><th align="left">函数及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-clear.html">dict.clear()</a> 删除字典内所有元素</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-copy.html">dict.copy()</a> 返回一个字典的浅复制</td></tr><tr><td align="left">3</td><td align="left">[dict.fromkeys(seq<a href="https://www.runoob.com/python/att-dictionary-fromkeys.html">, val])</a> 创建一个新字典，以序列 seq 中元素做字典的键，val 为字典所有键对应的初始值</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-get.html">dict.get(key, default&#x3D;None)</a> 返回指定键的值，如果值不在字典中返回default值</td></tr><tr><td align="left">5</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-has_key.html">dict.has_key(key)</a> 如果键在字典dict里返回true，否则返回false</td></tr><tr><td align="left">6</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-items.html">dict.items()</a> 以列表返回可遍历的(键, 值) 元组数组</td></tr><tr><td align="left">7</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-keys.html">dict.keys()</a> 以列表返回一个字典所有的键</td></tr><tr><td align="left">8</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-setdefault.html">dict.setdefault(key, default&#x3D;None)</a> 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default</td></tr><tr><td align="left">9</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-update.html">dict.update(dict2)</a> 把字典dict2的键&#x2F;值对更新到dict里</td></tr><tr><td align="left">10</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-values.html">dict.values()</a> 以列表返回字典中的所有值</td></tr><tr><td align="left">11</td><td align="left">[pop(key<a href="https://www.runoob.com/python/python-att-dictionary-pop.html">,default])</a> 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。</td></tr><tr><td align="left">12</td><td align="left"><a href="https://www.runoob.com/python/python-att-dictionary-popitem.html">popitem()</a> 返回并删除字典中的最后一对键和值。</td></tr></tbody></table><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><h2 id="基本打开输出文件"><a href="#基本打开输出文件" class="headerlink" title="基本打开输出文件"></a>基本打开输出文件</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;pi_digits.txt&#x27;</span>) <span class="hljs-keyword">as</span> file_object:<br>    contents = file_object.read()<br>    <span class="hljs-built_in">print</span>(contents)<br></code></pre></td></tr></table></figure><p>在这个程序中，第1行代码做了大量的工作。我们先来看看函数open() 。要以任何方式使用文件——哪怕仅仅是打印其内容，都得先打开 文件，这样才能访问它。函数open()接受一个参数：要打开的文件的名称。Python在当前执行的文件所在的目录中查找指定的文件。在这个示例中，当前运行的是file_reader.py，因此Python在file_reader.py所在的目录中查找pi_digits.txt。函数open() 返回一个表示文件的对象。在这里，open(‘pi_digits.txt’) 返回一个表示文件pi_digits.txt 的对象；Python将这个对象存储在我们将在后面使用的变量中。</p><p>关键字with 在不再需要访问文件后将其关闭。在这个程序中，注意到我们调用了open() ，但没有调用close() ；你也可以调用open() 和close() 来打开和关闭文件，但这样做时，如果程序存在bug，导致close() 语句未执行，文件将不会关闭。这看似微不足道，但未妥善地关闭文件可能会导致数据丢失或受损。如果在程序中过早地调用close() ，你会发现需要使用文件时它已关闭 （无法访问），这会导致更多的错误。并非在任何情况下都能轻松确定关闭文件的恰当时机，但通过使用前面所示的结构，可让Python去确定：你只管打开文件，并在需要时使用它，Python自会在合适的时候自动将其关闭。</p><h2 id="删除字符串末尾的空白-rstrip"><a href="#删除字符串末尾的空白-rstrip" class="headerlink" title="删除字符串末尾的空白 rstrip"></a>删除字符串末尾的空白 rstrip</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;pi_digits.txt&#x27;</span>) <span class="hljs-keyword">as</span> file_object:<br>    contents = file_object.read()<br>    <span class="hljs-built_in">print</span>(contents.rstrip())<br></code></pre></td></tr></table></figure><p>相比于原始文件，该输出唯一不同的地方是末尾多了一个空行。为何会多出这个空行呢？因为read() 到达文件末尾时返回一个空字符串，而将这个空字符串显示出来时就是一个空行。要删除多出来的空行，可在print 语句中使用rstrip() ：</p><p>每行左边的空格，为删除这些空格，可使用strip() </p><h2 id="逐行读取文件"><a href="#逐行读取文件" class="headerlink" title="逐行读取文件"></a>逐行读取文件</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">filename = <span class="hljs-string">&#x27;pi_digits.txt&#x27;</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename) <span class="hljs-keyword">as</span> file_object:<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> file_object:<br>    <span class="hljs-built_in">print</span>(line.rstrip())<br></code></pre></td></tr></table></figure><h2 id="文件打开模式"><a href="#文件打开模式" class="headerlink" title="文件打开模式"></a>文件打开模式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">filename = <span class="hljs-string">&#x27;programming.txt&#x27;</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> file_object:<br>    file_object.write(<span class="hljs-string">&quot;I love programming.&quot;</span>)<br></code></pre></td></tr></table></figure><p>在这个示例中，调用open() 时提供了两个实参（见❶）。第一个实参也是要打开的文件的名称；第二个实参（’w’ ）告诉Python，我们要以写入模式 打开这个文件。打开文件时，<strong>可指定读取模式 （’r’ ）、写入模式 （’w’ ）、附加模式 （’a’ ）附加到文件末尾、让你能够读取和写入文件的模式（’r+’ ）</strong>。如果你省略了模式实参，Python将以默认的只读模式打开文件。</p><h2 id="异常处理-try-except"><a href="#异常处理-try-except" class="headerlink" title="异常处理 try-except"></a>异常处理 try-except</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">filename = <span class="hljs-string">&#x27;alice.txt&#x27;</span><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename) <span class="hljs-keyword">as</span> f_obj:<br>    contents = f_obj.read()<br><span class="hljs-keyword">except</span> FileNotFoundError:<br>    msg = <span class="hljs-string">&quot;Sorry, the file &quot;</span> + filename + <span class="hljs-string">&quot; does not exist.&quot;</span><br><span class="hljs-built_in">print</span>(msg)<br></code></pre></td></tr></table></figure><p>在这个示例中，try 代码块引发FileNotFoundError 异常，因此Python找出与该错误匹配的except 代码块，并运行其中的代码。最终的结果是显示一条友好的错误消息，而不是traceback：</p><h1 id="一些方法"><a href="#一些方法" class="headerlink" title="一些方法"></a>一些方法</h1><h2 id="count"><a href="#count" class="headerlink" title=".count()"></a>.count()</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>Python count() 方法用于统计字符串里某个字符出现的次数。可选参数为在字符串搜索的开始与结束位置。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>count()方法语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span>.count(sub, start= <span class="hljs-number">0</span>,end=<span class="hljs-built_in">len</span>(string))<br></code></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li>sub – 搜索的子字符串</li><li>start – 字符串开始搜索的位置。默认为第一个字符,第一个字符索引值为0。</li><li>end – 字符串中结束搜索的位置。字符中第一个字符的索引为 0。默认为字符串的最后一个位置。</li></ul><h2 id="to-bytes"><a href="#to-bytes" class="headerlink" title=".to_bytes()"></a>.to_bytes()</h2><p>(0x12).to_bytes(10, byteorder&#x3D; ‘big’, signed &#x3D; ‘true’)</p><ul><li><p>10：表示转换后的数据占10个字节</p></li><li><p>byteorder：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;(<span class="hljs-number">0x12</span>).to_bytes(<span class="hljs-number">10</span>, byteorder = <span class="hljs-string">&#x27;big&#x27;</span>)<br><br><span class="hljs-comment">#b&#x27;\xf8\x12\x00\x00&#x27;</span><br><br>&gt;&gt;&gt;(<span class="hljs-number">0x12</span>).to_bytes(<span class="hljs-number">10</span>, byteorder = <span class="hljs-string">&#x27;little&#x27;</span>)<br><br><span class="hljs-comment">#b&#x27;\x00\x00\x12\xf8&#x27;</span><br></code></pre></td></tr></table></figure><ul><li>signed： 表示有符号和无符号</li></ul><h2 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h2><p>函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：(类似于指针？？？？准确描述应该是类似 tpyedef )</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-built_in">abs</span> <span class="hljs-comment"># 变量a指向abs函数</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a(-<span class="hljs-number">1</span>) <span class="hljs-comment"># 所以也可以通过a调用abs函数1</span><br></code></pre></td></tr></table></figure><h2 id="abs-绝对值"><a href="#abs-绝对值" class="headerlink" title="abs 绝对值"></a>abs 绝对值</h2><p>abs( x )函数 取绝对值</p><p>x – 数值表达式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">abs</span>(<span class="hljs-number">100</span>)<span class="hljs-number">100</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">abs</span>(-<span class="hljs-number">20</span>)<span class="hljs-number">20</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">abs</span>(<span class="hljs-number">12.34</span>)<span class="hljs-number">12.34</span><br></code></pre></td></tr></table></figure><h2 id="max-找平均值"><a href="#max-找平均值" class="headerlink" title="max 找平均值"></a>max 找平均值</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><br>list1 = [<span class="hljs-number">123</span>, <span class="hljs-number">568</span>, <span class="hljs-number">423</span>, <span class="hljs-number">365</span>]<br><br><span class="hljs-built_in">print</span>( np.mean(list1) )<br></code></pre></td></tr></table></figure><h2 id="max-找最大-x2F-小值"><a href="#max-找最大-x2F-小值" class="headerlink" title="max 找最大&#x2F;小值"></a>max 找最大&#x2F;小值</h2><p>max( x, y, z, …. )  可以接收任意多个参数，并返回最大的那个（可以传入list）：</p><p>x – 数值表达式。y – 数值表达式。z – 数值表达式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><span class="hljs-number">2</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">max</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">5</span>)<br><span class="hljs-number">3</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>list1 = [<span class="hljs-number">123</span>, <span class="hljs-number">568</span>, <span class="hljs-number">423</span>, <span class="hljs-number">365</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Max value element : &quot;</span>, <span class="hljs-built_in">max</span>(list1))<br>Max value element :  <span class="hljs-number">568</span><br></code></pre></td></tr></table></figure><h2 id="exal-执行字符串类型的表达式"><a href="#exal-执行字符串类型的表达式" class="headerlink" title="exal 执行字符串类型的表达式"></a>exal 执行字符串类型的表达式</h2><p>eval(expression[, globals[, locals]])函数   函数用来执行一个字符串表达式，并返回表达式的值。</p><p>expression – 表达式。</p><p>globals – 变量作用域，全局命名空间，如果被提供，则必须是一个字典对象。</p><p>locals – 变量作用域，局部命名空间，如果被提供，可以是任何映射对象。</p><p>&gt;&gt;&gt;x &#x3D; 7</p><p>&gt;&gt;&gt; eval( ‘3 * x’ )</p><p>21</p><p>&gt;&gt;&gt; eval(‘pow(2,2)’)</p><p>4</p><p>a&#x3D;eval(input(“请输入一个整数”))           #（自动类型转换）</p><h2 id="int-强制转换"><a href="#int-强制转换" class="headerlink" title="int 强制转换"></a>int 强制转换</h2><p>class int(x, base&#x3D;10)    强制转换返回整型数据。</p><p>x – 字符串或数字。base – 进制数，默认十进制。</p><p>&gt;&gt;&gt; int(‘0xa’,16)  </p><p>10  </p><p>&gt;&gt;&gt; int(‘10’,8)  </p><p>8</p><p>a&#x3D;int(input(“请输入一个整数”))             #（强制类型转换）</p><h2 id="type-判断对象类型"><a href="#type-判断对象类型" class="headerlink" title="type 判断对象类型"></a>type 判断对象类型</h2><p>首先，我们来判断对象类型，使用<code>type()</code>函数：</p><p>基本类型都可以用<code>type()</code>判断：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haskell">&gt;&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">type</span>(123)</span><br>&lt;<span class="hljs-keyword">class</span> &#x27;int&#x27;&gt;<br>&gt;&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">type</span>(&#x27;<span class="hljs-title">str&#x27;</span>)</span><br>&lt;<span class="hljs-keyword">class</span> &#x27;str&#x27;&gt;<br>&gt;&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">type</span>(<span class="hljs-type">None</span>)</span><br>&lt;<span class="hljs-class"><span class="hljs-keyword">type</span>(<span class="hljs-type">None</span>) &#x27;<span class="hljs-type">NoneType&#x27;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果一个变量指向函数或者类，也可以用<code>type()</code>判断：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(<span class="hljs-built_in">abs</span>)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;builtin_function_or_method&#x27;</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(a)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.Animal&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>但是<code>type()</code>函数返回的是什么类型呢？它返回对应的Class类型。如果我们要在<code>if</code>语句中判断，就需要比较两个变量的type类型是否相同：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">type</span>(<span class="hljs-number">123</span>)==<span class="hljs-built_in">type</span>(<span class="hljs-number">456</span>)</span><br>True<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">type</span>(<span class="hljs-number">123</span>)==<span class="hljs-built_in">int</span></span><br>True<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">type</span>(<span class="hljs-string">&#x27;abc&#x27;</span>)==<span class="hljs-built_in">type</span>(<span class="hljs-string">&#x27;123&#x27;</span>)</span><br>True<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">type</span>(<span class="hljs-string">&#x27;abc&#x27;</span>)==<span class="hljs-built_in">str</span></span><br>True<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">type</span>(<span class="hljs-string">&#x27;abc&#x27;</span>)==<span class="hljs-built_in">type</span>(<span class="hljs-number">123</span>)</span><br>False<br></code></pre></td></tr></table></figure><p>判断基本数据类型可以直接写<code>int</code>，<code>str</code>等，但如果要判断一个对象是否是函数怎么办？可以使用<code>types</code>模块中定义的常量：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">import</span> types</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fn</span>():</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    <span class="hljs-keyword">pass</span></span><br><span class="hljs-meta prompt_">...</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">type</span>(fn)==types.FunctionType</span><br>True<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">type</span>(<span class="hljs-built_in">abs</span>)==types.BuiltinFunctionType</span><br>True<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">type</span>(<span class="hljs-keyword">lambda</span> x: x)==types.LambdaType</span><br>True<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">type</span>((x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)))==types.GeneratorType</span><br>True<br></code></pre></td></tr></table></figure><h2 id="isinstance-判断类型是否相同"><a href="#isinstance-判断类型是否相同" class="headerlink" title="isinstance 判断类型是否相同"></a>isinstance 判断类型是否相同</h2><p>isinstance(object, classinfo)     如果对象的类型与参数二的类型（classinfo）相同则返回 True，否则返回 False</p><p>object – 实例对象。</p><p>classinfo – 可以是直接或间接类名、基本类型或者由它们组成的元组。</p><p>能用<code>type()</code>判断的基本类型也可以用<code>isinstance()</code>判断：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-built_in">str</span>)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(<span class="hljs-number">123</span>, <span class="hljs-built_in">int</span>)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(<span class="hljs-string">b&#x27;a&#x27;</span>, <span class="hljs-built_in">bytes</span>)<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>并且还可以判断一个变量是否是某些类型中的一种，比如下面的代码就可以判断是否是list或者tuple：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], (<span class="hljs-built_in">list</span>, <span class="hljs-built_in">tuple</span>))<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>), (<span class="hljs-built_in">list</span>, <span class="hljs-built_in">tuple</span>))<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#判断传入的参数是否正确</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(x, (<span class="hljs-built_in">int</span>, <span class="hljs-built_in">float</span>)):<br>        <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&#x27;bad operand type&#x27;</span>)<br></code></pre></td></tr></table></figure><p>isinstance() 与 type() 区别：</p><p>type() 不会认为子类是一种父类类型，不考虑继承关系。</p><p>isinstance() 会认为子类是一种父类类型，考虑继承关系。</p><p>如果要判断两个类型是否相同推荐使用 isinstance()。</p><h2 id="dir-获得对象的所有属性和方法"><a href="#dir-获得对象的所有属性和方法" class="headerlink" title="dir 获得对象的所有属性和方法"></a>dir 获得对象的所有属性和方法</h2><p>如果要获得一个对象的所有属性和方法，可以使用<code>dir()</code>函数，它返回一个包含字符串的list，比如，获得一个str对象的所有属性和方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">dir</span>(<span class="hljs-string">&#x27;ABC&#x27;</span>)<br>[<span class="hljs-string">&#x27;__add__&#x27;</span>, <span class="hljs-string">&#x27;__class__&#x27;</span>,..., <span class="hljs-string">&#x27;__subclasshook__&#x27;</span>, <span class="hljs-string">&#x27;capitalize&#x27;</span>, <span class="hljs-string">&#x27;casefold&#x27;</span>,..., <span class="hljs-string">&#x27;zfill&#x27;</span>]<br></code></pre></td></tr></table></figure><p>类似<code>__xxx__</code>的属性和方法在Python中都是有特殊用途的，比如<code>__len__</code>方法返回长度。在Python中，如果你调用<code>len()</code>函数试图获取一个对象的长度，实际上，在<code>len()</code>函数内部，它自动去调用该对象的<code>__len__()</code>方法，所以，下面的代码是等价的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">len</span>(<span class="hljs-string">&#x27;ABC&#x27;</span>)<br><span class="hljs-number">3</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;ABC&#x27;</span>.__len__()<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h2 id="二次三次方根"><a href="#二次三次方根" class="headerlink" title="二次三次方根"></a>二次三次方根</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">9</span>*<span class="hljs-number">9</span><br>== <span class="hljs-number">9</span>**<span class="hljs-number">2</span><br><br><span class="hljs-number">9</span>*<span class="hljs-number">9</span>*<span class="hljs-number">9</span><br>== <span class="hljs-number">9</span>**<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h1 id="math模块的一些方法"><a href="#math模块的一些方法" class="headerlink" title="math模块的一些方法"></a>math模块的一些方法</h1><h2 id="math-modf-分离小数和整数部分"><a href="#math-modf-分离小数和整数部分" class="headerlink" title="math.modf(分离小数和整数部分)"></a>math.modf(分离小数和整数部分)</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>modf() 方法返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>以下展示了使用 modf() 方法的实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math   <span class="hljs-comment"># This will import math module</span><br><br><span class="hljs-built_in">print</span>( math.modf(-<span class="hljs-number">100.12</span>) )<br><span class="hljs-built_in">print</span>( math.modf(-<span class="hljs-number">100.12</span>)[<span class="hljs-number">0</span>] )<br></code></pre></td></tr></table></figure><p>以上实例运行后输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">(-<span class="hljs-number">0.12000000000000455</span>, -<span class="hljs-number">100.0</span>)<br>-<span class="hljs-number">0.12000000000000455</span><br></code></pre></td></tr></table></figure><h1 id="用户自定义函数"><a href="#用户自定义函数" class="headerlink" title="用户自定义函数"></a>用户自定义函数</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_abs</span>(<span class="hljs-params">x</span>):<br><br>   <span class="hljs-keyword">if</span> x &gt;= <span class="hljs-number">0</span>:<br><br>      <span class="hljs-keyword">return</span> x<br><br>   <span class="hljs-keyword">else</span>:<br><br>       <span class="hljs-keyword">return</span> -x<br></code></pre></td></tr></table></figure><p>（导入其他文件内的函数的方法）如果你已经把<code>my_abs()</code>的函数定义保存为<code>abs.py</code>文件了，那么，可以在该文件的当前目录下启动Python解释器，用<code>from abs import my_abs</code>来导入<code>my_abs()</code>函数，注意<code>abs</code>是文件名（不含<code>.py</code>扩展名）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> <span class="hljs-built_in">abs</span> <span class="hljs-keyword">import</span> my_abs<br><span class="hljs-meta">&gt;&gt;&gt; </span>my_abs(-<span class="hljs-number">9</span>) <br><span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><h2 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#pass语句，实际上pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来。但是缺少了pass，代码运行就会有语法错误。</span><br><span class="hljs-keyword">if</span> age &gt;= <span class="hljs-number">18</span>:<br><span class="hljs-keyword">pass</span><br> <br>函数返回多个值<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_two</span>(<span class="hljs-params">x, y</span>):<br>    x = x + <span class="hljs-number">1</span><br>    y = y + <span class="hljs-number">2</span><br><span class="hljs-keyword">return</span> x, y<br> <br><span class="hljs-meta">&gt;&gt;&gt; </span>x = y = <span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>x, y = add_two(x,y)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(x, y)<br><span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>r = add_two(x,y)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(r)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>其实返回值是一个tuple(静态数组)！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。</p><p>函数的传入参数<br>函数传入list要特别小心，函数内的修改会影响其本身，类似C中的指针对list产生了修改。<br>关键字传值(带**的传值)传入的是值，不会影响原来的内容。</p><h2 id="函数的输入"><a href="#函数的输入" class="headerlink" title="函数的输入"></a>函数的输入</h2><h3 id="函数的默认参数"><a href="#函数的默认参数" class="headerlink" title="函数的默认参数"></a>函数的默认参数</h3><p>默认参数。由于我们经常计算x2，所以，完全可以把第二个参数n的默认值设定为2：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">power</span>(<span class="hljs-params">x, n=<span class="hljs-number">2</span></span>):<br>    s = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> n &gt; <span class="hljs-number">0</span>:<br>        n = n - <span class="hljs-number">1</span><br>        s = s * x<br>    <span class="hljs-keyword">return</span> s<br></code></pre></td></tr></table></figure><p>调用时可以 power(5) 直接计算5的2次方，也可以power(5,3)计算5的3次方。即默认参数可以传入也可以不传入。<br>定义默认参数要牢记一点：默认参数必须指向不变对象！</p><p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431752945034eb82ac80a3e64b9bb4929b16eeed1eb9000">具体可以点击此处参考</a></p><h3 id="输入可变长变量"><a href="#输入可变长变量" class="headerlink" title="输入可变长变量"></a>输入可变长变量</h3><p>可变长度的传入变量，加了星号（*）的变量名会存放所有未命名的变量参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">printinfo</span>(<span class="hljs-params"> *vartuple </span>):<br>   <span class="hljs-string">&quot;打印任何传入的参数&quot;</span><br>   <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;输出: &quot;</span><br>   <span class="hljs-keyword">for</span> var <span class="hljs-keyword">in</span> vartuple:<br>      <span class="hljs-built_in">print</span> var<br>   <span class="hljs-keyword">return</span>;<br><br> <br><span class="hljs-comment"># 调用printinfo 函数</span><br>printinfo( <span class="hljs-number">10</span> );<br>printinfo( <span class="hljs-number">70</span>, <span class="hljs-number">60</span>, <span class="hljs-number">50</span> );<br></code></pre></td></tr></table></figure><h3 id="关键字参数（字典-dict-参数）"><a href="#关键字参数（字典-dict-参数）" class="headerlink" title="关键字参数（字典(dict)参数）"></a>关键字参数（字典(dict)参数）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">person</span>(<span class="hljs-params">name, age, **kw</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;name:&#x27;</span>, name, <span class="hljs-string">&#x27;age:&#x27;</span>, age, <span class="hljs-string">&#x27;other:&#x27;</span>, kw)<br> <br><span class="hljs-meta">&gt;&gt;&gt; </span>person(<span class="hljs-string">&#x27;Michael&#x27;</span>, <span class="hljs-number">30</span>)<br>name: Michael age: <span class="hljs-number">30</span> other: &#123;&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>person(<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-number">35</span>, city=<span class="hljs-string">&#x27;Beijing&#x27;</span>)<br>name: Bob age: <span class="hljs-number">35</span> other: &#123;<span class="hljs-string">&#x27;city&#x27;</span>: <span class="hljs-string">&#x27;Beijing&#x27;</span>&#125;<br><span class="hljs-comment">#如果函数内使用了某个关键字参数，但调用时没有传入，代码会有异常</span><br><span class="hljs-comment">#如果要限制只能传指定名字的参数，则可以使用命名关键字参数</span><br></code></pre></td></tr></table></figure><h3 id="命名关键词参数"><a href="#命名关键词参数" class="headerlink" title="命名关键词参数"></a>命名关键词参数</h3> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#命名关键字参数，是对关键字参数方式的进一步约束，更安全了</span><br><span class="hljs-comment">#定义需要一个*号作为分隔符，*后面的参数表示只能传递该名字的参数</span><br><span class="hljs-comment">#如下表示两个位置参数，还有两个名为city和job的关键字参数，调用时传其它名字会报错</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">person</span>(<span class="hljs-params">name, age, *, city, job</span>):<br>    <span class="hljs-built_in">print</span>(name, age, city, job)<br></code></pre></td></tr></table></figure><p>和关键字参数<code>**kw</code>不同，命名关键字参数需要一个特殊分隔符<code>*</code>，<code>*</code>后面的参数被视为命名关键字参数。</p><p>调用方式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>person(<span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-number">24</span>, city=<span class="hljs-string">&#x27;Beijing&#x27;</span>, job=<span class="hljs-string">&#x27;Engineer&#x27;</span>)<br>Jack <span class="hljs-number">24</span> Beijing Engineer<br></code></pre></td></tr></table></figure><p>添加缺省值，从而简化调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">person</span>(<span class="hljs-params">name, age, *, city=<span class="hljs-string">&#x27;Beijing&#x27;</span>, job</span>):<br>    <span class="hljs-built_in">print</span>(name, age, city, job)<br></code></pre></td></tr></table></figure><p>由于命名关键字参数<code>city</code>具有默认值，调用时，可不传入<code>city</code>参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>person(<span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-number">24</span>, job=<span class="hljs-string">&#x27;Engineer&#x27;</span>)<br>Jack <span class="hljs-number">24</span> Beijing Engineer<br></code></pre></td></tr></table></figure><h1 id="匿名函数lambda"><a href="#匿名函数lambda" class="headerlink" title="匿名函数lambda"></a>匿名函数lambda</h1><p>python 使用 lambda 来创建匿名函数。</p><ul><li>lambda只是一个表达式，函数体比def简单很多。</li><li>lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。</li><li>lambda函数拥有自己的命名空间，且不能访问自有参数列表之外或全局命名空间里的参数。</li><li>虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。</li></ul><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p>lambda函数的语法只包含一个语句，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">lambda</span> [arg1 [,arg2,.....argn]]:expression<br></code></pre></td></tr></table></figure><p>如下实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 可写函数说明</span><br><span class="hljs-built_in">sum</span> = <span class="hljs-keyword">lambda</span> arg1, arg2: arg1 + arg2;<br> <br><span class="hljs-comment"># 调用sum函数</span><br><span class="hljs-built_in">print</span>( <span class="hljs-string">&quot;相加后的值为 : &quot;</span>, <span class="hljs-built_in">sum</span>( <span class="hljs-number">10</span>, <span class="hljs-number">20</span> ))<br><span class="hljs-built_in">print</span>( <span class="hljs-string">&quot;相加后的值为 : &quot;</span>, <span class="hljs-built_in">sum</span>( <span class="hljs-number">20</span>, <span class="hljs-number">20</span> ))<br></code></pre></td></tr></table></figure><h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><h2 id="面向过程-和-面向对象的对比"><a href="#面向过程-和-面向对象的对比" class="headerlink" title="面向过程 和 面向对象的对比"></a>面向过程 和 面向对象的对比</h2><p>Q：存储学生的信息并打印出来</p><p><strong>面向过程</strong></p><p> 假设我们要处理学生的成绩表，为了表示一个学生的成绩，面向过程的程序可以用一个dict表示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">std1 = &#123; <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Michael&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">98</span> &#125;<br>std2 = &#123; <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">81</span> &#125;<br></code></pre></td></tr></table></figure><p>而处理学生成绩可以通过函数实现，比如打印学生的成绩：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_score</span>(<span class="hljs-params">std</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%s: %s&#x27;</span> % (std[<span class="hljs-string">&#x27;name&#x27;</span>], std[<span class="hljs-string">&#x27;score&#x27;</span>]))<br></code></pre></td></tr></table></figure><p><strong>面向对象</strong></p><p>如果采用面向对象的程序设计思想，我们首选思考的不是程序的执行流程，而是<code>Student</code>这种数据类型应该被视为一个对象，这个对象拥有<code>name</code>和<code>score</code>这两个属性（Property）。如果要打印一个学生的成绩，首先必须创建出这个学生对应的对象，然后，给对象发一个<code>print_score</code>消息，让对象自己把自己的数据打印出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, score</span>):<br>        self.name = name<br>        self.score = score<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">print_score</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%s: %s&#x27;</span> % (self.name, self.score))<br></code></pre></td></tr></table></figure><p>给对象发消息实际上就是调用对象对应的关联函数，我们称之为对象的方法（Method）。面向对象的程序写出来就像这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">bart = Student(<span class="hljs-string">&#x27;Bart Simpson&#x27;</span>, <span class="hljs-number">59</span>)<br>lisa = Student(<span class="hljs-string">&#x27;Lisa Simpson&#x27;</span>, <span class="hljs-number">87</span>)<br>bart.print_score()<br>lisa.print_score()<br></code></pre></td></tr></table></figure><h2 id="类、实例、方法和属性"><a href="#类、实例、方法和属性" class="headerlink" title="类、实例、方法和属性"></a>类、实例、方法和属性</h2><ul><li>类 Student</li><li>实例 jack</li><li>方法 print_score</li><li>属性 obj_name</li><li>增加属性 gender</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>): <span class="hljs-comment">#Student是类</span><br>    obj_name = <span class="hljs-string">&#x27;this is obj name str！&#x27;</span><span class="hljs-comment">#这个类有一个属性（类属性）</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, score</span>):  <span class="hljs-comment">#特殊方法“__init__”前后分别有两个下划线！！！</span><br>        self.name = name<br>        self.score = score<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">print_score</span>(<span class="hljs-params">self</span>):<span class="hljs-comment">#print_score 这个函数就是方法</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%s: %s&#x27;</span> % (self.name, self.score))<br>        <br>jack = Student(<span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-number">95</span>)  <span class="hljs-comment">#jack是实例</span><br>jack.gender = <span class="hljs-string">&#x27;man&#x27;</span> <span class="hljs-comment">#此处加了一个属性（实例属性）</span><br><br><span class="hljs-built_in">print</span> (<span class="hljs-string">&#x27;%s is a %s&#x27;</span> % (jack.name, jack.gender))<span class="hljs-comment">#输出 增加的实例属性</span><br><span class="hljs-built_in">print</span> (<span class="hljs-string">&#x27;%s&#x27;</span> % (jack.obj_name))<span class="hljs-comment">#输出类属性</span><br><span class="hljs-built_in">print</span> (<span class="hljs-string">&#x27;Hi,%s your score is %s&#x27;</span> % (jack.name, jack.score))<span class="hljs-comment">#输出实例的属性</span><br><span class="hljs-comment">#运行结果</span><br>Jack <span class="hljs-keyword">is</span> a man<br>this <span class="hljs-keyword">is</span> obj name <span class="hljs-built_in">str</span>！<br>Hi，Jack yours score <span class="hljs-keyword">is</span> <span class="hljs-number">95</span><br></code></pre></td></tr></table></figure><h3 id="类-实例"><a href="#类-实例" class="headerlink" title="类 实例"></a>类 实例</h3><p>类是创建实例的模板，而实例则是一个一个具体的对象，各个实例拥有的数据都互相独立，互不影响；</p><hr><p>面向对象最重要的概念就是<strong>类（Class）</strong>和<strong>实例（Instance）</strong>，必须牢记类是抽象的模板，比如Student类，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的<strong>方法</strong>，但各自的数据可能不同。</p><p>仍以Student类为例，在Python中，定义类是通过<code>class</code>关键字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>): <span class="hljs-comment">#Student是类</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, score</span>):  <span class="hljs-comment">#特殊方法“__init__”前后分别有两个下划线！！！</span><br>        self.name = name<br>        self.score = score<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">print_score</span>(<span class="hljs-params">self</span>):<span class="hljs-comment">#这就是方法</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%s: %s&#x27;</span> % (self.name, self.score))<br></code></pre></td></tr></table></figure><p><code>class</code>后面紧接着是类名，即<code>Student</code>，类名通常是大写开头的单词，紧接着是<code>(object)</code>，表示该类是从哪个类继承下来的，继承的概念我们后面再讲，通常，如果没有合适的继承类，就使用<code>object</code>类，这是所有类最终都会继承的类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">jack = Student(<span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-number">95</span>)     <span class="hljs-comment">#jack是实例</span><br></code></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p><strong>方法</strong>就是与实例绑定的函数，和普通函数不同，方法可以直接访问实例的数据；</p><hr><p>面向对象编程的一个重要特点就是数据封装。在上面的<code>Student</code>类中，每个实例就拥有各自的<code>name</code>和<code>score</code>这些数据。我们可以通过函数来访问这些数据，比如打印一个学生的成绩：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_score</span>(<span class="hljs-params">std</span>):<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%s: %s&#x27;</span> % (std.name, std.score))<br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>print_score(bart)<br>Bart Simpson: <span class="hljs-number">59</span><br></code></pre></td></tr></table></figure><p>但是，既然<code>Student</code>实例本身就拥有这些数据，要访问这些数据，就没有必要从外面的函数去访问，可以直接在<code>Student</code>类的内部定义访问数据的函数，这样，就把“数据”给封装起来了。这些封装数据的函数是和<code>Student</code>类本身是关联起来的，我们称之为类的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, score</span>):<br>        self.name = name<br>        self.score = score<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">print_score</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%s: %s&#x27;</span> % (self.name, self.score))<br></code></pre></td></tr></table></figure><p>要定义一个方法，除了第一个参数是<code>self</code>外，其他和普通函数一样。要调用一个方法，只需要在实例变量上直接调用，除了<code>self</code>不用传递，其他参数正常传入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bart.print_score()<br>Bart Simpson: <span class="hljs-number">59</span><br></code></pre></td></tr></table></figure><h3 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h3><ul><li>实例增加属性</li></ul><p>类相当于一个模板，用模板（类）定义实例后，实例还可以再加其他属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>): <span class="hljs-comment">#Student是类</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, score</span>):  <span class="hljs-comment">#特殊方法“__init__”前后分别有两个下划线！！！</span><br>        self.name = name<br>        self.score = score<br><br>jack = Student(<span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-number">95</span>)<br>jack.gender = <span class="hljs-string">&#x27;man&#x27;</span> <span class="hljs-comment">#此处加了一个属性</span><br><br><br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;%s is a %s&quot;</span> % (jack.name, jack.gender))<br></code></pre></td></tr></table></figure><h2 id="访问限制-private"><a href="#访问限制-private" class="headerlink" title="访问限制 private"></a>访问限制 private</h2><p>外部无法访问，只能通过方法访问（私有变量）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, score</span>):<br>        self.__name = name<span class="hljs-comment">#变成私有变量（private）了</span><br>        self.__score = score<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">print_score</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%s: %s&#x27;</span> % (self.__name, self.__score))<br></code></pre></td></tr></table></figure><hr><p>需要注意的是，在Python中，变量名类似<code>__xxx__</code>的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用<code>__name__</code>、<code>__score__</code>这样的变量名。</p><p>有些时候，你会看到以一个下划线开头的实例变量名，比如<code>_name</code>，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。</p><p>双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问<code>__name</code>是因为Python解释器对外把<code>__name</code>变量改成了<code>_Student__name</code>，所以，仍然可以通过<code>_Student__name</code>来访问<code>__name</code>变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bart._Student__name<br><span class="hljs-string">&#x27;Bart Simpson&#x27;</span><br></code></pre></td></tr></table></figure><p>但是强烈建议你不要这么干，因为不同版本的Python解释器可能会把<code>__name</code>改成不同的变量名。</p><p>总的来说就是，Python本身没有任何机制阻止你干坏事，一切全靠自觉。</p><p>最后注意下面的这种<strong>错误写法</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bart = Student(<span class="hljs-string">&#x27;Bart Simpson&#x27;</span>, <span class="hljs-number">59</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bart.get_name()<br><span class="hljs-string">&#x27;Bart Simpson&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>bart.__name = <span class="hljs-string">&#x27;New Name&#x27;</span> <span class="hljs-comment"># 设置__name变量！</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>bart.__name<br><span class="hljs-string">&#x27;New Name&#x27;</span><br></code></pre></td></tr></table></figure><p>表面上看，外部代码“成功”地设置了<code>__name</code>变量，但实际上这个<code>__name</code>变量和class内部的<code>__name</code>变量<em>不是</em>一个变量！内部的<code>__name</code>变量已经被Python解释器自动改成了<code>_Student__name</code>，而外部代码给<code>bart</code>新增了一个<code>__name</code>变量。不信试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bart.get_name() <span class="hljs-comment"># get_name()内部返回self.__name</span><br><span class="hljs-string">&#x27;Bart Simpson&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p><strong>用组合的方式建立了类与组合的类之间的关系，它是一种‘有’的关系,比如教授有生日，教授教python课程</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BirthDate</span>:    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,year,month,day</span>):<br>        self.year=year<br>        self.month=month<br>        self.day=day<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Couse</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,name,price,period</span>):<br>        self.name=name<br>        self.price=price<br>        self.period=period<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,name,gender,birth,course</span>):<br>        self.name=name <br>        self.gender=gender<br>        self.birth=birth<br>        self.course=course<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">teach</span>(<span class="hljs-params">self</span>): <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;teaching&#x27;</span>)<br>p1=Teacher(<span class="hljs-string">&#x27;egon&#x27;</span>,<span class="hljs-string">&#x27;male&#x27;</span>, <br>            BirthDate(<span class="hljs-string">&#x27;1995&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;27&#x27;</span>), <br>            Couse(<span class="hljs-string">&#x27;python&#x27;</span>,<span class="hljs-string">&#x27;28000&#x27;</span>,<span class="hljs-string">&#x27;4 months&#x27;</span>)<br>           ) <br><br><span class="hljs-built_in">print</span>(p1.birth.year,p1.birth.month,p1.birth.day) <br><br><span class="hljs-built_in">print</span>(p1.course.name,p1.course.price,p1.course.period)<br><span class="hljs-string">&#x27;&#x27;&#x27; </span><br><span class="hljs-string">运行结果: </span><br><span class="hljs-string">1 27 </span><br><span class="hljs-string">python 28000 4 months </span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>当类之间有显著不同，并且较小的类是较大的类所需要的组件时，用组合比较好</strong></p><h2 id="继承-多态"><a href="#继承-多态" class="headerlink" title="继承 多态"></a>继承 多态</h2><ul><li>抽象：抽象即抽取类似或者说比较像的部分。是一个从具题到抽象的过程。</li><li>继承：子类继承了父类的方法和属性</li><li>派生：子类在父类方法和属性的基础上产生了新的方法和属性</li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li>建立一个新类（子类 Subclass）可以copy一份原来类（父类 基类或超类 Base class、Super class）的全部功能（方法、变量 等）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-title class_ inherited__">object</span>):<span class="hljs-comment">#父类</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Animal is running...&#x27;</span>)<br>        <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-title class_ inherited__">Animal</span>):<span class="hljs-comment">#子类</span><br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment">#运行结果</span><br>Animal <span class="hljs-keyword">is</span> running...<span class="hljs-comment">#子类有了父类的方法</span><br></code></pre></td></tr></table></figure><ul><li>当子类和父类都存在相同的<code>run()</code>方法时，我们说，子类的<code>run()</code>覆盖了父类的<code>run()</code>，在代码运行的时候，总是会调用子类的<code>run()</code>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-title class_ inherited__">object</span>):<span class="hljs-comment">#父类</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Animal is running...&#x27;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-title class_ inherited__">Animal</span>):<span class="hljs-comment">#子类</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Dog is running...&#x27;</span>)<br><br><span class="hljs-comment">#运行结果</span><br>Dog <span class="hljs-keyword">is</span> running...<span class="hljs-comment">#子类覆盖了父类的方法</span><br></code></pre></td></tr></table></figure><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p><strong>就是一个集合的概念，子类包含了父类，子类比父类范围更大，这种好处是通用性更强</strong></p><ul><li>子类继承了父类的类型，子类既是  <strong>子类类型</strong>  也是  <strong>父类类型</strong>  </li><li>传入类型设置为  父类   可以有很好的通用性</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-title class_ inherited__">object</span>):<span class="hljs-comment">#父类</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Animal is running...&#x27;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-title class_ inherited__">Animal</span>):<span class="hljs-comment">#子类</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Dog is running...&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run_twice</span>(<span class="hljs-params">animal</span>):<span class="hljs-comment">#因为传入的是 父类 所以子类父类都可以用    有很好通用性</span><br>    animal.run()<br>    animal.run()<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>run_twice(Animal())<br>Animal <span class="hljs-keyword">is</span> running...<br>Animal <span class="hljs-keyword">is</span> running...<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>run_twice(Dog())<br>Dog <span class="hljs-keyword">is</span> running...<br>Dog <span class="hljs-keyword">is</span> running...<br></code></pre></td></tr></table></figure><hr><p>要理解什么是多态，我们首先要对数据类型再作一点说明。当我们定义一个class的时候，我们实际上就定义了一种数据类型。我们定义的数据类型和Python自带的数据类型，比如str、list、dict没什么两样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-built_in">list</span>() <span class="hljs-comment"># a是list类型</span><br>b = Animal() <span class="hljs-comment"># b是Animal类型</span><br>c = Dog() <span class="hljs-comment"># c是Dog类型</span><br></code></pre></td></tr></table></figure><p>判断一个变量是否是某个类型可以用<code>isinstance()</code>判断：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(a, <span class="hljs-built_in">list</span>)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(b, Animal)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(c, Dog)<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>看来<code>a</code>、<code>b</code>、<code>c</code>确实对应着<code>list</code>、<code>Animal</code>、<code>Dog</code>这3种类型。</p><p>但是等等，试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(c, Animal)<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>看来<code>c</code>不仅仅是<code>Dog</code>，<code>c</code>还是<code>Animal</code>！</p><p>不过仔细想想，这是有道理的，因为<code>Dog</code>是从<code>Animal</code>继承下来的，当我们创建了一个<code>Dog</code>的实例<code>c</code>时，我们认为<code>c</code>的数据类型是<code>Dog</code>没错，但<code>c</code>同时也是<code>Animal</code>也没错，<code>Dog</code>本来就是<code>Animal</code>的一种！</p><p>所以，在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。但是，反过来就不行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>b = Animal()<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(b, Dog)<br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p><code>Dog</code>可以看成<code>Animal</code>，但<code>Animal</code>不可以看成<code>Dog</code>。</p><p>要理解多态的好处，我们还需要再编写一个函数，这个函数接受一个<code>Animal</code>类型的变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">run_twice</span>(<span class="hljs-params">animal</span>):<br>    animal.run()<br>    animal.run()<br></code></pre></td></tr></table></figure><p>当我们传入<code>Animal</code>的实例时，<code>run_twice()</code>就打印出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>run_twice(Animal())<br>Animal <span class="hljs-keyword">is</span> running...<br>Animal <span class="hljs-keyword">is</span> running...<br></code></pre></td></tr></table></figure><p>当我们传入<code>Dog</code>的实例时，<code>run_twice()</code>就打印出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>run_twice(Dog())<br>Dog <span class="hljs-keyword">is</span> running...<br>Dog <span class="hljs-keyword">is</span> running...<br></code></pre></td></tr></table></figure><p>当我们传入<code>Cat</code>的实例时，<code>run_twice()</code>就打印出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>run_twice(Cat())<br>Cat <span class="hljs-keyword">is</span> running...<br>Cat <span class="hljs-keyword">is</span> running...<br></code></pre></td></tr></table></figure><p>看上去没啥意思，但是仔细想想，现在，如果我们再定义一个<code>Tortoise</code>类型，也从<code>Animal</code>派生：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tortoise</span>(<span class="hljs-title class_ inherited__">Animal</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Tortoise is running slowly...&#x27;</span>)<br></code></pre></td></tr></table></figure><p>当我们调用<code>run_twice()</code>时，传入<code>Tortoise</code>的实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>run_twice(Tortoise())<br>Tortoise <span class="hljs-keyword">is</span> running slowly...<br>Tortoise <span class="hljs-keyword">is</span> running slowly...<br></code></pre></td></tr></table></figure><p>你会发现，新增一个<code>Animal</code>的子类，不必对<code>run_twice()</code>做任何修改，实际上，任何依赖<code>Animal</code>作为参数的函数或者方法都可以不加修改地正常运行，原因就在于多态。</p><p>多态的好处就是，当我们需要传入<code>Dog</code>、<code>Cat</code>、<code>Tortoise</code>……时，我们只需要接收<code>Animal</code>类型就可以了，因为<code>Dog</code>、<code>Cat</code>、<code>Tortoise</code>……都是<code>Animal</code>类型，然后，按照<code>Animal</code>类型进行操作即可。由于<code>Animal</code>类型有<code>run()</code>方法，因此，传入的任意类型，只要是<code>Animal</code>类或者子类，就会自动调用实际类型的<code>run()</code>方法，这就是多态的意思：</p><p>对于一个变量，我们只需要知道它是<code>Animal</code>类型，无需确切地知道它的子类型，就可以放心地调用<code>run()</code>方法，而具体调用的<code>run()</code>方法是作用在<code>Animal</code>、<code>Dog</code>、<code>Cat</code>还是<code>Tortoise</code>对象上，由运行时该对象的确切类型决定，这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种<code>Animal</code>的子类时，只要确保<code>run()</code>方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则：</p><p>对扩展开放：允许新增<code>Animal</code>子类；</p><p>对修改封闭：不需要修改依赖<code>Animal</code>类型的<code>run_twice()</code>等函数。</p><p>继承还可以一级一级地继承下来，就好比从爷爷到爸爸、再到儿子这样的关系。而任何类，最终都可以追溯到根类object，这些继承关系看上去就像一颗倒着的树。比如如下的继承树：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ascii">                ┌───────────────┐<br>                │    object     │<br>                └───────────────┘<br>                        │<br>           ┌────────────┴────────────┐<br>           │                         │<br>           ▼                         ▼<br>    ┌─────────────┐           ┌─────────────┐<br>    │   Animal    │           │    Plant    │<br>    └─────────────┘           └─────────────┘<br>           │                         │<br>     ┌─────┴──────┐            ┌─────┴──────┐<br>     │            │            │            │<br>     ▼            ▼            ▼            ▼<br>┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐<br>│   Dog   │  │   Cat   │  │  Tree   │  │ Flower  │<br>└─────────┘  └─────────┘  └─────────┘  └─────────┘<br></code></pre></td></tr></table></figure><h4 id="静态语言-vs-动态语言"><a href="#静态语言-vs-动态语言" class="headerlink" title="静态语言 vs 动态语言"></a>静态语言 vs 动态语言</h4><p>对于静态语言（例如Java）来说，如果需要传入<code>Animal</code>类型，则传入的对象必须是<code>Animal</code>类型或者它的子类，否则，将无法调用<code>run()</code>方法。</p><p>对于Python这样的动态语言来说，则不一定需要传入<code>Animal</code>类型。我们只需要保证传入的对象有一个<code>run()</code>方法就可以了：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Timer</span>(object):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>        print(<span class="hljs-string">&#x27;Start...&#x27;</span>)<br></code></pre></td></tr></table></figure><p>这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</p><p>Python的“file-like object“就是一种鸭子类型。对真正的文件对象，它有一个<code>read()</code>方法，返回其内容。但是，许多对象，只要有<code>read()</code>方法，都被视为“file-like object“。许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了<code>read()</code>方法的对象。</p><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p><strong>抽象类是一个特殊的类，它的特殊之处在于只能被继承，不能被实例化</strong></p><p><em>比如我们有香蕉的类，有苹果的类，有桃子的类，从这些类抽取相同的内容就是水果这个抽象的类，你吃水果时，要么是吃一个具体的香蕉，要么是吃一个具体的桃子。。。。。。你永远无法吃到一个叫做水果的东西</em></p><p><em>从实现角度来看，抽象类与普通类的不同之处在于：抽象类中有抽象方法，该类不能被实例化，只能被继承，且子类必须实现抽象方法。这一点与接口有点类似，但其实是不同的，即将揭晓答案</em></p><h2 id="经典类和新式类"><a href="#经典类和新式类" class="headerlink" title="经典类和新式类"></a>经典类和新式类</h2><p><img src="/2020/297a89d9/1610094679745.jpg" alt="1610094679745"></p>]]></content>
    
    
    <categories>
      
      <category>language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MarkDown学习笔记</title>
    <link href="/2020/da7ed36c/"/>
    <url>/2020/da7ed36c/</url>
    
    <content type="html"><![CDATA[<h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><p>asdasdasdasdassdasdas</p><h2 id="这是一段引用"><a href="#这是一段引用" class="headerlink" title="这是一段引用"></a>这是一段引用</h2><blockquote><p>这是一段引用</p></blockquote><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><ul><li>阿斯大声</li><li>阿斯大声打</li><li>阿斯大声问请问恶</li></ul><h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><ol><li><p>阿斯大声打</p></li><li><p>阿斯大声阿斯大声</p></li><li><p>dasd阿斯dasdaaa</p></li></ol><h2 id="斜体-和-加粗-强调"><a href="#斜体-和-加粗-强调" class="headerlink" title="斜体 和 加粗 (强调)"></a>斜体 和 加粗 (强调)</h2><p>这是<em>斜体</em>      这是<strong>加粗</strong>   这是_什么呢_  好像也__是一样的__</p><h2 id="这段是横线"><a href="#这段是横线" class="headerlink" title="这段是横线"></a>这段是横线</h2><hr><hr><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p><a href="./assets/00.jpg">这是超链接</a></p><p><a href=".%5Cassets%5C00.jpg">www.Baidu.com</a></p><p><a href="https://sigrok.org/wiki/Protocol_decoder_API">这是一个超链接 （注意链接前后不要留空格）</a></p><p>This is <a href="http://example.com/" title="Optional Title Here">an example</a> reference-style link.</p><h2 id="文章内的超链接"><a href="#文章内的超链接" class="headerlink" title="文章内的超链接"></a><a id="文章内的超链接">文章内的超链接</a></h2><p> <a href="##%E8%A1%A8%E6%A0%BC">这是一个文章内部的超链接</a></p><p> Ctrl+左键  </p><p><a href="#HTML跳转">回到-&gt;HTML 跳转</a></p><h2 id="Email-链接"><a href="#Email-链接" class="headerlink" title="Email 链接"></a>Email 链接</h2><p>作者的 Emal <a href="mailto:&#120;&#120;&#64;&#120;&#120;&#x2e;&#99;&#111;&#109;">&#120;&#120;&#64;&#120;&#120;&#x2e;&#99;&#111;&#109;</a> 链接</p><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><ul><li>内联风格</li></ul><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1557132849466&di=61258032fff80f7d4bfff0ad0b325b12&imgtype=0&src=http://s6.sinaimg.cn/middle/6dca756dhad5c3293f515&690" alt="iPhone"></p><ul><li>引用风格</li></ul><p><strong>一直没弄出来</strong></p><p>xxx<img src="/photo_id" alt="photo_id"></p><h2 id="代码块-与-代码行"><a href="#代码块-与-代码行" class="headerlink" title="代码块 与 代码行"></a>代码块 与 代码行</h2><p><code>  delay_init();     //延时函数初始化</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>delay_init();     <span class="hljs-comment">//延时函数初始化</span><br>TIM_ALL_Init();<br> LED_Init();     <span class="hljs-comment">//LED端口初始化</span><br>LCD_Init();<br>POINT_COLOR=WHITE;<br>BACK_COLOR = BLACK;<br>LCD_Clear(BLACK);<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><table><thead><tr><th>name</th><th>age</th><th>sex</th></tr></thead><tbody><tr><td>Done</td><td>20</td><td>0</td></tr><tr><td>Jack</td><td>21</td><td>0</td></tr><tr><td>Done<br/>这里换行了</td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><p><del>这是一条删除             线线线线线线线线线线线线线线线</del></p><h2 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h2><p><u>xiahuaxian</u></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">u</span>&gt;</span></span>xiahuaxian<span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">u</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="这是一个注释"><a href="#这是一个注释" class="headerlink" title="这是一个注释"></a>这是一个注释</h2><p>[注释] <a href="%E8%BF%99%E6%98%AF%E6%B3%A8%E9%87%8A%E7%9A%84%E8%A7%A3%E9%87%8A">^注释</a>:Somebody that I used to know.</p><h2 id="数学表达式"><a href="#数学表达式" class="headerlink" title="数学表达式"></a>数学表达式</h2><p>$ (h&#x2F;2)<em>(a+9)&#x2F;(b</em>9))*L $</p><p>$lim_{x \to \infty} \ exp(-x)&#x3D;0$</p><h2 id="修改文字颜色-HTLML"><a href="#修改文字颜色-HTLML" class="headerlink" title="修改文字颜色 HTLML"></a>修改文字颜色 HTLML</h2><p>You can use HTML to style content what pure Markdown does not support.</p><p><span style="color:red"><strong>TEXT Style</strong></span></p><p><span style="color:#29b6f6"> <strong>TEXT Style</strong> </span></p><p><span style="color:rgb(255, 255, 255)"><strong>TEXT Style</strong></span></p><p><span style="color:LightPink"> <strong>TEXT Style</strong> </span></p><p><span style="color:Thistle"> <strong>TEXT Style</strong> </span></p><p><span style="color:Gold"> <strong>TEXT Style</strong> </span></p><p><span style="color:Tomato"> <strong>TEXT Style</strong> </span></p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:red&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:#29b6f6&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:rgb(255, 255, 255)&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><br>https://www.5tu.cn/colors/yansezhongwenming.html<br></code></pre></td></tr></table></figure><p>For example, use <code>&lt;span style=&quot;color:red&quot;&gt;this text is red&lt;/span&gt;</code> to add text with red color.</p><h2 id="表情-Emoji-smile"><a href="#表情-Emoji-smile" class="headerlink" title="表情 Emoji :smile:"></a>表情 Emoji :smile:</h2><p>Input emoji with syntax <code>:smile:</code>.</p><p>User can trigger auto-complete suggestions for emoji by pressing <code>ESC</code> key, or trigger it automatically after enabling it on preference panel. Also, inputting UTF-8 emoji characters directly is also supported by going to <code>Edit</code> -&gt; <code>Emoji &amp; Symbols</code> in the menu bar (macOS).</p><h2 id="Task-List-带勾的计划任务-勾选框"><a href="#Task-List-带勾的计划任务-勾选框" class="headerlink" title="Task List 带勾的计划任务 勾选框"></a>Task List 带勾的计划任务 勾选框</h2><ul><li><input disabled="" type="checkbox"> a task list item</li><li><input disabled="" type="checkbox"> list syntax required </li><li><input checked="" disabled="" type="checkbox"> completed</li></ul><p>注意    [内有一个空格] </p><h2 id="Video"><a href="#Video" class="headerlink" title="Video"></a>Video</h2><p>You can use the <code>&lt;video&gt;</code> HTML tag to embed videos. For example:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Markdown"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;xxx.mp4&quot;</span> /&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">文字[^脚注1]文字.<br>[<span class="hljs-symbol">^脚注1</span>]:<span class="hljs-link">这是脚注1的内容</span><br></code></pre></td></tr></table></figure><p>文字<a href="%E8%BF%99%E6%98%AF%E8%84%9A%E6%B3%A81%E7%9A%84%E5%86%85%E5%AE%B9">^脚注1</a>文字.</p><h2 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h2><p><strong>1.实现下标与上标的三种方法：</strong></p><ul><li><p>方法1（符号）：(这是Markdown的拓展语法)</p><figure class="highlight parser3"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs parser3"><span class="language-xml">下标 ：θ~</span><span class="hljs-number">1</span><span class="language-xml">~ </span><br><span class="language-xml">上标 ：θ</span><span class="hljs-keyword">^2</span><span class="language-xml">^</span><br><span class="language-xml"></span><span class="hljs-number">12</span><br></code></pre></td></tr></table></figure></li><li><p>结果如下：<br>下标 ：θ<del>1</del><br>上标 ：θ^2^</p></li><li><p>方法2（HTML标签）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml">下标 ：θ<span class="hljs-tag">&lt;<span class="hljs-name">sub</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">sub</span>&gt;</span><br>上标 ：θ<span class="hljs-tag">&lt;<span class="hljs-name">sup</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">sup</span>&gt;</span><br>12<br></code></pre></td></tr></table></figure></li><li><p>结果如下：<br>下标 ：θ<sub>1</sub><br>上标 ：θ<sup>2</sup></p></li><li><p>方法3（公式块）：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br>下标 ：θ_1 ，上标 ：θ^<span class="hljs-number">2</span><br><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure></li><li><p>结果如下：</p></li><li><p>$$<br>下标 ：θ_1 ，上标 ：θ^2<br>$$</p></li></ul><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><h2 id="HTML-跳转"><a href="#HTML-跳转" class="headerlink" title="HTML 跳转"></a><a id="HTML跳转">HTML 跳转</a></h2><p><a href="#文章内的超链接">点击到达-&gt;文章内的超链接</a> </p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">&lt;<span class="hljs-keyword">a</span> href=<span class="hljs-string">&quot;#demo&quot;</span>&gt;点击到达跳转位置演示&lt;/<span class="hljs-keyword">a</span>&gt; <span class="hljs-comment"># 在需要跳转的地方添加此代码。</span><br>&lt;<span class="hljs-keyword">a</span> id=<span class="hljs-string">&quot;demo&quot;</span>&gt;跳转位置演示（跳转位置设置点）&lt;/<span class="hljs-keyword">a</span>&gt; <span class="hljs-comment"># 在跳转位置添加次代码。</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>markdown</tag>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OSI</title>
    <link href="/2020/1a11e44c/"/>
    <url>/2020/1a11e44c/</url>
    
    <content type="html"><![CDATA[<h1 id="OSI"><a href="#OSI" class="headerlink" title="OSI"></a>OSI</h1><p>开放系统互联参考模型(OSI Referenec Model)，即我们通常所说的网络互联的七层框架，它是国际标准组织(International Organization for Standization)于1977年提出的标准，又称为ISO&#x2F;IEC 7498或X.200建议。值得注意的是，OSI并没有提供一个可以实现的方法，它不是一个标准而只是一个制定标准时使用的概念性的框架，更不是一个网络协议。</p><ol><li>物理层(Physical Layer)：主要功能为定义了网络的物理结构，传输的电磁标准，Bit流的编码及网络的时间原则，如分时复用及分频复用。决定了网络连接类型(端到端或多端连接)及物理拓扑结构。说的通俗一些，这一层主要负责实际的<a href="https://product.pconline.com.cn/itbk/sjtx/sj/1203/2699254.html">信号</a>传输。</li><li>数据链路层(D<a href="https://product.pconline.com.cn/itbk/diy/mb/1107/2474080.html">ata</a> Link eview)：在两个主机上建立数据链路连接，向物理层传输数据信号，并对信号进行处理使之无差错并合理的传输</li><li>网络层(Network Layer)：主要负责路由，选择合适的路径，进行阻塞控制等功能。</li><li>传输层(Transfer Layer)：最关键的一层，向拥护提供可靠的端到端(End-to-End)服务，它屏蔽了下层的数据通信细节，让用户及应用程序不需要考虑实际的通信方法。</li><li>会话层(Session Layer)：主要负责两个会话进程之间的通信，即两个会话层实体之间的信息交换，管理数据的交换。</li><li>表示层(Presentation Layer)：处理通信信号的表示方法，进行不同的格式之间的翻译，并负责数据的加密解密，数据的压缩与恢复</li><li>应用层(Application Layer)：保持应用程序之间建立连接所需要的数据记录，为用户服务。 三大协议NetBEUI和 IPX&#x2F;SPX TCP&#x2F;IP</li></ol><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td></td></tr><tr><td>应用层(Application Layer)</td><td>消息</td></tr><tr><td>表示层(Presentation Layer)</td><td></td></tr><tr><td>会话层(Session Layer)</td><td></td></tr><tr><td>传输层(Transfer Layer)</td><td>数据段(segment)</td></tr><tr><td>网络层(Network Layer)</td><td>分组、数据包（packet）</td></tr><tr><td>链路层(Data Link eview)</td><td>帧（frame）</td></tr><tr><td>物理层(Physical Layer)</td><td>P-PDU（bit）</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>osi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>摄影</title>
    <link href="/2020/bda63754/"/>
    <url>/2020/bda63754/</url>
    
    <content type="html"><![CDATA[<p><img src="/2020/bda63754/1e3bb3da2c76d5c2ed546428edc1cd4e_720w.jpg" alt="1e3bb3da2c76d5c2ed546428edc1cd4e_720w"></p><p><img src="/2020/bda63754/%E8%89%B2%E7%8E%AF3.png" alt="色环3"></p><h1 id="调色"><a href="#调色" class="headerlink" title="调色"></a>调色</h1><h2 id="马卡龙糖果色"><a href="#马卡龙糖果色" class="headerlink" title="马卡龙糖果色"></a>马卡龙糖果色</h2><h3 id="形式"><a href="#形式" class="headerlink" title="形式"></a>形式</h3><p>高明度、低对比、高饱和、高明度</p><ul><li><p>暖色—橙色、黄色、粉色</p></li><li><p>冷色—绿色、蓝色、青色、建议青蓝色为主色调</p></li></ul><h3 id="适合场景"><a href="#适合场景" class="headerlink" title="适合场景"></a>适合场景</h3><ul><li>建议晴天的白天、避免大光比、复杂的色彩组成、</li><li>建议有蓝色元素(天空)、橙色黄色粉色等暖色系元素、</li></ul><h2 id="青橙色调色"><a href="#青橙色调色" class="headerlink" title="青橙色调色"></a>青橙色调色</h2><h3 id="形式-1"><a href="#形式-1" class="headerlink" title="形式"></a>形式</h3><p>青色橙色作为主色调</p><p>拉高白色、降低黑色增强对比</p><ul><li>降低高光、提升阴影恢复细节</li><li>拉高白色、降低黑色增强对比</li></ul><h3 id="适合场景-1"><a href="#适合场景-1" class="headerlink" title="适合场景"></a>适合场景</h3><p>天空、大海等蓝色元素 和 肤色、灯光等的橙色元素。</p><p><img src="/2020/bda63754/%E9%9D%92%E6%A9%99%E6%A1%88%E4%BE%8B-1.jpg" alt="青橙案例-1"></p><h2 id="日系蓝黄色调"><a href="#日系蓝黄色调" class="headerlink" title="日系蓝黄色调"></a>日系蓝黄色调</h2><p>画面本身有蓝、黄橙绿元素、</p><p>白天的街景、建筑最佳</p><ul><li>降低对比度（降低高光和白色、提升阴影），操作后照片会偏灰，降低黑色压实影调</li><li>曲线压缩最亮部分（右顶点向下偏），使得白色更加柔和</li><li>主色调为蓝黄色及相邻色（），基本不含其他色</li></ul><p><img src="/2020/bda63754/%E6%97%A5%E7%B3%BB%E8%93%9D%E9%BB%84%E8%89%B2%E8%B0%83-Frank.jpg" alt="日系蓝黄色调-Frank"></p><h2 id="黑金色调"><a href="#黑金色调" class="headerlink" title="黑金色调"></a>黑金色调</h2>]]></content>
    
    
    <categories>
      
      <category>more_interest</category>
      
    </categories>
    
    
    <tags>
      
      <tag>摄影</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>USART硬件流控制</title>
    <link href="/2020/3b631eba/"/>
    <url>/2020/3b631eba/</url>
    
    <content type="html"><![CDATA[<h1 id="USART硬件流控制"><a href="#USART硬件流控制" class="headerlink" title="USART硬件流控制"></a>USART硬件流控制</h1><p><img src="/2020/3b631eba/SouthEast.jpeg"></p><p>RS232 DB9定义</p><p>1 CD ← Carrier Detect 载波检测</p><p>2 RXD ← Receive Data 接收数据</p><p>3 TXD → Transmit Data 发送数据</p><p>4 <strong>DTR → Data Terminal Ready数据终端就绪</strong></p><p>5 GND — System Ground 系统接地</p><p>6 DSR ← Data Set Ready 数据设备就绪</p><p>7 <strong>RTS → Request To Send 请求发送</strong></p><p>8 CTS ← Clear To Send 清除发送(允许发送)</p><p>9 RI → 振铃指示</p><h2 id="RTS-CTS"><a href="#RTS-CTS" class="headerlink" title="RTS CTS"></a>RTS CTS</h2><ul><li>RTS （Require ToSend，发送请求）为输出信号，用于指示本设备准备好可接收数据，低电平有效，低电平说明本设备可以接收数据。</li><li>CTS （Clear ToSend，发送允许）为输入信号，用于判断是否可以向对方发送数据，低电平有效，低电平说明本设备可以向对方发送数据。</li></ul><h2 id="DTR-DSR"><a href="#DTR-DSR" class="headerlink" title="DTR DSR"></a>DTR DSR</h2>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>usart</tag>
      
      <tag>rts</tag>
      
      <tag>cts</tag>
      
      <tag>dtr</tag>
      
      <tag>dsr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bluetooth蓝牙</title>
    <link href="/2020/95869d00/"/>
    <url>/2020/95869d00/</url>
    
    <content type="html"><![CDATA[<h1 id="蓝牙分类"><a href="#蓝牙分类" class="headerlink" title="蓝牙分类"></a>蓝牙分类</h1><pre><code class=" mermaid">graph LRBluetooth_3.0 --&gt;BRBluetooth_3.0 --&gt;EDRBluetooth_3.0 --&gt;AMP_HS</code></pre><pre><code class=" mermaid">graph LRBluetooth_4.0 --&gt;BRBluetooth_4.0 --&gt;EDRBluetooth_4.0 --&gt;AMP_HSBluetooth_4.0 --&gt;LE</code></pre><p>只有一种蓝牙即 Bluetooth SIG。</p><p>但是蓝牙技术本身包括四种类型：BR、EDR、AMP 和 LE。</p><p>为了方便，人们将以前的 BR&#x2F;EDR&#x2F;AMP 技术称为“经典蓝牙”（BT）技术。</p><p>LE也即低功耗蓝牙BLE。</p><h1 id="SPP"><a href="#SPP" class="headerlink" title="SPP"></a>SPP</h1><p>SPP（Serial Port Profile）串口</p>]]></content>
    
    
    <categories>
      
      <category>Communication</category>
      
    </categories>
    
    
    <tags>
      
      <tag>embedded</tag>
      
      <tag>bluetooth</tag>
      
      <tag>蓝牙</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SourceInsigh中Qicker的使用</title>
    <link href="/2020/4ade0b2f/"/>
    <url>/2020/4ade0b2f/</url>
    
    <content type="html"><![CDATA[<h1 id="Qicker-em"><a href="#Qicker-em" class="headerlink" title="Qicker.em"></a>Qicker.em</h1><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ol><li><p>代码补全：</p><ul><li><p>wh：       while（）</p></li><li><p>if，ife，ifs：     if，if else， if elseif else</p></li><li><p>for：      for</p></li><li><p>fo：自动生成for语句与for命令相比它直接会定义循环变量</p></li></ul>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> ( ulI = <span class="hljs-number">0</span>; ulI &lt; # ; ulI++ )<br>&#123;<br>    UINT32_T ulI = <span class="hljs-number">0</span>;<br>    #<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>do: do while</li><li>switch：</li><li>case：</li><li>#ifd: #ifdef</li><li>#if：</li><li>cpp ：自动生成适用于c++的c原型说明定义</li><li>struct：</li><li>enum：</li></ul></li><li><p>添加文件头注释： 命令：fi 解释：file  </p></li><li><p>添加函数头注释（.h）： 命令：fi 解释：file </p></li><li><p>增加修改历史列表： 命令：hi （会报错）</p></li><li><p>根据（.c）生成（.h）文件：命令：hdn</p></li><li><p>添加函数说明注释： 命令：fu 解释： function  </p></li><li><p>添加单行注释：（<span style="color:red">不知道为什么没用</span>）</p><ul><li>命令：as 解释： add start    (添加之后 <code>/* add by zhangsan, 20140504, Mantis号:d, 原: */</code> ) </li><li>命令：ms 解释： modify start  (添加之后：<code>/ modify by zhangsan, 20140504, Mantis号:d, 原因: */</code>  ) </li><li>命令：ds 解释： delete start  (添加之后：<code>/ delete by zhangsan, 20140504, Mantis号:d, 原因: */</code>  )</li></ul></li><li><p>添加标记注释： </p><ul><li><p>命令：ab 解释： add begin    (添加之后：<code>/* add begin by zhangsan, 20140504, Mantis号:d 原因: */</code>) </p></li><li><p>命令：mb 解释： modify begin  (添加之后：<code>/* modify begin by zhangsan, 20140504, Mantis号:d 原因: */</code>) </p></li><li><p>命令：me 解释： modify end    (添加之后：<code>/* modify end by zhangsan, 20140504 */</code>)  </p></li><li><p>命令：db 解释： delete begin  (添加之后：<code>/* delete begin by zhangsan, 20140504, Mantis号:d 原因: */</code>) </p></li><li><p>命令：de 解释： delete end    (添加之后：<code>/* delete end by zhangsan, 20140504 */</code>)</p></li></ul></li><li><p>配置命令：</p></li></ol><ul><li>命令：co 解释：config （修改相关配置信息）</li></ul><p> 如何使用呢，以为整个文件添加注释为例，在源文件的任何地方输入命令 fi 之后直接按ctrl + enter(配置的快捷键)即可。</p><h2 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h2><p> source insight有很多宏可以用，这里介绍的宏是quicker.em这个宏，它是华为的一个员工写的，很实用。</p><ol><li><p>安装quicker.em宏</p><ul><li><p>打开base这个工程Project-&gt;Open Project，选择base工程，即可打开；</p></li><li><p>将宏文件quicker.em添加到该base工程中；</p></li><li><p>设置宏的快捷方式：Options-&gt;Key Assignments，找到Marco:AutoExpand,添加快捷键即可，一般推介用Ctrl+Enter组合键。</p></li></ul></li><li><p>HeaderFileCreate，这个宏功能用于自动创建一个.c文件的头文件。</p><p>使用方法：</p><ul><li>创建自定义快捷菜单Options-&gt;Menu Assignments，选择Macro:HeaderFileCreate这一项，将它添加到右边Menu项的Work下，然后点Insert插入，点OK即可。</li><li>打开该.c文件，在work栏就能看到我们刚才添加的自定义快捷菜单HeaderFileCreate，点击它，就自动生产头文件了。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sourceinsigh</tag>
      
      <tag>si</tag>
      
      <tag>ide</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DSlogic协议开发笔记</title>
    <link href="/2020/5ced0506/"/>
    <url>/2020/5ced0506/</url>
    
    <content type="html"><![CDATA[<h1 id="参考资料-smiley"><a href="#参考资料-smiley" class="headerlink" title="参考资料:smiley:"></a>参考资料:smiley:</h1><p><a href="https://sigrok.org/wiki/Protocol_decoder_HOWTO">Protocol decoder HOWTO(新手指导)</a></p><p><a href="https://sigrok.org/wiki/Protocol_decoder_API#register-function">Protocol decoder API</a></p><p><a href="https://sigrok.org/wiki/Protocol_decoder_API/Queries">Protocol decoder API&#x2F;Queries</a></p><h1 id="名词解析"><a href="#名词解析" class="headerlink" title="名词解析"></a>名词解析</h1><ul><li><strong>Protocol Decoders (PDs)</strong></li></ul><p>协议解码器</p><ul><li><strong>libsigrokdecode</strong></li></ul><p>是一个采用C语言编写的共享库,提供了数据流协议解码功能。该协议解码器采用Python(&#x3D; 3.0)编写。 </p><h1 id="Decoder-class-functions"><a href="#Decoder-class-functions" class="headerlink" title="Decoder class functions"></a>Decoder class functions</h1><h2 id="必须的函数"><a href="#必须的函数" class="headerlink" title="必须的函数"></a>必须的函数</h2><ul><li>start(self)</li></ul><p> 这个函数在解码开始之前被调用。这里可以  [register()](#Decoder registration) 输出类型，检查用户提供的PD选项的有效性，等等。 </p><ul><li>decode(self) （解码）</li></ul><p>在 <strong>non-stacked</strong> 解码器中，这个函数由libsigrokdecode后端调用以开始解码。它不接受任何参数，而是进入一个无限循环，并通过调用更通用的wait()方法获取样本。这使得特定的协议解码器从繁琐但常见的任务中解放出来，比如检测边缘，或者在相对于当前位置的特定时间点采样信号。</p><p>  注意:这个decode(self)方法的签名已经在协议解码器API的第三版中引入，在以前的版本中只有decode(self、startsample、endsample、data)是可用的。</p><ul><li>decode(self, startsample, endsample, data)</li></ul><p>…</p><h2 id="可选的函数"><a href="#可选的函数" class="headerlink" title="可选的函数"></a>可选的函数</h2><ul><li>metadata(self, key, value)（  元数据 ）</li></ul><p> 用于传递关于数据流的解码器元数据。目前 <strong><code>key</code></strong>  的唯一值是sigrokdecode.SRD_CONF_SAMPLERATE， <strong><code>value</code></strong>  则为数据流的采样率（samplerate），单位为Hz。 </p><h1 id="Decoder-registration"><a href="#Decoder-registration" class="headerlink" title="Decoder registration"></a>Decoder registration</h1><p> 解码器类必须包含几个指定PD元数据的属性。可以使用以下关键字：</p><p><a href="https://sigrok.org/wiki/Protocol_decoder_API">原文查考 Decoder registration 章节</a></p><table><thead><tr><th>Key</th><th>Description</th></tr></thead><tbody><tr><td><strong><code>api_version</code></strong></td><td>这个模块使用的libsigrokdecode API版本。现在不是2就是3。</td></tr><tr><td><strong><code>id</code></strong></td><td>此协议解码器的简短唯一标识符。它应该是全小写的，只包含a-z, 0-9和下划线。这必须匹配PD的Python模块名(decoders目录中的子目录名)。siglock -cli工具使用它在命令行上指定PDs。例如:’jtag’， ‘sdcard_spi’， ‘uart’。</td></tr><tr><td><strong><code>name</code></strong></td><td>解码器的名称。当列出可用的PDs时使用。例如:“JTAG”，“SD卡(SPI模式)”，“UART”。</td></tr><tr><td><strong><code>longname</code></strong></td><td>译码器的(长)名。当列出可用的PDs时使用。Example: ‘Joint Test Action Group (IEEE 1149.1)’, ‘Secure Digital card (SPI mode)’, ‘Universal Asynchronous Receiver&#x2F;Transmitter（UART）’</td></tr><tr><td><strong><code>desc</code></strong></td><td>解码器的自由的一行描述。当列出可用的PDs时使用。应该以句号结束。Example: ‘Protocol for testing, debugging, and flashing ICs.’, ‘Secure Digital card (SPI mode) low-level protocol.’, ‘Asynchronous, serial bus.’.</td></tr><tr><td><strong><code>license</code></strong></td><td>提供模块的许可证。这必须是gplv2+(即GNU通用公共许可证2或更高版本)，或者gplv3+ (GNU通用公共许可证3或更高版本)。libsigrokdecode中不允许为模块提供其他许可证。</td></tr><tr><td><strong><code>inputs</code></strong></td><td>此解码器需要的输入类型列表。如果解码器从逻辑分析器驱动程序获取输入，则应将其设置为logic，该逻辑将映射到数据籽类型SR_DF_LOGIC。如果它从另一个PD获取输入，则应该将其设置为该PD的输出键的值。它应该符合与id键相同的规则(小写，没有空格，等等)。</td></tr><tr><td><strong><code>outputs</code></strong></td><td>此解码器产生的输出类型列表。如果这个解码器能够将解码后的数据反馈到数据流中，那么它的输出将被标识为该密钥的值。它应该与id键遵循相同的规则。</td></tr><tr><td><strong><code>channels</code></strong></td><td>该密钥包含有关<strong>必须</strong>提供给该PD的通道(pin)的信息;没有他们，PD将无法工作。例如，SPI解码器必须知道哪个信道有时钟信号。该键包含一个通道条目的元组，其中每个条目都是一个Python dict，其键为id、name和desc。Example: <strong><code>&#123;&#39;id&#39;: &#39;rx&#39;, &#39;name&#39;: &#39;RX&#39;, &#39;desc&#39;: &#39;UART receive line&#39;&#125;</code></strong>.</td></tr><tr><td><strong><code>optional_channels</code></strong></td><td>PD可选的通道，但不是必须的。该键的格式与上面的通道键相同(dicts的元组)。如果相应的协议解码器没有可选通道，则允许该元组为空。</td></tr><tr><td><strong><code>options</code></strong></td><td>描述此解码器的选项的元组。每个元组条目都是一个Python dict，其键id、desc、缺省值和值。如果PD没有可选的通道，则此元组可以为空。Example: <strong><code>&#123;&#39;id&#39;: &#39;bitorder&#39;, &#39;desc&#39;: &#39;Bit order&#39;, &#39;default&#39;: &#39;msb-first&#39;, &#39;values&#39;: (&#39;msb-first&#39;, &#39;lsb-first&#39;)&#125;</code></strong>.</td></tr><tr><td><strong><code>annotations</code></strong></td><td>此协议解码器可以输出的注释类的列表。此列表的元素是由标识符字符串和可读的描述字符串组成的元组。标识符字符串可以在siglock -cli选项中用于选择特定的注释类型，因此不应该包含空白或特殊字符。</td></tr><tr><td><strong><code>annotation_rows</code></strong></td><td>注释行用于将多个注释类型分组在一起。这个列表的元素是三个元素元组，包括: 1.注释行ID(与其他ID的命名规则相同)。2.注释行的人类可读的名称&#x2F;描述字符串。3. 包含注释元组中注释类的索引的元组。<a href="https://sigrok.org/wiki/Protocol_decoder_HOWTO#annotations_.26_annotation_rows">示例参考</a></td></tr><tr><td><strong><code>binary</code></strong></td><td>此协议解码器可以输出的二进制输出类型列表，格式与**<code>annotations</code>**列表相同。</td></tr></tbody></table><h1 id="self-put"><a href="#self-put" class="headerlink" title="self.put( )"></a>self.put( )</h1><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p><strong>put(startsample, endsample, output_id, data)</strong></p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>startsample：开始的序号</p><p>endsample：结束的序号</p><p>output_id：取值看下表</p><p>data：根据output_id的不同数据也不同</p><table><thead><tr><th>output_id</th><th>funcation</th></tr></thead><tbody><tr><td><strong>OUTPUT_ANN</strong></td><td>注释信息</td></tr><tr><td><strong>OUTPUT_PYTHON</strong></td><td></td></tr><tr><td><strong>OUTPUT_BINARY</strong></td><td></td></tr><tr><td><strong>OUTPUT_META</strong></td><td></td></tr></tbody></table><ol><li><strong>OUTPUT_ANN</strong>：</li></ol><ul><li><p>这个东西在显示bit数据时会在信号上有小点点指示。</p></li><li><p>不同缩放级别显示不同内容<br>Example: <code>self.put(10, 20, self.out_ann, [4, [&#39;Start&#39;, &#39;St&#39;, &#39;S&#39;]])</code></p></li><li><p>data参数是一个包含两个项的Python列表。第一项是注释索引(由解码器中项的顺序决定)。第二个是注释字符串列表。字符串应该是相同注释文本的长版本和短版本(按长度排序，最长优先)，可以由前端根据缩放级别显示不同的注释文本。</p></li></ul><ol start="2"><li><strong>OUTPUT_PYTHON</strong> ：</li></ol><ul><li><p>输出特定格式的数据么？（ 数据内容本身完全依赖于各自的解码器，应该在其pd.py文件中记录。 ）</p><p>Example: <em><code>self.put(10, 20, self.out_python, [&#39;PACKET&#39;, [&#39;Foo&#39;, 19.7, [1, 2, 3], (&#39;bar&#39;, &#39;baz&#39;)]])</code></em> </p></li><li><p>数据参数是将传递给堆叠解码器的任意Python对象。格式和内容完全依赖于解码器。通常，包含各种内容的Python列表被传递给堆叠的PDs。</p></li></ul><ol start="3"><li><p><strong>OUTPUT_BINARY</strong>：</p><ul><li><p>输出数据0x55 0xaa等等（ 二进制格式的索引为4，发出的字节分别为0xfe、0x55、0xaa）</p><p> Example: <em><code>self.put(10, 20, self.out_binary, [4, b&#39;\xfe\x55\xaa&#39;])</code></em> </p></li><li><p>data参数是一个包含两个项的Python列表。第一项是二进制格式的索引(由解码器中项的顺序决定)。第二个是Python bytes对象。</p></li></ul></li><li><p><strong>OUTPUT_META</strong> ：</p></li></ol><ul><li><p>输出解码出来的数字（ 在本例中数据本身是一个浮点数）</p><p> Example: <em><code>self.put(10, 20, self.out_meta, 15.7)</code></em> </p></li><li><p>数据参数是特定类型的Python对象，在各自的register()函数中定义</p></li></ul><h1 id="self-wait"><a href="#self-wait" class="headerlink" title="self.wait()"></a>self.wait()</h1><p>这是协议解码器用来将查询发送到libsigrokdecode后端的API调用。<br>从PD的角度来看，这是一个阻塞呼叫。它将阻塞，直到在样本数据中找到指定的条件，然后才将控制权返回给PD。</p><h2 id="原型-1"><a href="#原型-1" class="headerlink" title="原型"></a>原型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">wait</span>(<span class="hljs-params">self, conds</span>):<br>    <span class="hljs-comment"># 1. 等待，直到conds中的一个或多个条件匹配.</span><br>    <span class="hljs-comment"># 2. 设置 self.samplenum ，匹配样本的绝对样本数.</span><br>    <span class="hljs-comment"># 3. 根据 self.matched 条件匹配.</span><br>    <span class="hljs-comment"># 4. 返回一个包含匹配样本的pin值的元组.</span><br></code></pre></td></tr></table></figure><h2 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h2><h3 id="空参"><a href="#空参" class="headerlink" title="空参"></a>空参</h3><p>如果完全不提供conds，或者它是一个空列表[]，或者它只是一个“空”条件{}，那么后端将直接跳到下一个示例。 （相当于直接进入下一个样本）</p><p><strong>Examples:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Don&#x27;t wait for any condition, just skip to the next sample.</span><br>pins = self.wait()<br>pins = self.wait([])<br>pins = self.wait(&#123;&#125;)<br>pins = self.wait(&#123;<span class="hljs-string">&#x27;skip&#x27;</span>: <span class="hljs-number">1</span>&#125;) <span class="hljs-comment"># Skip one sample, see below.</span><br></code></pre></td></tr></table></figure><h3 id="conds-引脚状态条件-上下沿"><a href="#conds-引脚状态条件-上下沿" class="headerlink" title="conds 引脚状态条件(上下沿)"></a><strong>conds</strong> 引脚状态条件(上下沿)</h3><table><thead><tr><th>Value</th><th>Describe</th></tr></thead><tbody><tr><td>‘<strong>l’</strong></td><td>Low pin value (logical 0)</td></tr><tr><td>‘h’</td><td>High pin value (logical 1)</td></tr><tr><td>‘r’</td><td>Rising edge</td></tr><tr><td>‘f’</td><td>Falling edge</td></tr><tr><td>‘e’</td><td>Either edge (rising or falling)</td></tr><tr><td>‘s’</td><td>稳定状态 Stable state, the opposite of ‘e’. That is, there was no edge and the current and previous pin value were both low (or both high).</td></tr><tr><td>other</td><td>任何其他值都会产生错误。</td></tr></tbody></table><p><strong>Examples:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Wait until pin 7 has a falling edge.</span><br>pins = self.wait(&#123;<span class="hljs-number">7</span>: <span class="hljs-string">&#x27;f&#x27;</span>&#125;)<br><br><span class="hljs-comment"># Wait until pin 3 has a rising edge “and” pin 4 is high at the same time.</span><br>pins = self.wait(&#123;<span class="hljs-number">3</span>: <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-number">4</span>: <span class="hljs-string">&#x27;h&#x27;</span>&#125;)<br><br><span class="hljs-comment"># Wait until pins 2-4 are low and pin 16 has any edge.</span><br>pins = self.wait(&#123;<span class="hljs-number">2</span>: <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-number">3</span>: <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-number">4</span>: <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-number">16</span>: <span class="hljs-string">&#x27;e&#x27;</span>&#125;)<br></code></pre></td></tr></table></figure><h3 id="conds-样品跳过条-样本数量"><a href="#conds-样品跳过条-样本数量" class="headerlink" title="conds 样品跳过条(样本数量)"></a><strong>conds</strong> 样品跳过条(样本数量)</h3><p>后端另一个常见的查询是，当解码器想要跳过一定数量的样本时，而不管样本值是什么(因为它们与当前的协议无关)。<br>这可以通过条件dict中的一个特殊键来实现— ‘<strong>skip’</strong> 。 ‘<strong>skip’</strong> 键的值是要跳过的样本的整数。</p><p>解码器也可以跳过一定的时间，通过使用采样来计算 ‘<strong>skip’</strong> 键的正确值。</p><p><strong>Examples:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Skip over the next 100 samples.</span><br>pins = self.wait(&#123;<span class="hljs-string">&#x27;skip&#x27;</span>: <span class="hljs-number">100</span>&#125;)<br><br><span class="hljs-comment"># Skip over the next 20ms of samples.</span><br>pins = self.wait(&#123;<span class="hljs-string">&#x27;skip&#x27;</span>: <span class="hljs-number">20</span> * (<span class="hljs-number">1000</span> / self.samplerate)&#125;)<br><br><span class="hljs-comment"># Skip half a bitwidth of samples (e.g. for UART).</span><br>self.halfbitwidth = <span class="hljs-built_in">int</span>((self.samplerate / self.options[<span class="hljs-string">&#x27;baudrate&#x27;</span>]) / <span class="hljs-number">2.0</span>)<br>pins = self.wait(&#123;<span class="hljs-string">&#x27;skip&#x27;</span>: self.halfbitwidth&#125;)<br></code></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">pins = self.wait(&#123;<span class="hljs-string">&#x27;skip&#x27;</span>: <span class="hljs-number">100</span>&#125;)  <span class="hljs-comment">#这里的pins是元组，</span><br>(pins,) = self.wait(&#123;<span class="hljs-string">&#x27;skip&#x27;</span>: <span class="hljs-number">100</span>&#125;)<span class="hljs-comment">#可以写成这样</span><br></code></pre></td></tr></table></figure><h1 id="self-skip"><a href="#self-skip" class="headerlink" title="self.skip()"></a>self.skip()</h1><p><strong>这个函数不知道怎么回事，用了会报错</strong></p><p>注意这下面的skip不是wait</p><p>在相同的条件下混合通道索引键和“跳过”键通常没有多大意义，然而，在不同的情况下，混合索引键和“跳过”键是非常合理的: </p><p>（下面的语句应该是  <code>((pin7 e)和(pin12 l))或(skip 10000)</code> ）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Wait until there&#x27;s</span><br><span class="hljs-comment"># a) an edge on pin 7 and a low state on pin 12, and/or</span><br><span class="hljs-comment"># b) 1000 samples passed by,</span><br><span class="hljs-comment"># whichever occurs first (both conditions could occur at the same time too).</span><br><span class="hljs-comment"># This is basically &quot;wait for an edge on pin 7 and a low state on pin 12,</span><br><span class="hljs-comment"># with a timeout of 1000 samples&quot;.</span><br>pins = self.skip((&#123;<span class="hljs-number">7</span>: <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-number">12</span>: <span class="hljs-string">&#x27;l&#x27;</span>&#125;, &#123;<span class="hljs-string">&#x27;skip&#x27;</span>: <span class="hljs-number">1000</span>&#125;))<br></code></pre></td></tr></table></figure><h1 id="self-matched"><a href="#self-matched" class="headerlink" title="self.matched"></a>self.matched</h1><p>当解码器通过<strong>self.wait（）</strong>请求前端等待多个条件时，当该调用返回时，PD仅知道<strong>至少一个</strong>条件已匹配。但是，在大多数情况下，它还需要知道<strong>哪些</strong>条件匹配（或不匹配）。</p><p>这是<strong>self.matched</strong>提供的信息。它是布尔值（<strong>True</strong>或<strong>False</strong>）的元组，始终包含与上次<strong>self.wait（）</strong>调用中存在的条件一样多的条目。对于每个条件，各自的布尔值表示此特定条件是否匹配。</p><p><strong>Example:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 等待，直到引脚9的上升边 或 引脚27的高状态(逻辑1)， 或 经过一定的“时间”(这里:跳过1000个样本)。这意味着有一个1000个样本的“超时”之后self.wait()将返回(不管其他条件如何)。</span><br>pins = self.wait([&#123;<span class="hljs-number">9</span>: <span class="hljs-string">&#x27;r&#x27;</span>&#125;, &#123;<span class="hljs-number">27</span>: <span class="hljs-string">&#x27;h&#x27;</span>&#125;, &#123;<span class="hljs-string">&#x27;skip&#x27;</span>: <span class="hljs-number">1000</span>&#125;])<br><br><span class="hljs-keyword">if</span> self.matched == (<span class="hljs-literal">True</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>):<br>    <span class="hljs-comment"># 前两个条件是同时匹配的。</span><br>    <span class="hljs-comment"># Pin 9 contains a rising edge and pin 27 is high.</span><br><span class="hljs-keyword">elif</span> self.matched == (<span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>):<br>    <span class="hljs-comment"># Rising edge on pin 9, pin 27 is guaranteed to not be high.</span><br><span class="hljs-keyword">elif</span> self.matched == (<span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>):<br>    <span class="hljs-comment"># Pin 27 is high, pin 9 is guaranteed to not be a rising edge.</span><br><span class="hljs-keyword">elif</span> self.matched == (<span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>):<br>    <span class="hljs-comment"># Pin 9 is not a rising edge, pin 27 is not high, but 1000 samples were skipped.</span><br><span class="hljs-keyword">elif</span> self.matched == (<span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">True</span>):<br>    <span class="hljs-comment"># Pin 9 is not a rising edge, pin 27 is high, and it just so happens that</span><br>    <span class="hljs-comment"># exactly 1000 samples were skipped.</span><br><span class="hljs-keyword">elif</span> self.matched == (<span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>):<br>    <span class="hljs-comment"># Bug, this cannot happen. self.wait() only returns upon &gt;= 1 matches.</span><br></code></pre></td></tr></table></figure><p>对于’skip’键&#x2F;值对self。如果达到指定数目的样本，则匹配的tuple将包含一个真值。 </p><p><strong>Example:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Wait for a falling edge on channel 18, or until 25000 samples passed by.</span><br>pins = self.wait([&#123;<span class="hljs-number">18</span>: <span class="hljs-string">&#x27;f&#x27;</span>&#125;, &#123;<span class="hljs-string">&#x27;skip&#x27;</span>: <span class="hljs-number">25000</span>&#125;])<br><br><span class="hljs-keyword">if</span> self.matched[<span class="hljs-number">0</span>]:<br>    <span class="hljs-comment"># Pin 18 has a falling edge.</span><br><span class="hljs-keyword">if</span> self.matched[<span class="hljs-number">1</span>]:<br>    <span class="hljs-comment"># 25000 samples were skipped.</span><br></code></pre></td></tr></table></figure><h1 id="self-samplenum"><a href="#self-samplenum" class="headerlink" title="self.samplenum"></a>self.samplenum</h1><p><em>self.samplenum 相当于一个指针，指示当前解码器解码的样本的位置</em></p><p> <strong>self.samplenum</strong>是一个特殊属性，对于协议解码器来说是只读的，并且只能由libsigrokdecode后端设置。 </p><p> <strong>self.samplenum</strong> 总是在最后一次self.wait()调用返回后的当前绝对样本号(从0开始)。 </p><h1 id="self-samplerate"><a href="#self-samplerate" class="headerlink" title="self.samplerate"></a>self.samplerate</h1><p>采样率</p><h1 id="self-has-channel"><a href="#self-has-channel" class="headerlink" title="self.has_channel"></a>self.has_channel</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#code1 </span><br>...<br>self.have_cs = self.has_channel(<span class="hljs-number">3</span>)<br>...<br><br><span class="hljs-comment">#code2</span><br>...<br><span class="hljs-keyword">if</span> self.have_cs <span class="hljs-keyword">and</span> (first <span class="hljs-keyword">or</span> (self.matched &amp; (<span class="hljs-number">0b1</span> &lt;&lt; self.have_cs))):<br>    ....<br>...<br></code></pre></td></tr></table></figure><p>self.has_channel返回的值似乎是对应通道的值，比如这里返回的应该是3.</p><h1 id="一些奇怪的问题"><a href="#一些奇怪的问题" class="headerlink" title="一些奇怪的问题"></a>一些奇怪的问题</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">xxxxx</span>(<span class="hljs-params">self</span>):<br>    logging.info(<span class="hljs-string">&#x27;----- xxx start -----&#x27;</span>)<br>    data = <span class="hljs-number">0</span><br>    bit_count = <span class="hljs-number">5</span><br><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        pin_state = self.wait( [&#123;<span class="hljs-number">0</span>: <span class="hljs-string">&#x27;r&#x27;</span>&#125;, &#123;<span class="hljs-string">&#x27;skip&#x27;</span>: self.freq_half_samp &#125;] )<br>        <span class="hljs-keyword">if</span>( self.matched &amp; (<span class="hljs-number">0b1</span> &lt;&lt; <span class="hljs-number">0</span>) ):        <span class="hljs-comment">#r</span><br>            self.LS_2 |= <span class="hljs-number">0b0</span> &lt;&lt; bit_count<br>            self.wait( [&#123;<span class="hljs-string">&#x27;skip&#x27;</span>: (self.bit_samp-self.freq_quarter_samp) &#125;] )<br>        <span class="hljs-keyword">else</span>:<br>            self.LS_2 |= <span class="hljs-number">0b1</span> &lt;&lt; bit_count<br>            self.wait( [&#123;<span class="hljs-string">&#x27;skip&#x27;</span>: (self.bit_samp-self.freq_half_samp) &#125;] )<br>        <span class="hljs-keyword">if</span>( bit_count == <span class="hljs-number">0</span> ):<br>            <span class="hljs-keyword">break</span><br>        bit_count -= <span class="hljs-number">1</span><br>    logging.info(<span class="hljs-string">&#x27;----- xxx end -----&#x27;</span>)<br>    <span class="hljs-keyword">return</span> data<br><br><br></code></pre></td></tr></table></figure><p>注意到<code>pin_state = self.wait( [&#123;0: &#39;r&#39;&#125;, &#123;&#39;skip&#39;: self.freq_half_samp &#125;] )</code>语句，把pin_state删掉就可以正常运行，若没删if后面的self.wait就会一直出问题。</p><ul><li>原因应该是pin_state没打括号，pin_state变成了元组，所以出现这种情况</li></ul><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="一些快速处理数据的方法"><a href="#一些快速处理数据的方法" class="headerlink" title="一些快速处理数据的方法"></a>一些快速处理数据的方法</h2><ul><li>快速计算奇偶校验</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ones = <span class="hljs-built_in">bin</span>(<span class="hljs-number">0x55</span>).count(<span class="hljs-string">&#x27;1&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li>BCD转成整数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">bcd2int</span>(<span class="hljs-params">b</span>):<br>    <span class="hljs-keyword">return</span> (b &amp; <span class="hljs-number">0x0f</span>) + ((b &gt;&gt; <span class="hljs-number">4</span>) * <span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><ul><li>一种将总线引脚序列转换为数字值的好方法：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">reduce_bus</span>(<span class="hljs-params">bus</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-number">0xFF</span> <span class="hljs-keyword">in</span> bus:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span> <span class="hljs-comment"># unassigned bus channels</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> reduce(<span class="hljs-keyword">lambda</span> a, b: (a &lt;&lt; <span class="hljs-number">1</span>) | b, <span class="hljs-built_in">reversed</span>(bus))<br></code></pre></td></tr></table></figure><ul><li>根据协议命令构造方法名的一个好方法是(假设cmd是8，这将调用self.handle_cmd_0x08函数):</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">fn = <span class="hljs-built_in">getattr</span>(self, <span class="hljs-string">&#x27;handle_cmd_0x%02x&#x27;</span> % cmd);<br>fn(arg1, arg2, ...)<br></code></pre></td></tr></table></figure><ul><li>一种处理Python缺少枚举类型(对状态、pin索引、注释索引等有用)的方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cycle</span>:<br>    NONE, MEMRD, MEMWR, IORD, IOWR, FETCH, INTACK = <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dslogic</tag>
      
      <tag>逻辑分析仪</tag>
      
      <tag>pyhton</tag>
      
      <tag>decoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>给正在准备蓝桥杯的你</title>
    <link href="/2020/a2d461a8/"/>
    <url>/2020/a2d461a8/</url>
    
    <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>以前参加过单片机和嵌入式的蓝桥，比赛虽然水但是还是可以锻炼个人能力的。<br>个人是在大二接触到这个比赛的，当时因为种种原因没能进入我们学校的电子协会，所以全程比赛都是一个人在准备，四处碰壁无比艰辛。学校报名结束了我才知道这个比赛(已经快寒假了我才了解到有这个比赛)，最后是以个人名义(比赛分为学校统一报名和个人报名，都一样的，只是谁给你交报名费的区别)自己交钱报名参赛的。也挺感谢这个比赛的，能力的提升我自己感觉还是有的，xxx不是经常说以赛促学么不是，哈哈哈哈。<br>在CSDN里面写了些准备比赛的笔记，还有一些自己做赛题的时候码的代码，贴出来给大家一个参考，也算为后来者提供一丝的帮助吧。<br>对了我是参加的第<strong>九届单片机组</strong>，第十届嵌入式的，这些往后届的赛题我也没做，哈哈哈。</p><h1 id="关于代码："><a href="#关于代码：" class="headerlink" title="关于代码："></a>关于代码：</h1><p><strong>代码都是准备比赛的时候写的，代码风格不一定很好但是代码都把该实现的功能都实现了，也还请见谅吧。</strong></p><h1 id="关于准备比赛："><a href="#关于准备比赛：" class="headerlink" title="关于准备比赛："></a>关于准备比赛：</h1><p>准备比赛的话，其实没什么诀窍的。我本人的话“上去就是码”，代码要多写！一定要多码，一定要多码，一定要多码。多码代码，多想其他实现方法，做多了速度就上去了，套路也摸清了，<br>自然也能取得自己满意的成绩。</p><h1 id="联系："><a href="#联系：" class="headerlink" title="联系："></a>联系：</h1><p><a href="mailto:&#x6f;&#105;&#x6b;&#105;&#111;&#117;&#64;&#x6f;&#117;&#116;&#108;&#x6f;&#111;&#107;&#x2e;&#99;&#111;&#x6d;">&#x6f;&#105;&#x6b;&#105;&#111;&#117;&#64;&#x6f;&#117;&#116;&#108;&#x6f;&#111;&#107;&#x2e;&#99;&#111;&#x6d;</a><br>虽然我已经工作了。如果你有问题的话，也欢迎来找我，虽然我可能也不太会了。希望能对看本文的你有所帮助，最后祝大家都能从比赛中提高自己的能力！</p><h1 id="笔记："><a href="#笔记：" class="headerlink" title="笔记："></a>笔记：</h1><p>蓝桥杯嵌入式入门学习笔记    <a href="https://blog.csdn.net/weixin_42078116/article/details/87890491">https://blog.csdn.net/weixin_42078116/article/details/87890491</a><br>蓝桥杯单片机组 比赛笔记    <a href="https://blog.csdn.net/weixin_42078116/article/details/80165089">https://blog.csdn.net/weixin_42078116/article/details/80165089</a><br>蓝桥杯嵌入式国赛扩展板 CT117E-EX 学习笔记    <a href="https://blog.csdn.net/weixin_42078116/article/details/90905706">https://blog.csdn.net/weixin_42078116/article/details/90905706</a></p><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><p>单片机的好像忘记了传，我待会传一下，可以去我的下载里面找。<br>蓝桥杯嵌入式省赛所有赛题代码.7z    <a href="https://download.csdn.net/download/weixin_42078116/11227537">https://download.csdn.net/download/weixin_42078116/11227537</a><br>蓝桥杯嵌入式省赛及国赛所有赛题代码.7z    <a href="https://download.csdn.net/download/weixin_42078116/11227496">https://download.csdn.net/download/weixin_42078116/11227496</a>    </p>]]></content>
    
    
    <categories>
      
      <category>life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言高质量编程</title>
    <link href="/2019/b0d7d162/"/>
    <url>/2019/b0d7d162/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言高质量编程"><a href="#C语言高质量编程" class="headerlink" title="C语言高质量编程"></a>C语言高质量编程</h1><h1 id="1-2-头文件的结构"><a href="#1-2-头文件的结构" class="headerlink" title="1.2 头文件的结构"></a>1.2 头文件的结构</h1><ol><li>头文件开头处的版权和版本声明（参见示例1-1）。</li><li>预处理块。</li><li>函数和类结构声明等。</li></ol><p>假设头文件名称为 <code>graphics.h</code>，头文件的结构参见下面。</p><ul><li>【规则1-2-1】为了防止头文件被重复引用，应当用<code>ifndef/define/endif</code> 结构产生预处理块。</li><li>【规则 1-2-2】用<code>#include &lt;filename.h&gt;</code> 格式来引用标准库的头文件（编译器将从标准库目录开始搜索）。</li><li>【规则1-2-3】用<code>#include “filename.h”</code> 格式来引用非标准库的头文件（编译器将从用户的工作目录开始搜索）。</li><li>【建议1-2-1】头文件中只存放“声明”而不存放“定义”在 C++ 语法中，类的成员函数可以在声明的同时被定义，并且自动成为内联函数。这虽然会带来书写上的方便，但却造成了风格不一致，弊大于利。建议将成员函数的定义与声明分开，不论该函数体有多么小。</li><li>【建议1-2-2】不提倡使用全局变量，尽量不要在头文件中出现象extern int value 这类声明。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> GRAPHICS_H <span class="hljs-comment">// 防止graphics.h 被重复引用</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GRAPHICS_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span> <span class="hljs-comment">// 引用标准库的头文件</span></span><br>⋯<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> “myheader.h” <span class="hljs-comment">// 引用非标准库的头文件</span></span><br>⋯<br><span class="hljs-type">void</span> <span class="hljs-title function_">Function1</span><span class="hljs-params">(⋯)</span>; <span class="hljs-comment">// 全局函数声明</span><br>⋯<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Box</span> // 类结构声明</span><br><span class="hljs-class">&#123;</span><br>⋯<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h1 id="1-3-定义文件的结构"><a href="#1-3-定义文件的结构" class="headerlink" title="1.3 定义文件的结构"></a>1.3 定义文件的结构</h1><p>定义文件有三部分内容：</p><ol><li>定义文件开头处的版权和版本声明（参见示例1-1）。</li><li>对一些头文件的引用。</li><li>程序的实现体（包括数据和代码）。<br>假设定义文件的名称为 graphics.cpp，定义文件的结构参见下面。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> “graphics.h” <span class="hljs-comment">// 引用头文件</span></span><br>⋯<br><span class="hljs-comment">// 全局函数的实现体</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Function1</span><span class="hljs-params">(⋯)</span><br>&#123;<br>⋯<br>&#125;<br><span class="hljs-comment">// 类成员函数的实现体</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Box::Draw</span><span class="hljs-params">(⋯)</span><br>&#123;<br>⋯<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="2-1-空行"><a href="#2-1-空行" class="headerlink" title="2.1 空行"></a>2.1 空行</h1><p>空行起着分隔程序段落的作用。空行得体（不过多也不过少）将使程序的布局更加清晰。空行不会浪费内存，虽然打印含有空行的程序是会多消耗一些纸张，但是值得。所以不要舍不得用空行。</p><ul><li>【规则 2-1-1】在每个类声明之后、每个函数定义结束之后都要加空行。参见示例2-1（a）</li><li>【规则2-1-2】在一个函数体内，逻揖上密切相关的语句之间不加空行，其它地方应加空行分隔</li></ul><h1 id="2-2-代码行"><a href="#2-2-代码行" class="headerlink" title="2.2 代码行"></a>2.2 代码行</h1><ul><li>【规则2-2-1】<strong>一行代码只做一件事情</strong>，<strong>如只定义一个变量</strong>，或只写一条语句。这样的代码容易阅读，并且方便于写注释。</li><li>【规则2-2-2】if、for、while、do 等语句自占一行，执行语句不得紧跟其后。**不论执行语句有多少都要加{}**。这样可以防止书写失误。</li></ul><h1 id="2-3-代码行内的空格"><a href="#2-3-代码行内的空格" class="headerlink" title="2.3 代码行内的空格"></a>2.3 代码行内的空格</h1><ul><li>【规则2-3-1】关键字之后要留空格。象const、virtual、inline、case 等关键字之后至少要留一个空格，否则无法辨析关键字。象if、for、while 等关键字之后应留一个空格再跟左括号‘（’，以突出关键字。</li><li>【规则2-3-2】函数名之后不要留空格，紧跟左括号‘（’，以与关键字区别。</li><li><strong>【规则2-3-3】</strong>‘（’向后紧跟，‘）’、‘，’、‘;’ 向前紧跟，<strong>紧跟处不留空格。</strong></li><li><strong>【规则2-3-4】</strong>‘，’之后要留空格，如<code>Function(x,  y,  z)</code>。如果‘;’不是一行的结束符号，其后要留空格，如<code>for (initialization;  condition;  update)</code>。</li><li>【规则2-3-5】赋值操作符、比较操作符、算术操作符、逻辑操作符、位域操作符，如“&#x3D;”、“+&#x3D;” “&gt;&#x3D;”、“&lt;&#x3D;”、“+”、“*”、“%”、“&amp;&amp;”、“||”、“&lt;&lt;”,“^”等二元操作符的前后应当加空格。</li><li>【规则2-3-6】一元操作符如“!”、“~”、“++”、“–”、“&amp;”（地址运算符）等前后不加空格。</li><li>【规则2-3-7】xu“［］”、“.”、“-&gt;”这类操作符前后不加空格。</li><li>【建议2-3-1】对于表达式比较长的for 语句和if 语句，为了紧凑起见可以适当地去掉一些空格，如<code>for (i=0; i&lt;10; i++)和if ((a&lt;=b) &amp;&amp; (c&lt;=d))</code></li></ul><h1 id="2-4-对齐"><a href="#2-4-对齐" class="headerlink" title="2.4 对齐"></a>2.4 对齐</h1><ul><li>【规则2-4-1】程序的分界符‘{’和‘}’应独占一行并且位于同一列，同时与引用它们的语句左对齐。</li><li>【规则2-4-2】{ }之内的代码块在‘{’右边数格处左对齐。</li></ul><h1 id="2-5-长行拆分"><a href="#2-5-长行拆分" class="headerlink" title="2.5 长行拆分"></a>2.5 长行拆分</h1><ul><li>【规则2-5-1】代码行最大长度宜控制在70 至80 个字符以内。代码行不要过长，否则眼睛看不过来，也不便于打印。</li><li>【规则2-5-2】长表达式要在低优先级操作符处拆分成新行，操作符放在新行之首（以便突出操作符）。拆分出的新行要进行适当的缩进，使排版整齐，语句可读。</li></ul><h1 id="2-6-修饰符的位置"><a href="#2-6-修饰符的位置" class="headerlink" title="2.6 修饰符的位置"></a>2.6 修饰符的位置</h1><p>修饰符 * 和＆ 应该靠近数据类型还是该靠近变量名，是个有争议的活题。若将修饰符 * 靠近数据类型，例如：int*  x; 从语义上讲此写法比较直观，即x是int 类型的指针。上述写法的弊端是容易引起误解，例如：int*  x, y; 此处y 容易被误解为指针变量。虽然将x 和y 分行定义可以避免误解，但并不是人人都愿意这样做。</p><ul><li>【规则2-6-1】应当将修饰符 * 和＆ 紧靠变量名</li></ul><h1 id="2-7-注释"><a href="#2-7-注释" class="headerlink" title="2.7 注释"></a>2.7 注释</h1><p>C 语言的注释符为“&#x2F;<em>…</em>&#x2F;”。C++语言中，程序块的注释常采用“&#x2F;<em>…</em>&#x2F;”，行注释一般采用“&#x2F;&#x2F;…”。注释通常用于：<br>（1）版本、版权声明；<br>（2）函数接口说明；<br>（3）重要的代码行或段落提示。<br>虽然注释有助于理解代码，但注意不可过多地使用注释。<br>【规则2-7-1】注释是对代码的“提示”，而不是文档。程序中的注释不可喧宾夺主，注释太多了会让人眼花缭乱。注释的花样要少。<br>【规则2-7-2】如果代码本来就是清楚的，则不必加注释。否则多此一举，令人厌烦。例如i++; &#x2F;&#x2F; i 加 1，多余的注释<br>【规则2-7-3】边写代码边注释，修改代码同时修改相应的注释，以保证注释与代码的一致性。不再有用的注释要删除。<br>【规则2-7-4】注释应当准确、易懂，防止注释有二义性。错误的注释不但无益反而有害。<br>【规则2-7-5】尽量避免在注释中使用缩写，特别是不常用缩写。<br>【规则2-7-6】注释的位置应与被描述的代码相邻，可以放在代码的上方或右方，不可放在下方。<br><strong>【规则2-7-8】</strong>当代码比较长，特别是有多重嵌套时，应当在一些段落的结束处加注释，便于阅读。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 函数介绍：</span><br><span class="hljs-comment">* 输入参数：</span><br><span class="hljs-comment">* 输出参数：</span><br><span class="hljs-comment">* 返回值：</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Function</span><span class="hljs-params">(<span class="hljs-type">float</span> x, <span class="hljs-type">float</span> y, <span class="hljs-type">float</span> z)</span><br>&#123;<br>    …<br>&#125;<br><br><span class="hljs-keyword">if</span> (…)<br>&#123;<br>    …<br>    <span class="hljs-keyword">while</span> (…)<br>    &#123;<br>        …<br>    &#125; <span class="hljs-comment">// end of while</span><br>    …<br>&#125; <span class="hljs-comment">// end of if</span><br><br></code></pre></td></tr></table></figure><h1 id="3-2-简单的单片机应用程序命名规则"><a href="#3-2-简单的单片机应用程序命名规则" class="headerlink" title="3.2 简单的单片机应用程序命名规则"></a>3.2 简单的单片机应用程序命名规则</h1><ol><li>函数名用大写字母开头的单词组合而成。<br>例如：<br>void Draw(void); &#x2F;&#x2F; 函数名<br>void Setvalue(int value); &#x2F;&#x2F; 函数名</li><li>变量和参数用小写字母开头的单词组合而成，float 变量名前加 f，int 变量名前加 i，bit变量前加 b 。（char 不加）<br>例如：<br>bit b_tirm;<br>int i_time;<br>float f_time;<br>char time;</li><li>常量、宏定义（DF_xxx）全用大写的字母，用下划线分割单词。<br>例如：<br>code char MAX &#x3D; 100;<br>#define DF_MAX 100</li></ol><h1 id="4-3-if-语句"><a href="#4-3-if-语句" class="headerlink" title="4.3 if 语句"></a>4.3 if 语句</h1><h2 id="4-3-1-布尔变量与零值比较"><a href="#4-3-1-布尔变量与零值比较" class="headerlink" title="4.3.1 布尔变量与零值比较"></a>4.3.1 布尔变量与零值比较</h2><p>【规则4-3-1】不可将布尔变量直接与TRUE、FALSE 或者1、0 进行比较。根据布尔类型的语义，零值为“假”（记为FALSE），任何非零值都是“真”（记为TRUE）。TRUE 的值究竟是什么并没有统一的标准。例如Visual C++ 将TRUE 定义为</p><p>1，而Visual Basic 则将TRUE 定义为-1。</p><p>假设布尔变量名字为flag，它与零值比较的标准if 语句如下：</p><p>if (flag) &#x2F;&#x2F; 表示flag 为真</p><p>if (!flag) &#x2F;&#x2F; 表示flag 为假</p><p>其它的用法都属于不良风格，例如：<br>if (flag &#x3D;&#x3D; TRUE)<br>if (flag &#x3D;&#x3D; 1 )<br>if (flag &#x3D;&#x3D; FALSE)</p><p>if (flag &#x3D;&#x3D; 0)</p><h2 id="4-3-2-整型变量与零值比较"><a href="#4-3-2-整型变量与零值比较" class="headerlink" title="4.3.2 整型变量与零值比较"></a>4.3.2 整型变量与零值比较</h2><p>【规则4-3-2】应当将整型变量用“&#x3D;&#x3D;”或“！&#x3D;”直接与0 比较。<br>假设整型变量的名字为value，它与零值比较的标准if 语句如下：<br>if (value &#x3D;&#x3D; 0)<br>if (value !&#x3D; 0)<br>不可模仿布尔变量的风格而写成<br>if (value) &#x2F;&#x2F; 会让人误解 value 是布尔变量</p><p>if (!value)</p><h2 id="4-3-3-浮点变量与零值比较"><a href="#4-3-3-浮点变量与零值比较" class="headerlink" title="4.3.3 浮点变量与零值比较"></a>4.3.3 浮点变量与零值比较</h2><p>【规则4-3-3】不可将浮点变量用“&#x3D;&#x3D;”或“！&#x3D;”与任何数字比较。千万要留意，无论是float 还是double 类型的变量，都有精度限制。所以一定要避免将浮点变量用“&#x3D;&#x3D;”或“！&#x3D;”与数字比较，应该设法转化成“&gt;&#x3D;”或“&lt;&#x3D;”形式。</p><p>假设浮点变量的名字为x，应当将</p><p>if (x &#x3D;&#x3D; 0.0) &#x2F;&#x2F; 隐含错误的比较<br>转化为<br>if ((x&gt;&#x3D;-EPSINON) &amp;&amp; (x&lt;&#x3D;EPSINON))</p><p>其中EPSINON 是允许的误差（即精度）。</p><h3 id="4-3-4-指针变量与零值比较"><a href="#4-3-4-指针变量与零值比较" class="headerlink" title="4.3.4 指针变量与零值比较"></a>4.3.4 指针变量与零值比较</h3><p>【规则4-3-4】应当将指针变量用“&#x3D;&#x3D;”或“！&#x3D;”与NULL 比较。指针变量的零值是“空”（记为NULL）。尽管NULL 的值与0 相同，但是两者意义不同。假设指针变量的名字为p，它与零值比较的标准if 语句如下：</p><p>if (p &#x3D;&#x3D; NULL) &#x2F;&#x2F; p 与NULL 显式比较，强调p 是指针变量</p><p>if (p !&#x3D; NULL)<br>不要写成<br>if (p &#x3D;&#x3D; 0) &#x2F;&#x2F; 容易让人误解p 是整型变量<br>if (p !&#x3D; 0)<br>或者<br>if (p) &#x2F;&#x2F; 容易让人误解p 是布尔变量</p><p>if (!p)</p><h3 id="4-3-5-对if-语句的补充说明"><a href="#4-3-5-对if-语句的补充说明" class="headerlink" title="4.3.5 对if 语句的补充说明"></a>4.3.5 对if 语句的补充说明</h3><p>有时候我们可能会看到 if (NULL &#x3D;&#x3D; p) 这样古怪的格式。不是程序写错了，是程序员为了防止将 if (p &#x3D;&#x3D; NULL) 误写成 if (p &#x3D; NULL)，而有意把p 和NULL 颠倒。编译器认为 if (p &#x3D; NULL) 是合法的，但是会指出 if (NULL &#x3D; p)是错误的，因为NULL不能被赋值。</p><h1 id="4-4-循环语句的效率"><a href="#4-4-循环语句的效率" class="headerlink" title="4.4 循环语句的效率"></a>4.4 循环语句的效率</h1><p>【建议4-4-1】在多重循环中，如果有可能，应当将最长的循环放在最内层，最短的循环放在最外层，以减少CPU 跨切循环层的次数。例如示例4-4(b)的效率比示例4-4(a)的高。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 示例 4-4(a) 低效率：长循环在最外层 </span><br><span class="hljs-keyword">for</span> (row=<span class="hljs-number">0</span>; row&lt;<span class="hljs-number">100</span>; row++)<br>&#123;<br>    <span class="hljs-keyword">for</span> ( col=<span class="hljs-number">0</span>; col&lt;<span class="hljs-number">5</span>; col++ )<br>    &#123;<br>        sum = sum + a[row][col];<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 示例4-4(b) 高效率：长循环在最内层</span><br><span class="hljs-keyword">for</span> (col=<span class="hljs-number">0</span>; col&lt;<span class="hljs-number">5</span>; col++ )<br>&#123;<br>    <span class="hljs-keyword">for</span> (row=<span class="hljs-number">0</span>; row&lt;<span class="hljs-number">100</span>; row++)<br>    &#123;<br>        sum = sum + a[row][col];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>【建议4-4-2】如果循环体内存在逻辑判断，并且循环次数很大，宜将逻辑判断移到循环体的外面。示例4-4(c)的程序比示例4-4(d)多执行了N-1 次逻辑判断。并且由于前者老要进行逻辑判断，打断了循环“流水线”作业，使得编译器不能对循环进行优化处理，降低了效率。如果N 非常大，最好采用示例4-4(d)的写法，可以提高效率。如果N 非常小，两者效率差别并不明显，采用示例4-4(c)的写法比较好，因为程序更加简洁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 效率低但程序简洁</span><br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;N; i++)<br>&#123;<br>    <span class="hljs-keyword">if</span> (condition)<br>        DoSomething();<br>    <span class="hljs-keyword">else</span><br>        DoOtherthing();<br>&#125;<br><span class="hljs-comment">// 效率高但程序不简洁</span><br><span class="hljs-keyword">if</span> (condition)<br>&#123;<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;N; i++)<br>        DoSomething();<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;N; i++)<br>        DoOtherthing();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="4-5-for-语句的循环控制变量"><a href="#4-5-for-语句的循环控制变量" class="headerlink" title="4.5 for 语句的循环控制变量"></a>4.5 for 语句的循环控制变量</h1><p>【规则4-5-1】不可在for 循环体内修改循环变量，防止for 循环失去控制。<br>【建议4-5-1】建议for 语句的循环控制变量的取值采用“半开半闭区间”写法。<br>示例 4-5(a)中的x 值属于半开半闭区间“0 &#x3D;&lt; x &lt; N”，起点到终点的间隔为N，循环次数为N。<br>示例 4-5(b)中的x 值属于闭区间“0 &#x3D;&lt; x &lt;&#x3D; N-1”，起点到终点的间隔为N-1，循环次数为N。</p><p>相比之下，示例4-5(a)的写法更加直观，尽管两者的功能是相同的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 循环变量属于半开半闭区间 </span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>; x&lt;N; x++)<br>&#123;<br>    ⋯<br>&#125;<br><span class="hljs-comment">// 循环变量属于闭区间</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>; x&lt;=N<span class="hljs-number">-1</span>; x++)<br>&#123;<br>    ⋯<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="4-6-switch-语句"><a href="#4-6-switch-语句" class="headerlink" title="4.6 switch 语句"></a>4.6 switch 语句</h1><p>【规则4-6-1】每个case 语句的结尾不要忘了加break，否则将导致多个分支重叠（除非有意使多个分支重叠）。<br>【规则4-6-2】不要忘记最后那个default 分支。即使程序真的不需要default 处理，也应该保留语句 default : break; 这样做并非多此一举，而是为了防止别人误以为你忘了default 处理。</p><h1 id="4-7-goto-语句"><a href="#4-7-goto-语句" class="headerlink" title="4.7 goto 语句"></a>4.7 goto 语句</h1><p>自从提倡结构化设计以来，goto 就成了有争议的语句。首先，由于goto 语句可以灵活跳转，如果不加限制，它的确会破坏结构化设计风格。其次，goto 语句经常带来错误或隐患。它可能跳过了某些对象的构造、变量的初始化、重要的计算等语句，例如：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pf">goto <span class="hljs-keyword">state</span>;<br>String s1, s2; // 被goto 跳过<br>int sum = <span class="hljs-number">0</span>; // 被goto 跳过<br>⋯<br><span class="hljs-keyword">state</span>:<br>⋯<br></code></pre></td></tr></table></figure><p>所以我们主张少用、慎用goto 语句，而不是禁用。</p><h1 id="5-1-为什么需要常量"><a href="#5-1-为什么需要常量" class="headerlink" title="5.1 为什么需要常量"></a>5.1 为什么需要常量</h1><p>如果不使用常量，直接在程序中填写数字或字符串，将会有什么麻烦？<br>（1） 程序的可读性（可理解性）变差。程序员自己会忘记那些数字或字符串是什么意思，用户则更加不知它们从何处来、表示什么。<br>（2） 在程序的很多地方输入同样的数字或字符串，难保不发生书写错误。</p><p>（3） 如果要修改数字或字符串，则会在很多地方改动，既麻烦又容易出错。</p><p>【规则5-1-1】尽量使用含义直观的常量来表示那些将在程序中多次出现的数字或字符串。</p><h1 id="5-2-const-与-define-的比较"><a href="#5-2-const-与-define-的比较" class="headerlink" title="5.2 const 与 #define 的比较"></a>5.2 const 与 #define 的比较</h1><p>C++ 语言可以用const 来定义常量，也可以用 #define 来定义常量。但是前者比后者有更多的优点：<br>（1） const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误（边际效应）。</p><p>（2） 有些集成化的调试工具可以对 const 常量进行调试，但是不能对宏常量进行调试。</p><p>【规则5-2-1】在C++ 程序中只使用const 常量而不使用宏常量，即const 常量完全取代宏常量</p><h1 id="5-3-常量定义规则"><a href="#5-3-常量定义规则" class="headerlink" title="5.3 常量定义规则"></a>5.3 常量定义规则</h1>]]></content>
    
    
    <categories>
      
      <category>language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PID算法</title>
    <link href="/2019/14ee3806/"/>
    <url>/2019/14ee3806/</url>
    
    <content type="html"><![CDATA[<h2 id="PID算法笔记"><a href="#PID算法笔记" class="headerlink" title="PID算法笔记"></a>PID算法笔记</h2><p>位式控制算法，只考虑当前值，控制量有惯性，比较僵硬</p><h3 id="P–比例算法"><a href="#P–比例算法" class="headerlink" title="P–比例算法"></a>P–比例算法</h3><ul><li>只考虑现在的误差</li></ul><p>E<sub>k</sub> &#x3D; S<sub>V</sub> - X<sub>k</sub>(E<sub>k</sub>差值  S<sub>v</sub>期望值  X<sub>k</sub>当前值)</p><p>单纯的P控制算法：P<sub>out</sub>&#x3D;K<sub>p</sub> * E<sub>k</sub> ( P<sub>out</sub>输出的控制量  K<sub>p</sub>控制量  E<sub>k</sub>差值)</p><p><strong>单纯的P控制算法当前误差等于零后不控制</strong></p><p>P<sub>out</sub>&#x3D;K<sub>p</sub> * E<sub>k</sub>+OUT<sub>0</sub>(OUT<sub>0</sub>是一个常数维持静态误差)</p><hr><h3 id="I–积分算法"><a href="#I–积分算法" class="headerlink" title="I–积分算法"></a>I–积分算法</h3><ul><li>根据历史误差控制</li></ul><p>E<sub>1</sub>, E<sub>2</sub>, E<sub>3</sub>, E<sub>4</sub>, E<sub>5</sub>, ……….. E<sub>k</sub>  (E<sub>k</sub>差值)</p><p>S<sub>k</sub>&#x3D;E<sub>1</sub>+ E<sub>2</sub>+ E<sub>3</sub>+ E<sub>4</sub>+ E<sub>5</sub>+ ……….. +E<sub>k</sub>    (S<sub>k</sub> 误差和即积分)</p><p>I<sub>out</sub>&#x3D;K<sub>p</sub> * S<sub>k</sub> (I<sub>out</sub>输出的控制量  K<sub>p</sub>控制量)</p><p><strong>单纯的I控制算法历史误差等于零后不控制（当前误差可能很大）</strong></p><p>I<sub>out</sub>&#x3D;K<sub>p</sub> * S<sub>k</sub> +OUT<sub>0</sub>(OUT<sub>0</sub>是一个常数维持静态误差)</p><hr><h3 id="D–微分算法"><a href="#D–微分算法" class="headerlink" title="D–微分算法"></a>D–微分算法</h3><ul><li>考察最近变化趋势进行控制</li></ul><p>D<sub>k</sub>&#x3D;E<sub>k</sub> - E<sub>k-1</sub></p><p>D<sub>out</sub>&#x3D;K<sub>p</sub> * D<sub>k</sub> </p><hr><hr><hr><h2 id="Proportion-比例"><a href="#Proportion-比例" class="headerlink" title="Proportion (比例)"></a>Proportion (比例)</h2><p>误差越大，反馈越大</p><p>过小时系统反应很慢，过大时会产生振荡</p><ul><li>开环增益越大，稳态误差减小（无法消除，属于有差调节）</li><li>过渡时间缩短</li><li>稳定程度变差</li></ul><h2 id="Integral（积分）"><a href="#Integral（积分）" class="headerlink" title="Integral（积分）"></a>Integral（积分）</h2><p>误差持续越久，反馈越大</p><p>第一次到达目标会产生过冲，超调</p><p>积分求位置误差</p><ul><li>消除系统稳态误差（能够消除静态误差，属于无差调节）</li><li>稳定程度变差</li></ul><h2 id="Differential（微分）"><a href="#Differential（微分）" class="headerlink" title="Differential（微分）"></a>Differential（微分）</h2><p>误差变化率越大，反馈越大</p><p>根据以前的变化率预测未来的变化率</p><p>过大时会拖慢系统响应速度</p><p>提高响应速度，减少震荡</p><ul><li>减小超调量</li><li>减小调节时间（与P控制相比较而言）</li><li>增强系统稳定性</li><li>增加系统阻尼程度</li></ul><h2 id="PID总结"><a href="#PID总结" class="headerlink" title="PID总结"></a>PID总结</h2><ul><li><strong>稳定性</strong>（P和I降低系统稳定性，D提高系统稳定性）：在平衡状态下，系统受到某个干扰后，经过一段时间其被控量可以达到某一稳定状态；</li><li><strong>准确性</strong>（P和I提高稳态精度，D无作用）：系统处于稳态时，其稳态误差；</li><li><strong>快速性</strong>（P和D提高响应速度，I降低响应速度）：系统对动态响应的要求。一般由过渡时间的长短来衡量。</li></ul>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构</title>
    <link href="/2019/79666db/"/>
    <url>/2019/79666db/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="C语言打印运行时间"><a href="#C语言打印运行时间" class="headerlink" title="C语言打印运行时间"></a>C语言打印运行时间</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;time.h&gt;</span></span><br><span class="hljs-type">time_t</span> start, stop;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    start = clock();<span class="hljs-comment">//滴答时钟</span><br>    <span class="hljs-comment">//运行的函数</span><br>    stop = clock();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf----%lf\r\n&quot;</span>, (<span class="hljs-type">double</span>)(stop-start),(<span class="hljs-type">double</span>)(stop-start)/CLK_TCK);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="尾递归可以优化成For"><a href="#尾递归可以优化成For" class="headerlink" title="尾递归可以优化成For"></a>尾递归可以优化成For</h2><p>尾递归：程序返回时才发生递归。</p><h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h2 id="1-3-应用实例：最大子列和问题"><a href="#1-3-应用实例：最大子列和问题" class="headerlink" title="1.3 应用实例：最大子列和问题"></a>1.3 应用实例：最大子列和问题</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">Max3</span><span class="hljs-params">( <span class="hljs-type">int</span> A, <span class="hljs-type">int</span> B, <span class="hljs-type">int</span> C )</span><br>&#123; <span class="hljs-comment">/* 返回3个整数中的最大值 */</span><br>    <span class="hljs-keyword">return</span> A &gt; B ? A &gt; C ? A : C : B &gt; C ? B : C;<br>&#125;<br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">DivideAndConquer</span><span class="hljs-params">( <span class="hljs-type">int</span> List[], <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right )</span><br>&#123; <span class="hljs-comment">/* 分治法求List[left]到List[right]的最大子列和 */</span><br>    <span class="hljs-type">int</span> MaxLeftSum, MaxRightSum; <span class="hljs-comment">/* 存放左右子问题的解 */</span><br>    <span class="hljs-type">int</span> MaxLeftBorderSum, MaxRightBorderSum; <span class="hljs-comment">/*存放跨分界线的结果*/</span><br> <br>    <span class="hljs-type">int</span> LeftBorderSum, RightBorderSum;<br>    <span class="hljs-type">int</span> center, i;<br> <br>    <span class="hljs-keyword">if</span>( left == right )  &#123; <span class="hljs-comment">/* 递归的终止条件，子列只有1个数字 */</span><br>        <span class="hljs-keyword">if</span>( List[left] &gt; <span class="hljs-number">0</span> )  <span class="hljs-keyword">return</span> List[left];<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br> <br>    <span class="hljs-comment">/* 下面是&quot;分&quot;的过程 */</span><br>    center = ( left + right ) / <span class="hljs-number">2</span>; <span class="hljs-comment">/* 找到中分点 */</span><br>    <span class="hljs-comment">/* 递归求得两边子列的最大和 */</span><br>    MaxLeftSum = DivideAndConquer( List, left, center );<br>    MaxRightSum = DivideAndConquer( List, center+<span class="hljs-number">1</span>, right );<br> <br>    <span class="hljs-comment">/* 下面求跨分界线的最大子列和 */</span><br>    MaxLeftBorderSum = <span class="hljs-number">0</span>; LeftBorderSum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>( i=center; i&gt;=left; i-- ) &#123; <span class="hljs-comment">/* 从中线向左扫描 */</span><br>        LeftBorderSum += List[i];<br>        <span class="hljs-keyword">if</span>( LeftBorderSum &gt; MaxLeftBorderSum )<br>            MaxLeftBorderSum = LeftBorderSum;<br>    &#125; <span class="hljs-comment">/* 左边扫描结束 */</span><br> <br>    MaxRightBorderSum = <span class="hljs-number">0</span>; RightBorderSum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>( i=center+<span class="hljs-number">1</span>; i&lt;=right; i++ ) &#123; <span class="hljs-comment">/* 从中线向右扫描 */</span><br>        RightBorderSum += List[i];<br>        <span class="hljs-keyword">if</span>( RightBorderSum &gt; MaxRightBorderSum )<br>            MaxRightBorderSum = RightBorderSum;<br>    &#125; <span class="hljs-comment">/* 右边扫描结束 */</span><br> <br>    <span class="hljs-comment">/* 下面返回&quot;治&quot;的结果 */</span><br>    <span class="hljs-keyword">return</span> Max3( MaxLeftSum, MaxRightSum, MaxLeftBorderSum + MaxRightBorderSum );<br>&#125;<br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">MaxSubseqSum3</span><span class="hljs-params">( <span class="hljs-type">int</span> List[], <span class="hljs-type">int</span> N )</span><br>&#123; <span class="hljs-comment">/* 保持与前2种算法相同的函数接口 */</span><br>    <span class="hljs-keyword">return</span> DivideAndConquer( List, <span class="hljs-number">0</span>, N<span class="hljs-number">-1</span> );<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第二章-线性结构"><a href="#第二章-线性结构" class="headerlink" title="第二章 线性结构"></a>第二章 线性结构</h1><h2 id="2-1-线性表及其实现"><a href="#2-1-线性表及其实现" class="headerlink" title="2.1 线性表及其实现"></a>2.1 线性表及其实现</h2><h3 id="数组实现"><a href="#数组实现" class="headerlink" title="数组实现"></a>数组实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Position;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">List</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> &#123;</span><br>    ElementType Data[MAXSIZE];<br>    Position Last;<br>&#125;;<br> <br><span class="hljs-comment">/* 初始化 */</span><br>List <span class="hljs-title function_">MakeEmpty</span><span class="hljs-params">()</span><br>&#123;<br>    List L;<br> <br>    L = (List)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> LNode));<br>    L-&gt;Last = <span class="hljs-number">-1</span>;<br> <br>    <span class="hljs-keyword">return</span> L;<br>&#125;<br> <br><span class="hljs-comment">/* 查找 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR -1</span><br> <br>Position <span class="hljs-title function_">Find</span><span class="hljs-params">( List L, ElementType X )</span><br>&#123;<br>    Position i = <span class="hljs-number">0</span>;<br> <br>    <span class="hljs-keyword">while</span>( i &lt;= L-&gt;Last &amp;&amp; L-&gt;Data[i]!= X )<br>        i++;<br>    <span class="hljs-keyword">if</span> ( i &gt; L-&gt;Last )  <span class="hljs-keyword">return</span> ERROR; <span class="hljs-comment">/* 如果没找到，返回错误信息 */</span><br>    <span class="hljs-keyword">else</span>  <span class="hljs-keyword">return</span> i;  <span class="hljs-comment">/* 找到后返回的是存储位置 */</span><br>&#125;<br> <br><span class="hljs-comment">/* 插入 */</span><br><span class="hljs-comment">/*注意:在插入位置参数P上与课程视频有所不同，课程视频中i是序列位序（从1开始），这里P是存储下标位置（从0开始），两者差1*/</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">Insert</span><span class="hljs-params">( List L, ElementType X, Position P )</span> <br>&#123; <span class="hljs-comment">/* 在L的指定位置P前插入一个新元素X */</span><br>    Position i;<br> <br>    <span class="hljs-keyword">if</span> ( L-&gt;Last == MAXSIZE<span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-comment">/* 表空间已满，不能插入 */</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;表满&quot;</span>); <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>    &#125;  <br>    <span class="hljs-keyword">if</span> ( P&lt;<span class="hljs-number">0</span> || P&gt;L-&gt;Last+<span class="hljs-number">1</span> ) &#123; <span class="hljs-comment">/* 检查插入位置的合法性 */</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;位置不合法&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>    &#125; <br>    <span class="hljs-keyword">for</span>( i=L-&gt;Last; i&gt;=P; i-- )<br>        L-&gt;Data[i+<span class="hljs-number">1</span>] = L-&gt;Data[i]; <span class="hljs-comment">/* 将位置P及以后的元素顺序向后移动 */</span><br>    L-&gt;Data[P] = X;  <span class="hljs-comment">/* 新元素插入 */</span><br>    L-&gt;Last++;       <span class="hljs-comment">/* Last仍指向最后元素 */</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <br>&#125; <br> <br><span class="hljs-comment">/* 删除 */</span><br><span class="hljs-comment">/*注意:在删除位置参数P上与课程视频有所不同，课程视频中i是序列位序（从1开始），这里P是存储下标位置（从0开始），两者差1*/</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">Delete</span><span class="hljs-params">( List L, Position P )</span><br>&#123; <span class="hljs-comment">/* 从L中删除指定位置P的元素 */</span><br>    Position i;<br> <br>    <span class="hljs-keyword">if</span>( P&lt;<span class="hljs-number">0</span> || P&gt;L-&gt;Last ) &#123; <span class="hljs-comment">/* 检查空表及删除位置的合法性 */</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;位置%d不存在元素&quot;</span>, P ); <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>    &#125;<br>    <span class="hljs-keyword">for</span>( i=P+<span class="hljs-number">1</span>; i&lt;=L-&gt;Last; i++ )<br>        L-&gt;Data[i<span class="hljs-number">-1</span>] = L-&gt;Data[i]; <span class="hljs-comment">/* 将位置P+1及以后的元素顺序向前移动 */</span><br>    L-&gt;Last--; <span class="hljs-comment">/* Last仍指向最后元素 */</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;   <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">PtrToLNode</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> &#123;</span><br>    ElementType Data;<br>    PtrToLNode Next;<br>&#125;;<br><span class="hljs-keyword">typedef</span> PtrToLNode Position;<br><span class="hljs-keyword">typedef</span> PtrToLNode List;<br> <br><span class="hljs-comment">/* 查找 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR NULL</span><br> <br>Position <span class="hljs-title function_">Find</span><span class="hljs-params">( List L, ElementType X )</span><br>&#123;<br>    Position p = L; <span class="hljs-comment">/* p指向L的第1个结点 */</span><br> <br>    <span class="hljs-keyword">while</span> ( p &amp;&amp; p-&gt;Data!=X )<br>        p = p-&gt;Next;<br> <br>    <span class="hljs-comment">/* 下列语句可以用 return p; 替换 */</span><br>    <span class="hljs-keyword">if</span> ( p )<br>        <span class="hljs-keyword">return</span> p;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> ERROR;<br>&#125;<br> <br><span class="hljs-comment">/* 带头结点的插入 */</span><br><span class="hljs-comment">/*注意:在插入位置参数P上与课程视频有所不同，课程视频中i是序列位序（从1开始），这里P是链表结点指针，在P之前插入新结点 */</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">Insert</span><span class="hljs-params">( List L, ElementType X, Position P )</span><br>&#123; <span class="hljs-comment">/* 这里默认L有头结点 */</span><br>    Position tmp, pre;<br> <br>    <span class="hljs-comment">/* 查找P的前一个结点 */</span>        <br>    <span class="hljs-keyword">for</span> ( pre=L; pre&amp;&amp;pre-&gt;Next!=P; pre=pre-&gt;Next ) ;            <br>    <span class="hljs-keyword">if</span> ( pre==<span class="hljs-literal">NULL</span> ) &#123; <span class="hljs-comment">/* P所指的结点不在L中 */</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;插入位置参数错误\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* 找到了P的前一个结点pre */</span><br>        <span class="hljs-comment">/* 在P前插入新结点 */</span><br>        tmp = (Position)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> LNode)); <span class="hljs-comment">/* 申请、填装结点 */</span><br>        tmp-&gt;Data = X; <br>        tmp-&gt;Next = P;<br>        pre-&gt;Next = tmp;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br> <br><span class="hljs-comment">/* 带头结点的删除 */</span><br><span class="hljs-comment">/*注意:在删除位置参数P上与课程视频有所不同，课程视频中i是序列位序（从1开始），这里P是拟删除结点指针 */</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">Delete</span><span class="hljs-params">( List L, Position P )</span><br>&#123; <span class="hljs-comment">/* 这里默认L有头结点 */</span><br>    Position tmp, pre;<br> <br>    <span class="hljs-comment">/* 查找P的前一个结点 */</span>        <br>    <span class="hljs-keyword">for</span> ( pre=L; pre&amp;&amp;pre-&gt;Next!=P; pre=pre-&gt;Next ) ;            <br>    <span class="hljs-keyword">if</span> ( pre==<span class="hljs-literal">NULL</span> || P==<span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">/* P所指的结点不在L中 */</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;删除位置参数错误\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* 找到了P的前一个结点pre */</span><br>        <span class="hljs-comment">/* 将P位置的结点删除 */</span><br>        pre-&gt;Next = P-&gt;Next;<br>        <span class="hljs-built_in">free</span>(P);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-2-堆栈"><a href="#2-2-堆栈" class="headerlink" title="2.2 堆栈"></a>2.2 堆栈</h2><h3 id="数组实现-1"><a href="#数组实现-1" class="headerlink" title="数组实现"></a>数组实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Position;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SNode</span> &#123;</span><br>    ElementType *Data; <span class="hljs-comment">/* 存储元素的数组 */</span><br>    Position Top;      <span class="hljs-comment">/* 栈顶指针 */</span><br>    <span class="hljs-type">int</span> MaxSize;       <span class="hljs-comment">/* 堆栈最大容量 */</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SNode</span> *<span class="hljs-title">Stack</span>;</span><br> <br>Stack <span class="hljs-title function_">CreateStack</span><span class="hljs-params">( <span class="hljs-type">int</span> MaxSize )</span><br>&#123;<br>    Stack S = (Stack)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> SNode));<br>    S-&gt;Data = (ElementType *)<span class="hljs-built_in">malloc</span>(MaxSize * <span class="hljs-keyword">sizeof</span>(ElementType));<br>    S-&gt;Top = <span class="hljs-number">-1</span>;<br>    S-&gt;MaxSize = MaxSize;<br>    <span class="hljs-keyword">return</span> S;<br>&#125;<br> <br><span class="hljs-type">bool</span> <span class="hljs-title function_">IsFull</span><span class="hljs-params">( Stack S )</span><br>&#123;<br>    <span class="hljs-keyword">return</span> (S-&gt;Top == S-&gt;MaxSize<span class="hljs-number">-1</span>);<br>&#125;<br> <br><span class="hljs-type">bool</span> <span class="hljs-title function_">Push</span><span class="hljs-params">( Stack S, ElementType X )</span><br>&#123;<br>    <span class="hljs-keyword">if</span> ( IsFull(S) ) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;堆栈满&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        S-&gt;Data[++(S-&gt;Top)] = X;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br> <br><span class="hljs-type">bool</span> <span class="hljs-title function_">IsEmpty</span><span class="hljs-params">( Stack S )</span><br>&#123;<br>    <span class="hljs-keyword">return</span> (S-&gt;Top == <span class="hljs-number">-1</span>);<br>&#125;<br> <br>ElementType <span class="hljs-title function_">Pop</span><span class="hljs-params">( Stack S )</span><br>&#123;<br>    <span class="hljs-keyword">if</span> ( IsEmpty(S) ) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;堆栈空&quot;</span>);<br>        <span class="hljs-keyword">return</span> ERROR; <span class="hljs-comment">/* ERROR是ElementType的特殊值，标志错误 */</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <br>        <span class="hljs-keyword">return</span> ( S-&gt;Data[(S-&gt;Top)--] );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="链表实现-1"><a href="#链表实现-1" class="headerlink" title="链表实现"></a>链表实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SNode</span> *<span class="hljs-title">PtrToSNode</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SNode</span> &#123;</span><br>    ElementType Data;<br>    PtrToSNode Next;<br>&#125;;<br><span class="hljs-keyword">typedef</span> PtrToSNode Stack;<br> <br>Stack <span class="hljs-title function_">CreateStack</span><span class="hljs-params">( )</span> <br>&#123; <span class="hljs-comment">/* 构建一个堆栈的头结点，返回该结点指针 */</span><br>    Stack S;<br> <br>    S = (Stack)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> SNode));<br>    S-&gt;Next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> S;<br>&#125;<br> <br><span class="hljs-type">bool</span> <span class="hljs-title function_">IsEmpty</span> <span class="hljs-params">( Stack S )</span><br>&#123; <span class="hljs-comment">/* 判断堆栈S是否为空，若是返回true；否则返回false */</span><br>    <span class="hljs-keyword">return</span> ( S-&gt;Next == <span class="hljs-literal">NULL</span> );<br>&#125;<br> <br><span class="hljs-type">bool</span> <span class="hljs-title function_">Push</span><span class="hljs-params">( Stack S, ElementType X )</span><br>&#123; <span class="hljs-comment">/* 将元素X压入堆栈S */</span><br>    PtrToSNode TmpCell;<br> <br>    TmpCell = (PtrToSNode)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> SNode));<br>    TmpCell-&gt;Data = X;<br>    TmpCell-&gt;Next = S-&gt;Next;<br>    S-&gt;Next = TmpCell;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br> <br>ElementType <span class="hljs-title function_">Pop</span><span class="hljs-params">( Stack S )</span>  <br>&#123; <span class="hljs-comment">/* 删除并返回堆栈S的栈顶元素 */</span><br>    PtrToSNode FirstCell;<br>    ElementType TopElem;<br> <br>    <span class="hljs-keyword">if</span>( IsEmpty(S) ) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;堆栈空&quot;</span>); <br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        FirstCell = S-&gt;Next; <br>        TopElem = FirstCell-&gt;Data;<br>        S-&gt;Next = FirstCell-&gt;Next;<br>        <span class="hljs-built_in">free</span>(FirstCell);<br>        <span class="hljs-keyword">return</span> TopElem;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-3-队列"><a href="#2-3-队列" class="headerlink" title="2.3 队列"></a>2.3 队列</h2><h3 id="数组实现-2"><a href="#数组实现-2" class="headerlink" title="数组实现"></a>数组实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Position;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> &#123;</span><br>    ElementType *Data;     <span class="hljs-comment">/* 存储元素的数组 */</span><br>    Position Front, Rear;  <span class="hljs-comment">/* 队列的头、尾指针 */</span><br>    <span class="hljs-type">int</span> MaxSize;           <span class="hljs-comment">/* 队列最大容量 */</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> *<span class="hljs-title">Queue</span>;</span><br> <br>Queue <span class="hljs-title function_">CreateQueue</span><span class="hljs-params">( <span class="hljs-type">int</span> MaxSize )</span><br>&#123;<br>    Queue Q = (Queue)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> QNode));<br>    Q-&gt;Data = (ElementType *)<span class="hljs-built_in">malloc</span>(MaxSize * <span class="hljs-keyword">sizeof</span>(ElementType));<br>    Q-&gt;Front = Q-&gt;Rear = <span class="hljs-number">0</span>;<br>    Q-&gt;MaxSize = MaxSize;<br>    <span class="hljs-keyword">return</span> Q;<br>&#125;<br> <br><span class="hljs-type">bool</span> <span class="hljs-title function_">IsFull</span><span class="hljs-params">( Queue Q )</span><br>&#123;<br>    <span class="hljs-keyword">return</span> ((Q-&gt;Rear+<span class="hljs-number">1</span>)%Q-&gt;MaxSize == Q-&gt;Front);<br>&#125;<br> <br><span class="hljs-type">bool</span> <span class="hljs-title function_">AddQ</span><span class="hljs-params">( Queue Q, ElementType X )</span><br>&#123;<br>    <span class="hljs-keyword">if</span> ( IsFull(Q) ) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;队列满&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        Q-&gt;Rear = (Q-&gt;Rear+<span class="hljs-number">1</span>)%Q-&gt;MaxSize;<br>        Q-&gt;Data[Q-&gt;Rear] = X;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br> <br><span class="hljs-type">bool</span> <span class="hljs-title function_">IsEmpty</span><span class="hljs-params">( Queue Q )</span><br>&#123;<br>    <span class="hljs-keyword">return</span> (Q-&gt;Front == Q-&gt;Rear);<br>&#125;<br> <br>ElementType <span class="hljs-title function_">DeleteQ</span><span class="hljs-params">( Queue Q )</span><br>&#123;<br>    <span class="hljs-keyword">if</span> ( IsEmpty(Q) ) &#123; <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;队列空&quot;</span>);<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-keyword">else</span>  &#123;<br>        Q-&gt;Front =(Q-&gt;Front+<span class="hljs-number">1</span>)%Q-&gt;MaxSize;<br>        <span class="hljs-keyword">return</span>  Q-&gt;Data[Q-&gt;Front];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="链表实现-2"><a href="#链表实现-2" class="headerlink" title="链表实现"></a>链表实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">PtrToNode</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span> <span class="hljs-comment">/* 队列中的结点 */</span><br>    ElementType Data;<br>    PtrToNode Next;<br>&#125;;<br><span class="hljs-keyword">typedef</span> PtrToNode Position;<br> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> &#123;</span><br>    Position Front, Rear;  <span class="hljs-comment">/* 队列的头、尾指针 */</span><br>    <span class="hljs-type">int</span> MaxSize;           <span class="hljs-comment">/* 队列最大容量 */</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> *<span class="hljs-title">Queue</span>;</span><br> <br><span class="hljs-type">bool</span> <span class="hljs-title function_">IsEmpty</span><span class="hljs-params">( Queue Q )</span><br>&#123;<br>    <span class="hljs-keyword">return</span> ( Q-&gt;Front == <span class="hljs-literal">NULL</span>);<br>&#125;<br> <br>ElementType <span class="hljs-title function_">DeleteQ</span><span class="hljs-params">( Queue Q )</span><br>&#123;<br>    Position FrontCell; <br>    ElementType FrontElem;<br>     <br>    <span class="hljs-keyword">if</span>  ( IsEmpty(Q) ) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;队列空&quot;</span>);<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        FrontCell = Q-&gt;Front;<br>        <span class="hljs-keyword">if</span> ( Q-&gt;Front == Q-&gt;Rear ) <span class="hljs-comment">/* 若队列只有一个元素 */</span><br>            Q-&gt;Front = Q-&gt;Rear = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">/* 删除后队列置为空 */</span><br>        <span class="hljs-keyword">else</span>                     <br>            Q-&gt;Front = Q-&gt;Front-&gt;Next;<br>        FrontElem = FrontCell-&gt;Data;<br> <br>        <span class="hljs-built_in">free</span>( FrontCell );  <span class="hljs-comment">/* 释放被删除结点空间  */</span><br>        <span class="hljs-keyword">return</span>  FrontElem;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第三章-树"><a href="#第三章-树" class="headerlink" title="第三章 树"></a>第三章 树</h1><h2 id="3-3-二叉树的遍历"><a href="#3-3-二叉树的遍历" class="headerlink" title="3.3 二叉树的遍历"></a>3.3 二叉树的遍历</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">InorderTraversal</span><span class="hljs-params">( BinTree BT )</span><br>&#123;<br>    <span class="hljs-keyword">if</span>( BT ) &#123;<br>        InorderTraversal( BT-&gt;Left );<br>        <span class="hljs-comment">/* 此处假设对BT结点的访问就是打印数据 */</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, BT-&gt;Data); <span class="hljs-comment">/* 假设数据为整型 */</span><br>        InorderTraversal( BT-&gt;Right );<br>    &#125;<br>&#125;<br> <br><span class="hljs-type">void</span> <span class="hljs-title function_">PreorderTraversal</span><span class="hljs-params">( BinTree BT )</span><br>&#123;<br>    <span class="hljs-keyword">if</span>( BT ) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, BT-&gt;Data );<br>        PreorderTraversal( BT-&gt;Left );<br>        PreorderTraversal( BT-&gt;Right );<br>    &#125;<br>&#125;<br> <br><span class="hljs-type">void</span> <span class="hljs-title function_">PostorderTraversal</span><span class="hljs-params">( BinTree BT )</span><br>&#123;<br>    <span class="hljs-keyword">if</span>( BT ) &#123;<br>        PostorderTraversal( BT-&gt;Left );<br>        PostorderTraversal( BT-&gt;Right );<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, BT-&gt;Data);<br>    &#125;<br>&#125;<br> <br><span class="hljs-type">void</span> <span class="hljs-title function_">LevelorderTraversal</span> <span class="hljs-params">( BinTree BT )</span><br>&#123; <br>    Queue Q; <br>    BinTree T;<br> <br>    <span class="hljs-keyword">if</span> ( !BT ) <span class="hljs-keyword">return</span>; <span class="hljs-comment">/* 若是空树则直接返回 */</span><br>     <br>    Q = CreatQueue(); <span class="hljs-comment">/* 创建空队列Q */</span><br>    AddQ( Q, BT );<br>    <span class="hljs-keyword">while</span> ( !IsEmpty(Q) ) &#123;<br>        T = DeleteQ( Q );<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, T-&gt;Data); <span class="hljs-comment">/* 访问取出队列的结点 */</span><br>        <span class="hljs-keyword">if</span> ( T-&gt;Left )   AddQ( Q, T-&gt;Left );<br>        <span class="hljs-keyword">if</span> ( T-&gt;Right )  AddQ( Q, T-&gt;Right );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>堆栈</tag>
      
      <tag>队列</tag>
      
      <tag>链表</tag>
      
      <tag>树</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蓝桥杯嵌入式 国赛扩展板 CT117E-EX 学习笔记</title>
    <link href="/2019/ea2a1972/"/>
    <url>/2019/ea2a1972/</url>
    
    <content type="html"><![CDATA[<h1 id="蓝桥杯嵌入式国赛扩展板-CT117E-EX-学习笔记"><a href="#蓝桥杯嵌入式国赛扩展板-CT117E-EX-学习笔记" class="headerlink" title="蓝桥杯嵌入式国赛扩展板 CT117E-EX 学习笔记"></a>蓝桥杯嵌入式国赛扩展板 CT117E-EX 学习笔记</h1><h1 id="CT117E-EX-扩展板笔记"><a href="#CT117E-EX-扩展板笔记" class="headerlink" title="CT117E-EX 扩展板笔记"></a>CT117E-EX 扩展板笔记</h1><hr><h2 id="数码管（74HC595）"><a href="#数码管（74HC595）" class="headerlink" title="数码管（74HC595）"></a>数码管（74HC595）</h2><blockquote><p>博主参加国赛有点皮，准备的不够就参赛了，结果国赛没敲出来数码管实在有点可惜。望看到本文的朋友在准备国赛一定要把这个功能做到盲打出来，第十届国赛没提供数码管的驱动。</p></blockquote><h3 id="RCLK-R-存储寄存器读取"><a href="#RCLK-R-存储寄存器读取" class="headerlink" title="RCLK(R:存储寄存器读取)"></a>RCLK(R:存储寄存器读取)</h3><ul><li>上升沿    移位寄存器进入存储寄存器</li><li>下降沿    数据保持不变</li></ul><h3 id="SCK-S-送入595"><a href="#SCK-S-送入595" class="headerlink" title="SCK(S:送入595)"></a>SCK(S:送入595)</h3><ul><li>上升沿    数据寄存器数据移位。Q0–&gt;Q1–&gt;Q2–&gt;Q3–&gt;…–&gt;Q7;</li><li>下降沿    移位寄存器数据不变</li></ul><h3 id="SER（数据脚）"><a href="#SER（数据脚）" class="headerlink" title="SER（数据脚）"></a>SER（数据脚）</h3><ul><li>串行数据输入端</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">SEG_DisplayValue</span><span class="hljs-params">(u8 Bit1,  u8 Bit2, u8 Bit3)</span><br>&#123;<br>u8 i = <span class="hljs-number">0</span>;<span class="hljs-comment">//</span><br>u8 code_tmp = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    *略过部分代码</span><br><span class="hljs-comment">    */</span><br><br>code_tmp = Seg7[Bit1];<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)&#123;<br><br><span class="hljs-keyword">if</span>(code_tmp &amp; <span class="hljs-number">0x80</span>)&#123;<br>SER_H;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>SER_L;<br>&#125;<br>SCK_H;<span class="hljs-comment">//数据移位</span><br>code_tmp = code_tmp &lt;&lt; <span class="hljs-number">1</span>;   <br>SCK_L;<br>&#125;<br>RCLK_H;<span class="hljs-comment">//上升沿时移位寄存器进入存储寄存器</span><br>RCLK_L;<span class="hljs-comment">//下降沿是数据保持不变</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数码管显示数组"><a href="#数码管显示数组" class="headerlink" title="数码管显示数组"></a>数码管显示数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">u8 code t_display[]=&#123;                       <span class="hljs-comment">//标准字库</span><br><span class="hljs-comment">//   0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F</span><br><span class="hljs-number">0x3F</span>,<span class="hljs-number">0x06</span>,<span class="hljs-number">0x5B</span>,<span class="hljs-number">0x4F</span>,<span class="hljs-number">0x66</span>,<span class="hljs-number">0x6D</span>,<span class="hljs-number">0x7D</span>,<span class="hljs-number">0x07</span>,<span class="hljs-number">0x7F</span>,<span class="hljs-number">0x6F</span>,<span class="hljs-number">0x77</span>,<span class="hljs-number">0x7C</span>,<span class="hljs-number">0x39</span>,<span class="hljs-number">0x5E</span>,<span class="hljs-number">0x79</span>,<span class="hljs-number">0x71</span>,<br><br><span class="hljs-comment">//black  -     H    J    K    L    N    o   P    U     t    G    Q    r   M    y</span><br><span class="hljs-number">0x00</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x76</span>,<span class="hljs-number">0x1E</span>,<span class="hljs-number">0x70</span>,<span class="hljs-number">0x38</span>,<span class="hljs-number">0x37</span>,<span class="hljs-number">0x5C</span>,<span class="hljs-number">0x73</span>,<span class="hljs-number">0x3E</span>,<span class="hljs-number">0x78</span>,<span class="hljs-number">0x3d</span>,<span class="hljs-number">0x67</span>,<span class="hljs-number">0x50</span>,<span class="hljs-number">0x37</span>,<span class="hljs-number">0x6e</span>,<br>    <br> <span class="hljs-comment">//0. 1. 2. 3. 4. 5. 6. 7. 8. 9. -1</span><br><span class="hljs-number">0xBF</span>,<span class="hljs-number">0x86</span>,<span class="hljs-number">0xDB</span>,<span class="hljs-number">0xCF</span>,<span class="hljs-number">0xE6</span>,<span class="hljs-number">0xED</span>,<span class="hljs-number">0xFD</span>,<span class="hljs-number">0x87</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xEF</span>,<span class="hljs-number">0x46</span>&#125;;    <br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//   0    1    2    3    4    5    6    7    8    9</span><br><br><span class="hljs-number">0x3F</span>,<span class="hljs-number">0x06</span>,<span class="hljs-number">0x5B</span>,<span class="hljs-number">0x4F</span>,<span class="hljs-number">0x66</span>,<span class="hljs-number">0x6D</span>,<span class="hljs-number">0x7D</span>,<span class="hljs-number">0x07</span>,<span class="hljs-number">0x7F</span>,<span class="hljs-number">0x6F</span>,<span class="hljs-number">0x77</span><br></code></pre></td></tr></table></figure><hr><h2 id="ADC按键"><a href="#ADC按键" class="headerlink" title="ADC按键"></a>ADC按键</h2><h3 id="ADC-KEY-引脚"><a href="#ADC-KEY-引脚" class="headerlink" title="ADC KEY 引脚"></a>ADC KEY 引脚</h3><p> PA5      ADC_12_<strong>IN5</strong></p><blockquote><p>背下ADC按键区间</p></blockquote><h3 id="按键值"><a href="#按键值" class="headerlink" title="按键值"></a>按键值</h3><table><thead><tr><th align="left">ADC值</th><th>ADC按键区间</th></tr></thead><tbody><tr><td align="left">0</td><td>&lt;100</td></tr><tr><td align="left">200</td><td>&lt;400</td></tr><tr><td align="left">600</td><td>&lt;800</td></tr><tr><td align="left">1000</td><td>&lt;1200</td></tr><tr><td align="left">1300-1400</td><td>&lt;1600</td></tr><tr><td align="left">1700-1900</td><td>&lt;2000</td></tr><tr><td align="left">2100-2400</td><td>&lt;2600</td></tr><tr><td align="left">2800-3000</td><td>&lt;3200</td></tr></tbody></table><hr><h2 id="DHT11模块"><a href="#DHT11模块" class="headerlink" title="DHT11模块"></a>DHT11模块</h2><h3 id="芯片性能"><a href="#芯片性能" class="headerlink" title="芯片性能"></a>芯片性能</h3><ul><li>温度测量范围：0－50℃</li><li>湿度测量范围：20－90％RH</li><li>采样周期 ：1S</li></ul><h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><table><thead><tr><th>Byte0</th><th>Byte1</th><th>Byte2</th><th>Byte3</th><th>Byte4</th></tr></thead><tbody><tr><td>湿度整数数据</td><td>湿度小数数据</td><td>温度整数数据</td><td>温度小数数据</td><td>校验和</td></tr></tbody></table><h3 id="编程思路"><a href="#编程思路" class="headerlink" title="编程思路"></a>编程思路</h3><ul><li>主机输出</li><li>主机拉  <strong>低</strong>  至少 <font color="red">18ms</font></li><li>主机拉  <strong>高</strong>  <font color="red">20-40us</font></li><li>主机输入</li><li>主机等待信号线拉 <strong>低</strong>   （DHT11发送持续  <strong>40-50us</strong> 的  <strong>低</strong>   响应信号）</li><li>主机等待信号线拉 <strong>高</strong>   （DHT11发送持续  <strong>40-50us</strong> 的  <strong>高</strong>   拉高信号）</li><li>for(){   &#x2F;&#x2F;40bit数据       5Byte<ul><li>主机等待数据线拉<strong>低</strong>    （数据Bit开始）</li><li>主机等待数据线拉<strong>高</strong>    </li><li>主机延时 时间大于<strong>28us</strong>小于<strong>70us</strong>    （ <font color="red">Type值 40us</font>）</li><li>主机读取数据</li></ul></li><li>}</li><li>主机输出</li><li>主机拉高</li></ul><h3 id="技巧-amp-TIP"><a href="#技巧-amp-TIP" class="headerlink" title="技巧&amp;TIP"></a>技巧&amp;TIP</h3><ul><li>DHT11分辨率都是整数级别的<strong>读取小数的数据部分没有意义</strong>。（全为0）</li><li>读取间隔建议大于100ms（采样 1S 过高的读取频率没有意义）</li><li>在72MHz频率下 <strong>Delay_LCD</strong> 运行一次大约 <strong>375us</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Delay_LCD</span><span class="hljs-params">(u16 n)</span><br>&#123;<br>u16 i,j;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>;i&lt;n;++i)<br><span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">3000</span>;++j);<br>&#125;<br><span class="hljs-comment">//将里面的 3000 改成 8 运行一次大概 1us </span><br><span class="hljs-comment">//运行次数越少比1us越多</span><br><span class="hljs-comment">//运行次数越多比1us越少</span><br></code></pre></td></tr></table></figure><hr><h2 id="18B20模块"><a href="#18B20模块" class="headerlink" title="18B20模块"></a>18B20模块</h2><h3 id="芯片性能-1"><a href="#芯片性能-1" class="headerlink" title="芯片性能"></a>芯片性能</h3><ul><li>±0.5°C accuracy from -10°C to +85°C</li><li>Can be powered from data line. Power supply range is 3.0V to 5.5V</li><li>Converts 12-bit temperature to digital word in 750 ms (max.)</li></ul><h3 id="数据格式-1"><a href="#数据格式-1" class="headerlink" title="数据格式"></a>数据格式</h3><h4 id="数据格式-2"><a href="#数据格式-2" class="headerlink" title="数据格式"></a>数据格式</h4><ul><li>写Byte数据先写<strong>低位</strong></li><li>读Byte数据先读出的是<strong>低位</strong></li><li>读出来的温度先是  <strong>LSM 8bit</strong>  然后是 MSB 8bit</li></ul><h4 id="总线协议-amp-时序"><a href="#总线协议-amp-时序" class="headerlink" title="总线协议&amp;时序"></a>总线协议&amp;时序</h4><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-n4fqEHfa-1627893566676)(蓝桥杯嵌入式决赛笔记.assets&#x2F;01-1557625836489.png)]</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-MDCAsN9Z-1627893566679)(蓝桥杯嵌入式决赛笔记.assets&#x2F;02.png)]</p><h3 id="编程思路-1"><a href="#编程思路-1" class="headerlink" title="编程思路"></a>编程思路</h3><blockquote><p>第十届提供了底层接口，比赛会下面这些就好了</p></blockquote><p>0xCCOW_SKIP_ROM</p><p>0x44DS18B20_CONVERT</p><p>0xCCOW_SKIP_ROM</p><p>0xBEDS18B20_READ</p><hr><h2 id="LIS302DL"><a href="#LIS302DL" class="headerlink" title="LIS302DL"></a>LIS302DL</h2><p>NULL</p><hr><h2 id="光敏-D-amp-A"><a href="#光敏-D-amp-A" class="headerlink" title="光敏 D&amp;A"></a>光敏 D&amp;A</h2><h3 id="光敏D"><a href="#光敏D" class="headerlink" title="光敏D"></a>光敏D</h3><ul><li>GPIOA_Pin_3 </li><li>GPIO_Mode_IPU</li></ul><h3 id="光敏A"><a href="#光敏A" class="headerlink" title="光敏A"></a>光敏A</h3><blockquote><p>AD通道号就是Pin号</p></blockquote><ul><li>GPIOA_Pin_4</li><li>ADC1</li><li>ADC_Channel_4</li></ul><hr><h2 id="电位器"><a href="#电位器" class="headerlink" title="电位器"></a>电位器</h2><blockquote><p>省赛内容没什么好说的</p></blockquote><p>NULL</p><hr><h2 id="PULS-amp-PWM"><a href="#PULS-amp-PWM" class="headerlink" title="PULS&amp;PWM"></a>PULS&amp;PWM</h2><blockquote><p>比较捕获模式万能解题。如果题目不是要求同时采集CH1和CH2可以用PWM捕获模式挺好用的，改进一下可以不使用中断直接读取出占空比和频率，效率挺高。</p></blockquote><p>PA1        TIM2_CH2</p><p>PA2        TIM2_CH3</p><p>PA6        TIM3_CH1</p><p>PA7        TIM3_CH2</p><hr><h2 id="界面颜色搭配"><a href="#界面颜色搭配" class="headerlink" title="界面颜色搭配"></a>界面颜色搭配</h2><blockquote><p>萝卜青菜各有所爱，好看就行了</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">LCD_SetBackColor(Blue);<span class="hljs-comment">//界面标题</span><br>LCD_SetTextColor(White);<br><span class="hljs-comment">//Line01</span><br>LCD_SetBackColor(White);<span class="hljs-comment">//界面内容</span><br>LCD_SetTextColor(Blue);<br><span class="hljs-comment">//Line1-77</span><br>LCD_SetBackColor(Blue);<span class="hljs-comment">//界面介绍</span><br>LCD_SetTextColor(Black);<br><span class="hljs-comment">//Line892</span><br></code></pre></td></tr></table></figure><h1 id="蓝桥的其他文章与我个人敲的代码"><a href="#蓝桥的其他文章与我个人敲的代码" class="headerlink" title="蓝桥的其他文章与我个人敲的代码"></a>蓝桥的其他文章与我个人敲的代码</h1><p><a href="https://blog.csdn.net/weixin_42078116/article/details/87983401">蓝桥杯嵌入式STM32 零碎笔记</a></p><p><a href="https://blog.csdn.net/weixin_42078116/article/details/90905914">蓝桥杯嵌入式 错题本</a></p><p>省赛及国赛的赛题的实现代码可以在我的下载里面找到</p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ct117e-ex</tag>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蓝桥杯嵌入式 错题本</title>
    <link href="/2019/62231d0e/"/>
    <url>/2019/62231d0e/</url>
    
    <content type="html"><![CDATA[<h1 id="杂乱笔记"><a href="#杂乱笔记" class="headerlink" title="杂乱笔记"></a>杂乱笔记</h1><hr><h2 id="Keil仿真准确测量运行时间"><a href="#Keil仿真准确测量运行时间" class="headerlink" title="Keil仿真准确测量运行时间"></a>Keil仿真准确测量运行时间</h2><p>Debug-&gt;Setting-&gt;Trsce-&gt;Core 修改好核心时钟频率即可准确测量函数运行时间</p><hr><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><blockquote><p>图看百度</p></blockquote><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-CSWmqarp-1627893544937)(STM32杂乱笔记.assets&#x2F;00.jpg)]</p><ul><li>坑</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//编译报错</span><br>(DS18B20_DQ_IN != <span class="hljs-number">0</span>)? data_temp |= <span class="hljs-number">0x80</span>:data_temp&amp;=<span class="hljs-number">0x7f</span>;<br><br><span class="hljs-comment">//规范写法</span><br>(DS18B20_DQ_IN!=<span class="hljs-number">0</span>)? (data_temp|=<span class="hljs-number">0x80</span>):(data_temp&amp;=<span class="hljs-number">0x7f</span>);<br></code></pre></td></tr></table></figure><ul><li>！！！极注意！！！  请小心有位运算时打上括号            &lt;&lt;  比  +-  要低</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">u16 temp;<br>u8 h,l;<br>temp = (u16)(h&lt;&lt;<span class="hljs-number">8</span>) + l;<span class="hljs-comment">// 正确语法</span><br>temp = h&lt;&lt;<span class="hljs-number">8</span> + l;<span class="hljs-comment">// 错误语法！！！！！</span><br></code></pre></td></tr></table></figure><hr><h2 id="snprintf"><a href="#snprintf" class="headerlink" title="snprintf();"></a>snprintf();</h2><ul><li>所传入的值以<strong>‘&#x2F;0’</strong>结尾    要得到   <strong>20</strong>  个数据需要传入参数  <strong>20+1</strong></li></ul><hr><h2 id="通用-TIM-输出低电平"><a href="#通用-TIM-输出低电平" class="headerlink" title="通用  TIM  输出低电平"></a>通用  TIM  输出低电平</h2><p>调用 TIM_CCxCmd 关闭输出使能即可<strong>持续输出低电平</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">TIM_CCxCmd</span><span class="hljs-params">(TIM_TypeDef* TIMx, <span class="hljs-type">uint16_t</span> TIM_Channel, <span class="hljs-type">uint16_t</span> TIM_CCx)</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>CCxE位</th><th>OCx输出状态</th></tr></thead><tbody><tr><td>0</td><td>禁止输出(OCx&#x3D;0，OCx_EN&#x3D;0)</td></tr><tr><td>1</td><td>OCx &#x3D; OCxREF + 极性，OCx_EN&#x3D;1</td></tr></tbody></table><hr><h2 id="Printf第一个字符丢失"><a href="#Printf第一个字符丢失" class="headerlink" title="Printf第一个字符丢失"></a>Printf第一个字符丢失</h2><ul><li>将发送放在等待标志位后面即可解决问题</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">&#123;<br><span class="hljs-comment">/* Loop until the end of transmission */</span><br><span class="hljs-keyword">while</span> (USART_GetFlagStatus(USART2, USART_FLAG_TC) == RESET);<br><br><span class="hljs-comment">/* Place your implementation of fputc here */</span><br><span class="hljs-comment">/* e.g. write a character to the USART */</span><br>USART_SendData(USART2, (<span class="hljs-type">uint8_t</span>) ch);<br><br><span class="hljs-keyword">return</span> ch;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="union计算移位"><a href="#union计算移位" class="headerlink" title="union计算移位"></a>union计算移位</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">union</span><br>&#123;<br>u16 Val_u16;<br>u8 Val_u8[<span class="hljs-number">2</span>];<br>&#125;_HL_UNION;<br></code></pre></td></tr></table></figure><hr><h2 id="USART里面DMA要修改"><a href="#USART里面DMA要修改" class="headerlink" title="USART里面DMA要修改"></a>USART里面DMA要修改</h2><p>移植官方的库的时候     要把DST(destination) 为 SRC(source)</p><hr><h2 id="做赛题时遇到的问题"><a href="#做赛题时遇到的问题" class="headerlink" title="做赛题时遇到的问题"></a>做赛题时遇到的问题</h2><ul><li><p>AO1 AO2无法满量程  4068</p></li><li><p>display 一次时间太久</p><ul><li>分成Init 和刷新部分     且每次刷新屏幕一行</li></ul></li><li><p>IT.c 文件复制模板</p><ul><li>Get</li></ul></li><li><p>RCC_PCLK1Config（）是什么东西</p><ul><li>预分频</li></ul></li><li><p>ADC_GetFlag    ADC_FLAG_EOC 完成标志位</p><ul><li>1为完成   <code>！= SET</code></li></ul></li><li><p>Snprintf对浮点数的对齐处理似乎有问题</p><ul><li>手动对齐</li></ul></li><li><p>R37</p><ul><li>ADC12 CH8</li></ul></li><li><p>RTC ！！！！  </p><ul><li>注意！要在官方库文件里面加SetCounter！还要修改分频系数！  </li><li>分频系数要改，然后还要加一个预装载值</li></ul></li><li><p>USART2的RX     DMA  CH6</p><ul><li>USART2 RX</li><li>DMA_SetCurrDataCounter 要先关闭  DMA 使能时才能调用</li><li>注意数组的越界！！！！！</li></ul></li><li><p>关于TIM2的CH3与USART2的TX冲突的解决办法</p><ul><li>关闭USART2使能       关闭USART2时钟          使能CH3              ———-&amp;&#x2F;&#x2F;使能</li><li>关闭CH3                      打开USART2时钟         打开USART2使能 ———-&amp;&#x2F;&#x2F;使能</li></ul></li><li><p>define   （x）   </p><ul><li>只是简单代换注意括号</li></ul></li><li><p>usart例程没开 usart  时钟？</p><ul><li>在.h文件里面</li></ul></li><li><p>usart与捕获不冲突</p><ul><li>对  不冲突</li></ul></li><li><p>相位不同的互补方波</p><ul><li>重置定时器</li><li>再重新Init</li></ul></li><li><p>强制为    高&#x2F;低    电平    TIM_ForcedOCxConfig     </p><ul><li>强制电平是类似于 OC 的一种 Mode 用完了需要    TIM_OCxInit</li></ul></li><li><p>操作LED后要将573的N_LE引脚拉低    这样才能避免操作LCD时影响到LED的亮灭。</p></li><li><p>USART_IT_IDLE 空闲中断要用   USART_ReceiveData(USARTx);  或者  USARTx-&gt;SR; USARTx-&gt;DR;   清除中断。USART_ClearITPendingBit清除不了。</p></li></ul><h1 id="蓝桥的其他文章与我个人敲的代码"><a href="#蓝桥的其他文章与我个人敲的代码" class="headerlink" title="蓝桥的其他文章与我个人敲的代码"></a>蓝桥的其他文章与我个人敲的代码</h1><p><a href="https://blog.csdn.net/weixin_42078116/article/details/87983401">蓝桥杯嵌入式STM32 零碎笔记</a></p><p><a href="https://blog.csdn.net/weixin_42078116/article/details/90905706">蓝桥杯嵌入式国赛扩展板 CT117E-EX 学习</a></p><p>省赛及国赛的赛题的实现代码可以在我的下载里面找到</p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蓝桥杯STM32国赛笔记</title>
    <link href="/2019/b9b15cd2/"/>
    <url>/2019/b9b15cd2/</url>
    
    <content type="html"><![CDATA[<h1 id="CT117E-EX-扩展板笔记"><a href="#CT117E-EX-扩展板笔记" class="headerlink" title="CT117E-EX 扩展板笔记"></a>CT117E-EX 扩展板笔记</h1><h2 id="数码管（74HC595）"><a href="#数码管（74HC595）" class="headerlink" title="数码管（74HC595）"></a>数码管（74HC595）</h2><h3 id="RCLK-R-存储寄存器读取"><a href="#RCLK-R-存储寄存器读取" class="headerlink" title="RCLK(R:存储寄存器读取)"></a>RCLK(R:存储寄存器读取)</h3><ul><li>上升沿    移位寄存器进入存储寄存器</li><li>下降沿    数据保持不变</li></ul><h3 id="SCK-S-送入595"><a href="#SCK-S-送入595" class="headerlink" title="SCK(S:送入595)"></a>SCK(S:送入595)</h3><ul><li>上升沿    数据寄存器数据移位。Q0–&gt;Q1–&gt;Q2–&gt;Q3–&gt;…–&gt;Q7;</li><li>下降沿    移位寄存器数据不变</li></ul><h3 id="SER（数据脚）"><a href="#SER（数据脚）" class="headerlink" title="SER（数据脚）"></a>SER（数据脚）</h3><ul><li>串行数据输入端</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">SEG_DisplayValue</span><span class="hljs-params">(u8 Bit1,  u8 Bit2, u8 Bit3)</span><br>&#123;<br>u8 i = <span class="hljs-number">0</span>;<span class="hljs-comment">//</span><br>u8 code_tmp = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    *略过部分代码</span><br><span class="hljs-comment">    */</span><br><br>code_tmp = Seg7[Bit1];<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)&#123;<br><br><span class="hljs-keyword">if</span>(code_tmp &amp; <span class="hljs-number">0x80</span>)&#123;<br>SER_H;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>SER_L;<br>&#125;<br>SCK_H;<span class="hljs-comment">//数据移位</span><br>code_tmp = code_tmp &lt;&lt; <span class="hljs-number">1</span>;   <br>SCK_L;<br>&#125;<br>RCLK_H;<span class="hljs-comment">//上升沿时移位寄存器进入存储寄存器</span><br>RCLK_L;<span class="hljs-comment">//下降沿是数据保持不变</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数码管显示数组"><a href="#数码管显示数组" class="headerlink" title="数码管显示数组"></a>数码管显示数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">u8 code t_display[]=&#123;                       <span class="hljs-comment">//标准字库</span><br><span class="hljs-comment">//   0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F</span><br><span class="hljs-number">0x3F</span>,<span class="hljs-number">0x06</span>,<span class="hljs-number">0x5B</span>,<span class="hljs-number">0x4F</span>,<span class="hljs-number">0x66</span>,<span class="hljs-number">0x6D</span>,<span class="hljs-number">0x7D</span>,<span class="hljs-number">0x07</span>,<span class="hljs-number">0x7F</span>,<span class="hljs-number">0x6F</span>,<span class="hljs-number">0x77</span>,<span class="hljs-number">0x7C</span>,<span class="hljs-number">0x39</span>,<span class="hljs-number">0x5E</span>,<span class="hljs-number">0x79</span>,<span class="hljs-number">0x71</span>,<br><br><span class="hljs-comment">//black  -     H    J    K    L    N    o   P    U     t    G    Q    r   M    y</span><br><span class="hljs-number">0x00</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x76</span>,<span class="hljs-number">0x1E</span>,<span class="hljs-number">0x70</span>,<span class="hljs-number">0x38</span>,<span class="hljs-number">0x37</span>,<span class="hljs-number">0x5C</span>,<span class="hljs-number">0x73</span>,<span class="hljs-number">0x3E</span>,<span class="hljs-number">0x78</span>,<span class="hljs-number">0x3d</span>,<span class="hljs-number">0x67</span>,<span class="hljs-number">0x50</span>,<span class="hljs-number">0x37</span>,<span class="hljs-number">0x6e</span>,<br>    <br> <span class="hljs-comment">//0. 1. 2. 3. 4. 5. 6. 7. 8. 9. -1</span><br><span class="hljs-number">0xBF</span>,<span class="hljs-number">0x86</span>,<span class="hljs-number">0xDB</span>,<span class="hljs-number">0xCF</span>,<span class="hljs-number">0xE6</span>,<span class="hljs-number">0xED</span>,<span class="hljs-number">0xFD</span>,<span class="hljs-number">0x87</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xEF</span>,<span class="hljs-number">0x46</span>&#125;;    <br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//   0    1    2    3    4    5    6    7    8    9</span><br><br><span class="hljs-number">0x3F</span>,<span class="hljs-number">0x06</span>,<span class="hljs-number">0x5B</span>,<span class="hljs-number">0x4F</span>,<span class="hljs-number">0x66</span>,<span class="hljs-number">0x6D</span>,<span class="hljs-number">0x7D</span>,<span class="hljs-number">0x07</span>,<span class="hljs-number">0x7F</span>,<span class="hljs-number">0x6F</span>,<span class="hljs-number">0x77</span><br></code></pre></td></tr></table></figure><h2 id="ADC按键"><a href="#ADC按键" class="headerlink" title="ADC按键"></a>ADC按键</h2><h3 id="ADC-KEY-引脚"><a href="#ADC-KEY-引脚" class="headerlink" title="ADC KEY 引脚"></a>ADC KEY 引脚</h3><p> PA5      ADC_12_<strong>IN5</strong></p><h3 id="按键值"><a href="#按键值" class="headerlink" title="按键值"></a>按键值</h3><table><thead><tr><th align="left">ADC值</th><th>ADC按键区间</th></tr></thead><tbody><tr><td align="left">0</td><td>&lt;100</td></tr><tr><td align="left">200</td><td>&lt;400</td></tr><tr><td align="left">600</td><td>&lt;800</td></tr><tr><td align="left">1000</td><td>&lt;1200</td></tr><tr><td align="left">1300-1400</td><td>&lt;1600</td></tr><tr><td align="left">1700-1900</td><td>&lt;2000</td></tr><tr><td align="left">2100-2400</td><td>&lt;2600</td></tr><tr><td align="left">2800-3000</td><td>&lt;3200</td></tr></tbody></table><h2 id="DHT11模块"><a href="#DHT11模块" class="headerlink" title="DHT11模块"></a>DHT11模块</h2><h3 id="芯片性能"><a href="#芯片性能" class="headerlink" title="芯片性能"></a>芯片性能</h3><ul><li>温度测量范围：0－50℃</li><li>湿度测量范围：20－90％RH</li><li>采样周期 ：1S</li></ul><h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><table><thead><tr><th>Byte0</th><th>Byte1</th><th>Byte2</th><th>Byte3</th><th>Byte4</th></tr></thead><tbody><tr><td>湿度整数数据</td><td>湿度小数数据</td><td>温度整数数据</td><td>温度小数数据</td><td>校验和</td></tr></tbody></table><h3 id="编程思路"><a href="#编程思路" class="headerlink" title="编程思路"></a>编程思路</h3><ul><li>主机输出</li><li>主机拉  <strong>低</strong>  至少 <font color="red">18ms</font></li><li>主机拉  <strong>高</strong>  <font color="red">20-40us</font></li><li>主机输入</li><li>主机等待信号线拉 <strong>低</strong>   （DHT11发送持续  <strong>40-50us</strong> 的  <strong>低</strong>   响应信号）</li><li>主机等待信号线拉 <strong>高</strong>   （DHT11发送持续  <strong>40-50us</strong> 的  <strong>高</strong>   拉高信号）</li><li>for(){   &#x2F;&#x2F;40bit数据       5Byte<ul><li>主机等待数据线拉<strong>低</strong>    （数据Bit开始）</li><li>主机等待数据线拉<strong>高</strong>    </li><li>主机延时 时间大于<strong>28us</strong>小于<strong>70us</strong>    （ <font color="red">Type值 40us</font>）</li><li>主机读取数据</li></ul></li><li>}</li><li>主机输出</li><li>主机拉高</li></ul><h3 id="技巧-amp-TIP"><a href="#技巧-amp-TIP" class="headerlink" title="技巧&amp;TIP"></a>技巧&amp;TIP</h3><ul><li><p>DHT11分辨率都是整数级别的<strong>读取小数的数据部分没有意义</strong>。（全为0）</p></li><li><p>读取间隔建议大于100ms（采样 1S 过高的读取频率没有意义）</p></li><li><p>在72MHz频率下 <strong>Delay_LCD</strong> 运行一次大约 <strong>375us</strong></p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Delay_LCD</span><span class="hljs-params">(u16 n)</span><br>&#123;<br>u16 i,j;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>;i&lt;n;++i)<br><span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">3000</span>;++j);<br>&#125;<br><span class="hljs-comment">//将里面的 3000 改成 8 运行一次大概 1us </span><br><span class="hljs-comment">//运行次数越少比1us越多</span><br><span class="hljs-comment">//运行次数越多比1us越少</span><br></code></pre></td></tr></table></figure><h2 id="18B20模块"><a href="#18B20模块" class="headerlink" title="18B20模块"></a>18B20模块</h2><h3 id="芯片性能-1"><a href="#芯片性能-1" class="headerlink" title="芯片性能"></a>芯片性能</h3><ul><li>±0.5°C accuracy from -10°C to +85°C</li><li>Can be powered from data line. Power supply range is 3.0V to 5.5V</li><li>Converts 12-bit temperature to digital word in 750 ms (max.)</li></ul><h3 id="数据格式-1"><a href="#数据格式-1" class="headerlink" title="数据格式"></a>数据格式</h3><h4 id="数据格式-2"><a href="#数据格式-2" class="headerlink" title="数据格式"></a>数据格式</h4><ul><li><p>写Byte数据先写<strong>低位</strong></p></li><li><p>读Byte数据先读出的是<strong>低位</strong></p></li><li><p>读出来的温度先是  <strong>LSM 8bit</strong>  然后是 MSB 8bit</p></li></ul><h4 id="总线协议-amp-时序"><a href="#总线协议-amp-时序" class="headerlink" title="总线协议&amp;时序"></a>总线协议&amp;时序</h4><p><img src="/2019/b9b15cd2/01-1557625836489.png" alt="复位时序"></p><p><img src="/2019/b9b15cd2/02.png" alt="读写时序"></p><h3 id="编程思路-1"><a href="#编程思路-1" class="headerlink" title="编程思路"></a>编程思路</h3><p>0xCCOW_SKIP_ROM</p><p>0x44DS18B20_CONVERT</p><p>0xCCOW_SKIP_ROM</p><p>0xBEDS18B20_READ</p><h2 id="LIS302DL"><a href="#LIS302DL" class="headerlink" title="LIS302DL"></a>LIS302DL</h2><p>NULL</p><h2 id="光敏-D-amp-A"><a href="#光敏-D-amp-A" class="headerlink" title="光敏 D&amp;A"></a>光敏 D&amp;A</h2><h3 id="光敏D"><a href="#光敏D" class="headerlink" title="光敏D"></a>光敏D</h3><ul><li>GPIOA_Pin_3 </li><li>GPIO_Mode_IPU</li></ul><h3 id="光敏A"><a href="#光敏A" class="headerlink" title="光敏A"></a>光敏A</h3><ul><li><p>GPIOA_Pin_4</p></li><li><p>ADC1</p></li><li><p>ADC_Channel_4</p></li></ul><h2 id="电位器"><a href="#电位器" class="headerlink" title="电位器"></a>电位器</h2><p>NULL</p><h2 id="PULS-amp-PWM"><a href="#PULS-amp-PWM" class="headerlink" title="PULS&amp;PWM"></a>PULS&amp;PWM</h2><p>PA1        TIM2_CH2</p><p>PA2        TIM2_CH3</p><p>PA6        TIM3_CH1</p><p>PA7        TIM3_CH2</p><h2 id="界面颜色搭配"><a href="#界面颜色搭配" class="headerlink" title="界面颜色搭配"></a>界面颜色搭配</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">LCD_SetBackColor(Blue);<br>LCD_SetTextColor(White);<br><span class="hljs-comment">//Line01</span><br>LCD_SetBackColor(White);<br>LCD_SetTextColor(Blue);<br><span class="hljs-comment">//Line1-77</span><br>LCD_SetBackColor(Blue);<br>LCD_SetTextColor(Black);<br><span class="hljs-comment">//Line892</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stm32</tag>
      
      <tag>蓝桥杯</tag>
      
      <tag>国赛</tag>
      
      <tag>ct117e</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C按特定格式读取字符串的数据 Sscanf的用法</title>
    <link href="/2019/d334b917/"/>
    <url>/2019/d334b917/</url>
    
    <content type="html"><![CDATA[<h1 id="C按特定格式读取字符串的数据-sscanf的用法"><a href="#C按特定格式读取字符串的数据-sscanf的用法" class="headerlink" title="C按特定格式读取字符串的数据 sscanf的用法"></a>C按特定格式读取字符串的数据 sscanf的用法</h1><h1 id="Sscanf-函数"><a href="#Sscanf-函数" class="headerlink" title="Sscanf 函数"></a>Sscanf 函数</h1><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">int</span> <span class="hljs-title function_">sscanf</span><span class="hljs-params">( <span class="hljs-type">const</span> <span class="hljs-type">char</span> *buffer, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, [ argument ] ...   )</span>; <br><br></code></pre></td></tr></table></figure><p>buffer   存储的数据<br>format 窗体控件字符串。 有关详细信息，请参阅”格式规范”。<br>argument    可选自变量<br>locale   要使用的区域设置</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>sscanf与scanf类似，都是用于输入的，只是后者以键盘(stdin)为输入源，前者以<strong>固定字符串</strong>为输入源。</p><h3 id="控制字符说明"><a href="#控制字符说明" class="headerlink" title="控制字符说明"></a>控制字符说明</h3><blockquote><p>%c  一个单一的字符<br>%d  一个十进制整数<br>%i  一个整数<br>%e, %f, %g 一个浮点数<br>%o  一个八进制数<br>%s  一个字符串<br>%x  一个十六进制数<br>%p  一个指针<br>%n  一个等于读取字符数量的整数<br>%u  一个无符号整数<br>%[]  一个字符集<br>%%  一个精度符</p></blockquote><h2 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h2><p>函数将返回成功赋值的字段个数；返回值不包括已读取但未赋值的字段个数。 返回值为 0 表示没有将任何字段赋值。 如果在第一次读取之前到达字符串结尾，则返回EOF。</p><h2 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">char</span> buf[<span class="hljs-number">512</span>];<br><span class="hljs-built_in">sscanf</span>(<span class="hljs-string">&quot;123456 &quot;</span>, <span class="hljs-string">&quot;%s&quot;</span>, buf);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf);<br><span class="hljs-comment">//结果为：123456</span><br><br><br><span class="hljs-comment">//取指定长度的字符串。如在下例中，取最大长度为4字节的字符串。</span><br><span class="hljs-built_in">sscanf</span>(<span class="hljs-string">&quot;123456 &quot;</span>, <span class="hljs-string">&quot;%4s&quot;</span>, buf);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf);<br><span class="hljs-comment">//结果为：1234</span><br><br><span class="hljs-comment">//取到指定字符为止的字符串。如在下例中，取遇到空格为止字符串。</span><br><span class="hljs-built_in">sscanf</span>(<span class="hljs-string">&quot;123456 abcdedf&quot;</span>, <span class="hljs-string">&quot;%[^ ]&quot;</span>, buf);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf);<br><span class="hljs-comment">//结果为：123456</span><br><br><span class="hljs-comment">//取仅包含指定字符集的字符串。如在下例中，取仅包含1到9和小写字母的字符串。</span><br><span class="hljs-built_in">sscanf</span>(<span class="hljs-string">&quot;123456abcdedfBCDEF&quot;</span>, <span class="hljs-string">&quot;%[1-9a-z]&quot;</span>, buf);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf);<br><span class="hljs-comment">//结果为：123456abcdedf</span><br><br><span class="hljs-comment">//取到指定字符集为止的字符串。如在下例中，取遇到大写字母为止的字符串。</span><br><span class="hljs-built_in">sscanf</span>(<span class="hljs-string">&quot;123456abcdedfBCDEF&quot;</span>, <span class="hljs-string">&quot;%[^A-Z]&quot;</span>, buf);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf);<br><span class="hljs-comment">//结果为：123456abcdedf</span><br><br><span class="hljs-comment">//给定一个字符串iios/12DDWDFF@122，获取 / 和 @ 之间的字符串，先将 &quot;iios/&quot;过滤掉，再将非&#x27;@&#x27;的一串内容送到buf中</span><br><span class="hljs-built_in">sscanf</span>(<span class="hljs-string">&quot;iios/12DDWDFF@122&quot;</span>, <span class="hljs-string">&quot;%*[^/]/%[^@]&quot;</span>, buf);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf);<br><span class="hljs-comment">//结果为：12DDWDFF</span><br><br><span class="hljs-comment">//给定一个字符串&quot;hello, world&quot;，仅保留&quot;world&quot;。（注意：“，”之后有一空格）</span><br><span class="hljs-built_in">sscanf</span>(<span class="hljs-string">&quot;hello, world&quot;</span>, <span class="hljs-string">&quot;%*s%s&quot;</span>, buf);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf);<br><span class="hljs-comment">//结果为：world</span><br><br></code></pre></td></tr></table></figure><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p><img src="/2019/d334b917/Center.png" alt="c"></p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c/c++</tag>
      
      <tag>sscanf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32F070系列的IAP程序</title>
    <link href="/2018/2d20bb21/"/>
    <url>/2018/2d20bb21/</url>
    
    <content type="html"><![CDATA[<h1 id="STM32F070系列的IAP程序"><a href="#STM32F070系列的IAP程序" class="headerlink" title="STM32F070系列的IAP程序"></a>STM32F070系列的IAP程序</h1><h1 id="总程序思路"><a href="#总程序思路" class="headerlink" title="总程序思路"></a>总程序思路</h1><p><img src="/2018/2d20bb21/70.png" alt="bootloader"></p><p><img src="/2018/2d20bb21/70-16635087132592.png" alt="app"></p><p>之所以不直接将接收到的BIN文件直接写入到APP区域是因为如果升级过程出现某些错误时，程序将会清除升级标志位，并跳转到APP运行程序减少产品变砖的概率。</p><p><em><strong>注：如果在  将BacpupApp区域的BIN文件拷贝到App区域   这一步如果拷贝两次都校验失败将会导致程序停掉。</strong></em></p><h1 id="STM32内Flash区域划分"><a href="#STM32内Flash区域划分" class="headerlink" title="STM32内Flash区域划分"></a>STM32内Flash区域划分</h1><p> <img src="/2018/2d20bb21/70-16635087883674.png" alt="stm32"></p><p><img src="/2018/2d20bb21/70-16635087985376.png" alt="flash"></p><p>此次使用的MCU型号是STM32F070CB，由其Flash组织特性可知其Flash一页为1KB（若总Flash大小，大于等于256KB则其一页大小为2KB），为了程序简单高效，所以使FLAG占用一页（1KB）的位置（Flag只使用了前2B的空间）。</p><h1 id="STM32与上位机通信过程"><a href="#STM32与上位机通信过程" class="headerlink" title="STM32与上位机通信过程"></a>STM32与上位机通信过程</h1><h2 id="上位机发送给STM32"><a href="#上位机发送给STM32" class="headerlink" title="上位机发送给STM32"></a>上位机发送给STM32</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 16B 命令数据长度</span><br><span class="hljs-comment"># 注：命令长度设置为 0x10  即16B大小</span><br>0x55  0xAA   0x01    命令长度    命令码   固件总包数   0x00   0x00   0x00   0x00   0x00   0x00   0x00  0x00   0x00    和校验<br><br><span class="hljs-comment"># 1024+7B 固件数据长度</span><br>0x55  0xAA   0x01  包号  命令码     0xFF   BINData[1024]    和校验<br></code></pre></td></tr></table></figure><h2 id="STM32发送给上位机"><a href="#STM32发送给上位机" class="headerlink" title="STM32发送给上位机"></a>STM32发送给上位机</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 16B 命令数据长度</span><br><span class="hljs-comment"># 注：命令长度设置为 0x10  即16B大小</span><br>0x55  0xAA   0x01  命令长度  命令码    0x00   0x00   0x00   0x00   0x00   0x00   0x00   0x00   0x00   0x00    和校验<br></code></pre></td></tr></table></figure><p><img src="/2018/2d20bb21/70-16635090195918.png" alt="img"></p><h1 id="IAP应用说明"><a href="#IAP应用说明" class="headerlink" title="IAP应用说明"></a>IAP应用说明</h1><ul><li>App区域和Bootloader区域都有IAP实现的程序段，所以要实现IAP就要要求App区域和Bootloader的程序都可以正常工作。</li></ul><p>App程序需要做的修改：</p><ol><li>添加 iap.c 文件，并在main函数最前面调用 iap.c 里的函数    iRemapIrqVector();   重映射中断向量</li><li>用这种方法重映射中断向量，RAM的前0xC0个字节不能用，需要将RAM始地址修改到  0x2000 00C0 处，将Size大小减掉0xC0</li><li>ROM起始地址修改到  0x0800 3000 处，将Size大小设置成0xE800（58KB）</li><li>在程序的串口命令判断中添加IAP升级命令判断，满足条件则使能升级标志位，并重启MCU进入Bootloader</li><li>刷入APP和Bootloader</li></ol><h1 id="关于移植到其他芯片"><a href="#关于移植到其他芯片" class="headerlink" title="关于移植到其他芯片"></a>关于移植到其他芯片</h1><ol><li>如果移植到F103系列芯片的话重映射中断向量将变得非常简单，一行代码就搞定，也就无需修改RAM起始地址</li><li>如果移植的芯片容量不一样需要查看其一个页的大小是多少，然后重新划分Flash区域</li></ol><p>Bootloader源码下载：<a href="https://download.csdn.net/download/weixin_42078116/10610445">源码</a><br>App区源码：待加入<br>上位机程序和源码：<a href="https://download.csdn.net/download/weixin_42078116/10610490">源码</a></p><p>参考资料：</p><p><a href="http://www.openedv.com/forum.php?mod=viewthread&tid=85906">STM32实现IAP功能的学习笔记</a></p><p><a href="http://www.openedv.com/forum.php?mod=viewthread&tid=85906">STM32实现IAP功能的学习笔记</a> </p><h1 id="扩展：STM32运行过程"><a href="#扩展：STM32运行过程" class="headerlink" title="扩展：STM32运行过程"></a>扩展：STM32运行过程</h1><blockquote><p>  TIPS：STM32上电后先  <strong>执行复位中断 Reset_Handler</strong>  然后才会进入  main 函数。</p><p>  STM32的程序运行过程在很多资料里也都有介绍，因为STM32F103的单片机是基于Cortex-M3核的，它的内部主要是通过中断向量表来响应各种中断，内部闪存的起始地址是0x08000000，中断向量表的起始地址是0x8000004，程序启动后，将首先从“中断向量表”取出复位中断向量执行复位中断程序完成启动，当中断来临时STM32 的内部硬件机制亦会自动将 PC 指针定位到“中断向量表”处，并根据中断源取出对应的中断向量执行相应的中断服务程序。</p><p>  <img src="/2018/2d20bb21/70-166350916978910.png" alt="img"></p><p>  如上图所示STM32的正常启动流程是：<br>  a. STM32上电后会从 0x8000004 处取出复位中断向量的地址，并跳转执行复位中断服务程序，如标号1所示；<br>  b. 复位中断复位程序执行完成之后就会跳转到我们的main函数如标号2所示；<br>  c. main函数一般为死循环，当其收到某一中断请求之后STM32会强制把PC指针指向中断向量表，如标号3所示；<br>  d. 查询中断向量表，根据中断源来跳转到相应的中断服务程序中执行响应的操作；如标号4、5所示；<br>  e. 执行完中断服务程序之后会再回到main函数中，如标号6所示。</p><p>  以上是STM32的正常运行过程，而当加入IAP程序之后，运行流程就如下所示：</p><p>  <img src="/2018/2d20bb21/70-166350918005812.png" alt="img"></p><p>  加入IAP后程序运行如下：<br>  a. STM32复位之后还是从0x8000004处获取中断向量表的地址，并跳转执行复位中断服务程序，如标号1所示；<br>  b. 执行完复位中断服务程序之后回调转到IAP的main函数中，如标号2所示；<br>  c. IAP的过程就是通过某种选定的通信方式（如串口）来接收程序文件，并且存储在指定的FLASH空间里，随后会加载新的程序，而新程序<br>  的复位中断向量起始地址为0X08000004+N+M，取出新程序的复位中断向量的地址，并跳转执行新程序的复位中断服务程序，随后跳转<br>  至新程序的 main 函数，如标号3、4所示；<br>  d. 此时在STM32的FLASH里面会有两个中断向量表，在新程序 main 函数执行的过程中，当中断来临时PC指针仍会回跳转至地址为<br>  0x8000004 中断向量表处，而并不是新程序的中断向量表，这是由STM32的硬件机制决定的，如标号5所示；<br>  e. 查询中断向量表，根据中断源来跳转到新的中断服务程序中执行响应的操作，如标号6所示；<br>  f. 执行完中断服务程序之后会再回到main函数中，如标号7、8所示。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>misc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iap</tag>
      
      <tag>bootloader</tag>
      
      <tag>stm32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蓝桥杯 超准超声波测距</title>
    <link href="/2018/125d6be2/"/>
    <url>/2018/125d6be2/</url>
    
    <content type="html"><![CDATA[<h1 id="蓝桥杯-单片机组-超准超声波测距"><a href="#蓝桥杯-单片机组-超准超声波测距" class="headerlink" title="蓝桥杯 单片机组 超准超声波测距"></a>蓝桥杯 单片机组 超准超声波测距</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Timer1Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <span class="hljs-comment">//2000微秒@12.000MHz</span><br>&#123;<br>    AUXR &amp;= <span class="hljs-number">0xBF</span>; <span class="hljs-comment">//定时器时钟12T模式</span><br>    TMOD &amp;= <span class="hljs-number">0x0F</span>; <span class="hljs-comment">//设置定时器模式</span><br>    TMOD |= <span class="hljs-number">0x10</span>; <span class="hljs-comment">//设置定时器模式</span><br>    TL1 = <span class="hljs-number">0x30</span>; <span class="hljs-comment">//设置定时初值</span><br>    TH1 = <span class="hljs-number">0xF8</span>; <span class="hljs-comment">//设置定时初值</span><br>    TF1 = <span class="hljs-number">0</span>; <span class="hljs-comment">//清除TF1标志</span><br>    <span class="hljs-comment">// TR1 = 1; //定时器1开始计时</span><br>&#125;<br><br> <br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Sand_wav</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> i;<br><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">20</span>;i++)<br>    &#123;<br>        P10 = ~P10;<br>        &#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> i;_nop_();_nop_();i = <span class="hljs-number">33</span>;<span class="hljs-keyword">while</span> (--i);&#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> <span class="hljs-title function_">Read_wav</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">float</span> range;<br><br>    Sand_wav();<br>     <br>    <span class="hljs-comment">// TR0 = 0;</span><br>    TR1 = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>((P11 != <span class="hljs-number">0</span>) &amp;&amp; (TF1 == <span class="hljs-number">0</span>));<br>    TR1 = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// TR0 = 1;</span><br>     <br>    <span class="hljs-keyword">if</span>(TF1 == <span class="hljs-number">1</span>)<br>    &#123;<br>        TF1 = <span class="hljs-number">0</span>;<br>        TL1 = <span class="hljs-number">0x30</span>; <span class="hljs-comment">//设置定时初值</span><br>        TH1 = <span class="hljs-number">0xF8</span>; <span class="hljs-comment">//设置定时初值</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">99</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        range = TH1*<span class="hljs-number">256</span> + TL1 <span class="hljs-number">-63535</span> +<span class="hljs-number">260</span>;<br>     <br>        range = range * <span class="hljs-number">0.017</span>;<br>     <br>        TL1 = <span class="hljs-number">0x30</span>; <span class="hljs-comment">//设置定时初值</span><br>        TH1 = <span class="hljs-number">0xF8</span>; <span class="hljs-comment">//设置定时初值</span><br>     <br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>)range;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意   </p><ul><li>ET1不要打开</li><li>在Read_wav没有关闭T0要注意主程序延时使程序进入中断</li><li>清除中断标志   重新TH0 TL0初值赋值</li><li>运算时减去260是除去发送波形的间隔（此BUG极大影响了精准度 近4cm）</li></ul><p>单片机组 和 嵌入式组的相关代码资源可以在我的主页下载。</p>]]></content>
    
    
    <categories>
      
      <category>misc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>蓝桥杯</tag>
      
      <tag>超声波</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CC2530</title>
    <link href="/2018/8d6db935/"/>
    <url>/2018/8d6db935/</url>
    
    <content type="html"><![CDATA[<blockquote><p>CC2530是针对IEEE 802.15.4，Zigbee和RF4CE应用的真正片上系统（SoC）解决方案。 它能够以非常低的总物料成本构建强大的网络节点。 CC2530将领先的射频收发器的卓越性能与业界标准增强型8051 MCU，系统内可编程闪存，8 KB RAM以及许多其他强大功能相结合。 CC2530有四种不同的闪存版本：分别为CC2530F32 &#x2F; 64&#x2F;128&#x2F;256对应32&#x2F;64&#x2F;128&#x2F;256 KB的闪存。 CC2530具有多种工作模式，非常适合需要超低功耗的系统。 运行模式之间的短暂转换时间进一步确保了低能耗。</p><p>•CC2530是TI公司推出的用来实现嵌入式ZigBee应用的低功耗片上系统。</p><p>•在单个芯片上整合了ZigBee 射频(RF)前端、内存和微控制器。</p><p>•8 位MCU（增强型、标准8051指令集）。</p><p>•256 KB Flash和8 KB 的RAM，内部16MHz RC 和 32kHz RC 振荡器。</p><p>•8路12位ADC；18个中断源；4个Timer；硬件支持的AES128 ；WDT(1.9ms-1s)；32 kHz晶振的休眠模式定时器、POR(上电复位)、BOD(掉电检测)，以及21 个通用I&#x2F;O 。</p></blockquote><h1 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><img src="/2018/8d6db935/20180211202707601.png" alt="img"></p><p>I &#x2F; O端口具有以下主要功能：</p><ul><li>21个数字通用输入&#x2F;输出引脚</li><li>通用I &#x2F; O或外设I &#x2F; O</li><li>输入上拉或下拉功能</li><li>外部中断功能</li></ul><blockquote><p>所有21个I &#x2F; O引脚都具有外部中断功能。 因此，如果需要，外部设备可能会产生中断。 外部中断功能也可用于将器件从睡眠模式（电源模式PM1，PM2和PM3）中唤醒</p></blockquote><blockquote><p>通用IO：共21个，分成3组，<strong>P0组、P1组、P2组</strong>，其中P0\P1组各8个IO，P2组5个（P2_0、P2_1、 P2_2、P2_3、 P2_4）。其中P1_0、P1_1有20mA的输出驱动能力，其余的只有4mA。</p></blockquote><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><ol><li><p>GPIO<strong>功能</strong>选择寄存器——<strong>PxSEL</strong></p><p> 寄存器PxSEL（其中x是端口号0-2）用于将端口中的每个引脚配置为<strong>通用I&#x2F;O引脚</strong>或<strong>外设I&#x2F;O引脚</strong>，可位寻址。 默认情况下，复位后，所有数字输入&#x2F;输出引脚都配置为<strong>通用上拉输入引脚</strong>。</p><blockquote><p>其中，P2SEL只有第0位至第2位是端口2的功能选择控制位，第3位至第6位是端口1的外设优先级控制位。</p></blockquote></li></ol><ul><li>0&#x3D;通用</li><li>1&#x3D;外设I&#x2F;O</li></ul><ol><li><p>GPIO<strong>输入输出方向</strong>选择寄存器——<strong>PxDIR</strong></p><p>寄存器PxDIR用于将每个端口的引脚方向设置为<strong>输入方向</strong>或<strong>输出方向</strong>。 因此，将PxDIR中的相应位设置为1，相应的引脚就变成输出方向，可位寻址。复位后为<strong>输入引脚</strong>。</p><blockquote><p>其中，P2DIR只有第0位至第4位是端口2的方向选择控制位，第6位和第7位是端口0外设优先级控制位。</p></blockquote></li></ol><ul><li><p>0&#x3D;输入</p></li><li><p>1&#x3D;输出</p></li></ul><ol start="2"><li><p>GPIO<strong>输入模式</strong>寄存器——<strong>PxINP</strong></p><p>寄存器PxINP用于设置IO端口的<strong>输入模式</strong>，通用I &#x2F; O端口引脚可配置为具有<strong>上拉</strong>，<strong>下拉</strong>或<strong>三态</strong>操作模式。 默认情况下，复位后，输入配置为带有上拉的输入。如果要取消输入端口的上拉或下拉功能，必须将PxINP中的相应位设置为1。</p><ul><li>请注意，即使IO端口是外设功能输入，配置为外设I &#x2F; O信号的引脚也不具有上拉或下拉功能。</li></ul><blockquote><p>其中，P2INP中，第0位至第4位是端口2的输入模式选择位</p><p><strong>第5位至第7位是端口0、端口1、端口2的上下拉选择位。</strong></p><ul><li>0&#x3D;PullUp</li><li>1&#x3D;PullDown</li></ul></blockquote></li></ol><ul><li>0&#x3D;上拉或下拉</li><li>1&#x3D;三态</li></ul><h1 id="Z-Stack"><a href="#Z-Stack" class="headerlink" title="Z-Stack"></a>Z-Stack</h1><h2 id="创建一个任务-Create-Task"><a href="#创建一个任务-Create-Task" class="headerlink" title="创建一个任务 Create Task"></a>创建一个任务 Create Task</h2><ul><li>&#x2F;&#x2F; 任务列表<br>const pTaskEventHandlerFn tasksArr[] &#x3D; {…..}</li><li>&#x2F;&#x2F; 初始化任务<br>void osalInitTasks( void )<br>{…..}</li><li>&#x2F;&#x2F; 任务处理函数<br>uint16 Hello_ProcessEvent(uint8 task_id, uint16 events)<br>{…}</li></ul><h2 id="HAL库之LED"><a href="#HAL库之LED" class="headerlink" title="HAL库之LED"></a>HAL库之LED</h2><ol><li>uint8 HalLedSet (uint8 leds, uint8 mode)</li></ol><table><thead><tr><th>ModeName</th><th>作用</th></tr></thead><tbody><tr><td>HAL_LED_MODE_BLINK</td><td>闪烁  (一次)</td></tr><tr><td>HAL_LED_MODE_FLASH</td><td>闪烁</td></tr><tr><td>HAL_LED_MODE_ON</td><td></td></tr><tr><td>HAL_LED_MODE_OFF</td><td></td></tr><tr><td>HAL_LED_MODE_TOGGLE</td><td>触发</td></tr></tbody></table><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><ol><li><p>uint8 osal_start_timerEx( uint8 taskID, uint16 event_id, uint16 timeout_value )</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//为指定的任务设置定时器</span><br><br>osal_start_timerEx(task_id, <span class="hljs-number">0x0001</span>, <span class="hljs-number">10000</span>);<br></code></pre></td></tr></table></figure></li><li></li></ol><h2 id="PAN-ID"><a href="#PAN-ID" class="headerlink" title="PAN_ID"></a>PAN_ID</h2><ul><li><p>全称 Personal Area Network (网络标识符)</p></li><li><p>相当于网络号，网段。</p></li></ul><p>Tools\f8Config.cfgLine59</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Define the default PAN ID.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Setting this to a value other than 0xFFFF causes</span><br><span class="hljs-comment"> * ZDO_COORD to use this value as its PAN ID and</span><br><span class="hljs-comment"> * Routers and end devices to join PAN with this ID</span><br><span class="hljs-comment"> */</span><br>-DZDAPP_CONFIG_PAN_ID=<span class="hljs-number">0x0010</span><br></code></pre></td></tr></table></figure><h2 id="Z-Stack开发步骤"><a href="#Z-Stack开发步骤" class="headerlink" title="Z-Stack开发步骤"></a>Z-Stack开发步骤</h2><h3 id="功能类型定义"><a href="#功能类型定义" class="headerlink" title="功能类型定义"></a>功能类型定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 功能类型值定义</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    DevTemp = <span class="hljs-number">1</span>,<br>    DevHumm,<br><span class="hljs-comment">//略---------------------</span><br>    DevMaxNum<br>&#125;;<br></code></pre></td></tr></table></figure><p>枚举功能类型值，需要时添加即可。</p><h3 id="定义节点功能列表"><a href="#定义节点功能列表" class="headerlink" title="定义节点功能列表"></a>定义节点功能列表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/***************************************************/</span><br><span class="hljs-comment">/* 节点功能列表                                    */</span><br><span class="hljs-comment">/***************************************************/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ep_info_t</span> <span class="hljs-title">funcList</span>[] =</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(HAS_GAS)</span><br>    &#123;<br>        <span class="hljs-comment">//stat,income,timeout,resource</span><br>        <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, sensorGasTimeout, sensorGasResAvailable,<br>        &#123; DevGas, <span class="hljs-number">0</span>, <span class="hljs-number">3</span> &#125;,                   <span class="hljs-comment">// type, id, refresh cycle</span><br>    &#125;,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-comment">//略----------------</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(ZDO_COORDINATOR)</span><br>    &#123;   <span class="hljs-comment">// 协调器</span><br>        CoordinatorNwkStateChangeRoutine,<br>        CoordinatorIncomingRoutine,<br>        CoordinatorTimeoutRoutine,<br>        CoordinatorResAvailableRoutine,<br>        &#123; DevCoordinator, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;,<br>    &#125;,<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(RTR_NWK)</span><br>    &#123;   <span class="hljs-comment">// 路由器</span><br>        RouterNwkStateChangeRoutine,<br>        RouterIncomingRoutine,<br>        RouterTimeoutRoutine,<br>        RouterResAvailableRoutine,<br>        &#123; DevRouter, <span class="hljs-number">0</span>, <span class="hljs-number">30</span> &#125;,<br>    &#125;,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p>功能列表</p></li><li><p>参考下面的 <strong>ep_info_t</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 不能修改下面的内容!!!</span><br><span class="hljs-type">const</span> uint8 funcCount = <span class="hljs-keyword">sizeof</span>(funcList) / <span class="hljs-keyword">sizeof</span>(funcList[<span class="hljs-number">0</span>]);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><br></code></pre></td></tr></table></figure></li><li><p>功能数量</p></li><li></li></ul><h3 id="ep-info-t"><a href="#ep-info-t" class="headerlink" title="ep_info_t"></a>ep_info_t</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ep_info_t</span> &#123;</span><br>    <span class="hljs-comment">// 网络状态发生变化时会调用该函数</span><br>    <span class="hljs-type">void</span> (*nwk_stat_change)(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep);<br>    <span class="hljs-comment">// 接收到数据时会调用该函数</span><br>    <span class="hljs-type">void</span> (*incoming_data)(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg);<br>    <span class="hljs-comment">// 周期性调用的函数</span><br>    <span class="hljs-type">void</span> (*time_out)(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep);<br>    <span class="hljs-comment">// 系统资源可用时调用该函数,系统资源指的是:串口接收到数据/中断等等</span><br>    <span class="hljs-type">void</span> (*res_available)(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep, RES_TYPE type, <span class="hljs-type">void</span> *res);<br>    <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> cycle成员会被用来计数,并周期性调用time_out函数</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">func_info_t</span> <span class="hljs-title">function</span>;</span><br>    <br><span class="hljs-comment">//以下数据用户不能进行更改！！！！！</span><br>    <br>    <span class="hljs-comment">// 当前端点号</span><br>    uint8 ep;<br>    <span class="hljs-comment">// 与此端点绑定的任务ID</span><br>    uint8 task_id;<br>    <span class="hljs-comment">// 递减计数,为0时调用time_out函数,并重载初值=cycle</span><br>    uint8 timerTick;<br>    uint8 userTimer;<br>    endPointDesc_t SampleApp_epDesc;<br>    SimpleDescriptionFormat_t simpleDesc;<br>&#125;;<br><br><span class="hljs-comment">//一个典型的初始化</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(ZDO_COORDINATOR)</span><br>    &#123;   <span class="hljs-comment">// 协调器</span><br>        CoordinatorNwkStateChangeRoutine,<span class="hljs-comment">//节点加入网络完成后调用</span><br>        CoordinatorIncomingRoutine,<span class="hljs-comment">//端点接收到数据后会调用</span><br>        CoordinatorTimeoutRoutine,<span class="hljs-comment">//周期调用</span><br>        CoordinatorResAvailableRoutine,<span class="hljs-comment">//系统初始化、串口收到数据、用户定时器到时 会调用</span><br>        &#123; DevCoordinator, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;,<span class="hljs-comment">//功能类型、功能编号、刷新周期</span><br>    &#125;,<br><br></code></pre></td></tr></table></figure><h4 id="nwk-stat-change"><a href="#nwk-stat-change" class="headerlink" title="nwk_stat_change"></a>nwk_stat_change</h4><p><strong>节点加入网络完成后调用</strong></p><ul><li>可用于读取当前  端点  信息</li><li></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">xxNwkStateChange</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep)</span><br>    <br><span class="hljs-type">void</span> <span class="hljs-title function_">sensorVoiceNwkStateChange</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep)</span><br>&#123;<br>    voiceEndPoint = ep;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="incoming-data"><a href="#incoming-data" class="headerlink" title="incoming_data"></a>incoming_data</h4><p><strong>端点接收到数据后会调用</strong></p><ul><li>下发的指令的处理</li><li></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">xxReceiveData</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg)</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">testReceiveData</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg)</span><br>&#123;<br>    <span class="hljs-comment">//msg-&gt;Data[0] 是接受到的总  比特   数 </span><br><span class="hljs-keyword">if</span>( (msg-&gt;Data[<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;L&#x27;</span>)&amp;&amp;(msg-&gt;Data[<span class="hljs-number">2</span>]==<span class="hljs-string">&#x27;E&#x27;</span>)&amp;&amp;(msg-&gt;Data[<span class="hljs-number">3</span>]==<span class="hljs-string">&#x27;D&#x27;</span>) )<br>    &#123;<br><span class="hljs-keyword">if</span>( msg-&gt;Data[<span class="hljs-number">4</span>]==<span class="hljs-string">&#x27;1&#x27;</span> )<br>&#123;<br>HalUARTWrite(HAL_UART_PORT_0, <span class="hljs-string">&quot;LED_1\r\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;LED_1\r\n&quot;</span>) - <span class="hljs-number">1</span>);<br><span class="hljs-comment">//HalLedBlink(HAL_LED_1, 2, 50, 100);</span><br>&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="time-out"><a href="#time-out" class="headerlink" title="time_out"></a>time_out</h4><p><strong>周期调用</strong></p><ul><li>读取传感器数据</li><li></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">xxTimeout</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep)</span><br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">sensorFireTimeout</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep)</span><br>&#123;<br>    uint8 value = FireInfo();<br>    SendData(ep-&gt;ep, &amp;value, <span class="hljs-number">0x0000</span>, TRANSFER_ENDPOINT, <span class="hljs-keyword">sizeof</span>(value));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="res-available"><a href="#res-available" class="headerlink" title="res_available"></a>res_available</h4><p><strong>系统初始化、串口收到数据、用户定时器到时 会调用</strong></p><ul><li>初始化端口、</li><li></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">xxResAvailable</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep, RES_TYPE type, <span class="hljs-type">void</span> *res)</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">sensorRainResAvailable</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">ep_info_t</span> *ep, RES_TYPE type, <span class="hljs-type">void</span> *res)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(type == ResInit)<br>    &#123;<br>        RainInit();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="IAR学习笔记"><a href="#IAR学习笔记" class="headerlink" title="IAR学习笔记"></a>IAR学习笔记</h1><h2 id="无法观察局部变量"><a href="#无法观察局部变量" class="headerlink" title="无法观察局部变量"></a>无法观察局部变量</h2><p>在软件调试的时候发现Watch窗口中无法观察局部变量的值，总是显示<unavailable><br>　　设置IAR中的”<strong>Options — c&#x2F;c++ compiler — Optimization — Level</strong>“ 选项：<br>　　Level的缺省值为Low，当我把Level选为None之后，即不执行任何优化时，全局变量、静态局部变量、局部变量的值都可以看到。</p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>embedded</tag>
      
      <tag>cc2530</tag>
      
      <tag>zigbee</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

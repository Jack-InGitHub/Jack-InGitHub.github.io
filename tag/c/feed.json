{
    "version": "https://jsonfeed.org/version/1",
    "title": "Oikiou's Blog • All posts by \"c\" tag",
    "description": "Blog",
    "home_page_url": "https://www.oikiou.top",
    "items": [
        {
            "id": "https://www.oikiou.top/2020/3dd7ffa7/",
            "url": "https://www.oikiou.top/2020/3dd7ffa7/",
            "title": "C",
            "date_published": "2020-08-08T00:08:08.000Z",
            "content_html": "<h1 id=\"标准库函数\"><a href=\"#标准库函数\" class=\"headerlink\" title=\"标准库函数\"></a>标准库函数</h1><h2 id=\"fprintf-输出到流中\"><a href=\"#fprintf-输出到流中\" class=\"headerlink\" title=\"fprintf 输出到流中\"></a>fprintf 输出到流中</h2><h3 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>C 库函数 <strong>int fprintf(FILE *stream, const char *format, …)</strong> 发送格式化输出到流 stream 中。</p>\n<h3 id=\"声明\"><a href=\"#声明\" class=\"headerlink\" title=\"声明\"></a>声明</h3><p>下面是 fprintf() 函数的声明。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">fprintf</span><span class=\"hljs-params\">(FILE *stream, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *format, ...)</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h3><ul>\n<li><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。</li>\n<li><strong>format</strong> – 这是 C 字符串，包含了要被写入到流 stream 中的文本。它可以包含嵌入的 format 标签，format 标签可被随后的附加参数中指定的值替换，并按需求进行格式化。format 标签属性是 <strong>%[flags][width][.precision][length]specifier</strong>，具体讲解如下：</li>\n</ul>\n<h3 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><p>如果成功，则返回写入的字符总数，否则返回一个负数。</p>\n<h3 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h3><p>下面的实例演示了 fprintf() 函数的用法。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdlib.h&gt;</span></span><br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span><br>&#123;<br>   FILE * fp;<br><br>   fp = fopen (<span class=\"hljs-string\">&quot;file.txt&quot;</span>, <span class=\"hljs-string\">&quot;w+&quot;</span>);<br>   <span class=\"hljs-built_in\">fprintf</span>(fp, <span class=\"hljs-string\">&quot;%s %s %s %d&quot;</span>, <span class=\"hljs-string\">&quot;We&quot;</span>, <span class=\"hljs-string\">&quot;are&quot;</span>, <span class=\"hljs-string\">&quot;in&quot;</span>, <span class=\"hljs-number\">2014</span>);<br>   <br>   fclose(fp);<br>   <br>   <span class=\"hljs-keyword\">return</span>(<span class=\"hljs-number\">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>让我们编译并运行上面的程序，这将创建文件 <strong>file.txt</strong>，它的内容如下：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">We</span> are in <span class=\"hljs-number\">2014</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"atoi-字符串转换成整数\"><a href=\"#atoi-字符串转换成整数\" class=\"headerlink\" title=\"atoi 字符串转换成整数\"></a>atoi 字符串转换成整数</h2><h3 id=\"描述-1\"><a href=\"#描述-1\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>C 库函数 <strong>int atoi(const char *str)</strong> 把参数 <strong>str</strong> 所指向的字符串转换为一个整数（类型为 int 型）。</p>\n<h3 id=\"声明-1\"><a href=\"#声明-1\" class=\"headerlink\" title=\"声明\"></a>声明</h3><p>下面是 atoi() 函数的声明。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">atoi</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *str)</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"参数-1\"><a href=\"#参数-1\" class=\"headerlink\" title=\"参数\"></a>参数</h3><ul>\n<li><strong>str</strong> – 要转换为整数的字符串。</li>\n</ul>\n<h3 id=\"返回值-1\"><a href=\"#返回值-1\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><p>该函数返回转换后的长整数，如果没有执行有效的转换，则返回零。</p>\n<h3 id=\"实例-1\"><a href=\"#实例-1\" class=\"headerlink\" title=\"实例\"></a>实例</h3><p>下面的实例演示了 atoi() 函数的用法。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdlib.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string.h&gt;</span></span><br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span><br>&#123;<br>   <span class=\"hljs-type\">int</span> val;<br>   <span class=\"hljs-type\">char</span> str[<span class=\"hljs-number\">20</span>];<br>   <br>   <span class=\"hljs-built_in\">strcpy</span>(str, <span class=\"hljs-string\">&quot;98993489&quot;</span>);<br>   val = atoi(str);<br>   <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;字符串值 = %s, 整型值 = %d\\n&quot;</span>, str, val);<br><br>   <span class=\"hljs-built_in\">strcpy</span>(str, <span class=\"hljs-string\">&quot;runoob.com&quot;</span>);<br>   val = atoi(str);<br>   <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;字符串值 = %s, 整型值 = %d\\n&quot;</span>, str, val);<br><br>   <span class=\"hljs-keyword\">return</span>(<span class=\"hljs-number\">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>让我们编译并运行上面的程序，这将产生以下结果：</p>\n<figure class=\"highlight dns\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dns\">字符串值 = <span class=\"hljs-number\">98993489</span>, 整型值 = <span class=\"hljs-number\">98993489</span><br>字符串值 = runoob.com, 整型值 = <span class=\"hljs-number\">0</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"printf\"><a href=\"#printf\" class=\"headerlink\" title=\"printf\"></a>printf</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">printf</span> <span class=\"hljs-params\">( <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> * format, ... )</span>;<br></code></pre></td></tr></table></figure>\n<p>将format 指向的 C 字符串写入标准输出 ( stdout )。如果format包含格式说明符（以%开头的子序列），则format后面的附加参数将被格式化并插入到结果字符串中，替换它们各自的说明符。</p>\n<h3 id=\"格式化\"><a href=\"#格式化\" class=\"headerlink\" title=\"格式化\"></a>格式化</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">%[flags][width][.precision][length]specifier<br></code></pre></td></tr></table></figure>\n<h4 id=\"specifier\"><a href=\"#specifier\" class=\"headerlink\" title=\"specifier\"></a>specifier</h4><table>\n<thead>\n<tr>\n<th align=\"left\"><em>specifier</em></th>\n<th align=\"left\">Output</th>\n<th align=\"left\">Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>d</code> <em>or</em> <code>i</code></td>\n<td align=\"left\">Signed decimal integer(有符号十进制整数)</td>\n<td align=\"left\"><code>392</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>u</code></td>\n<td align=\"left\">Unsigned decimal integer</td>\n<td align=\"left\"><code>7235</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>o</code></td>\n<td align=\"left\">Unsigned octal (无符号八进制)</td>\n<td align=\"left\"><code>610</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>x</code></td>\n<td align=\"left\">Unsigned hexadecimal integer (无符号十六进制整数)</td>\n<td align=\"left\"><code>7fa</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>X</code></td>\n<td align=\"left\">Unsigned hexadecimal integer (uppercase)</td>\n<td align=\"left\"><code>7FA</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>f</code></td>\n<td align=\"left\">Decimal floating point, lowercase (十进制浮点数，小写)</td>\n<td align=\"left\"><code>392.65</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>F</code></td>\n<td align=\"left\">Decimal floating point, uppercase</td>\n<td align=\"left\"><code>392.65</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>e</code></td>\n<td align=\"left\">Scientific notation (mantissa&#x2F;exponent), lowercase (科学记数法（尾数&#x2F;指数），小写)</td>\n<td align=\"left\"><code>3.9265e+2</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>E</code></td>\n<td align=\"left\">Scientific notation (mantissa&#x2F;exponent), uppercase</td>\n<td align=\"left\"><code>3.9265E+2</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>g</code></td>\n<td align=\"left\">Use the shortest representation: <code>%e</code> or <code>%f</code> (使用最短的表示：<code>%e</code>或<code>%f</code>)</td>\n<td align=\"left\"><code>392.65</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>G</code></td>\n<td align=\"left\">Use the shortest representation: <code>%E</code> or <code>%F</code></td>\n<td align=\"left\"><code>392.65</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>a</code></td>\n<td align=\"left\">Hexadecimal floating point, lowercase (十六进制浮点数，小写)</td>\n<td align=\"left\"><code>-0xc.90fep-2</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>A</code></td>\n<td align=\"left\">Hexadecimal floating point, uppercase</td>\n<td align=\"left\"><code>-0XC.90FEP-2</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>c</code></td>\n<td align=\"left\">Character</td>\n<td align=\"left\"><code>a</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>s</code></td>\n<td align=\"left\">String of characters</td>\n<td align=\"left\"><code>sample</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>p</code></td>\n<td align=\"left\">Pointer address</td>\n<td align=\"left\"><code>b8000000</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>n</code></td>\n<td align=\"left\">Nothing printed. <br/>The corresponding argument must be a pointer to a <code>signed int</code>.<br>The number of characters written so far is stored in the pointed location.</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><code>%</code></td>\n<td align=\"left\">A <code>%</code> followed by another <code>%</code> character will write a single <code>%</code> to the stream.</td>\n<td align=\"left\"><code>%</code></td>\n</tr>\n</tbody></table>\n<h4 id=\"flags\"><a href=\"#flags\" class=\"headerlink\" title=\"flags\"></a>flags</h4><p>格式说明符 还可以按顺序包含子说明符：<code>flags</code>、<code>width</code>、<code>.precision</code>和<code>modifiers </code>（这个是什么?），它们是可选的并遵循以下规范：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\"><em>flags</em></th>\n<th align=\"left\">description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>-</code></td>\n<td align=\"left\">Left-justify within the given field width; Right justification is the default (see <em>width</em> sub-specifier).<br/>(在给定的字段宽度内左对齐；右对齐是默认设置（请参阅<em>宽度</em>子说明符）。)</td>\n</tr>\n<tr>\n<td align=\"left\"><code>+</code></td>\n<td align=\"left\">Forces to preceed the result with a plus or minus sign (<code>+</code> or <code>-</code>) even for positive numbers. By default, only negative numbers are preceded with a <code>-</code> sign.<br/>(即使对于正数，也强制在结果前面加上加号或减号（<code>+</code>或<code>-</code>)。默认情况下，只有负数前面带有<code>-</code>号。)</td>\n</tr>\n<tr>\n<td align=\"left\"><em>(space)</em></td>\n<td align=\"left\">If no sign is going to be written, a blank space is inserted before the value.<br/>(如果不写入符号，则在值之前插入一个空格。)</td>\n</tr>\n<tr>\n<td align=\"left\"><code>#</code></td>\n<td align=\"left\">Used with <code>o</code>, <code>x</code> or <code>X</code> specifiers the value is preceeded with <code>0</code>, <code>0x</code> or <code>0X</code> respectively for values different than zero. <br/>Used with <code>a</code>, <code>A</code>, <code>e</code>, <code>E</code>, <code>f</code>, <code>F</code>, <code>g</code> or <code>G</code> it forces the written output to contain a decimal point even if no more digits follow. By default, if no digits follow, no decimal point is written.<br/>(与<code>o</code>、<code>x</code>或<code>X</code>说明符一起使用时，该值前面分别带有<code>0</code>、<code>0x</code>或<code>0X</code>，用于表示不同于零的值。<br/>与<code>a</code>、<code>A</code>、<code>e</code>、<code>E</code>、<code>f</code>、<code>F</code>、<code>g</code>或<code>G</code>一起使用，即使后面没有数字，它也会强制书面输出包含小数点。默认情况下，如果后面没有数字，则不写入小数点。)</td>\n</tr>\n<tr>\n<td align=\"left\"><code>0</code></td>\n<td align=\"left\">Left-pads the number with zeroes (<code>0</code>) instead of spaces when padding is specified (see <em>width</em> sub-specifier).<br/>指定填充时，用零（<code>0</code>）而不是空格填充数字（请参阅<em>宽度</em>子说明符）。</td>\n</tr>\n</tbody></table>\n<h4 id=\"width\"><a href=\"#width\" class=\"headerlink\" title=\"width\"></a>width</h4><table>\n<thead>\n<tr>\n<th align=\"left\"><em>width</em></th>\n<th align=\"left\">description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><em>(number)</em></td>\n<td align=\"left\">Minimum number of characters to be printed. If the value to be printed is shorter than this number, the result is padded with blank spaces. The value is not truncated even if the result is larger.<br/>(要打印的最小字符数。如果要打印的值比这个数字短，结果用空格填充。即使结果较大，该值也不会被截断。)</td>\n</tr>\n<tr>\n<td align=\"left\"><code>*</code></td>\n<td align=\"left\">The <em>width</em> is not specified in the <em>format</em> string, but as an additional integer value argument preceding the argument that has to be formatted.<br/>(宽度未在格式字符串中指定，而是作为必须格式化的参数之前的附加整数值参数。)</td>\n</tr>\n</tbody></table>\n<h4 id=\"precision\"><a href=\"#precision\" class=\"headerlink\" title=\".precision\"></a>.precision</h4><table>\n<thead>\n<tr>\n<th align=\"left\"><em>.precision</em></th>\n<th align=\"left\">description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>.</code><em>number</em></td>\n<td align=\"left\">For integer specifiers (<code>d</code>, <code>i</code>, <code>o</code>, <code>u</code>, <code>x</code>, <code>X</code>): <em>precision</em> specifies the minimum number of digits to be written. If the value to be written is shorter than this number, the result is padded with leading zeros. The value is not truncated even if the result is longer. A <em>precision</em> of <code>0</code> means that no character is written for the value <code>0</code>. For <code>a</code>, <code>A</code>, <code>e</code>, <code>E</code>, <code>f</code> and <code>F</code> specifiers: this is the number of digits to be printed <strong>after</strong> the decimal point (by default, this is 6). For <code>g</code> and <code>G</code> specifiers: This is the maximum number of significant digits to be printed. For <code>s</code>: this is the maximum number of characters to be printed. By default all characters are printed until the ending null character is encountered. If the period is specified without an explicit value for <em>precision</em>, <code>0</code> is assumed.<br/>对于整数说明符（<code>d</code>、<code>i</code>、<code>o</code>、<code>u</code>、<code>x</code>、<code>X</code>）：<em>精度</em>指定要写入的最小位数。如果要写入的值小于此数字，则结果用前导零填充。即使结果更长，该值也不会被截断。<em>精度</em>为<code>0</code>意味着不为值<code>0</code>写入任何字符。<br/>对于<code>a</code>、<code>A</code>、<code>e</code>、<code>E</code>、<code>f</code>和<code>F</code>说明符：这是要打印的位数小数点<strong>后（默认为 6）。</strong><br/>对于<code>g</code>和<code>G</code>说明符：这是要打印的最大有效位数。<br/>对于<code>s</code>：这是要打印的最大字符数。默认情况下，所有字符都会打印，直到遇到结束的空字符。<br/>如果指定了周期而没有明确的<em>精度</em>值，则假定为<code>0 。</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>.*</code></td>\n<td align=\"left\">The <em>precision</em> is not specified in the <em>format</em> string, but as an additional integer value argument preceding the argument that has to be formatted.<br/><em>精度</em>未在格式字符串中指定，<em>而是</em>作为必须格式化的参数之前的附加整数值参数。</td>\n</tr>\n</tbody></table>\n<p><em>长度</em>子说明符修改数据类型的长度 。这是一个图表，显示了用于解释有和没有<em>长度</em>说明符的相应参数的类型（如果使用不同的类型，则执行适当的类型提升或转换，如果允许）：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\"></th>\n<th align=\"left\">specifiers</th>\n<th align=\"left\"></th>\n<th align=\"left\"></th>\n<th align=\"left\"></th>\n<th align=\"left\"></th>\n<th align=\"left\"></th>\n<th align=\"left\"></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><em>length</em></td>\n<td align=\"left\"><code>d i</code></td>\n<td align=\"left\"><code>u o x X</code></td>\n<td align=\"left\"><code>f F e E g G a A</code></td>\n<td align=\"left\"><code>c</code></td>\n<td align=\"left\"><code>s</code></td>\n<td align=\"left\"><code>p</code></td>\n<td align=\"left\"><code>n</code></td>\n</tr>\n<tr>\n<td align=\"left\"><em>(none)</em></td>\n<td align=\"left\"><code>int</code></td>\n<td align=\"left\"><code>unsigned int</code></td>\n<td align=\"left\"><code>double</code></td>\n<td align=\"left\"><code>int</code></td>\n<td align=\"left\"><code>char*</code></td>\n<td align=\"left\"><code>void*</code></td>\n<td align=\"left\"><code>int*</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>h</code></td>\n<td align=\"left\"><code>short int</code></td>\n<td align=\"left\"><code>unsigned short int</code></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"><code>short int*</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>l</code></td>\n<td align=\"left\"><code>long int</code></td>\n<td align=\"left\"><code>unsigned long int</code></td>\n<td align=\"left\"></td>\n<td align=\"left\"><code>wint_t</code></td>\n<td align=\"left\"><code>wchar_t*</code></td>\n<td align=\"left\"></td>\n<td align=\"left\"><code>long int*</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>L</code></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"><code>long double</code></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">↓C99↓</td>\n<td align=\"left\">↓C99↓</td>\n<td align=\"left\">↓C99↓</td>\n<td align=\"left\">↓C99↓</td>\n<td align=\"left\">↓C99↓</td>\n<td align=\"left\">↓C99↓</td>\n<td align=\"left\">↓C99↓</td>\n<td align=\"left\">↓C99↓</td>\n</tr>\n<tr>\n<td align=\"left\"><code>hh</code></td>\n<td align=\"left\"><code>signed char</code></td>\n<td align=\"left\"><code>unsigned char</code></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"><code>signed char*</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>ll</code></td>\n<td align=\"left\"><code>long long int</code></td>\n<td align=\"left\"><code>unsigned long long int</code></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"><code>long long int*</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>j</code></td>\n<td align=\"left\"><code>intmax_t</code></td>\n<td align=\"left\"><code>uintmax_t</code></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"><code>intmax_t*</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>z</code></td>\n<td align=\"left\"><code>size_t</code></td>\n<td align=\"left\"><code>size_t</code></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"><code>size_t*</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>t</code></td>\n<td align=\"left\"><code>ptrdiff_t</code></td>\n<td align=\"left\"><code>ptrdiff_t</code></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"><code>ptrdiff_t*</code></td>\n</tr>\n</tbody></table>\n<h1 id=\"杂乱\"><a href=\"#杂乱\" class=\"headerlink\" title=\"杂乱\"></a>杂乱</h1><h2 id=\"stderr-stdout\"><a href=\"#stderr-stdout\" class=\"headerlink\" title=\"stderr stdout\"></a>stderr stdout</h2><ul>\n<li><p>stdout – 标准输出设备 stdout。 </p>\n</li>\n<li><p>stderr – 标准错误输出设备</p>\n</li>\n</ul>\n<p>两者默认向屏幕输出。 但如果用转向标准输出到磁盘文件，则可看出两者区别。stdout输出到磁盘文件，stderr在屏幕。 </p>\n<blockquote>\n<p>转向标准输出到磁盘文件tmp.txt<br>my.exe &gt; tmp.txt</p>\n</blockquote>\n<p>在默认情况下，stdout是行缓冲的，他的输出会放在一个buffer里面，只有到换行的时候，才会输出到屏幕。而stderr是无缓冲的，会直接输出。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span><br>&#123;<br>    <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stdout</span>,<span class=\"hljs-string\">&quot;Group&quot;</span>);<br>    <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>,<span class=\"hljs-string\">&quot;XiyouLinux&quot;</span>);<br>&#125;<br><br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">linux下，第一次会输出XiYouLinuxGroup,是因为stdout将输出的Group放到了缓冲区当中直到程序结束在将缓冲区中的数据刷新出来。</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n\n",
            "tags": [
                "c/c++",
                "c"
            ]
        },
        {
            "id": "https://www.oikiou.top/2019/b0d7d162/",
            "url": "https://www.oikiou.top/2019/b0d7d162/",
            "title": "C语言高质量编程",
            "date_published": "2019-10-28T02:30:00.000Z",
            "content_html": "<h1 id=\"C语言高质量编程\"><a href=\"#C语言高质量编程\" class=\"headerlink\" title=\"C语言高质量编程\"></a>C语言高质量编程</h1><h1 id=\"1-2-头文件的结构\"><a href=\"#1-2-头文件的结构\" class=\"headerlink\" title=\"1.2 头文件的结构\"></a>1.2 头文件的结构</h1><ol>\n<li>头文件开头处的版权和版本声明（参见示例1-1）。</li>\n<li>预处理块。</li>\n<li>函数和类结构声明等。</li>\n</ol>\n<p>假设头文件名称为 <code>graphics.h</code>，头文件的结构参见下面。</p>\n<ul>\n<li>【规则1-2-1】为了防止头文件被重复引用，应当用<code>ifndef/define/endif</code> 结构产生预处理块。</li>\n<li>【规则 1-2-2】用<code>#include &lt;filename.h&gt;</code> 格式来引用标准库的头文件（编译器将从标准库目录开始搜索）。</li>\n<li>【规则1-2-3】用<code>#include “filename.h”</code> 格式来引用非标准库的头文件（编译器将从用户的工作目录开始搜索）。</li>\n<li>【建议1-2-1】头文件中只存放“声明”而不存放“定义”在 C++ 语法中，类的成员函数可以在声明的同时被定义，并且自动成为内联函数。这虽然会带来书写上的方便，但却造成了风格不一致，弊大于利。建议将成员函数的定义与声明分开，不论该函数体有多么小。</li>\n<li>【建议1-2-2】不提倡使用全局变量，尽量不要在头文件中出现象extern int value 这类声明。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifndef</span> GRAPHICS_H <span class=\"hljs-comment\">// 防止graphics.h 被重复引用</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> GRAPHICS_H</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;math.h&gt;</span> <span class=\"hljs-comment\">// 引用标准库的头文件</span></span><br>⋯<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> “myheader.h” <span class=\"hljs-comment\">// 引用非标准库的头文件</span></span><br>⋯<br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">Function1</span><span class=\"hljs-params\">(⋯)</span>; <span class=\"hljs-comment\">// 全局函数声明</span><br>⋯<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Box</span> // 类结构声明</span><br><span class=\"hljs-class\">&#123;</span><br>⋯<br>&#125;;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br></code></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"1-3-定义文件的结构\"><a href=\"#1-3-定义文件的结构\" class=\"headerlink\" title=\"1.3 定义文件的结构\"></a>1.3 定义文件的结构</h1><p>定义文件有三部分内容：</p>\n<ol>\n<li>定义文件开头处的版权和版本声明（参见示例1-1）。</li>\n<li>对一些头文件的引用。</li>\n<li>程序的实现体（包括数据和代码）。<br>假设定义文件的名称为 graphics.cpp，定义文件的结构参见下面。</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> “graphics.h” <span class=\"hljs-comment\">// 引用头文件</span></span><br>⋯<br><span class=\"hljs-comment\">// 全局函数的实现体</span><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">Function1</span><span class=\"hljs-params\">(⋯)</span><br>&#123;<br>⋯<br>&#125;<br><span class=\"hljs-comment\">// 类成员函数的实现体</span><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">Box::Draw</span><span class=\"hljs-params\">(⋯)</span><br>&#123;<br>⋯<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<h1 id=\"2-1-空行\"><a href=\"#2-1-空行\" class=\"headerlink\" title=\"2.1 空行\"></a>2.1 空行</h1><p>空行起着分隔程序段落的作用。空行得体（不过多也不过少）将使程序的布局更加清晰。空行不会浪费内存，虽然打印含有空行的程序是会多消耗一些纸张，但是值得。所以不要舍不得用空行。</p>\n<ul>\n<li>【规则 2-1-1】在每个类声明之后、每个函数定义结束之后都要加空行。参见示例2-1（a）</li>\n<li>【规则2-1-2】在一个函数体内，逻揖上密切相关的语句之间不加空行，其它地方应加空行分隔</li>\n</ul>\n<h1 id=\"2-2-代码行\"><a href=\"#2-2-代码行\" class=\"headerlink\" title=\"2.2 代码行\"></a>2.2 代码行</h1><ul>\n<li>【规则2-2-1】<strong>一行代码只做一件事情</strong>，<strong>如只定义一个变量</strong>，或只写一条语句。这样的代码容易阅读，并且方便于写注释。</li>\n<li>【规则2-2-2】if、for、while、do 等语句自占一行，执行语句不得紧跟其后。**不论执行语句有多少都要加{}**。这样可以防止书写失误。</li>\n</ul>\n<h1 id=\"2-3-代码行内的空格\"><a href=\"#2-3-代码行内的空格\" class=\"headerlink\" title=\"2.3 代码行内的空格\"></a>2.3 代码行内的空格</h1><ul>\n<li>【规则2-3-1】关键字之后要留空格。象const、virtual、inline、case 等关键字之后至少要留一个空格，否则无法辨析关键字。象if、for、while 等关键字之后应留一个空格再跟左括号‘（’，以突出关键字。</li>\n<li>【规则2-3-2】函数名之后不要留空格，紧跟左括号‘（’，以与关键字区别。</li>\n<li><strong>【规则2-3-3】</strong>‘（’向后紧跟，‘）’、‘，’、‘;’ 向前紧跟，<strong>紧跟处不留空格。</strong></li>\n<li><strong>【规则2-3-4】</strong>‘，’之后要留空格，如<code>Function(x,  y,  z)</code>。如果‘;’不是一行的结束符号，其后要留空格，如<code>for (initialization;  condition;  update)</code>。</li>\n<li>【规则2-3-5】赋值操作符、比较操作符、算术操作符、逻辑操作符、位域操作符，如“&#x3D;”、“+&#x3D;” “&gt;&#x3D;”、“&lt;&#x3D;”、“+”、“*”、“%”、“&amp;&amp;”、“||”、“&lt;&lt;”,“^”等二元操作符的前后应当加空格。</li>\n<li>【规则2-3-6】一元操作符如“!”、“~”、“++”、“–”、“&amp;”（地址运算符）等前后不加空格。</li>\n<li>【规则2-3-7】xu“［］”、“.”、“-&gt;”这类操作符前后不加空格。</li>\n<li>【建议2-3-1】对于表达式比较长的for 语句和if 语句，为了紧凑起见可以适当地去掉一些空格，如<code>for (i=0; i&lt;10; i++)和if ((a&lt;=b) &amp;&amp; (c&lt;=d))</code></li>\n</ul>\n<h1 id=\"2-4-对齐\"><a href=\"#2-4-对齐\" class=\"headerlink\" title=\"2.4 对齐\"></a>2.4 对齐</h1><ul>\n<li>【规则2-4-1】程序的分界符‘{’和‘}’应独占一行并且位于同一列，同时与引用它们的语句左对齐。</li>\n<li>【规则2-4-2】{ }之内的代码块在‘{’右边数格处左对齐。</li>\n</ul>\n<h1 id=\"2-5-长行拆分\"><a href=\"#2-5-长行拆分\" class=\"headerlink\" title=\"2.5 长行拆分\"></a>2.5 长行拆分</h1><ul>\n<li>【规则2-5-1】代码行最大长度宜控制在70 至80 个字符以内。代码行不要过长，否则眼睛看不过来，也不便于打印。</li>\n<li>【规则2-5-2】长表达式要在低优先级操作符处拆分成新行，操作符放在新行之首（以便突出操作符）。拆分出的新行要进行适当的缩进，使排版整齐，语句可读。</li>\n</ul>\n<h1 id=\"2-6-修饰符的位置\"><a href=\"#2-6-修饰符的位置\" class=\"headerlink\" title=\"2.6 修饰符的位置\"></a>2.6 修饰符的位置</h1><p>修饰符 * 和＆ 应该靠近数据类型还是该靠近变量名，是个有争议的活题。若将修饰符 * 靠近数据类型，例如：int*  x; 从语义上讲此写法比较直观，即x是int 类型的指针。上述写法的弊端是容易引起误解，例如：int*  x, y; 此处y 容易被误解为指针变量。虽然将x 和y 分行定义可以避免误解，但并不是人人都愿意这样做。</p>\n<ul>\n<li>【规则2-6-1】应当将修饰符 * 和＆ 紧靠变量名</li>\n</ul>\n<h1 id=\"2-7-注释\"><a href=\"#2-7-注释\" class=\"headerlink\" title=\"2.7 注释\"></a>2.7 注释</h1><p>C 语言的注释符为“&#x2F;<em>…</em>&#x2F;”。C++语言中，程序块的注释常采用“&#x2F;<em>…</em>&#x2F;”，行注释一般采用“&#x2F;&#x2F;…”。注释通常用于：<br>（1）版本、版权声明；<br>（2）函数接口说明；<br>（3）重要的代码行或段落提示。<br>虽然注释有助于理解代码，但注意不可过多地使用注释。<br>【规则2-7-1】注释是对代码的“提示”，而不是文档。程序中的注释不可喧宾夺主，注释太多了会让人眼花缭乱。注释的花样要少。<br>【规则2-7-2】如果代码本来就是清楚的，则不必加注释。否则多此一举，令人厌烦。例如i++; &#x2F;&#x2F; i 加 1，多余的注释<br>【规则2-7-3】边写代码边注释，修改代码同时修改相应的注释，以保证注释与代码的一致性。不再有用的注释要删除。<br>【规则2-7-4】注释应当准确、易懂，防止注释有二义性。错误的注释不但无益反而有害。<br>【规则2-7-5】尽量避免在注释中使用缩写，特别是不常用缩写。<br>【规则2-7-6】注释的位置应与被描述的代码相邻，可以放在代码的上方或右方，不可放在下方。<br><strong>【规则2-7-8】</strong>当代码比较长，特别是有多重嵌套时，应当在一些段落的结束处加注释，便于阅读。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">* 函数介绍：</span><br><span class=\"hljs-comment\">* 输入参数：</span><br><span class=\"hljs-comment\">* 输出参数：</span><br><span class=\"hljs-comment\">* 返回值：</span><br><span class=\"hljs-comment\">*/</span><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">Function</span><span class=\"hljs-params\">(<span class=\"hljs-type\">float</span> x, <span class=\"hljs-type\">float</span> y, <span class=\"hljs-type\">float</span> z)</span><br>&#123;<br>    …<br>&#125;<br><br><span class=\"hljs-keyword\">if</span> (…)<br>&#123;<br>    …<br>    <span class=\"hljs-keyword\">while</span> (…)<br>    &#123;<br>        …<br>    &#125; <span class=\"hljs-comment\">// end of while</span><br>    …<br>&#125; <span class=\"hljs-comment\">// end of if</span><br><br></code></pre></td></tr></table></figure>\n\n<h1 id=\"3-2-简单的单片机应用程序命名规则\"><a href=\"#3-2-简单的单片机应用程序命名规则\" class=\"headerlink\" title=\"3.2 简单的单片机应用程序命名规则\"></a>3.2 简单的单片机应用程序命名规则</h1><ol>\n<li>函数名用大写字母开头的单词组合而成。<br>例如：<br>void Draw(void); &#x2F;&#x2F; 函数名<br>void Setvalue(int value); &#x2F;&#x2F; 函数名</li>\n<li>变量和参数用小写字母开头的单词组合而成，float 变量名前加 f，int 变量名前加 i，bit变量前加 b 。（char 不加）<br>例如：<br>bit b_tirm;<br>int i_time;<br>float f_time;<br>char time;</li>\n<li>常量、宏定义（DF_xxx）全用大写的字母，用下划线分割单词。<br>例如：<br>code char MAX &#x3D; 100;<br>#define DF_MAX 100</li>\n</ol>\n<h1 id=\"4-3-if-语句\"><a href=\"#4-3-if-语句\" class=\"headerlink\" title=\"4.3 if 语句\"></a>4.3 if 语句</h1><h2 id=\"4-3-1-布尔变量与零值比较\"><a href=\"#4-3-1-布尔变量与零值比较\" class=\"headerlink\" title=\"4.3.1 布尔变量与零值比较\"></a>4.3.1 布尔变量与零值比较</h2><p>【规则4-3-1】不可将布尔变量直接与TRUE、FALSE 或者1、0 进行比较。根据布尔类型的语义，零值为“假”（记为FALSE），任何非零值都是“真”（记为TRUE）。TRUE 的值究竟是什么并没有统一的标准。例如Visual C++ 将TRUE 定义为</p>\n<p>1，而Visual Basic 则将TRUE 定义为-1。</p>\n<p>假设布尔变量名字为flag，它与零值比较的标准if 语句如下：</p>\n<p>if (flag) &#x2F;&#x2F; 表示flag 为真</p>\n<p>if (!flag) &#x2F;&#x2F; 表示flag 为假</p>\n<p>其它的用法都属于不良风格，例如：<br>if (flag &#x3D;&#x3D; TRUE)<br>if (flag &#x3D;&#x3D; 1 )<br>if (flag &#x3D;&#x3D; FALSE)</p>\n<p>if (flag &#x3D;&#x3D; 0)</p>\n<h2 id=\"4-3-2-整型变量与零值比较\"><a href=\"#4-3-2-整型变量与零值比较\" class=\"headerlink\" title=\"4.3.2 整型变量与零值比较\"></a>4.3.2 整型变量与零值比较</h2><p>【规则4-3-2】应当将整型变量用“&#x3D;&#x3D;”或“！&#x3D;”直接与0 比较。<br>假设整型变量的名字为value，它与零值比较的标准if 语句如下：<br>if (value &#x3D;&#x3D; 0)<br>if (value !&#x3D; 0)<br>不可模仿布尔变量的风格而写成<br>if (value) &#x2F;&#x2F; 会让人误解 value 是布尔变量</p>\n<p>if (!value)</p>\n<h2 id=\"4-3-3-浮点变量与零值比较\"><a href=\"#4-3-3-浮点变量与零值比较\" class=\"headerlink\" title=\"4.3.3 浮点变量与零值比较\"></a>4.3.3 浮点变量与零值比较</h2><p>【规则4-3-3】不可将浮点变量用“&#x3D;&#x3D;”或“！&#x3D;”与任何数字比较。千万要留意，无论是float 还是double 类型的变量，都有精度限制。所以一定要避免将浮点变量用“&#x3D;&#x3D;”或“！&#x3D;”与数字比较，应该设法转化成“&gt;&#x3D;”或“&lt;&#x3D;”形式。</p>\n<p>假设浮点变量的名字为x，应当将</p>\n<p>if (x &#x3D;&#x3D; 0.0) &#x2F;&#x2F; 隐含错误的比较<br>转化为<br>if ((x&gt;&#x3D;-EPSINON) &amp;&amp; (x&lt;&#x3D;EPSINON))</p>\n<p>其中EPSINON 是允许的误差（即精度）。</p>\n<h3 id=\"4-3-4-指针变量与零值比较\"><a href=\"#4-3-4-指针变量与零值比较\" class=\"headerlink\" title=\"4.3.4 指针变量与零值比较\"></a>4.3.4 指针变量与零值比较</h3><p>【规则4-3-4】应当将指针变量用“&#x3D;&#x3D;”或“！&#x3D;”与NULL 比较。指针变量的零值是“空”（记为NULL）。尽管NULL 的值与0 相同，但是两者意义不同。假设指针变量的名字为p，它与零值比较的标准if 语句如下：</p>\n<p>if (p &#x3D;&#x3D; NULL) &#x2F;&#x2F; p 与NULL 显式比较，强调p 是指针变量</p>\n<p>if (p !&#x3D; NULL)<br>不要写成<br>if (p &#x3D;&#x3D; 0) &#x2F;&#x2F; 容易让人误解p 是整型变量<br>if (p !&#x3D; 0)<br>或者<br>if (p) &#x2F;&#x2F; 容易让人误解p 是布尔变量</p>\n<p>if (!p)</p>\n<h3 id=\"4-3-5-对if-语句的补充说明\"><a href=\"#4-3-5-对if-语句的补充说明\" class=\"headerlink\" title=\"4.3.5 对if 语句的补充说明\"></a>4.3.5 对if 语句的补充说明</h3><p>有时候我们可能会看到 if (NULL &#x3D;&#x3D; p) 这样古怪的格式。不是程序写错了，是程序员为了防止将 if (p &#x3D;&#x3D; NULL) 误写成 if (p &#x3D; NULL)，而有意把p 和NULL 颠倒。编译器认为 if (p &#x3D; NULL) 是合法的，但是会指出 if (NULL &#x3D; p)是错误的，因为NULL不能被赋值。</p>\n<h1 id=\"4-4-循环语句的效率\"><a href=\"#4-4-循环语句的效率\" class=\"headerlink\" title=\"4.4 循环语句的效率\"></a>4.4 循环语句的效率</h1><p>【建议4-4-1】在多重循环中，如果有可能，应当将最长的循环放在最内层，最短的循环放在最外层，以减少CPU 跨切循环层的次数。例如示例4-4(b)的效率比示例4-4(a)的高。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">// 示例 4-4(a) 低效率：长循环在最外层 </span><br><span class=\"hljs-keyword\">for</span> (row=<span class=\"hljs-number\">0</span>; row&lt;<span class=\"hljs-number\">100</span>; row++)<br>&#123;<br>    <span class=\"hljs-keyword\">for</span> ( col=<span class=\"hljs-number\">0</span>; col&lt;<span class=\"hljs-number\">5</span>; col++ )<br>    &#123;<br>        sum = sum + a[row][col];<br>    &#125;<br>&#125;<br><span class=\"hljs-comment\">// 示例4-4(b) 高效率：长循环在最内层</span><br><span class=\"hljs-keyword\">for</span> (col=<span class=\"hljs-number\">0</span>; col&lt;<span class=\"hljs-number\">5</span>; col++ )<br>&#123;<br>    <span class=\"hljs-keyword\">for</span> (row=<span class=\"hljs-number\">0</span>; row&lt;<span class=\"hljs-number\">100</span>; row++)<br>    &#123;<br>        sum = sum + a[row][col];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n<p>【建议4-4-2】如果循环体内存在逻辑判断，并且循环次数很大，宜将逻辑判断移到循环体的外面。示例4-4(c)的程序比示例4-4(d)多执行了N-1 次逻辑判断。并且由于前者老要进行逻辑判断，打断了循环“流水线”作业，使得编译器不能对循环进行优化处理，降低了效率。如果N 非常大，最好采用示例4-4(d)的写法，可以提高效率。如果N 非常小，两者效率差别并不明显，采用示例4-4(c)的写法比较好，因为程序更加简洁。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">// 效率低但程序简洁</span><br><span class=\"hljs-keyword\">for</span> (i=<span class=\"hljs-number\">0</span>; i&lt;N; i++)<br>&#123;<br>    <span class=\"hljs-keyword\">if</span> (condition)<br>        DoSomething();<br>    <span class=\"hljs-keyword\">else</span><br>        DoOtherthing();<br>&#125;<br><span class=\"hljs-comment\">// 效率高但程序不简洁</span><br><span class=\"hljs-keyword\">if</span> (condition)<br>&#123;<br>    <span class=\"hljs-keyword\">for</span> (i=<span class=\"hljs-number\">0</span>; i&lt;N; i++)<br>        DoSomething();<br>&#125;<br><span class=\"hljs-keyword\">else</span><br>&#123;<br>    <span class=\"hljs-keyword\">for</span> (i=<span class=\"hljs-number\">0</span>; i&lt;N; i++)<br>        DoOtherthing();<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"4-5-for-语句的循环控制变量\"><a href=\"#4-5-for-语句的循环控制变量\" class=\"headerlink\" title=\"4.5 for 语句的循环控制变量\"></a>4.5 for 语句的循环控制变量</h1><p>【规则4-5-1】不可在for 循环体内修改循环变量，防止for 循环失去控制。<br>【建议4-5-1】建议for 语句的循环控制变量的取值采用“半开半闭区间”写法。<br>示例 4-5(a)中的x 值属于半开半闭区间“0 &#x3D;&lt; x &lt; N”，起点到终点的间隔为N，循环次数为N。<br>示例 4-5(b)中的x 值属于闭区间“0 &#x3D;&lt; x &lt;&#x3D; N-1”，起点到终点的间隔为N-1，循环次数为N。</p>\n<p>相比之下，示例4-5(a)的写法更加直观，尽管两者的功能是相同的。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">// 循环变量属于半开半闭区间 </span><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> x=<span class=\"hljs-number\">0</span>; x&lt;N; x++)<br>&#123;<br>    ⋯<br>&#125;<br><span class=\"hljs-comment\">// 循环变量属于闭区间</span><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> x=<span class=\"hljs-number\">0</span>; x&lt;=N<span class=\"hljs-number\">-1</span>; x++)<br>&#123;<br>    ⋯<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"4-6-switch-语句\"><a href=\"#4-6-switch-语句\" class=\"headerlink\" title=\"4.6 switch 语句\"></a>4.6 switch 语句</h1><p>【规则4-6-1】每个case 语句的结尾不要忘了加break，否则将导致多个分支重叠（除非有意使多个分支重叠）。<br>【规则4-6-2】不要忘记最后那个default 分支。即使程序真的不需要default 处理，也应该保留语句 default : break; 这样做并非多此一举，而是为了防止别人误以为你忘了default 处理。</p>\n<h1 id=\"4-7-goto-语句\"><a href=\"#4-7-goto-语句\" class=\"headerlink\" title=\"4.7 goto 语句\"></a>4.7 goto 语句</h1><p>自从提倡结构化设计以来，goto 就成了有争议的语句。首先，由于goto 语句可以灵活跳转，如果不加限制，它的确会破坏结构化设计风格。其次，goto 语句经常带来错误或隐患。它可能跳过了某些对象的构造、变量的初始化、重要的计算等语句，例如：</p>\n<figure class=\"highlight pf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pf\">goto <span class=\"hljs-keyword\">state</span>;<br>String s1, s2; // 被goto 跳过<br>int sum = <span class=\"hljs-number\">0</span>; // 被goto 跳过<br>⋯<br><span class=\"hljs-keyword\">state</span>:<br>⋯<br></code></pre></td></tr></table></figure>\n\n<p>所以我们主张少用、慎用goto 语句，而不是禁用。</p>\n<h1 id=\"5-1-为什么需要常量\"><a href=\"#5-1-为什么需要常量\" class=\"headerlink\" title=\"5.1 为什么需要常量\"></a>5.1 为什么需要常量</h1><p>如果不使用常量，直接在程序中填写数字或字符串，将会有什么麻烦？<br>（1） 程序的可读性（可理解性）变差。程序员自己会忘记那些数字或字符串是什么意思，用户则更加不知它们从何处来、表示什么。<br>（2） 在程序的很多地方输入同样的数字或字符串，难保不发生书写错误。</p>\n<p>（3） 如果要修改数字或字符串，则会在很多地方改动，既麻烦又容易出错。</p>\n<p>【规则5-1-1】尽量使用含义直观的常量来表示那些将在程序中多次出现的数字或字符串。</p>\n<h1 id=\"5-2-const-与-define-的比较\"><a href=\"#5-2-const-与-define-的比较\" class=\"headerlink\" title=\"5.2 const 与 #define 的比较\"></a>5.2 const 与 #define 的比较</h1><p>C++ 语言可以用const 来定义常量，也可以用 #define 来定义常量。但是前者比后者有更多的优点：<br>（1） const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误（边际效应）。</p>\n<p>（2） 有些集成化的调试工具可以对 const 常量进行调试，但是不能对宏常量进行调试。</p>\n<p>【规则5-2-1】在C++ 程序中只使用const 常量而不使用宏常量，即const 常量完全取代宏常量</p>\n<h1 id=\"5-3-常量定义规则\"><a href=\"#5-3-常量定义规则\" class=\"headerlink\" title=\"5.3 常量定义规则\"></a>5.3 常量定义规则</h1>",
            "tags": [
                "c"
            ]
        }
    ]
}
{
    "version": "https://jsonfeed.org/version/1",
    "title": "Oikiou's Blog • All posts by \"note\" tag",
    "description": "Blog",
    "home_page_url": "https://www.oikiou.top",
    "items": [
        {
            "id": "https://www.oikiou.top/2020/da7ed36c/",
            "url": "https://www.oikiou.top/2020/da7ed36c/",
            "title": "MarkDown学习笔记",
            "date_published": "2020-08-08T00:08:08.000Z",
            "content_html": "<h2 id=\"二级标题\"><a href=\"#二级标题\" class=\"headerlink\" title=\"二级标题\"></a>二级标题</h2><h3 id=\"三级标题\"><a href=\"#三级标题\" class=\"headerlink\" title=\"三级标题\"></a>三级标题</h3><h4 id=\"四级标题\"><a href=\"#四级标题\" class=\"headerlink\" title=\"四级标题\"></a>四级标题</h4><h5 id=\"五级标题\"><a href=\"#五级标题\" class=\"headerlink\" title=\"五级标题\"></a>五级标题</h5><h6 id=\"六级标题\"><a href=\"#六级标题\" class=\"headerlink\" title=\"六级标题\"></a>六级标题</h6><p>asdasdasdasdassdasdas</p>\n<h2 id=\"这是一段引用\"><a href=\"#这是一段引用\" class=\"headerlink\" title=\"这是一段引用\"></a>这是一段引用</h2><blockquote>\n<p>这是一段引用</p>\n</blockquote>\n<h2 id=\"无序列表\"><a href=\"#无序列表\" class=\"headerlink\" title=\"无序列表\"></a>无序列表</h2><ul>\n<li>阿斯大声</li>\n<li>阿斯大声打</li>\n<li>阿斯大声问请问恶</li>\n</ul>\n<h2 id=\"有序列表\"><a href=\"#有序列表\" class=\"headerlink\" title=\"有序列表\"></a>有序列表</h2><ol>\n<li><p>阿斯大声打</p>\n</li>\n<li><p>阿斯大声阿斯大声</p>\n</li>\n<li><p>dasd阿斯dasdaaa</p>\n</li>\n</ol>\n<h2 id=\"斜体-和-加粗-强调\"><a href=\"#斜体-和-加粗-强调\" class=\"headerlink\" title=\"斜体 和 加粗 (强调)\"></a>斜体 和 加粗 (强调)</h2><p>这是<em>斜体</em>      这是<strong>加粗</strong>   这是_什么呢_  好像也__是一样的__</p>\n<h2 id=\"这段是横线\"><a href=\"#这段是横线\" class=\"headerlink\" title=\"这段是横线\"></a>这段是横线</h2><hr>\n<hr>\n<h2 id=\"超链接\"><a href=\"#超链接\" class=\"headerlink\" title=\"超链接\"></a>超链接</h2><p><a href=\"./assets/00.jpg\">这是超链接</a></p>\n<p><a href=\".%5Cassets%5C00.jpg\">www.Baidu.com</a></p>\n<p><a href=\"https://sigrok.org/wiki/Protocol_decoder_API\">这是一个超链接 （注意链接前后不要留空格）</a></p>\n<p>This is <a href=\"http://example.com/\" title=\"Optional Title Here\">an example</a> reference-style link.</p>\n<h2 id=\"文章内的超链接\"><a href=\"#文章内的超链接\" class=\"headerlink\" title=\"文章内的超链接\"></a><a id=\"文章内的超链接\">文章内的超链接</a></h2><p> <a href=\"##%E8%A1%A8%E6%A0%BC\">这是一个文章内部的超链接</a></p>\n<p> Ctrl+左键  </p>\n<p><a href=\"#HTML跳转\">回到-&gt;HTML 跳转</a></p>\n<h2 id=\"Email-链接\"><a href=\"#Email-链接\" class=\"headerlink\" title=\"Email 链接\"></a>Email 链接</h2><p>作者的 Emal <a href=\"mailto:&#120;&#120;&#64;&#120;&#x78;&#46;&#x63;&#x6f;&#109;\">&#120;&#120;&#64;&#120;&#x78;&#46;&#x63;&#x6f;&#109;</a> 链接</p>\n<h2 id=\"插入图片\"><a href=\"#插入图片\" class=\"headerlink\" title=\"插入图片\"></a>插入图片</h2><ul>\n<li>内联风格</li>\n</ul>\n<p><img src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1557132849466&di=61258032fff80f7d4bfff0ad0b325b12&imgtype=0&src=http://s6.sinaimg.cn/middle/6dca756dhad5c3293f515&690\" alt=\"iPhone\"></p>\n<ul>\n<li>引用风格</li>\n</ul>\n<p><strong>一直没弄出来</strong></p>\n<p>xxx<img src=\"/photo_id\" alt=\"photo_id\"></p>\n<h2 id=\"代码块-与-代码行\"><a href=\"#代码块-与-代码行\" class=\"headerlink\" title=\"代码块 与 代码行\"></a>代码块 与 代码行</h2><p><code>  delay_init();\t    \t //延时函数初始化\t</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>\tdelay_init();\t    \t <span class=\"hljs-comment\">//延时函数初始化\t</span><br>\tTIM_ALL_Init();<br> \tLED_Init();\t\t\t     <span class=\"hljs-comment\">//LED端口初始化</span><br>\tLCD_Init();<br>\tPOINT_COLOR=WHITE;<br>\tBACK_COLOR = BLACK;<br>\tLCD_Clear(BLACK);<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h2><table>\n<thead>\n<tr>\n<th>name</th>\n<th>age</th>\n<th>sex</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Done</td>\n<td>20</td>\n<td>0</td>\n</tr>\n<tr>\n<td>Jack</td>\n<td>21</td>\n<td>0</td>\n</tr>\n<tr>\n<td>Done<br/>这里换行了</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"删除线\"><a href=\"#删除线\" class=\"headerlink\" title=\"删除线\"></a>删除线</h2><p><del>这是一条删除             线线线线线线线线线线线线线线线</del></p>\n<h2 id=\"下划线\"><a href=\"#下划线\" class=\"headerlink\" title=\"下划线\"></a>下划线</h2><p><u>xiahuaxian</u></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\"><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">u</span>&gt;</span></span>xiahuaxian<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">u</span>&gt;</span></span><br></code></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"这是一个注释\"><a href=\"#这是一个注释\" class=\"headerlink\" title=\"这是一个注释\"></a>这是一个注释</h2><p>[注释] <a href=\"%E8%BF%99%E6%98%AF%E6%B3%A8%E9%87%8A%E7%9A%84%E8%A7%A3%E9%87%8A\">^注释</a>:Somebody that I used to know.</p>\n<h2 id=\"数学表达式\"><a href=\"#数学表达式\" class=\"headerlink\" title=\"数学表达式\"></a>数学表达式</h2><p>$ (h&#x2F;2)<em>(a+9)&#x2F;(b</em>9))*L $</p>\n<p>$lim_{x \\to \\infty} \\ exp(-x)&#x3D;0$</p>\n<h2 id=\"修改文字颜色-HTLML\"><a href=\"#修改文字颜色-HTLML\" class=\"headerlink\" title=\"修改文字颜色 HTLML\"></a>修改文字颜色 HTLML</h2><p>You can use HTML to style content what pure Markdown does not support.</p>\n<p><span style=\"color:red\"><strong>TEXT Style</strong></span></p>\n<p><span style=\"color:#29b6f6\"> <strong>TEXT Style</strong> </span></p>\n<p><span style=\"color:rgb(255, 255, 255)\"><strong>TEXT Style</strong></span></p>\n<p><span style=\"color:LightPink\"> <strong>TEXT Style</strong> </span></p>\n<p><span style=\"color:Thistle\"> <strong>TEXT Style</strong> </span></p>\n<p><span style=\"color:Gold\"> <strong>TEXT Style</strong> </span></p>\n<p><span style=\"color:Tomato\"> <strong>TEXT Style</strong> </span></p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;color:red&quot;</span>&gt;</span> <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;color:#29b6f6&quot;</span>&gt;</span> <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;color:rgb(255, 255, 255)&quot;</span>&gt;</span> <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span><br><br>https://www.5tu.cn/colors/yansezhongwenming.html<br></code></pre></td></tr></table></figure>\n\n<p>For example, use <code>&lt;span style=&quot;color:red&quot;&gt;this text is red&lt;/span&gt;</code> to add text with red color.</p>\n<h2 id=\"表情-Emoji-smile\"><a href=\"#表情-Emoji-smile\" class=\"headerlink\" title=\"表情 Emoji :smile:\"></a>表情 Emoji :smile:</h2><p>Input emoji with syntax <code>:smile:</code>.</p>\n<p>User can trigger auto-complete suggestions for emoji by pressing <code>ESC</code> key, or trigger it automatically after enabling it on preference panel. Also, inputting UTF-8 emoji characters directly is also supported by going to <code>Edit</code> -&gt; <code>Emoji &amp; Symbols</code> in the menu bar (macOS).</p>\n<h2 id=\"Task-List-带勾的计划任务-勾选框\"><a href=\"#Task-List-带勾的计划任务-勾选框\" class=\"headerlink\" title=\"Task List 带勾的计划任务 勾选框\"></a>Task List 带勾的计划任务 勾选框</h2><ul>\n<li><input disabled=\"\" type=\"checkbox\"> a task list item</li>\n<li><input disabled=\"\" type=\"checkbox\"> list syntax required </li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> completed</li>\n</ul>\n<p>注意    [内有一个空格] </p>\n<h2 id=\"Video\"><a href=\"#Video\" class=\"headerlink\" title=\"Video\"></a>Video</h2><p>You can use the <code>&lt;video&gt;</code> HTML tag to embed videos. For example:</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Markdown\"><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">video</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;xxx.mp4&quot;</span> /&gt;</span></span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"脚注\"><a href=\"#脚注\" class=\"headerlink\" title=\"脚注\"></a>脚注</h2><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\">文字[^脚注1]文字.<br>[<span class=\"hljs-symbol\">^脚注1</span>]:<span class=\"hljs-link\">这是脚注1的内容</span><br></code></pre></td></tr></table></figure>\n\n<p>文字<a href=\"%E8%BF%99%E6%98%AF%E8%84%9A%E6%B3%A81%E7%9A%84%E5%86%85%E5%AE%B9\">^脚注1</a>文字.</p>\n<h2 id=\"上下标\"><a href=\"#上下标\" class=\"headerlink\" title=\"上下标\"></a>上下标</h2><p><strong>1.实现下标与上标的三种方法：</strong></p>\n<ul>\n<li><p>方法1（符号）：(这是Markdown的拓展语法)</p>\n<figure class=\"highlight parser3\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs parser3\"><span class=\"language-xml\">下标 ：θ~</span><span class=\"hljs-number\">1</span><span class=\"language-xml\">~ </span><br><span class=\"language-xml\">上标 ：θ</span><span class=\"hljs-keyword\">^2</span><span class=\"language-xml\">^</span><br><span class=\"language-xml\"></span><span class=\"hljs-number\">12</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p>结果如下：<br>下标 ：θ<del>1</del><br>上标 ：θ^2^</p>\n</li>\n<li><p>方法2（HTML标签）：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\">下标 ：θ<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">sub</span>&gt;</span>1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">sub</span>&gt;</span><br>上标 ：θ<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">sup</span>&gt;</span>2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">sup</span>&gt;</span><br>12<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>结果如下：<br>下标 ：θ<sub>1</sub><br>上标 ：θ<sup>2</sup></p>\n</li>\n<li><p>方法3（公式块）：</p>\n<figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gams\"><span class=\"hljs-symbol\">$</span><span class=\"hljs-symbol\">$</span><br>下标 ：θ_1 ，上标 ：θ^<span class=\"hljs-number\">2</span><br><span class=\"hljs-symbol\">$</span><span class=\"hljs-symbol\">$</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p>结果如下：</p>\n</li>\n<li><p>$$<br>下标 ：θ_1 ，上标 ：θ^2<br>$$</p>\n</li>\n</ul>\n<h1 id=\"Note\"><a href=\"#Note\" class=\"headerlink\" title=\"Note\"></a>Note</h1><h2 id=\"HTML-跳转\"><a href=\"#HTML-跳转\" class=\"headerlink\" title=\"HTML 跳转\"></a><a id=\"HTML跳转\">HTML 跳转</a></h2><p><a href=\"#文章内的超链接\">点击到达-&gt;文章内的超链接</a> </p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\">&lt;<span class=\"hljs-keyword\">a</span> href=<span class=\"hljs-string\">&quot;#demo&quot;</span>&gt;点击到达跳转位置演示&lt;/<span class=\"hljs-keyword\">a</span>&gt; <span class=\"hljs-comment\"># 在需要跳转的地方添加此代码。</span><br>&lt;<span class=\"hljs-keyword\">a</span> id=<span class=\"hljs-string\">&quot;demo&quot;</span>&gt;跳转位置演示（跳转位置设置点）&lt;/<span class=\"hljs-keyword\">a</span>&gt; <span class=\"hljs-comment\"># 在跳转位置添加次代码。</span><br></code></pre></td></tr></table></figure>\n\n\n\n",
            "tags": [
                "markdown",
                "note"
            ]
        },
        {
            "id": "https://www.oikiou.top/2018/ef667962/",
            "url": "https://www.oikiou.top/2018/ef667962/",
            "title": "嵌入式编程杂乱笔记",
            "date_published": "2018-03-11T14:57:15.000Z",
            "content_html": "<h1 id=\"嵌入式编程杂乱笔记目录\"><a href=\"#嵌入式编程杂乱笔记目录\" class=\"headerlink\" title=\"嵌入式编程杂乱笔记目录\"></a>嵌入式编程杂乱笔记目录</h1><p>[TOC]</p>\n<h1 id=\"硬件类\"><a href=\"#硬件类\" class=\"headerlink\" title=\"硬件类\"></a>硬件类</h1><h2 id=\"NTC和PTC\"><a href=\"#NTC和PTC\" class=\"headerlink\" title=\"NTC和PTC\"></a>NTC和PTC</h2><p>NTC (Negative Temperature Coefficient 负温度系数)      PTC (Positive 正温度系数)</p>\n<h2 id=\"VCC、-VDD、VEE、VSS区别\"><a href=\"#VCC、-VDD、VEE、VSS区别\" class=\"headerlink\" title=\"VCC、 VDD、VEE、VSS区别\"></a>VCC、 VDD、VEE、VSS区别</h2><ul>\n<li>一、解释<br>VCC：C&#x3D;circuit 表示电路的意思, 即接入电路的电压；<br>VDD：D&#x3D;device 表示器件的意思, 即器件内部的工作电压；<br>VSS：S&#x3D;series 表示公共连接的意思，通常指电路公共接地端电压；<br>VEE：负电压供电；<br>VPP：编程&#x2F;擦除电压。</li>\n<li>二、说明<br>1、对于数字电路来说，VCC是电路的供电电压,VDD是芯片的工作电压（通常Vcc&gt;Vdd），VSS是接地点。<br>2、有些IC既有VDD引脚又有VCC引脚，说明这种器件自身带有电压转换功能。<br>3、在场效应管（或COMS器件）中，VDD为漏极，VSS为源极，VDD和VSS指的是元件引脚，而不表示供电电压。</li>\n</ul>\n<h2 id=\"NOR-NAND\"><a href=\"#NOR-NAND\" class=\"headerlink\" title=\"NOR NAND\"></a>NOR NAND</h2><p>NOR(或非) NAND(与非)</p>\n<p>SLC（Single-Level Cell）、MLC（Multi-Level Cell） 、 TLC（Triple-Level Cell）</p>\n<p><strong>共同点：</strong></p>\n<p>两者向浮栅中注入电子表示0(电子浮栅效应管存在导电沟道bit位被接地 见后续图片)，未注入表示1，对其清除数据是对其写1。</p>\n<ul>\n<li><strong>NOR FLASH</strong><ul>\n<li>随机读取(可随机读取，能直接运行代码，BIOS)</li>\n<li>随机读取较快、写入较很慢(热电子注入效率更低)、擦除次数较少、</li>\n<li>容量较小、体积较小、可靠性高一些、数据保存期更高</li>\n<li>初始通电消耗更多的电流, 待机状态电流远远更低</li>\n<li></li>\n<li>浮栅 热电子注入方式充电、FN隧道效应放电</li>\n</ul>\n</li>\n<li><strong>NAND FLASH</strong><ul>\n<li>块读取(块读取，不能运行代码)</li>\n<li>随机读取较慢(地址线复用导致)、顺序读取速度较快、写入较快、擦除次数较多、</li>\n<li>容量较大、体积较大、可靠性较低一些(较容易发生位交换现象)、数据保存期低一些</li>\n<li>待机状态功耗较高</li>\n<li></li>\n<li>浮栅 FN隧道效应充电、FN隧道效应放电</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/2018/ef667962/contenteetimes-images-design-embedded-2018-fl-1-t1.jpg\" alt=\"img\"></p>\n<h3 id=\"详细介绍\"><a href=\"#详细介绍\" class=\"headerlink\" title=\"详细介绍\"></a>详细介绍</h3><h4 id=\"浮栅效应管\"><a href=\"#浮栅效应管\" class=\"headerlink\" title=\"浮栅效应管\"></a>浮栅效应管</h4><p>NOR FLASH 和 NAND FLASH 都是使用浮栅场效应管(Floating Gate FET)作为基本存储单元来存储数据的，浮栅场效应管共有 4 个端电极，分别是为源极（Source）、漏极（Drain）、控制栅极（Control Gate）和浮置栅极（Floating Gate），前 3 个端电极的作用于普通 MOSFET 是一样的，区别仅在于浮栅，FLASH 就是利用浮栅是否存储电荷来表征数字 0’和‘1’的。</p>\n<p>当向浮栅注入电荷后，D 和 S 之间存在导电沟道，从 D 极读到‘0’<span style=\"color:#29b6f6\">(电子浮栅效应管存在导电沟道bit位被接地 见后续图片)</span>；当浮栅中没有电荷时，D 和 S 间没有导电沟道，从 D 极读到‘1’，原理示意图见图</p>\n<p>注：SLC 可以简单认为是利用浮栅是否存储电荷来表征数字 0’和‘1’的，MLC 则是要利用浮栅中电荷的多少来表征‘00’，‘01’，‘10’和‘11’的，TLC 与 MLC 类似。</p>\n<blockquote>\n<p>  SLC传统上，每个储存单元内储存1个信息位，称为单阶储存单元（Single-Level Cell，SLC）。SLC闪存的优点是传输速度更快，功率消耗更低和储存单元的寿命更长，成本也就更高。一般情况下，SLC多数用于企业级的固态硬盘中，由于企业对于数据的安全性要求更高，需要保存更长时间。</p>\n<p>  MLC多阶储存单元（Multi-Level Cell,MLC）可以在每个储存单元内储存2个以上的信息位。与SLC相比，MLC成本较低，其传输速度较慢，功率消耗较高和储存单元的寿命较低。 但目前主流的固态硬盘中，性能较为优秀的产品选用的都是MLC颗粒，因此可以说MLC颗粒的固态硬盘拥有较高的性价比。甚至一些企业级的固态硬盘，使用的也是MLC颗粒，被专门优化过，称为eMLC颗粒，e代表的是企业enterprise。</p>\n<p>  TLC三阶储存单元（Triple-Level Cell, TLC），这种架构的原理与MLC类似，但可以在每个储存单元内储存3个信息位。由于存储的数据密度相对MLC和SLC更大，所以价格也就更便宜，但使用寿命和性能也就更低，不过这并不能阻止人们购买TLC颗粒的固态硬盘。甚至目前市场上绝大多数的入门级产品使用的都是TLC颗粒。而为了解决TLC颗粒过低的写入寿命问题，许多厂商都在研发新技术，3D-TLC就是这样的技术，目前已经比较广泛的应用在产品中，其性能甚至可以和MLC颗粒一较长短，使用寿命得到大幅度的延长。</p>\n</blockquote>\n<p><img src=\"/2018/ef667962/20200311_01_Nor_FLASH_vs_NAND_FLASH.png\" alt=\"Nor FLASH和NAND FLASH基本结构和特点的异同\"></p>\n<h5 id=\"读-写-擦除\"><a href=\"#读-写-擦除\" class=\"headerlink\" title=\"读 写 擦除\"></a>读 写 擦除</h5><p>FLASH 中，常用的向浮栅注入电荷的技术有两种—热电子注入(hot electron injection)和 F-N 隧道效应(Fowler Nordheim tunneling)；从浮栅中挪走电荷的技术通常使用 F-N 隧道效应(Fowler Nordheim tunneling)，基本原理见图。</p>\n<p>写操作就是向浮栅注入电荷的过程，NOR FLASH 通过热电子注入方式向浮栅注入电荷（这种方法的电荷注入效率较低，因此 NOR FLASH 的写速率较低），NAND FLASH 则通过 F-N 隧道效应向浮栅注入电荷。FLASH 在写操作之前，必须先将原来的数据擦除（即将浮栅中的电荷挪走），也即 FLASH 擦除后读出的都是‘1’。<span style=\"color:#29b6f6\">(只能擦除再写入的原因应该是擦除和写入加的电压是反向的, 一个是充电, 一个是放电)</span></p>\n<p>擦除操作就是从浮栅中挪走电荷的过程，NOR FLASH 和 NAND FLASH 都是通过 F-N 隧道效应将浮栅中的电荷挪走的。</p>\n<p>读出操作时，控制栅极上施加的电压很小，不会改变浮栅中的电荷量，即读出操作不会改变 FLASH 中原有的数据，也即浮栅有电荷时，D 和 S 间存在导电沟道，从 D 极读到‘0’<span style=\"color:#29b6f6\">(电子浮栅效应管存在导电沟道bit位被接地 见后续图片)</span>；当浮栅中没有电荷时，D 和 S 间没有导电沟道，从 D 极读到‘1’。</p>\n<p><a href=\"https://www.sunev.cn/blog/wp-content/uploads/2020/03/20200311_03_Nor_FLASH_vs_NAND_FLASH.png\"><img src=\"/2018/ef667962/20200311_03_Nor_FLASH_vs_NAND_FLASH.png\" alt=\"Nor FLASH和NAND FLASH基本结构和特点的异同\"></a></p>\n<h4 id=\"NOR-和-NAND-Flash-的结构特性\"><a href=\"#NOR-和-NAND-Flash-的结构特性\" class=\"headerlink\" title=\"NOR 和 NAND Flash 的结构特性\"></a>NOR 和 NAND Flash 的结构特性</h4><h6 id=\"NOR-Flash\"><a href=\"#NOR-Flash\" class=\"headerlink\" title=\"NOR Flash\"></a>NOR Flash</h6><p>NOR FLASH 的结构原理图见图 ，可见每个 Bit Line 下的基本存储单元是并联的，当某个 Word Line 被选中后，就可以实现对该 Word 的读取，也就是可以实现位读取（即 Random Ａccess），且具有较高的读取速率</p>\n<p>下图是一个 3*8bit 的 NOR FLASH 的原理结构图，这种并联结构决定了 NOR FLASH 的很多特性。</p>\n<p><img src=\"/2018/ef667962/20200311_04_Nor_FLASH_vs_NAND_FLASH.png\" alt=\"Nor FLASH和NAND FLASH基本结构和特点的异同\"></p>\n<p>下图是沿 Bit Line 切面的剖面图，展示了 NOR FLASH 的硅切面示意图，</p>\n<p><img src=\"/2018/ef667962/20200311_05_Nor_FLASH_vs_NAND_FLASH.png\" alt=\"Nor FLASH和NAND FLASH基本结构和特点的异同\"></p>\n<ol>\n<li>基本存储单元的并联结构决定了金属导线占用很大的面积，因此 NOR　FLASH 的存储密度较低，无法适用于需要大容量存储的应用场合，即适用于 code-storage，不适用于 data-storage。</li>\n<li>基本存储单元的并联结构决定了 NOR FLASH 具有存储单元可独立寻址且读取效率高的特性，因此适用于 code-storage，且程序可以直接在 NOR 中运行（即具有 RAM 的特性）。</li>\n<li>NOR FLASH 写入采用了热电子注入方式，效率较低，因此 NOR 写入速率较低，不适用于频繁擦除&#x2F;写入场合。</li>\n</ol>\n<blockquote>\n<p>  最后来个小贴士：NOR  FLASH 的中的 N 是 NOT，含义是 Floating Gate 中有电荷时，读出‘0’，无电荷时读出‘1’，是一种‘非’的逻辑；OR 的含义是同一个 Bit Line 下的各个基本存储单元是并联的，是一种‘或’的逻辑，这就是 NOR 的由来。 </p>\n</blockquote>\n<h6 id=\"NAND-Flash\"><a href=\"#NAND-Flash\" class=\"headerlink\" title=\"NAND Flash\"></a>NAND Flash</h6><p>NAND FLASH 的结构原理图见图，可见每个 Bit Line 下的基本存储单元是串联的，NAND 读取数据的单位是 Page，当需要读取某个 Page 时，FLASH 控制器就不在这个 Page 的 Word Line 施加电压，而对其他所有 Page 的 Word Line 施加电压（电压值不能改变 Floating Gate 中电荷数量），让这些 Page 的所有基本存储单元的 D 和 S 导通，而我们要读取的 Page 的基本存储单元的 D 和 S 的导通&#x2F;关断状态则取决于 Floating Gate 是否有电荷，有电荷时，Bit Line 读出‘0’，无电荷 Bit Line 读出‘1’，实现了 Page 数据的读出，可见 NAND 无法实现位读取（即 Random Ａccess），程序代码也就无法在 NAND 上运行。</p>\n<p>下图是一个 8*8bit 的 NAND FLASH 的原理结构图，NAND FLASH 的串联结构决定了其很多特点。</p>\n<p><img src=\"/2018/ef667962/20200311_07_Nor_FLASH_vs_NAND_FLASH.png\" alt=\"Nor FLASH和NAND FLASH基本结构和特点的异同\"></p>\n<p>下图是沿 Bit Line 切面的剖面图，展示了 NAND FLASH 的硅切面示意图</p>\n<p><img src=\"/2018/ef667962/20200311_08_Nor_FLASH_vs_NAND_FLASH.png\" alt=\"Nor FLASH和NAND FLASH基本结构和特点的异同\"></p>\n<ol>\n<li>基本存储单元的串联结构减少了金属导线占用的面积，Die 的利用率很高，因此 NAND FLASH 存储密度高，适用于需要大容量存储的应用场合，即适用于 data-storage，见图 3.3[3]。</li>\n<li>基本存储单元的串联结构决定了 NAND FLASH 无法进行位读取，也就无法实现存储单元的独立寻址，因此程序不可以直接在 NAND 中运行,因此 NAND 是以 Page 为读取单位和写入单位，以 Block 为擦除单位，见图 3.6。</li>\n<li>NAND FLASH 写入采用 F-N 隧道效应方式，效率较高，因此 NAND 擦除&#x2F;写入速率很高，适用于频繁擦除&#x2F;写入场合。同时 NAND 是以 Page 为单位进行读取的，因此读取速率也不算低（稍低于 NOR）。</li>\n</ol>\n<blockquote>\n<p>  最后来个小贴士：NAND FLASH 的中的 N 是 NOT，含义是 Floating Gate 中有电荷时，读出‘0’，无电荷时读出‘1’，是一种‘非’的逻辑；AND 的含义是同一个 Bit Line 下的各个基本存储单元是串联的，是一种‘与’的逻辑，这就是 NAND 的由来。</p>\n</blockquote>\n<h6 id=\"NOR-和-NAND-的对比\"><a href=\"#NOR-和-NAND-的对比\" class=\"headerlink\" title=\"NOR 和 NAND 的对比\"></a>NOR 和 NAND 的对比</h6><p><img src=\"/2018/ef667962/20200311_10_Nor_FLASH_vs_NAND_FLASH.png\" alt=\"Nor FLASH和NAND FLASH基本结构和特点的异同\"></p>\n<p><img src=\"/2018/ef667962/20200311_11_Nor_FLASH_vs_NAND_FLASH.png\" alt=\"Nor FLASH和NAND FLASH基本结构和特点的异同\"></p>\n<h1 id=\"编译器相关\"><a href=\"#编译器相关\" class=\"headerlink\" title=\"编译器相关\"></a>编译器相关</h1><h2 id=\"Keil仿真准确测量运行时间\"><a href=\"#Keil仿真准确测量运行时间\" class=\"headerlink\" title=\"Keil仿真准确测量运行时间\"></a>Keil仿真准确测量运行时间</h2><p>Debug-&gt;Setting-&gt;Trsce-&gt;Core 修改好核心时钟频率即可准确测量函数运行时间</p>\n<h2 id=\"程序内存位置分配\"><a href=\"#程序内存位置分配\" class=\"headerlink\" title=\"程序内存位置分配\"></a>程序内存位置分配</h2><ul>\n<li><p>bss段：</p>\n<ul>\n<li><strong>未初始化的全局变量</strong></li>\n<li>BSS段（BSS segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域。BSS是英文BlockStarted by Symbol的简称。BSS段属于静态内存分配。</li>\n</ul>\n</li>\n<li><p>data段：</p>\n<ul>\n<li><strong>已初始化的全局变量</strong></li>\n<li>数据段（DATA segment）通常是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。</li>\n</ul>\n</li>\n<li><p>text段：</p>\n<ul>\n<li>代码段</li>\n<li>代码段（CODE segment&#x2F;TEXTsegment）通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读,某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。</li>\n</ul>\n</li>\n<li><p>rodata段：</p>\n<ul>\n<li>？？？</li>\n<li>存放C中的字符串和#define定义的常量</li>\n</ul>\n</li>\n<li><p>heap堆：</p>\n<ul>\n<li>堆（程序员指定的内存 malloc）</li>\n<li>当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）</li>\n</ul>\n</li>\n<li><p>stack栈：</p>\n<ul>\n<li>栈</li>\n<li>是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存&#x2F;恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。</li>\n</ul>\n</li>\n<li><p>常量段：</p>\n<ul>\n<li>？？？</li>\n<li>常量段一般包含编译器产生的数据（与只读段包含用户定义的只读数据不同）。比如说由一个语句a&#x3D;2+3编译器把2+3编译期就算出5，存成常量5在常量段中</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Pragma-Pack-内存对齐\"><a href=\"#Pragma-Pack-内存对齐\" class=\"headerlink\" title=\"#Pragma Pack (内存对齐)\"></a>#Pragma Pack (内存对齐)</h2><h3 id=\"规则\"><a href=\"#规则\" class=\"headerlink\" title=\"规则\"></a>规则</h3><ol>\n<li><p>复杂类型中各个成员按照它们被声明的顺序在内存中顺序存储，第一个成员的地址和整个类型的地址相同</p>\n</li>\n<li><p>结构、联合或者类的对齐长度，按照#pragma pack    <strong>指定的对齐参数</strong>   和     <strong>这个数据成员自身长度</strong>     两个中    <strong>比较小</strong>     的那个进行。（确定成员位置）</p>\n</li>\n<li><p>复杂类型（如结构）整体的对齐&lt;注意是“整体”&gt;是按照结构体中     <strong>长度最大的数据成员</strong>     和    <strong>#pragma pack指定值之间</strong>     <strong>较小</strong>    的那个值进行；这样在成员是复杂类型时，可以最小化长度。（确定对齐大小）</p>\n</li>\n</ol>\n<p>即：先用规则3确定变量对齐的“容器”大小，再用规则2确定各个变量的存放位置。</p>\n<h3 id=\"看图\"><a href=\"#看图\" class=\"headerlink\" title=\"看图\"></a>看图</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">stc</span></span><br><span class=\"hljs-class\">&#123;</span><br>    <span class=\"hljs-type\">char</span> one;<br>    <span class=\"hljs-type\">short</span> two;<br>    <span class=\"hljs-type\">char</span> three;<br>    <span class=\"hljs-type\">int</span> four;<br>&#125; c,d;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>#pragma pack (1)</li>\n</ul>\n<p><img src=\"/2018/ef667962/%E6%97%A0%E6%A0%87%E9%A2%98.png\" alt=\"无标题\"></p>\n<ul>\n<li>#pragma pack (2)</li>\n</ul>\n<p><img src=\"/2018/ef667962/%E6%97%A0%E6%A0%87%E9%A2%98-1608969543089.png\" alt=\"无标题\"></p>\n<ul>\n<li>#pragma pack (4)</li>\n</ul>\n<p><img src=\"/2018/ef667962/%E6%97%A0%E6%A0%87%E9%A2%98-1608969576331.png\" alt=\"无标题\"></p>\n<h3 id=\"原型\"><a href=\"#原型\" class=\"headerlink\" title=\"原型\"></a>原型</h3><ul>\n<li><p>pragma pack(n)</p>\n</li>\n<li><p>pragma pack()</p>\n</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> pack(1)<span class=\"hljs-comment\">//自定义对齐参数   指定对齐参数</span></span><br><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> _<span class=\"hljs-title\">MotorStartStop_</span>&#123;</span><br>\t<span class=\"hljs-comment\">//Code******</span><br>&#125; MStartStopRec_TYPEDEF;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> pack()<span class=\"hljs-comment\">//取消自定义的对齐参数</span></span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><p>Pragma Pack(push)</p>\n</li>\n<li><p>Pragma Pack(pop)</p>\n</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> pack(push)<span class=\"hljs-comment\">//Push压栈  保存系统的对齐方式(push指令之前的对齐状态)</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> pack(1)<span class=\"hljs-comment\">//            自定义对齐方式</span></span><br><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> _<span class=\"hljs-title\">MotorStartStop_</span>&#123;</span><br>\t<span class=\"hljs-comment\">//Code******</span><br>&#125; MStartStopRec_TYPEDEF;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> pack(pop)<span class=\"hljs-comment\">//Pop弹出    恢复系统的对齐方式</span></span><br><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> pack(push,1)<span class=\"hljs-comment\">//此语句等同于以下两条语句</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> pack(push)</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> pack(1) </span><br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"pragma-OPTIMIZE-n-优化级别调整\"><a href=\"#pragma-OPTIMIZE-n-优化级别调整\" class=\"headerlink\" title=\"#pragma OPTIMIZE(n)(优化级别调整)\"></a>#pragma OPTIMIZE(n)(优化级别调整)</h2><p><span style=\"color:red\">在ARM里面已经用不了</span></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> save\t\t\t<span class=\"hljs-comment\">//SAVE指令将优化指令的当前设置存储到一个SAVE堆栈中。可以使用RESTORE指令还原设置。</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> optimize (1)</span><br><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">func</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>.<br>.<br>.<br>&#125;<br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> restore\t\t\t<span class=\"hljs-comment\">//RESTORE指令 恢复</span></span><br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"内联函数\"><a href=\"#内联函数\" class=\"headerlink\" title=\"内联函数\"></a>内联函数</h2><p> tip:宏函数</p>\n<p>在大多数情况下，内联特定功能的决定最好留给编译器。使用<code>__inline__</code>或<code>inline</code>关键字限定函数的功能向编译器暗示它可以内联该函数，<strong>但最终决定权在于编译器</strong>。使用限定函数将<code>__attribute__((always_inline))</code>强制编译器内联函数。 </p>\n<h3 id=\"inline内联\"><a href=\"#inline内联\" class=\"headerlink\" title=\"__inline内联\"></a><del>__inline内联</del></h3><p>最终决定权在于编译器,不使用</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> __inline <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">f</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> x)</span>&#123;<br>    <span class=\"hljs-keyword\">return</span> x*<span class=\"hljs-number\">5</span>+<span class=\"hljs-number\">1</span>;<br>&#125;<br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">g</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> x, <span class=\"hljs-type\">int</span> y)</span>&#123;<br>    <span class=\"hljs-keyword\">return</span> f(x) + f(y);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"forceinline强制内联\"><a href=\"#forceinline强制内联\" class=\"headerlink\" title=\"__forceinline强制内联\"></a>__forceinline强制内联</h3><ol>\n<li><p><code>__forceinline</code>的语义与C ++ <code>inline</code> 关键字的语义完全相同。编译器将尝试内联该函数，而不管其特性如何。</p>\n<p><strong>在某些情况下，编译器可能会选择忽略<code>__forceinline</code>关键字而不是内联函数。</strong>例如：</p>\n<ul>\n<li>递归函数永远不会内联到自身中。</li>\n<li>使用函数<code>alloca()</code>(内存分配函数)永远不会内联。</li>\n</ul>\n<p><code>__forceinline</code>是存储类限定符。它不影响函数的类型。</p>\n</li>\n<li><p>它等效于 <strong>attribute</strong>((always_inline))</p>\n</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">__forceinline <span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">max</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> x, <span class=\"hljs-type\">int</span> y)</span><br>&#123;<br>    <span class=\"hljs-keyword\">return</span> x &gt; y ? x : y; <span class=\"hljs-comment\">// always inline if possible</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">max</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> x, <span class=\"hljs-type\">int</span> y)</span> __<span class=\"hljs-title function_\">attribute__</span><span class=\"hljs-params\">((always_inline))</span>;<br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">max</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> x, <span class=\"hljs-type\">int</span> y)</span><br>&#123;<br>    <span class=\"hljs-keyword\">return</span> x &gt; y ? x : y; <span class=\"hljs-comment\">// always inline if possible</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"使用递减的循环可以提高程序运行效率\"><a href=\"#使用递减的循环可以提高程序运行效率\" class=\"headerlink\" title=\"使用递减的循环可以提高程序运行效率\"></a>使用递减的循环可以提高程序运行效率</h2><p><a href=\"http://www.keil.com/support/man/docs/armcc/armcc_chr1359124222426.htm\">参考  C代码中循环终止的优化 </a></p>\n<ul>\n<li>使用简单终止循环的条件。</li>\n<li>使用递减到0的循环 </li>\n<li>使用 unsigned int 类型</li>\n<li>与0进行对比</li>\n</ul>\n<h2 id=\"volatile-的使用\"><a href=\"#volatile-的使用\" class=\"headerlink\" title=\"volatile 的使用\"></a>volatile 的使用</h2><ul>\n<li>访问内存映射的外围设备。</li>\n<li>在多个线程之间共享全局变量。</li>\n<li>在中断例程或信号处理程序中访问全局变量。</li>\n</ul>\n<h2 id=\"纯函数-优化\"><a href=\"#纯函数-优化\" class=\"headerlink\" title=\"纯函数(优化)\"></a>纯函数(优化)</h2><p> <code>__pure</code>  </p>\n<p>纯函数定义：同样的的输入有同样的输出， 纯函数无法通过使用全局变量或通过指针间接读取或写入全局状态 </p>\n<p>优势：编译器通常可以执行强大的优化， 例如通用子表达式消除（CSE） 。</p>\n<h2 id=\"packed-pragma-packed-字节对齐\"><a href=\"#packed-pragma-packed-字节对齐\" class=\"headerlink\" title=\"__packed  #pragma packed 字节对齐\"></a>__packed  #pragma packed 字节对齐</h2><p> 将整个结构声明为 __packed 通常会导致代码大小和性能的损失。 </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">__packed <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">mystruct</span></span><br><span class=\"hljs-class\">&#123;</span><br>    <span class=\"hljs-type\">char</span> c;<br>    <span class=\"hljs-type\">short</span> s;<br>&#125; <span class=\"hljs-comment\">// 不建议的</span><br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">mystruct</span></span><br><span class=\"hljs-class\">&#123;</span><br>    <span class=\"hljs-type\">char</span> c;<br>    __packed <span class=\"hljs-type\">short</span> s; <span class=\"hljs-comment\">// 建议的</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p> <a href=\"http://www.keil.com/support/man/docs/armcc/armcc_chr1359124230195.htm\">参考</a></p>\n<p><a href=\"http://www.keil.com/support/man/docs/armcc/armcc_chr1359124230944.htm\">__packed和#pragma packed对比</a></p>\n<h2 id=\"func-FUNCTION-FILE-LINE\"><a href=\"#func-FUNCTION-FILE-LINE\" class=\"headerlink\" title=\"__func__ __FUNCTION__ __FILE__ __LINE__\"></a>__func__ __FUNCTION__ __FILE__ __LINE__</h2><p>__func__ __FUNCTION__ __FILE__ __LINE__</p>\n<p>获取当前函数名称</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">foo</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;This function is called &#x27;%s&#x27;.\\n&quot;</span>, __func__);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>prints:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">This function is called <span class=\"hljs-string\">&#x27;foo&#x27;</span>.<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"attribute-used-不能将其优化移除\"><a href=\"#attribute-used-不能将其优化移除\" class=\"headerlink\" title=\"__attribute__((used))不能将其优化移除\"></a>__attribute__((used))不能将其优化移除</h2><p>用这个东西声明函数之后，即使这个函数没有被引用，编译器也不能将其优化移除，仍然要求将此函数保留在工程中。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">lose_this</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>)</span>;<br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">keep_this</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>)</span> __<span class=\"hljs-title function_\">attribute__</span><span class=\"hljs-params\">((used))</span>;     <span class=\"hljs-comment\">// retained in object file</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">keep_this</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> arg)</span> &#123;<br>  <span class=\"hljs-keyword\">return</span> (arg+<span class=\"hljs-number\">1</span>);<br>&#125;<br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">keep_this_too</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>)</span> __<span class=\"hljs-title function_\">attribute__</span><span class=\"hljs-params\">((used))</span>; <span class=\"hljs-comment\">// 保留在工程文件中</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">keep_this_too</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> arg)</span> &#123;<br>  <span class=\"hljs-keyword\">return</span> (arg<span class=\"hljs-number\">-1</span>);<br>&#125;<br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>  <span class=\"hljs-keyword\">for</span> (;;);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"attribute-section-“XX-name”-放置到特定的段里面\"><a href=\"#attribute-section-“XX-name”-放置到特定的段里面\" class=\"headerlink\" title=\"__attribute__((section(“XX_name”)))放置到特定的段里面\"></a>__attribute__((section(“XX_name”)))放置到特定的段里面</h2><p><strong>XX_name:是输入段的名称(字符串)。</strong></p>\n<p>这个东西是告诉编译器，将特定的函数或者变量放置到特定的段里面。</p>\n<p>变量和函数在输入段中的地址是连续的，并顺序先按section名(也就是XX_name)排序，section内再按照函数名称进行排序。</p>\n<h2 id=\"attribute-at-0x00-将变量定义到指定的地方\"><a href=\"#attribute-at-0x00-将变量定义到指定的地方\" class=\"headerlink\" title=\"__attribute__((at(0x00)))将变量定义到指定的地方\"></a>__attribute__((at(0x00)))将变量定义到指定的地方</h2><p>将变量定义到指定的地方</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">//linux</span><br><span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">char</span> temp_A@<span class=\"hljs-number\">0x00</span>; <span class=\"hljs-comment\">//定义无符号变量temp_A，强制其地址为0x00 变量@地址</span><br><span class=\"hljs-comment\">//keil</span><br><span class=\"hljs-type\">uint8_t</span> cnt __attribute__((at(<span class=\"hljs-number\">0x20008000</span>))); <span class=\"hljs-comment\">//格式固定下划线为两个下划线，括号必须那么多层</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"attribute-alias-“sss”-起别名\"><a href=\"#attribute-alias-“sss”-起别名\" class=\"headerlink\" title=\"__attribute__((alias(“sss”)))起别名\"></a>__attribute__((alias(“sss”)))起别名</h2><p>相当于起别名</p>\n<h3 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">foo</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s\\n&quot;</span>, __FUNCTION__);<br>&#125;<br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">bar</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> __<span class=\"hljs-title function_\">attribute__</span><span class=\"hljs-params\">((alias(<span class=\"hljs-string\">&quot;foo&quot;</span>)))</span>;<br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">gazonk</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>    bar(); <span class=\"hljs-comment\">// calls foo</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Code-RO-RW-ZI\"><a href=\"#Code-RO-RW-ZI\" class=\"headerlink\" title=\"Code RO RW ZI\"></a>Code RO RW ZI</h2><p>Program Size: Code&#x3D;14554 RO-data&#x3D;1234 RW-data&#x3D;272 ZI-data&#x3D;6168  </p>\n<p>Program Size: Code&#x3D;13682 RO-data&#x3D;1098 RW-data&#x3D;224 ZI-data&#x3D;6160  </p>\n<ul>\n<li><p>Code </p>\n</li>\n<li><p>Read Only</p>\n</li>\n<li><p>Read Write</p>\n</li>\n<li><p>Zero Initial</p>\n</li>\n</ul>\n<h2 id=\"汇编延时-不受优化影响\"><a href=\"#汇编延时-不受优化影响\" class=\"headerlink\" title=\"汇编延时 不受优化影响\"></a>汇编延时 不受优化影响</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * @brief 汇编延时</span><br><span class=\"hljs-comment\"> * @attention us延时不是很准确</span><br><span class=\"hljs-comment\"> * @details 三个汇编指令理论应该是三个时钟周期</span><br><span class=\"hljs-comment\"> * 则 理论上</span><br><span class=\"hljs-comment\"> * ms AsmDelay( n*(SystemCoreClock/3000) )</span><br><span class=\"hljs-comment\"> * </span><br><span class=\"hljs-comment\"> * 实际有所差异 在STM32F105上</span><br><span class=\"hljs-comment\"> * ms AsmDelay( n*(SystemCoreClock/6000) )</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">if</span> defined (__CC_ARM)              <span class=\"hljs-comment\">// ARM Compiler</span></span><br>__attribute__((always_inline)) __ASM <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">AsmDelay</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint32_t</span> t)</span><br>&#123;<br>    subs    r0, #<span class=\"hljs-number\">1</span>;<br>    bne     AsmDelay;<br>    bx      lr;<br>&#125;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">elif</span> defined (__ICCARM__)         <span class=\"hljs-comment\">// IAR Compiler</span></span><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">AsmDelay</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint32_t</span> t)</span><br>&#123;<br>    __asm(<br>    <span class=\"hljs-string\">&quot;subs  r0, #1\\n&quot;</span><br>    <span class=\"hljs-string\">&quot;bne.n AsmDelay\\n&quot;</span><br>    <span class=\"hljs-string\">&quot;bx    lr&quot;</span><br>    );<br>&#125;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">elif</span> <span class=\"hljs-keyword\">define</span> (__GUNC__)            <span class=\"hljs-comment\">// GUN Compiler</span></span><br><span class=\"hljs-type\">void</span> __attribute__((naked)) AsmDelay(<span class=\"hljs-type\">uint32_t</span> t)<br>&#123;<br>    __asm(<br>    <span class=\"hljs-string\">&quot;subs  r0, #1\\n&quot;</span><br>    <span class=\"hljs-string\">&quot;bne   AsmDelay\\n&quot;</span><br>    <span class=\"hljs-string\">&quot;bx    lr&quot;</span><br>    );<br>&#125;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"大小端-endian\"><a href=\"#大小端-endian\" class=\"headerlink\" title=\"大小端 endian\"></a>大小端 endian</h2><ul>\n<li>大端模式Big-endian，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；<code>大端模式便于阅读</code></li>\n<li>小端模式Little-endian，………..</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>0x00123456</th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>大端</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>地址</td>\n<td>0x00000000</td>\n<td>0x00000001</td>\n<td>0x00000002</td>\n<td>0x00000003</td>\n</tr>\n<tr>\n<td>数值</td>\n<td>0x00</td>\n<td>0x12</td>\n<td>0x34</td>\n<td>0x56</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>小端</strong></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>地址</td>\n<td>0x00000000</td>\n<td>0x00000001</td>\n<td>0x00000002</td>\n<td>0x00000003</td>\n</tr>\n<tr>\n<td>数值</td>\n<td>0x56</td>\n<td>0x34</td>\n<td>0x12</td>\n<td>0x00</td>\n</tr>\n</tbody></table>\n<h1 id=\"C类\"><a href=\"#C类\" class=\"headerlink\" title=\"C类\"></a>C类</h1><h2 id=\"变量命名\"><a href=\"#变量命名\" class=\"headerlink\" title=\"变量命名\"></a>变量命名</h2><ol>\n<li>选择合适的变量长度(最短的标识符显示最多信息量的原则)</li>\n<li>短变量名i,j等一般作用域较小，有限范围内有效</li>\n</ol>\n<h3 id=\"循环变量的命名\"><a href=\"#循环变量的命名\" class=\"headerlink\" title=\"循环变量的命名\"></a>循环变量的命名</h3><p><strong>避免使用i、j、k等名字</strong></p>\n<p>如果循环体长度较长的话，那就很容易使人忘记它代表的是什么，因此最好给循环控制变量一个富有意义的名字。由于经常进行更改，扩展和拷贝等代码到另一个程序中，因此，大多数有经验的程序员都避免用i、j、k这类的名字。<br>通过精心对循环控制变量进行命名，可以避免它们的交叉：当你想用i时误用了j，或者想用j时却又误用了i。<br>如果不得不使用它们的话，那除了把它们用作循环控制变量之外，最好不再用作别的变量名。这一约定是众所周知的，如果不遵守它只会引起别人的困惑。</p>\n<h3 id=\"状态变量的命名\"><a href=\"#状态变量的命名\" class=\"headerlink\" title=\"状态变量的命名\"></a>状态变量的命名</h3><p>利用枚举类型和命名常量来设置状态量的值</p>\n<p>如果没有注释，将数值赋给状态量将是非常费解的。</p>\n<h3 id=\"逻辑变量命名\"><a href=\"#逻辑变量命名\" class=\"headerlink\" title=\"逻辑变量命名\"></a>逻辑变量命名</h3><p>使用肯定的逻辑变量名。</p>\n<p>否定式的变量名如NotFound、NotDone和Notsuccessful等在“非”运算中是很难读懂的，如：</p>\n  <figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">if not NotFound</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"参量的命名\"><a href=\"#参量的命名\" class=\"headerlink\" title=\"参量的命名\"></a>参量的命名</h3><p><strong>对常量来说，应该用它所代表的抽象实体而不是数值来命名。</strong><br>FIVE是一个很不恰当的常量名称（不管它代表的数值是否是5.0）；CYCLES_NEEDED则是个恰当的名称，CYCLES_NEEDED可以等于5.0也可以等于6.0，而Five &#x3D; 6.0则是个荒唐的语句。</p>\n<h2 id=\"运算符优先级\"><a href=\"#运算符优先级\" class=\"headerlink\" title=\"运算符优先级\"></a>运算符优先级</h2><p><img src=\"/2018/ef667962/00.jpeg\"></p>\n<ul>\n<li>坑</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">//编译报错</span><br>(DS18B20_DQ_IN != <span class=\"hljs-number\">0</span>) ? data_temp|=<span class=\"hljs-number\">0x80</span> : data_temp&amp;=<span class=\"hljs-number\">0x7f</span>;<br><span class=\"hljs-comment\">//规范写法</span><br>(DS18B20_DQ_IN!=<span class=\"hljs-number\">0</span>) ? (data_temp|=<span class=\"hljs-number\">0x80</span>):(data_temp&amp;=<span class=\"hljs-number\">0x7f</span>);<br></code></pre></td></tr></table></figure>\n<ul>\n<li>！！！极注意！！！  请小心有位运算时打上括号            &lt;&lt;  比  +-  要低 <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">u16 temp;<br>u8 h,l;<br>temp = (u16)(h&lt;&lt;<span class=\"hljs-number\">8</span>) + l;<span class=\"hljs-comment\">// 正确语法</span><br>temp = h&lt;&lt;<span class=\"hljs-number\">8</span> + l;<span class=\"hljs-comment\">// 错误语法！！！！！</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"printf\"><a href=\"#printf\" class=\"headerlink\" title=\"printf()\"></a>printf()</h2><table>\n<thead>\n<tr>\n<th align=\"left\">转换说明符</th>\n<th>输出</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">%a，%A</td>\n<td>浮点数、十六进制、p-计数法（c99）</td>\n</tr>\n<tr>\n<td align=\"left\">%c</td>\n<td>一个单一的字符</td>\n</tr>\n<tr>\n<td align=\"left\">%d</td>\n<td>有符号十进制整数</td>\n</tr>\n<tr>\n<td align=\"left\">%f</td>\n<td>浮点数、十六进制数法</td>\n</tr>\n<tr>\n<td align=\"left\">%e,%E</td>\n<td>e计数法，E计数法</td>\n</tr>\n<tr>\n<td align=\"left\">%g,%G</td>\n<td>g自动使用%e和%f，G自动使用%E和%f</td>\n</tr>\n<tr>\n<td align=\"left\">%i</td>\n<td>有符号十进制整数</td>\n</tr>\n<tr>\n<td align=\"left\">%o</td>\n<td>一个八进制数</td>\n</tr>\n<tr>\n<td align=\"left\">%p</td>\n<td>一个指针</td>\n</tr>\n<tr>\n<td align=\"left\">%s</td>\n<td>一个字符串</td>\n</tr>\n<tr>\n<td align=\"left\">%u</td>\n<td>无符号十进制整数</td>\n</tr>\n<tr>\n<td align=\"left\">%x，%X</td>\n<td>十六进制数字的无符号十六进制整数</td>\n</tr>\n<tr>\n<td align=\"left\">%%</td>\n<td>百分号</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>标志</th>\n<th>意义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-</td>\n<td>项目是左对齐的；打印在字符的最左侧开始处。</td>\n</tr>\n<tr>\n<td>+</td>\n<td>有符号的值显示正负号。</td>\n</tr>\n<tr>\n<td>(空格)</td>\n<td>带前导空格，复数会带减号符号，+会覆盖空格标志。</td>\n</tr>\n<tr>\n<td>#</td>\n<td>%o以0开始，%x以0x开始，浮点保证打印小数点，%g防止尾随零被删</td>\n</tr>\n<tr>\n<td>0</td>\n<td>前导零填充，会忽略-符号。</td>\n</tr>\n<tr>\n<td>修饰符</td>\n<td>意义</td>\n</tr>\n<tr>\n<td>———</td>\n<td>————————————————————</td>\n</tr>\n<tr>\n<td>digit(s)</td>\n<td>字段宽度的最小值。<br/>%4d</td>\n</tr>\n<tr>\n<td>.digit(s)</td>\n<td>精度。<br/>%5.2f</td>\n</tr>\n<tr>\n<td>h</td>\n<td>和整数说明符一起使用。表示short int或unsigned short int<br/>%hu、%hx、%6.4hd</td>\n</tr>\n<tr>\n<td>hh</td>\n<td>和整数说明符一起使用。表示signed char或unsigned char<br/>%hhu、%hhx、%6.4hhd</td>\n</tr>\n<tr>\n<td>j</td>\n<td>和整数说明符一起使用。表示intmax_t或uintmax_t<br/>%jd、%8jX</td>\n</tr>\n<tr>\n<td>l</td>\n<td>和整数说明符一起使用。long int或unsigned long int<br/>%ld、%lu</td>\n</tr>\n<tr>\n<td>ll</td>\n<td>和整数说明符一起使用。long long int或unsigned long long int（C99）<br/>%lld、%llu</td>\n</tr>\n<tr>\n<td>L</td>\n<td>和浮点数一起使用。表示long double<br/>%Lf、%Le</td>\n</tr>\n<tr>\n<td>t</td>\n<td>和整数说明符一起使用。ptrdiff_t（两个指针的差，相对向量）(C99)</td>\n</tr>\n<tr>\n<td>z</td>\n<td>和整数转换符一起使用。表示一个size_t值（sizeof的返回值）(C99)</td>\n</tr>\n</tbody></table>\n<h2 id=\"数值数据类型-u-ul-b\"><a href=\"#数值数据类型-u-ul-b\" class=\"headerlink\" title=\"数值数据类型 u ul b\"></a>数值数据类型 u ul b</h2><h3 id=\"用于说明数据类型\"><a href=\"#用于说明数据类型\" class=\"headerlink\" title=\"用于说明数据类型\"></a>用于说明数据类型</h3><p>u &#x3D;&#x3D; unsigned int</p>\n<p>l &#x3D;&#x3D;  long</p>\n<p>ul &#x3D;&#x3D; unsigned long</p>\n<p>数值后面加“L”和“l”（小写的l）的意义是该数值是long型。<br>详细说如下：<br>5L\t\t\t的数据类型为long int。<br>5.12L\t   的数据类型为long double。<br>数值后面加“U”和“u”的意义是该数值是unsigned型。</p>\n<h3 id=\"用于说明数值表示方法\"><a href=\"#用于说明数值表示方法\" class=\"headerlink\" title=\"用于说明数值表示方法\"></a>用于说明数值表示方法</h3><table>\n<thead>\n<tr>\n<th>进制↓   \\   表示方法→</th>\n<th>前面加</th>\n<th></th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>二进制</td>\n<td>0b</td>\n<td></td>\n<td>0b1010 &#x3D; 10</td>\n</tr>\n<tr>\n<td>八进制</td>\n<td>0</td>\n<td></td>\n<td>012 &#x3D; 10</td>\n</tr>\n<tr>\n<td>十进制</td>\n<td></td>\n<td>u l ul</td>\n<td>1u (规范性)</td>\n</tr>\n<tr>\n<td>十六进制</td>\n<td>0x</td>\n<td></td>\n<td>0x12 &#x3D; 18</td>\n</tr>\n</tbody></table>\n<ul>\n<li>注意：在宏定义中数字应加上尾缀，避免与八进制混淆</li>\n</ul>\n<h2 id=\"sprintf\"><a href=\"#sprintf\" class=\"headerlink\" title=\"sprintf()\"></a>sprintf()</h2><ul>\n<li><p>写入buff的数据会连带‘\\0’一起写入</p>\n</li>\n<li><p>在 C 里，对“字符串”的通常约定，是以 <code>&#39;\\0&#39;</code> 为结尾的字符串。从而在传递字符串参数的时候，只需要一个指向字符串首字符的指针。来自 C 的操作字符串的函数(<code>sprintf</code>, <code>strcpy</code>, <code>strcat</code>, 等等)通常都遵循这一约定，包括在写字符串的时候，会在末尾添加一个 <code>&#39;\\0&#39;</code> 。（除非在某些情况下有特殊约定）</p>\n<p>但是，<code>memcpy</code> 等不是操作字符串的函数，就不会添加最后的 <code>&#39;\\0&#39;</code> 。</p>\n</li>\n</ul>\n<h2 id=\"snprintf\"><a href=\"#snprintf\" class=\"headerlink\" title=\"snprintf()\"></a>snprintf()</h2><ul>\n<li>所传入的值以<strong>‘\\0’</strong>结尾    要得到   <strong>20</strong>  个数据需要传入参数  <strong>20+1</strong></li>\n<li>如果传入的str是<code>&quot;Hello&quot;</code> size参数是5则 无法写入<code>&#39;\\0&#39;</code> ,size参数是6 则可以写入 <code>&#39;\\0&#39;</code></li>\n</ul>\n<h2 id=\"sscanf\"><a href=\"#sscanf\" class=\"headerlink\" title=\"sscanf()\"></a>sscanf()</h2><h3 id=\"原型-1\"><a href=\"#原型-1\" class=\"headerlink\" title=\"原型\"></a>原型</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">sscanf</span><span class=\"hljs-params\">( <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *buffer, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *format, [ argument ] ...   )</span>; <br><br></code></pre></td></tr></table></figure>\n\n<p>buffer \t\t\t  存储的数据<br>format \t\t\t窗体控件字符串。 有关详细信息，请参阅”格式规范”。<br>argument\t    可选自变量<br>locale\t\t\t   要使用的区域设置</p>\n<h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p>sscanf与scanf类似，都是用于输入的，只是后者以键盘(stdin)为输入源，前者以<strong>固定字符串</strong>为输入源。</p>\n<h4 id=\"控制字符说明\"><a href=\"#控制字符说明\" class=\"headerlink\" title=\"控制字符说明\"></a>控制字符说明</h4><blockquote>\n<p>%c  一个单一的字符<br>%d  一个十进制整数<br>%i  一个整数<br>%e, %f, %g 一个浮点数<br>%o  一个八进制数<br>%s  一个字符串<br>%x  一个十六进制数<br>%p  一个指针<br>%n  一个等于读取字符数量的整数<br>%u  一个无符号整数<br>%[]  一个字符集<br>%%  一个精度符</p>\n</blockquote>\n<h3 id=\"函数返回值\"><a href=\"#函数返回值\" class=\"headerlink\" title=\"函数返回值\"></a>函数返回值</h3><p>函数将返回成功赋值的字段个数；返回值不包括已读取但未赋值的字段个数。 返回值为 0 表示没有将任何字段赋值。 如果在第一次读取之前到达字符串结尾，则返回EOF。</p>\n<h3 id=\"例程\"><a href=\"#例程\" class=\"headerlink\" title=\"例程\"></a>例程</h3><h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">char</span> buf[<span class=\"hljs-number\">512</span>];<br><span class=\"hljs-built_in\">sscanf</span>(<span class=\"hljs-string\">&quot;123456 &quot;</span>, <span class=\"hljs-string\">&quot;%s&quot;</span>, buf);<br><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s\\n&quot;</span>, buf);<br><span class=\"hljs-comment\">//结果为：123456</span><br><br><br><span class=\"hljs-comment\">//取指定长度的字符串。如在下例中，取最大长度为4字节的字符串。</span><br><span class=\"hljs-built_in\">sscanf</span>(<span class=\"hljs-string\">&quot;123456 &quot;</span>, <span class=\"hljs-string\">&quot;%4s&quot;</span>, buf);<br><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s\\n&quot;</span>, buf);<br><span class=\"hljs-comment\">//结果为：1234</span><br><br><span class=\"hljs-comment\">//取到指定字符为止的字符串。如在下例中，取遇到空格为止字符串。</span><br><span class=\"hljs-built_in\">sscanf</span>(<span class=\"hljs-string\">&quot;123456 abcdedf&quot;</span>, <span class=\"hljs-string\">&quot;%[^ ]&quot;</span>, buf);<br><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s\\n&quot;</span>, buf);<br><span class=\"hljs-comment\">//结果为：123456</span><br><br><span class=\"hljs-comment\">//取仅包含指定字符集的字符串。如在下例中，取仅包含1到9和小写字母的字符串。</span><br><span class=\"hljs-built_in\">sscanf</span>(<span class=\"hljs-string\">&quot;123456abcdedfBCDEF&quot;</span>, <span class=\"hljs-string\">&quot;%[1-9a-z]&quot;</span>, buf);<br><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s\\n&quot;</span>, buf);<br><span class=\"hljs-comment\">//结果为：123456abcdedf</span><br><br><span class=\"hljs-comment\">//取到指定字符集为止的字符串。如在下例中，取遇到大写字母为止的字符串。</span><br><span class=\"hljs-built_in\">sscanf</span>(<span class=\"hljs-string\">&quot;123456abcdedfBCDEF&quot;</span>, <span class=\"hljs-string\">&quot;%[^A-Z]&quot;</span>, buf);<br><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s\\n&quot;</span>, buf);<br><span class=\"hljs-comment\">//结果为：123456abcdedf</span><br><br><span class=\"hljs-comment\">//给定一个字符串iios/12DDWDFF@122，获取 / 和 @ 之间的字符串，先将 &quot;iios/&quot;过滤掉，再将非&#x27;@&#x27;的一串内容送到buf中</span><br><span class=\"hljs-built_in\">sscanf</span>(<span class=\"hljs-string\">&quot;iios/12DDWDFF@122&quot;</span>, <span class=\"hljs-string\">&quot;%*[^/]/%[^@]&quot;</span>, buf);<br><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s\\n&quot;</span>, buf);<br><span class=\"hljs-comment\">//结果为：12DDWDFF</span><br><br><span class=\"hljs-comment\">//给定一个字符串&quot;hello, world&quot;，仅保留&quot;world&quot;。（注意：“，”之后有一空格）</span><br><span class=\"hljs-built_in\">sscanf</span>(<span class=\"hljs-string\">&quot;hello, world&quot;</span>, <span class=\"hljs-string\">&quot;%*s%s&quot;</span>, buf);<br><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s\\n&quot;</span>, buf);<br><span class=\"hljs-comment\">//结果为：world</span><br><br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h4><p><img src=\"/2018/ef667962/20161218131342960.png\"></p>\n<h2 id=\"Union\"><a href=\"#Union\" class=\"headerlink\" title=\"Union\"></a>Union</h2><h3 id=\"数据拆分、移位\"><a href=\"#数据拆分、移位\" class=\"headerlink\" title=\"数据拆分、移位\"></a>数据拆分、移位</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-keyword\">union</span><br>&#123;<br>\tu16 Val_u16;<br>\tu8 Val_u8[<span class=\"hljs-number\">2</span>];<br>&#125;_HL_UNION;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Struct\"><a href=\"#Struct\" class=\"headerlink\" title=\"Struct\"></a>Struct</h2><ul>\n<li>注意节约内存，小数据全部写在前面方便对齐。</li>\n<li>结构体内的结构体因为已经是对其了的，所以，可以建议放在最前、最后。</li>\n</ul>\n<h2 id=\"register\"><a href=\"#register\" class=\"headerlink\" title=\"register\"></a>register</h2><p>　　这个关键字<strong>请求</strong>（只是请求，最终看编译器）编译器尽可能的将变量存在CPU内部寄存器中，而不是通过内存寻址访问，以提高效率。注意是尽可能，不是绝对。你想想，一个CPU 的寄存器也就那么几个或几十个，你要是定义了很多很多register 变量，它累死也可能不能全部把这些变量放入寄存器吧。</p>\n<h2 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h2><ol>\n<li>并行设备的硬件寄存器（如：状态寄存器）<ul>\n<li>延伸 const  volatile</li>\n</ul>\n</li>\n<li>一个中断服务子程序中会访问到的<strong>非自动变量</strong>(Non-automatic variables)<ul>\n<li><strong>自动变量</strong>：是在函数内部定义和使用的变量，它是<strong>局部变量</strong>。</li>\n<li><strong>非自动变量</strong>：有两种，一种是<strong>全局变量</strong>，一种是<strong>静态变量</strong>。</li>\n</ul>\n</li>\n<li>多线程应用中被几个任务共享的变量</li>\n</ol>\n<h2 id=\"static\"><a href=\"#static\" class=\"headerlink\" title=\"static\"></a>static</h2><h2 id=\"const\"><a href=\"#const\" class=\"headerlink\" title=\"const\"></a>const</h2><h3 id=\"关于Const指针\"><a href=\"#关于Const指针\" class=\"headerlink\" title=\"关于Const指针\"></a>关于Const指针</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> *p1;\t\t<span class=\"hljs-comment\">//指向常量的指针 (const int) *p1，指向的值不能修改，指针本身可以修改</span><br><br><span class=\"hljs-type\">int</span> *<span class=\"hljs-type\">const</span> p2;    \t<span class=\"hljs-comment\">//指针是常量 int *(const p2) 不能指向别的变量，但是指向的变量可以修改\t\t因为不能被修改所以必须要被初始化。</span><br>   <br><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> *<span class=\"hljs-type\">const</span> p3;<span class=\"hljs-comment\">//不能指向别的变量，也不能修改指向变量的值</span><br><br><span class=\"hljs-comment\">//注意   这个等同于第一个   容易产生误解尽量不要使用这个表达</span><br><span class=\"hljs-type\">int</span> <span class=\"hljs-type\">const</span> *p;\t\t<span class=\"hljs-comment\">//指向常量的指针</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"Const常量可以被修改\"><a href=\"#Const常量可以被修改\" class=\"headerlink\" title=\"Const常量可以被修改\"></a>Const常量可以被修改</h3><p>对于一个Cont常量，实际上你访问的是它的<strong>内存拷贝</strong>，你仍然可以去用指针去修改它。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span><br>&#123;<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> const_val=<span class=\"hljs-number\">66</span>;<br>\t<span class=\"hljs-type\">int</span> *p = &amp;const_val;<br>    <br>\t*p = <span class=\"hljs-number\">33</span>;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;const_val=%d \\r\\n&quot;</span>, const_val );\t\t<span class=\"hljs-comment\">//const_val=33</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"const-局部变量\"><a href=\"#const-局部变量\" class=\"headerlink\" title=\"const 局部变量\"></a>const 局部变量</h3><p>const 局部变量居然定义在stack上，用指针居然可以修改其值</p>\n<h2 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h2><h3 id=\"const-指针\"><a href=\"#const-指针\" class=\"headerlink\" title=\"const 指针\"></a>const 指针</h3><p><a href=\"###%E5%85%B3%E4%BA%8EConst%E6%8C%87%E9%92%88\">关于Const指针</a></p>\n<h3 id=\"有x个指针的数组\"><a href=\"#有x个指针的数组\" class=\"headerlink\" title=\"有x个指针的数组\"></a>有x个指针的数组</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">char</span> *p2[<span class=\"hljs-number\">3</span>]<span class=\"hljs-comment\">//这是有三个指针的数组</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"指向x个元素数组的指针\"><a href=\"#指向x个元素数组的指针\" class=\"headerlink\" title=\"指向x个元素数组的指针\"></a>指向x个元素数组的指针</h3><ul>\n<li>指针执行<code>p1 = p1 + 1;</code>操作，p1中的值会增加12个字节</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">char</span> (*p1)[<span class=\"hljs-number\">3</span>]<span class=\"hljs-comment\">//指向x个元素数组的指针</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"二维、多维数组的指针\"><a href=\"#二维、多维数组的指针\" class=\"headerlink\" title=\"二维、多维数组的指针\"></a>二维、多维数组的指针</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> a[<span class=\"hljs-number\">3</span>][<span class=\"hljs-number\">2</span>] =&#123;&#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>&#125;,&#123;<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>&#125;,&#123;<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">6</span>&#125;&#125;<br><span class=\"hljs-type\">int</span> (*pa)[<span class=\"hljs-number\">2</span>] = a<br><span class=\"hljs-comment\">//a是指向指针的指针</span><br><span class=\"hljs-comment\">//a是一个指针，他指向的是下一维度的数组的头（指针、地址，它指向二维数组的第一个值），</span><br>*(*(a+<span class=\"hljs-number\">0</span>)+<span class=\"hljs-number\">0</span>) == <span class=\"hljs-number\">1</span><br>*(*(a+<span class=\"hljs-number\">0</span>)+<span class=\"hljs-number\">1</span>) == <span class=\"hljs-number\">2</span><br>*(*(a+<span class=\"hljs-number\">1</span>)+<span class=\"hljs-number\">0</span>) == <span class=\"hljs-number\">3</span><br></code></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"指针参数的内存传递\"><a href=\"#指针参数的内存传递\" class=\"headerlink\" title=\"指针参数的内存传递\"></a>指针参数的内存传递</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> a=<span class=\"hljs-number\">10</span>, b=<span class=\"hljs-number\">20</span>;<br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">fun_p</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> *p)</span><br>&#123;<br>    p = &amp;b;<br>&#125;<br><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">fun_p_p</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> *p)</span><br>&#123;<br>    *p = &amp;b;<br>&#125;<br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>    <span class=\"hljs-type\">int</span> *p_a = &amp;a;<br><br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;&amp;a=%X-&amp;b=%X\\r\\n&quot;</span>, &amp;a, &amp;b);<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;p_a=%X\\r\\n&quot;</span>, p_a);<br><br>    fun_p(p_a);<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;p_a=%X\\r\\n&quot;</span>, p_a);<br><br>    fun_p_p(&amp;p_a);<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;p_a=%X\\r\\n&quot;</span>, p_a);<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>编译器总是要为函数的每个参数制作临时副本，<code>void fun_p(int *p)</code>函数的指针参数是<code>p</code>，编译器为其分配的副本是<code>_p</code>，编译器使<code>_p=p</code>就是两者不是同一个变量但是指向相同的地址，函数里面修改了<code>_P</code>的指向，但是并没有修改<code>p</code>的指向，所以导致函数<code>void fun_p(int *p)</code>并没有得到期待的运行结果。</p>\n<p>而<code>void fun_p_p(int *p)</code>函数是用指向<code>p_a</code>的指针修改了<code>p_a</code>的值。</p>\n<p><span style=\"color:red\">修改某个变量，要用指向这个变量的指针！而修改指针要用（指向指针的指针）才行！</span></p>\n<h3 id=\"野指针\"><a href=\"#野指针\" class=\"headerlink\" title=\"野指针\"></a>野指针</h3><p>申请内存后的指针，被<code>free() </code>或<code> delete()</code>之后内存被释放，但是指针还是指向的那块内存，这个指针就叫野指针。</p>\n<h2 id=\"跳的转到指定地址执行程序\"><a href=\"#跳的转到指定地址执行程序\" class=\"headerlink\" title=\"跳的转到指定地址执行程序\"></a>跳的转到指定地址执行程序</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">第一种办法：<span class=\"hljs-keyword\">goto</span><br>第二种办法：<br><span class=\"hljs-comment\">//解释</span><br><span class=\"hljs-type\">void</span> (*)(<span class=\"hljs-type\">void</span>)\t\t\t\t<span class=\"hljs-comment\">//函数指针类型</span><br>(<span class=\"hljs-type\">void</span> (*)(<span class=\"hljs-type\">void</span>)) <span class=\"hljs-number\">100</span>\t\t<span class=\"hljs-comment\">//将 100 强制转换为 函数指针类型</span><br><br><span class=\"hljs-comment\">//函数定义</span><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">func</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>\t<span class=\"hljs-comment\">//code</span><br>&#125;<br><br><span class=\"hljs-comment\">//函数调用</span><br>func();<br><br><span class=\"hljs-comment\">//使用函数指针来执行</span><br><span class=\"hljs-type\">void</span> (*pF)(<span class=\"hljs-type\">void</span>) = func;\t<span class=\"hljs-comment\">//使用函数指针指向func函数</span><br>pF();\t\t\t\t\t\t<span class=\"hljs-comment\">//利用函数指针调用函数</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"内联函数-inline\"><a href=\"#内联函数-inline\" class=\"headerlink\" title=\"内联函数 inline\"></a>内联函数 inline</h2><p>详见Keil-&gt; Arm Compiler 6 User’s Guides-&gt; Inlining functions</p>\n<table>\n<thead>\n<tr>\n<th>Inlining options, keywords, or attributes</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>__inline__</code></td>\n<td>Specify  this keyword on a function definition or declaration as a hint to the compiler  to favor inlining of the function. However, for each function call, the compiler  still decides whether to inline the function. This is equivalent to  <code>__inline</code>.</td>\n</tr>\n<tr>\n<td><code>__attribute__((always_inline))</code></td>\n<td>Specify  this function attribute on a function definition or declaration to tell the  compiler to always inline this function, with certain exceptions such as for  recursive functions. This overrides the <code>-fno-inline-functions</code>  option.</td>\n</tr>\n<tr>\n<td><code>__attribute__((noinline))</code></td>\n<td>Specify  this function attribute on a function definition or declaration to tell the  compiler to not inline the function. This is equivalent to  <code>__declspec(noinline)</code>.</td>\n</tr>\n<tr>\n<td><code>-fno-inline-functions</code></td>\n<td>This  is a compiler command-line option. Specify this option to the compiler to  disable inlining. This option overrides the <code>__inline__</code>  hint.</td>\n</tr>\n</tbody></table>\n<p><strong>Note:</strong></p>\n<ul>\n<li>Arm Compiler only  inlines functions within the same compilation unit, unless you use Link Time  Optimization. For more information, see <a href=\"armclang_intro_chr1413367986635.htm\"><em>Optimizing across modules with link time  optimization</em></a> in the Software Development  Guide. </li>\n<li>C++ and C99 provide the <code>inline</code> language keyword. The effect of  this <code>inline</code> language keyword is identical to the effect of using  the <code>__inline__</code> compiler keyword. However, the effect in C99 mode is  different from the effect in C++ or other C that does not adhere to the C99  standard. For more information, see <a href=\"https://developer.arm.com/docs/101754/0614/armclang-reference/other-compiler-specific-features/inline-functions\"><em>Inline functions</em></a> in  the Arm Compiler Reference Guide. </li>\n<li>Function inlining normally happens at higher optimization levels, such as  <code>-O2</code>, except when you specify  <code>__attribute__((always_inline))</code>.</li>\n</ul>\n<h2 id=\"do-while-continue\"><a href=\"#do-while-continue\" class=\"headerlink\" title=\"do while continue\"></a>do while continue</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-keyword\">do</span> &#123;<br>    <span class=\"hljs-comment\">// ...</span><br>    <span class=\"hljs-keyword\">continue</span>; <span class=\"hljs-comment\">// 相当于一个go to 去到了contin</span><br>    <span class=\"hljs-comment\">// ...</span><br>contin:;<br>&#125; <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-comment\">/* ... */</span>);<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"预编译ifdef\"><a href=\"#预编译ifdef\" class=\"headerlink\" title=\"预编译ifdef\"></a>预编译ifdef</h2><ul>\n<li><p>第一种</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> WIN7</span><br>     xxx<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">elif</span> defined WIN8 </span><br>\txxx<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span> </span><br>\txxxx<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p>第二种</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">if</span> defined(WIN7)</span><br>\txxx<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">elif</span> defined(WIN8) </span><br>\txxx<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span> </span><br>\txxxx<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br><br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"宏相关\"><a href=\"#宏相关\" class=\"headerlink\" title=\"宏相关\"></a>宏相关</h2><ul>\n<li><p>一般来说在宏中不要使用增量(++i)或减量(–i)运算符。假设宏里面有多个替换，结果是不可预知的。</p>\n</li>\n<li><p>在宏后面对宏的注释应该要用块注释，而不应使用行注释。因为有些编译器会将行注释理解成宏的一部分(这么智障的编译器嘛？？)。</p>\n</li>\n<li><p>define定义一个宏函数记得写 do{}while(0)</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> device_init_wakeup(dev,val) \\ </span><br> device_can_wakeup(dev) = !!(val);   \\ <br> device_set_wakeup_enable(dev,val);<br> <br> <span class=\"hljs-keyword\">if</span> (n &gt; <span class=\"hljs-number\">0</span>) device_init_wakeup(d, v);<br></code></pre></td></tr></table></figure>\n\n<p>   为什么不简单写{}</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> device_init_wakeup(dev,val) \\ </span><br>&#123; device_can_wakeup(dev) = !!(val); \\ <br>device_set_wakeup_enable(dev,val); &#125;<br><br><span class=\"hljs-keyword\">if</span> (n &gt; <span class=\"hljs-number\">0</span>) <br>    device_init_wakeup(d, v);<br><span class=\"hljs-keyword\">else</span><br>    <span class=\"hljs-keyword\">continue</span>;<br></code></pre></td></tr></table></figure>\n\n</li>\n<li><p>__FILE__和__LINE__，FILE展开为当前源文件的文件名，是一个字符串，LINE展开为当前代码行的行号，是一个整数。</p>\n</li>\n<li><p>类似上面的 C99有__func__ 可以打印出当前函数名，但是注意这是一个变量而不是宏。</p>\n</li>\n<li><p>gcc 定义宏</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">gcc -c -DMACHINE=<span class=\"hljs-number\">8086</span> main.c<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>在宏中用#将宏参量（可以是变量、函数名）转换成<strong>字符串</strong>。——创建字符串</p>\n</li>\n<li><p>在宏中用##将两者进行粘合变成<strong>一个标识符</strong>(变量等…)。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> X_NAME(n) \tx##n</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> X_CHAR(x)\t#x</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> PSQR(x)\t\tprintf( <span class=\"hljs-string\">&quot;The square of &quot;</span> #x <span class=\"hljs-string\">&quot; is %d\\n&quot;</span>,((x)*(x)) )</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> PSQRx(x)\tprintf( <span class=\"hljs-string\">&quot;The square of %s is %d\\n&quot;</span>, #x, ((x)*(x)) )</span><br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">X_NAME</span><span class=\"hljs-params\">(<span class=\"hljs-number\">1</span>)</span> = <span class=\"hljs-number\">5</span>;\t\t<span class=\"hljs-comment\">//等价于   x1 = 5;</span><br>PSQR( x1 );<br>PSQRx( x1 );<br><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s-%s-%d\\r\\n&quot;</span>, X_CHAR( X_NAME(<span class=\"hljs-number\">1</span>) ), X_CHAR( x1 ), X_NAME(<span class=\"hljs-number\">1</span>) );<br><br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">输出：</span><br><span class=\"hljs-comment\">The square of x1 is 25</span><br><span class=\"hljs-comment\">The square of x1 is 25</span><br><span class=\"hljs-comment\">X_NAME( 1 )-x1-5</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p>可变参数</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> DEBUGP(format, ...) printk(format, ## __VA_ARGS__)</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"宏展开的顺序\"><a href=\"#宏展开的顺序\" class=\"headerlink\" title=\"宏展开的顺序\"></a>宏展开的顺序</h3><ul>\n<li><p>带#和带##的运算符不需要进行参数的展开！！除了带#和##运算符的参数之外，其它参数在替换之前要对实参本身做充分的展开，所以应该先把sub_z展开成26再替换到alt[x]中x的位置。</p>\n  <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> sh(x) printf(<span class=\"hljs-string\">&quot;n&quot;</span> #x <span class=\"hljs-string\">&quot;=%d, or %d\\n&quot;</span>,n##x,alt[x])</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> sub_z 26</span><br><br>sh(sub_z)<br><span class=\"hljs-comment\">//展开成了printf(&quot;n&quot; &quot;sub_z&quot; &quot;=%d, or %d\\n&quot;,nsub_z,alt[26])</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"强制转换\"><a href=\"#强制转换\" class=\"headerlink\" title=\"强制转换\"></a>强制转换</h2><h3 id=\"signed-int转换到unsigned-int\"><a href=\"#signed-int转换到unsigned-int\" class=\"headerlink\" title=\"signed int转换到unsigned int\"></a>signed int转换到unsigned int</h3><p>带符号整型转换到无符号整型,最高位(high-order bit)会丧失其作为符号位的功能。如果该带符号整数的值非负,那么转换后值不变;如果该带符号整数的值为负,那么转换后的结果通常是一个非常大的正数。</p>\n<h2 id=\"uint32-t-无符号相减-定时器溢出问题\"><a href=\"#uint32-t-无符号相减-定时器溢出问题\" class=\"headerlink\" title=\"uint32_t 无符号相减 定时器溢出问题\"></a>uint32_t 无符号相减 定时器溢出问题</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">timer_loop</span><span class=\"hljs-params\">()</span><br>&#123;<br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Timer</span>* <span class=\"hljs-title\">target</span>;</span><br>\t<span class=\"hljs-keyword\">for</span>(target=head_handle; target; target=target-&gt;next) &#123;<br>\t\t<span class=\"hljs-keyword\">if</span>(_timer_ticks &gt;= target-&gt;timeout) &#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span>(target-&gt;repeat == <span class=\"hljs-number\">0</span>) &#123;<br>\t\t\t\ttimer_stop(target);<br>\t\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\t\ttarget-&gt;timeout = _timer_ticks + target-&gt;repeat;<br>\t\t\t&#125;<br>\t\t\ttarget-&gt;timeout_cb();<br>\t\t&#125;<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这个uint32_t的_timer_ticks，每毫秒自加1，设备运行到49天的时候会涉及到溢出的问题。所以在timer_loop里面的判断超时的语句需要小修改下。</p>\n<p><code>if(_timer_ticks &gt;= target-&gt;timeout)</code></p>\n<p> 修改为 </p>\n<p><code>if((int)((uint32_t)(target-&gt;timeout -_timer_ticks)) &lt;= 0)</code> </p>\n<p>完美解决uint32_t变量溢出时，超时判断有误的bug</p>\n<p>HAL库的无符号相减，tick是++</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-keyword\">while</span>((now_tick - tick_start) &lt; wait )<br>&#123;&#125;<br><br><span class=\"hljs-comment\">//</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>RT-thread 内的判断</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">// 最大定时长度是 RT_TICK_MAX / 2</span><br><span class=\"hljs-keyword\">if</span> ((current_tick - t-&gt;timeout_tick) &lt; RT_TICK_MAX / <span class=\"hljs-number\">2</span>)<br></code></pre></td></tr></table></figure>\n\n\n\n\n\n<p><strong>这里其实涉及的是无符号数相减，减出负数</strong></p>\n<p>负数在计算机内是用其补码来存储的。</p>\n<p>减法会被换算成两个数的加法，a-b会被换算成a加上b的补码，即a+(~b+1)。</p>\n<p>252-250&#x3D;(b1111 1100)+(b0000 0110)&#x3D;(b0000 0010)&#x3D;2</p>\n<p>1-250&#x3D;(b0000 0001)+(b0000 0110)&#x3D;(b0000 0111)&#x3D;7</p>\n<p><em><strong>所以计算两值的差值就可以直接相减</strong></em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">uint8_t</span> now = <span class=\"hljs-number\">2</span>;<br><span class=\"hljs-type\">uint8_t</span> pre = <span class=\"hljs-number\">250</span>;<br><span class=\"hljs-type\">uint8_t</span> differ=<span class=\"hljs-number\">0</span>;<br><br>differ = (<span class=\"hljs-type\">uint8_t</span>)(now - pre);<br><span class=\"hljs-comment\">// differ = 0x08</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"c编译原理\"><a href=\"#c编译原理\" class=\"headerlink\" title=\"c编译原理\"></a>c编译原理</h2><p><img src=\"/2018/ef667962/2018051223284857.png\" alt=\"2018051223284857\"></p>\n<p><img src=\"/2018/ef667962/20180513215202780.png\" alt=\"20180513215202780\"></p>\n<h3 id=\"预编译\"><a href=\"#预编译\" class=\"headerlink\" title=\"预编译\"></a>预编译</h3><ul>\n<li>define展开</li>\n<li>FILE LINE等展开</li>\n<li>include包含</li>\n<li>转化 .i 文件</li>\n</ul>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\">gcc -E<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h3><ul>\n<li>优化在这进行，包括数值计算一类</li>\n<li>编译成汇编文件</li>\n<li>转化 .s .asm文件</li>\n</ul>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\">gcc -S<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"汇编\"><a href=\"#汇编\" class=\"headerlink\" title=\"汇编\"></a>汇编</h3><ul>\n<li>汇编语言代码翻译成目标机器指令的过程</li>\n<li>data段code段在这里产生</li>\n<li>转化 .o .obj文件</li>\n</ul>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\">gcc -c<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h3><ul>\n<li>链接成 .exe .out .axf等</li>\n<li>动态链接、静态链接(动态库.so、静态库.a)</li>\n</ul>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\">gcc<br></code></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"内存分配相关\"><a href=\"#内存分配相关\" class=\"headerlink\" title=\"内存分配相关\"></a>内存分配相关</h2><p><img src=\"/2018/ef667962/806053-20170722131756261-1095755633.png\" alt=\"806053-20170722131756261-1095755633\"></p>\n<h3 id=\"code-代码区\"><a href=\"#code-代码区\" class=\"headerlink\" title=\".code 代码区\"></a>.code 代码区</h3><p>代码段（code segment&#x2F;text segment ）通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。</p>\n<h3 id=\"data-已初始化区\"><a href=\"#data-已初始化区\" class=\"headerlink\" title=\".data 已初始化区\"></a>.data 已初始化区</h3><h3 id=\"bss-未初始化区\"><a href=\"#bss-未初始化区\" class=\"headerlink\" title=\".bss 未初始化区\"></a>.bss 未初始化区</h3><h3 id=\"stack-栈区\"><a href=\"#stack-栈区\" class=\"headerlink\" title=\"stack 栈区\"></a>stack 栈区</h3><p><img src=\"/2018/ef667962/686215-20151218231826459-500964006.png\" alt=\"686215-20151218231826459-500964006\"></p>\n<ul>\n<li><strong>在C语言中，函数参数的入栈顺序是从右到左</strong></li>\n</ul>\n<h3 id=\"heap-堆区\"><a href=\"#heap-堆区\" class=\"headerlink\" title=\"heap 堆区\"></a>heap 堆区</h3><h2 id=\"new-delete-malloc-free\"><a href=\"#new-delete-malloc-free\" class=\"headerlink\" title=\"new delete malloc free\"></a>new delete malloc free</h2><h3 id=\"new-x2F-delete\"><a href=\"#new-x2F-delete\" class=\"headerlink\" title=\"new &#x2F; delete\"></a>new &#x2F; delete</h3><ul>\n<li>Allocate &#x2F; release memory 分配&#x2F;释放<ol>\n<li>Memory allocated from ‘Free Store’.   这个FreeStore和Heap不一定一样 似乎取决于它的具体实现方式</li>\n<li>Returns a fully typed pointer.</li>\n<li><code>new</code> (standard version) never returns a <code>NULL</code> (will throw on failure).</li>\n<li>Are called with Type-ID (compiler calculates the size). 使用 Type-ID 调用（编译器计算大小）。</li>\n<li>Has a version explicitly to handle arrays. 有一个明确的版本来处理数组。</li>\n<li>Reallocating (to get more space) not handled intuitively (because of copy constructor). 重新分配（以获得更多空间）没有直观地处理（因为复制构造函数）。</li>\n<li>Whether they call <code>malloc</code> &#x2F; <code>free</code> is implementation defined. 他们是否调用<code>malloc</code>&#x2F;<code>free</code>是由实现来定义的。</li>\n<li>Can add a new memory allocator to deal with low memory (<code>std::set_new_handler</code>).</li>\n<li><code>operator new</code> &#x2F; <code>operator delete</code> can be overridden legally.</li>\n<li><strong>Constructor &#x2F; destructor used to initialize &#x2F; destroy the object.  构造函数&#x2F;析构函数用于初始化&#x2F;销毁对象。</strong></li>\n</ol>\n</li>\n</ul>\n<h3 id=\"malloc-x2F-free\"><a href=\"#malloc-x2F-free\" class=\"headerlink\" title=\"malloc &#x2F; free\"></a>malloc &#x2F; free</h3><ul>\n<li>Allocate &#x2F; release memory<ol>\n<li>Memory allocated from ‘Heap’.</li>\n<li>Returns a <code>void*</code>.</li>\n<li>Returns <code>NULL</code> on failure.</li>\n<li>Must specify the size required in bytes. 必须以字节为单位指定所需的大小。</li>\n<li>Allocating array requires manual calculation of space. 分配数组需要手动计算空间。</li>\n<li>Reallocating larger chunk of memory simple (no copy constructor to worry about). 重新分配更大的内存块很简单（无需担心复制构造函数）。</li>\n<li>They will <strong>NOT</strong> call <code>new</code> &#x2F; <code>delete</code>.</li>\n<li>No way to splice user code into the allocation sequence to help with low memory. 无法将用户代码拼接到分配序列中以帮助解决内存不足的问题。</li>\n<li><code>malloc</code> &#x2F; <code>free</code> can <strong>NOT</strong> be overridden legally.</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"Table-comparison-of-the-features\"><a href=\"#Table-comparison-of-the-features\" class=\"headerlink\" title=\"Table comparison of the features:\"></a>Table comparison of the features:</h3><table>\n<thead>\n<tr>\n<th align=\"left\">Feature</th>\n<th align=\"left\"><code>new</code> &#x2F; <code>delete</code></th>\n<th align=\"left\"><code>malloc</code> &#x2F; <code>free</code></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Memory allocated from</td>\n<td align=\"left\">‘Free Store’</td>\n<td align=\"left\">‘Heap’</td>\n</tr>\n<tr>\n<td align=\"left\">Returns</td>\n<td align=\"left\">Fully typed pointer</td>\n<td align=\"left\"><code>void*</code></td>\n</tr>\n<tr>\n<td align=\"left\">On failure</td>\n<td align=\"left\">Throws (never returns <code>NULL</code>)</td>\n<td align=\"left\">Returns <code>NULL</code></td>\n</tr>\n<tr>\n<td align=\"left\">Required size</td>\n<td align=\"left\">Calculated by compiler</td>\n<td align=\"left\">Must be specified in bytes<br/>必须以字节为单位指定</td>\n</tr>\n<tr>\n<td align=\"left\">Handling arrays<br>处理数组</td>\n<td align=\"left\">Has an explicit version</td>\n<td align=\"left\">Requires manual calculations</td>\n</tr>\n<tr>\n<td align=\"left\">Reallocating<br>重新分配</td>\n<td align=\"left\">Not handled intuitively</td>\n<td align=\"left\">Simple (no copy constructor)</td>\n</tr>\n<tr>\n<td align=\"left\">Call of reverse</td>\n<td align=\"left\">Implementation defined</td>\n<td align=\"left\">No</td>\n</tr>\n<tr>\n<td align=\"left\">Low memory cases</td>\n<td align=\"left\">Can add a new memory allocator<br>可以添加新的内存分配器</td>\n<td align=\"left\">Not handled by user code<br>不由用户代码处理</td>\n</tr>\n<tr>\n<td align=\"left\">Overridable</td>\n<td align=\"left\">Yes</td>\n<td align=\"left\">No</td>\n</tr>\n<tr>\n<td align=\"left\">Use of constructor &#x2F; destructor<br>构造函数&#x2F;析构函数的使用</td>\n<td align=\"left\">Yes</td>\n<td align=\"left\">No</td>\n</tr>\n<tr>\n<td align=\"left\">Type</td>\n<td align=\"left\">运算符</td>\n<td align=\"left\">函数</td>\n</tr>\n</tbody></table>\n<p>Technically, memory allocated by <code>new</code> comes from the ‘Free Store’ while memory allocated by <code>malloc</code> comes from the ‘Heap’. Whether these two areas are the same is an implementation detail, which is another reason that <code>malloc</code> and <code>new</code> cannot be mixed. 从技术上讲，分配的内存<code>new</code>来自“免费存储”，而分配的内存<code>malloc</code>来自“堆”。这两个区域是否相同是一个实现细节，这是另一个<code>malloc</code>不能<code>new</code>混为一谈的原因。</p>\n<ul>\n<li><p>最相关的区别是<code>new</code>运算符分配内存然后调用<strong>构造函数</strong>，<code>delete</code>调用<strong>析构函数</strong>然后释放内存。</p>\n<ul>\n<li>严格来说，new 操作符只是分配内存。是 new 表达式调用 new 运算符，然后在分配的内存中运行构造函数。</li>\n</ul>\n</li>\n<li><p><code>new</code>调用对象的ctor，<code>delete</code>调用dtor。</p>\n<p><code>malloc</code>&amp;<code>free</code>只是分配和释放原始内存。</p>\n</li>\n</ul>\n<h1 id=\"STM32相关\"><a href=\"#STM32相关\" class=\"headerlink\" title=\"STM32相关\"></a>STM32相关</h1><h2 id=\"ADC-与-通道映射关系\"><a href=\"#ADC-与-通道映射关系\" class=\"headerlink\" title=\"ADC 与 通道映射关系\"></a>ADC 与 通道映射关系</h2><p><img src=\"/2018/ef667962/ADC%E9%80%9A%E9%81%93%E4%B8%8E%E5%BC%95%E8%84%9A%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB.png\" alt=\"ADC通道与引脚对应关系\"></p>\n<h2 id=\"Printf第一个字符丢失\"><a href=\"#Printf第一个字符丢失\" class=\"headerlink\" title=\"Printf第一个字符丢失\"></a>Printf第一个字符丢失</h2><ul>\n<li>将发送放在等待标志位后面即可解决问题</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">&#123;<br>\t<span class=\"hljs-comment\">/* Loop until the end of transmission */</span><br>\t<span class=\"hljs-keyword\">while</span> (USART_GetFlagStatus(USART2, USART_FLAG_TC) == RESET);<br>\t<br>\t<span class=\"hljs-comment\">/* Place your implementation of fputc here */</span><br>\t<span class=\"hljs-comment\">/* e.g. write a character to the USART */</span><br>\tUSART_SendData(USART2, (<span class=\"hljs-type\">uint8_t</span>) ch);<br>\t<br>\t<span class=\"hljs-keyword\">return</span> ch;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"通用TIM-PWM输出低电平\"><a href=\"#通用TIM-PWM输出低电平\" class=\"headerlink\" title=\"通用TIM PWM输出低电平\"></a>通用TIM PWM输出低电平</h2><p>调用 TIM_CCxCmd 关闭输出使能即可<strong>持续输出低电平</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">TIM_CCxCmd</span><span class=\"hljs-params\">(TIM_TypeDef* TIMx, <span class=\"hljs-type\">uint16_t</span> TIM_Channel, <span class=\"hljs-type\">uint16_t</span> TIM_CCx)</span><br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>CCxE位</th>\n<th>OCx输出状态</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>禁止输出(OCx&#x3D;0，OCx_EN&#x3D;0)</td>\n</tr>\n<tr>\n<td>1</td>\n<td>OCx &#x3D; OCxREF + 极性，OCx_EN&#x3D;1</td>\n</tr>\n</tbody></table>\n<h2 id=\"杂乱笔记\"><a href=\"#杂乱笔记\" class=\"headerlink\" title=\"杂乱笔记\"></a>杂乱笔记</h2><ul>\n<li><p>仿真建议使用SWD模式(使用的线少)         emmm。。。。？</p>\n</li>\n<li><p>KEY_UP高电有效（可用于唤醒）、KEY0、KEY1低电有效</p>\n</li>\n<li><p><strong>编译器会默认把没有赋值的变量自动赋值为0（真的是这样吗？，局部变量呢？答复:局部变量不会被初始化,请一定注意要去手动进行初始化）</strong></p>\n</li>\n<li><p><strong>NTC (Negative Temperature Coefficient 负温度系数)      PTC (Positive 正温度系数)</strong></p>\n</li>\n<li><p>RTC (实时时钟)</p>\n</li>\n<li><p>APB1和APB2的区别,<br>APB1操作速度限于36MHz,\t上面连接的是低速外设,包括 TIM234567、WWDG、SPI2、SPI3、USART23、UART45、CAN12、PWRPower interface clock、 BKP、 DAC、I2C12、等，<strong>具体请参考7.3.8章节APB1外设使能寄存器</strong><br>APB2操作速度全速,\t上面连接的是高速外设,包括 UART1 、SPI1、Timer1、ADC1、ADC2、所有普通 IO 口(PA-PE)(PA-PE)(PA-PE)(PA-PE)(PA-PE)(PA-PE) 、第二功能IO 口 、<strong>具体请参考7.3.7章节APB2外设使能寄存器</strong></p>\n</li>\n<li><p>原子提供的delay_ms 最大是1864ms不能超过这个值</p>\n</li>\n<li><p>volatile 简单地说就是防止编译器对代码进行优化。</p>\n</li>\n<li><p>enum 枚举类型</p>\n</li>\n<li><p><strong>SysTick     LOAD 转载到 VAL 需要时钟周期所以计算 LOAD 时需要-1</strong></p>\n</li>\n<li><p><strong>PA13 PA14 PA15 PB3 PB4 上电默认是SWD+JTAG模式所以这些GPIO口不能直接使用可调用 GPIO_PinRemapConfig 函数修改</strong></p>\n</li>\n<li><p>DAC要将对应的IO设置成模拟输入！！！</p>\n</li>\n<li><p>USART1 时钟脉冲来源   PCLK2     USART2-4来源   PCLK1</p>\n</li>\n<li><p><strong>使用USART不需要使能AFIO    （发生重映射才需要进行打开AFIO参考CSDN）</strong></p>\n</li>\n<li><p>0,1,2,3,4 各有自己的中断函数        5-9共用一个中断函数    10-15共用一个中断函数</p>\n</li>\n<li><p><strong>u8 temp <em>attribute</em>((at (地址)));\t\t\t\t\t&#x2F;&#x2F;需要定义为全局变量—-定义变量到指定地址</strong></p>\n</li>\n<li><p>容量</p>\n<p>4表示16KB （小容量ld）<br>6表示32KB （小容量ld）<br>8表示64KB （中容量md）<br>B表示128KB （中容量md）<br>C表示256KB （大容量hd）<br>E表示512KB （大容量hd）<br>F表示768KB （超大容量xl）<br>G表示1024KB （超大容量xl）</p>\n</li>\n<li><p>ADC输入范围：VREF- ≤  VIN  ≤  VREF+</p>\n</li>\n<li><p>在扫描模式下，由ADC_SQRx或者ADC_JSQRx寄存器选中的通道被转换。如果设置了EOCIE或者JEOCIE，在最后一个通道转换完毕后才会产生EOC或者JEOC中断。</p>\n</li>\n<li><p>ADC ADC1通道17 测得的是内部参考电压(根据数据手册中的数据，这个参照电压的典型值是1.20V，最小值是1.16V，最大值是1.24V)，!!!不是ADC的参考电压Vref+!!!</p>\n</li>\n<li><p>系统滴答定时器</p>\n<p>SysTick-&gt;CTRL        类似控制及状态位寄存器<br>SysTick-&gt;LOAD\t   到时间自动重装的重装载寄存器<br>SysTick-&gt;VAL\t      当前数值寄存器<br>SysTick-&gt;CALIB      校准数值寄存器（暂时没有用到）</p>\n</li>\n</ul>\n<h1 id=\"RTOS相关\"><a href=\"#RTOS相关\" class=\"headerlink\" title=\"RTOS相关\"></a>RTOS相关</h1><h2 id=\"线程进程\"><a href=\"#线程进程\" class=\"headerlink\" title=\"线程进程\"></a>线程进程</h2><h3 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h3><ul>\n<li><p>资源分配的最小单位(拥有独立的地址空间，同一个进程内的线程共享进程地址空间)</p>\n</li>\n<li><p>进程是程序执行的实例</p>\n</li>\n</ul>\n<h3 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h3><ul>\n<li><p>程序执行的最小单位</p>\n</li>\n<li><p>CPU调度最小单位，一个进程并发多个线程</p>\n</li>\n</ul>\n<h3 id=\"关系\"><a href=\"#关系\" class=\"headerlink\" title=\"关系\"></a>关系</h3><ul>\n<li>资源分配给进程，同一进程内的所有线程共享该进程的所有资源；</li>\n<li>同一个进程的线程之间可以直接交流；两个进程想通信，必须通过一个中间代理来实现；</li>\n<li>处理机分配给线程，即真正在处理机上运行的是线程；</li>\n<li><strong>线程共享内存空间；进程的内存是独立的；</strong></li>\n<li>系统开销：在创建和撤销进程的时候，系统都要分配和回收资源，导致系统的明显大于创建和撤销线程时的开销。但进程有独立的地址空间，进程崩溃后，在保护模式的下不会对其他进程造成影响，而线程只是进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有独立的地址空间，一个线程死后就等于整个进程死掉，所以多进程程序要比多线程程序健壮，但是在进程切换的时候消耗的资源较大，效率差。</li>\n<li><strong>多线程执行效率高; 多进程耗资源，安全。</strong></li>\n</ul>\n<h1 id=\"外设\"><a href=\"#外设\" class=\"headerlink\" title=\"外设\"></a>外设</h1><h2 id=\"IIC\"><a href=\"#IIC\" class=\"headerlink\" title=\"IIC\"></a>IIC</h2><p><strong>双向通信速度（模式）：</strong></p>\n<p>100 kbit&#x2F;s：标准模式，Standard-mode (Sm)；</p>\n<p>400 kbit&#x2F;s：快速模式，Fast-mode (Fm)；</p>\n<p>1 Mbit&#x2F;s：快速模式+，Fast-mode Plus (Fm+)；</p>\n<p>3.4Mbit&#x2F;s：高速模式，High-speed mode (Hs-mode)；</p>\n<p><strong>单向通信速度（模式）：</strong></p>\n<p>5 Mbit&#x2F;s：超快模式，UItra Fast-mode (UFm)。</p>\n<h2 id=\"SPI\"><a href=\"#SPI\" class=\"headerlink\" title=\"SPI\"></a>SPI</h2><p>CKPOL (Clock Polarity) &#x3D; CPOL &#x3D; POL &#x3D; Polarity &#x3D; （时钟）极性<br>CKPHA (Clock Phase)  &#x3D; CPHA &#x3D; PHA &#x3D; Phase &#x3D; （时钟）相位</p>\n<h3 id=\"CPOL极性\"><a href=\"#CPOL极性\" class=\"headerlink\" title=\"CPOL极性\"></a>CPOL极性</h3><p>先说什么是SCLK时钟的空闲时刻，其就是当SCLK在发送8个bit比特数据之前和之后的状态，于此对应的，SCLK在发送数据的时候，就是正常的工作的时候，有效active的时刻了。其英文精简解释为：Clock Polarity &#x3D; IDLE state of SCK。</p>\n<p>SPI的CPOL，<span style=\"color:#29b6f6\"><strong>表示当SCLK空闲idle的时候，其电平的值是低电平0还是高电平1</strong></span>：<br>CPOL&#x3D;0，时钟空闲idle时候的电平是低电平，所以当SCLK有效的时候，就是高电平，就是所谓的active-high；<br>CPOL&#x3D;1，时钟空闲idle时候的电平是高电平，所以当SCLK有效的时候，就是低电平，就是所谓的active-low；<br><img src=\"/2018/ef667962/231416549884871.gif\" alt=\"img\"></p>\n<p>从上图中可以看出，(CPOL&#x3D;0)的SCK 波形，它有（传输）8 个脉冲，而在脉冲传输前和完成后都保持在【低电平状态】。<br>此时的状态就是时钟的空闲状态或无效状态，因为此时没有脉冲，也就不会有数据传输。同理得出，（CPOL&#x3D;）1 的图，时钟的空闲状态或无效状态时SCK 是保持【高电平的】。</p>\n<h3 id=\"CPHA相位\"><a href=\"#CPHA相位\" class=\"headerlink\" title=\"CPHA相位\"></a>CPHA相位</h3><p>首先说明一点，capture strobe &#x3D; latch &#x3D; read &#x3D; sample，都是表示数据采样，数据有效的时刻。<br>相位，对应着数据采样是在第几个边沿（edge），是第一个边沿还是第二个边沿，0对应着第一个边沿，1对应着第二个边沿。对于：</p>\n<p>CPHA&#x3D;0，表示第一个边沿：<br>对于CPOL&#x3D;0，idle时候的是低电平，第一个边沿就是从低变到高，所以是上升沿；<br>对于CPOL&#x3D;1，idle时候的是高电平，第一个边沿就是从高变到低，所以是下降沿；</p>\n<p>CPHA&#x3D;1，表示第二个边沿：<br>对于CPOL&#x3D;0，idle时候的是低电平，第二个边沿就是从高变到低，所以是下降沿；<br>对于CPOL&#x3D;1，idle时候的是高电平，第一个边沿就是从低变到高，所以是上升沿；</p>\n<p><span style=\"color:#29b6f6\"><strong>数据是在SCK的第一个时钟边沿保持稳定【数据被采样捕获】，在下一个边沿改变【SCK 的下降沿数据改变】</strong></span></p>\n<h1 id=\"嵌入式高效位算法\"><a href=\"#嵌入式高效位算法\" class=\"headerlink\" title=\"嵌入式高效位算法\"></a>嵌入式高效位算法</h1><p>参考资料：</p>\n<p><a href=\"http://aggregate.org/MAGIC/#Bit%20Reversal\">The Aggregate Magic Algorithms</a></p>\n<p><a href=\"http://graphics.stanford.edu/~seander/bithacks.html\">Bit Twiddling Hacks</a></p>\n<p>WORDBITS:\t\t数据宽度</p>\n<h2 id=\"位逆序\"><a href=\"#位逆序\" class=\"headerlink\" title=\"位逆序\"></a>位逆序</h2><h3 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1\"></a>1</h3><p>在整数x中反转位有点痛苦，但这里有一个32位值的SWAR算法: </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span><br><span class=\"hljs-title function_\">reverse</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">register</span> <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> x)</span><br>&#123;<br>\tx = (((x &amp; <span class=\"hljs-number\">0xaaaaaaaa</span>) &gt;&gt; <span class=\"hljs-number\">1</span>) | ((x &amp; <span class=\"hljs-number\">0x55555555</span>) &lt;&lt; <span class=\"hljs-number\">1</span>));<br>\tx = (((x &amp; <span class=\"hljs-number\">0xcccccccc</span>) &gt;&gt; <span class=\"hljs-number\">2</span>) | ((x &amp; <span class=\"hljs-number\">0x33333333</span>) &lt;&lt; <span class=\"hljs-number\">2</span>));<br>\tx = (((x &amp; <span class=\"hljs-number\">0xf0f0f0f0</span>) &gt;&gt; <span class=\"hljs-number\">4</span>) | ((x &amp; <span class=\"hljs-number\">0x0f0f0f0f</span>) &lt;&lt; <span class=\"hljs-number\">4</span>));<br>\tx = (((x &amp; <span class=\"hljs-number\">0xff00ff00</span>) &gt;&gt; <span class=\"hljs-number\">8</span>) | ((x &amp; <span class=\"hljs-number\">0x00ff00ff</span>) &lt;&lt; <span class=\"hljs-number\">8</span>));<br>\t<span class=\"hljs-keyword\">return</span>((x &gt;&gt; <span class=\"hljs-number\">16</span>) | (x &lt;&lt; <span class=\"hljs-number\">16</span>));<br><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p> 也可以重写这个算法，使用4个而不是8个常量，从而节省一些指令带宽。在我的1.2GHz Athlon(雷鸟)上，这种差别太小了，无法可靠地测量。下面是另一个版本: </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span><br><span class=\"hljs-title function_\">reverse</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">register</span> <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> x)</span><br>&#123;<br>        <span class=\"hljs-keyword\">register</span> <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> y = <span class=\"hljs-number\">0x55555555</span>;<br>        x = (((x &gt;&gt; <span class=\"hljs-number\">1</span>) &amp; y) | ((x &amp; y) &lt;&lt; <span class=\"hljs-number\">1</span>));<br>        y = <span class=\"hljs-number\">0x33333333</span>;<br>        x = (((x &gt;&gt; <span class=\"hljs-number\">2</span>) &amp; y) | ((x &amp; y) &lt;&lt; <span class=\"hljs-number\">2</span>));<br>        y = <span class=\"hljs-number\">0x0f0f0f0f</span>;<br>        x = (((x &gt;&gt; <span class=\"hljs-number\">4</span>) &amp; y) | ((x &amp; y) &lt;&lt; <span class=\"hljs-number\">4</span>));<br>        y = <span class=\"hljs-number\">0x00ff00ff</span>;<br>        x = (((x &gt;&gt; <span class=\"hljs-number\">8</span>) &amp; y) | ((x &amp; y) &lt;&lt; <span class=\"hljs-number\">8</span>));<br>        <span class=\"hljs-keyword\">return</span>((x &gt;&gt; <span class=\"hljs-number\">16</span>) | (x &lt;&lt; <span class=\"hljs-number\">16</span>));<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"8位查表\"><a href=\"#8位查表\" class=\"headerlink\" title=\"8位查表\"></a>8位查表</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">private Byte  <span class=\"hljs-title function_\">BitReverse</span><span class=\"hljs-params\">(Byte bData)</span><br>&#123;<br>    Byte[] lookup = &#123; <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">8</span>,  <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">12</span>, <br>                     <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">14</span> , <br>                     <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">9</span>,  <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">13</span>,<br>                     <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">15</span> &#125;;<br>    Byte ret_val = (Byte)(((lookup[(bData &amp; <span class=\"hljs-number\">0x0F</span>)]) &lt;&lt; <span class=\"hljs-number\">4</span>) + lookup[((bData &amp; <span class=\"hljs-number\">0xF0</span>) &gt;&gt; <span class=\"hljs-number\">4</span>)]);<br>    <span class=\"hljs-keyword\">return</span> ret_val;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"16位查表\"><a href=\"#16位查表\" class=\"headerlink\" title=\"16位查表\"></a>16位查表</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">char</span> BitReverseTable256[] = <br>&#123;<br>  <span class=\"hljs-number\">0x00</span>, <span class=\"hljs-number\">0x80</span>, <span class=\"hljs-number\">0x40</span>, <span class=\"hljs-number\">0xC0</span>, <span class=\"hljs-number\">0x20</span>, <span class=\"hljs-number\">0xA0</span>, <span class=\"hljs-number\">0x60</span>, <span class=\"hljs-number\">0xE0</span>, <span class=\"hljs-number\">0x10</span>, <span class=\"hljs-number\">0x90</span>, <span class=\"hljs-number\">0x50</span>, <span class=\"hljs-number\">0xD0</span>, <span class=\"hljs-number\">0x30</span>, <span class=\"hljs-number\">0xB0</span>, <span class=\"hljs-number\">0x70</span>, <span class=\"hljs-number\">0xF0</span>, <br>  <span class=\"hljs-number\">0x08</span>, <span class=\"hljs-number\">0x88</span>, <span class=\"hljs-number\">0x48</span>, <span class=\"hljs-number\">0xC8</span>, <span class=\"hljs-number\">0x28</span>, <span class=\"hljs-number\">0xA8</span>, <span class=\"hljs-number\">0x68</span>, <span class=\"hljs-number\">0xE8</span>, <span class=\"hljs-number\">0x18</span>, <span class=\"hljs-number\">0x98</span>, <span class=\"hljs-number\">0x58</span>, <span class=\"hljs-number\">0xD8</span>, <span class=\"hljs-number\">0x38</span>, <span class=\"hljs-number\">0xB8</span>, <span class=\"hljs-number\">0x78</span>, <span class=\"hljs-number\">0xF8</span>, <br>  <span class=\"hljs-number\">0x04</span>, <span class=\"hljs-number\">0x84</span>, <span class=\"hljs-number\">0x44</span>, <span class=\"hljs-number\">0xC4</span>, <span class=\"hljs-number\">0x24</span>, <span class=\"hljs-number\">0xA4</span>, <span class=\"hljs-number\">0x64</span>, <span class=\"hljs-number\">0xE4</span>, <span class=\"hljs-number\">0x14</span>, <span class=\"hljs-number\">0x94</span>, <span class=\"hljs-number\">0x54</span>, <span class=\"hljs-number\">0xD4</span>, <span class=\"hljs-number\">0x34</span>, <span class=\"hljs-number\">0xB4</span>, <span class=\"hljs-number\">0x74</span>, <span class=\"hljs-number\">0xF4</span>, <br>  <span class=\"hljs-number\">0x0C</span>, <span class=\"hljs-number\">0x8C</span>, <span class=\"hljs-number\">0x4C</span>, <span class=\"hljs-number\">0xCC</span>, <span class=\"hljs-number\">0x2C</span>, <span class=\"hljs-number\">0xAC</span>, <span class=\"hljs-number\">0x6C</span>, <span class=\"hljs-number\">0xEC</span>, <span class=\"hljs-number\">0x1C</span>, <span class=\"hljs-number\">0x9C</span>, <span class=\"hljs-number\">0x5C</span>, <span class=\"hljs-number\">0xDC</span>, <span class=\"hljs-number\">0x3C</span>, <span class=\"hljs-number\">0xBC</span>, <span class=\"hljs-number\">0x7C</span>, <span class=\"hljs-number\">0xFC</span>, <br>  <span class=\"hljs-number\">0x02</span>, <span class=\"hljs-number\">0x82</span>, <span class=\"hljs-number\">0x42</span>, <span class=\"hljs-number\">0xC2</span>, <span class=\"hljs-number\">0x22</span>, <span class=\"hljs-number\">0xA2</span>, <span class=\"hljs-number\">0x62</span>, <span class=\"hljs-number\">0xE2</span>, <span class=\"hljs-number\">0x12</span>, <span class=\"hljs-number\">0x92</span>, <span class=\"hljs-number\">0x52</span>, <span class=\"hljs-number\">0xD2</span>, <span class=\"hljs-number\">0x32</span>, <span class=\"hljs-number\">0xB2</span>, <span class=\"hljs-number\">0x72</span>, <span class=\"hljs-number\">0xF2</span>, <br>  <span class=\"hljs-number\">0x0A</span>, <span class=\"hljs-number\">0x8A</span>, <span class=\"hljs-number\">0x4A</span>, <span class=\"hljs-number\">0xCA</span>, <span class=\"hljs-number\">0x2A</span>, <span class=\"hljs-number\">0xAA</span>, <span class=\"hljs-number\">0x6A</span>, <span class=\"hljs-number\">0xEA</span>, <span class=\"hljs-number\">0x1A</span>, <span class=\"hljs-number\">0x9A</span>, <span class=\"hljs-number\">0x5A</span>, <span class=\"hljs-number\">0xDA</span>, <span class=\"hljs-number\">0x3A</span>, <span class=\"hljs-number\">0xBA</span>, <span class=\"hljs-number\">0x7A</span>, <span class=\"hljs-number\">0xFA</span>,<br>  <span class=\"hljs-number\">0x06</span>, <span class=\"hljs-number\">0x86</span>, <span class=\"hljs-number\">0x46</span>, <span class=\"hljs-number\">0xC6</span>, <span class=\"hljs-number\">0x26</span>, <span class=\"hljs-number\">0xA6</span>, <span class=\"hljs-number\">0x66</span>, <span class=\"hljs-number\">0xE6</span>, <span class=\"hljs-number\">0x16</span>, <span class=\"hljs-number\">0x96</span>, <span class=\"hljs-number\">0x56</span>, <span class=\"hljs-number\">0xD6</span>, <span class=\"hljs-number\">0x36</span>, <span class=\"hljs-number\">0xB6</span>, <span class=\"hljs-number\">0x76</span>, <span class=\"hljs-number\">0xF6</span>, <br>  <span class=\"hljs-number\">0x0E</span>, <span class=\"hljs-number\">0x8E</span>, <span class=\"hljs-number\">0x4E</span>, <span class=\"hljs-number\">0xCE</span>, <span class=\"hljs-number\">0x2E</span>, <span class=\"hljs-number\">0xAE</span>, <span class=\"hljs-number\">0x6E</span>, <span class=\"hljs-number\">0xEE</span>, <span class=\"hljs-number\">0x1E</span>, <span class=\"hljs-number\">0x9E</span>, <span class=\"hljs-number\">0x5E</span>, <span class=\"hljs-number\">0xDE</span>, <span class=\"hljs-number\">0x3E</span>, <span class=\"hljs-number\">0xBE</span>, <span class=\"hljs-number\">0x7E</span>, <span class=\"hljs-number\">0xFE</span>,<br>  <span class=\"hljs-number\">0x01</span>, <span class=\"hljs-number\">0x81</span>, <span class=\"hljs-number\">0x41</span>, <span class=\"hljs-number\">0xC1</span>, <span class=\"hljs-number\">0x21</span>, <span class=\"hljs-number\">0xA1</span>, <span class=\"hljs-number\">0x61</span>, <span class=\"hljs-number\">0xE1</span>, <span class=\"hljs-number\">0x11</span>, <span class=\"hljs-number\">0x91</span>, <span class=\"hljs-number\">0x51</span>, <span class=\"hljs-number\">0xD1</span>, <span class=\"hljs-number\">0x31</span>, <span class=\"hljs-number\">0xB1</span>, <span class=\"hljs-number\">0x71</span>, <span class=\"hljs-number\">0xF1</span>,<br>  <span class=\"hljs-number\">0x09</span>, <span class=\"hljs-number\">0x89</span>, <span class=\"hljs-number\">0x49</span>, <span class=\"hljs-number\">0xC9</span>, <span class=\"hljs-number\">0x29</span>, <span class=\"hljs-number\">0xA9</span>, <span class=\"hljs-number\">0x69</span>, <span class=\"hljs-number\">0xE9</span>, <span class=\"hljs-number\">0x19</span>, <span class=\"hljs-number\">0x99</span>, <span class=\"hljs-number\">0x59</span>, <span class=\"hljs-number\">0xD9</span>, <span class=\"hljs-number\">0x39</span>, <span class=\"hljs-number\">0xB9</span>, <span class=\"hljs-number\">0x79</span>, <span class=\"hljs-number\">0xF9</span>, <br>  <span class=\"hljs-number\">0x05</span>, <span class=\"hljs-number\">0x85</span>, <span class=\"hljs-number\">0x45</span>, <span class=\"hljs-number\">0xC5</span>, <span class=\"hljs-number\">0x25</span>, <span class=\"hljs-number\">0xA5</span>, <span class=\"hljs-number\">0x65</span>, <span class=\"hljs-number\">0xE5</span>, <span class=\"hljs-number\">0x15</span>, <span class=\"hljs-number\">0x95</span>, <span class=\"hljs-number\">0x55</span>, <span class=\"hljs-number\">0xD5</span>, <span class=\"hljs-number\">0x35</span>, <span class=\"hljs-number\">0xB5</span>, <span class=\"hljs-number\">0x75</span>, <span class=\"hljs-number\">0xF5</span>,<br>  <span class=\"hljs-number\">0x0D</span>, <span class=\"hljs-number\">0x8D</span>, <span class=\"hljs-number\">0x4D</span>, <span class=\"hljs-number\">0xCD</span>, <span class=\"hljs-number\">0x2D</span>, <span class=\"hljs-number\">0xAD</span>, <span class=\"hljs-number\">0x6D</span>, <span class=\"hljs-number\">0xED</span>, <span class=\"hljs-number\">0x1D</span>, <span class=\"hljs-number\">0x9D</span>, <span class=\"hljs-number\">0x5D</span>, <span class=\"hljs-number\">0xDD</span>, <span class=\"hljs-number\">0x3D</span>, <span class=\"hljs-number\">0xBD</span>, <span class=\"hljs-number\">0x7D</span>, <span class=\"hljs-number\">0xFD</span>,<br>  <span class=\"hljs-number\">0x03</span>, <span class=\"hljs-number\">0x83</span>, <span class=\"hljs-number\">0x43</span>, <span class=\"hljs-number\">0xC3</span>, <span class=\"hljs-number\">0x23</span>, <span class=\"hljs-number\">0xA3</span>, <span class=\"hljs-number\">0x63</span>, <span class=\"hljs-number\">0xE3</span>, <span class=\"hljs-number\">0x13</span>, <span class=\"hljs-number\">0x93</span>, <span class=\"hljs-number\">0x53</span>, <span class=\"hljs-number\">0xD3</span>, <span class=\"hljs-number\">0x33</span>, <span class=\"hljs-number\">0xB3</span>, <span class=\"hljs-number\">0x73</span>, <span class=\"hljs-number\">0xF3</span>, <br>  <span class=\"hljs-number\">0x0B</span>, <span class=\"hljs-number\">0x8B</span>, <span class=\"hljs-number\">0x4B</span>, <span class=\"hljs-number\">0xCB</span>, <span class=\"hljs-number\">0x2B</span>, <span class=\"hljs-number\">0xAB</span>, <span class=\"hljs-number\">0x6B</span>, <span class=\"hljs-number\">0xEB</span>, <span class=\"hljs-number\">0x1B</span>, <span class=\"hljs-number\">0x9B</span>, <span class=\"hljs-number\">0x5B</span>, <span class=\"hljs-number\">0xDB</span>, <span class=\"hljs-number\">0x3B</span>, <span class=\"hljs-number\">0xBB</span>, <span class=\"hljs-number\">0x7B</span>, <span class=\"hljs-number\">0xFB</span>,<br>  <span class=\"hljs-number\">0x07</span>, <span class=\"hljs-number\">0x87</span>, <span class=\"hljs-number\">0x47</span>, <span class=\"hljs-number\">0xC7</span>, <span class=\"hljs-number\">0x27</span>, <span class=\"hljs-number\">0xA7</span>, <span class=\"hljs-number\">0x67</span>, <span class=\"hljs-number\">0xE7</span>, <span class=\"hljs-number\">0x17</span>, <span class=\"hljs-number\">0x97</span>, <span class=\"hljs-number\">0x57</span>, <span class=\"hljs-number\">0xD7</span>, <span class=\"hljs-number\">0x37</span>, <span class=\"hljs-number\">0xB7</span>, <span class=\"hljs-number\">0x77</span>, <span class=\"hljs-number\">0xF7</span>, <br>  <span class=\"hljs-number\">0x0F</span>, <span class=\"hljs-number\">0x8F</span>, <span class=\"hljs-number\">0x4F</span>, <span class=\"hljs-number\">0xCF</span>, <span class=\"hljs-number\">0x2F</span>, <span class=\"hljs-number\">0xAF</span>, <span class=\"hljs-number\">0x6F</span>, <span class=\"hljs-number\">0xEF</span>, <span class=\"hljs-number\">0x1F</span>, <span class=\"hljs-number\">0x9F</span>, <span class=\"hljs-number\">0x5F</span>, <span class=\"hljs-number\">0xDF</span>, <span class=\"hljs-number\">0x3F</span>, <span class=\"hljs-number\">0xBF</span>, <span class=\"hljs-number\">0x7F</span>, <span class=\"hljs-number\">0xFF</span><br>&#125;;<br><br><span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> v; <span class=\"hljs-comment\">// reverse 32-bit value, 8 bits at time</span><br><span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> c; <span class=\"hljs-comment\">// c will get v reversed</span><br><br><span class=\"hljs-comment\">// Option 1:</span><br>c = (BitReverseTable256[v &amp; <span class=\"hljs-number\">0xff</span>] &lt;&lt; <span class=\"hljs-number\">24</span>) | <br>    (BitReverseTable256[(v &gt;&gt; <span class=\"hljs-number\">8</span>) &amp; <span class=\"hljs-number\">0xff</span>] &lt;&lt; <span class=\"hljs-number\">16</span>) | <br>    (BitReverseTable256[(v &gt;&gt; <span class=\"hljs-number\">16</span>) &amp; <span class=\"hljs-number\">0xff</span>] &lt;&lt; <span class=\"hljs-number\">8</span>) |<br>    (BitReverseTable256[(v &gt;&gt; <span class=\"hljs-number\">24</span>) &amp; <span class=\"hljs-number\">0xff</span>]);<br><br><span class=\"hljs-comment\">// Option 2:</span><br><span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">char</span> * p = (<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">char</span> *) &amp;v;<br><span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">char</span> * q = (<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">char</span> *) &amp;c;<br>q[<span class=\"hljs-number\">3</span>] = BitReverseTable256[p[<span class=\"hljs-number\">0</span>]]; <br>q[<span class=\"hljs-number\">2</span>] = BitReverseTable256[p[<span class=\"hljs-number\">1</span>]]; <br>q[<span class=\"hljs-number\">1</span>] = BitReverseTable256[p[<span class=\"hljs-number\">2</span>]]; <br>q[<span class=\"hljs-number\">0</span>] = BitReverseTable256[p[<span class=\"hljs-number\">3</span>]];<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"整数平均值\"><a href=\"#整数平均值\" class=\"headerlink\" title=\"整数平均值\"></a>整数平均值</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">(x+y)/<span class=\"hljs-number\">2</span>\t<span class=\"hljs-comment\">//可能导致溢出 相加溢出</span><br>    <br>(x＆y)+((x ^ y)&gt;&gt; <span class=\"hljs-number\">1</span>)\t<span class=\"hljs-comment\">//可以改用这种方法</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><p>原理：</p>\n<p>这实际上是“众所周知”事实的扩展，对于二进制整数值<code>x</code>和<code>y</code>，<code>（x + y）</code> 等于<code>（（x＆y）+（x | y））</code>等于<code>（（x ^ y）+ 2 *（x＆y ））</code>。</p>\n<p>给定两个整数值<code>x</code>和<code>y</code>，平均值的（底数）通常将由<code>（x + y）/ 2计算</code>；不幸的是，由于溢出，这可能会产生错误的结果。一个非常偷偷摸摸的替代方法是使用<code>（x＆y）+（（（x ^ y）/ 2）</code>。如果我们由于C没有指定是否对移位进行签名而意识到潜在的不可移植性，则可以将其简化为<code>（x＆y）+（（x ^ y）&gt;&gt; 1）</code>。无论哪种情况，好处是此代码序列都不会溢出。</p>\n</li>\n</ul>\n<h2 id=\"整数求最大最小值\"><a href=\"#整数求最大最小值\" class=\"headerlink\" title=\"整数求最大最小值\"></a>整数求最大最小值</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">x-(((x-y)&gt;&gt;(WORDBITS<span class=\"hljs-number\">-1</span>))&amp;(x-y))\t\t\t\t<span class=\"hljs-comment\">//Maximum</span><br>x+(((y-x)&gt;&gt;(WORDBITS<span class=\"hljs-number\">-1</span>))&amp;(y-x))\t\t\t\t<span class=\"hljs-comment\">//Minimum </span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><p>解释</p>\n<p>WORDBITS是数据宽度（8，16，32，……）</p>\n</li>\n<li><p>原理</p>\n<p>((x-y)&gt;&gt;(WORDBITS-1)) 相当于取出符号位</p>\n<p>当x&gt;y时结果是0</p>\n<p><span style=\"color:red\"> 注意！ 当x&lt;y时结果是全1，，比如WORDBITS是8那么这个式子运算结果是0xFF</span></p>\n<p><span style=\"color:red\">注意！ 负数的移位似乎不太一样（当有符号整数右移时，最左边的位的值被复制到其他位）,（ 不幸的是，这种行为是特定于体系结构的）</span></p>\n</li>\n</ul>\n<p>同样的可以利用这一点应用到其他算法中：<a href=\"#%E6%95%B4%E6%95%B0%E9%80%89%E6%8B%A9%E8%B5%8B%E5%80%BC\">整数选择赋值</a></p>\n<h2 id=\"整数选择赋值\"><a href=\"#整数选择赋值\" class=\"headerlink\" title=\"整数选择赋值\"></a>整数选择赋值</h2> <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-keyword\">if</span> (a&lt;b) x=c; <span class=\"hljs-keyword\">else</span> x=d; \t\t\t\t\t<span class=\"hljs-comment\">//都是整数</span><br><br>x=((((a-b) &gt;&gt; (WORDBITS<span class=\"hljs-number\">-1</span>)) &amp; (c^d)) ^ d) \t<span class=\"hljs-comment\">//优化后</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><p>原理</p>\n<p>参考<a href=\"#%E6%95%B4%E6%95%B0%E6%B1%82%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%80%BC\">整数求最大最小值</a></p>\n</li>\n</ul>\n<h2 id=\"没有临时值，交换值两数据的值\"><a href=\"#没有临时值，交换值两数据的值\" class=\"headerlink\" title=\"没有临时值，交换值两数据的值\"></a>没有临时值，交换值两数据的值</h2> <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">//example 1</span><br>x ^= y; <span class=\"hljs-comment\">/* x&#x27; = (x^y) */</span><br>y ^= x;\t<span class=\"hljs-comment\">/* y&#x27; = (y^(x^y)) = x */</span><br>x ^= y; <span class=\"hljs-comment\">/* x&#x27; = (x^y)^x = y */</span><br><br><span class=\"hljs-comment\">//example 2</span><br>x += y; \t<span class=\"hljs-comment\">/* x&#x27; = (x+y) */</span><br>y = x - y;\t<span class=\"hljs-comment\">/* y&#x27; = (x+y)-y = x */</span><br>x -= y;\t\t<span class=\"hljs-comment\">/* x&#x27; = (x+y)-x = y */</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><p>注意:</p>\n<p>但是当x和y之间的大小有显著差异时，较小的大小的值可能会严重损失准确性。例如，如果x的模比y大得多，那么(x+y)&#x3D;&#x3D;x，最后得到y&#x3D;0。 </p>\n<p>这里如果变量的存储大小很小 还可能会产生溢出 计算出来的数据就会问题了</p>\n</li>\n</ul>\n<h2 id=\"计算byte内有多少bit置1\"><a href=\"#计算byte内有多少bit置1\" class=\"headerlink\" title=\"计算byte内有多少bit置1\"></a>计算byte内有多少bit置1</h2><p>此为 汉明距离 问题</p>\n<h3 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h3><p>just</p>\n<h3 id=\"Bit1-Bit0数量相关\"><a href=\"#Bit1-Bit0数量相关\" class=\"headerlink\" title=\"Bit1 Bit0数量相关\"></a>Bit1 Bit0数量相关</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">//bit 1 较少 0x1000 0000 只需要一次</span><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">bitcount</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> n)</span> &#123;<br>    <span class=\"hljs-type\">int</span> count=<span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">while</span> (n)  &#123;<br>        count++;<br>        n &amp;= (n - <span class=\"hljs-number\">1</span>);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> count;<br>&#125;<br><span class=\"hljs-comment\">//bit 0 较少 </span><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">bitcount</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> n)</span> &#123;<br>    <span class=\"hljs-type\">int</span> count = <span class=\"hljs-number\">8</span> * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">int</span>);<br>    n ^= (<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span>) <span class=\"hljs-number\">-1</span>;<br>    <span class=\"hljs-keyword\">while</span> (n)<br>    &#123;<br>        count--;<br>        n &amp;= (n - <span class=\"hljs-number\">1</span>);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"查表\"><a href=\"#查表\" class=\"headerlink\" title=\"查表\"></a>查表</h3><p>8位查表 4位查表</p>\n<h3 id=\"合并计数-优\"><a href=\"#合并计数-优\" class=\"headerlink\" title=\"合并计数(优)\"></a>合并计数(优)</h3><p>以<code>0x34520</code>为例，<code>b0011 0100 0101 0010 0000</code></p>\n<p>第一步：每2位为一组，组内高低位相加</p>\n<figure class=\"highlight tap\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tap\">RAW |00110100010100100000|<br>H   |0<span class=\"hljs-number\"> 1 </span>0<span class=\"hljs-number\"> 0 </span>0<span class=\"hljs-number\"> 0 </span>0<span class=\"hljs-number\"> 1 </span>0<span class=\"hljs-number\"> 0 </span>|<br>L   |<span class=\"hljs-number\"> 0 </span>1<span class=\"hljs-number\"> 1 </span>0<span class=\"hljs-number\"> 1 </span>1<span class=\"hljs-number\"> 0 </span>0<span class=\"hljs-number\"> 0 </span>0|<br>-------------------------|<br>H&gt;&gt;1|<span class=\"hljs-number\"> 0 </span>1<span class=\"hljs-number\"> 0 </span>0<span class=\"hljs-number\"> 0 </span>0<span class=\"hljs-number\"> 0 </span>1<span class=\"hljs-number\"> 0 </span>0|<br>L   |<span class=\"hljs-number\"> 0 </span>1<span class=\"hljs-number\"> 1 </span>0<span class=\"hljs-number\"> 1 </span>1<span class=\"hljs-number\"> 0 </span>0<span class=\"hljs-number\"> 0 </span>0|<br><br><br>  <span class=\"hljs-number\"> 00 </span>01<span class=\"hljs-number\"> 01 </span>00<span class=\"hljs-number\"> 01 </span>01<span class=\"hljs-number\"> 00 </span>00<span class=\"hljs-number\"> 00 </span>00<br>+ <span class=\"hljs-number\"> 00 </span>01<span class=\"hljs-number\"> 00 </span>00<span class=\"hljs-number\"> 00 </span>00<span class=\"hljs-number\"> 00 </span>01<span class=\"hljs-number\"> 00 </span>00<br>= <span class=\"hljs-number\"> 00 </span>10<span class=\"hljs-number\"> 01 </span>00<span class=\"hljs-number\"> 01 </span>01<span class=\"hljs-number\"> 00 </span>01<span class=\"hljs-number\"> 00 </span>00<br></code></pre></td></tr></table></figure>\n\n<p>第二步：每4位为一组，组内高低位相加</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-string\">RAW</span>  <span class=\"hljs-number\">0010 </span><span class=\"hljs-number\">0100 </span><span class=\"hljs-number\">0101 </span><span class=\"hljs-number\">0001 </span><span class=\"hljs-number\">0000</span><br><span class=\"hljs-string\">H</span>    <span class=\"hljs-number\">00</span>   <span class=\"hljs-number\">01</span>   <span class=\"hljs-number\">01</span>   <span class=\"hljs-number\">00</span>   <span class=\"hljs-number\">00</span>  <br><span class=\"hljs-string\">L</span>      <span class=\"hljs-number\">10</span>   <span class=\"hljs-number\">00</span>   <span class=\"hljs-number\">01</span>   <span class=\"hljs-number\">01</span>   <span class=\"hljs-number\">00</span><br><span class=\"hljs-string\">-----------------------------</span><br><span class=\"hljs-string\">H&gt;&gt;2</span> <span class=\"hljs-number\">0000 </span><span class=\"hljs-number\">0001 </span><span class=\"hljs-number\">0001 </span><span class=\"hljs-number\">0000 </span><span class=\"hljs-number\">0000</span><br><span class=\"hljs-string\">L</span>    <span class=\"hljs-number\">0010 </span><span class=\"hljs-number\">0000 </span><span class=\"hljs-number\">0001 </span><span class=\"hljs-number\">0001 </span><span class=\"hljs-number\">0000</span><br><span class=\"hljs-string\">-----------------------------</span><br><br><span class=\"hljs-attr\">H:</span>   <span class=\"hljs-number\">0000 </span><span class=\"hljs-number\">0001 </span><span class=\"hljs-number\">0001 </span><span class=\"hljs-number\">0000 </span><span class=\"hljs-number\">0000</span><br><span class=\"hljs-attr\">L:</span>   <span class=\"hljs-number\">0010 </span><span class=\"hljs-number\">0000 </span><span class=\"hljs-number\">0001 </span><span class=\"hljs-number\">0001 </span><span class=\"hljs-number\">0000</span><br><span class=\"hljs-string\">=</span>    <span class=\"hljs-number\">0010 </span><span class=\"hljs-number\">0001 </span><span class=\"hljs-number\">0010 </span><span class=\"hljs-number\">0001 </span><span class=\"hljs-number\">0000</span> <br></code></pre></td></tr></table></figure>\n\n<p>第三步：每8位为一组，组内高低位相加</p>\n<figure class=\"highlight dns\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dns\">RAW <span class=\"hljs-number\">00000010</span> <span class=\"hljs-number\">00010010</span> <span class=\"hljs-number\">00010000</span><br>    <span class=\"hljs-number\">0000</span>     <span class=\"hljs-number\">0001</span>     <span class=\"hljs-number\">0001</span>    <br>        <span class=\"hljs-number\">0010</span>     <span class=\"hljs-number\">0010</span>     <span class=\"hljs-number\">0000</span><br><br>H:  <span class=\"hljs-number\">00000000</span> <span class=\"hljs-number\">00000001</span> <span class=\"hljs-number\">00000001</span><br>L:  <span class=\"hljs-number\">00000010</span> <span class=\"hljs-number\">00000010</span> <span class=\"hljs-number\">00000000</span><br>=   <span class=\"hljs-number\">00000010</span> <span class=\"hljs-number\">00000011</span> <span class=\"hljs-number\">00000001</span><br></code></pre></td></tr></table></figure>\n\n<p>第四步：每16位为一组，组内高低位相加</p>\n<figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs asciidoc\">RAW 0000000000000010 0000001100000001<br><span class=\"hljs-code\">    00000000         00000011        </span><br><span class=\"hljs-code\">            00000010         00000001</span><br><span class=\"hljs-code\">    </span><br>H:  0000000000000000 0000000000000011<br>L:  0000000000000010 0000000000000001<br><span class=\"hljs-section\">=   0000000000000010 0000000000000100</span><br></code></pre></td></tr></table></figure>\n\n<p>第五步：每32位为一组，组内高低位相加</p>\n<figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs asciidoc\">RAW 0000000000000010 0000000000000100<br><br><span class=\"hljs-code\">    0000000000000000 0000000000000010</span><br>+   0000000000000000 0000000000000100<br><span class=\"hljs-section\">=   0000000000000000 0000000000000110 = 6 </span><br></code></pre></td></tr></table></figure>\n\n\n\n<p>这样最后得到的00000000 00000111即7即34520二进制中1的个数。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">unsigned</span> <span class=\"hljs-title function_\">numbits</span><span class=\"hljs-params\">(<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> i)</span> &#123;<br>    <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-type\">const</span> MASK1  = <span class=\"hljs-number\">0x55555555</span>;<br>    <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-type\">const</span> MASK2  = <span class=\"hljs-number\">0x33333333</span>;<br>    <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-type\">const</span> MASK4  = <span class=\"hljs-number\">0x0f0f0f0f</span>;<br>    <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-type\">const</span> MASK8  = <span class=\"hljs-number\">0x00ff00ff</span>;<br>    <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-type\">const</span> MASK16 = <span class=\"hljs-number\">0x0000ffff</span>;<br>    i = (i&amp;MASK1 ) + (i&gt;&gt;<span class=\"hljs-number\">1</span> &amp;MASK1 );<br>    i = (i&amp;MASK2 ) + (i&gt;&gt;<span class=\"hljs-number\">2</span> &amp;MASK2 );<br>    i = (i&amp;MASK4 ) + (i&gt;&gt;<span class=\"hljs-number\">4</span> &amp;MASK4 );<br>    i = (i&amp;MASK8 ) + (i&gt;&gt;<span class=\"hljs-number\">8</span> &amp;MASK8 );<br>    i = (i&amp;MASK16) + (i&gt;&gt;<span class=\"hljs-number\">16</span>&amp;MASK16);<br>\t<span class=\"hljs-keyword\">return</span> i;<br>&#125;<br><br><span class=\"hljs-comment\">// 另外一种实现</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> TWO(c)       \t(0x1u &lt;&lt; (c))</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> MASK(c)      \t(((unsigned int)(-1)) / (TWO(TWO(c)) + 1u))</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> COUNT(x,c) \t\t((x) &amp; MASK(c)) + (((x) &gt;&gt; (TWO(c))) &amp; MASK(c))</span><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">bitcount</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> n)</span><br>&#123;<br>    n = COUNT(n, <span class=\"hljs-number\">0</span>) ;<br>    n = COUNT(n, <span class=\"hljs-number\">1</span>) ;<br>    n = COUNT(n, <span class=\"hljs-number\">2</span>) ;<br>    n = COUNT(n, <span class=\"hljs-number\">3</span>) ;<br>    n = COUNT(n, <span class=\"hljs-number\">4</span>) ;<br>    <span class=\"hljs-comment\">/* n = COUNT(n, 5) ;      for 64-bit integers */</span><br>    <span class=\"hljs-keyword\">return</span> n ;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n\n\n<h1 id=\"规范性\"><a href=\"#规范性\" class=\"headerlink\" title=\"规范性\"></a>规范性</h1><h2 id=\"头文件\"><a href=\"#头文件\" class=\"headerlink\" title=\"头文件\"></a>头文件</h2><ul>\n<li>common.h作为顶层头文件，主要放置(f10x.h、通用define、通用enum、)，不得包含用户头文件以避免循环依赖。</li>\n<li>#ifndef标识符规范，前面加两个下划线 __COMMON_H</li>\n<li></li>\n</ul>\n<h2 id=\"命名\"><a href=\"#命名\" class=\"headerlink\" title=\"命名\"></a>命名</h2><table>\n<thead>\n<tr>\n<th>类型</th>\n<th>规则</th>\n<th>详细</th>\n<th>例子</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>全局变量</td>\n<td>前面加 g</td>\n<td></td>\n<td>gRoomHmidity</td>\n</tr>\n<tr>\n<td>指针</td>\n<td>前面加 p</td>\n<td></td>\n<td>pHumidity</td>\n</tr>\n<tr>\n<td>有符号变量</td>\n<td>前面加i</td>\n<td></td>\n<td>iTemperature</td>\n</tr>\n<tr>\n<td>struct函数指针</td>\n<td>前面加f(可选的)</td>\n<td></td>\n<td>fGetVal</td>\n</tr>\n<tr>\n<td>不允许直接访问</td>\n<td>前面加_</td>\n<td></td>\n<td>_DataVal</td>\n</tr>\n<tr>\n<td>enum</td>\n<td>变量前面加 e</td>\n<td></td>\n<td>eFlag</td>\n</tr>\n<tr>\n<td></td>\n<td>值全大写即可</td>\n<td></td>\n<td>ERR_OK</td>\n</tr>\n<tr>\n<td>Typedef</td>\n<td>后面加 _t</td>\n<td></td>\n<td>uint32_t</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<ul>\n<li>不要使用八进制，误认是十进制。</li>\n<li>Switch default无操作需要得到注释。</li>\n<li>禁止变量未赋值就进行使用。</li>\n<li>如果某常量与其他常量密切相关，在定义中应该明确表示出此关系。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">float</span> RAD=<span class=\"hljs-number\">100</span>;<br><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">float</span> DIAM=RAD*<span class=\"hljs-number\">2</span>;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>通讯过程中使用的结构,必须注意字节序。</strong></li>\n<li><strong>宏定义中尽量不使用return、goto、continue、break等改变程序流程的语句。</strong></li>\n<li>避免使用危险函数sprintf &#x2F;vsprintf&#x2F;strcpy&#x2F;strcat&#x2F;gets操作字符串<ul>\n<li>用strncpy()代替strcpy()</li>\n<li>用strncat()代替strcat()</li>\n<li>用snprintf()代替sprintf()</li>\n<li>用fgets()代替gets()</li>\n</ul>\n</li>\n<li></li>\n</ul>\n<h1 id=\"特殊技巧及知识总结\"><a href=\"#特殊技巧及知识总结\" class=\"headerlink\" title=\"特殊技巧及知识总结\"></a>特殊技巧及知识总结</h1><ul>\n<li>字符串中可以使用\\0OO(八进制)或\\xHH(十六进制)来引用ASCII码中的符号。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;ascii=\\x35\\n&quot;</span>);  <span class=\"hljs-comment\">// &quot;ascii=5&quot;</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>if&#x2F;else结构中尽量把TRUE概念较高的条件放到前面可以提高效率。</li>\n<li>尽量把最有可能FALSE的子表达式放在“&amp;&amp;”的左边，同理尽量把最有可能为TRUE的子表达式放在“||”的左边。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-keyword\">if</span>( p5 &amp;&amp; p95 )\t\t<span class=\"hljs-comment\">//第一个不满足就不满足</span><br><span class=\"hljs-keyword\">if</span>( p95 || p5 )\t\t<span class=\"hljs-comment\">//第一个满足就满足</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>对于多维数组来说，”先行后列”的遍历效率会更高，但可能不明显。</li>\n<li>如果某常量与其他常量密切相关，在定义中应该明确表示出此关系。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">float</span> RAD=<span class=\"hljs-number\">100</span>;<br><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">float</span> DIAM=RAD*<span class=\"hljs-number\">2</span>;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><p>如果输入参数传递的是一个ADT&#x2F;UDT类型的参数（抽象数据类型&#x2F;用户定义数据类型），宜采用 <code>const &amp;</code>的方式来传递以提高效率。而对于int等类型的基本类型的参数没有必要改成 <code>const &amp;</code>传递。指针传递，提高效率。</p>\n</li>\n<li><p>虽然类型名称和<code>*</code>组合是一种指针类型，但是编译器是将<code>*</code>于后面的变量结合的，列如：</p>\n</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span>* a,b,c;<br><span class=\"hljs-comment\">//编译器的理解是  a是int*， b、c是int</span><br><span class=\"hljs-comment\">//这也是为什么推荐将*粘着变量的原因</span><br><span class=\"hljs-type\">int</span> *a,b,c;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>多维数组中的指针</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">//以下四种表达是等价的</span><br><span class=\"hljs-comment\">// i是指行，j是指列</span><br><span class=\"hljs-comment\">// a[i][j]里面 *(a+i) 就等价于 a[i]</span><br>a[i][j]<br>*(a[i]+j)<br>(*(a+i))[j]<br>*(*(a+i)+j)<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><span style=\"color:red\">字符数组</span>是保存字符变量的数组，而<span style=\"color:red\">字符串</span>是以<code>\\0</code>结尾的字符数组。</li>\n<li>malloc&#x2F;free和new&#x2F;delete，这两者的区别主要有。new&#x2F;delete是C++里的，更高级，更安全，返回的是有类型的指针，出错会抛出异常。</li>\n<li>中断内不能使用除法<ul>\n<li>中断内有些指令需要较多的周期才能完成，它们是除法指令，双字传送指令LDRD&#x2F;STRD以及多<br>重数据传送指令(LDM&#x2F;STM)。对于前两者，CM3将为了保证中断及时响应而取消它们的执行。也就是中断内无法完成<strong>除法指令</strong>！！！</li>\n</ul>\n</li>\n<li>调试模式如果单步调试，会屏蔽各种中断，定时器，IWDG都无法进行，而且定时器仍然在计数但是不会响应中断。</li>\n</ul>\n<h2 id=\"代码解析\"><a href=\"#代码解析\" class=\"headerlink\" title=\"代码解析\"></a>代码解析</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-keyword\">switch</span> (tx_semaphore_get(tx_semaphore, convert_ms_to_ticks(timeout)))<br>&#123;<br>    <span class=\"hljs-keyword\">case</span> TX_SUCCESS:<br>        result = FFW_SUCCESS;<br>        <span class=\"hljs-keyword\">break</span>;<br>    <span class=\"hljs-keyword\">case</span> TX_NO_INSTANCE:<br>        result = FFW_TIMEOUT;<br>        <span class=\"hljs-keyword\">break</span>;<br>    <span class=\"hljs-keyword\">case</span> TX_SEMAPHORE_ERROR:<br>        result = FFW_INVALID_ARGUMENT;<br>        <span class=\"hljs-keyword\">break</span>;<br>    <span class=\"hljs-keyword\">default</span>:<br>        result = FFW_FAILURE;<br>        <span class=\"hljs-keyword\">break</span>;<br>&#125;<br><br><span class=\"hljs-comment\">// convert_ms_to_ticks 这样做会更加通用</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"BUG-翻车集锦\"><a href=\"#BUG-翻车集锦\" class=\"headerlink\" title=\"BUG 翻车集锦\"></a>BUG 翻车集锦</h1><ul>\n<li><p>TIM捕获触发DMA传输，但是在调试模式下DMA传出来的数据有问题。</p>\n<p>把DMA出来的的数据再复制一份，复制出来的数据是没有问题的。</p>\n<p>分析可能是，DEBUG下CPU停了，但是DMA总线还在跑，外设可能也是还在运行的，导致看起来DMA出来的数据有问题。</p>\n</li>\n<li><p>ADC矫正会发生ADC转换，如果有DMA配合使用，需要注意DMA需要在ADC矫正后使能。</p>\n</li>\n<li><p>隐式转换  小范围会转换成大范围  有一点特殊的是   unsigned int &gt; int</p>\n</li>\n<li><p>运算符优先级！位运算符优先级较低</p>\n</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">//编译报错</span><br>(DS18B20_DQ_IN != <span class=\"hljs-number\">0</span>)? data_temp |= <span class=\"hljs-number\">0x80</span>:data_temp&amp;=<span class=\"hljs-number\">0x7f</span>;<br><span class=\"hljs-comment\">//规范写法</span><br>(DS18B20_DQ_IN!=<span class=\"hljs-number\">0</span>)? (data_temp|=<span class=\"hljs-number\">0x80</span>):(data_temp&amp;=<span class=\"hljs-number\">0x7f</span>);<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>运算符优先级！！！极注意！！！  请小心有位运算时打上括号            &lt;&lt;  比  +-  要低</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">u16 temp;<br>u8 h,l;<br>temp = (u16)(h&lt;&lt;<span class=\"hljs-number\">8</span>) + l;<span class=\"hljs-comment\">// 正确语法</span><br>temp = h&lt;&lt;<span class=\"hljs-number\">8</span> + l;<span class=\"hljs-comment\">// 错误语法！！！！！</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>0b110</code> 这种二进制写法似乎只有在GNU模式才被允许。</p>\n</li>\n<li><p>STM32的看门狗是使得RST引脚拉低，来复位的。所以要注意复位电容的选择，太大会导致软件无法复位。</p>\n</li>\n<li><p><code>代码段内 \\ 换行后不能接 /* xxx */ 注释，注释需要些在 \\ 的前面，如 /* xxx */ \\ 这样才行</code></p>\n</li>\n<li><p>printf 内字符串问题</p>\n  <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">define</span> DC_LOG_ERROR    <span class=\"hljs-string\">&quot;\\x11&quot;</span></span><br><br><span class=\"hljs-comment\">// 没有逗号 这是正常想要表达的逻辑, 前面的DC_LOG_ERROR 和 &quot;%s:%d check SID Stasrt&quot; 合并成一个表达式</span><br><span class=\"hljs-built_in\">printf</span>(DC_LOG_ERROR  <span class=\"hljs-string\">&quot;%s:%d check SID Stasrt&quot;</span>,__func__, __LINE__);<br><span class=\"hljs-comment\">// 有逗号 只会识别前面一个字符串 后面的都没了</span><br><span class=\"hljs-built_in\">printf</span>(DC_LOG_ERROR, <span class=\"hljs-string\">&quot;%s:%d check SID Stasrt&quot;</span>,__func__, __LINE__);<br></code></pre></td></tr></table></figure></li>\n</ul>\n",
            "tags": [
                "embedded",
                "note"
            ]
        }
    ]
}
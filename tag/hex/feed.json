{
    "version": "https://jsonfeed.org/version/1",
    "title": "Oikiou's Blog • All posts by \"hex\" tag",
    "description": "Blog",
    "home_page_url": "https://www.oikiou.top",
    "items": [
        {
            "id": "https://www.oikiou.top/2021/d3f98b78/",
            "url": "https://www.oikiou.top/2021/d3f98b78/",
            "title": "Hex 文件格式解析",
            "date_published": "2021-09-24T12:27:40.000Z",
            "content_html": "<h1 id=\"Hex-文件格式解析\"><a href=\"#Hex-文件格式解析\" class=\"headerlink\" title=\"Hex 文件格式解析\"></a>Hex 文件格式解析</h1><h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://developer.arm.com/documentation/ka003292/1-0\">Intel HEX File Format Keil</a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/Intel_HEX\">Intel HEX Wiki</a></p>\n<h2 id=\"格式\"><a href=\"#格式\" class=\"headerlink\" title=\"格式\"></a>格式</h2><ul>\n<li>以行为单位，每行以冒号开头，内容全部为16进制码（以ASCII码形式显示）</li>\n<li>在HEX文件里面，每一行代表一个记录。记录的基本格式为如表所示</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><strong>冒号</strong></th>\n<th><strong>本行数据长度</strong></th>\n<th><strong>本行数据起始地址</strong></th>\n<th><strong>数据类型</strong></th>\n<th><strong>数据</strong></th>\n<th><strong>校验码</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td>1 byte</td>\n<td>2 bytes</td>\n<td>1 byte</td>\n<td>n byte</td>\n<td>1 byte</td>\n</tr>\n</tbody></table>\n<p><img src=\"/2021/d3f98b78/hex_format.jpg\" alt=\"Hex文件格式解析\"></p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Start code</td>\n<td>one character, an ASCII colon ‘:’</td>\n</tr>\n<tr>\n<td>Byte count</td>\n<td>两个十六进制数字（一个十六进制数字对），表示数据字段中的字节数（十六进制数字对）。最大字节数为 255 (0xFF)。16 (0x10) 和 32 (0x20) 是常用的字节数。</td>\n</tr>\n<tr>\n<td>Address</td>\n<td>四位十六进制数字，表示数据的 16 位起始内存地址偏移量。数据的物理地址是通过将此偏移量添加到先前建立的基地址来计算的，从而允许内存寻址超出 16 位地址的 64 KB 限制。默认为零的基地址可以通过各种类型的记录进行更改。基地址和地址偏移量始终表示为<a href=\"https://en.wikipedia.org/wiki/Big_endian\">大端</a>值。</td>\n</tr>\n<tr>\n<td>Record type</td>\n<td>两个十六进制数字，<em>00</em>到<em>05</em>，定义数据字段的含义。参考下文</td>\n</tr>\n<tr>\n<td>Data</td>\n<td>一个由<em>n</em>个字节组成的数据序列，由 <em>2n</em> 个十六进制数字表示。一些记录省略了这个字段（<em>n</em>等于零）。数据字节的含义和解释取决于应用程序。</td>\n</tr>\n<tr>\n<td>Checksum</td>\n<td>two hex digits, a computed value that can be used to verify the record has no errors.计算校验和前所有16进制码的累加和。</td>\n</tr>\n</tbody></table>\n<h3 id=\"指令类型-Record-type\"><a href=\"#指令类型-Record-type\" class=\"headerlink\" title=\"指令类型 Record type\"></a>指令类型 Record type</h3><p>指令类型<code>Record type</code>的值一般是<code>00~05</code>，这表示了，当前这行<code>hex</code>格式的数据，所代表的含义：</p>\n<table>\n<thead>\n<tr>\n<th>十六进制代码</th>\n<th>记录类型</th>\n<th align=\"center\">描述</th>\n<th align=\"center\">Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>00</strong></td>\n<td>数据</td>\n<td align=\"center\">包含数据和该数据的16位起始地址。字节计数指定记录中的数据字节数。右侧显示的示例为0B （十一）个数据字节（61， 64， 64， 72， 65， 73， 73， 20， 67， 61， 70）位于以地址开头的连续地址 0010。</td>\n<td align=\"center\"><code>:0B 0010 00 6164647265737320676170 A7</code></td>\n</tr>\n<tr>\n<td><strong>01</strong></td>\n<td>文件结束</td>\n<td align=\"center\">每个文件在文件的最后一行必须恰好发生一次。数据字段为空（因此字节数为00），并且地址字段通常为 0000。</td>\n<td align=\"center\"><code>:00 0000 01 FF</code></td>\n</tr>\n<tr>\n<td><strong>02</strong></td>\n<td>扩展段地址</td>\n<td align=\"center\">数据字段包含一个16位的段基址（因此字节数始终为02）与80x86实模式寻址兼容。地址字段（通常为0000）被忽略。最近的段地址02记录乘以16，然后加到每个后续数据记录地址，以形成数据的物理起始地址。这允许寻址多达1 MB的地址空间。</td>\n<td align=\"center\"><code>:02 0000 02 1200 EA</code></td>\n</tr>\n<tr>\n<td><strong>03</strong></td>\n<td>起始段地址</td>\n<td align=\"center\">对于80x86处理器，请指定CS：IP寄存器的初始内容（即起始执行地址）。地址字段是0000，字节数始终为04，前两个数据字节是CS值，后两个是IP值。</td>\n<td align=\"center\"><code>:04 0000 03 00003800 C1</code></td>\n</tr>\n<tr>\n<td><strong>04</strong></td>\n<td>扩展线性地址</td>\n<td align=\"center\">允许32位寻址（最大4GiB）。记录的地址字段将被忽略（通常是0000），其字节数始终为02。两个数据字节（大字节序）为所有后续类型指定32位绝对地址的高16位00记录; 这些高位地址位适用于下一个04记录。类型的绝对地址00 通过组合最近的高16位地址位形成记录 04 用低16位的地址记录 00记录。如果是类型00 记录之前没有任何类型 04 记录，然后其高16位地址位默认为0000。</td>\n<td align=\"center\"><code>:02 0000 04 FFFF FC</code></td>\n</tr>\n<tr>\n<td><strong>05</strong></td>\n<td>起始线性地址</td>\n<td align=\"center\">地址字段是 0000（未使用），字节数始终为04。四个数据字节代表一个32位地址值（big-endian）。对于80386和更高版本的CPU，此地址将加载到EIP寄存器中。<br/><strong>（仅限 MDK-ARM）</strong>起始线性地址记录指定应用程序的起始地址。这些记录包含完整的线性 32 位地址。</td>\n<td align=\"center\"><code>:04 0000 05 000000CD 2A</code></td>\n</tr>\n</tbody></table>\n<h5 id=\"扩展线性地址记录-HEX386\"><a href=\"#扩展线性地址记录-HEX386\" class=\"headerlink\" title=\"扩展线性地址记录 (HEX386)\"></a>扩展线性地址记录 (HEX386)</h5><p>扩展线性地址记录也称为 32 位地址记录和 HEX386 记录。这些记录包含数据地址的高 16 位（位 16-31）。扩展线性地址记录总是有两个数据字节，如下所示：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">:02000004FFFFFC<br></code></pre></td></tr></table></figure>\n\n<p>在哪里：</p>\n<ul>\n<li><strong>02</strong>是记录中的数据字节数。</li>\n<li><strong>0000</strong>是地址字段。对于扩展线性地址记录，此字段始终为 0000。</li>\n<li><strong>04</strong>是记录类型 04（扩展的线性地址记录）。</li>\n<li><strong>FFFF</strong>是地址的高 16 位。</li>\n<li><strong>FC</strong>是记录的校验和，计算方式为<br>01h + NOT(02h + 00h + 00h + 04h + FFh + FFh)。</li>\n</ul>\n<p>读取扩展线性地址记录时，存储在数据字段中的扩展线性地址将被保存并应用于从 Intel HEX 文件读取的后续记录。线性地址保持有效，直到被另一个扩展地址记录改变。</p>\n<p>数据记录的绝对内存地址是通过将记录中的地址字段与扩展线性地址记录的移位地址数据相加得到的。下面的例子说明了这个过程。</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs haskell\"><span class=\"hljs-type\">Address</span> from the <span class=\"hljs-class\"><span class=\"hljs-keyword\">data</span> record&#x27;s address field      2462</span><br><span class=\"hljs-type\">Extended</span> linear address record <span class=\"hljs-class\"><span class=\"hljs-keyword\">data</span> field     <span class=\"hljs-type\">FFFF</span></span><br>                                              <span class=\"hljs-comment\">--------</span><br><span class=\"hljs-type\">Absolute</span>-memory address                       <span class=\"hljs-type\">FFFF2462</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"扩展段地址记录-HEX86\"><a href=\"#扩展段地址记录-HEX86\" class=\"headerlink\" title=\"扩展段地址记录 (HEX86)\"></a>扩展段地址记录 (HEX86)</h5><p>扩展段地址记录（也称为 HEX86 记录）包含数据地址段的第 4-19 位。扩展段地址记录总是有两个数据字节，如下所示：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">:020000021200EA<br></code></pre></td></tr></table></figure>\n\n<p>在哪里：</p>\n<ul>\n<li><strong>02</strong>是记录中的数据字节数。</li>\n<li><strong>0000</strong>是地址字段。对于扩展段地址记录，该字段始终为 0000。</li>\n<li><strong>02</strong>是记录类型 02（扩展段地址记录）。</li>\n<li><strong>1200</strong>是地址段。</li>\n<li><strong>EA</strong>是记录的校验和，计算方式为<br>01h + NOT(02h + 00h + 00h + 02h + 12h + 00h)。</li>\n</ul>\n<p>当读取扩展段地址记录时，存储在数据字段中的扩展段地址被保存并应用于从 Intel HEX 文件读取的后续记录。段地址保持有效，直到被另一个扩展地址记录改变。</p>\n<p>数据记录的绝对内存地址是通过将记录中的地址字段添加到来自扩展段地址记录的移位地址数据中获得的。以下示例说明了此过程。</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs haskell\"><span class=\"hljs-type\">Address</span> from the <span class=\"hljs-class\"><span class=\"hljs-keyword\">data</span> record&#x27;s address field     2462</span><br><span class=\"hljs-type\">Extended</span> segment address record <span class=\"hljs-class\"><span class=\"hljs-keyword\">data</span> field      1200</span><br>                                             <span class=\"hljs-comment\">--------</span><br><span class=\"hljs-type\">Absolute</span> memory address                      <span class=\"hljs-number\">00014462</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"起始线性地址记录（仅限-MDK-ARM）\"><a href=\"#起始线性地址记录（仅限-MDK-ARM）\" class=\"headerlink\" title=\"起始线性地址记录（仅限 MDK-ARM）\"></a>起始线性地址记录（仅限 MDK-ARM）</h5><p>起始线性地址记录指定应用程序的起始地址。这些记录包含完整的线性 32 位地址。起始线性地址记录总是有四个数据字节，如下所示：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">:04000005000000CD2A<br></code></pre></td></tr></table></figure>\n\n<p>在哪里：</p>\n<ul>\n<li><strong>04</strong>是记录中的数据字节数。</li>\n<li><strong>0000</strong>是地址字段。对于起始线性地址记录，该字段始终为 0000。</li>\n<li><strong>05</strong>是记录类型 05（起始线性地址记录）。</li>\n<li><strong>000000CD</strong>是应用程序的 4 字节线性起始地址。</li>\n<li><strong>2A</strong>是记录的校验和，计算方式为<br>01h + NOT(04h + 00h + 00h + 05h + 00h + 00h + 00h + CDh)。</li>\n</ul>\n<p>Start Linear Address 指定了 __main（pre-main）函数的地址，而不是通常在调用 SystemInit() 之后调用 __main 的启动代码的地址。奇数线性起始地址指定 __main 是为 Thumb 指令集编译的。</p>\n<p>起始线性地址记录可以出现在 hex 文件中的任何位置。在大多数情况下，可以忽略此记录，因为它不包含对闪存进行编程所需的信息。</p>\n<h5 id=\"文件结束-EOF-记录\"><a href=\"#文件结束-EOF-记录\" class=\"headerlink\" title=\"文件结束 (EOF) 记录\"></a>文件结束 (EOF) 记录</h5><p>英特尔 HEX 文件必须以文件结束 (EOF) 记录结尾。此记录在记录类型字段中必须具有值 01。EOF 记录始终如下所示：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">:00000001FF<br></code></pre></td></tr></table></figure>\n\n<p>在哪里：</p>\n<ul>\n<li><strong>00</strong>是记录中的数据字节数。</li>\n<li><strong>0000</strong>是数据在内存中的位置。文件尾记录中的地址是无意义的并且被忽略。地址 0000h 是典型的。</li>\n<li><strong>01</strong>是记录类型 01（文件结束记录）。</li>\n<li><strong>FF</strong>是记录的校验和，计算方式为<br>01h + NOT(00h + 00h + 00h + 01h)。</li>\n</ul>\n<h2 id=\"tip\"><a href=\"#tip\" class=\"headerlink\" title=\"tip\"></a>tip</h2><ul>\n<li><strong>用Notepad++打开hex文件，会自动上色、换行</strong></li>\n</ul>\n",
            "tags": [
                "hex"
            ]
        }
    ]
}
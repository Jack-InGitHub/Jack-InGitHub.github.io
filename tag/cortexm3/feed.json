{
    "version": "https://jsonfeed.org/version/1",
    "title": "Oikiou's Blog • All posts by \"cortexm3\" tag",
    "description": "Blog",
    "home_page_url": "https://www.oikiou.top",
    "items": [
        {
            "id": "https://www.oikiou.top/2023/880e7a30/",
            "url": "https://www.oikiou.top/2023/880e7a30/",
            "title": "常见MCU上电初始化逻辑 以STM32F1 CortexM3 为例",
            "date_published": "2023-06-20T11:23:05.000Z",
            "content_html": "<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>每一款芯片是如何启动的都值得去研究，只有明白了它是怎么样启动的，你才能知道为什么你的程序可以运行？程序是从哪里运行来的？运行你写的函数之前执行了哪些操作？</p>\n<p>也只有这样你才有对全局的掌控，才能对代码了然于心，提高你解决复杂问题的能力。</p>\n<blockquote>\n<p>  有一次踩坑，某MCU的BSS段未在<code>main</code>运行之前初始化导致程序运行异常，也是跟这个启动流程有关。</p>\n</blockquote>\n<p>通过了解启动文件，我们可以体会到处理器的架构、指令集、中断向量安排等内容，是非常值得玩味的。</p>\n<h1 id=\"进入正题\"><a href=\"#进入正题\" class=\"headerlink\" title=\"进入正题\"></a>进入正题</h1><h2 id=\"STM32-上电后做了什么\"><a href=\"#STM32-上电后做了什么\" class=\"headerlink\" title=\"STM32 上电后做了什么\"></a>STM32 上电后做了什么</h2><h3 id=\"图解启动流程\"><a href=\"#图解启动流程\" class=\"headerlink\" title=\"图解启动流程\"></a>图解启动流程</h3><p><img src=\"/2023/880e7a30/STM32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.svg\" alt=\"STM32启动流程\"></p>\n<p><img src=\"/2023/880e7a30/215103893_3_20210208091156505-16901903555945.png\" alt=\"215103893_3_20210208091156505\"></p>\n<h3 id=\"文字详细解读启动流程\"><a href=\"#文字详细解读启动流程\" class=\"headerlink\" title=\"文字详细解读启动流程\"></a>文字详细解读启动流程</h3><p><strong>启动过程概览</strong></p>\n<blockquote>\n<p>  1、初始化堆栈指针 SP&#x3D;_initial_sp</p>\n<p>  2、初始化PC指针&#x3D;Reset_Handler</p>\n<p>  3、初始化中断向量表</p>\n<p>  4、配置系统时钟</p>\n<p>  5、调用C 库函数<code>_main</code>初始化用户堆栈、.bss段、.data段，从而最终调用main 函数去到C 的世界</p>\n</blockquote>\n<p>而Cortex-M3内核规定，起始地址必须存放堆顶指针，而第二个地址则必须存放复位中断入口向量地址，这样在Cortex-M3内核复位后，会自动从起始地址的下一个32位空间取出复位中断入口向量，跳转执行复位中断服务程序。</p>\n<p><strong>启动过程涉及的代码</strong></p>\n<blockquote>\n<p>  启动过程涉及的文件不仅包含startup_stm32f10x_hd.s，还涉及到了MDK自带的连接库文件entry.o、entry2.o、entry5.o、entry7.o等（从生成的map文件可以看出来）</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs asm\">Stack_Size      EQU     0x00000400<br><br>                AREA    STACK, NOINIT, READWRITE, ALIGN=3<br>Stack_Mem       SPACE   Stack_Size<br>__initial_sp<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>  开辟栈的大小为0X00000400（1KB），名字为STACK，NOINIT 即不初始化，可读可写，8（2^3）字节对齐。</p>\n<p>  栈的作用是用于局部变量，函数调用，函数形参等的开销，栈的大小不能超过内部SRAM 的大小。如果编写的程序比较大，定义的局部变量很多，那么就需要修改栈的大小。如果某一天，你写的程序出现了莫名奇怪的错误，并进入了 hardfault 的时候，这时你就要考虑下是不是栈不够大，溢出了。</p>\n<p>  <strong>EQU</strong>：宏定义的伪指令，相当于等于，类似与C 中的define。</p>\n<p>  <strong>AREA</strong>：告诉汇编器汇编一个新的代码段或者数据段。STACK 表示段名，这个可以任意命名；NOINIT 表示不初始化；READWRITE 表示可读可写，ALIGN&#x3D;3，表示按照2^3对齐，即8 字节对齐。</p>\n<p>  <strong>SPACE</strong>：用于分配一定大小的内存空间，单位为字节。这里指定大小等于Stack_Size。标号<code>__initial_sp</code> 紧挨着SPACE 语句放置，表示栈的结束地址，即栈顶地址，栈是由<strong>高向低生长</strong>的。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs asm\">; &lt;h&gt; Heap Configuration<br>;   &lt;o&gt;  Heap Size (in Bytes) &lt;0x0-0xFFFFFFFF:8&gt;<br>; &lt;/h&gt;<br><br>Heap_Size       EQU     0x00000200<br><br>                AREA    HEAP, NOINIT, READWRITE, ALIGN=3<br>__heap_base<br>Heap_Mem        SPACE   Heap_Size<br>__heap_limit<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>  开辟堆的大小为0X00000200（512 字节），名字为HEAP，NOINIT 即不初始化，可读可写，8（2^3）字节对齐。<code>__heap_base</code> 表示对的起始地址，<code>__heap_limit</code> 表示堆的结束地址。堆是由<strong>低向高生长</strong>的，跟栈的生长方向相反。</p>\n<p>  堆主要用来动态内存的分配，像malloc()函数申请的内存就在堆上面。这个在STM32里面用的比较少。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs asm\">; Vector Table Mapped to Address 0 at Reset<br>                AREA    RESET, DATA, READONLY\t\t\t; 定义一个数据段，名字为RESET， 可读。并声明 __Vectors 、__Vectors_End 和__Vectors_Size 这三个标号具有全局属性，可供外部的文件调用。<br>                EXPORT  __Vectors<br>                EXPORT  __Vectors_End<br>                EXPORT  __Vectors_Size<br>    <br>__Vectors       DCD     __initial_sp                    ; Top of Stack  栈顶位置，第一个表项是栈顶地址;该处物理地址值即为 __Vetors 标号所表示的值;该地址中存储__initial_sp所表示的地址值，<br>                DCD     Reset_Handler                   ; Reset Handler 复位程序地址<br>                DCD     NMI_Handler                     ; NMI Handler<br>...<br>__Vectors_End<br><br>__Vectors_Size  EQU  __Vectors_End - __Vectors<br><br>                AREA    |.text|, CODE, READONLY<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>  定义一个数据段，名字为RESET， 可读。并声明 __Vectors 、__Vectors_End 和__Vectors_Size 这三个标号具有全局属性，可供外部的文件调用。</p>\n<p>  <strong>EXPORT</strong>：声明一个标号可被外部的文件使用，使标号具有全局属性。如果是IAR 编译器，则使用的是GLOBAL 这个指令。</p>\n<p>  <code>__Vectors</code> 为向量表起始地址，<code>__Vectors_End</code> 为向量表结束地址，两个相减即可算出向量表大小，也就是<code>__Vectors_Size</code>。</p>\n<p>  向量表从FLASH 的0 地址开始放置，以4 个字节为一个单位，地址0 存放的是栈顶地址，0X04 存放的是复位程序的地址，以此类推。从代码上看，向量表中存放的都是中断服务函数的函数名，可我们知道C 语言中的函数名就是一个地址。</p>\n<p>  <strong>DCD</strong>：分配一个或者多个以字为单位的内存，以四字节对齐，并要求初始化这些内存。在向量表中，DCD 分配了一堆内存，并且以ESR 的入口地址初始化它们。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs asm\">; 这里调用 SystemInit 初始化时钟 时钟初始化完成后跳转到main函数<br>; Reset handler<br>Reset_Handler    PROC<br>                 EXPORT  Reset_Handler             [WEAK]<br>     IMPORT  __main<br>     IMPORT  SystemInit<br>                 LDR     R0, =SystemInit<br>                 BLX     R0<br>                 LDR     R0, =__main<br>                 BX      R0<br>                 ENDP<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>  复位子程序是系统上电后第一个执行的程序，调用SystemInit 函数初始化系统时钟，然后调用C 库函数<code>_mian</code>，最终调用main 函数去到C 的世界。</p>\n<p>  <strong>WEAK</strong>：表示弱定义，如果外部文件优先定义了该标号则首先引用该标号，如果外部文件没有声明也不会出错。这里表示复位子程序可以由用户在其他文件重新实现，这里并不是唯一的。</p>\n<p>  <strong>IMPORT</strong>：表示该标号来自外部文件，跟C 语言中的EXTERN 关键字类似。这里表示<code>SystemInit</code>和<code>__main</code> 这两个函数均来自外部的文件。</p>\n<p>  <code>SystemInit()</code>是一个标准的库函数，在<code>system_stm32f10x.c</code>这个库文件定义。主要作用是配置系统时钟，这里调用这个函数之后，单片机的系统时钟配被配置为72M。</p>\n<p>  <code>__main</code> 是一个标准的C 库函数，主要作用是初始化用户堆栈，并在函数的最后调用main 函数去到C 的世界。这就是为什么我们写的程序都有一个main 函数的原因。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs asm\">;*******************************************************************************<br>; User Stack and Heap initialization<br>;*******************************************************************************<br>                 IF      :DEF:__MICROLIB           <br>                <br>                 EXPORT  __initial_sp<br>                 EXPORT  __heap_base<br>                 EXPORT  __heap_limit<br>                <br>                 ELSE<br>                <br>                 IMPORT  __use_two_region_memory    ;定义全局标号__use_two_region_memory<br>                 EXPORT  __user_initial_stackheap   ;声明全局标号__user_initial_stackheap，这样外部程序也可调用此标号，进行堆栈和堆的赋值，在__main函数执行过程中调用<br>                 <br>__user_initial_stackheap                            ;标号__user_initial_stackheap，表示用户堆栈初始化程序入口<br><br>                 LDR     R0, =  Heap_Mem            ;保存堆始地址<br>                 LDR     R1, =(Stack_Mem + Stack_Size);保存栈的大小<br>                 LDR     R2, = (Heap_Mem +  Heap_Size);保存堆的大小<br>                 LDR     R3, = Stack_Mem            ;保存栈顶指针<br>                 BX      LR<br><br>                 ALIGN<br><br>                 ENDIF<br><br>                 END<br><br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>  首先判断是否定义了<code>__MICROLIB </code>，如果定义了这个宏则赋予标号<code>__initial_sp</code>（栈顶地址）、<code>__heap_base</code>（堆起始地址）、<code>__heap_limit</code>（堆结束地址）全局属性，可供外部文件调用。有关这个宏我们在KEIL 里面配置，具体见下图 。然后堆栈的初始化就由C 库函数<code>_main</code> 来完成。</p>\n<p>  <img src=\"/2023/880e7a30/v2-e38d0eae51917b604ec87c9e767a7049_720w.webp\" alt=\"img\"></p>\n<p>  如果没有定义<code>__MICROLIB</code> ， 则采用双段存储器模式， 且声明标号<code>__user_initial_stackheap</code> 具有全局属性，让用户自己来初始化堆栈。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">// 初始化嵌入式闪存接口、PLL并更新系统核心时钟变量。</span><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">  * @brief  Setup the microcontroller system</span><br><span class=\"hljs-comment\">  *         Initialize the Embedded Flash Interface, the PLL and update the </span><br><span class=\"hljs-comment\">  *         SystemCoreClock variable.</span><br><span class=\"hljs-comment\">  * @note   This function should be used only after reset.</span><br><span class=\"hljs-comment\">  * @param  None</span><br><span class=\"hljs-comment\">  * @retval None</span><br><span class=\"hljs-comment\">  */</span><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">SystemInit</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">if</span> defined(STM32F100xE) || defined(STM32F101xE) || defined(STM32F101xG) || defined(STM32F103xE) || defined(STM32F103xG)</span><br>  <span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> DATA_IN_ExtSRAM</span><br>    SystemInit_ExtMemCtl(); <br>  <span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span> <span class=\"hljs-comment\">/* DATA_IN_ExtSRAM */</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span> </span><br><br>  <span class=\"hljs-comment\">/* Configure the Vector Table location -------------------------------------*/</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">if</span> defined(USER_VECT_TAB_ADDRESS)</span><br>  SCB-&gt;VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; <span class=\"hljs-comment\">/* Vector Table Relocation in Internal SRAM. */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span> <span class=\"hljs-comment\">/* USER_VECT_TAB_ADDRESS */</span></span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"main-做了什么\"><a href=\"#main-做了什么\" class=\"headerlink\" title=\"__main() 做了什么\"></a><code>__main()</code> 做了什么</h3><p><a href=\"https://developer.arm.com/documentation/dui0808/c/chr1358938922456\">参考ARM文档</a></p>\n<blockquote>\n<p>  The entry point of a program is at __main in the C library where library code:</p>\n<ol>\n<li>Copies non-root (RO and RW) execution regions from their load addresses to their execution addresses. Also, if any data sections are compressed, they are decompressed from the load address to the execution address.</li>\n<li>Zeroes ZI regions.</li>\n<li>Branches to <code>__rt_entry</code>.</li>\n</ol>\n</blockquote>\n<p>程序的入口点位于 C 库中的 __main，其中库代码：</p>\n<ol>\n<li>将 non-root（RO 和 RW）从其加载地址复制到其执行地址。此外，如果任何数据部分被压缩，它们将从加载地址解压缩到执行地址。</li>\n<li>将 ZI 区域归零。</li>\n<li>跳转到 <code>__rt_entry</code>。</li>\n</ol>\n<blockquote>\n<p>  The library function <code>__rt_entry()</code> runs the program as follows:</p>\n<ol>\n<li><p>Sets up the stack and the heap by one of a number of means that include calling <code>__user_setup_stackheap()</code>, calling <code>__rt_stackheap_init()</code>, or loading the absolute addresses of scatter-loaded regions.</p>\n</li>\n<li><p>Calls <code>__rt_lib_init()</code> to initialize referenced library functions, initialize the locale and, if necessary, set up argc and argv for <code>main()</code>.</p>\n<p>For C++, calls the constructors for any top-level objects by way of <code>__cpp_initialize__aeabi_</code>.</p>\n</li>\n<li><p>Calls <code>main()</code>, the user-level root of the application.</p>\n<p>From <code>main()</code>, your program might call, among other things, library functions.</p>\n</li>\n<li><p>Calls <code>exit()</code> with the value returned by <code>main()</code>.</p>\n</li>\n</ol>\n</blockquote>\n<p>库函数<code>__rt_entry()</code>运行程序如下：</p>\n<ol>\n<li><p>通过多种方式中的一种设置堆栈和堆，包括调用<code>__user_setup_stackheap()</code>、调用<code>__rt_stackheap_init()</code>或加载scatter-loaded  区域的绝对地址。</p>\n</li>\n<li><p>调用<code>__rt_lib_init()</code>初始化引用的库函数、初始化区域设置，并在必要时为<code>main()</code>设置<code>argv</code>和<code>argc</code>参数。</p>\n<p>对于 C++，通过 <code>__cpp_initialize__aeabi_</code> 调用任何top-level对象的构造函数。</p>\n</li>\n<li><p>调用<code>main()</code>，应用程序的 user-level 级别的起始。</p>\n<p>在<code>main()</code>中，您的程序可能会调用库函数等。</p>\n</li>\n<li><p>根据<code>main()</code>的返回值调用<code>exit()</code>。</p>\n</li>\n</ol>\n<h3 id=\"一些参考\"><a href=\"#一些参考\" class=\"headerlink\" title=\"一些参考\"></a>一些参考</h3><blockquote>\n<p>  STM32启动过程–启动文件–分析：<a href=\"https://www.cnblogs.com/dreamboy2000/p/15806645.html\">https://www.cnblogs.com/dreamboy2000/p/15806645.html</a></p>\n<p>  ARM编译器指南 执行环境的初始化和应用程序的执行：<a href=\"https://developer.arm.com/documentation/dui0808/c/chr1358938922456\">https://developer.arm.com/documentation/dui0808/c/chr1358938922456</a></p>\n</blockquote>\n",
            "tags": [
                "embedded",
                "stm32",
                "cortexm3"
            ]
        }
    ]
}
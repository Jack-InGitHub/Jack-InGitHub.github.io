{
    "version": "https://jsonfeed.org/version/1",
    "title": "Oikiou's Blog • All posts by \"flash\" tag",
    "description": "Blog",
    "home_page_url": "https://www.oikiou.top",
    "items": [
        {
            "id": "https://www.oikiou.top/2024/4ce716c0/",
            "url": "https://www.oikiou.top/2024/4ce716c0/",
            "title": "Flash磨损均衡",
            "date_published": "2024-06-04T14:57:15.000Z",
            "content_html": "<h1 id=\"Flash磨损均衡\"><a href=\"#Flash磨损均衡\" class=\"headerlink\" title=\"Flash磨损均衡\"></a>Flash磨损均衡</h1><h1 id=\"flash-原理和部分名称\"><a href=\"#flash-原理和部分名称\" class=\"headerlink\" title=\"flash 原理和部分名称\"></a>flash 原理和部分名称</h1><p><img src=\"/2024/4ce716c0/image-20240604163634862.png\"></p>\n<ul>\n<li><strong>package</strong> 是存储芯片，即带有电连接器的小黑色矩形。</li>\n<li><strong>dies</strong> 每个<code>package</code>包含一个或多个<code>die</code>（例如一个、两个或四个）。<code>die</code> 是可以独立执行命令或报告状态的最小单元。</li>\n<li><strong>planes</strong>每个芯片包含一个或多个<code>planes</code> （通常为一或两个）。每个<code>planes</code>上都可以进行相同的并发操作，但有一些限制。</li>\n<li><strong>blocks</strong> 每个<code>planes</code>包含若干个<code>block</code> ，<code>block</code><strong>是可以擦除的最小单位</strong>。</li>\n<li><strong>pages</strong>每个<code>block</code>包含若干个 <code>page</code>，<code>page</code>是可进行编程（即写入）的最小单位。</li>\n</ul>\n<p><strong>磨损均衡 可实现的 底层原理是（同一个块）一次擦除，多次写入。</strong></p>\n<p>擦除是将任意内容改成0xff，即全1状态。<br>你可以对一个page执行多次写入，但是需要注意的是写入仅能将1改成0，<strong>无法将0改成1</strong>。</p>\n<blockquote>\n<p>EEPROM可以单字节（或者四字节）写，而FLASH只能按整个blocks擦除，另外EEPROM一般有100万次的读写寿命，而FLASH只有10万次；</p>\n</blockquote>\n<h1 id=\"一些简单实现的Demo\"><a href=\"#一些简单实现的Demo\" class=\"headerlink\" title=\"一些简单实现的Demo\"></a>一些简单实现的Demo</h1><p>这些demo只是头脑风暴的一些实现，仅仅是一个思路，具体实现还需要完善很多的细节。</p>\n<p><a href=\"Flash%E7%A3%A8%E6%8D%9F%E5%9D%87%E8%A1%A1.assets/flash%E7%9A%84%E7%A3%A8%E6%8D%9F%E5%9D%87%E8%A1%A1.drawio\">draw.io 源文件</a></p>\n<h2 id=\"数据长度固定\"><a href=\"#数据长度固定\" class=\"headerlink\" title=\"数据长度固定\"></a>数据长度固定</h2><p>数据长度固定，使用bitmap记录数据状态。</p>\n<p><img src=\"/2024/4ce716c0/image-20240604162704326.png\"></p>\n<p><img src=\"/2024/4ce716c0/image-20240604175346112.png\"><br><img src=\"/2024/4ce716c0/image-20240604175403042.png\"></p>\n<h2 id=\"数据长度可变\"><a href=\"#数据长度可变\" class=\"headerlink\" title=\"数据长度可变\"></a>数据长度可变</h2><p><img src=\"/2024/4ce716c0/image-20240604181628435.png\"></p>\n<h1 id=\"一些高性能的磨损均衡算法-SSD-Wear-Leveling\"><a href=\"#一些高性能的磨损均衡算法-SSD-Wear-Leveling\" class=\"headerlink\" title=\"一些高性能的磨损均衡算法 SSD Wear Leveling\"></a>一些高性能的磨损均衡算法 SSD Wear Leveling</h1><p>Flash采取<strong>异地更新</strong>的策略 ,更新的数据会被放到别的物理页上,而不是覆盖原来的数据。包含新版本数据的页被称为<strong>有效页</strong>,新版本数据被称为<strong>有效数据</strong>。包含旧版本数据的页被称为<strong>无效页</strong>，或称为脏页，脏页经过擦除操作后成为空闲页，才可以重新写入数据。因为Flash是<strong>以块为单位执行擦除</strong>的，因此需要将脏页所在块上的所有物理页都擦除，在擦除之前需要检查此块上是否存在有效页，如果存在就必须先转移到其他块上。因为每个Flash块的擦除次数有限，一般是在10 万次到100万次之间，只要有块的擦除次数达到了上限，Flash数据存储的性能将下降。所以必须想办法，使<strong>擦除操作平均作用在每个Flash块上</strong>，这种方法就是磨损均衡(wear-leveling)算法。</p>\n<p>我们在应用Flash时，实际上访问的是Flash的逻辑地址，在逻辑地址和物理地址之间，存在着映射关系。数据更新后只需改变映射表中物理页的地址，并将原版本数据所在的物理页标为无效。对于经常被更新的数据块，我们称之为<strong>“热”数据块</strong>，对长期得不到更新的数据块，称之为<strong>“冷”数据块</strong>。数据块经常更新的话，就会经常被擦除，而长期不更行的数据块，不会出现脏页而被擦除，其擦除次数会明显少于存放着经常被更新数据的块。如何实现“冷热”数据存放位置的交换是磨损均衡处理中需要考虑的问题。</p>\n<p>目前常用的磨损均衡算法大致分为两类，一类是随机性算法，一类是确定性算法。</p>\n<ul>\n<li>对于随机性算法，其原理为：在每次写或擦除操作后，按照某一概率来触发磨损均衡处理。按照均匀分布的概率，<strong>随机选择某个块执行擦除操作</strong>。不论块上放的是“冷”数据还是“热”数据,让每个块得到相等的擦除机会。最后将选中块上的有效数据复制到空块后擦除此块。将数据移动到哪个空闲块上,也是随机选择,因为没有记录块的擦除情况,存在将“冷”数据又移动到一个“冷”块上的情况,结果此块并没有增加擦除次数, 这种情况尤其会发生在有大量“冷”数据的系统里。</li>\n<li>对于确定性算法，又分为周期性和全局性两种，其中<strong>周期性算法</strong>的原理为：将Flash的寿命看做是一个接一个的磨损均衡周期组成的。在一个处理周期中，达到规定的擦除次数的块在这一轮周期中将不会被选中，这样可使各个块都达到相同的擦除次数，再开始下一个擦除周期。通过调整Flash块的规定擦除次数，可以使整个Flash能够达到理想的磨损均衡。<strong>全局性算法</strong>的原理为：不划分处理周期，在一个全局范围内控制块的磨损均衡。当任何两个块的擦除次数之差超过一个给定的阈值时，或者当某块的擦除次数超过了所有块的平均擦除次数时，启动磨损均衡处理，将擦除次数少的块上的数据和擦除次数多的块上的数据进行交换。如果块上存放的是“冷”数据，即数据很少被更新，则该块上的数据不易变脏，很少得到擦除的机会。相反，如果该块上存放的是“热”数据，则该块上的数据经常被更新，经常得到擦除脏数据的机会。根据这个原理来交换“冷热”数据，从而实现磨损均衡。</li>\n</ul>\n<p>对比两类磨损均衡算法，可以看出：随机性算法的效果受随机因素影响较大，在擦除前，并不知道各个块被擦除的情况，同时对逻辑页的随机性请求并不能做到完全等概率，所以虽然随机性算法是等概率地选择处理页，但每个块的擦除次数并不能达到等概率分布，不能达到很好的磨损均衡效果。确定性算法因记录了物理块的擦除次数，故在处理中可根据这些信息来作出调整决策，各块基本达到了相近的擦除次数，磨损均衡的效果明显好于随机性算法。但这是在消耗大量内存开销的基础上实现的。</p>\n<p>根据以上讨论的情况，可以看出，必须结合两类算法的优势，来实现效果较好的磨损均衡处理，才能既保证Flash的读写速度，又能保证Flash的使用寿命，这将是决定固态存储能否全面战胜机械硬盘的关键之战。</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p>Understanding Flash: Blocks, Pages and Program &#x2F; Erases<br><a href=\"https://flashdba.com/2014/06/20/understanding-flash-blocks-pages-and-program-erases/\">https://flashdba.com/2014/06/20/understanding-flash-blocks-pages-and-program-erases/</a><br>Flash存储器磨损均衡原理及实现<br><a href=\"https://blog.csdn.net/csdliqi/article/details/80361163\">https://blog.csdn.net/csdliqi/article/details/80361163</a><br>深入解析SSD Wear Leveling磨损均衡技术：如何让你的硬盘更长寿？<br><a href=\"https://blog.csdn.net/zhuzongpeng/article/details/134520307\">https://blog.csdn.net/zhuzongpeng/article/details/134520307</a></p>\n",
            "tags": [
                "flash"
            ]
        },
        {
            "id": "https://www.oikiou.top/2022/fd90dc4c/",
            "url": "https://www.oikiou.top/2022/fd90dc4c/",
            "title": "使用Jlink 烧写SPI Flash存储芯片",
            "date_published": "2022-08-26T15:23:05.000Z",
            "content_html": "<h1 id=\"使用Jlink-烧写SPI-Flash存储芯片\"><a href=\"#使用Jlink-烧写SPI-Flash存储芯片\" class=\"headerlink\" title=\"使用Jlink 烧写SPI Flash存储芯片\"></a>使用Jlink 烧写SPI Flash存储芯片</h1><p>参考:</p>\n<p><a href=\"https://www.segger.com/products/debug-probes/j-link/tools/j-flash-spi/\">https://www.segger.com/products/debug-probes/j-link/tools/j-flash-spi/</a></p>\n<h1 id=\"硬件连接\"><a href=\"#硬件连接\" class=\"headerlink\" title=\"硬件连接\"></a>硬件连接</h1><h2 id=\"SPI-Single\"><a href=\"#SPI-Single\" class=\"headerlink\" title=\"SPI &amp; Single\"></a>SPI &amp; Single</h2><p><img src=\"/2022/fd90dc4c/formatpng.png\" alt=\"img\"></p>\n<p><img src=\"/2022/fd90dc4c/pinout-spi-20-pin.gif\" alt=\"引出线 spi 20 针\"></p>\n<h2 id=\"QSPI-Quad\"><a href=\"#QSPI-Quad\" class=\"headerlink\" title=\"QSPI &amp; Quad\"></a>QSPI &amp; Quad</h2><p><img src=\"/2022/fd90dc4c/pinout-qspi-20-pin.png\" alt=\"img\"></p>\n<blockquote>\n<p>  注意:</p>\n<p>  这里要注意的一点，正版的Jlink仿真器1脚是输入引脚，是外部提供参考电平的，但由于现在大部分的JLink仿真器都是学习(dao)版的，1脚不是输入，而是3.3v的输出(并不确定也有可能是5V的, 盗版的Jlink真的是什么乱七八糟的都有)，所以正常情况下可以直接用这个管教来给SPI Flash供电。</p>\n<p>  <strong>关于 nRESET 的注意事项</strong>：如果有另一个设备&#x2F;外围设备也控制 SPI 闪存（例如闪存连接到的 CPU），则 J-Link 的 nRESET 应连接到目标系统的复位或 CPU 的复位引脚确保 J-Link 可以在对 SPI 闪存进行编程时保持 CPU 处于复位状态。</p>\n<p>  <strong>一开始没注意到这个功能, 现在回过头来再看, 有这个功能之后烧芯片简直不要太简单, 根本不需要拆芯片了, 直接用芯片夹就可以烧录了.</strong></p>\n</blockquote>\n<h1 id=\"软件\"><a href=\"#软件\" class=\"headerlink\" title=\"软件\"></a>软件</h1><p>安装Jlink套件的时候会自带<code>JFlashSPI.exe</code>在开始菜单名称应该类似<code>J-Flash SPI</code>, 这是J-Flash的GUI程序,还有一个命令行的不多做介绍.</p>\n<blockquote>\n<p>  如果没有找到自带的, 请更新Jlink套件, 旧版确实不带这个东西.</p>\n<p>  Segger Jlink套件下载链接 <a href=\"https://www.segger.com/downloads/jlink/\">https://www.segger.com/downloads/jlink/</a></p>\n</blockquote>\n<p><img src=\"/2022/fd90dc4c/image-20220826224742256.png\" alt=\"image-20220826224742256\"></p>\n<p>点击<code>target -&gt; connet</code>连接到Jlink, 它会自动检测大部分SPI闪存, </p>\n<blockquote>\n<p>  有时候识别的具体型号并不准确, 但是这不重要他们参数类似, 可以正常完成编程的工作.</p>\n<p>  Jlink支持的SPI Flash型号可以在<a href=\"https://www.segger.com/products/debug-probes/j-link/technology/cpus-and-devices/supported-spi-flashes/\">点击这里</a>找到.</p>\n</blockquote>\n<p>点击<code>file -&gt; open data file </code>我们打开要烧录的文件.</p>\n<blockquote>\n<p>  bin 文件需要设定起始地址</p>\n<p>  hex文件自带了位置信息</p>\n</blockquote>\n<p>点击<code>target -&gt; auto</code>可以自动将文件烧录进去 还会进行读回校验.</p>\n<p>至此烧录完成.</p>\n<p><strong>Tips:</strong></p>\n<blockquote>\n<p>  点击<code>target -&gt; read back</code> 可以将SPI Flash内的数据读取出来<br>  点击<code>options -&gt; settings -&gt; setup -&gt; interface speed</code>可以修改时钟速度. </p>\n</blockquote>\n<p><strong>Other:</strong></p>\n<p>Jlink真的是超级牛的工具, J-Scope, RTT这些都很好用, 还有很多高级功能我还没用上.<br>我前面有写过RTT的笔记, 在调试一个项目的时候没法使用串口, 当时就是用RTT搭建了一个log平台.</p>\n<h1 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h1><h2 id=\"winbood-W25Q128封装\"><a href=\"#winbood-W25Q128封装\" class=\"headerlink\" title=\"winbood W25Q128封装\"></a>winbood W25Q128封装</h2><p><img src=\"/2022/fd90dc4c/image-20220826104542006.png\" alt=\"image-20220826104542006\"></p>\n<p><img src=\"/2022/fd90dc4c/20210622091839750557.png\" alt=\"img\"></p>\n",
            "tags": [
                "flash",
                "spi",
                "j-link",
                "jlink",
                "j-tag"
            ]
        }
    ]
}
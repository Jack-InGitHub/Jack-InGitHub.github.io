{
    "version": "https://jsonfeed.org/version/1",
    "title": "Oikiou's Blog",
    "description": "Blog",
    "home_page_url": "https://www.oikiou.top",
    "items": [
        {
            "id": "https://www.oikiou.top/2023/3c5e47f1/",
            "url": "https://www.oikiou.top/2023/3c5e47f1/",
            "title": "CMake的使用",
            "date_published": "2023-03-30T02:23:15.000Z",
            "content_html": "<h1 id=\"LVGL\"><a href=\"#LVGL\" class=\"headerlink\" title=\"LVGL\"></a>LVGL</h1><p>Github：<a href=\"https://github.com/lvgl/lvgl/\">https://github.com/lvgl/lvgl/</a></p>\n<p>LVGL：<a href=\"https://lvgl.io/\">https://lvgl.io/</a></p>\n<p>LVGL（轻巧多功能图形库）是一个免费的开源图形库，提供创建具有易于使用的图形元素、精美的视觉效果和低内存占用的嵌入式 GUI 所需的一切。</p>\n<h3 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h3><ul>\n<li>丰富且强大的模块化<a href=\"https://docs.lvgl.io/master/widgets/index.html\">图形组件</a>：按钮 (buttons)、图表 (charts)、列表 (lists)、滑动条 (sliders)、图片 (images) 等</li>\n<li>高级的图形引擎：动画、抗锯齿、透明度、平滑滚动、图层混合等效果</li>\n<li>支持多种<a href=\"https://docs.lvgl.io/master/overview/indev.html\">输入设备</a>：触摸屏、 键盘、编码器、按键等</li>\n<li>支持<a href=\"https://docs.lvgl.io/master/overview/display.html\">多显示设备</a></li>\n<li>不依赖特定的硬件平台，可以在任何显示屏上运行</li>\n<li>配置可裁剪（最低资源占用：64 kB Flash，16 kB RAM）</li>\n<li>基于UTF-8的多语种支持，例如中文、日文、韩文、阿拉伯文等</li>\n<li>可以通过<a href=\"https://docs.lvgl.io/master/overview/style.html\">类CSS</a>的方式来设计、布局图形界面（例如：<a href=\"https://docs.lvgl.io/master/layouts/flex.html\">Flexbox</a>、<a href=\"https://docs.lvgl.io/master/layouts/grid.html\">Grid</a>）</li>\n<li>支持操作系统、外置内存、以及硬件加速（LVGL已内建支持STM32 DMA2D、SWM341 DMA2D、NXP PXP和VGLite）</li>\n<li>即便仅有<a href=\"https://docs.lvgl.io/master/porting/display.html\">单缓冲区(frame buffer)</a>的情况下，也可保证渲染如丝般顺滑</li>\n<li>全部由C编写完成，并支持C++调用</li>\n<li>支持Micropython编程，参见：<a href=\"https://blog.lvgl.io/2019-02-20/micropython-bindings\">LVGL API in Micropython</a></li>\n<li>支持<a href=\"https://docs.lvgl.io/master/get-started/platforms/pc-simulator.html\">模拟器</a>仿真，可以无硬件依托进行开发</li>\n<li>丰富详实的<a href=\"https://github.com/lvgl/lvgl/tree/master/examples\">例程</a></li>\n<li>详尽的<a href=\"http://docs.lvgl.io/\">文档</a>以及API参考手册，可线上查阅或可下载为PDF格式</li>\n</ul>\n<h3 id=\"硬件要求\"><a href=\"#硬件要求\" class=\"headerlink\" title=\"硬件要求\"></a>硬件要求</h3><table>\n<thead>\n<tr>\n<th><strong>要求</strong></th>\n<th><strong>最低要求</strong></th>\n<th><strong>建议要求</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>架构</strong></td>\n<td>16、32、64位微控制器或微处理器</td>\n<td></td>\n</tr>\n<tr>\n<td><strong>时钟</strong></td>\n<td>&gt; 16 MHz</td>\n<td>&gt; 48 MHz</td>\n</tr>\n<tr>\n<td><strong>Flash&#x2F;ROM</strong></td>\n<td>&gt; 64 kB</td>\n<td>&gt; 180 kB</td>\n</tr>\n<tr>\n<td><strong>Static RAM</strong></td>\n<td>&gt; 16 kB</td>\n<td>&gt; 48 kB</td>\n</tr>\n<tr>\n<td><strong>Draw buffer</strong></td>\n<td>&gt; 1 × <em>hor. res.</em> pixels</td>\n<td>&gt; 1&#x2F;10屏幕大小</td>\n</tr>\n<tr>\n<td><strong>编译器</strong></td>\n<td>C99或更新</td>\n<td></td>\n</tr>\n</tbody></table>\n<p><em>注意：资源占用情况与具体硬件平台、编译器等因素有关，上表中仅给出参考值</em></p>\n<h1 id=\"如何入门\"><a href=\"#如何入门\" class=\"headerlink\" title=\"如何入门\"></a>如何入门</h1><p>请按照如下顺序来学习LVGL：</p>\n<ol>\n<li>使用<a href=\"https://lvgl.io/demos\">网页在线例程</a>来体验LVGL</li>\n<li>阅读文档<a href=\"https://docs.lvgl.io/master/intro/index.html\">简介</a>章节来初步了解LVGL</li>\n<li>再来阅读一下文档快速<a href=\"https://docs.lvgl.io/master/get-started/quick-overview.html\">快速概览</a>章节来了解LVGL的基本知识</li>\n<li>学习如何使用<a href=\"https://docs.lvgl.io/master/get-started/platforms/pc-simulator.html\">模拟器</a>来在电脑上仿真LVGL</li>\n<li>试着动手实践一些<a href=\"https://github.com/lvgl/lvgl/tree/master/examples\">例程</a></li>\n<li>参考<a href=\"https://docs.lvgl.io/master/porting/index.html\">移植指南</a>尝试将LVGL移植到一块开发板上，LVGL也已经提供了一些移植好的<a href=\"https://github.com/lvgl?q=lv_port_\">工程</a></li>\n<li>仔细阅读文档<a href=\"https://docs.lvgl.io/master/overview/index.html\">总览</a>章节来更加深入的了解和熟悉LVGL</li>\n<li>浏览文档<a href=\"https://docs.lvgl.io/master/widgets/index.html\">组件(Widgets)</a>章节来了解如何使用它们</li>\n<li>如果你有问题可以到LVGL<a href=\"http://forum.lvgl.io/\">论坛</a>提问</li>\n<li>阅读文档<a href=\"https://docs.lvgl.io/master/CONTRIBUTING.html\">如何向社区贡献</a>章节来看看你能帮LVGL社区做些什么，以促进LVGL软件质量的不断提高</li>\n</ol>\n<h1 id=\"模拟器入门\"><a href=\"#模拟器入门\" class=\"headerlink\" title=\"模拟器入门\"></a>模拟器入门</h1><p>您可以<strong>仅使用PC试用</strong>LVGL（即没有任何开发板）。LVGL将在PC上的模拟器环境中运行，任何人都可以编写和试验真正的LVGL应用程序。</p>\n<p>在PC上使用模拟器具有以下优点：</p>\n<ul>\n<li>硬件独立 - 编写代码，在PC上运行它，并在显示器上查看结果。</li>\n<li>跨平台 - 任何Windows，Linux或macOS系统都可以运行PC模拟器。</li>\n<li>可移植性 - 编写的代码是可移植的，这意味着您可以在迁移到嵌入式硬件时简单地复制它。</li>\n<li>易于验证 - 模拟器对于报告错误也非常有用，因为它为每个用户提供了一个通用平台。因此，最好在模拟器中重现错误并在<a href=\"https://forum.lvgl.io/\">论坛</a>中使用该代码片段。</li>\n</ul>\n<p><a href=\"https://docs.lvgl.io/master/get-started/platforms/pc-simulator.html\">PC 上的模拟器 — LVGL 文档</a></p>\n",
            "tags": [
                "linux",
                "cmake"
            ]
        },
        {
            "id": "https://www.oikiou.top/2023/3c5e47f1/",
            "url": "https://www.oikiou.top/2023/3c5e47f1/",
            "title": "CMake的使用",
            "date_published": "2023-03-29T13:57:15.000Z",
            "content_html": "<h1 id=\"CMake\"><a href=\"#CMake\" class=\"headerlink\" title=\"CMake\"></a>CMake</h1><p>CMake是开源、跨平台的构建工具，可以让我们通过编写简单的配置文件去生成本地的Makefile，这个配置文件是<strong>独立于运行平台和编译器</strong>的，这样就不用亲自去编写Makefile了，而且配置文件可以直接拿到其它平台上使用，无需修改，非常方便。</p>\n<p><a href=\"https://blog.csdn.net/whahu1989/article/details/82078563\">Linux下CMake简明教程_linux中cmake_爱就是恒久忍耐的博客-CSDN博客</a></p>\n<h1 id=\"CMake-的安装\"><a href=\"#CMake-的安装\" class=\"headerlink\" title=\"CMake 的安装\"></a>CMake 的安装</h1><h2 id=\"Ubuntu下的安装\"><a href=\"#Ubuntu下的安装\" class=\"headerlink\" title=\"Ubuntu下的安装\"></a>Ubuntu下的安装</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">sudo apt-get install cmake</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">cmake --version</span><br>cmake version 3.16.3<br>.....<br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">这样就安装好了</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"CMake语法\"><a href=\"#CMake语法\" class=\"headerlink\" title=\"CMake语法\"></a>CMake语法</h1><h2 id=\"最简单的版本\"><a href=\"#最简单的版本\" class=\"headerlink\" title=\"最简单的版本\"></a>最简单的版本</h2><blockquote>\n<p>  环境：只有一个main.c的<code>hello world</code>文件，没有任何依赖。</p>\n</blockquote>\n<p>在<code>main.c</code>的同级目录下建立一个文件，文件名叫<code>CMakeFileLists.txt</code>，这个文件名不能变更，只能是这个形式。</p>\n<p>文件内容如下：</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-comment\"># cmake的最低版本要求是2.8</span><br><span class=\"hljs-keyword\">cmake_minimum_required</span>(VERSION <span class=\"hljs-number\">2.8</span>)<br><br><span class=\"hljs-comment\"># 工程名</span><br><span class=\"hljs-keyword\">project</span>(download)<br><br><span class=\"hljs-comment\"># 使用main.c这个源文件 生成elf文件 生成的文件名字叫main</span><br><span class=\"hljs-keyword\">add_executable</span>(main, main.c)<br></code></pre></td></tr></table></figure>\n\n<p>我们在当前目录（<code>main.c</code>和<code>CMakeFileLists.txt</code>的目录下）运行<code>cmake .</code>，含义就是在当前目录下执行cmake。执行成功后会生成<code>Makefils</code>以及一些cmake运行时自动生成的文件。</p>\n<p>这个时候我们使用命令<code>make</code>就可以看到正确编译了。</p>\n<h2 id=\"一个目录下的多个源文件\"><a href=\"#一个目录下的多个源文件\" class=\"headerlink\" title=\"一个目录下的多个源文件\"></a>一个目录下的多个源文件</h2><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">cmake_minimum_required</span> (VERSION <span class=\"hljs-number\">2.8</span>)<br><br><span class=\"hljs-keyword\">project</span> (demo)<br><br><span class=\"hljs-comment\"># 当前目录下的源文件存列表存放到变量SRC_LIST里</span><br><span class=\"hljs-keyword\">aux_source_directory</span>(. SRC_LIST)<br><br><span class=\"hljs-comment\"># 在add_executable里调用SRC_LIST（注意调用变量时的写法）</span><br><span class=\"hljs-keyword\">add_executable</span>(main <span class=\"hljs-variable\">$&#123;SRC_LIST&#125;</span>)<br></code></pre></td></tr></table></figure>\n\n<p><code>aux_source_directory()</code>也存在弊端，它<strong>会把指定目录下的所有源文件都加进来</strong>，可能会加入一些我们不需要的文件，此时我们可以使用<strong>set命令</strong>去新建变量来存放需要的源文件</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">cmake_minimum_required</span> (VERSION <span class=\"hljs-number\">2.8</span>)<br><br><span class=\"hljs-keyword\">project</span> (demo)<br><br><span class=\"hljs-comment\"># set 命令设置变量存放源文件</span><br><span class=\"hljs-keyword\">set</span>( SRC_LIST<br>\t ./main.c<br>\t ./testFunc1.c<br>\t ./testFunc.c)<br><br><span class=\"hljs-keyword\">add_executable</span>(main <span class=\"hljs-variable\">$&#123;SRC_LIST&#125;</span>)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"不同目录下的多个源文件\"><a href=\"#不同目录下的多个源文件\" class=\"headerlink\" title=\"不同目录下的多个源文件\"></a>不同目录下的多个源文件</h2><blockquote>\n<p>  文件结构</p>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">./bin<br>./build<br>./include<br>\txx.h<br>\txxx.h<br>./src<br>\txxx.c<br>\txx.c<br></code></pre></td></tr></table></figure>\n</blockquote>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">cmake_minimum_required</span> (VERSION <span class=\"hljs-number\">2.8</span>)<br><br><span class=\"hljs-keyword\">project</span> (demo)<br><br><span class=\"hljs-comment\"># 修改输出位置</span><br><span class=\"hljs-comment\"># EXECUTABLE_OUT_PATH和PROJECT_SOURCE_DIR是CMake自带的预定义变量</span><br><span class=\"hljs-comment\"># EXECUTABLE_OUTPUT_PATH ：目标二进制可执行文件的存放位置</span><br><span class=\"hljs-comment\"># PROJECT_SOURCE_DIR：工程的根目录</span><br><span class=\"hljs-keyword\">set</span> (EXECUTABLE_OUTPUT_PATH <span class=\"hljs-variable\">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)<br><br><span class=\"hljs-comment\"># 当前src目录下的源文件存列表存放到变量SRC_LIST里</span><br><span class=\"hljs-keyword\">aux_source_directory</span> (src SRC_LIST)<br><br><span class=\"hljs-comment\"># 将include文件夹设定为头文件搜索路径</span><br><span class=\"hljs-comment\"># 该命令是用来向工程添加多个指定头文件的搜索路径，路径之间用空格分隔。</span><br><span class=\"hljs-keyword\">include_directories</span> (<span class=\"hljs-keyword\">include</span>)<br><br><span class=\"hljs-comment\"># 生成elf文件</span><br><span class=\"hljs-keyword\">add_executable</span> (main <span class=\"hljs-variable\">$&#123;SRC_LIST&#125;</span>)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"静态库和动态库的编译\"><a href=\"#静态库和动态库的编译\" class=\"headerlink\" title=\"静态库和动态库的编译\"></a>静态库和动态库的编译</h2><p>编译出动态库和静态库，然后等着让其它程序去使用。</p>\n<blockquote>\n<p>  文件结构</p>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">./bin<br>./build<br>./lib<br>./include<br>\txx.h<br>\txxx.h<br>./src<br>\txxx.c<br>\txx.c<br></code></pre></td></tr></table></figure>\n</blockquote>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">cmake_minimum_required</span> (VERSION <span class=\"hljs-number\">3.5</span>)<br><br><span class=\"hljs-keyword\">project</span> (demo)<br><br><span class=\"hljs-keyword\">set</span> (SRC_LIST <span class=\"hljs-variable\">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src/xxx.c)<br><br><span class=\"hljs-comment\"># 生成动态库或静态库</span><br><span class=\"hljs-comment\"># 第1个参数指定库的名字；</span><br><span class=\"hljs-comment\"># 第2个参数决定是动态还是静态，如果没有就默认静态；</span><br><span class=\"hljs-comment\"># 第3个参数指定生成库的源文件</span><br><span class=\"hljs-keyword\">add_library</span> (testFunc_shared SHARED <span class=\"hljs-variable\">$&#123;SRC_LIST&#125;</span>)<br><span class=\"hljs-keyword\">add_library</span> (testFunc_static STATIC <span class=\"hljs-variable\">$&#123;SRC_LIST&#125;</span>)<br><br><span class=\"hljs-comment\"># 设置最终生成的库的名称，还有其它功能，如设置库的版本号等等</span><br><span class=\"hljs-keyword\">set_target_properties</span> (testFunc_shared PROPERTIES OUTPUT_NAME <span class=\"hljs-string\">&quot;testFunc&quot;</span>)<br><span class=\"hljs-keyword\">set_target_properties</span> (testFunc_static PROPERTIES OUTPUT_NAME <span class=\"hljs-string\">&quot;testFunc&quot;</span>)<br><br><span class=\"hljs-keyword\">set</span> (LIBRARY_OUTPUT_PATH <span class=\"hljs-variable\">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"对库进行链接\"><a href=\"#对库进行链接\" class=\"headerlink\" title=\"对库进行链接\"></a>对库进行链接</h2><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">find_library</span>(TESTFUNC_LIB testFunc HINTS <span class=\"hljs-variable\">$&#123;PROJECT_SOURCE_DIR&#125;</span>/testFunc/lib)<br><br><span class=\"hljs-keyword\">target_link_libraries</span> (main <span class=\"hljs-variable\">$&#123;TESTFUNC_LIB&#125;</span>)<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>find_library: 在指定目录下查找指定库，并把<strong>库的绝对路径</strong>存放到变量里，其第一个参数是变量名称，第二个参数是库名称，第三个参数是HINTS，第4个参数是路径，其它用法可以参考cmake文档</li>\n<li>target_link_libraries: 把目标文件与库文件进行链接</li>\n</ul>\n<p>ps：在lib目录下有testFunc的静态库和动态库，find_library(TESTFUNC_LIB testFunc …默认是查找动态库，如果想直接指定使用动态库还是静态库，可以写成find_library(TESTFUNC_LIB libtestFunc.so …或者find_library(TESTFUNC_LIB libtestFunc.a …</p>\n<p>ps： 查看elf文件使用了哪些库，可以使用readelf -d .&#x2F;xx来查看</p>\n<p>之前本节教程使用的是库查找方法是link_directories，但是很多读者反映运行时有问题，本人去官方文档上查了下，发现不建议使用了，推荐使用find_library或者find_package</p>\n<h2 id=\"添加编译选项\"><a href=\"#添加编译选项\" class=\"headerlink\" title=\"添加编译选项\"></a>添加编译选项</h2><p>有时编译程序时想添加一些编译选项，如-Wall，-std&#x3D;c++11等，就可以使用add_compile_options来进行操作。</p>\n<p><code>add_compile_options(-std=c++11 -Wall) </code></p>\n<h2 id=\"更加完善的目录结构及编译选项\"><a href=\"#更加完善的目录结构及编译选项\" class=\"headerlink\" title=\"更加完善的目录结构及编译选项\"></a>更加完善的目录结构及编译选项</h2><blockquote>\n<p>  文件结构</p>\n<p>  构建的时候我们需要先<code>cd build</code>，然后再<code>cmake ..</code>构建，最后<code>make -j8</code>编译即可。</p>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">.<br>├── build<br>├── CMakeLists.txt<br>├── libzip<br>│   ├── ioapi.c<br>│   ├── ioapi.h<br>│   ├── unzip.c<br>│   └── unzip.h<br>├── main<br>│   └── curl_zip.c<br>├── tools<br>    └── log<br>        └── log.h<br></code></pre></td></tr></table></figure>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">cmake_minimum_required(VERSION 3.0)<br>project(curl_zip)<br><br>set(Target down)<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">设置语言标准</span><br>set(CMAKE_C_STANDARD 11)<br>set(CMAKE_CXX_STANDARD 17)<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">为当前路径以及子目录的源文件加入由-D预编译定义</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">add_definitions(-DFOO -DDEBUG ...)</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">设置C++编译参数(CMAKE_CXX_FLAGS是全局变量)</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\"><span class=\"hljs-built_in\">set</span>(CMAKE_CXX_FLAGS <span class=\"hljs-string\">&quot;-Wall std=c++11 -Wextra -fPIC -g&quot;</span>)</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">设置指定的C++编译器版本是必须的，如果不设置，或者为OFF，则指定版本不可用时，会使用上一版本。</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\"><span class=\"hljs-built_in\">set</span>(CMAKE_CXX_STANDARD_REQUIRED ON)</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">设置编译器选项</span><br>add_compile_options(-O3 -Wall) <br><br><br>message(&quot;Target=&quot; $&#123;Target&#125;)<br>message(&quot;---------- Start building ----------&quot;)<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">设置包含路径</span><br>include_directories(    $&#123;PROJECT_SOURCE_DIR&#125;/libzip<br>                        $&#123;PROJECT_SOURCE_DIR&#125;/tools/log<br>)<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">把xxx目录下所有源文件写入变量SRC_LIST</span><br><span class=\"hljs-meta prompt_\">aux_source_directory($</span><span class=\"language-bash\">&#123;PROJECT_SOURCE_DIR&#125;/libzip           SRC_LIST)</span><br><span class=\"hljs-meta prompt_\">aux_source_directory($</span><span class=\"language-bash\">&#123;PROJECT_SOURCE_DIR&#125;/src/curl         SRC_LIST)</span><br><span class=\"hljs-meta prompt_\">aux_source_directory($</span><span class=\"language-bash\">&#123;PROJECT_SOURCE_DIR&#125;/main             SRC_LIST)</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">以SRC_LIST为源文件生成目标文件xxx</span><br><span class=\"hljs-meta prompt_\">add_executable($</span><span class=\"language-bash\">&#123;Target&#125; <span class=\"hljs-variable\">$&#123;SRC_LIST&#125;</span>)</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">创建库文件</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">add_library(&lt;name&gt; [STATIC | SHARED | MODULE] [EXCLUDE_FROM_ALL] source1 source2 ... sourceN)</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">目标文件链接的库</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">target_link_libraries() 总是指明 PRIVATE、PUBLIC 、INTERFACE</span><br>target_link_libraries( $&#123;Target&#125;<br>    pthread<br>    curl<br>    z<br>)<br><br>message(&quot;---------- Stop  building ----------&quot;)<br></code></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
            "tags": [
                "linux",
                "cmake"
            ]
        },
        {
            "id": "https://www.oikiou.top/2023/47a3870e/",
            "url": "https://www.oikiou.top/2023/47a3870e/",
            "title": "Linux 应用编程",
            "date_published": "2023-03-26T08:26:15.000Z",
            "content_html": "<h1 id=\"Linux-Application-Programming\"><a href=\"#Linux-Application-Programming\" class=\"headerlink\" title=\"Linux Application Programming\"></a>Linux Application Programming</h1><h1 id=\"标准IO库-lt-stdio-h-gt\"><a href=\"#标准IO库-lt-stdio-h-gt\" class=\"headerlink\" title=\"标准IO库 &lt;stdio.h&gt;\"></a>标准IO库 &lt;stdio.h&gt;</h1><h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><h3 id=\"strtol-字符串转long-int\"><a href=\"#strtol-字符串转long-int\" class=\"headerlink\" title=\"strtol() 字符串转long int\"></a>strtol() 字符串转long int</h3><p>C 库函数 <code>strtol()</code> 把参数 <strong>str</strong> 所指向的字符串根据给定的 <strong>base</strong> 转换为一个长整数（类型为 long int 型），base 必须介于 2 和 36（包含）之间，或者是特殊值 0。</p>\n<p>strtol() 方法将具有字符串数据类型的值转换为长整数。strtol() 方法跳过字符串开头的所有空白字符，将连续的字符转换为部分的一部分，然后在到达第一个非数字字符时终止。</p>\n<h4 id=\"声明\"><a href=\"#声明\" class=\"headerlink\" title=\"声明\"></a>声明</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">long</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">strtol</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *str, <span class=\"hljs-type\">char</span> **endptr, <span class=\"hljs-type\">int</span> base)</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h4><ul>\n<li><strong>str</strong> – 要转换为长整数的字符串。</li>\n<li><strong>endptr</strong> – 对类型为 char* 的对象的引用，其值由函数设置为 <strong>str</strong> 中数值后的下一个字符。</li>\n<li><strong>base</strong> – 基数，必须介于 2 和 36（包含）之间，或者是特殊值 0。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p>该函数返回转换后的长整数，如果没有执行有效的转换，则返回一个零值。</p>\n<h4 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h4><p>下面的实例演示了 strtol() 函数的用法。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdlib.h&gt;</span></span><br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span><br>&#123;<br>   <span class=\"hljs-type\">char</span> str[<span class=\"hljs-number\">30</span>] = <span class=\"hljs-string\">&quot;2030300 This is test&quot;</span>;<br>   <span class=\"hljs-type\">char</span> *ptr;<br>   <span class=\"hljs-type\">long</span> ret;<br><br>   ret = strtol(str, &amp;ptr, <span class=\"hljs-number\">10</span>);<br>   <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;数字（无符号长整数）是 %ld\\n&quot;</span>, ret);<br>   <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;字符串部分是 |%s|&quot;</span>, ptr);<br><br>   <span class=\"hljs-keyword\">return</span>(<span class=\"hljs-number\">0</span>);<br>&#125;<br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">输出：</span><br><span class=\"hljs-comment\">数字（无符号长整数）是 2030300</span><br><span class=\"hljs-comment\">字符串部分是 | This is test|</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"strtok-用分隔符分解字符串\"><a href=\"#strtok-用分隔符分解字符串\" class=\"headerlink\" title=\"strtok() 用分隔符分解字符串\"></a>strtok() 用分隔符分解字符串</h3><h4 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h4><p>C 库函数 <code>strtok()</code> 分解字符串 <strong>str</strong> 为一组字符串，<strong>delim</strong> 为分隔符。</p>\n<h4 id=\"声明-1\"><a href=\"#声明-1\" class=\"headerlink\" title=\"声明\"></a>声明</h4><p>下面是 strtok() 函数的声明。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">char</span> *<span class=\"hljs-title function_\">strtok</span><span class=\"hljs-params\">(<span class=\"hljs-type\">char</span> *str, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *delim)</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"参数-1\"><a href=\"#参数-1\" class=\"headerlink\" title=\"参数\"></a>参数</h4><ul>\n<li><strong>str</strong> – 要被分解成一组小字符串的字符串。输入NULL则是从上次结束的位置继续查找。</li>\n<li><strong>delim</strong> – 包含分隔符的 C 字符串。</li>\n</ul>\n<h4 id=\"返回值-1\"><a href=\"#返回值-1\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p>该函数返回被分解的第一个子字符串，如果没有可检索的字符串，则返回一个空指针。</p>\n<h4 id=\"实例-1\"><a href=\"#实例-1\" class=\"headerlink\" title=\"实例\"></a>实例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">char</span> str[] = <span class=\"hljs-string\">&quot;8.8.8.8&quot;</span><br><span class=\"hljs-type\">char</span> s[] = <span class=\"hljs-string\">&quot;.&quot;</span> <br><span class=\"hljs-type\">char</span> *token;<br>token = strtok(str, s);<br><span class=\"hljs-keyword\">while</span> (token != <span class=\"hljs-literal\">NULL</span>)<br>&#123;<br>    token = strtok(<span class=\"hljs-literal\">NULL</span>, s);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<p>让我们编译并运行上面的程序，这将产生以下结果：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">This is <br> www<span class=\"hljs-selector-class\">.runoob</span><span class=\"hljs-selector-class\">.com</span> <br> website<br></code></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"文件\"><a href=\"#文件\" class=\"headerlink\" title=\"文件\"></a>文件</h2><h3 id=\"fclose\"><a href=\"#fclose\" class=\"headerlink\" title=\"fclose()\"></a>fclose()</h3><p>关闭流 stream。刷新所有的缓冲区（相当于做了fflush）。</p>\n<h4 id=\"fclose函数的作用\"><a href=\"#fclose函数的作用\" class=\"headerlink\" title=\"fclose函数的作用\"></a><strong>fclose函数的作用</strong></h4><ul>\n<li><p><strong>清空相关的缓冲区</strong></p>\n<p>以写文件为例,程序会先将文本信息存入缓冲区中,然后根据缓冲区刷新指令或者等缓冲区满了以后才向文件写入,那么我们如果不使用fclose()关闭流,就有可能有部分文本信息在缓冲区中没有写入到文本文件中,从而导致文本信息缺失.但是这东西看运气.</p>\n</li>\n<li><p><strong>释放内存</strong></p>\n<p>我们知道,如果我们不手动关闭这个流,系统会维持打开的状态,维持当然需要消耗一定的内存资源,本着苍蝇再小也是块肉的原则当然是要把它关掉了,其实如果有很多流在使用后没有关闭,这部分内存资源也是十分可观的.</p>\n</li>\n</ul>\n<h4 id=\"多次fclose-会发生什么\"><a href=\"#多次fclose-会发生什么\" class=\"headerlink\" title=\"多次fclose()会发生什么\"></a>多次fclose()会发生什么</h4><blockquote>\n<p>  <strong>能不能多次对同一个文件描述符调用fclose？</strong></p>\n<p>  <strong>答案是不行的</strong>。</p>\n<p>  为啥不行，我们需要看看fclose到底干了什么</p>\n<p>  fclose关闭的是一个文件流，当调用fclose时，将会使用户态（C库）缓冲区中的数据刷新到内核区域（或通过socket发送，或者仅仅写回硬盘）。<br>  于此同时，fclose会调用free来释放fp所指向的用户态buffer。</p>\n<p>  因此，如果多次调用fclose，会多次调用free来释放一块已经被释放的区域，而这个动作是危险的。<br>  很多解释是说，因为一旦被释放之后，这块区域就属于未知区域。有可能系统已经把该区域分给了其他进程，所以不能多次fclose。</p>\n<p>  但是我看过Linux关于close的内核源码，发现并不是这样，当第一次调用close时，将会把对应的文件描述符数组flip[fp] &#x3D; NULL。如果再调用close时，会在前面判断该项是否为null，如果为null，return -EINVAL;因此，多次调用fclose时会报错，但不会影响系统其他进程。</p>\n<p>  <a href=\"https://blog.csdn.net/zdavb/article/details/49069803\">来源CSDN</a></p>\n</blockquote>\n<blockquote>\n<p>  *<em>调用fclose之后，FILE <em>fp会变成NULL吗？</em></em></p>\n<p>  不会，没有什么机制把fp置空的动作，只是这个时候fp所指向的区域已经不再有效。</p>\n<p>  <a href=\"https://blog.csdn.net/zdavb/article/details/49069803\">来源CSDN</a></p>\n</blockquote>\n<h3 id=\"fflush\"><a href=\"#fflush\" class=\"headerlink\" title=\"fflush()\"></a>fflush()</h3><p>刷新流 stream 的输出缓冲区，将数据刷新到内核缓冲。</p>\n<h4 id=\"描述-1\"><a href=\"#描述-1\" class=\"headerlink\" title=\"描述\"></a>描述</h4><p>C 库函数 <strong>int fflush(FILE *stream)</strong> 刷新流 stream 的输出缓冲区。</p>\n<h4 id=\"声明-2\"><a href=\"#声明-2\" class=\"headerlink\" title=\"声明\"></a>声明</h4><p>下面是 fflush() 函数的声明。</p>\n<figure class=\"highlight fortran\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs fortran\"><span class=\"hljs-built_in\">int</span> fflush(<span class=\"hljs-keyword\">FILE</span> *stream)<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"参数-2\"><a href=\"#参数-2\" class=\"headerlink\" title=\"参数\"></a>参数</h4><ul>\n<li><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象指定了一个缓冲流。</li>\n</ul>\n<h4 id=\"返回值-2\"><a href=\"#返回值-2\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p>如果成功，该函数返回零值。如果发生错误，则返回 EOF，且设置错误标识符（即 feof）。</p>\n<h3 id=\"fsync\"><a href=\"#fsync\" class=\"headerlink\" title=\"fsync()\"></a>fsync()</h3><p>fsync函数同步内存中所有已修改的文件数据到储存设备。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">// 头文件</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;unistd.h&gt;</span></span><br><br><span class=\"hljs-comment\">// 原型</span><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">fsync</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> fd)</span>;<br><br><span class=\"hljs-comment\">// 参数</span><br>fd 是该进程打开来的文件描述符<br><br><span class=\"hljs-comment\">// 返回值</span><br>函数成功执行时，返回<span class=\"hljs-number\">0</span>。失败返回<span class=\"hljs-number\">-1</span>，errno被设为以下的某个值<br>EBADF：文件描述词无效<br>EIO：读写的过程中发生错误<br>EROFS, EINVAL：文件所在的文件系统不支持同步<br>调用 fsync 可以保证文件的修改时间也被更新。fsync 系统调用可以使您精确的强制每次写入都被更新到磁盘中。您也可以使用同步（synchronous）I/O 操作打开一个文件，这将引起所有写数据都立刻被提交到磁盘中。通过在 open 中指定 O_SYNC 标志启用同步I/O。<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"错误输出\"><a href=\"#错误输出\" class=\"headerlink\" title=\"错误输出\"></a>错误输出</h2><h3 id=\"perror\"><a href=\"#perror\" class=\"headerlink\" title=\"perror()\"></a>perror()</h3><blockquote>\n<p>  errno是一个错误编号，本质上是一个整形的变量，每个错误对应着一个错误编号，当你调用”<strong>某些</strong>“函数出错时，这个函数会更新errno的值。</p>\n<p>  也就是说，并不是所有的函数都会将错误编号输出到errno变量中。</p>\n</blockquote>\n<p><strong>描述</strong></p>\n<p>C 库函数 <strong>void perror(const char *str)</strong> 把一个描述性错误消息输出到标准错误 stderr。首先输出字符串 <strong>str</strong>，后跟一个冒号，然后是一个空格。</p>\n<p><strong>声明</strong></p>\n<p>下面是 perror() 函数的声明。</p>\n<figure class=\"highlight axapta\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs axapta\"><span class=\"hljs-keyword\">void</span> perror(<span class=\"hljs-keyword\">const</span> <span class=\"hljs-built_in\">char</span> *<span class=\"hljs-built_in\">str</span>)<br></code></pre></td></tr></table></figure>\n\n<p><strong>参数</strong></p>\n<ul>\n<li><strong>str</strong> – 这是 C 字符串，包含了一个自定义消息，将显示在原本的错误消息之前。</li>\n</ul>\n<h1 id=\"lt-stdlib-h-gt\"><a href=\"#lt-stdlib-h-gt\" class=\"headerlink\" title=\"&lt;stdlib.h&gt;\"></a>&lt;stdlib.h&gt;</h1><h2 id=\"字符串-1\"><a href=\"#字符串-1\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><h3 id=\"atoi-字符串转int\"><a href=\"#atoi-字符串转int\" class=\"headerlink\" title=\"atoi() 字符串转int\"></a>atoi() 字符串转int</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">atoi</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *str)</span><br></code></pre></td></tr></table></figure>\n\n<p>将字符串参数<strong>str</strong>转换为整数（int 类型）。</p>\n<p>在字符串的开头，atoi() 方法忽略所有空格，转换紧跟在空格之后的单词，然后在遇到第一个非数字单词时停止。atoi() 模块实现了字符串的整数描述。</p>\n<h4 id=\"参数-3\"><a href=\"#参数-3\" class=\"headerlink\" title=\"参数\"></a>参数</h4><ul>\n<li><strong>str</strong> – 这是整数的字符串表示形式。</li>\n</ul>\n<h4 id=\"返回值-3\"><a href=\"#返回值-3\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p>此函数将转换后的整数作为 int 值返回。如果无法执行有效的转换，则返回零。</p>\n<h4 id=\"实例-2\"><a href=\"#实例-2\" class=\"headerlink\" title=\"实例\"></a>实例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">val = atoi(<span class=\"hljs-string\">&quot;123456&quot;</span>);<br></code></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"lt-arpa-x2F-inet-h-gt\"><a href=\"#lt-arpa-x2F-inet-h-gt\" class=\"headerlink\" title=\"&lt;arpa&#x2F;inet.h&gt;\"></a>&lt;arpa&#x2F;inet.h&gt;</h1><h3 id=\"inet-pton\"><a href=\"#inet-pton\" class=\"headerlink\" title=\"inet_pton()\"></a>inet_pton()</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">inet_pton</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> af, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *<span class=\"hljs-keyword\">restrict</span> src , <span class=\"hljs-type\">void</span> *<span class=\"hljs-keyword\">restrict</span> dst )</span>;<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>  函数中的p和n分别代表<strong>表达式(presentation)<strong>和</strong>数值(numeric)</strong></p>\n<p>  这里的表达式一般是指字符串，数值对于IPv4就是uint32</p>\n</blockquote>\n<p><code>inet_pton()</code> 转换网络主机地址表达式(presentation)为二进制数值(numeric)，支持IPv4 to IPv6，线程安全，可重入。</p>\n<h4 id=\"参数-4\"><a href=\"#参数-4\" class=\"headerlink\" title=\"参数\"></a>参数</h4><ul>\n<li><code>af</code> – 仅支持<code>AF_INET</code>或<code>AF_INET6</code>，IPv4 IPv6</li>\n<li><code>src</code> – 表达式(presentation)字符串</li>\n<li><code>dst</code> – 数值(numeric)指针</li>\n</ul>\n<h4 id=\"返回值-4\"><a href=\"#返回值-4\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p>inet_pton () <strong>成功返回1</strong>（网络地址转换成功）。如果src不包含表示指定地址族中有效网络地址的字符串，<strong>则返回 0</strong> 。如果af不包含有效地址族，<strong>则返回 -1</strong> 并将errno设置为EAFNOSUPPORT。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">char</span> ip_str[] = <span class=\"hljs-string\">&quot;8.8.8.8&quot;</span>;<br><span class=\"hljs-type\">uint32_t</span> ip_u32; <br><br>result = inet_pton(AF_INET, ip_str, &amp;ip_u32);<br></code></pre></td></tr></table></figure>\n\n\n<h3 id=\"inet-ntop\"><a href=\"#inet-ntop\" class=\"headerlink\" title=\"inet_ntop()\"></a>inet_ntop()</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *<span class=\"hljs-title function_\">inet_ntop</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> af, </span><br><span class=\"hljs-params\">                      <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">void</span> *<span class=\"hljs-keyword\">restrict</span> src, </span><br><span class=\"hljs-params\">                      <span class=\"hljs-type\">char</span> *<span class=\"hljs-keyword\">restrict</span> dst, </span><br><span class=\"hljs-params\">                      <span class=\"hljs-type\">socklen_t</span> size)</span>;<br></code></pre></td></tr></table></figure>\n\n<p><code>inet_ntop()</code> 函数转换二进制数值(numeric)为网络主机地址表达式(presentation)，支持IPv4 to IPv6，线程安全，可重入。</p>\n<h4 id=\"参数-5\"><a href=\"#参数-5\" class=\"headerlink\" title=\"参数\"></a>参数</h4><ul>\n<li><code>af</code> – 仅支持<code>AF_INET</code>或<code>AF_INET6</code>，IPv4 or IPv6</li>\n<li><code>src</code> – 数值(numeric)指针</li>\n<li><code>dst</code> – 表达式(presentation)字符串</li>\n<li><code>size</code> – 此缓冲区可用字节数</li>\n</ul>\n<h4 id=\"返回值-5\"><a href=\"#返回值-5\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p>成功时，inet_ntop() 返回一个指向 <code>dst</code> 的<strong>非空指针</strong>。如果有错误则返回<code>NULL</code>，errno设置为指示错误。</p>\n<h4 id=\"示例-1\"><a href=\"#示例-1\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">char</span> ip_str[<span class=\"hljs-number\">16</span>];<br><span class=\"hljs-type\">uint32_t</span> ip_u32 = <span class=\"hljs-number\">0x08080808</span>; <br><br>result = inet_ntop(AF_INET, &amp;ip_u32, ip_str, <span class=\"hljs-keyword\">sizeof</span>(ip_str));<br></code></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"Misc\"><a href=\"#Misc\" class=\"headerlink\" title=\"Misc.\"></a>Misc.</h1><h3 id=\"assert-断言\"><a href=\"#assert-断言\" class=\"headerlink\" title=\"assert() 断言\"></a>assert() 断言</h3><p><a href=\"https://so.csdn.net/so/search?q=assert&spm=1001.2101.3001.7020\">assert</a>()是一个调试程序时经常使用的宏，在程序运行时它计算括号内的表达式，如果表达式为FALSE (0), 程序将报告错误，并终止执行。如果表达式不为0，则继续执行后面的语句，它的作用是<strong>终止程序以免导致严重后果，同时也便于查找错误</strong>。</p>\n<p>所需头文件：<code>#include &lt;assert.h&gt;</code></p>\n<p>报告错误的条件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">assert</span><span class=\"hljs-params\">(</span><br><span class=\"hljs-params\">   <span class=\"hljs-type\">int</span> expression</span><br><span class=\"hljs-params\">)</span>;<br></code></pre></td></tr></table></figure>\n\n<p>参数：Expression (including pointers) that evaluates to nonzero or 0.（表达式【包括指针】是非零或零）</p>\n<p>原理：assert的作用是现计算表达式 expression ，如果其值为假（即为0），那么它先向stderr打印一条出错信息，然后通过调用 abort 来终止程序运行。<br>示例程序：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><br><span class=\"hljs-type\">void</span> *<span class=\"hljs-title function_\">memcpy</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span> *pvTo, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">void</span> *pvFrom, <span class=\"hljs-type\">size_t</span> size)</span><br>&#123;<br>\tassert((pvTo != <span class=\"hljs-literal\">NULL</span>) &amp;&amp; (pvFrom != <span class=\"hljs-literal\">NULL</span>));   <span class=\"hljs-comment\">// 使用断言</span><br>\t<span class=\"hljs-comment\">//...</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>总结</strong></p>\n<ul>\n<li><p><strong>在函数开始处检验传入参数的合法性</strong></p>\n</li>\n<li><p><strong>每个assert只检验一个条件,因为同时检验多个条件时,如果断言失败,无法直观的判断是哪个条件失败</strong></p>\n</li>\n<li><p><strong>不能使用改变环境的语句,因为assert只在DEBUG个生效,如果这么做,会使用程序在真正运行时遇到问题</strong></p>\n</li>\n<li><p><strong>assert和后面的语句应空一行,以形成逻辑和视觉上的一致感</strong></p>\n</li>\n<li><p><strong>有的地方,assert不能代替条件过滤</strong></p>\n<p>ASSERT只有在Debug版本中才有效，如果编译为Release版本则被忽略掉。</p>\n</li>\n</ul>\n<p><strong>何时需要使用断言</strong></p>\n<ul>\n<li>可以在预计正常情况下程序不会到达的地方放置断言：ASSERT( FALSE );</li>\n<li>断言可以用于检查传递给私有方法的参数。（对于公有方法，因为是提供给外部的接口，所以必须在方法中有相应的参数检验才能保证代码的健壮性）</li>\n<li>使用断言测试方法执行的前置条件和后置条件</li>\n<li>使用断言检查类的不变状态，确保任何情况下，某个变量的状态必须满足。（如age属性应大于0小于某个合适值）</li>\n</ul>\n<p><strong>什么地方不要使用断言</strong></p>\n<p>断言语句不是永远会执行，可以屏蔽也可以启用</p>\n<ul>\n<li>不要使用断言作为公共方法的参数检查，公共方法的参数合法性永远都要执行</li>\n<li>断言语句不可以有任何边界效应，不要使用断言语句去修改变量和改变方法的返回值</li>\n</ul>\n<h1 id=\"Note\"><a href=\"#Note\" class=\"headerlink\" title=\"Note\"></a>Note</h1><h2 id=\"sync、fsync、fdatasync、fflush对比\"><a href=\"#sync、fsync、fdatasync、fflush对比\" class=\"headerlink\" title=\"sync、fsync、fdatasync、fflush对比\"></a>sync、fsync、fdatasync、fflush对比</h2><blockquote>\n<blockquote>\n<p>  <strong>c库缓冲 —–fflush—–&gt; 内核缓冲 —–fsync—–&gt; 磁盘</strong></p>\n</blockquote>\n<ol>\n<li><p>void sync(void)  函数<strong>只是将所有修改过的块缓冲区排入写队列，然后就返回</strong>，它<strong>并不等待实际写磁盘操作结束</strong>。通常称为update的系统守护进程会周期性地（一般每隔30秒）调用sync函数。这就保证了定期冲洗内核的块缓冲区。命令sync(1)也调用sync函数。</p>\n</li>\n<li><p>int fsync(int fd)  函数是系统提供的系统调用。<strong>只对由文件描述符filedes指定的单一文件起作用，并且等待写磁盘操作结束，然后返回</strong>。fsync可用于数据库这样的应用程序，这种应用程序需要确保将修改过的块立即写到磁盘上。fsync<strong>还会同步更新文件的属性</strong>，即inode部分。</p>\n</li>\n<li><p>int fdatasync(int fd)  函数类似于fsync，但它<strong>只影响文件的数据部分</strong>。它<strong>并不会更新文件的属性</strong>。</p>\n</li>\n<li><p>int fflush(FILE *stream)：标准I&#x2F;O函数（如：fread，fwrite）会在内存建立缓冲，该函数<strong>刷新内存缓冲，将内容写入内核缓冲</strong>，要想将其写入磁盘，还需要调用fsync（先调用fflush后调用fsync，否则不起作用）。fflush接受一个参数<code>FILE *</code>。它还可以刷新标准输入输出。fclose函数在关闭文件之前也会做flush操作</p>\n</li>\n</ol>\n</blockquote>\n<h2 id=\"关于缓冲\"><a href=\"#关于缓冲\" class=\"headerlink\" title=\"关于缓冲.\"></a>关于缓冲.</h2><p>C标准库的I&#x2F;O缓冲区有三种类型:全缓冲、行缓冲和无缓冲。当用户程序调用库函数做写操作时, 不同类型的缓冲区具有不同特性。</p>\n<ul>\n<li><p>全缓冲：如果缓冲区写满了就写回内核。<strong>常规文件通常是全缓冲的。</strong></p>\n</li>\n<li><p>行缓冲：如果用户程序写的数据中有换行符就把这一行写回内核,或者如果缓冲区写满了就写回内核。<strong>标准输入和标准输出对应终端设备时通常是行缓冲的。</strong></p>\n</li>\n<li><p>无缓冲：用户程序每次调库函数做写操作都要通过系统调用写回内核。<strong>标准错误输出通常是无缓冲的</strong>，这样用户程序产生的错误信息可以尽快输出到设备。</p>\n</li>\n</ul>\n<blockquote>\n<p>  虽然write系统调用位于C标准库I&#x2F;O缓冲区的底层，被称为Unbuffered I&#x2F;O函数，但在write的底层也可以分配一个内核I&#x2F;O缓冲区，所以write 也不一定是直接写到文件的，也可能写到内核I&#x2F;O缓冲区中。</p>\n<p>  可以使用fsync函数同步至磁盘文件，至于究竟写到了文件中还是内核缓冲区中对于进程来说是没有差别的，如果进程A和进程B打开同一文件，进程A写到内核I&#x2F;O缓冲区中的数据从进程B也能读到，因为内核空间是进程共享的，而c标准库的I&#x2F;O缓冲区则不具有这一特性，因为进程的用户空间是完全独立的。</p>\n</blockquote>\n",
            "tags": [
                "linux"
            ]
        },
        {
            "id": "https://www.oikiou.top/2023/efa34a49/",
            "url": "https://www.oikiou.top/2023/efa34a49/",
            "title": "speedtest.net 测速",
            "date_published": "2023-03-26T07:39:31.000Z",
            "content_html": "<h1 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h1><h2 id=\"Ubuntu\"><a href=\"#Ubuntu\" class=\"headerlink\" title=\"Ubuntu\"></a>Ubuntu</h2><p>对于以前安装过<code>speedtest-cli</code>版本用户来说，需要先卸载原来的版本</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">sudo apt-get install curl<br>curl -s https://packagecloud.io/install/repositories/ookla/speedtest-cli/script.deb.sh | sudo bash<br>sudo apt-get install speedtest<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"Service-ID-List\"><a href=\"#Service-ID-List\" class=\"headerlink\" title=\"Service ID List\"></a>Service ID List</h1><p><a href=\"https://williamyaps.github.io/wlmjavascript/servercli.html\">Speedtest Server List (williamyaps.github.io)</a></p>\n<blockquote>\n<p>  我们可以在<code>www.speedtest.net</code>可以看到当前所选节点的ID，鼠标停留在当前节点名字上，浏览器会显示这个节点的链接，这个链接最后面的字段<code>id=xxxx</code>就是这个节点的ID。</p>\n</blockquote>\n<p>现在有很多节点已经不能用了，下面的是2023.3.26测试可用的。</p>\n<ul>\n<li>中国电信</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">节点位置</th>\n<th align=\"center\">服务器id</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">上海</td>\n<td align=\"center\">3633</td>\n</tr>\n<tr>\n<td align=\"center\">广东广州5G</td>\n<td align=\"center\">27594</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<ul>\n<li>中国联通</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">节点位置</th>\n<th align=\"center\">服务器id</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">上海</td>\n<td align=\"center\">24447</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<ul>\n<li>中国移动</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">节点位置</th>\n<th align=\"center\">服务器id</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">浙江 杭州 5G</td>\n<td align=\"center\">54312</td>\n</tr>\n<tr>\n<td align=\"center\">北京</td>\n<td align=\"center\">25858</td>\n</tr>\n</tbody></table>\n<ul>\n<li>其他</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>节点位置</th>\n<th>服务器id</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>福州</td>\n<td>56354</td>\n</tr>\n</tbody></table>\n",
            "tags": [
                "speedtest",
                "tools"
            ]
        },
        {
            "id": "https://www.oikiou.top/2023/bb8e62be/",
            "url": "https://www.oikiou.top/2023/bb8e62be/",
            "title": "Linux 应用编程 Zlib Minizip",
            "date_published": "2023-03-25T09:26:15.000Z",
            "content_html": "<h1 id=\"linux-下-zlib-的c语言开发\"><a href=\"#linux-下-zlib-的c语言开发\" class=\"headerlink\" title=\"linux 下 zlib 的c语言开发\"></a>linux 下 zlib 的c语言开发</h1><h1 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">安装库 注意其中名称中是 1g 不是 lg   dev是就Development</span> <br>sudo apt install zlib1g-dev<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">编译需要添加 -lz 参数</span><br>gcc ... -lz<br></code></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><p><a href=\"https://www.zlib.net/zlib_how.html\">zlib Usage Example</a></p>\n",
            "tags": [
                "linuxapp",
                "zlib",
                "minizip"
            ]
        },
        {
            "id": "https://www.oikiou.top/2023/52593829/",
            "url": "https://www.oikiou.top/2023/52593829/",
            "title": "Linux 应用编程 Curl Libcurl",
            "date_published": "2023-03-24T06:26:15.000Z",
            "content_html": "<h1 id=\"linux-下-curl-的c语言开发\"><a href=\"#linux-下-curl-的c语言开发\" class=\"headerlink\" title=\"linux 下 curl 的c语言开发\"></a>linux 下 curl 的c语言开发</h1><h1 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h1><h2 id=\"从源码安装\"><a href=\"#从源码安装\" class=\"headerlink\" title=\"从源码安装\"></a>从源码安装</h2><p>Curl 的官网下载地址：<a href=\"http://curl.haxx.se/download/\">http://curl.haxx.se/download/</a><br>Curl 的使用例子地址： <a href=\"https://curl.haxx.se/libcurl/c/example.html\">https://curl.haxx.se/libcurl/c/example.html</a></p>\n<p>下载、解压好后…..</p>\n<ul>\n<li><p>配置参数</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">./configure<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>编译</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">make<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>安装到系统</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">sudo make install<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>检查安装</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">返回版本信息就是安装成功了</span><br>curl --version<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"从包管理器安装\"><a href=\"#从包管理器安装\" class=\"headerlink\" title=\"从包管理器安装\"></a>从包管理器安装</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">如果出现找不到 curl.h 头文件 就需要安装libcurl</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">成功执行将会在 /user/include/x86_64-linux-gnu/curl 下看到curl.h头文件。</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">CentOS:执行以下命令：</span><br>yum install libcurl-dev libcurl-devel<br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">Ubuntu执行以下命令：</span><br>sudo apt-get install libcurl4-openssl-dev<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">-lcurl 指定链接库</span><br>gcc ... -l curl<br></code></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><p>&#x2F;&#x2F; TODO</p>\n",
            "tags": [
                "linuxapp",
                "curl",
                "libcurl"
            ]
        },
        {
            "id": "https://www.oikiou.top/2023/79891ac1/",
            "url": "https://www.oikiou.top/2023/79891ac1/",
            "title": "License差异对比",
            "date_published": "2023-02-02T06:23:05.000Z",
            "content_html": "<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://spdx.org/licenses/\">SPDX License List</a></p>\n<p>使用 <strong>SPDX 短格式标识符</strong> 以简单、高效、便携和机器可读的方式 传达 FOSS 许可证信息</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-regexp\">//</span> SPDX-License-Identifier: MIT<br><span class=\"hljs-regexp\">/* SPDX-License-Identifier: MIT OR Apache-2.0 */</span><br><span class=\"hljs-comment\"># SPDX-License-Identifier: GPL-2.0-or-later</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"术语\"><a href=\"#术语\" class=\"headerlink\" title=\"术语\"></a>术语</h1><h2 id=\"什么是“分发”？\"><a href=\"#什么是“分发”？\" class=\"headerlink\" title=\"什么是“分发”？\"></a>什么是“分发”？</h2><p>许可证授予的权利，允许你自由使用、修改、复制，但是<strong>在“分发”时就必须遵守许可证的约束</strong>。换言之，如果不”分发”，就不需要遵守。</p>\n<p>分发就是指将版权作品从一个人转移到另一个人。这意味着，如果你是自己使用，不提供给他人，就没有分发。另外，这里的”人”也指”法人”，因此如果使用方是公司，且只在公司内部使用，也不需要遵守许可证[]。</p>\n<p>其中AGPL有个特例：AGPL定义，如果你使用开源软件<strong>提供网络交互服务，那么该行为也定义为“分发”</strong>，即图中的“网络使用即分发”</p>\n<h2 id=\"什么是“传染性”？\"><a href=\"#什么是“传染性”？\" class=\"headerlink\" title=\"什么是“传染性”？\"></a>什么是“传染性”？</h2><p>传染性来源于GPL，GPL的支持者确信自由软件世界应具有自我保护能力和可持续发展性——为了确保自由软件的演绎作品同样“自由”，所以要求只要使用了GPL的代码，那么整个项目都必须以GPL方式公开源代码</p>\n<p>LGPL 在这方面要求就没GPL那么严格，如果只是子系统&#x2F;模块用了，那么只需要子系统&#x2F;模块开源，整个工程不用开源；如果是以动态链接调用LGPL许可证的库，那么项目也不用开源。</p>\n<p>MPL 在这个方面就更宽松，哪个文件用了该许可证的代码，只需要这些文件开源即可，其他文件不受影响</p>\n<p>所以，GPL v2&#x2F;v3、AGPL 属于工程级别的强传染性；LGPL属于库级别的若传染性；MPL 就是文件级别的，传染性可以忽略不计了</p>\n<h2 id=\"GPL-系列的协议有何区别？\"><a href=\"#GPL-系列的协议有何区别？\" class=\"headerlink\" title=\"GPL 系列的协议有何区别？\"></a>GPL 系列的协议有何区别？</h2><p><strong>AGPL 和 GPL 的区别：</strong></p>\n<p>AGPL明确了GPL 2.0&#x2F;3.0关于提供网络服务也属于分发限制的说明：使用GPL的自由软件，但是并不发布与网络之中，则可以自由的使用GPL协议确不开源自己私有的解决方案。AGPL则增加了对此做法的约束。比如使用了AGPL代码的软件是一个网络应用，那么这个软件的所有源码和修改代码也必须开源</p>\n<p><strong>GPL v2 和 GPL v3的主要差异：</strong></p>\n<p>a) GPLv3包含了明确的专利许可</p>\n<p>b) 添加了对数字版权管理和加密签名的限制，不仅要求用户公开源码，还要求公布相关硬件及必要的安装信息。</p>\n<p><strong>GPL 和LGPL的区别：</strong></p>\n<p>主要区别在于传染性方面，GPL是工程级别的强传染，LGPL是库级别的弱传染</p>\n<h2 id=\"违反开源项目许可有何风险？\"><a href=\"#违反开源项目许可有何风险？\" class=\"headerlink\" title=\"违反开源项目许可有何风险？\"></a>违反开源项目许可有何风险？</h2><p>1.被许可人在违反许可证设定的义务时会构成合同违约</p>\n<p>2.开源软件受著作权保护，著作权法著作权法，但是开源许可证本质却是走在了版权保护的对立面，所以其法律效力并没有被明确认可，是否侵权可能需要法院视具体情况而定</p>\n<p>3.在中国，侵权责任和违约责任不能同时主张</p>\n<p>4.在中国，过往的判例都没有涉及开源软件许可证本身</p>\n<p>5.除了面临法律诉讼风险，违反许可证的行为会导致自由软件者和开源社区的排斥，某种程度上会影响违约公司的商业信誉</p>\n<h1 id=\"差异\"><a href=\"#差异\" class=\"headerlink\" title=\"差异\"></a>差异</h1><p><img src=\"/2023/79891ac1/v2-3a460a2dad345fe0c2e0e79b626aacc9_720w.webp\" alt=\"img\"></p>\n",
            "tags": [
                "license"
            ]
        },
        {
            "id": "https://www.oikiou.top/2023/e7fefe87/",
            "url": "https://www.oikiou.top/2023/e7fefe87/",
            "title": "Let’s Encrypt SSL 证书申请",
            "date_published": "2023-01-12T04:08:08.000Z",
            "content_html": "<h1 id=\"Let’s-Encrypt-SSL-证书申请\"><a href=\"#Let’s-Encrypt-SSL-证书申请\" class=\"headerlink\" title=\"Let’s Encrypt SSL 证书申请\"></a>Let’s Encrypt SSL 证书申请</h1><h1 id=\"为什么申请？\"><a href=\"#为什么申请？\" class=\"headerlink\" title=\"为什么申请？\"></a>为什么申请？</h1><blockquote>\n<h2 id=\"HTTP：未实施数据加密\"><a href=\"#HTTP：未实施数据加密\" class=\"headerlink\" title=\"HTTP：未实施数据加密\"></a>HTTP：未实施数据加密</h2><p>  每个以 HTTP 开头的 URL 链接都使用一种基本类型的“超文本传输协议”。由 Tim Berners-Lee 于 1990 年代初创建，当时互联网仍处于起步阶段，该网络协议标准允许 Web 浏览器和服务器通过数据交换进行通信。</p>\n<p>  HTTP 也被称为“无状态系统”，这意味着它可以按需连接。您单击一个链接，请求连接，您的 Web 浏览器将此请求发送到服务器，服务器通过打开页面进行响应。连接越快，数据呈现给您的速度就越快。</p>\n<p>  作为一种“应用层协议”，HTTP 仍然专注于呈现信息，但不太关心这些信息从一个地方传播到另一个地方的方式。不幸的是，这意味着 HTTP 可能会<a href=\"https://www.globalsign.com/en/blog/what-is-a-man-in-the-middle-attack\">被拦截并可能被更改</a>，从而使信息和信息接收者（即您）都容易受到攻击。</p>\n<h2 id=\"HTTPS：加密连接\"><a href=\"#HTTPS：加密连接\" class=\"headerlink\" title=\"HTTPS：加密连接\"></a>HTTPS：加密连接</h2><p>  HTTPS 不是 HTTP 的对立面，而是它的表弟。两者本质上是相同的，因为它们都指的是相同的“超文本传输协议”，该协议使请求的 Web 数据能够显示在您的屏幕上。但是，HTTPS 仍然略有不同，更先进，也更安全。</p>\n<p>  简单的说，HTTPS协议是HTTP的扩展。缩写中的“S”来自 Secure 一词，它由传输层安全性 (TLS) [<a href=\"https://www.globalsign.com/en/ssl-information-center/what-is-ssl/\">安全套接字层 (SSL)</a>的后继者] 提供支持，这是一种在 Web 服务器和服务器之间建立加密连接的标准安全技术。浏览器。</p>\n<p>  如果没有 HTTPS，您输入网站的任何数据（例如您的用户名&#x2F;密码、信用卡或银行详细信息、任何其他表单提交数据等）都将以明文形式发送，因此容易被拦截或窃听。因此，在输入任何信息之前，您应该始终检查站点是否使用 HTTPS。</p>\n<p>  除了加密服务器和您的浏览器之间传输的数据外，TLS 还验证您正在连接的服务器并保护传输的数据不被篡改。</p>\n<p>  这有助于我这样思考——HTTPS 中的 HTTP 相当于一个目的地，而 SSL 相当于一个旅程。第一个负责将数据显示到屏幕上，第二个负责管理数据到达那里的方式。通过联合力量，他们以安全的方式移动数据。  </p>\n<p>  <a href=\"https://www.globalsign.com/en/blog/the-difference-between-http-and-https\">What’s the difference between HTTP and HTTPS?</a></p>\n</blockquote>\n<p>HTTPS 有助于确保网络安全。毫无疑问，它是比 HTTP 更好的网络协议解决方案。</p>\n<p>将网站开启HTTPS的服务是需要SSL的证书的，我们来看一下如何在Let’s Encrypt上申请免费的SSL证书。</p>\n<blockquote>\n<p>  Let’s Encrypt 是免费、开放和自动化的证书颁发机构。由非盈利组织<a href=\"https://www.abetterinternet.org/\">互联网安全研究小组（ISRG）</a>运营。</p>\n</blockquote>\n<h1 id=\"申请的前提条件\"><a href=\"#申请的前提条件\" class=\"headerlink\" title=\"申请的前提条件\"></a>申请的前提条件</h1><p>我们申请SSL证书的前提条件有下面这几个</p>\n<ol>\n<li>拥有域名，能够自主配置DNS。或者提供Web服务器做验证，在网站目录下放一个文件。</li>\n<li>获取证书的环境要能访问DNS服务器，因为会需要做DNS解析校验。</li>\n<li>需要有远程主机的权限，会需要更新和安装组件。</li>\n</ol>\n<h1 id=\"申请步骤\"><a href=\"#申请步骤\" class=\"headerlink\" title=\"申请步骤\"></a>申请步骤</h1><p>Let’s Encrypt 的证书申请除去手动申请常见的主要有下面这几种</p>\n<ul>\n<li><code>acme.sh</code>的方式<em>（我当时选取了这个方式）</em></li>\n<li>docker 镜像获取</li>\n<li><code>certbot</code>方式获取证书<em>（官网建议使用这种方式获取证书，可以在不下线的状态下自动执行证书颁发和安装）</em></li>\n</ul>\n<h2 id=\"acme-sh脚本\"><a href=\"#acme-sh脚本\" class=\"headerlink\" title=\"acme.sh脚本\"></a><code>acme.sh</code>脚本</h2><p><a href=\"https://github.com/acmesh-official/acme.sh\">Github链接：An ACME Shell script: acme.sh</a></p>\n<p>Github的README其实介绍的其实很全面，这里copy一下。</p>\n<blockquote>\n<p>  <strong>acme.sh</strong> 实现了 <code>acme</code> 协议, 可以从 letsencrypt 生成免费的证书.</p>\n<p>  主要步骤:</p>\n<ol>\n<li>安装 <strong>acme.sh</strong></li>\n<li>生成证书</li>\n<li>copy 证书到 nginx&#x2F;apache 或者其他服务</li>\n<li>更新证书</li>\n<li>更新 <strong>acme.sh</strong></li>\n<li>出错怎么办, 如何调试</li>\n</ol>\n<p>  下面详细介绍.</p>\n<h1 id=\"1-安装-acme-sh\"><a href=\"#1-安装-acme-sh\" class=\"headerlink\" title=\"1. 安装 acme.sh\"></a>1. 安装 <strong>acme.sh</strong></h1><p>  安装很简单, 一个命令:</p>\n<blockquote>\n<p>  这里输入你的邮箱，这个邮箱有什么用倒是不太清楚</p>\n</blockquote>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">curl https://get.acme.sh | sh -s email=my@example.com<br></code></pre></td></tr></table></figure>\n\n<p>  普通用户和 root 用户都可以安装使用. 安装过程进行了以下几步:</p>\n<ol>\n<li>把 acme.sh 安装到你的 <strong>home</strong> 目录下:</li>\n</ol>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">~/.acme.sh/<br></code></pre></td></tr></table></figure>\n\n<p>  并创建 一个 shell 的 alias, 例如 .bashrc，方便你的使用: <code>alias acme.sh=~/.acme.sh/acme.sh</code></p>\n<ol start=\"2\">\n<li>自动为你创建 cronjob, 每天 0:00 点自动检测所有的证书, 如果快过期了, 需要更新, 则会自动更新证书.</li>\n</ol>\n<p>  更高级的安装选项请参考: <a href=\"https://github.com/Neilpang/acme.sh/wiki/How-to-install\">https://github.com/Neilpang/acme.sh/wiki/How-to-install</a></p>\n<p>  <strong>安装过程不会污染已有的系统任何功能和文件</strong>, 所有的修改都限制在安装目录中: <code>~/.acme.sh/</code></p>\n<h1 id=\"2-生成证书\"><a href=\"#2-生成证书\" class=\"headerlink\" title=\"2. 生成证书\"></a>2. 生成证书</h1><p>  <strong>acme.sh</strong> 实现了 <strong>acme</strong> 协议支持的所有验证协议. 一般有两种方式验证: http 和 dns 验证.</p>\n<h3 id=\"1-http-方式需要在你的网站根目录下放置一个文件-来验证你的域名所有权-完成验证-然后就可以生成证书了\"><a href=\"#1-http-方式需要在你的网站根目录下放置一个文件-来验证你的域名所有权-完成验证-然后就可以生成证书了\" class=\"headerlink\" title=\"1. http 方式需要在你的网站根目录下放置一个文件, 来验证你的域名所有权,完成验证. 然后就可以生成证书了.\"></a>1. http 方式需要在你的网站根目录下放置一个文件, 来验证你的域名所有权,完成验证. 然后就可以生成证书了.</h3>  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">acme.sh --issue -d mydomain.com -d www.mydomain.com --webroot /home/wwwroot/mydomain.com/<br></code></pre></td></tr></table></figure>\n\n<p>  只需要指定域名, 并指定域名所在的网站根目录. <strong>acme.sh</strong> 会全自动的生成验证文件, 并放到网站的根目录, 然后自动完成验证. 最后会聪明的删除验证文件. 整个过程没有任何副作用.</p>\n<p>  如果你用的 <strong>apache</strong>服务器, <strong>acme.sh</strong> 还可以智能的从 <strong>apache</strong>的配置中自动完成验证, 你不需要指定网站根目录:</p>\n  <figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">acme<span class=\"hljs-selector-class\">.sh</span> <span class=\"hljs-attr\">--issue</span> -d mydomain<span class=\"hljs-selector-class\">.com</span> <span class=\"hljs-attr\">--apache</span><br></code></pre></td></tr></table></figure>\n\n<p>  如果你用的 <strong>nginx</strong>服务器, 或者反代, <strong>acme.sh</strong> 还可以智能的从 <strong>nginx</strong>的配置中自动完成验证, 你不需要指定网站根目录:</p>\n  <figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">acme<span class=\"hljs-selector-class\">.sh</span> <span class=\"hljs-attr\">--issue</span> -d mydomain<span class=\"hljs-selector-class\">.com</span> <span class=\"hljs-attr\">--nginx</span><br></code></pre></td></tr></table></figure>\n\n<p>  <strong>注意, 无论是 apache 还是 nginx 模式, acme.sh在完成验证之后, 会恢复到之前的状态, 都不会私自更改你本身的配置. 好处是你不用担心配置被搞坏, 也有一个缺点, 你需要自己配置 ssl 的配置, 否则只能成功生成证书, 你的网站还是无法访问https. 但是为了安全, 你还是自己手动改配置吧.</strong></p>\n<p>  如果你还没有运行任何 web 服务, <strong>80</strong> 端口是空闲的, 那么 <strong>acme.sh</strong> 还能假装自己是一个webserver, 临时听在<strong>80</strong> 端口, 完成验证:</p>\n  <figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">acme<span class=\"hljs-selector-class\">.sh</span> <span class=\"hljs-attr\">--issue</span> -d mydomain<span class=\"hljs-selector-class\">.com</span> <span class=\"hljs-attr\">--standalone</span><br></code></pre></td></tr></table></figure>\n\n<p>  更高级的用法请参考: <a href=\"https://github.com/Neilpang/acme.sh/wiki/How-to-issue-a-cert\">https://github.com/Neilpang/acme.sh/wiki/How-to-issue-a-cert</a></p>\n<h3 id=\"2-手动-dns-方式-手动在域名上添加一条-txt-解析记录-验证域名所有权\"><a href=\"#2-手动-dns-方式-手动在域名上添加一条-txt-解析记录-验证域名所有权\" class=\"headerlink\" title=\"2. 手动 dns 方式, 手动在域名上添加一条 txt 解析记录, 验证域名所有权.\"></a>2. 手动 dns 方式, 手动在域名上添加一条 txt 解析记录, 验证域名所有权.</h3><p>  这种方式的好处是, 你不需要任何服务器, 不需要任何公网 ip, 只需要 dns 的解析记录即可完成验证. 坏处是，如果不同时配置 Automatic DNS API，使用这种方式 acme.sh 将无法自动更新证书，每次都需要手动再次重新解析验证域名所有权。</p>\n  <figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">acme<span class=\"hljs-selector-class\">.sh</span> <span class=\"hljs-attr\">--issue</span> <span class=\"hljs-attr\">--dns</span> -d mydomain<span class=\"hljs-selector-class\">.com</span> \\<br> <span class=\"hljs-attr\">--yes-I-know-dns-manual-mode-enough-go-ahead-please</span><br></code></pre></td></tr></table></figure>\n\n<p>  然后, <strong>acme.sh</strong> 会生成相应的解析记录显示出来, 你只需要在你的域名管理面板中添加这条 txt 记录即可.</p>\n<p>  等待解析完成之后, 重新生成证书:</p>\n  <figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">acme<span class=\"hljs-selector-class\">.sh</span> <span class=\"hljs-attr\">--renew</span> -d mydomain<span class=\"hljs-selector-class\">.com</span> \\<br>  <span class=\"hljs-attr\">--yes-I-know-dns-manual-mode-enough-go-ahead-please</span><br></code></pre></td></tr></table></figure>\n\n<p>  注意第二次这里用的是 <code>--renew</code></p>\n<p>  dns 方式的真正强大之处在于可以使用域名解析商提供的 api 自动添加 txt 记录完成验证.</p>\n<p>  <strong>acme.sh</strong> 目前支持 cloudflare, dnspod, cloudxns, godaddy 以及 ovh 等数十种解析商的自动集成.</p>\n<p>  以 dnspod 为例, 你需要先登录到 dnspod 账号, 生成你的 api id 和 api key, 都是免费的. 然后:</p>\n  <figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\"><span class=\"hljs-built_in\">export</span> <span class=\"hljs-attribute\">DP_Id</span>=<span class=\"hljs-string\">&quot;1234&quot;</span><br><br><span class=\"hljs-built_in\">export</span> <span class=\"hljs-attribute\">DP_Key</span>=<span class=\"hljs-string\">&quot;sADDsdasdgdsf&quot;</span><br><br>acme.sh --issue --dns dns_dp -d aa.com -d www.aa.com<br></code></pre></td></tr></table></figure>\n\n<p>  证书就会自动生成了. 这里给出的 api id 和 api key 会被自动记录下来, 将来你在使用 dnspod api 的时候, 就不需要再次指定了. 直接生成就好了:</p>\n  <figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">acme<span class=\"hljs-selector-class\">.sh</span> <span class=\"hljs-attr\">--issue</span> -d mydomain2<span class=\"hljs-selector-class\">.com</span> <span class=\"hljs-attr\">--dns</span>  dns_dp<br></code></pre></td></tr></table></figure>\n\n<p>  更详细的 api 用法: <a href=\"https://github.com/Neilpang/acme.sh/blob/master/dnsapi/README.md\">https://github.com/Neilpang/acme.sh/blob/master/dnsapi/README.md</a></p>\n<h1 id=\"3-copy-x2F-安装-证书\"><a href=\"#3-copy-x2F-安装-证书\" class=\"headerlink\" title=\"3. copy&#x2F;安装 证书\"></a>3. copy&#x2F;安装 证书</h1><p>  前面证书生成以后, 接下来需要把证书 copy 到真正需要用它的地方.</p>\n<p>  注意, 默认生成的证书都放在安装目录下: <code>~/.acme.sh/</code>, <strong>请不要直接使用此目录下的文件,</strong> 例如: 不要直接让 nginx&#x2F;apache 的配置文件使用这下面的文件. 这里面的文件都是内部使用, 而且目录结构可能会变化.</p>\n<p>  正确的使用方法是使用 <code>--install-cert</code> 命令,并指定目标位置, 然后证书文件会被copy到相应的位置, 例如:</p>\n<h2 id=\"Apache-example\"><a href=\"#Apache-example\" class=\"headerlink\" title=\"Apache example:\"></a>Apache example:</h2>  <figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gradle\">acme.sh --install-cert -d example.com \\<br>--cert-<span class=\"hljs-keyword\">file</span>      <span class=\"hljs-regexp\">/path/</span>to<span class=\"hljs-regexp\">/certfile/i</span>n<span class=\"hljs-regexp\">/apache/</span>cert.pem  \\<br>--key-<span class=\"hljs-keyword\">file</span>       <span class=\"hljs-regexp\">/path/</span>to<span class=\"hljs-regexp\">/keyfile/i</span>n<span class=\"hljs-regexp\">/apache/</span>key.pem  \\<br>--fullchain-<span class=\"hljs-keyword\">file</span> <span class=\"hljs-regexp\">/path/</span>to<span class=\"hljs-regexp\">/fullchain/</span>certfile<span class=\"hljs-regexp\">/apache/</span>fullchain.pem \\<br>--reloadcmd     <span class=\"hljs-string\">&quot;service apache2 force-reload&quot;</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Nginx-example\"><a href=\"#Nginx-example\" class=\"headerlink\" title=\"Nginx example:\"></a>Nginx example:</h2>  <figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gradle\">acme.sh --install-cert -d example.com \\<br>--key-<span class=\"hljs-keyword\">file</span>       <span class=\"hljs-regexp\">/path/</span>to<span class=\"hljs-regexp\">/keyfile/i</span>n<span class=\"hljs-regexp\">/nginx/</span>key.pem  \\<br>--fullchain-<span class=\"hljs-keyword\">file</span> <span class=\"hljs-regexp\">/path/</span>to<span class=\"hljs-regexp\">/fullchain/</span>nginx/cert.pem \\<br>--reloadcmd     <span class=\"hljs-string\">&quot;service nginx force-reload&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>  (一个小提醒, 这里用的是 <code>service nginx force-reload</code>, 不是 <code>service nginx reload</code>, 据测试, <code>reload</code> 并不会重新加载证书, 所以用的 <code>force-reload</code>)</p>\n<blockquote>\n<p>  我当时使用这个命令的时候发现用 <code>service nginx force-reload</code>  报没有权限，然后是将当前用户</p>\n</blockquote>\n<p>  Nginx 的配置 <code>ssl_certificate</code> 使用 <code>/etc/nginx/ssl/fullchain.cer</code> ，而非 <code>/etc/nginx/ssl/&lt;domain&gt;.cer</code> ，否则 <a href=\"https://www.ssllabs.com/ssltest/\">SSL Labs</a> 的测试会报 <code>Chain issues Incomplete</code> 错误。</p>\n<p>  <code>--install-cert</code>命令可以携带很多参数, 来指定目标文件. 并且可以指定 reloadcmd, 当证书更新以后, reloadcmd会被自动调用,让服务器生效.</p>\n<p>  详细参数请参考: <a href=\"https://github.com/Neilpang/acme.sh#3-install-the-issued-cert-to-apachenginx-etc\">https://github.com/Neilpang/acme.sh#3-install-the-issued-cert-to-apachenginx-etc</a></p>\n<p>  值得注意的是, 这里指定的所有参数都会被自动记录下来, 并在将来证书自动更新以后, 被再次自动调用.</p>\n<h1 id=\"4-查看已安装证书信息\"><a href=\"#4-查看已安装证书信息\" class=\"headerlink\" title=\"4. 查看已安装证书信息\"></a>4. 查看已安装证书信息</h1>  <figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">acme.sh --<span class=\"hljs-built_in\">info</span> -d example.com<br><span class=\"hljs-comment\"># 会输出如下内容：</span><br><span class=\"hljs-attribute\">DOMAIN_CONF</span>=/root/.acme.sh/example.com/example.com.conf<br><span class=\"hljs-attribute\">Le_Domain</span>=example.com<br><span class=\"hljs-attribute\">Le_Alt</span>=<span class=\"hljs-literal\">no</span><br><span class=\"hljs-attribute\">Le_Webroot</span>=dns_ali<br>Le_PreHook=<br>Le_PostHook=<br>Le_RenewHook=<br><span class=\"hljs-attribute\">Le_API</span>=https://acme-v02.api.letsencrypt.org/directory<br>Le_Keylength=<br><span class=\"hljs-attribute\">Le_OrderFinalize</span>=https://acme-v02.api.letsencrypt.org/acme/finalize/23xxxx150/781xxxx4310<br><span class=\"hljs-attribute\">Le_LinkOrder</span>=https://acme-v02.api.letsencrypt.org/acme/order/233xxx150/781xxxx4310<br><span class=\"hljs-attribute\">Le_LinkCert</span>=https://acme-v02.api.letsencrypt.org/acme/cert/04cbd28xxxxxx349ecaea8d07<br><span class=\"hljs-attribute\">Le_CertCreateTime</span>=1649358725<br><span class=\"hljs-attribute\">Le_CertCreateTimeStr</span>=Thu Apr  7 19:12:05 UTC 2022<br><span class=\"hljs-attribute\">Le_NextRenewTimeStr</span>=Mon Jun  6 19:12:05 UTC 2022<br><span class=\"hljs-attribute\">Le_NextRenewTime</span>=1654456325<br>Le_RealCertPath=<br>Le_RealCACertPath=<br><span class=\"hljs-attribute\">Le_RealKeyPath</span>=/etc/acme/example.com/privkey.pem<br><span class=\"hljs-attribute\">Le_ReloadCmd</span>=service nginx force-reload<br><span class=\"hljs-attribute\">Le_RealFullChainPath</span>=/etc/acme/example.com/chain.pem<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"5-更新证书\"><a href=\"#5-更新证书\" class=\"headerlink\" title=\"5. 更新证书\"></a>5. 更新证书</h1><p>  目前证书在 60 天以后会自动更新, 你无需任何操作. 今后有可能会缩短这个时间, 不过都是自动的, 你不用关心.</p>\n<p>  请确保 cronjob 正确安装, 看起来是类似这样的:</p>\n  <figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gradle\">crontab  -l<br><br><span class=\"hljs-number\">56</span> * * * * <span class=\"hljs-string\">&quot;/root/.acme.sh&quot;</span><span class=\"hljs-regexp\">/acme.sh --cron --home &quot;/</span>root<span class=\"hljs-regexp\">/.acme.sh&quot; &gt; /</span>dev/<span class=\"hljs-keyword\">null</span><br></code></pre></td></tr></table></figure>\n\n<h1 id=\"6-关于修改ReloadCmd\"><a href=\"#6-关于修改ReloadCmd\" class=\"headerlink\" title=\"6. 关于修改ReloadCmd\"></a>6. 关于修改ReloadCmd</h1><p>  目前修改<code>ReloadCmd</code>没有专门的命令，可以通过重新安装证书来实现修改<code>reloadCmd</code>的目的。 此外，安装证书后，相关信息是保存在<code>~/.acme.sh/example.com/example.conf</code>文件下的，内容就是<code>acme.sh --info -d example.com</code>输出的信息，不过<code>ReloadCmd</code>在文件中使用了Base64编码。理论上可以通过直接修改该文件来修改<code>ReloadCmd</code>，且修改时，无需Base64编码，直接写命令原文<code>acme.sh</code>也可以识别。 不过，<code>example.conf</code>文件的位置和内容格式以后可能会改变！<code>example.conf</code>一直都是内部使用, 后面有可能会改为用 sqlite 或者mysql 格式存储. 所以一般不建议自己修改。</p>\n<h1 id=\"7-更新-acme-sh\"><a href=\"#7-更新-acme-sh\" class=\"headerlink\" title=\"7. 更新 acme.sh\"></a>7. 更新 acme.sh</h1><p>  目前由于 acme 协议和 letsencrypt CA 都在频繁的更新, 因此 acme.sh 也经常更新以保持同步.</p>\n<p>  升级 acme.sh 到最新版 :</p>\n  <figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">acme<span class=\"hljs-selector-class\">.sh</span> <span class=\"hljs-attr\">--upgrade</span><br></code></pre></td></tr></table></figure>\n\n<p>  如果你不想手动升级, 可以开启自动升级:</p>\n  <figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">acme<span class=\"hljs-selector-class\">.sh</span> <span class=\"hljs-attr\">--upgrade</span> <span class=\"hljs-attr\">--auto-upgrade</span><br></code></pre></td></tr></table></figure>\n\n<p>  之后, acme.sh 就会自动保持更新了.</p>\n<p>  你也可以随时关闭自动更新:</p>\n  <figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">acme<span class=\"hljs-selector-class\">.sh</span> <span class=\"hljs-attr\">--upgrade</span> <span class=\"hljs-attr\">--auto-upgrade</span>  <span class=\"hljs-number\">0</span><br></code></pre></td></tr></table></figure>\n\n<h1 id=\"8-出错怎么办：\"><a href=\"#8-出错怎么办：\" class=\"headerlink\" title=\"8. 出错怎么办：\"></a>8. 出错怎么办：</h1><p>  如果出错, 请添加 debug log：</p>\n  <figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jboss-cli\">acme.sh <span class=\"hljs-params\">--issue</span>  <span class=\"hljs-string\">.....</span>  <span class=\"hljs-params\">--debug</span> <br></code></pre></td></tr></table></figure>\n\n<p>  或者：</p>\n  <figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jboss-cli\">acme.sh <span class=\"hljs-params\">--issue</span>  <span class=\"hljs-string\">.....</span>  <span class=\"hljs-params\">--debug</span>  2<br></code></pre></td></tr></table></figure>\n\n<p>  请参考： <a href=\"https://github.com/Neilpang/acme.sh/wiki/How-to-debug-acme.sh\">https://github.com/Neilpang/acme.sh/wiki/How-to-debug-acme.sh</a></p>\n<p>  最后, 本文并非完全的使用说明, 还有很多高级的功能, 更高级的用法请参看其他 wiki 页面.</p>\n<p>  <a href=\"https://github.com/Neilpang/acme.sh/wiki\">https://github.com/Neilpang/acme.sh/wiki</a></p>\n</blockquote>\n<h2 id=\"Docker\"><a href=\"#Docker\" class=\"headerlink\" title=\"Docker\"></a>Docker</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker run --rm  -itd  \\<br>  -v &quot;$(pwd)/out&quot;:/acme.sh  \\<br>  -e Ali_Key=&quot;xxxxxx&quot; \\<br>  -e Ali_Secret=&quot;xxxx&quot; \\<br>  neilpang/acme.sh  --issue --dns dns_ali -d domain.cn -d *.domain.cn<br></code></pre></td></tr></table></figure>\n\n<p>详细用法，可以参考：<a href=\"https://github.com/Neilpang/acme.sh/wiki/Run-acme.sh-in-docker\">传送门</a></p>\n<blockquote>\n<h1 id=\"acme-sh-💕-docker\"><a href=\"#acme-sh-💕-docker\" class=\"headerlink\" title=\"acme.sh 💕 docker\"></a>acme.sh 💕 docker</h1><p>  作为 docker 的忠实粉丝之一，我知道我们讨厌在 docker 主机上安装任何东西，即使它只是复制一个 shell 脚本。</p>\n<p>  用于 letsencrypt ssl 证书的带有 acme.sh 的自动化 nginx 反向代理 docker 图像： https: <a href=\"https://github.com/Neilpang/letsproxy\">&#x2F;&#x2F;github.com&#x2F;Neilpang&#x2F;letsproxy</a></p>\n<p>  部署到 docker 容器并重新加载它：<a href=\"https://github.com/Neilpang/acme.sh/wiki/deploy-to-docker-containers\">https :&#x2F;&#x2F;github.com&#x2F;Neilpang&#x2F;acme.sh&#x2F;wiki&#x2F;deploy-to-docker-containers</a></p>\n<p>  所以，这里出现了“docker 中的 acme.sh”。</p>\n<ol>\n<li>基于<strong>alpine</strong>，只有 5MB 大小。</li>\n<li>作为可执行文件运行或作为守护进程运行</li>\n<li>支持所有命令行参数。</li>\n</ol>\n<h1 id=\"1-说“Hello-World”\"><a href=\"#1-说“Hello-World”\" class=\"headerlink\" title=\"1.说“Hello World”\"></a>1.说“Hello World”</h1>  <figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dockerfile\">docker <span class=\"hljs-keyword\">run</span><span class=\"language-bash\"> --<span class=\"hljs-built_in\">rm</span> neilpang/acme.sh</span><br></code></pre></td></tr></table></figure>\n\n<h1 id=\"2-用作可执行文件：\"><a href=\"#2-用作可执行文件：\" class=\"headerlink\" title=\"2.用作可执行文件：\"></a>2.用作可执行文件：</h1>  <figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">docker run <span class=\"hljs-attr\">--rm</span>  -it  \\<br>  -v <span class=\"hljs-string\">&quot;$(pwd)/out&quot;</span>:/acme<span class=\"hljs-selector-class\">.sh</span>  \\<br>  <span class=\"hljs-attr\">--net</span>=host \\<br>  neilpang/acme<span class=\"hljs-selector-class\">.sh</span>  <span class=\"hljs-attr\">--issue</span> -d example<span class=\"hljs-selector-class\">.com</span>  <span class=\"hljs-attr\">--standalone</span><br></code></pre></td></tr></table></figure>\n\n<p>  您可以在此处使用<strong>acme.sh</strong>支持的<strong>任何命令</strong>，其他示例：</p>\n  <figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-selector-id\">#revoke</span> <span class=\"hljs-selector-tag\">a</span> cert<br>docker run <span class=\"hljs-attr\">--rm</span>  -it  \\<br>  -v <span class=\"hljs-string\">&quot;$(pwd)/out&quot;</span>:/acme<span class=\"hljs-selector-class\">.sh</span>  \\<br>  <span class=\"hljs-attr\">--net</span>=host \\<br>  neilpang/acme<span class=\"hljs-selector-class\">.sh</span>  <span class=\"hljs-attr\">--revoke</span> -d example<span class=\"hljs-selector-class\">.com</span><br><span class=\"hljs-selector-id\">#use</span> dns mode<br>docker run <span class=\"hljs-attr\">--rm</span>  -it  \\<br>  -v <span class=\"hljs-string\">&quot;$(pwd)/out&quot;</span>:/acme<span class=\"hljs-selector-class\">.sh</span>  \\<br>  neilpang/acme<span class=\"hljs-selector-class\">.sh</span>  <span class=\"hljs-attr\">--issue</span> <span class=\"hljs-attr\">--dns</span> -d example<span class=\"hljs-selector-class\">.com</span><br><span class=\"hljs-selector-id\">#run</span> cron job<br>docker run <span class=\"hljs-attr\">--rm</span>  -it  \\<br>  -v <span class=\"hljs-string\">&quot;$(pwd)/out&quot;</span>:/acme<span class=\"hljs-selector-class\">.sh</span>  \\<br>  <span class=\"hljs-attr\">--net</span>=host \\<br>  neilpang/acme<span class=\"hljs-selector-class\">.sh</span>  <span class=\"hljs-attr\">--cron</span><br></code></pre></td></tr></table></figure>\n\n<p>  无论如何，您可以像调用真正的 shell 脚本一样调用<strong>neilpang&#x2F;acme.sh。</strong></p>\n<h1 id=\"3-将-acme-sh-作为-docker-守护进程运行。\"><a href=\"#3-将-acme-sh-作为-docker-守护进程运行。\" class=\"headerlink\" title=\"3. 将 acme.sh 作为 docker 守护进程运行。\"></a>3. 将 acme.sh 作为 docker 守护进程运行。</h1><ol>\n<li>将 acme.sh 作为 docker 守护进程运行，以便它可以自动处理更新 cronjob。</li>\n</ol>\n  <figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">docker <span class=\"hljs-built_in\">run</span> --rm  -itd  \\<br>  -v <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$(pwd)</span>/out&quot;</span>:/acme.sh  \\<br>  <span class=\"hljs-attribute\">--net</span>=host \\<br>  <span class=\"hljs-attribute\">--name</span>=acme.sh \\<br>  neilpang/acme.sh daemon<br></code></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>然后你就可以使用<code>docker exec</code>来执行任何acme.sh 命令了。</li>\n</ol>\n  <figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">docker  exec  acme<span class=\"hljs-selector-class\">.sh</span> <span class=\"hljs-attr\">--help</span><br>docker  exec  acme<span class=\"hljs-selector-class\">.sh</span> <span class=\"hljs-attr\">--issue</span> -d example<span class=\"hljs-selector-class\">.com</span>  <span class=\"hljs-attr\">--standalone</span><br></code></pre></td></tr></table></figure>\n\n<p>  是的，再次强调，您可以在此处使用<strong>acme.sh</strong>支持的<strong>任何命令</strong>。</p>\n</blockquote>\n<h2 id=\"Certbot\"><a href=\"#Certbot\" class=\"headerlink\" title=\"Certbot\"></a>Certbot</h2><p><a href=\"https://certbot.eff.org/\">https://certbot.eff.org/</a></p>\n",
            "tags": [
                "ssl",
                "https"
            ]
        },
        {
            "id": "https://www.oikiou.top/2022/a2c49dae/",
            "url": "https://www.oikiou.top/2022/a2c49dae/",
            "title": "PowerShell",
            "date_published": "2022-12-19T12:48:05.000Z",
            "content_html": "<h1 id=\"PowerShell\"><a href=\"#PowerShell\" class=\"headerlink\" title=\"PowerShell\"></a>PowerShell</h1><h1 id=\"Note\"><a href=\"#Note\" class=\"headerlink\" title=\"Note\"></a>Note</h1><h2 id=\"PowerShell-Oh-My-Posh-美化\"><a href=\"#PowerShell-Oh-My-Posh-美化\" class=\"headerlink\" title=\"PowerShell + Oh My Posh 美化\"></a>PowerShell + Oh My Posh 美化</h2><p><a href=\"https://www.edgeless.top/PowerShell%E7%BE%8E%E5%8C%96/\">参考 PowerShell美化</a></p>\n<h2 id=\"PowerShell-获取当前文件夹名称-仅获取当前文件夹名\"><a href=\"#PowerShell-获取当前文件夹名称-仅获取当前文件夹名\" class=\"headerlink\" title=\"PowerShell 获取当前文件夹名称 仅获取当前文件夹名\"></a>PowerShell 获取当前文件夹名称 仅获取当前文件夹名</h2><figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs powershell\">(<span class=\"hljs-built_in\">get-item</span> .).name<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Powershell获取当前时间\"><a href=\"#Powershell获取当前时间\" class=\"headerlink\" title=\"Powershell获取当前时间\"></a>Powershell获取当前时间</h2><p><a href=\"http://www.splaybow.com/post/powershell-get-date.html\">参考 PowerShell使用Get-Date获取日期和时间</a></p>\n<p>在PowerShell中直接调用<code>Get-Date</code>，可以返回当前的日期和时间，包括年、月、日、时、分、秒。</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs powershell\"><span class=\"hljs-built_in\">PS</span> &gt; <span class=\"hljs-built_in\">Get-Date</span><br><span class=\"hljs-number\">2022</span>年<span class=\"hljs-number\">12</span>月<span class=\"hljs-number\">19</span>日 <span class=\"hljs-number\">21</span>:<span class=\"hljs-number\">32</span>:<span class=\"hljs-number\">28</span><br></code></pre></td></tr></table></figure>\n\n<p>使用<code>-Format</code>参数来获取<code>Get-Date</code>中的年、月、日、时、分、秒。</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs txt\">yyyy 年<br>M    月<br>d    日<br>h    小时（12小时制）<br>H    小时（24小时制）<br>m    分钟<br>s    秒<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs powershell\"><span class=\"hljs-built_in\">PS</span> &gt; <span class=\"hljs-built_in\">Get-Date</span> <span class=\"hljs-literal\">-Format</span> HH:mm:ss<br><span class=\"hljs-number\">21</span>:<span class=\"hljs-number\">34</span>:<span class=\"hljs-number\">11</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Powershell-ANSI颜色\"><a href=\"#Powershell-ANSI颜色\" class=\"headerlink\" title=\"Powershell ANSI颜色\"></a>Powershell ANSI颜色</h2><p><a href=\"https://juejin.cn/post/6920241597846126599\">参考: 了解 ANSI 转义码的 color 设置</a></p>\n<blockquote>\n<p>  To use one of the ANSI escape codes, we need a literal <a href=\"https://en.wikipedia.org/wiki/Escape_character#ASCII_escape_character\">ESC character</a>. This is octal 033, or decimal 27. In Bash, you would use <code>&quot;\\033&quot;</code> or <code>&quot;\\e&quot;</code>; There’s no direct equivalent sequence in PowerShell but you can instead embed an expression: <code>&quot;$([char]27)&quot;</code></p>\n<p>  PowerShell 中没有直接等效的序列，但您可以改为嵌入一个表达式：<code>&quot;$([char]27)&quot;</code>，也就是说要将<code>\\e</code>修改为<code>$([char]27)</code></p>\n<p>  例如<code>\\e[32;1m text \\e[0m</code> 修改为 <code>$([char]27)[32;1m text $([char]27)[0m</code></p>\n</blockquote>\n<p><strong>ANSI Escape code编码中有专门控制字符颜色的控制符，</strong>例如：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">\\e[37;44;3;1m<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><code>\\e</code> 代表开始ANSI Escape code</li>\n<li><code>[</code> 代表转义序列开始符 CSI，Control Sequence Introducer</li>\n<li><code>37;44;4;1</code> 代表以<code>; </code>分隔的文本样式控制符，其中 37 代表文本前景色为白色，44代表背景为蓝色，3代表斜体，1代表加粗，<code>;</code>的数量不做限制</li>\n<li><code>m</code> 代表结束控制符序列</li>\n</ul>\n<h4 id=\"常用文本样式控制符\"><a href=\"#常用文本样式控制符\" class=\"headerlink\" title=\"常用文本样式控制符\"></a>常用文本样式控制符</h4><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>作用</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>重置&#x2F;正常</td>\n<td>关闭所有属性。</td>\n</tr>\n<tr>\n<td>1</td>\n<td>粗体或增加强度</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td>弱化（降低强度）</td>\n<td>未广泛支持。</td>\n</tr>\n<tr>\n<td>3</td>\n<td>斜体</td>\n<td>未广泛支持。有时视为反相显示。</td>\n</tr>\n<tr>\n<td>4</td>\n<td>下划线</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td>缓慢闪烁</td>\n<td>低于每分钟150次。</td>\n</tr>\n<tr>\n<td>6</td>\n<td>快速闪烁</td>\n<td>MS-DOS ANSI.SYS；每分钟150以上；未广泛支持。</td>\n</tr>\n<tr>\n<td>7</td>\n<td>反显</td>\n<td>前景色与背景色交换。</td>\n</tr>\n<tr>\n<td>8</td>\n<td>隐藏</td>\n<td>未广泛支持。</td>\n</tr>\n<tr>\n<td>9</td>\n<td>划除</td>\n<td>字符清晰，但标记为删除。未广泛支持。</td>\n</tr>\n<tr>\n<td>10</td>\n<td>主要（默认）字体</td>\n<td></td>\n</tr>\n<tr>\n<td>11–19</td>\n<td>替代字体</td>\n<td>选择替代字体</td>\n</tr>\n<tr>\n<td>20</td>\n<td>尖角体</td>\n<td>几乎无支持。</td>\n</tr>\n<tr>\n<td>21</td>\n<td>关闭粗体或双下划线</td>\n<td>关闭粗体未广泛支持；双下划线几乎无支持。</td>\n</tr>\n<tr>\n<td>22</td>\n<td>正常颜色或强度</td>\n<td>不强不弱。</td>\n</tr>\n<tr>\n<td>23</td>\n<td>非斜体、非尖角体</td>\n<td></td>\n</tr>\n<tr>\n<td>24</td>\n<td>关闭下划线</td>\n<td>去掉单双下划线。</td>\n</tr>\n<tr>\n<td>25</td>\n<td>关闭闪烁</td>\n<td></td>\n</tr>\n<tr>\n<td>27</td>\n<td>关闭反显</td>\n<td></td>\n</tr>\n<tr>\n<td>28</td>\n<td>关闭隐藏</td>\n<td></td>\n</tr>\n<tr>\n<td>29</td>\n<td>关闭划除</td>\n<td></td>\n</tr>\n<tr>\n<td>30–37</td>\n<td>设置前景色</td>\n<td>参见下面的颜色表。</td>\n</tr>\n<tr>\n<td>38</td>\n<td>设置前景色</td>\n<td>下一个参数是5;n或2;r;g;b，见下。</td>\n</tr>\n<tr>\n<td>39</td>\n<td>默认前景色</td>\n<td>由具体实现定义（按照标准）。</td>\n</tr>\n<tr>\n<td>40–47</td>\n<td>设置背景色</td>\n<td>参见下面的颜色表。</td>\n</tr>\n<tr>\n<td>48</td>\n<td>设置背景色</td>\n<td>下一个参数是5;n或2;r;g;b，见下。</td>\n</tr>\n<tr>\n<td>49</td>\n<td>默认背景色</td>\n<td>由具体实现定义（按照标准）。</td>\n</tr>\n<tr>\n<td>51</td>\n<td>Framed</td>\n<td></td>\n</tr>\n<tr>\n<td>52</td>\n<td>Encircled</td>\n<td></td>\n</tr>\n<tr>\n<td>53</td>\n<td>上划线</td>\n<td></td>\n</tr>\n<tr>\n<td>54</td>\n<td>Not framed or encircled</td>\n<td></td>\n</tr>\n<tr>\n<td>55</td>\n<td>关闭上划线</td>\n<td></td>\n</tr>\n<tr>\n<td>60</td>\n<td>表意文字下划线或右边线</td>\n<td>几乎无支持。</td>\n</tr>\n<tr>\n<td>61</td>\n<td>表意文字双下划线或双右边线</td>\n<td></td>\n</tr>\n<tr>\n<td>62</td>\n<td>表意文字上划线或左边线</td>\n<td></td>\n</tr>\n<tr>\n<td>63</td>\n<td>表意文字双上划线或双左边线</td>\n<td></td>\n</tr>\n<tr>\n<td>64</td>\n<td>表意文字着重标志</td>\n<td></td>\n</tr>\n<tr>\n<td>65</td>\n<td>表意文字属性关闭</td>\n<td>重置60–64的所有效果。</td>\n</tr>\n<tr>\n<td>90–97</td>\n<td>设置明亮的前景色</td>\n<td>aixterm（非标准）。</td>\n</tr>\n<tr>\n<td>100–107</td>\n<td>设置明亮的背景色</td>\n<td>aixterm（非标准）。</td>\n</tr>\n</tbody></table>\n<p>颜色对照表</p>\n<p><img src=\"/2022/a2c49dae/e9436bb4998a4fbf9bd5abbe74121ccdtplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp\" alt=\"3bit-color\"></p>\n<h2 id=\"Powershell-修改提示符的文字内容和颜色\"><a href=\"#Powershell-修改提示符的文字内容和颜色\" class=\"headerlink\" title=\"Powershell 修改提示符的文字内容和颜色\"></a>Powershell 修改提示符的文字内容和颜色</h2><p><a href=\"https://www.lfhacks.com/tech/powershell-prompt-customization/\">参考: Powershell 修改提示符的文字内容和颜色</a></p>\n<p><a href=\"https://blog.vvzero.com/2019/07/22/set-user-alias-for-windows-PowerShell/\">参考: 为 Windows PowerShell 设置 User Alias （命令别名）</a></p>\n<ol>\n<li><p>首先我们先找到Powershell的配置文件的路径, 我们输入命令<code>echo $profile</code>就能显示.</p>\n</li>\n<li><p>如果这个文件不存在, 我们输入命令<code>notepad $Profile</code>或者<code>code $Profile</code>去新建一个文件.</p>\n</li>\n<li><p>Powershell 有一个特殊的函数： <code>prompt</code> 函数，这个函数规定了提示符的内容和外观。</p>\n<p>我们可以利用下面的命令可以查看当前使用的 <code>prompt</code> 函数的内容：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs powershell\">(<span class=\"hljs-built_in\">Get-Command</span> Prompt).ScriptBlock<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>通过 <code>prompt</code> 函数的返回值我们就能自定义提示符。</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs powershell\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">prompt</span></span> &#123;<br>  <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$</span>([char]27)[32m&quot;</span> + <span class=\"hljs-variable\">$</span>(<span class=\"hljs-built_in\">Get-Date</span> <span class=\"hljs-literal\">-Format</span> HH:mm:ss) + <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$</span>([char]27)[0m&quot;</span> +<br>  <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$</span>([char]27)[95m&quot;</span> + <span class=\"hljs-variable\">$</span>((<span class=\"hljs-built_in\">get-item</span> .).name) + <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$</span>([char]27)[0m&quot;</span> +<br>  <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$</span>([char]27)[33m&gt;<span class=\"hljs-variable\">$</span>([char]27)[0m&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>  第一行 <code>Get-Date</code>获取当前系统的时间, <code>-Format</code>格式化使用<code>HH:mm:ss</code>的格式, 前后使用了ANSI颜色转义将前景色设置为深绿色</p>\n<p>  第二行 <code>(get-item .).name</code>获取了当前文件夹的名称, 并设置前景色为深紫色</p>\n<p>  第三行 输出一个深黄色的<code>&gt;</code>符号</p>\n</blockquote>\n</li>\n<li><p>输入 <code>. $Profile</code> 命令生效。(注意这里是大小写不敏感的)</p>\n</li>\n</ol>\n<h2 id=\"Powershell-起别名-User-Alias-命令别名\"><a href=\"#Powershell-起别名-User-Alias-命令别名\" class=\"headerlink\" title=\"Powershell 起别名(User Alias) 命令别名\"></a>Powershell 起别名(User Alias) 命令别名</h2><p><a href=\"https://blog.vvzero.com/2019/07/22/set-user-alias-for-windows-PowerShell/\">参考 为 Windows PowerShell 设置 User Alias （命令别名）</a></p>\n<blockquote>\n<p>  我们的思路就是将命令设置成为一个<code>function</code>, 运行这个<code>function</code>执行特定的指令即可.</p>\n</blockquote>\n<p>两个思路:</p>\n<ol>\n<li><p>使用<code>New-Alias</code>指令, 添加到Powershell的<code>$Profile</code>文件里面, 每次启动运行一次. 这个命令里面不能含有空格.</p>\n<p><a href=\"https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/new-alias?view=powershell-7.3\">参考 Microsoft的Powershell文档</a></p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs powershell\"><span class=\"hljs-comment\"># 此命令创建一个名为 List 的别名来表示 Get-ChildItem cmdlet。</span><br><span class=\"hljs-built_in\">New-Alias</span> <span class=\"hljs-literal\">-Name</span> <span class=\"hljs-string\">&quot;List&quot;</span> <span class=\"hljs-built_in\">Get-ChildItem</span><br><span class=\"hljs-comment\"># 为notepad++ 设置别名 np</span><br><span class=\"hljs-built_in\">New-Alias</span> <span class=\"hljs-literal\">-Name</span> <span class=\"hljs-string\">&quot;np&quot;</span> notepad++.exe<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>使用<code>function</code>指令, 添加到Powershell的<code>$Profile</code>文件里面, 把指令当作<code>function</code>的名称来调用, 这样命令可以带有空格.</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs powershell\"><span class=\"hljs-comment\"># 带参数的function</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">np</span>+</span> &#123;<br>    <span class=\"hljs-keyword\">param</span> (<br>        <span class=\"hljs-variable\">$ComputerName</span><br>    )<br>    notepad++.exe <span class=\"hljs-variable\">$ComputerName</span><br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ol>\n",
            "tags": [
                "ps",
                "powershell"
            ]
        },
        {
            "id": "https://www.oikiou.top/2022/d911b12b/",
            "url": "https://www.oikiou.top/2022/d911b12b/",
            "title": "Zsh 安装 配置",
            "date_published": "2022-12-12T14:57:15.000Z",
            "content_html": "<h1 id=\"zsh\"><a href=\"#zsh\" class=\"headerlink\" title=\"zsh\"></a>zsh</h1><p><strong>Zsh</strong>是一个为交互使用而设计的shell，它也是一种强大的脚本语言。<em>bash</em>、ksh 和 <em>tcsh</em> 的许多有用特性都被合并到 <em>zsh</em> 中; 添加了许多原始功能。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">Ubuntu</span> <br>sudo apt-get install zsh<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>  zsh非常强大，同时它的配置也是较为繁杂，所以我们使用“oh my zsh”这个框架来简化我们的配置流程。</p>\n</blockquote>\n<p><code>cat /etc/shells</code> 查看当前系统有哪些shell版本<br><code>echo @SHELL</code> 查看当前使用的shell版本</p>\n<p>安装完成后会在<code>~</code>目录下产生一个<code>.zshrc</code>这个跟<code>.bashrc</code>是一样的文件，只是配置的对象不一样。<code>rc</code>就是启动的意思，启动zsh读取的配置就是这个文件。</p>\n<h1 id=\"Oh-My-Zsh\"><a href=\"#Oh-My-Zsh\" class=\"headerlink\" title=\"Oh My Zsh\"></a>Oh My Zsh</h1><p><a href=\"https://ohmyz.sh/\">官网</a></p>\n<p>Oh My Zsh 是一个令人愉快的、开源的、社区驱动的框架，用于管理你的 Zsh 配置。它捆绑了数千个有用的功能、助手、插件、主题和一些东西 让你大喊大叫… “Oh My ZSH!”</p>\n<h2 id=\"安装-1\"><a href=\"#安装-1\" class=\"headerlink\" title=\"安装\"></a>安装</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">sh -c &quot;$(wget https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)&quot;<br></code></pre></td></tr></table></figure>\n\n<p>安装完成后发现<code>~</code>目录下会有一个<code>.oh-my-zsh</code>文件夹，文件夹内的一些文件主要用处</p>\n<ul>\n<li><code>themes</code> 一些主题文件</li>\n<li><code>plugins</code> 插件，我们的插件就下载放在这个文件夹里面</li>\n</ul>\n<p>Powerlevel10k 是用于 Zsh 美化的一个非常酷的主题，它强调速度、 灵活性和开箱即用的体验。</p>\n<h2 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h2><h3 id=\"zsh-syntax-highlighting-语法高亮\"><a href=\"#zsh-syntax-highlighting-语法高亮\" class=\"headerlink\" title=\"zsh-syntax-highlighting 语法高亮\"></a>zsh-syntax-highlighting 语法高亮</h3><p>插件功能：这个包为<code>shell zsh</code>提供语法突出显示。它允许高亮显示在<code>zsh</code>提示符下输入到交互式终端的命令。这有助于在运行命令之前检查它们，特别是在捕获语法错误方面。<br>例：在你输入某个命令时，如果该命令不存在，那么它显示为红色；否则，它会变成绿色。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting<br></code></pre></td></tr></table></figure>\n\n<p>将 <code>zsh-syntax-highlighting</code> 添加到 <code>~/.zshrc</code> 中</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">plugins=(--other-- zsh-syntax-highlighting)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"zsh-autosuggestions-自动补全\"><a href=\"#zsh-autosuggestions-自动补全\" class=\"headerlink\" title=\"zsh-autosuggestions 自动补全\"></a>zsh-autosuggestions 自动补全</h3><p>插件功能：输入命令时可提示自动补全（灰色部分），按tab键（→ ）即可补全。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions<br></code></pre></td></tr></table></figure>\n\n<p>将 <code>zsh-autosuggestions</code> 添加到 <code>~/.zshrc</code> 中</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\"><span class=\"hljs-attribute\">plugins</span><span class=\"hljs-operator\">=</span>(--other-- zsh-autosuggestions)<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"Powerlevel10k\"><a href=\"#Powerlevel10k\" class=\"headerlink\" title=\"Powerlevel10k\"></a>Powerlevel10k</h1><p><a href=\"https://github.com/romkatv/powerlevel10k\">https://github.com/romkatv/powerlevel10k</a></p>\n<h2 id=\"安装-2\"><a href=\"#安装-2\" class=\"headerlink\" title=\"安装\"></a>安装</h2><h3 id=\"安装字体\"><a href=\"#安装字体\" class=\"headerlink\" title=\"安装字体\"></a>安装字体</h3><blockquote>\n<p>  powerlevel10k里面使用了很多的图标，而这些图标只有一些特定的字体才能显示，所以我们需要安装这些字体这样才能正常显示，我们称这些有很多图标的字体为<code>Nerd Fonts</code>。</p>\n</blockquote>\n<p>首先我们需要先安装一下字体，我们先下载官方推荐的<code>MesloLGS NF</code>字体来配置。</p>\n<ul>\n<li>Download these four ttf files:<ul>\n<li>[MesloLGS NF Regular.ttf](<a href=\"https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS\">https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS</a> NF Regular.ttf)</li>\n<li>[MesloLGS NF Bold.ttf](<a href=\"https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS\">https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS</a> NF Bold.ttf)</li>\n<li>[MesloLGS NF Italic.ttf](<a href=\"https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS\">https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS</a> NF Italic.ttf)</li>\n<li>[MesloLGS NF Bold Italic.ttf](<a href=\"https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS\">https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS</a> NF Bold Italic.ttf)</li>\n</ul>\n</li>\n<li>Double-click on each file and click “Install”. This will make <code>MesloLGS NF</code> font available to all applications on your system.</li>\n</ul>\n<blockquote>\n<p>  我们如果是在ssh配置远程主机的时候，是在本地的主机上安装这个字体。</p>\n<p>  字体影响的是显示，ssh显示是在本地渲染的，所以肯定是在本地主机上安装字体。</p>\n</blockquote>\n<h4 id=\"其他的Nerd-Fonts字体\"><a href=\"#其他的Nerd-Fonts字体\" class=\"headerlink\" title=\"其他的Nerd Fonts字体\"></a>其他的<code>Nerd Fonts</code>字体</h4><p><a href=\"https://github.com/ryanoasis/nerd-fonts\">https://github.com/ryanoasis/nerd-fonts</a></p>\n<p>我们可以在这里下载一些打过补丁的热门字体。</p>\n<h3 id=\"安装Powerlevel10k\"><a href=\"#安装Powerlevel10k\" class=\"headerlink\" title=\"安装Powerlevel10k\"></a>安装Powerlevel10k</h3><p>官方的README文档提出了几种安装方式，它推荐使用手动安装方式。</p>\n<h4 id=\"Manual\"><a href=\"#Manual\" class=\"headerlink\" title=\"Manual\"></a>Manual</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ~/powerlevel10k<br>echo &#x27;source ~/powerlevel10k/powerlevel10k.zsh-theme&#x27; &gt;&gt;~/.zshrc<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"Oh-My-Zsh-1\"><a href=\"#Oh-My-Zsh-1\" class=\"headerlink\" title=\"Oh My Zsh\"></a>Oh My Zsh</h4><ol>\n<li><p>Clone the repository:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">git clone --depth=1 https://github.com/romkatv/powerlevel10k.git $&#123;ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom&#125;/themes/powerlevel10k<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>在<code>~/.zshrc</code>文件中，设置<code>ZSH_THEME=&quot;powerlevel10k/powerlevel10k&quot;</code></p>\n</li>\n</ol>\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p>安装好后我们启动zsh，在zsh环境下输入<code>p10k configure</code>用于配置p10k</p>\n<blockquote>\n<p>  这一步我在<code>MobaXterm</code>下进行，发现可配置的选项缺失很多，后面在<code>Windows Terminal</code>重新配置发现显示是正常的。</p>\n<p>  <code>MobaXterm</code>下<code>Fira Code</code>字体似乎显示也有些问题，<code>MesloLGS NF</code>就是正常的。</p>\n</blockquote>\n",
            "tags": [
                "linux",
                "zsh",
                "shell"
            ]
        },
        {
            "id": "https://www.oikiou.top/2022/4dd4ea8a/",
            "url": "https://www.oikiou.top/2022/4dd4ea8a/",
            "title": "Ip 转换成 Location 的Api",
            "date_published": "2022-11-08T15:24:15.000Z",
            "content_html": "<h1 id=\"ip-to-location\"><a href=\"#ip-to-location\" class=\"headerlink\" title=\"ip to location\"></a>ip to location</h1><h2 id=\"ipwhois\"><a href=\"#ipwhois\" class=\"headerlink\" title=\"ipwhois\"></a>ipwhois</h2><p>IPWHOIS.IO的IP地理定位API的URL格式很简单。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">http://ipwhois.app/json/&#123;IP&#125;<br></code></pre></td></tr></table></figure>\n\n<p>例如，我们可以用以下IP地址发出API请求：47.9.123.84。</p>\n<p><img src=\"/2022/4dd4ea8a/ipwhois-api.png\" alt=\"img\"></p>\n<p><strong>参考链接:</strong></p>\n<ul>\n<li><a href=\"https://webdamn.com/ip-geolocation-api/\">IP Geolocation API – IPWHOIS.IO</a></li>\n<li><a href=\"https://webdamn.com/how-to-integrate-ip-geolocation-api-with-php/\">How to Integrate IP Geolocation API with PHP</a></li>\n<li><a href=\"https://webdamn.com/scrape-search-result-data-using-serpapi-with-python/\">Scrape Search Result Data using SerpApi with Python</a></li>\n<li><a href=\"https://webdamn.com/get-geocoding-using-positionstack-api-with-php/\">Get Geocoding using Positionstack API with PHP</a></li>\n<li><a href=\"https://webdamn.com/flight-data-using-aviationstack-api-with-php/\">Flight Data using Aviationstack API with PHP</a></li>\n<li><a href=\"https://webdamn.com/get-address-information-using-geocode-api-with-php/\">Get Address Information using Geocode API with PHP</a></li>\n<li><a href=\"https://webdamn.com/review-scraping-using-reviewapi-with-php/\">Review Scraping using ReviewAPI with PHP</a></li>\n<li><a href=\"https://webdamn.com/simple-web-scraping-with-zenscrape-api-using-php/\">Simple Web Scraping with Zenscrape API using PHP</a></li>\n<li><a href=\"https://webdamn.com/scrape-search-result-with-zenserp-api-using-php/\">Scrape Search Result with Zenserp API using PHP</a></li>\n<li><a href=\"https://webdamn.com/build-user-agent-lookup-system-using-userstack-api-with-php/\">Build User Agent Lookup System using Userstack API with PHP</a></li>\n<li><a href=\"https://webdamn.com/build-ip-lookup-website-using-ipapi-with-php/\">Build IP Lookup Website using ipapi with PHP</a></li>\n<li><a href=\"https://webdamn.com/build-weather-website-with-weatherstack-api-using-php/\">Build Weather Website with Weatherstack API using PHP</a></li>\n<li><a href=\"https://webdamn.com/get-website-visitors-info-using-ipstack-api-with-php/\">Get Website Visitors Info using IPStack API with PHP</a></li>\n<li><a href=\"https://webdamn.com/scrape-serp-data-using-serpstack-api-with-python/\">Scrape SERP Data using SerpStack API with Python</a></li>\n</ul>\n",
            "tags": [
                "ip",
                "location",
                "api"
            ]
        },
        {
            "id": "https://www.oikiou.top/2022/6fb71d96/",
            "url": "https://www.oikiou.top/2022/6fb71d96/",
            "title": "单位换算",
            "date_published": "2022-11-01T14:57:15.000Z",
            "content_html": "<h1 id=\"单位换算\"><a href=\"#单位换算\" class=\"headerlink\" title=\"单位换算\"></a>单位换算</h1><h1 id=\"长度\"><a href=\"#长度\" class=\"headerlink\" title=\"长度\"></a>长度</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">★ -----------------</span><br>1 km = 1000 m<br>1 m  = 100  cm<br>1 cm = 10   mm<br>1 mm = 1000 um<br><br>1    inch = 2.54 cm<br>1/10 inch = 2.54 mm<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">--------------------</span><br>1 km = 1000 m<br>1 m  = 10   dm<br>1 dm = 10   cm<br>1 cm = 10   mm<br>1 m  = 1000 mm<br>1 mm = 1000 um<br>1 um = 1000 nm<br>1 nm = 1000 pm <br>1 pm = 1000 fm<br>1 fm = 1000 am<br>...<br>1 inch              = 2.54 cm<br>1 cm                = 0.3937008 inch<br>...<br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\"></span><br><span class=\"language-bash\">1 海里(nautical mile) = 1852 m = 1.852 km</span><br>1 km                = 0.5399568 海里(nautical mile)<br>...<br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">英制长度单位</span><br>1 英里(mile)          = 1.609344 km<br>1 km                = 0.6213712 英里(mile)<br>...<br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">天文学长度单位</span><br>1 光年                = 9.4653×10^12 km<br>1 天文单位 ≈ 1.496亿 千米<br>...<br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">我国传统的长度单位</span><br>1 km                = 2 里<br>1 里                 = 150 丈 = 500 米<br>1 丈                 = 10尺<br>1 丈                 = 3.33米<br>1 尺                 = 3.33分米<br>1 m                 = 0.3 丈 = 3 尺 = 30 寸<br>1 cm                = 3 分 = 30 厘<br><br></code></pre></td></tr></table></figure>\n\n<h1 id=\"时间单位\"><a href=\"#时间单位\" class=\"headerlink\" title=\"时间单位\"></a>时间单位</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">★ -----------------</span><br>1 s  = 1000 ms<br>1 ms = 1000 us<br>1 us = 1000 ns<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">   -----------------</span><br>1 minute = 60 s<br>1 s  = 1000 ms<br>1 ms = 1000 us<br>1 us = 1000 ns<br>1 ns = 1000 ps<br><br>100年      = 1世纪<br>365.25天   = 1年<br>1平太阳日     = 24小时3分56.555秒<br>1恒星日      = 23小时56分4.091秒<br>1太阳年(回归年) = 365.2422天(= 365天5小时48分46秒)<br>1恒星年      = 365.2564天(= 365天6小时9分9.5秒)<br>1朔望月      = 29.5306天<br>1恒星月      = 27.3712天<br>1太阳年      = 12个朔望日 = 354.36天<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"速度\"><a href=\"#速度\" class=\"headerlink\" title=\"速度\"></a>速度</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">★ -----------------</span><br>1 m/s  = 3.6 km/h<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">   -----------------</span><br>1 mph  = 1.609344 km/h<br>1 km/h = 0.6213712 mph<br><br></code></pre></td></tr></table></figure>\n\n<h1 id=\"温度\"><a href=\"#温度\" class=\"headerlink\" title=\"温度\"></a>温度</h1><p>$$<br>℉ &#x3D; ℃ * (9&#x2F;5) + 32<br>$$</p>\n<p>$$<br>℃ &#x3D; (℉ - 32)*(5&#x2F;9)<br>$$</p>\n<p>$$<br>K &#x3D; ℃ + 273.15<br>$$</p>\n<p>$$<br>℃ &#x3D; K - 273.15<br>$$</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">25 ℃ = 298.15 K = 77 F<br></code></pre></td></tr></table></figure>\n\n\n\n\n\n<h1 id=\"电容单位\"><a href=\"#电容单位\" class=\"headerlink\" title=\"电容单位\"></a>电容单位</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><br>1 F  = 1000 mF<br>1 mF = 1000 uF<br>1 uF = 1000 nF<br>1 nF = 1000 pF<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/6fb71d96/tutorials068_001_zh.gif\" alt=\"C\"></p>\n<ul>\n<li>数值中的<code>R</code>代表小数点<code>.</code></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">标示</th>\n<th align=\"left\">电阻</th>\n<th align=\"left\">电容</th>\n<th align=\"left\">电感</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">120</td>\n<td align=\"left\">12Ω</td>\n<td align=\"left\">12pF</td>\n<td align=\"left\">12μH</td>\n</tr>\n<tr>\n<td align=\"left\">122</td>\n<td align=\"left\">1.2kΩ</td>\n<td align=\"left\">1.2nF</td>\n<td align=\"left\">1.2mH</td>\n</tr>\n<tr>\n<td align=\"left\">124</td>\n<td align=\"left\">120kΩ</td>\n<td align=\"left\">120nF</td>\n<td align=\"left\">120mH</td>\n</tr>\n<tr>\n<td align=\"left\">126</td>\n<td align=\"left\">12MΩ</td>\n<td align=\"left\">12μF</td>\n<td align=\"left\">12H</td>\n</tr>\n<tr>\n<td align=\"left\">R15</td>\n<td align=\"left\">0.15Ω</td>\n<td align=\"left\">0.15pF</td>\n<td align=\"left\">0.15μH</td>\n</tr>\n<tr>\n<td align=\"left\">1R5</td>\n<td align=\"left\">1.5Ω</td>\n<td align=\"left\">1.5pF</td>\n<td align=\"left\">1.5μH</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th align=\"center\">误差符号</th>\n<th align=\"center\">误差</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Ｆ</td>\n<td align=\"center\">±1％</td>\n</tr>\n<tr>\n<td align=\"center\">Ｇ</td>\n<td align=\"center\">±2％</td>\n</tr>\n<tr>\n<td align=\"center\">Ｊ</td>\n<td align=\"center\">±5％</td>\n</tr>\n<tr>\n<td align=\"center\">Ｋ</td>\n<td align=\"center\">±10％</td>\n</tr>\n<tr>\n<td align=\"center\">Ｍ</td>\n<td align=\"center\">±20％</td>\n</tr>\n<tr>\n<td align=\"center\">Ｚ</td>\n<td align=\"center\">80%,－20%</td>\n</tr>\n</tbody></table>\n",
            "tags": [
                "unit",
                "m",
                "cm",
                "mm",
                "s",
                "us"
            ]
        },
        {
            "id": "https://www.oikiou.top/2022/3db44d04/",
            "url": "https://www.oikiou.top/2022/3db44d04/",
            "title": "Android 文件传输模式 电脑无法识别",
            "date_published": "2022-10-10T14:57:15.000Z",
            "content_html": "<h1 id=\"android-文件传输模式-电脑无法识别\"><a href=\"#android-文件传输模式-电脑无法识别\" class=\"headerlink\" title=\"android 文件传输模式 电脑无法识别\"></a>android 文件传输模式 电脑无法识别</h1><p>最近android手机连接电脑选择传输文件模式，电脑不再识别手机。选择照片模式就没有问题。</p>\n<p>手机选择文件传输模式后 选择自动搜索驱动程序 安装后会 提示“这个inf中的服务安装段落无效”。</p>\n<h2 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h2><ol>\n<li><p>按“Win+X” 点击 “设备管理器”</p>\n</li>\n<li><p>在设备管理器中找到你的手机，名字可能是你的手机型号，可能是未知设备 ，</p>\n</li>\n<li><p>右键选择更新驱动程序.</p>\n</li>\n<li><p>选择 “浏览计算机以查找驱动程序软件”</p>\n</li>\n<li><p>选择 “让我从计算机上的可用驱动程序列表中选取”</p>\n</li>\n<li><p>在列表里面找到“便携设备” (可能没有这一步操作)</p>\n</li>\n<li><p>选择 “MTP USB 设备”</p>\n<p><img src=\"/2022/3db44d04/1636599848857.png\" alt=\"win10系统识别不了USB设备解决方法介绍-Win10系统识别不了USB设备怎么办-53系统之家\"></p>\n</li>\n<li><p>点击 “下一步”</p>\n</li>\n<li><p>回到设备管理器看到设备已经可用正确运作了</p>\n</li>\n</ol>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://developer.android.com/studio/run/oem-usb\">安装原始设备制造商 (OEM) USB 驱动程序</a></p>\n<p><a href=\"https://developer.android.com/studio/run/win-usb\">获取 Google USB 驱动程序</a></p>\n",
            "tags": [
                "pc",
                "windows",
                "android",
                "mtp",
                "driver"
            ]
        },
        {
            "id": "https://www.oikiou.top/2022/9d389561/",
            "url": "https://www.oikiou.top/2022/9d389561/",
            "title": "Tmux 终端复用器(Terminal Multiplexer)",
            "date_published": "2022-09-29T15:57:15.000Z",
            "content_html": "<h1 id=\"tmux-终端复用器-terminal-multiplexer\"><a href=\"#tmux-终端复用器-terminal-multiplexer\" class=\"headerlink\" title=\"tmux 终端复用器(terminal multiplexer)\"></a>tmux 终端复用器(terminal multiplexer)</h1><p>☆为重要内容</p>\n<h1 id=\"Tmux-简介\"><a href=\"#Tmux-简介\" class=\"headerlink\" title=\"Tmux 简介\"></a>Tmux 简介</h1><p>tmux 终端复用器(terminal multiplexer)</p>\n<h2 id=\"tmux-能干什么\"><a href=\"#tmux-能干什么\" class=\"headerlink\" title=\"tmux 能干什么\"></a>tmux 能干什么</h2><p>命令行的典型使用方式是，打开一个终端窗口（terminal window，以下简称”窗口”），在里面输入命令。<strong>用户与计算机的这种临时的交互，称为一次”会话”（session）</strong> 。</p>\n<p>会话的一个重要特点是，窗口与其中启动的进程是<a href=\"https://www.ruanyifeng.com/blog/2016/02/linux-daemon.html\">连在一起</a>的。打开窗口，会话开始；关闭窗口，会话结束，会话内部的进程也会随之终止，不管有没有运行完。</p>\n<p>一个典型的例子就是，<a href=\"https://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html\">SSH 登录</a>远程计算机，打开一个远程窗口执行一个命令例如<code>iperf3 -s</code>。这时，关掉SSH，会发现<code>iperf3</code>进程也被关掉了。这是因为<code>iperf3</code>属于SSH的子进程，SSH作为父进程，如果父进程关掉了，子进程也就关掉了。</p>\n<p>为了解决这个问题，会话与窗口可以”解绑”：窗口关闭时，会话并不终止，而是继续运行，等到以后需要的时候，再让会话”绑定”其他窗口。</p>\n<p><strong>Tmux 就是会话与窗口的”解绑”工具，将它们彻底分离。</strong></p>\n<blockquote>\n<ul>\n<li>它允许在单个窗口中，同时访问多个会话。这对于同时运行多个命令行程序很有用。</li>\n<li>它可以让新窗口”接入”已经存在的会话。</li>\n<li>它允许每个会话有多个连接窗口，因此可以多人实时共享会话。</li>\n<li>它还支持窗口任意的垂直和水平拆分。</li>\n</ul>\n</blockquote>\n<p>类似的终端复用器还有 GNU Screen。Tmux 与它功能相似，但是更易用，也更强大。</p>\n<h1 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h1><p>Tmux 一般需要自己安装。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># Ubuntu 或 Debian</span><br>$ sudo apt-get install tmux<br><br><span class=\"hljs-comment\"># 启动</span><br>$ tmux<br><br><span class=\"hljs-comment\"># 退出</span><br>$ <span class=\"hljs-built_in\">exit</span><br></code></pre></td></tr></table></figure>\n\n<p>启动后底部<u>左边</u>是<strong>窗口</strong>信息（编号和名称），<u>右侧</u>是系统信息。</p>\n<p><img src=\"/2022/9d389561/image-20220929235001871.png\" alt=\"image-20220929235001871\"></p>\n<p>按下<code>Ctrl+d</code>或者显式输入<code>exit</code>命令，就可以退出 Tmux 窗口。</p>\n<h2 id=\"前缀键☆\"><a href=\"#前缀键☆\" class=\"headerlink\" title=\"前缀键☆\"></a><strong>前缀键</strong>☆</h2><p>Tmux 窗口有大量的快捷键。所有快捷键都要通过前缀键唤起。默认的前缀键是<code>Ctrl+b</code>，即先按下<code>Ctrl+b</code>，快捷键才会生效。</p>\n<p>举例来说，帮助命令的快捷键是<code>Ctrl+b ?</code>。它的用法是，在 Tmux 窗口中，先按下<code>Ctrl+b</code>，再按下<code>?</code>，就会显示帮助信息。</p>\n<p>然后，按下 ESC 键或<code>q</code>键，就可以退出帮助。</p>\n<h2 id=\"会话-窗格-窗口-的概念☆\"><a href=\"#会话-窗格-窗口-的概念☆\" class=\"headerlink\" title=\"会话  窗格  窗口  的概念☆\"></a><strong>会话  窗格  窗口  的概念</strong>☆</h2><blockquote>\n<p>  会话 session<br>  窗口 windows<br>  窗格 pane</p>\n</blockquote>\n<ul>\n<li><code>tmux new</code>的是会话, 会话可以包括多个窗口, 窗口内可以有多个窗格</li>\n</ul>\n<ul>\n<li><code>tmux ls</code> 列出的是会话</li>\n</ul>\n<p><img src=\"/2022/9d389561/image-20220930003505311.png\" alt=\"image-20220930003505311\"></p>\n<h1 id=\"会话的管理\"><a href=\"#会话的管理\" class=\"headerlink\" title=\"会话的管理\"></a>会话的管理</h1><h2 id=\"快捷键☆\"><a href=\"#快捷键☆\" class=\"headerlink\" title=\"快捷键☆\"></a>快捷键☆</h2><p>下面是一些会话相关的快捷键。</p>\n<blockquote>\n<ul>\n<li><code>Ctrl+b d</code>：分离当前会话。</li>\n<li><code>Ctrl+b s</code>：列出所有会话。</li>\n<li><code>Ctrl+b $</code>：重命名当前会话。</li>\n</ul>\n</blockquote>\n<h2 id=\"3-1-new新建会话☆\"><a href=\"#3-1-new新建会话☆\" class=\"headerlink\" title=\"3.1 new新建会话☆\"></a>3.1 new新建会话☆</h2><p>第一个启动的 Tmux 窗口，编号是<code>0</code>，第二个窗口的编号是<code>1</code>，以此类推。这些窗口对应的会话，就是 0 号会话、1 号会话。</p>\n<p>使用编号区分会话，不太直观，更好的方法是为会话起名。</p>\n<blockquote>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 直接新建一个</span><br>$ tmux<br><span class=\"hljs-comment\"># 新建并设置一个名字</span><br>$ tmux new -s &lt;session-name&gt;<br></code></pre></td></tr></table></figure>\n</blockquote>\n<p>上面命令新建一个指定名称的会话。</p>\n<p>在<code>tmux</code>内应该是无法执行这个指令的, 需要分屏参考下面的窗格操作章节.</p>\n<h2 id=\"3-2-detach分离会话☆\"><a href=\"#3-2-detach分离会话☆\" class=\"headerlink\" title=\"3.2 detach分离会话☆\"></a>3.2 detach分离会话☆</h2><p>在 Tmux 窗口中，按下<code>Ctrl+b d</code>或者输入<code>tmux detach</code>命令，就会将当前会话与窗口分离。</p>\n<blockquote>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ tmux detach<br></code></pre></td></tr></table></figure>\n</blockquote>\n<p>上面命令执行后，就会退出当前 Tmux 窗口，但是会话和里面的进程仍然在后台运行。</p>\n<p><code>tmux ls</code>命令可以查看当前所有的 Tmux 会话。</p>\n<blockquote>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ tmux <span class=\"hljs-built_in\">ls</span><br><span class=\"hljs-comment\"># or</span><br>$ tmux list-session<br></code></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"3-3-attach接入会话☆\"><a href=\"#3-3-attach接入会话☆\" class=\"headerlink\" title=\"3.3 attach接入会话☆\"></a>3.3 attach接入会话☆</h2><p><code>tmux attach</code>命令用于重新接入某个已存在的会话。</p>\n<blockquote>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 使用会话编号</span><br>$ tmux attach -t 0<br><br><span class=\"hljs-comment\"># 使用会话名称</span><br>$ tmux attach -t &lt;session-name&gt;<br></code></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"3-4-kill-session杀死会话☆\"><a href=\"#3-4-kill-session杀死会话☆\" class=\"headerlink\" title=\"3.4 kill-session杀死会话☆\"></a>3.4 kill-session杀死会话☆</h2><p><code>tmux kill-session</code>命令用于杀死某个会话。</p>\n<blockquote>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 使用会话编号</span><br>$ tmux kill-session -t 0<br><br><span class=\"hljs-comment\"># 使用会话名称</span><br>$ tmux kill-session -t &lt;session-name&gt;<br></code></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"3-5-切换会话\"><a href=\"#3-5-切换会话\" class=\"headerlink\" title=\"3.5 切换会话\"></a>3.5 切换会话</h2><p><code>tmux switch</code>命令用于切换会话。</p>\n<blockquote>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 使用会话编号</span><br>$ tmux switch -t 0<br><br><span class=\"hljs-comment\"># 使用会话名称</span><br>$ tmux switch -t &lt;session-name&gt;<br></code></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"3-6-重命名会话\"><a href=\"#3-6-重命名会话\" class=\"headerlink\" title=\"3.6 重命名会话\"></a>3.6 重命名会话</h2><p><code>tmux rename-session</code>命令用于重命名会话。</p>\n<blockquote>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ tmux rename-session -t 0 &lt;new-name&gt;<br></code></pre></td></tr></table></figure>\n</blockquote>\n<p>上面命令将0号会话重命名。</p>\n<h1 id=\"窗格操作\"><a href=\"#窗格操作\" class=\"headerlink\" title=\"窗格操作\"></a>窗格操作</h1><h2 id=\"快捷键☆-1\"><a href=\"#快捷键☆-1\" class=\"headerlink\" title=\"快捷键☆\"></a>快捷键☆</h2><blockquote>\n<ul>\n<li><code>Ctrl+b %</code>：划分左右两个窗格。☆</li>\n<li><code>Ctrl+b &quot;</code>：划分上下两个窗格。☆</li>\n<li><code>Ctrl+b &lt;arrow key&gt;</code>：光标切换到其他窗格。<code>&lt;arrow key&gt;</code>是指向要切换到的窗格的方向键，比如切换到下方窗格，就按方向键<code>↓</code>。☆</li>\n<li><code>Ctrl+b ;</code>：光标切换到上一个窗格。</li>\n<li><code>Ctrl+b o</code>：光标切换到下一个窗格。</li>\n<li><code>Ctrl+b &#123;</code>：当前窗格与上一个窗格交换位置。☆</li>\n<li><code>Ctrl+b &#125;</code>：当前窗格与下一个窗格交换位置。☆</li>\n<li><code>Ctrl+b Ctrl+o</code>：所有窗格向前移动一个位置，第一个窗格变成最后一个窗格。</li>\n<li><code>Ctrl+b Alt+o</code>：所有窗格向后移动一个位置，最后一个窗格变成第一个窗格。</li>\n<li><code>Ctrl+b x</code>：关闭当前窗格。☆</li>\n<li><code>Ctrl+b !</code>：将当前窗格拆分为一个独立窗口。</li>\n<li><code>Ctrl+b z</code>：当前窗格全屏显示，再使用一次会变回原来大小。</li>\n<li><code>Ctrl+b Ctrl+&lt;arrow key&gt;</code>：按箭头方向调整窗格大小。☆</li>\n<li><code>Ctrl+b q</code>：显示窗格编号。</li>\n</ul>\n</blockquote>\n<h2 id=\"5-1-划分窗格\"><a href=\"#5-1-划分窗格\" class=\"headerlink\" title=\"5.1 划分窗格\"></a>5.1 划分窗格</h2><p><code>tmux split-window</code>命令用来划分窗格。</p>\n<blockquote>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 划分上下两个窗格</span><br>$ tmux split-window<br><br><span class=\"hljs-comment\"># 划分左右两个窗格</span><br>$ tmux split-window -h<br></code></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"5-2-移动光标\"><a href=\"#5-2-移动光标\" class=\"headerlink\" title=\"5.2 移动光标\"></a>5.2 移动光标</h2><p><code>tmux select-pane</code>命令用来移动光标位置。</p>\n<blockquote>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 光标切换到上方窗格</span><br>$ tmux select-pane -U<br><br><span class=\"hljs-comment\"># 光标切换到下方窗格</span><br>$ tmux select-pane -D<br><br><span class=\"hljs-comment\"># 光标切换到左边窗格</span><br>$ tmux select-pane -L<br><br><span class=\"hljs-comment\"># 光标切换到右边窗格</span><br>$ tmux select-pane -R<br></code></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"5-3-交换窗格位置\"><a href=\"#5-3-交换窗格位置\" class=\"headerlink\" title=\"5.3 交换窗格位置\"></a>5.3 交换窗格位置</h2><p><code>tmux swap-pane</code>命令用来交换窗格位置。</p>\n<blockquote>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 当前窗格上移</span><br>$ tmux swap-pane -U<br><br><span class=\"hljs-comment\"># 当前窗格下移</span><br>$ tmux swap-pane -D<br></code></pre></td></tr></table></figure>\n</blockquote>\n<h1 id=\"窗口管理\"><a href=\"#窗口管理\" class=\"headerlink\" title=\"窗口管理\"></a>窗口管理</h1><h2 id=\"快捷键☆-2\"><a href=\"#快捷键☆-2\" class=\"headerlink\" title=\"快捷键☆\"></a>快捷键☆</h2><p>下面是一些窗口操作的快捷键。</p>\n<blockquote>\n<ul>\n<li><code>Ctrl+b c</code>：创建一个新窗口，状态栏会显示多个窗口的信息。</li>\n<li><code>Ctrl+b p</code>：切换到上一个窗口（按照状态栏上的顺序）。</li>\n<li><code>Ctrl+b n</code>：切换到下一个窗口。</li>\n<li><code>Ctrl+b &lt;number&gt;</code>：切换到指定编号的窗口，其中的<code>&lt;number&gt;</code>是状态栏上的窗口编号。</li>\n<li><code>Ctrl+b w</code>：从列表中选择窗口。</li>\n<li><code>Ctrl+b ,</code>：窗口重命名。</li>\n</ul>\n</blockquote>\n<h2 id=\"6-1-新建窗口\"><a href=\"#6-1-新建窗口\" class=\"headerlink\" title=\"6.1 新建窗口\"></a>6.1 新建窗口</h2><p><code>tmux new-window</code>命令用来创建新窗口。</p>\n<blockquote>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ tmux new-window<br><br><span class=\"hljs-comment\"># 新建一个指定名称的窗口</span><br>$ tmux new-window -n &lt;window-name&gt;<br></code></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"6-2-切换窗口\"><a href=\"#6-2-切换窗口\" class=\"headerlink\" title=\"6.2 切换窗口\"></a>6.2 切换窗口</h2><p><code>tmux select-window</code>命令用来切换窗口。</p>\n<blockquote>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 切换到指定编号的窗口</span><br>$ tmux select-window -t &lt;window-number&gt;<br><br><span class=\"hljs-comment\"># 切换到指定名称的窗口</span><br>$ tmux select-window -t &lt;window-name&gt;<br></code></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"6-3-重命名窗口\"><a href=\"#6-3-重命名窗口\" class=\"headerlink\" title=\"6.3 重命名窗口\"></a>6.3 重命名窗口</h2><p><code>tmux rename-window</code>命令用于为当前窗口起名（或重命名）。</p>\n<blockquote>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ tmux rename-window &lt;new-name&gt;<br></code></pre></td></tr></table></figure>\n</blockquote>\n<h1 id=\"Note\"><a href=\"#Note\" class=\"headerlink\" title=\"Note\"></a>Note</h1><h2 id=\"一些其他的快捷键\"><a href=\"#一些其他的快捷键\" class=\"headerlink\" title=\"一些其他的快捷键\"></a>一些其他的快捷键</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 列出所有快捷键，及其对应的 Tmux 命令</span><br>$ tmux list-keys<br><br><span class=\"hljs-comment\"># 列出所有 Tmux 命令及其参数</span><br>$ tmux list-commands<br><br><span class=\"hljs-comment\"># 列出当前所有 Tmux 会话的信息</span><br>$ tmux info<br><br><span class=\"hljs-comment\"># 重新加载当前的 Tmux 配置</span><br>$ tmux source-file ~/.tmux.conf<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"开启鼠标支持\"><a href=\"#开启鼠标支持\" class=\"headerlink\" title=\"开启鼠标支持\"></a>开启鼠标支持</h2><p>tmux2 以上版本和 tmux2 以上版本有所不同</p>\n<blockquote>\n<p>  查看版本<code>tmux -V</code></p>\n<p>  注意大写</p>\n</blockquote>\n<h3 id=\"tmux2-以上\"><a href=\"#tmux2-以上\" class=\"headerlink\" title=\"tmux2 以上\"></a>tmux2 以上</h3><p><strong>写入配置文件</strong></p>\n<p>在<code>~/.tmux.conf</code>中加入：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># Enable mouse mode (tmux 2.1 and above)</span><br><span class=\"hljs-built_in\">set</span> -g mouse on<br><br><span class=\"hljs-comment\"># Mouse based copy</span><br>bind-key -T copy-mode-vi MouseDragEnd1Pane send -X copy-pipe-and-cancel <span class=\"hljs-string\">&quot;reattach-to-user-namespace pbcopy&quot;</span><br>bind-key -T copy-mode MouseDragEnd1Pane send -X copy-pipe-and-cancel <span class=\"hljs-string\">&quot;reattach-to-user-namespace pbcopy&quot;</span> <br></code></pre></td></tr></table></figure>\n\n<p><strong>临时使用</strong></p>\n<p>按完前缀ctrl+B后，再按冒号：进入<code>命令行</code>模式，输入<code>set -g mouse on</code></p>\n<h3 id=\"tmux2-以下\"><a href=\"#tmux2-以下\" class=\"headerlink\" title=\"tmux2 以下\"></a>tmux2 以下</h3><p><strong>写入配置文件</strong></p>\n<p>在<code>~/.tmux.conf</code>中加入：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">setw -g mouse-resize-pane on<br>setw -g mouse-select-pane on<br>setw -g mouse-select-window on<br>setw -g mode-mouse on<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>  这几行的作用分别是:<br>  开启用鼠标拖动调节pane的大小（拖动位置是pane之间的分隔线）<br>  开启用鼠标点击pane来激活该pane<br>  开启用鼠标点击来切换活动window（点击位置是状态栏的窗口名称）<br>  开启window&#x2F;pane里面的鼠标支持（也即可以用鼠标滚轮回滚显示窗口内容，此时还可以用鼠标选取文本）</p>\n</blockquote>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ul>\n<li><a href=\"https://www.hamvocke.com/blog/a-quick-and-easy-guide-to-tmux/\">A Quick and Easy Guide to tmux</a></li>\n<li><a href=\"https://danielmiessler.com/study/tmux/\">Tactical tmux: The 10 Most Important Commands</a></li>\n<li><a href=\"https://linuxize.com/post/getting-started-with-tmux/\">Getting started with Tmux</a></li>\n<li><a href=\"https://www.ruanyifeng.com/blog/2019/10/tmux.html\">阮一峰</a></li>\n</ul>\n",
            "tags": [
                "linux",
                "tmux"
            ]
        },
        {
            "id": "https://www.oikiou.top/2022/a1ed3941/",
            "url": "https://www.oikiou.top/2022/a1ed3941/",
            "title": "我的工作法",
            "date_published": "2022-09-19T12:54:03.000Z",
            "content_html": "<h1 id=\"我的工作法\"><a href=\"#我的工作法\" class=\"headerlink\" title=\"我的工作法\"></a>我的工作法</h1><p><a href=\"https://unknwon.cn/2021/211013-boring-methodology-to-be-productive/\">高效工作法的朴素方法论 -By无闻</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/42694082\">逗总出品：GTD最全面教程，从入门到精通</a></p>\n<h1 id=\"出来玩最重要的是出来\"><a href=\"#出来玩最重要的是出来\" class=\"headerlink\" title=\"出来玩最重要的是出来\"></a>出来玩最重要的是出来</h1><p>不管今天一天做什么惊天地的大事, 第一步都是先起床.</p>\n<h2 id=\"花三分钟安排一天\"><a href=\"#花三分钟安排一天\" class=\"headerlink\" title=\"花三分钟安排一天\"></a>花三分钟安排一天</h2><p>每天开始，先梳理一遍今日视图里的所有任务</p>\n<p>梳理任务的关键在于对于自己实际的产出效率和可用时间上的正确评判</p>\n<h2 id=\"创造仪式感\"><a href=\"#创造仪式感\" class=\"headerlink\" title=\"创造仪式感\"></a>创造仪式感</h2><p>有的人喜欢喝咖啡, 比如倒好一杯咖啡之后就放下手机, 避免去接触任何和当前手上事务不相关的内容(放下手机并让它远离自己).</p>\n<h1 id=\"推送通知是互联网时代的毒药\"><a href=\"#推送通知是互联网时代的毒药\" class=\"headerlink\" title=\"推送通知是互联网时代的毒药\"></a>推送通知是互联网时代的毒药</h1><p>我注意到推送通知经常会带给人们焦虑的情绪，尤其是工作上的，我对此也深恶痛绝。</p>\n<ul>\n<li>在工作时间(专注的时间)关掉它们(尤其是手机), 别让他们打断你的工作节奏</li>\n</ul>\n<h1 id=\"异步沟通是健康的协作方式\"><a href=\"#异步沟通是健康的协作方式\" class=\"headerlink\" title=\"异步沟通是健康的协作方式\"></a>异步沟通是健康的协作方式</h1><p>实时沟通会打断各自的计划, 能够以异步沟通完成的事, 千万不要去同步沟通.  </p>\n<p>马斯克同样推崇异步沟通</p>\n<p><a href=\"https://www.youtube.com/watch?v=kLscv2VAQEE\">https://www.youtube.com/watch?v=kLscv2VAQEE</a></p>\n<h1 id=\"给自己放个假\"><a href=\"#给自己放个假\" class=\"headerlink\" title=\"给自己放个假\"></a>给自己放个假</h1><p>软件类属创造性工作，而人类大脑又是世界上最复杂、最精密的仪器。</p>\n<p>超时长工作并不会使得大脑变得更具创造性，因为每个机械师都知道零部件需要定期检查和维护。</p>\n<p><strong>恐怕你也无法想象你的航空公司会告诉你某架次飞机会因为长期没有检修而飞得更快吧？</strong></p>\n",
            "tags": [
                "life",
                "workflow"
            ]
        },
        {
            "id": "https://www.oikiou.top/2022/bc4a75ff/",
            "url": "https://www.oikiou.top/2022/bc4a75ff/",
            "title": "JPEG JPEG2000 WebP PNG GIF对比",
            "date_published": "2022-09-18T05:47:15.000Z",
            "content_html": "<h1 id=\"图像的显示原理\"><a href=\"#图像的显示原理\" class=\"headerlink\" title=\"图像的显示原理\"></a>图像的显示原理</h1><h2 id=\"有损-x2F-无损压缩\"><a href=\"#有损-x2F-无损压缩\" class=\"headerlink\" title=\"有损&#x2F;无损压缩\"></a>有损&#x2F;无损压缩</h2><p>图片文件格式有可能会对图片的文件大小进行不同程度的压缩，图片的压缩分为有损压缩和无损压缩两种。</p>\n<h3 id=\"有损压缩\"><a href=\"#有损压缩\" class=\"headerlink\" title=\"有损压缩\"></a>有损压缩</h3><p>对图像本身的改变，在保存图像时保留了较多的亮度信息，而将色相和色纯度的信息和周围的像素进行合并，合并的比例不同，压缩的比例也不同，由于信息量减少了，所以压缩比可以很高，图像质量也会相应的下降。并且这种损失是不可逆的，我们不可能从有一个有损压缩过的图片中恢复出全来的图片。常见的有损压缩手段，是按照一定的算法将临近的像素点进行合并。<br><strong>有损压缩的原理：</strong> <em>删除景物边缘的某些颜色部分，当人们在屏幕上观看这个场景图片，大脑会利用在景物上看到的颜色填补所丢失的颜色部分。</em><br><strong>有损压缩的优缺点：</strong> <em>是保持颜色的逐渐变化，删除图像中颜色的突然变化。生物学中的大量实验证明，人类大脑会利用与附近最接近的颜色来填补所丢失的颜色。例如，对于蓝色天空背景上的一朵白云，有损压缩的方法就是删除图像中景物边缘的某些颜色部分。当在·屏幕上看这幅图时，大脑会利用在景物上看到的颜色填补所丢失的颜色部分。利用有损压缩技术，某些数据被有意地删除了，而被取消的数据也不再恢复。 无可否认，利用有损压缩技术可以大大地压缩文件的数据，但是会影响图像质量。如果使用了有损压缩的图像仅在屏幕上显示，可能对图像质量影响不太大，至少对于人类眼睛的识别程度来说区别不大。可是，如果要把一幅经过有损压缩技术处理的图像用高分辨率打印机打印出来，那么图像质量就会有明显的受损痕迹。</em></p>\n<h3 id=\"无损压缩\"><a href=\"#无损压缩\" class=\"headerlink\" title=\"无损压缩\"></a>无损压缩</h3><p>无损压缩的基本原理是相同的颜色信息只需保存一次。压缩图像的软件首先会确定图像中哪些区域是相同的，哪些是不同的。包括了重复数据的图像(如蓝天) 就可以被压缩，只有蓝天的起始点和终结点需要被记录下来。但是蓝色可能还会有不同的深浅，天空有时也可能被树木、山峰或其他的对象掩盖，这些就需要另外记录。从本质上看，无损压缩的方法可以删除一些重复数据，大大减少要在磁盘上保存的图像尺寸。但是，无损压缩的方法并不能减少图像的内存占用量，这是因为，当从磁盘上读取图像时，软件又会把丢失的像素用适当的颜色信息填充进来。如果要减少图像占用内存的容量，就必须使用有损压缩方法。<br><strong>无损压缩的特点：</strong> <em>相同的颜色信息只需保存一次。</em><br><strong>无损压缩的原理：</strong> <em>首先辨别出相同颜色的区域，然后把这些相同的数据信息进行压缩记录，也就是记录它的颜色信息、起始和终止位置。</em></p>\n<h2 id=\"索引色-x2F-直接色\"><a href=\"#索引色-x2F-直接色\" class=\"headerlink\" title=\"索引色&#x2F;直接色\"></a>索引色&#x2F;直接色</h2><p>计算机在表示颜色的时候，有两种形式，一种称作索引颜色(Index Color)，一种称作直接颜色(Direct Color)。</p>\n<h3 id=\"索引色。\"><a href=\"#索引色。\" class=\"headerlink\" title=\"索引色。\"></a>索引色。</h3><p>是一种以有限的方式管理数字图像颜色的技术，以节省计算机内存和文件存储，同时加速显示刷新和文件传输。即用一个数字来代表（索引）一种颜色，在存储图片的时候，存储一个数字的组合，同时存储数字到图片颜色的映射。这种方式只能存储有限种颜色，通常是256种颜色，对应到计算机系统中，使用一个字节的数字来索引一种颜色。</p>\n<h3 id=\"直接色。\"><a href=\"#直接色。\" class=\"headerlink\" title=\"直接色。\"></a>直接色。</h3><p>使用四个数字来代表一种颜色，这四个数字分别代表这个颜色中红色、绿色、蓝色以及透明度（即rgba）。现在流行的显示设备可以在这四个维度分别支持256种变化，所以直接色可以表示2的32次方种颜色。当然并非所有的直接色都支持这么多种，为压缩空间使用，有可能只有表达红、绿、蓝的三个数字，每个数字也可能不支持256种变化之多</p>\n<h2 id=\"位图-x2F-矢量图\"><a href=\"#位图-x2F-矢量图\" class=\"headerlink\" title=\"位图&#x2F;矢量图\"></a>位图&#x2F;矢量图</h2><h3 id=\"位图。\"><a href=\"#位图。\" class=\"headerlink\" title=\"位图。\"></a>位图。</h3><p>位图也叫做点阵图，栅格图像，像素图。简单的说，就是最小单位由像素构成的图，缩放会失真。构成位图的最小单位是像素，位图就是由像素阵列的排列来实现其显示效果的，每个像素有自己的颜色信息，在对位图图像进行编辑操作的时候，可操作的对象是每个像素，我们可以改变图像的色相、饱和度、明度，从而改变图像的显示效果。举个例子来说，位图图像就好比在巨大的沙盘上画好的画，当你从远处看的时候，画面细腻多彩，但是当你靠的非常近的时候，你就能看到组成画面的每粒沙子以及每个沙粒单纯的不可变化颜色。</p>\n<h3 id=\"矢量图，\"><a href=\"#矢量图，\" class=\"headerlink\" title=\"矢量图，\"></a>矢量图，</h3><p>也叫做向量图。矢量图并不纪录画面上每一点的信息，而是纪录了元素形状及颜色的算法，当你打开一付矢量图的时候，软件对图形象对应的函数进行运算，将运算结果[图形的形状和颜色]显示给你看。无论显示画面是大还是小，画面上的对象对应的算法是不变的，所以，即使对画面进行倍数相当大的缩放，其显示效果仍然相同(不失真)。</p>\n<h1 id=\"JPEG-JPEG2000-WebP\"><a href=\"#JPEG-JPEG2000-WebP\" class=\"headerlink\" title=\"JPEG JPEG2000 WebP\"></a>JPEG JPEG2000 WebP</h1><blockquote>\n<p>  摘录自知乎: </p>\n<p>  原文: <a href=\"https://zhuanlan.zhihu.com/p/19586108\">https://zhuanlan.zhihu.com/p/19586108</a></p>\n<p>  作者: <a href=\"https://www.zhihu.com/people/xhacker\">柳东原</a> This Xhacker has super Big Cat power.</p>\n</blockquote>\n<p><strong>压缩性能综合看来，WebP 略好于 JPEG2000，而这两者都明显好于 JPEG。</strong></p>\n<p>前段时间测试了一下这三种有损图像压缩算法的质量。（WebP 也能支持无损，不过这里只测试有损。）</p>\n<p>测试结果（<a href=\"https://link.zhihu.com/?target=http://en.wikipedia.org/wiki/Structural_similarity\">SSIM Index</a> 可理解为图片与原图片的相似度）：</p>\n<p><img src=\"/2022/bc4a75ff/6dd37790364b1a5e709f8e67adab81d3_r.jpg\" alt=\"img\"></p>\n<p><img src=\"/2022/bc4a75ff/868c8f801447ee85c0867556cdb1f705_r.jpg\" alt=\"img\"></p>\n<p><img src=\"/2022/bc4a75ff/85ab2ef874126a10072e4669d9cd7c90_720w.jpg\" alt=\"img\"></p>\n<p><img src=\"/2022/bc4a75ff/ea62d92a63b45aa121eb0ccfce4a97fd_720w.jpg\" alt=\"img\"></p>\n<p><img src=\"/2022/bc4a75ff/6cdab6a9efdf3df3fba2657314d81734_720w.jpg\" alt=\"img\"></p>\n<p><img src=\"/2022/bc4a75ff/323465387e562470441127b8f0cc992e_720w.jpg\" alt=\"img\"></p>\n<p>测试细节：对于 JPEG 使用 libjpeg 压缩，JPEG 2000 使用 OpenJPEG，WebP 使用 libwebp。</p>\n<h1 id=\"JPEG-PNG-GIF-WEBP\"><a href=\"#JPEG-PNG-GIF-WEBP\" class=\"headerlink\" title=\"JPEG PNG GIF WEBP\"></a>JPEG PNG GIF WEBP</h1><p><strong>综合看来</strong></p>\n<ul>\n<li>PNG 可以保存透明信息, 比较适合颜色单一, 主要是纯色的图像, ( logo&#x2F;icon&#x2F;透明图 )</li>\n<li>JPEG 适用颜色种类多样 且颜色变化明显的图片 ( 一般照片 )</li>\n<li>GIF 支持动画,透明, 只有8位颜色 ( 动图 )</li>\n<li>WEBP 文件小, 支持透明, 有损无损压缩, 支持动画, 兼容性不好 ( 网页图像 )</li>\n</ul>\n<h2 id=\"JPEG\"><a href=\"#JPEG\" class=\"headerlink\" title=\"JPEG\"></a>JPEG</h2><p>JPEG是有损的、采用直接色的、位图。JPEG也是一种针对照片影像而广泛使用的有损压缩标准方法。JPEG图片格式的设计目标，是在不影响人类可分辨的图片质量的前提下，尽可能的压缩文件大小。这意味着JPEG去掉了一部分图片的原始信息，也即是进行了有损压缩。JPEG的图片的优点，是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，用来表达更生动的图像效果，比如颜色渐变。</p>\n<ul>\n<li>特性：适用于存储色彩丰富、层次分明的图片，不适合于线条绘图（drawing）和其他文字或图标（iconic）的图形，因为它的压缩方法用在这些类型的图形上，得到的结果并不好(PNG和GIF通常是用来存储这类的图形)</li>\n</ul>\n<h2 id=\"PNG\"><a href=\"#PNG\" class=\"headerlink\" title=\"PNG\"></a>PNG</h2><p>便携式网络图形是一种无损压缩的位图图形格式，支持索引、灰度、RGB三种颜色方案以及Alpha通道等特性</p>\n<ul>\n<li>特性：如果保存文本，线条或类似的边缘清晰，有大块相同颜色区域的图像，PNG格式的压缩效果就要比JPEG好很多，并且不会出现JPEG那样的高对比度区域的图像有损。如果图像既有清晰边缘，又有照片图像的特点，就需要在这两种格式之间权衡一下了。JPEG不支持透明度。<br>PNG格式有8位、24位、32位三种形式,其中8位PNG支持两种不同 的透明形式（索引透明和alpha透明）,24位PNG不支持透明,32位 PNG 在24位基础上增加了8位透明通道（32-24&#x3D;&#x3D;&#x3D;8）,因此可展现256级透明程度。</li>\n</ul>\n<h3 id=\"PNG8\"><a href=\"#PNG8\" class=\"headerlink\" title=\"PNG8\"></a>PNG8</h3><p>PNG8是<strong>无损的、使用索引色的、点阵图</strong>,支持不透明、索引透明、Alpha透明，都最多只能展示256（2的8次方）种颜色，所以“PNG8”格式更适合那些颜色比较单一的图像，例如纯色、logo、图标等；因为颜色数量少，所以图片的体积也会更小；</p>\n<ul>\n<li><p>PNG8(不透明),默认PNG8</p>\n</li>\n<li><p>PNG8(索引色透明),简单说可以理解为静态的GIF<br>指定一个像素点是不是透明<br>但是PNG由于算法的优势,体积比较少<br>所以,静态GIF完全可用PNG8取代</p>\n</li>\n<li><p>PNG8(Alpha透明),牛逼在可指定像素点的透明度,例如50%透明度<br>这种优点在于比PNG24&#x2F;32体积小,因为也只有256色嘛<br>缺点在于IE6支持不好,会把半透明的像素点显示成全透明</p>\n</li>\n</ul>\n<h3 id=\"PNG24\"><a href=\"#PNG24\" class=\"headerlink\" title=\"PNG24\"></a>PNG24</h3><p>是PNG的直接色版本。PNG24是<strong>无损的、使用直接色的、点阵图</strong>,支持2的24次方种颜色，表现为不透明。用三个8bits分别去表示 R（红）、G（绿）、B（蓝）。R(0255),G(0255),B(0~255)，可以表达256乘以256乘以256&#x3D;16777216种颜色的图片，这样PNG24就能比PNG8表示色彩更丰富的图片,图片的清晰度也会更好，图片质量更高，当然图片的大小也会相应增加，所以“PNG24”的图片比较适合像摄影作品之类颜色比较丰富的图片<br>PNG24与JPG一样能表达丰富的图片细节，但并不能替代JPG。图片存储为PNG24比存储为JPG，文件大小至少是JPG的5倍，但在图片品质上的提升却微乎其微。所以除非对品质的要求极高，否则色彩丰富的网络图片还是推荐使用JPG</p>\n<h3 id=\"PNG32\"><a href=\"#PNG32\" class=\"headerlink\" title=\"PNG32\"></a>PNG32</h3><p>支持2的32次方种颜色，32位是我们最常使用的格式，它是在PNG在24位的PNG基础上增加了8位的透明信息，支持不同程度的半透效果</p>\n<h3 id=\"PNG8-PNG24-PNG32三者的区别在于：\"><a href=\"#PNG8-PNG24-PNG32三者的区别在于：\" class=\"headerlink\" title=\"PNG8\\PNG24\\PNG32三者的区别在于：\"></a>PNG8\\PNG24\\PNG32三者的区别在于：</h3><ul>\n<li>PNG-32每个像素的深度为32bits，其中RGBA四个通道各占8bits。所谓的RGBA四个通道，就是红，绿，蓝，透明 这四种色值各自的大小，都用8bits来表示（0～255）。</li>\n<li>PNG-24的像素深度为24bits，其中RGB三个通道各占8bits。</li>\n<li>PNG-8则是使用8位的索引色。</li>\n</ul>\n<h2 id=\"GIF\"><a href=\"#GIF\" class=\"headerlink\" title=\"GIF\"></a>GIF</h2><p>GIF是一种<strong>无损、使用于索引色的、位图</strong>。由于采用了无损压缩，相比古老的bmp格式，尺寸较小，而且支持透明和动画。缺点是由于gif只存储8位索引（也就是最多能表达2^8&#x3D;256种颜色），色彩复杂、细节丰富的图片不适合保存为gif格式。色彩简单的logo、icon、线框图适合采用gif格式。</p>\n<p>静态GIF完全可用PNG8取代</p>\n<h2 id=\"WEBP\"><a href=\"#WEBP\" class=\"headerlink\" title=\"WEBP\"></a>WEBP</h2><p>WebP图片是一种同时提供了<strong>有损压缩与无损压缩、使用直接色的、位图</strong>，由Google开发。与png、jpg相比，相同的视觉体验下，WebP图像的尺寸缩小了大约30％。另外，WebP图像格式还支持有损压缩、无损压缩、透明和动画。理论上完全可以替代png、jpg、gif等图片格式，当然目前webp的还没有得到全面的支持。</p>\n<p>WEBP与PNG压缩对比</p>\n<p><img src=\"/2022/bc4a75ff/formatpng.png\" alt=\"img\"></p>\n<p>可以得出结论：</p>\n<blockquote>\n<p>  PNG 转 WebP 的压缩率要高于 PNG 原图压缩率，同样支持有损与无损压缩<br>  转换后的 WebP 体积大幅减少，图片质量也得到保障（同时肉眼几乎无法看出差异）<br>  转换后的 WebP 支持 Alpha 透明和 24-bit 颜色数，不存在 PNG8 色彩不够丰富和在浏览器中可能会出现毛边的问题</p>\n</blockquote>\n",
            "tags": [
                "jpeg",
                "webp",
                "jpeg2000",
                "image"
            ]
        },
        {
            "id": "https://www.oikiou.top/2022/631793c8/",
            "url": "https://www.oikiou.top/2022/631793c8/",
            "title": "文件后缀与文件",
            "date_published": "2022-09-15T09:47:15.000Z",
            "content_html": "<h1 id=\"文件后缀与文件\"><a href=\"#文件后缀与文件\" class=\"headerlink\" title=\"文件后缀与文件\"></a>文件后缀与文件</h1><table>\n<thead>\n<tr>\n<th>后缀</th>\n<th>名称描述</th>\n<th>简述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>.DS_Store</code></td>\n<td>Desktop Services Store</td>\n<td>Mac OS X操作系统所创造的隐藏文件，类似<code>desktop.ini</code></td>\n</tr>\n</tbody></table>\n<h2 id=\"编辑历史\"><a href=\"#编辑历史\" class=\"headerlink\" title=\"编辑历史\"></a>编辑历史</h2><table>\n<thead>\n<tr>\n<th>date</th>\n<th>note</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>2022.9.15</td>\n<td>First Version</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"DS-Store\"><a href=\"#DS-Store\" class=\"headerlink\" title=\".DS_Store\"></a>.DS_Store</h2><blockquote>\n<p>  DS_Store，英文全称是 Desktop Services Store（桌面服务存储），开头的 DS 是 Desktop Services（桌面服务） 的缩写。它是一种由macOS系统自动创建的隐藏文件，存在于每一个用「Finder」打开过的文件夹下面。</p>\n<p>  <code>.DS_Store</code> 是一种由苹果公司的Mac OS X操作系统所创造的隐藏文件，目的在于存贮目录的自定义属性，例如文件们的图标位置或者是背景色的选择。该文件由<code>Finder</code>创建并维护，类似于<code>Microsoft Windows</code>中的<code>desktop.ini</code>文件。</p>\n</blockquote>\n<h2 id=\"RTF\"><a href=\"#RTF\" class=\"headerlink\" title=\".RTF\"></a>.RTF</h2><blockquote>\n<p>  <strong>富文本格式</strong>（<strong>Rich Text Format</strong>）即<strong>RTF格式</strong>，又称<strong>多文本格式</strong>，是由<a href=\"https://zh.wikipedia.org/wiki/%E5%BE%AE%E8%BD%AF\">微软</a>公司开发的跨平台<a href=\"https://zh.wikipedia.org/wiki/%E6%96%87%E6%A1%A3\">文档</a>格式。大多数的<a href=\"https://zh.wikipedia.org/wiki/%E6%96%87%E5%AD%97%E5%A4%84%E7%90%86\">文字处理</a>软件都能读取和保存RTF文档。</p>\n<h2 id=\"支持软件\"><a href=\"#支持软件\" class=\"headerlink\" title=\"支持软件\"></a>支持软件</h2><ul>\n<li><a href=\"https://zh.wikipedia.org/wiki/WordPad\">WordPad</a>（<a href=\"https://zh.wikipedia.org/wiki/Microsoft_Windows\">Microsoft Windows</a>）&#x2F; <a href=\"https://zh.wikipedia.org/wiki/%E6%96%87%E5%AD%97%E7%B7%A8%E8%BC%AF_(%E6%87%89%E7%94%A8%E7%A8%8B%E5%BC%8F)\">文本编辑</a>（<a href=\"https://zh.wikipedia.org/wiki/Mac_OS\">Mac OS</a>）</li>\n<li><a href=\"https://zh.wikipedia.org/wiki/Microsoft_Word\">Microsoft Word</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/Apache_OpenOffice\">Apache OpenOffice</a> &#x2F; <a href=\"https://zh.wikipedia.org/wiki/LibreOffice\">LibreOffice</a></li>\n<li><a href=\"https://zh.wikipedia.org/zh-cn/WPS_Office\">WPS Office</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/EIOffice\">EIOffice</a></li>\n</ul>\n</blockquote>\n",
            "tags": [
                "DS_Store",
                "rtf",
                "后缀"
            ]
        },
        {
            "id": "https://www.oikiou.top/2022/613d8edd/",
            "url": "https://www.oikiou.top/2022/613d8edd/",
            "title": "Zip Gzip Bzip2 Tar 的区别和差异",
            "date_published": "2022-09-14T16:20:15.000Z",
            "content_html": "<h1 id=\"zip-gzip-bzip2-tar-命令的区别和差异\"><a href=\"#zip-gzip-bzip2-tar-命令的区别和差异\" class=\"headerlink\" title=\"zip gzip bzip2 tar 命令的区别和差异\"></a>zip gzip bzip2 tar 命令的区别和差异</h1><ul>\n<li><code>gzip</code> 和 <code>bzip2</code>用于压缩单个文件。bzip2 比 gzip 具有更高的压缩率，同样的也会需要<strong>更多更多更多</strong>时间来进行压缩。</li>\n<li><code>tar</code>格式的包只是将文件归档在一起, 并不会有任何压缩。</li>\n<li><code>zip</code> 和 <code>tar</code> 命令用于压缩和归档文件夹。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>zip</td>\n<td><code>.zip</code></td>\n<td>可以压缩目录</td>\n<td>源文件会保留</td>\n<td>专门的压缩命令</td>\n</tr>\n<tr>\n<td>gzip</td>\n<td><code>.gz</code></td>\n<td>只能压缩文件</td>\n<td>压缩后源文件会被删除</td>\n<td></td>\n</tr>\n<tr>\n<td>bzip2</td>\n<td><code>.bz2</code></td>\n<td>只能压缩文件</td>\n<td>加<code>-k</code>参数源文件可以保留</td>\n<td></td>\n</tr>\n<tr>\n<td>tar</td>\n<td><code>.tar</code></td>\n<td>可以压缩目录</td>\n<td>源文件会保留</td>\n<td>linux包大多是这形态<br>将目录打包成一个文件<code>Tape archive</code></td>\n</tr>\n<tr>\n<td>xz</td>\n<td><code>.xz</code></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"zip\"><a href=\"#zip\" class=\"headerlink\" title=\"zip\"></a>zip</h2><h2 id=\"gzip\"><a href=\"#gzip\" class=\"headerlink\" title=\"gzip\"></a>gzip</h2><p>该<code>gzip</code>程序用于压缩一个或多个文件。执行时，它将原始文件替换为原始文件的压缩版本。使用 gzip 压缩的文件具有扩展名<code>.gz</code></p>\n<h2 id=\"bzip2\"><a href=\"#bzip2\" class=\"headerlink\" title=\"bzip2\"></a>bzip2</h2><p>该<code>bzip2</code>命令类似于 gzip，但使用不同的压缩算法，以牺牲压缩速度为代价归档更高级别的压缩。使用 bzip2 压缩的文件具有扩展名<code>.bz2</code></p>\n<h2 id=\"tar\"><a href=\"#tar\" class=\"headerlink\" title=\"tar\"></a>tar</h2><p><code>tar</code>命令，首字母缩略词<em><strong>Tape archive</strong></em>用于创建存档文件。tar 存档可以由单独的文件、一个或多个目录层次结构或两者的混合组成。tar 文件有扩展名<code>.tar</code></p>\n<h2 id=\"xz\"><a href=\"#xz\" class=\"headerlink\" title=\"xz\"></a>xz</h2><p><code>xz</code>是一个通用的数据压缩工具，命令行语法类似于 gzip 和 bzip2 。它根据选择的操作模式压缩或解压缩每个文件。用 xz 压缩的文件具有扩展名<code>.xz</code></p>\n<h1 id=\"Zip-和-Unzip\"><a href=\"#Zip-和-Unzip\" class=\"headerlink\" title=\"Zip 和 Unzip\"></a>Zip 和 Unzip</h1><h2 id=\"zip-1\"><a href=\"#zip-1\" class=\"headerlink\" title=\"zip\"></a>zip</h2><p><strong>命令格式</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">zip [-r] [压缩后文件名] [文件或目录]<br></code></pre></td></tr></table></figure>\n\n<p><strong>命令描述</strong></p>\n<ul>\n<li><code>zip</code>命令用来对文件进行打包操作。zip是个使用广泛的压缩程序，文件经它压缩后会另外产生具有“.zip”扩展名的压缩文件；</li>\n<li>在linux压缩后的文件，基本都可以在Windows系统中解压；Windows中压缩的文件，在Linux中不一定可用，但是zip格式的压缩文件，可以做到可用；</li>\n<li>zip的压缩比不是很高；</li>\n</ul>\n<p><strong>示例</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 压缩文件</span><br>$ zip a.zip a.txt<br><span class=\"hljs-comment\"># 查看压缩后的文件</span><br>$ <span class=\"hljs-built_in\">ls</span><br>a.txt  a.zip  <br><br><span class=\"hljs-comment\"># 2. -r：压缩文件夹</span><br>$ zip -r test.zip testDir/<br>$ <span class=\"hljs-built_in\">ls</span><br>testDir  test.zip<br><br><span class=\"hljs-comment\"># 3. -x 排除文件</span><br>$ zip -r test2.zip testDir/ -x <span class=\"hljs-string\">&quot;testDir/hello*&quot;</span> -x <span class=\"hljs-string\">&quot;testDir/dir/*&quot;</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"unzip-解压\"><a href=\"#unzip-解压\" class=\"headerlink\" title=\"unzip 解压\"></a>unzip 解压</h2><p><strong>命令格式</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">unzip [选项] 文件名<br></code></pre></td></tr></table></figure>\n\n<p><strong>命令描述</strong></p>\n<p><code>unzip</code>命令用于解压缩由zip命令压缩的“.zip”压缩包。</p>\n<p><strong>选项</strong></p>\n<ul>\n<li>-n：解压缩时不要覆盖原有的文件；</li>\n<li>-o：不必先询问用户，unzip执行后覆盖原有的文件；</li>\n<li>-d &lt;目录&gt;：指定文件解压缩后所要存储的目录(不指定目录，默认解压到当前目录)</li>\n</ul>\n<p><strong>示例</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 解压文件到家目录</span><br>$ unzip test.zip -d ~<br></code></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"Gzip-和-Gunzip\"><a href=\"#Gzip-和-Gunzip\" class=\"headerlink\" title=\"Gzip 和 Gunzip\"></a>Gzip 和 Gunzip</h1><h2 id=\"gzip-1\"><a href=\"#gzip-1\" class=\"headerlink\" title=\"gzip\"></a><strong>gzip</strong></h2><p><strong>命令格式</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">gzip [文件]<br></code></pre></td></tr></table></figure>\n\n<p><strong>命令描述</strong></p>\n<p><code>gzip</code>命令 用来压缩文件。gzip是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多处“<code>.gz</code>”扩展名。<code>gzip</code>只能压缩文件，不能压缩文件夹，压缩后原文件会被删除</p>\n<p><code>gzip</code>是在Linux系统中经常使用的一个对文件进行压缩和解压缩的命令，既方便又好用。gzip不仅可以用来压缩大的、较少使用的文件以节省磁盘空间，还可以和tar命令一起构成Linux操作系统中比较流行的压缩文件格式。据统计，gzip命令对文本文件有60%～70%的压缩率。减少文件大小有两个明显的好处，一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间。</p>\n<p><strong>示例</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 压缩文件</span><br>$ gzip a.txt<br><span class=\"hljs-comment\"># 查看压缩后的文件，源文件被删除</span><br>$ <span class=\"hljs-built_in\">ls</span><br>a.txt.gz<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"gunzip-解压\"><a href=\"#gunzip-解压\" class=\"headerlink\" title=\"gunzip 解压\"></a>gunzip 解压</h2><p><strong>命令格式</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">gzip [文件]<br></code></pre></td></tr></table></figure>\n\n<p><strong>命令描述</strong></p>\n<p><code>gunzip</code>命令用来解压缩文件。gunzip是个使用广泛的解压缩程序，它用于解开被gzip压缩过的文件，这些压缩文件预设最后的扩展名为<code>.gz</code>。</p>\n<p><strong>示例</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 解压文件，解压后压缩文件被删除</span><br>$ gunzip a.txt.gz<br>$ <span class=\"hljs-built_in\">ls</span><br>a.txt <br></code></pre></td></tr></table></figure>\n\n<h1 id=\"Bzip2\"><a href=\"#Bzip2\" class=\"headerlink\" title=\"Bzip2\"></a>Bzip2</h1><h2 id=\"bzip2-1\"><a href=\"#bzip2-1\" class=\"headerlink\" title=\"bzip2\"></a>bzip2</h2><p><strong>命令格式</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">bzip2 [选项] [文件]<br></code></pre></td></tr></table></figure>\n\n<p><strong>命令描述</strong></p>\n<ul>\n<li>bzip2命令用于压缩“<code>.bz2</code>”格式的压缩包，是<code>gzip</code>的升级版本，可以保留原文件；</li>\n<li>bzip2的压缩比比较高，可用于压缩较大文件的压缩；</li>\n<li>bzip2也是只对文件进行压缩，如果相对目录进行压缩的话，可以配合 <code>tar</code>命令使用，使用 <code>tar -jcvf</code> 文件名 完成打包压缩。</li>\n</ul>\n<p><strong>选项</strong></p>\n<p>-k（keep）：保留原文件（不删除原文件）</p>\n<p><strong>示例</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># bzip2 压缩文件</span><br>$ bzip2 -k a.txt<br>$ <span class=\"hljs-built_in\">ls</span><br>a.txt  a.txt.bz2<br><br><span class=\"hljs-comment\"># 配合使用tar 命令，完成打包压缩</span><br>$ <span class=\"hljs-built_in\">mkdir</span> music<br>$ tar -jcvf music.tar.bz2 music/<br>$ <span class=\"hljs-built_in\">ls</span><br>music  music.tar.bz2<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"bunzip2-解压\"><a href=\"#bunzip2-解压\" class=\"headerlink\" title=\"bunzip2 解压\"></a>bunzip2 解压</h2><p><strong>命令格式</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">bunzip2 [选项] [文件]<br></code></pre></td></tr></table></figure>\n\n<p><strong>命令描述</strong></p>\n<ul>\n<li>解压缩“<code>.bz2</code>”格式的压缩文件；</li>\n<li>gunzip的升级版，可以使用<code>-k</code>保留原文件；</li>\n<li>可以配合使用tar命令，完成解压缩解包： <code>tar -jxvf 文件名</code></li>\n</ul>\n<p><strong>选项</strong></p>\n<p>-k（keep）：保留原文件（不删除原文件）</p>\n<p><strong>示例</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ <span class=\"hljs-built_in\">ls</span><br>a.txt.bz2  music.tar.bz2<br><br><span class=\"hljs-comment\"># 解压缩文件</span><br>$ bunzip2 -k a.txt.bz2<br>$ <span class=\"hljs-built_in\">ls</span><br>a.txt  a.txt.bz2  music.tar.bz2<br><br><span class=\"hljs-comment\"># 使用tar完成解压解包</span><br>$ tar -jxvf music.tar.bz2<br>$ <span class=\"hljs-built_in\">ls</span><br>a.txt  a.txt.bz2  music  music.tar.bz2<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"tar-1\"><a href=\"#tar-1\" class=\"headerlink\" title=\"tar\"></a>tar</h1><h2 id=\"tar-2\"><a href=\"#tar-2\" class=\"headerlink\" title=\"tar\"></a>tar</h2><p><strong>命令格式</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">tar [选项] [压缩后文件名] [目录]<br></code></pre></td></tr></table></figure>\n\n<p><strong>命令描述</strong></p>\n<p>打包目录，将目录打包成一个文件，同时可以压缩，压缩后的拓展名为<code>.tar.gz</code>，这个拓展名在下载Linux相关安装包时很常见。</p>\n<p>使用<code>tar</code>命令时，如果想要打包并压缩一个目录，可以有两种方法进行：</p>\n<ol>\n<li>先利用tar命令打包目录为一个文件，然后使用gzip压缩</li>\n<li>直接利用tar命令打包并压缩 (简单方便，推荐使用)</li>\n</ol>\n<p>解压时也有两种方式：</p>\n<ol>\n<li>先使用gunzip解压缩，再使用tar解包</li>\n<li>直接利用tar命令解压缩并解包 (简单方便，推荐使用)</li>\n</ol>\n<p><strong>选项</strong></p>\n<ul>\n<li>-c：打包(将所有文件变成一个文件 Create  a new archive)</li>\n<li>-x：解包</li>\n<li>-v：显示详细信息</li>\n<li>-f：指定文件名</li>\n<li>-z：打包同时压缩&#x2F;解压缩  ，gzip压缩</li>\n<li>-j：生成压缩文件 ，bzip2压缩</li>\n</ul>\n<p><strong>示例</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 压缩</span><br>tar -zcvf movie2.tar.gz movie<br><span class=\"hljs-comment\"># 解压</span><br>tar -zxvf movie2.tar.gz<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 1、2为    打包压缩    的两种方法</span><br><span class=\"hljs-comment\"># 1. 使用 tar -cvf 打包，然后使用gzip压缩</span><br>$ tar -cvf movie.tar movie/<br>$ <span class=\"hljs-built_in\">ls</span><br>movie  movie.tar<br>$ gzip movie.tar<br>$ <span class=\"hljs-built_in\">ls</span><br>movie  movie.tar.gz<br><br><span class=\"hljs-comment\"># 2. 使用 tar -zcvf 打包并压缩</span><br>$ tar -zcvf movie2.tar.gz movie<br>$ <span class=\"hljs-built_in\">ls</span><br>movie  movie2.tar.gz<br><br><span class=\"hljs-comment\"># 3、4为     解压缩并解包     的两种方法</span><br><span class=\"hljs-comment\"># 3. 先使用gunzip解压缩，然后 tar -xvf解包</span><br>$ gunzip movie.tar.gz<br>$ <span class=\"hljs-built_in\">ls</span><br>movie2.tar.gz  movie.tar<br>$ tar -xvf movie.tar<br>movie/<br>$ <span class=\"hljs-built_in\">ls</span><br>movie  movie2.tar.gz  movie.tar<br><br><span class=\"hljs-comment\"># 4. 使用tar -zxvf 解压缩并解包</span><br>$ tar -zxvf movie2.tar.gz<br>$ <span class=\"hljs-built_in\">ls</span><br>movie  movie2.tar.gz  movie.tar<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://techviewleo.com/compress-uncompress-files-tar-gzip-bzip2-xz-linux/\">LPIC 101 – Compress and Uncompress Files Using tar, gzip, bzip2 and xz on Linux</a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/List_of_archive_formats#Comparison\">List of archive formats</a></p>\n",
            "tags": [
                "zip",
                "gzip",
                "bzip",
                "tar"
            ]
        },
        {
            "id": "https://www.oikiou.top/2022/45a589a3/",
            "url": "https://www.oikiou.top/2022/45a589a3/",
            "title": "MD5",
            "date_published": "2022-09-14T14:57:15.000Z",
            "content_html": "<h1 id=\"MD5\"><a href=\"#MD5\" class=\"headerlink\" title=\"MD5\"></a>MD5</h1><p><strong>MD5消息摘要算法</strong>（英语：MD5 Message-Digest Algorithm），一种被广泛使用的<a href=\"https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A2%BC%E9%9B%9C%E6%B9%8A%E5%87%BD%E6%95%B8\">密码散列函数</a>，可以产生出一个128位（16个字符(BYTES)）的散列值（hash value），用于确保信息传输完整一致。将<a href=\"https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE\">数据</a>（如一段文字）运算变为另一固定长度值，是散列算法的基础原理。</p>\n<p><strong>参考</strong></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/121492822\">MD5破解的几种方法</a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/MD5\">Wiki MD5</a></p>\n<h1 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h1><ul>\n<li><p>不可逆向的</p>\n<blockquote>\n<p>  我们没办法把MD5码还原对应的原文。道理很简单，任意长度的数据经过MD5处理后，所包含的信息量已经大大减少，那是不可能再次还原成为原始信息的。</p>\n</blockquote>\n</li>\n<li><p>原文中作一个小变化其散列也会发生巨大的变化</p>\n<blockquote>\n  <figure class=\"highlight excel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs excel\"><span class=\"hljs-symbol\">MD5</span>(<span class=\"hljs-string\">&quot;The quick brown fox jumps over the lazy dog&quot;</span>)<br>= <span class=\"hljs-number\">9</span>e107d9d372bb6826bd81d3542a419d6<br></code></pre></td></tr></table></figure>\n\n<p>  比如用c取代d, 其MD5值发生了巨大的变化</p>\n  <figure class=\"highlight excel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs excel\"><span class=\"hljs-symbol\">MD5</span>(<span class=\"hljs-string\">&quot;The quick brown fox jumps over the lazy cog&quot;</span>)<br>= <span class=\"hljs-number\">1055</span>d3e698d289f2af8663725127bd4b<br></code></pre></td></tr></table></figure>\n</blockquote>\n</li>\n<li><p>已被破解</p>\n<blockquote>\n<p>  通俗点讲就是，可以找到一个A和一个B，使hash（A）&#x3D;hash（B），而真正有用的是给定一个A能得到B，使hash（A）&#x3D;hash（B），而王小云能做到这样</p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h1><p>MD5 摘要已在<a href=\"https://en.wikipedia.org/wiki/Software\">软件</a>世界中广泛使用，以确保传输的文件已完好无损地到达。例如，文件服务器通常会为文件提供预先计算的 MD5（称为<a href=\"https://en.wikipedia.org/wiki/Md5sum\">md5sum</a>）<a href=\"https://en.wikipedia.org/wiki/Checksum\">校验和</a>，以便用户可以将下载文件的校验和与其进行比较。</p>\n<p><img src=\"/2022/45a589a3/350px-CPT-Hashing-File-Transmission.png\" alt=\"350px-CPT-Hashing-File-Transmission.svg\"></p>\n<p>由于很容易产生 MD5 冲突，因此创建文件的人可能会创建具有相同校验和的第二个文件，因此该技术无法防止某些形式的恶意篡改。</p>\n<p>在某些情况下，校验和是不可信的（例如，如果它是通过与下载文件相同的渠道获得的，他人可能修改了文件后再次修改了MD5，使得MD5并不可信），在这种情况下，MD5 只能提供错误检查功能：“它会识别损坏或不完整的下载，这变成下载较大文件时更有可能。”</p>\n<h1 id=\"破解\"><a href=\"#破解\" class=\"headerlink\" title=\"破解\"></a>破解</h1><h2 id=\"穷举法-amp-字典法\"><a href=\"#穷举法-amp-字典法\" class=\"headerlink\" title=\"穷举法&amp;字典法\"></a>穷举法&amp;字典法</h2><p><strong>穷举法非常简单，就是不停地尝试各种字符的排列组合，看哪一个组合的MD5码能对上。</strong>可惜缺点是太耗费时间了。我们举个栗子，假设我们要破解一个6位大小写字母和数字混合的密码，那么一共有(26+26+10)<sup>6</sup> 种组合。这个数的大小超过500亿。</p>\n<p>既然计算如此费时，能不能考虑<strong>把计算结果以映射表的形式存放起来，一个萝卜一个坑</strong>，一个原文对应着一个MD5码呢？可以呀！这就是传说中的“字典法”。将已知的MD5码查表，直接反查出原文。<strong>字典法体现了算法设计的“以空间换时间”的思想。</strong>缺点是比较耗费空间。不过现在硬盘的价格变得白菜价了，空间开销不算什么。</p>\n<p><a href=\"https://www.cmd5.com/password.aspx\">CMD5 反查网站</a></p>\n<p><a href=\"https://www.somd5.com/\">SMD5 反查网站</a></p>\n<h2 id=\"哈希链表-amp-彩虹表法\"><a href=\"#哈希链表-amp-彩虹表法\" class=\"headerlink\" title=\"哈希链表&amp;彩虹表法\"></a>哈希链表&amp;彩虹表法</h2><blockquote>\n<p>  如果说穷举法太耗费时间，字典法太耗费存储空间的话，我们能不能考虑在时间消耗和空间消耗之间折中呢？我们可以考虑用链表将一系列有意义的原文和MD5码串起来。</p>\n<p>  要构造这样的链表，我们需要两个函数：哈希函数H(x)和衰减函数（reduction function）R(x)。哈希函数可以是MD5，也可以是其他的消息摘要算法。H(x)的值域是R(x)的定义域，R(x)的值域是H(x)的定义域。<strong>R(x)不是H(x)的反函数。</strong></p>\n<p>  将一个原文不停地使用H(x)和R(x)交替进行运算k次，再将原文本身和运算结果以链表的形式串接起来，就可以得到结点个数为2k+1的链表。实际存放的时候只存放首端和末端两个原文即可。<strong>这种链表叫做“哈希链表”，体现了算法设计的“时空权衡”（Space and Time Tradeoffs）。</strong></p>\n<p>  举个栗子，假设原文s&#x3D;abcabc，经过2次交替运算，得到以下的链表：</p>\n<p>  abcabc-&gt;H(x)-&gt;3C8B0D7A-&gt;R(x)-&gt;eopmca-&gt;H(x)-&gt;7E9F216C-&gt;R(x)-&gt;rapper</p>\n<p>  以上数据均为举例编造的，仅为说明原理使用。那我们存放这个链表的时候，只需要记录abcabc和rapper两个原文即可。</p>\n<p>  假设我们要破解的摘要值（哈希链表的H(x)不一定是MD5算法，这里用更准确的说法代替MD5码）是7E9F216C，经过R(x)运算得到rapper，说明我们要寻找的原文就在以rapper为末端的哈希链表中。从首端开始经过多次运算，我们发现eopmca的摘要值就是7E9F216C。于是就反查出7E9F216C对应的原文是eopmca。</p>\n<p>  <strong>如果在生成哈希链表的时候依次使用多个不一样的R(x)，此时的哈希链表就是“彩虹表”。</strong></p>\n<p>  这里有已经计算好的彩虹表：<a href=\"https://link.zhihu.com/?target=http://project-rainbowcrack.com/table.htm\">http://project-rainbowcrack.com</a></p>\n</blockquote>\n<h2 id=\"差分攻击\"><a href=\"#差分攻击\" class=\"headerlink\" title=\"差分攻击\"></a>差分攻击</h2><p>上面介绍的穷举法、字典法和彩虹表法都是暴力破解，适用于任何的消息摘要算法。</p>\n<p>真正意义上MD5算法的破解，是2004年山东大学王小云教授提出的MD5碰撞方法。她所用到的方法正是差分攻击。</p>\n<p><a href=\"https://www.sohu.com/a/501560600_121106869\">她是这样的“中国密码女神”！</a> </p>\n",
            "tags": [
                "md5"
            ]
        },
        {
            "id": "https://www.oikiou.top/2022/471570a6/",
            "url": "https://www.oikiou.top/2022/471570a6/",
            "title": "SpaceDesk手机用作电脑屏幕",
            "date_published": "2022-08-29T14:57:15.000Z",
            "content_html": "<h1 id=\"SpaceDesk\"><a href=\"#SpaceDesk\" class=\"headerlink\" title=\"SpaceDesk\"></a>SpaceDesk</h1><p>在windows主机上虚拟出一块屏幕, 通过网络传输到其他带屏设备上.</p>\n<ul>\n<li>投屏到手机支持触摸</li>\n</ul>\n<h1 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h1><p><a href=\"https://www.spacedesk.net/\">https://www.spacedesk.net/</a></p>\n<h1 id=\"Note\"><a href=\"#Note\" class=\"headerlink\" title=\"Note\"></a>Note</h1><h2 id=\"软件没有验证功能-不安全\"><a href=\"#软件没有验证功能-不安全\" class=\"headerlink\" title=\"软件没有验证功能(不安全)\"></a>软件没有验证功能(不安全)</h2><p>有一次在公司用手机客户端, 直接连接上了公司其他同事的电脑屏幕.</p>\n<p>公司的网络ip是dhcp的无法固定, 而且网络质量并不好, 所以我选择电脑开热点 手机连电脑热点.</p>\n<p>防火墙加规则,只允许热点网段的IP入站.</p>\n<p><img src=\"/2022/471570a6/image-20220811195054454.png\" alt=\"image-20220811195054454\"></p>\n<p><img src=\"/2022/471570a6/image-20220811194925793.png\" alt=\"image-20220811194925793\"></p>\n",
            "tags": [
                "windows",
                "spacedesk",
                "投屏"
            ]
        }
    ]
}
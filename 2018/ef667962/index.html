<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.webp"><link rel="icon" href="/img/favicon.webp"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="Oikiou"><meta name="keywords" content=""><meta name="description" content="嵌入式编程杂乱笔记目录[TOC] 硬件类NTC和PTCNTC (Negative Temperature Coefficient 负温度系数)      PTC (Positive 正温度系数) VCC、 VDD、VEE、VSS区别 一、解释VCC：C&#x3D;circuit 表示电路的意思, 即接入电路的电压；VDD：D&#x3D;device 表示器件的意思, 即器件内部的工作电压；VSS："><meta property="og:type" content="article"><meta property="og:title" content="嵌入式编程杂乱笔记"><meta property="og:url" content="https://www.oikiou.top/2018/ef667962/index.html"><meta property="og:site_name" content="Oikiou&#39;s Blog"><meta property="og:description" content="嵌入式编程杂乱笔记目录[TOC] 硬件类NTC和PTCNTC (Negative Temperature Coefficient 负温度系数)      PTC (Positive 正温度系数) VCC、 VDD、VEE、VSS区别 一、解释VCC：C&#x3D;circuit 表示电路的意思, 即接入电路的电压；VDD：D&#x3D;device 表示器件的意思, 即器件内部的工作电压；VSS："><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.oikiou.top/2018/ef667962/contenteetimes-images-design-embedded-2018-fl-1-t1.jpg"><meta property="og:image" content="https://www.oikiou.top/2018/ef667962/20200311_01_Nor_FLASH_vs_NAND_FLASH.png"><meta property="og:image" content="https://www.oikiou.top/2018/ef667962/20200311_03_Nor_FLASH_vs_NAND_FLASH.png"><meta property="og:image" content="https://www.oikiou.top/2018/ef667962/20200311_04_Nor_FLASH_vs_NAND_FLASH.png"><meta property="og:image" content="https://www.oikiou.top/2018/ef667962/20200311_05_Nor_FLASH_vs_NAND_FLASH.png"><meta property="og:image" content="https://www.oikiou.top/2018/ef667962/20200311_07_Nor_FLASH_vs_NAND_FLASH.png"><meta property="og:image" content="https://www.oikiou.top/2018/ef667962/20200311_08_Nor_FLASH_vs_NAND_FLASH.png"><meta property="og:image" content="https://www.oikiou.top/2018/ef667962/20200311_10_Nor_FLASH_vs_NAND_FLASH.png"><meta property="og:image" content="https://www.oikiou.top/2018/ef667962/20200311_11_Nor_FLASH_vs_NAND_FLASH.png"><meta property="og:image" content="https://www.oikiou.top/2018/ef667962/%E6%97%A0%E6%A0%87%E9%A2%98.png"><meta property="og:image" content="https://www.oikiou.top/2018/ef667962/%E6%97%A0%E6%A0%87%E9%A2%98-1608969543089.png"><meta property="og:image" content="https://www.oikiou.top/2018/ef667962/%E6%97%A0%E6%A0%87%E9%A2%98-1608969576331.png"><meta property="og:image" content="https://www.oikiou.top/2018/ef667962/00.jpeg"><meta property="og:image" content="https://www.oikiou.top/2018/ef667962/20161218131342960.png"><meta property="og:image" content="https://www.oikiou.top/2018/ef667962/2018051223284857.png"><meta property="og:image" content="https://www.oikiou.top/2018/ef667962/20180513215202780.png"><meta property="og:image" content="https://www.oikiou.top/2018/ef667962/806053-20170722131756261-1095755633.png"><meta property="og:image" content="https://www.oikiou.top/2018/ef667962/686215-20151218231826459-500964006.png"><meta property="og:image" content="https://www.oikiou.top/2018/ef667962/ADC%E9%80%9A%E9%81%93%E4%B8%8E%E5%BC%95%E8%84%9A%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB.png"><meta property="og:image" content="https://www.oikiou.top/2018/ef667962/process.png"><meta property="og:image" content="https://www.oikiou.top/2018/ef667962/6765e36cc4604fba897976638af03524.jpeg"><meta property="og:image" content="https://www.oikiou.top/2018/ef667962/I2C_data_transfer.svg"><meta property="og:image" content="https://www.oikiou.top/2018/ef667962/231416549884871.gif"><meta property="article:published_time" content="2018-03-11T14:57:15.000Z"><meta property="article:modified_time" content="2023-07-06T13:17:32.041Z"><meta property="article:author" content="Oikiou"><meta property="article:tag" content="embedded"><meta property="article:tag" content="note"><meta property="article:tag" content="stm32"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://www.oikiou.top/2018/ef667962/contenteetimes-images-design-embedded-2018-fl-1-t1.jpg"><meta name="referrer" content="no-referrer-when-downgrade"><title>嵌入式编程杂乱笔记 - Oikiou&#39;s Blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/custom.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"www.oikiou.top",root:"/",version:"1.9.7",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"bash"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"left",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!1,baidu:null,google:"G-TSV6137NWK",tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1},gtag:"G-TSV6137NWK"},search_path:"/xml/local-search-database.xml",include_content_in_search:!0};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script async>Fluid.ctx.dnt||Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=",function(){function a(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],a("js",new Date),a("config","")})</script><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Oikiou&#39;s Blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item"><a class="nav-link" href="/links/" target="_self"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(https://bing.img.run/1920x1080.php) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="嵌入式编程杂乱笔记"></span></div><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> Oikiou </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2018-03-11 22:57" pubdate>2018年3月11日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 18k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 301 分钟 </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="padding-left:2rem;margin-right:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">嵌入式编程杂乱笔记</h1><p id="updated-time" class="note note-info" style="display:none">本文最后更新于 2023-07-06T21:17:32+08:00</p><div class="markdown-body"><h1 id="嵌入式编程杂乱笔记目录"><a href="#嵌入式编程杂乱笔记目录" class="headerlink" title="嵌入式编程杂乱笔记目录"></a>嵌入式编程杂乱笔记目录</h1><p>[TOC]</p><h1 id="硬件类"><a href="#硬件类" class="headerlink" title="硬件类"></a>硬件类</h1><h2 id="NTC和PTC"><a href="#NTC和PTC" class="headerlink" title="NTC和PTC"></a>NTC和PTC</h2><p>NTC (Negative Temperature Coefficient 负温度系数) PTC (Positive 正温度系数)</p><h2 id="VCC、-VDD、VEE、VSS区别"><a href="#VCC、-VDD、VEE、VSS区别" class="headerlink" title="VCC、 VDD、VEE、VSS区别"></a>VCC、 VDD、VEE、VSS区别</h2><ul><li>一、解释<br>VCC：C&#x3D;circuit 表示电路的意思, 即接入电路的电压；<br>VDD：D&#x3D;device 表示器件的意思, 即器件内部的工作电压；<br>VSS：S&#x3D;series 表示公共连接的意思，通常指电路公共接地端电压；<br>VEE：负电压供电；<br>VPP：编程&#x2F;擦除电压。</li><li>二、说明<br>1、对于数字电路来说，VCC是电路的供电电压,VDD是芯片的工作电压（通常Vcc&gt;Vdd），VSS是接地点。<br>2、有些IC既有VDD引脚又有VCC引脚，说明这种器件自身带有电压转换功能。<br>3、在场效应管（或COMS器件）中，VDD为漏极，VSS为源极，VDD和VSS指的是元件引脚，而不表示供电电压。</li></ul><h2 id="NOR-NAND"><a href="#NOR-NAND" class="headerlink" title="NOR NAND"></a>NOR NAND</h2><p>NOR(或非) NAND(与非)</p><p>SLC（Single-Level Cell）、MLC（Multi-Level Cell） 、 TLC（Triple-Level Cell）</p><p><strong>共同点：</strong></p><p>两者向浮栅中注入电子表示0(电子浮栅效应管存在导电沟道bit位被接地 见后续图片)，未注入表示1，对其清除数据是对其写1。</p><ul><li><strong>NOR FLASH</strong><ul><li>随机读取(可随机读取，能直接运行代码，BIOS)</li><li>随机读取较快、写入较很慢(热电子注入效率更低)、擦除次数较少、</li><li>容量较小、体积较小、可靠性高一些、数据保存期更高</li><li>初始通电消耗更多的电流, 待机状态电流远远更低</li><li></li><li>浮栅 热电子注入方式充电、FN隧道效应放电</li></ul></li><li><strong>NAND FLASH</strong><ul><li>块读取(块读取，不能运行代码)</li><li>随机读取较慢(地址线复用导致)、顺序读取速度较快、写入较快、擦除次数较多、</li><li>容量较大、体积较大、可靠性较低一些(较容易发生位交换现象)、数据保存期低一些</li><li>待机状态功耗较高</li><li></li><li>浮栅 FN隧道效应充电、FN隧道效应放电</li></ul></li></ul><p><img src="/2018/ef667962/contenteetimes-images-design-embedded-2018-fl-1-t1.jpg" srcset="/img/loading.gif" lazyload alt="img"></p><h3 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h3><h4 id="浮栅效应管"><a href="#浮栅效应管" class="headerlink" title="浮栅效应管"></a>浮栅效应管</h4><p>NOR FLASH 和 NAND FLASH 都是使用浮栅场效应管(Floating Gate FET)作为基本存储单元来存储数据的，浮栅场效应管共有 4 个端电极，分别是为源极（Source）、漏极（Drain）、控制栅极（Control Gate）和浮置栅极（Floating Gate），前 3 个端电极的作用于普通 MOSFET 是一样的，区别仅在于浮栅，FLASH 就是利用浮栅是否存储电荷来表征数字 0’和‘1’的。</p><p>当向浮栅注入电荷后，D 和 S 之间存在导电沟道，从 D 极读到‘0’<span style="color:#29b6f6">(电子浮栅效应管存在导电沟道bit位被接地 见后续图片)</span>；当浮栅中没有电荷时，D 和 S 间没有导电沟道，从 D 极读到‘1’，原理示意图见图</p><p>注：SLC 可以简单认为是利用浮栅是否存储电荷来表征数字 0’和‘1’的，MLC 则是要利用浮栅中电荷的多少来表征‘00’，‘01’，‘10’和‘11’的，TLC 与 MLC 类似。</p><blockquote><p>SLC传统上，每个储存单元内储存1个信息位，称为单阶储存单元（Single-Level Cell，SLC）。SLC闪存的优点是传输速度更快，功率消耗更低和储存单元的寿命更长，成本也就更高。一般情况下，SLC多数用于企业级的固态硬盘中，由于企业对于数据的安全性要求更高，需要保存更长时间。</p><p>MLC多阶储存单元（Multi-Level Cell,MLC）可以在每个储存单元内储存2个以上的信息位。与SLC相比，MLC成本较低，其传输速度较慢，功率消耗较高和储存单元的寿命较低。 但目前主流的固态硬盘中，性能较为优秀的产品选用的都是MLC颗粒，因此可以说MLC颗粒的固态硬盘拥有较高的性价比。甚至一些企业级的固态硬盘，使用的也是MLC颗粒，被专门优化过，称为eMLC颗粒，e代表的是企业enterprise。</p><p>TLC三阶储存单元（Triple-Level Cell, TLC），这种架构的原理与MLC类似，但可以在每个储存单元内储存3个信息位。由于存储的数据密度相对MLC和SLC更大，所以价格也就更便宜，但使用寿命和性能也就更低，不过这并不能阻止人们购买TLC颗粒的固态硬盘。甚至目前市场上绝大多数的入门级产品使用的都是TLC颗粒。而为了解决TLC颗粒过低的写入寿命问题，许多厂商都在研发新技术，3D-TLC就是这样的技术，目前已经比较广泛的应用在产品中，其性能甚至可以和MLC颗粒一较长短，使用寿命得到大幅度的延长。</p></blockquote><p><img src="/2018/ef667962/20200311_01_Nor_FLASH_vs_NAND_FLASH.png" srcset="/img/loading.gif" lazyload alt="Nor FLASH和NAND FLASH基本结构和特点的异同"></p><h5 id="读-写-擦除"><a href="#读-写-擦除" class="headerlink" title="读 写 擦除"></a>读 写 擦除</h5><p>FLASH 中，常用的向浮栅注入电荷的技术有两种—热电子注入(hot electron injection)和 F-N 隧道效应(Fowler Nordheim tunneling)；从浮栅中挪走电荷的技术通常使用 F-N 隧道效应(Fowler Nordheim tunneling)，基本原理见图。</p><p>写操作就是向浮栅注入电荷的过程，NOR FLASH 通过热电子注入方式向浮栅注入电荷（这种方法的电荷注入效率较低，因此 NOR FLASH 的写速率较低），NAND FLASH 则通过 F-N 隧道效应向浮栅注入电荷。FLASH 在写操作之前，必须先将原来的数据擦除（即将浮栅中的电荷挪走），也即 FLASH 擦除后读出的都是‘1’。<span style="color:#29b6f6">(只能擦除再写入的原因应该是擦除和写入加的电压是反向的, 一个是充电, 一个是放电)</span></p><p>擦除操作就是从浮栅中挪走电荷的过程，NOR FLASH 和 NAND FLASH 都是通过 F-N 隧道效应将浮栅中的电荷挪走的。</p><p>读出操作时，控制栅极上施加的电压很小，不会改变浮栅中的电荷量，即读出操作不会改变 FLASH 中原有的数据，也即浮栅有电荷时，D 和 S 间存在导电沟道，从 D 极读到‘0’<span style="color:#29b6f6">(电子浮栅效应管存在导电沟道bit位被接地 见后续图片)</span>；当浮栅中没有电荷时，D 和 S 间没有导电沟道，从 D 极读到‘1’。</p><p><a target="_blank" rel="noopener" href="https://www.sunev.cn/blog/wp-content/uploads/2020/03/20200311_03_Nor_FLASH_vs_NAND_FLASH.png"><img src="/2018/ef667962/20200311_03_Nor_FLASH_vs_NAND_FLASH.png" srcset="/img/loading.gif" lazyload alt="Nor FLASH和NAND FLASH基本结构和特点的异同"></a></p><h4 id="NOR-和-NAND-Flash-的结构特性"><a href="#NOR-和-NAND-Flash-的结构特性" class="headerlink" title="NOR 和 NAND Flash 的结构特性"></a>NOR 和 NAND Flash 的结构特性</h4><h6 id="NOR-Flash"><a href="#NOR-Flash" class="headerlink" title="NOR Flash"></a>NOR Flash</h6><p>NOR FLASH 的结构原理图见图 ，可见每个 Bit Line 下的基本存储单元是并联的，当某个 Word Line 被选中后，就可以实现对该 Word 的读取，也就是可以实现位读取（即 Random Ａccess），且具有较高的读取速率</p><p>下图是一个 3*8bit 的 NOR FLASH 的原理结构图，这种并联结构决定了 NOR FLASH 的很多特性。</p><p><img src="/2018/ef667962/20200311_04_Nor_FLASH_vs_NAND_FLASH.png" srcset="/img/loading.gif" lazyload alt="Nor FLASH和NAND FLASH基本结构和特点的异同"></p><p>下图是沿 Bit Line 切面的剖面图，展示了 NOR FLASH 的硅切面示意图，</p><p><img src="/2018/ef667962/20200311_05_Nor_FLASH_vs_NAND_FLASH.png" srcset="/img/loading.gif" lazyload alt="Nor FLASH和NAND FLASH基本结构和特点的异同"></p><ol><li>基本存储单元的并联结构决定了金属导线占用很大的面积，因此 NOR　FLASH 的存储密度较低，无法适用于需要大容量存储的应用场合，即适用于 code-storage，不适用于 data-storage。</li><li>基本存储单元的并联结构决定了 NOR FLASH 具有存储单元可独立寻址且读取效率高的特性，因此适用于 code-storage，且程序可以直接在 NOR 中运行（即具有 RAM 的特性）。</li><li>NOR FLASH 写入采用了热电子注入方式，效率较低，因此 NOR 写入速率较低，不适用于频繁擦除&#x2F;写入场合。</li></ol><blockquote><p>最后来个小贴士：NOR FLASH 的中的 N 是 NOT，含义是 Floating Gate 中有电荷时，读出‘0’，无电荷时读出‘1’，是一种‘非’的逻辑；OR 的含义是同一个 Bit Line 下的各个基本存储单元是并联的，是一种‘或’的逻辑，这就是 NOR 的由来。</p></blockquote><h6 id="NAND-Flash"><a href="#NAND-Flash" class="headerlink" title="NAND Flash"></a>NAND Flash</h6><p>NAND FLASH 的结构原理图见图，可见每个 Bit Line 下的基本存储单元是串联的，NAND 读取数据的单位是 Page，当需要读取某个 Page 时，FLASH 控制器就不在这个 Page 的 Word Line 施加电压，而对其他所有 Page 的 Word Line 施加电压（电压值不能改变 Floating Gate 中电荷数量），让这些 Page 的所有基本存储单元的 D 和 S 导通，而我们要读取的 Page 的基本存储单元的 D 和 S 的导通&#x2F;关断状态则取决于 Floating Gate 是否有电荷，有电荷时，Bit Line 读出‘0’，无电荷 Bit Line 读出‘1’，实现了 Page 数据的读出，可见 NAND 无法实现位读取（即 Random Ａccess），程序代码也就无法在 NAND 上运行。</p><p>下图是一个 8*8bit 的 NAND FLASH 的原理结构图，NAND FLASH 的串联结构决定了其很多特点。</p><p><img src="/2018/ef667962/20200311_07_Nor_FLASH_vs_NAND_FLASH.png" srcset="/img/loading.gif" lazyload alt="Nor FLASH和NAND FLASH基本结构和特点的异同"></p><p>下图是沿 Bit Line 切面的剖面图，展示了 NAND FLASH 的硅切面示意图</p><p><img src="/2018/ef667962/20200311_08_Nor_FLASH_vs_NAND_FLASH.png" srcset="/img/loading.gif" lazyload alt="Nor FLASH和NAND FLASH基本结构和特点的异同"></p><ol><li>基本存储单元的串联结构减少了金属导线占用的面积，Die 的利用率很高，因此 NAND FLASH 存储密度高，适用于需要大容量存储的应用场合，即适用于 data-storage，见图 3.3[3]。</li><li>基本存储单元的串联结构决定了 NAND FLASH 无法进行位读取，也就无法实现存储单元的独立寻址，因此程序不可以直接在 NAND 中运行,因此 NAND 是以 Page 为读取单位和写入单位，以 Block 为擦除单位，见图 3.6。</li><li>NAND FLASH 写入采用 F-N 隧道效应方式，效率较高，因此 NAND 擦除&#x2F;写入速率很高，适用于频繁擦除&#x2F;写入场合。同时 NAND 是以 Page 为单位进行读取的，因此读取速率也不算低（稍低于 NOR）。</li></ol><blockquote><p>最后来个小贴士：NAND FLASH 的中的 N 是 NOT，含义是 Floating Gate 中有电荷时，读出‘0’，无电荷时读出‘1’，是一种‘非’的逻辑；AND 的含义是同一个 Bit Line 下的各个基本存储单元是串联的，是一种‘与’的逻辑，这就是 NAND 的由来。</p></blockquote><h6 id="NOR-和-NAND-的对比"><a href="#NOR-和-NAND-的对比" class="headerlink" title="NOR 和 NAND 的对比"></a>NOR 和 NAND 的对比</h6><p><img src="/2018/ef667962/20200311_10_Nor_FLASH_vs_NAND_FLASH.png" srcset="/img/loading.gif" lazyload alt="Nor FLASH和NAND FLASH基本结构和特点的异同"></p><p><img src="/2018/ef667962/20200311_11_Nor_FLASH_vs_NAND_FLASH.png" srcset="/img/loading.gif" lazyload alt="Nor FLASH和NAND FLASH基本结构和特点的异同"></p><h2 id="eMMC"><a href="#eMMC" class="headerlink" title="eMMC"></a>eMMC</h2><p>eMMC (Embedded Multi Media Card) 为MMC协会所订立的主要针对手机或平板电脑等产品的内嵌式存储器标准规格。</p><p><strong>eMMC</strong> 是 **flash(一般是NAND flash)<strong>加</strong>主控IC(坏块处理 ECC纠错 和数据管理)**，封装相对比较标准，并对外提供标准接口，类似于SD卡。</p><blockquote><p>Flash的生产厂家主要有： Samsung, Toshiba,Hynix, Intel, Micron,</p><p>flash控制IC主要有：Phison（群联）, SMI（慧荣）, SiliconGo(硅格半导体）</p></blockquote><p>几乎所有的手机和平板电脑都使用这种形式的闪存作为主存储，直到 2016 年<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Universal_Flash_Storage">通用闪存</a>(UFS) 开始控制市场。</p><p>eMMC 不支持<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI-bus</a>协议，一般使用 MLC NAND flash。</p><table><thead><tr><th align="center"></th><th align="center">Sequential Read(MB&#x2F;s)</th><th align="center">Sequential Write(MB&#x2F;s)</th><th align="center">Random Read(IO&#x2F;s)</th><th align="center">Random Write(IO&#x2F;s)</th><th align="center">Clock Frequency(Mhz)</th><th align="center">Used in</th></tr></thead><tbody><tr><td align="center">eMMC 4.3</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">eMMC 4.4</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">eMMC 4.41</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">52[<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/MultiMediaCard#cite_note-11">11]</a></td><td align="center"></td></tr><tr><td align="center">eMMC 4.5</td><td align="center">140[<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/MultiMediaCard#cite_note-12">12]</a></td><td align="center">50</td><td align="center">7000</td><td align="center">2000</td><td align="center">200</td><td align="center"><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Snapdragon_800">Snapdragon 800</a></td></tr><tr><td align="center">eMMC 5.0</td><td align="center">250</td><td align="center">90</td><td align="center">7000</td><td align="center">13000</td><td align="center"></td><td align="center">Snapdragon 801</td></tr><tr><td align="center">eMMC 5.1</td><td align="center">250</td><td align="center">125</td><td align="center">11000</td><td align="center">13000</td><td align="center"></td><td align="center">Snapdragon 820</td></tr></tbody></table><h2 id="UFS"><a href="#UFS" class="headerlink" title="UFS"></a>UFS</h2><table><thead><tr><th align="center">UFS</th><th align="center">1.0</th><th align="center">1.1</th><th align="center">2.0</th><th align="center">2.1</th><th align="center">2.2</th><th align="center">3.0</th><th align="center">3.1</th><th align="center">4.0</th></tr></thead><tbody><tr><td align="center">Introduced</td><td align="center">2011-02</td><td align="center">2012-06</td><td align="center">2013-09</td><td align="center">2016-04</td><td align="center">2020-08</td><td align="center">2018-01</td><td align="center">2020-01</td><td align="center">2022-08</td></tr><tr><td align="center">Bandwidth per lane</td><td align="center">300 MB&#x2F;s</td><td align="center">600 MB&#x2F;s</td><td align="center">1450 MB&#x2F;s</td><td align="center">2900 MB&#x2F;s</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">Max. number of lanes</td><td align="center">1</td><td align="center">2</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">Max. total bandwidth</td><td align="center">300 MB&#x2F;s</td><td align="center">1200 MB&#x2F;s</td><td align="center">2900 MB&#x2F;s</td><td align="center">5800 MB&#x2F;s</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/M-PHY">M-PHY</a> version</td><td align="center">?</td><td align="center">?</td><td align="center">3.0</td><td align="center">?</td><td align="center">4.1</td><td align="center">5.0</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/UniPro">UniPro</a> version</td><td align="center">?</td><td align="center">?</td><td align="center">1.6</td><td align="center">?</td><td align="center">1.8</td><td align="center">2.0</td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="NFC"><a href="#NFC" class="headerlink" title="NFC"></a>NFC</h2><p><strong>近场通信</strong>（英语：Near-field communication，NFC），又称<strong>近距离无线通信</strong>、<strong>近距离通信</strong>，是一套<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%80%9A%E8%A8%8A%E5%8D%94%E5%AE%9A">通信协议</a>，让两个电子设备（其中一个通常是移动设备，例如<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%99%BA%E6%85%A7%E5%9E%8B%E6%89%8B%E6%A9%9F">智能手机</a>）在相距几厘米之内进行<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B3%87%E6%96%99%E5%82%B3%E8%BC%B8">通信</a>。</p><p>近场通信是一种短距高频的无线电技术，在<strong>13.56MHz</strong>频率运行于20厘米距离内[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-cn/%E8%BF%91%E5%A0%B4%E9%80%9A%E8%A8%8A#cite_note-Ortiz_2008-5">5]</a>。其传输速度有106 Kbit&#x2F;秒、212 Kbit&#x2F;秒或者424 Kbit&#x2F;秒三种。</p><p>NFC的工作模式有<strong>卡模式</strong>、<strong>读写器模式</strong>和<strong>点对点模式</strong>三种</p><h2 id="RFID"><a href="#RFID" class="headerlink" title="RFID"></a>RFID</h2><p><strong>射频识别</strong>（英语：<strong>R</strong>adio <strong>F</strong>requency <strong>ID</strong>entification，<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B8%AE%E5%AF%AB">缩写</a>：<strong>RFID</strong>）是一种<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%84%A1%E7%B7%9A">无线</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF">通信技术</a>，可以通过<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%97%A0%E7%BA%BF%E7%94%B5">无线电</a>信号识别特定目标并读写相关数据，而无需识别系统与特定目标之间建立<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%9C%BA%E6%A2%B0">机械</a>或者<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%85%89%E5%AD%A6">光学</a>接触。</p><p>某些标签在识别时从识别器发出的电磁场中就可以得到能量，<strong>并不需要电池</strong>；<strong>也有标签本身拥有电源</strong>，并可以主动发出无线电波（调成无线电频率的电磁场）。</p><p>无源 RFID 标签主要在三个频率范围内运行：</p><ul><li><a target="_blank" rel="noopener" href="https://blog.atlasrfidstore.com/low-frequency-rfid-and-animal-identification">低频</a>(LF) 125 -134 kHz</li><li>高频 (HF)13.56 MHz</li><li><a target="_blank" rel="noopener" href="https://blog.atlasrfidstore.com/what-is-rfid">超高频</a>(UHF) 856 MHz 至 960 MHz</li></ul><blockquote><p><strong>NFC 与 RFID 有什么区别？</strong></p><p>简而言之：</p><p>RFID 代表射频识别，一种在不同距离的非接触式单向<strong>通信方法</strong>。</p><p>NFC 近场通信，允许双向通信并需要用户操作，从特性上来看NFC的功能会更强，<strong>NFC是RFID的一个子集</strong>。</p><p>RFID 是使用无线电波唯一识别物品的过程，而 NFC 是 RFID 技术系列中的一个专门子集。具体来说，NFC 是高频 (HF) RFID 的一个分支，均工作在 13.56 MHz 频率。NFC 旨在成为一种安全的数据交换形式，NFC 设备既可以作为 NFC 阅读器，也可以作为 <a target="_blank" rel="noopener" href="https://www.atlasrfidstore.com/near-field-communication/">NFC 标签</a>。这种独特的功能允许 NFC 设备进行点对点通信。</p><p>归根结底，<strong>NFC 建立在 HF RFID 的标准之上</strong>，并将其工作频率的局限性转化为近场通信的独特功能。</p><ul><li><strong>范围和应用</strong>——NFC 的作用范围非常短，一般工作范围在 0.1 米以内。它是一种用户交互技术，需要用户的特殊参与才能保证支付或访问等功能的完成。NFC技术在门禁、公共交通、移动支付等领域发挥着巨大的作用。</li><li>另一方面，RFID 扫描器可以同时读取大量标签，这在仓库库存中很常见。RFID 在数百英尺的距离内工作。</li><li><strong>通信</strong>——RFID 通常只能进行单向通信（从标签到阅读器），而 NFC 则能够进行双向通信。</li><li><strong>数据存储——NFC</strong>可以存储比简单识别信息更复杂的数据。NFC 标签最多可以存储 4KB 的数据。这些数据可以采用多种格式，包括文本、URL 和媒体。虽然 RFID 标签通常需要昂贵的读取器来提取数据，但大多数现代智能手机都配备了 NFC 读取功能。这大大降低了实施 NFC 标签的成本，因为用户可以简单地使用他们的智能手机读取数据。智能手机可以在标签或卡上读取和写入数据，获取详细的元数据，在扫描标签时启动应用程序或 URL，还可以使用 NFC（点对点 (P2P) 通信）在手机之间共享数据。</li></ul></blockquote><h1 id="编译器相关"><a href="#编译器相关" class="headerlink" title="编译器相关"></a>编译器相关</h1><h2 id="Keil仿真准确测量运行时间"><a href="#Keil仿真准确测量运行时间" class="headerlink" title="Keil仿真准确测量运行时间"></a>Keil仿真准确测量运行时间</h2><p>Debug-&gt;Setting-&gt;Trsce-&gt;Core 修改好核心时钟频率即可准确测量函数运行时间</p><h2 id="程序内存位置分配"><a href="#程序内存位置分配" class="headerlink" title="程序内存位置分配"></a>程序内存位置分配</h2><ul><li><p>bss段：</p><ul><li><strong>未初始化的全局变量</strong></li><li>BSS段（BSS segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域。BSS是英文BlockStarted by Symbol的简称。BSS段属于静态内存分配。</li></ul></li><li><p>data段：</p><ul><li><strong>已初始化的全局变量</strong></li><li>数据段（DATA segment）通常是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。</li></ul></li><li><p>text段：</p><ul><li>代码段</li><li>代码段（CODE segment&#x2F;TEXTsegment）通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读,某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。</li></ul></li><li><p>rodata段：</p><ul><li>？？？</li><li>存放C中的字符串和#define定义的常量</li></ul></li><li><p>heap堆：</p><ul><li>堆（程序员指定的内存 malloc）</li><li>当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）</li></ul></li><li><p>stack栈：</p><ul><li>栈</li><li>是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存&#x2F;恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。</li></ul></li><li><p>常量段：</p><ul><li>？？？</li><li>常量段一般包含编译器产生的数据（与只读段包含用户定义的只读数据不同）。比如说由一个语句a&#x3D;2+3编译器把2+3编译期就算出5，存成常量5在常量段中</li></ul></li></ul><h2 id="Pragma-Pack-内存对齐"><a href="#Pragma-Pack-内存对齐" class="headerlink" title="#Pragma Pack (内存对齐)"></a>#Pragma Pack (内存对齐)</h2><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><ol><li><p>复杂类型中各个成员按照它们被声明的顺序在内存中顺序存储，第一个成员的地址和整个类型的地址相同</p></li><li><p>结构、联合或者类的对齐长度，按照#pragma pack <strong>指定的对齐参数</strong> 和 <strong>这个数据成员自身长度</strong> 两个中 <strong>比较小</strong> 的那个进行。（确定成员位置）</p></li><li><p>复杂类型（如结构）整体的对齐&lt;注意是“整体”&gt;是按照结构体中 <strong>长度最大的数据成员</strong> 和 <strong>#pragma pack指定值之间</strong> <strong>较小</strong> 的那个值进行；这样在成员是复杂类型时，可以最小化长度。（确定对齐大小）</p></li></ol><p>即：先用规则3确定变量对齐的“容器”大小，再用规则2确定各个变量的存放位置。</p><h3 id="看图"><a href="#看图" class="headerlink" title="看图"></a>看图</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stc</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> one;<br>    <span class="hljs-type">short</span> two;<br>    <span class="hljs-type">char</span> three;<br>    <span class="hljs-type">int</span> four;<br>&#125; c,d;<br></code></pre></td></tr></table></figure><ul><li>#pragma pack (1)</li></ul><p><img src="/2018/ef667962/%E6%97%A0%E6%A0%87%E9%A2%98.png" srcset="/img/loading.gif" lazyload alt="无标题"></p><ul><li>#pragma pack (2)</li></ul><p><img src="/2018/ef667962/%E6%97%A0%E6%A0%87%E9%A2%98-1608969543089.png" srcset="/img/loading.gif" lazyload alt="无标题"></p><ul><li>#pragma pack (4)</li></ul><p><img src="/2018/ef667962/%E6%97%A0%E6%A0%87%E9%A2%98-1608969576331.png" srcset="/img/loading.gif" lazyload alt="无标题"></p><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><ul><li><p>pragma pack(n)</p></li><li><p>pragma pack()</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(1)<span class="hljs-comment">//自定义对齐参数   指定对齐参数</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">MotorStartStop_</span>&#123;</span><br>	<span class="hljs-comment">//Code******</span><br>&#125; MStartStopRec_TYPEDEF;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack()<span class="hljs-comment">//取消自定义的对齐参数</span></span><br></code></pre></td></tr></table></figure><ul><li><p>Pragma Pack(push)</p></li><li><p>Pragma Pack(pop)</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(push)<span class="hljs-comment">//Push压栈  保存系统的对齐方式(push指令之前的对齐状态)</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(1)<span class="hljs-comment">//            自定义对齐方式</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">MotorStartStop_</span>&#123;</span><br>	<span class="hljs-comment">//Code******</span><br>&#125; MStartStopRec_TYPEDEF;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(pop)<span class="hljs-comment">//Pop弹出    恢复系统的对齐方式</span></span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(push,1)<span class="hljs-comment">//此语句等同于以下两条语句</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(push)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(1) </span><br></code></pre></td></tr></table></figure><h2 id="pragma-OPTIMIZE-n-优化级别调整"><a href="#pragma-OPTIMIZE-n-优化级别调整" class="headerlink" title="#pragma OPTIMIZE(n)(优化级别调整)"></a>#pragma OPTIMIZE(n)(优化级别调整)</h2><p><span style="color:red">在ARM里面已经用不了</span></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> save			<span class="hljs-comment">//SAVE指令将优化指令的当前设置存储到一个SAVE堆栈中。可以使用RESTORE指令还原设置。</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> optimize (1)</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">func</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>.<br>.<br>.<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> restore			<span class="hljs-comment">//RESTORE指令 恢复</span></span><br></code></pre></td></tr></table></figure><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>tip:宏函数</p><p>在大多数情况下，内联特定功能的决定最好留给编译器。使用<code>__inline__</code>或<code>inline</code>关键字限定函数的功能向编译器暗示它可以内联该函数，<strong>但最终决定权在于编译器</strong>。使用限定函数将<code>__attribute__((always_inline))</code>强制编译器内联函数。</p><h3 id="inline内联"><a href="#inline内联" class="headerlink" title="__inline内联"></a><del>__inline内联</del></h3><p>最终决定权在于编译器,不使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __inline <span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>&#123;<br>    <span class="hljs-keyword">return</span> x*<span class="hljs-number">5</span>+<span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">g</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span>&#123;<br>    <span class="hljs-keyword">return</span> f(x) + f(y);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="forceinline强制内联"><a href="#forceinline强制内联" class="headerlink" title="__forceinline强制内联"></a>__forceinline强制内联</h3><ol><li><p><code>__forceinline</code>的语义与C ++ <code>inline</code> 关键字的语义完全相同。编译器将尝试内联该函数，而不管其特性如何。</p><p><strong>在某些情况下，编译器可能会选择忽略<code>__forceinline</code>关键字而不是内联函数。</strong>例如：</p><ul><li>递归函数永远不会内联到自身中。</li><li>使用函数<code>alloca()</code>(内存分配函数)永远不会内联。</li></ul><p><code>__forceinline</code>是存储类限定符。它不影响函数的类型。</p></li><li><p>它等效于 <strong>attribute</strong>((always_inline))</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">__forceinline <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">max</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> x &gt; y ? x : y; <span class="hljs-comment">// always inline if possible</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">max</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> __<span class="hljs-title function_">attribute__</span><span class="hljs-params">((always_inline))</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">max</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> x &gt; y ? x : y; <span class="hljs-comment">// always inline if possible</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用递减的循环可以提高程序运行效率"><a href="#使用递减的循环可以提高程序运行效率" class="headerlink" title="使用递减的循环可以提高程序运行效率"></a>使用递减的循环可以提高程序运行效率</h2><p><a target="_blank" rel="noopener" href="http://www.keil.com/support/man/docs/armcc/armcc_chr1359124222426.htm">参考 C代码中循环终止的优化</a></p><ul><li>使用简单终止循环的条件。</li><li>使用递减到0的循环</li><li>使用 unsigned int 类型</li><li>与0进行对比</li></ul><h2 id="volatile-的使用"><a href="#volatile-的使用" class="headerlink" title="volatile 的使用"></a>volatile 的使用</h2><ul><li>访问内存映射的外围设备。</li><li>在多个线程之间共享全局变量。</li><li>在中断例程或信号处理程序中访问全局变量。</li></ul><h2 id="纯函数-优化"><a href="#纯函数-优化" class="headerlink" title="纯函数(优化)"></a>纯函数(优化)</h2><p><code>__pure</code></p><p>纯函数定义：同样的的输入有同样的输出， 纯函数无法通过使用全局变量或通过指针间接读取或写入全局状态</p><p>优势：编译器通常可以执行强大的优化， 例如通用子表达式消除（CSE） 。</p><h2 id="packed-pragma-packed-字节对齐"><a href="#packed-pragma-packed-字节对齐" class="headerlink" title="__packed  #pragma packed 字节对齐"></a>__packed #pragma packed 字节对齐</h2><p>将整个结构声明为 __packed 通常会导致代码大小和性能的损失。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">__packed <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mystruct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> c;<br>    <span class="hljs-type">short</span> s;<br>&#125; <span class="hljs-comment">// 不建议的</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mystruct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> c;<br>    __packed <span class="hljs-type">short</span> s; <span class="hljs-comment">// 建议的</span><br>&#125;<br></code></pre></td></tr></table></figure><p><a target="_blank" rel="noopener" href="http://www.keil.com/support/man/docs/armcc/armcc_chr1359124230195.htm">参考</a></p><p><a target="_blank" rel="noopener" href="http://www.keil.com/support/man/docs/armcc/armcc_chr1359124230944.htm">__packed和#pragma packed对比</a></p><h2 id="func-FUNCTION-FILE-LINE"><a href="#func-FUNCTION-FILE-LINE" class="headerlink" title="__func__ __FUNCTION__ __FILE__ __LINE__"></a>__func__ __FUNCTION__ __FILE__ __LINE__</h2><p>__func__ __FUNCTION__ __FILE__ __LINE__</p><p>获取当前函数名称</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This function is called &#x27;%s&#x27;.\n&quot;</span>, __func__);<br>&#125;<br></code></pre></td></tr></table></figure><p>prints:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">This function is called <span class="hljs-string">&#x27;foo&#x27;</span>.<br></code></pre></td></tr></table></figure><h2 id="attribute-used-不能将其优化移除"><a href="#attribute-used-不能将其优化移除" class="headerlink" title="__attribute__((used))不能将其优化移除"></a>__attribute__((used))不能将其优化移除</h2><p>用这个东西声明函数之后，即使这个函数没有被引用，编译器也不能将其优化移除，仍然要求将此函数保留在工程中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lose_this</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">keep_this</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> __<span class="hljs-title function_">attribute__</span><span class="hljs-params">((used))</span>;     <span class="hljs-comment">// retained in object file</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">keep_this</span> <span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>  <span class="hljs-keyword">return</span> (arg+<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">keep_this_too</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> __<span class="hljs-title function_">attribute__</span><span class="hljs-params">((used))</span>; <span class="hljs-comment">// 保留在工程文件中</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">keep_this_too</span> <span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>  <span class="hljs-keyword">return</span> (arg<span class="hljs-number">-1</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>  <span class="hljs-keyword">for</span> (;;);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="attribute-section-“XX-name”-放置到特定的段里面"><a href="#attribute-section-“XX-name”-放置到特定的段里面" class="headerlink" title="__attribute__((section(“XX_name”)))放置到特定的段里面"></a>__attribute__((section(“XX_name”)))放置到特定的段里面</h2><p><strong>XX_name:是输入段的名称(字符串)。</strong></p><p>这个东西是告诉编译器，将特定的函数或者变量放置到特定的段里面。</p><p>变量和函数在输入段中的地址是连续的，并顺序先按section名(也就是XX_name)排序，section内再按照函数名称进行排序。</p><h2 id="attribute-at-0x00-将变量定义到指定的地方"><a href="#attribute-at-0x00-将变量定义到指定的地方" class="headerlink" title="__attribute__((at(0x00)))将变量定义到指定的地方"></a>__attribute__((at(0x00)))将变量定义到指定的地方</h2><p>将变量定义到指定的地方</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//linux</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> temp_A@<span class="hljs-number">0x00</span>; <span class="hljs-comment">//定义无符号变量temp_A，强制其地址为0x00 变量@地址</span><br><span class="hljs-comment">//keil</span><br><span class="hljs-type">uint8_t</span> cnt __attribute__((at(<span class="hljs-number">0x20008000</span>))); <span class="hljs-comment">//格式固定下划线为两个下划线，括号必须那么多层</span><br></code></pre></td></tr></table></figure><h2 id="attribute-alias-“sss”-起别名"><a href="#attribute-alias-“sss”-起别名" class="headerlink" title="__attribute__((alias(“sss”)))起别名"></a>__attribute__((alias(“sss”)))起别名</h2><p>相当于起别名</p><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, __FUNCTION__);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">bar</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> __<span class="hljs-title function_">attribute__</span><span class="hljs-params">((alias(<span class="hljs-string">&quot;foo&quot;</span>)))</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">gazonk</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    bar(); <span class="hljs-comment">// calls foo</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Code-RO-RW-ZI"><a href="#Code-RO-RW-ZI" class="headerlink" title="Code RO RW ZI"></a>Code RO RW ZI</h2><p>Program Size: Code&#x3D;14554 RO-data&#x3D;1234 RW-data&#x3D;272 ZI-data&#x3D;6168</p><p>Program Size: Code&#x3D;13682 RO-data&#x3D;1098 RW-data&#x3D;224 ZI-data&#x3D;6160</p><ul><li><p>Code</p></li><li><p>Read Only</p></li><li><p>Read Write</p></li><li><p>Zero Initial</p></li></ul><blockquote><p>编译器插入一个小的引导程序代码，该代码从编译好的image中获取具有初始化数据初始值的块，并将其复制到 RAM（这是 RW 区域）中。然后它将剩余的已用 RAM（ZI 区域）清零。然后控制权转移到程序员编写的实际代码中。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Total</span> RO Size (Code+Ro data)                <span class="hljs-number">36732</span> (<span class="hljs-number">35</span>.<span class="hljs-number">87</span>kB)<br><span class="hljs-attribute">Total</span> RW Size (RW Data + ZI Data)           <span class="hljs-number">27348</span> (<span class="hljs-number">26</span>.<span class="hljs-number">71</span>kB<br><span class="hljs-attribute">Total</span> ROM Size (Code + RO Data + RW Data)   <span class="hljs-number">36812</span> (<span class="hljs-number">35</span>.<span class="hljs-number">95</span>kB<br></code></pre></td></tr></table></figure></blockquote><h2 id="汇编延时-不受优化影响"><a href="#汇编延时-不受优化影响" class="headerlink" title="汇编延时 不受优化影响"></a>汇编延时 不受优化影响</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 汇编延时</span><br><span class="hljs-comment"> * @attention us延时不是很准确</span><br><span class="hljs-comment"> * @details 三个汇编指令理论应该是三个时钟周期</span><br><span class="hljs-comment"> * 则 理论上</span><br><span class="hljs-comment"> * ms AsmDelay( n*(SystemCoreClock/3000) )</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 实际有所差异 在STM32F105上</span><br><span class="hljs-comment"> * ms AsmDelay( n*(SystemCoreClock/6000) )</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined (__CC_ARM)              <span class="hljs-comment">// ARM Compiler</span></span><br>__attribute__((always_inline)) __ASM <span class="hljs-type">void</span> <span class="hljs-title function_">AsmDelay</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> t)</span><br>&#123;<br>    subs    r0, #<span class="hljs-number">1</span>;<br>    bne     AsmDelay;<br>    bx      lr;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined (__ICCARM__)         <span class="hljs-comment">// IAR Compiler</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">AsmDelay</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> t)</span><br>&#123;<br>    __asm(<br>    <span class="hljs-string">&quot;subs  r0, #1\n&quot;</span><br>    <span class="hljs-string">&quot;bne.n AsmDelay\n&quot;</span><br>    <span class="hljs-string">&quot;bx    lr&quot;</span><br>    );<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> <span class="hljs-keyword">define</span> (__GUNC__)            <span class="hljs-comment">// GUN Compiler</span></span><br><span class="hljs-type">void</span> __attribute__((naked)) AsmDelay(<span class="hljs-type">uint32_t</span> t)<br>&#123;<br>    __asm(<br>    <span class="hljs-string">&quot;subs  r0, #1\n&quot;</span><br>    <span class="hljs-string">&quot;bne   AsmDelay\n&quot;</span><br>    <span class="hljs-string">&quot;bx    lr&quot;</span><br>    );<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h2 id="大小端-endian"><a href="#大小端-endian" class="headerlink" title="大小端 endian"></a>大小端 endian</h2><ul><li>大端模式Big-endian，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；<code>大端模式便于阅读</code></li><li>小端模式Little-endian，………..</li></ul><table><thead><tr><th>0x00123456</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>大端</td><td></td><td></td><td></td><td></td></tr><tr><td>地址</td><td>0x00000000</td><td>0x00000001</td><td>0x00000002</td><td>0x00000003</td></tr><tr><td>数值</td><td>0x00</td><td>0x12</td><td>0x34</td><td>0x56</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>小端</strong></td><td></td><td></td><td></td><td></td></tr><tr><td>地址</td><td>0x00000000</td><td>0x00000001</td><td>0x00000002</td><td>0x00000003</td></tr><tr><td>数值</td><td>0x56</td><td>0x34</td><td>0x12</td><td>0x00</td></tr></tbody></table><h1 id="C类"><a href="#C类" class="headerlink" title="C类"></a>C类</h1><h2 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h2><ol><li>选择合适的变量长度(最短的标识符显示最多信息量的原则)</li><li>短变量名i,j等一般作用域较小，有限范围内有效</li></ol><h3 id="循环变量的命名"><a href="#循环变量的命名" class="headerlink" title="循环变量的命名"></a>循环变量的命名</h3><p><strong>避免使用i、j、k等名字</strong></p><p>如果循环体长度较长的话，那就很容易使人忘记它代表的是什么，因此最好给循环控制变量一个富有意义的名字。由于经常进行更改，扩展和拷贝等代码到另一个程序中，因此，大多数有经验的程序员都避免用i、j、k这类的名字。<br>通过精心对循环控制变量进行命名，可以避免它们的交叉：当你想用i时误用了j，或者想用j时却又误用了i。<br>如果不得不使用它们的话，那除了把它们用作循环控制变量之外，最好不再用作别的变量名。这一约定是众所周知的，如果不遵守它只会引起别人的困惑。</p><h3 id="状态变量的命名"><a href="#状态变量的命名" class="headerlink" title="状态变量的命名"></a>状态变量的命名</h3><p>利用枚举类型和命名常量来设置状态量的值</p><p>如果没有注释，将数值赋给状态量将是非常费解的。</p><h3 id="逻辑变量命名"><a href="#逻辑变量命名" class="headerlink" title="逻辑变量命名"></a>逻辑变量命名</h3><p>使用肯定的逻辑变量名。</p><p>否定式的变量名如NotFound、NotDone和Notsuccessful等在“非”运算中是很难读懂的，如：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">if not NotFound</span><br></code></pre></td></tr></table></figure><h3 id="参量的命名"><a href="#参量的命名" class="headerlink" title="参量的命名"></a>参量的命名</h3><p><strong>对常量来说，应该用它所代表的抽象实体而不是数值来命名。</strong><br>FIVE是一个很不恰当的常量名称（不管它代表的数值是否是5.0）；CYCLES_NEEDED则是个恰当的名称，CYCLES_NEEDED可以等于5.0也可以等于6.0，而Five &#x3D; 6.0则是个荒唐的语句。</p><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p><img src="/2018/ef667962/00.jpeg" srcset="/img/loading.gif" lazyload></p><blockquote><p>简记</p><p>算术运算符 &gt; 关系运算符 &gt; 位运算符 &gt; 逻辑运算符 &gt; 赋值运算符</p></blockquote><ul><li>坑</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//编译报错 ！赋值运算符优先级最低！</span><br>(DS18B20_DQ_IN != <span class="hljs-number">0</span>) ? data_temp|=<span class="hljs-number">0x80</span> : data_temp&amp;=<span class="hljs-number">0x7f</span>;<br><span class="hljs-comment">//规范写法</span><br>(DS18B20_DQ_IN!=<span class="hljs-number">0</span>) ? (data_temp|=<span class="hljs-number">0x80</span>):(data_temp&amp;=<span class="hljs-number">0x7f</span>);<br></code></pre></td></tr></table></figure><ul><li>！！！极注意！！！ 请小心有位运算时打上括号 &lt;&lt; 比 +- 要低<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">u16 temp;<br>u8 h,l;<br>temp = (u16)(h&lt;&lt;<span class="hljs-number">8</span>) + l;<span class="hljs-comment">// 正确语法</span><br>temp = h&lt;&lt;<span class="hljs-number">8</span> + l;<span class="hljs-comment">// 错误语法！！！！！</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="printf"><a href="#printf" class="headerlink" title="printf()"></a>printf()</h2><table><thead><tr><th align="left">转换说明符</th><th>输出</th></tr></thead><tbody><tr><td align="left">%a，%A</td><td>浮点数、十六进制、p-计数法（c99）</td></tr><tr><td align="left">%c</td><td>一个单一的字符</td></tr><tr><td align="left">%d</td><td>有符号十进制整数</td></tr><tr><td align="left">%f</td><td>浮点数、十六进制数法</td></tr><tr><td align="left">%e,%E</td><td>e计数法，E计数法</td></tr><tr><td align="left">%g,%G</td><td>g自动使用%e和%f，G自动使用%E和%f</td></tr><tr><td align="left">%i</td><td>有符号十进制整数</td></tr><tr><td align="left">%o</td><td>一个八进制数</td></tr><tr><td align="left">%p</td><td>一个指针</td></tr><tr><td align="left">%s</td><td>一个字符串</td></tr><tr><td align="left">%u</td><td>无符号十进制整数</td></tr><tr><td align="left">%x，%X</td><td>十六进制数字的无符号十六进制整数</td></tr><tr><td align="left">%%</td><td>百分号</td></tr></tbody></table><table><thead><tr><th>标志</th><th>意义</th></tr></thead><tbody><tr><td>-</td><td>项目是左对齐的；打印在字符的最左侧开始处。</td></tr><tr><td>+</td><td>有符号的值显示正负号。</td></tr><tr><td>(空格)</td><td>带前导空格，复数会带减号符号，+会覆盖空格标志。</td></tr><tr><td>#</td><td>%o以0开始，%x以0x开始，浮点保证打印小数点，%g防止尾随零被删</td></tr><tr><td>0</td><td>前导零填充，会忽略-符号。</td></tr><tr><td>修饰符</td><td>意义</td></tr><tr><td>———</td><td>————————————————————</td></tr><tr><td>digit(s)</td><td>字段宽度的最小值。<br>%4d</td></tr><tr><td>.digit(s)</td><td>精度。<br>%5.2f</td></tr><tr><td>h</td><td>和整数说明符一起使用。表示short int或unsigned short int<br>%hu、%hx、%6.4hd</td></tr><tr><td>hh</td><td>和整数说明符一起使用。表示signed char或unsigned char<br>%hhu、%hhx、%6.4hhd</td></tr><tr><td>j</td><td>和整数说明符一起使用。表示intmax_t或uintmax_t<br>%jd、%8jX</td></tr><tr><td>l</td><td>和整数说明符一起使用。long int或unsigned long int<br>%ld、%lu</td></tr><tr><td>ll</td><td>和整数说明符一起使用。long long int或unsigned long long int（C99）<br>%lld、%llu</td></tr><tr><td>L</td><td>和浮点数一起使用。表示long double<br>%Lf、%Le</td></tr><tr><td>t</td><td>和整数说明符一起使用。ptrdiff_t（两个指针的差，相对向量）(C99)</td></tr><tr><td>z</td><td>和整数转换符一起使用。表示一个size_t值（sizeof的返回值）(C99)</td></tr></tbody></table><h2 id="数值数据类型-u-ul-b"><a href="#数值数据类型-u-ul-b" class="headerlink" title="数值数据类型 u ul b"></a>数值数据类型 u ul b</h2><h3 id="用于说明数据类型"><a href="#用于说明数据类型" class="headerlink" title="用于说明数据类型"></a>用于说明数据类型</h3><p>u &#x3D;&#x3D; unsigned int</p><p>l &#x3D;&#x3D; long</p><p>ul &#x3D;&#x3D; unsigned long</p><p>数值后面加“L”和“l”（小写的l）的意义是该数值是long型。<br>详细说如下：<br>5L 的数据类型为long int。<br>5.12L 的数据类型为long double。<br>数值后面加“U”和“u”的意义是该数值是unsigned型。</p><h3 id="用于说明数值表示方法"><a href="#用于说明数值表示方法" class="headerlink" title="用于说明数值表示方法"></a>用于说明数值表示方法</h3><table><thead><tr><th>进制↓ \ 表示方法→</th><th>前面加</th><th></th><th>示例</th></tr></thead><tbody><tr><td>二进制</td><td>0b</td><td></td><td>0b1010 &#x3D; 10</td></tr><tr><td>八进制</td><td>0</td><td></td><td>012 &#x3D; 10</td></tr><tr><td>十进制</td><td></td><td>u l ul</td><td>1u (规范性)</td></tr><tr><td>十六进制</td><td>0x</td><td></td><td>0x12 &#x3D; 18</td></tr></tbody></table><ul><li>注意：在宏定义中数字应加上尾缀，避免与八进制混淆</li></ul><h2 id="sprintf"><a href="#sprintf" class="headerlink" title="sprintf()"></a>sprintf()</h2><ul><li><p>写入buff的数据会连带‘\0’一起写入</p></li><li><p>在 C 里，对“字符串”的通常约定，是以 <code>&#39;\0&#39;</code> 为结尾的字符串。从而在传递字符串参数的时候，只需要一个指向字符串首字符的指针。来自 C 的操作字符串的函数(<code>sprintf</code>, <code>strcpy</code>, <code>strcat</code>, 等等)通常都遵循这一约定，包括在写字符串的时候，会在末尾添加一个 <code>&#39;\0&#39;</code> 。（除非在某些情况下有特殊约定）</p><p>但是，<code>memcpy</code> 等不是操作字符串的函数，就不会添加最后的 <code>&#39;\0&#39;</code> 。</p></li></ul><h2 id="snprintf"><a href="#snprintf" class="headerlink" title="snprintf()"></a>snprintf()</h2><ul><li>所传入的值以<strong>‘\0’</strong>结尾 要得到 <strong>20</strong> 个数据需要传入参数 <strong>20+1</strong></li><li>如果传入的str是<code>&quot;Hello&quot;</code> size参数是5则 无法写入<code>&#39;\0&#39;</code> ,size参数是6 则可以写入 <code>&#39;\0&#39;</code></li></ul><h2 id="sscanf"><a href="#sscanf" class="headerlink" title="sscanf()"></a>sscanf()</h2><h3 id="原型-1"><a href="#原型-1" class="headerlink" title="原型"></a>原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sscanf</span><span class="hljs-params">( <span class="hljs-type">const</span> <span class="hljs-type">char</span> *buffer, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, [ argument ] ...   )</span>; <br><br></code></pre></td></tr></table></figure><p>buffer 存储的数据<br>format 窗体控件字符串。 有关详细信息，请参阅”格式规范”。<br>argument 可选自变量<br>locale 要使用的区域设置</p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>sscanf与scanf类似，都是用于输入的，只是后者以键盘(stdin)为输入源，前者以<strong>固定字符串</strong>为输入源。</p><h4 id="控制字符说明"><a href="#控制字符说明" class="headerlink" title="控制字符说明"></a>控制字符说明</h4><blockquote><p>%c 一个单一的字符<br>%d 一个十进制整数<br>%i 一个整数<br>%e, %f, %g 一个浮点数<br>%o 一个八进制数<br>%s 一个字符串<br>%x 一个十六进制数<br>%p 一个指针<br>%n 一个等于读取字符数量的整数<br>%u 一个无符号整数<br>%[] 一个字符集<br>%% 一个精度符</p></blockquote><h3 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h3><p>函数将返回成功赋值的字段个数；返回值不包括已读取但未赋值的字段个数。 返回值为 0 表示没有将任何字段赋值。 如果在第一次读取之前到达字符串结尾，则返回EOF。</p><h3 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h3><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> buf[<span class="hljs-number">512</span>];<br><span class="hljs-built_in">sscanf</span>(<span class="hljs-string">&quot;123456 &quot;</span>, <span class="hljs-string">&quot;%s&quot;</span>, buf);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf);<br><span class="hljs-comment">//结果为：123456</span><br><br><br><span class="hljs-comment">//取指定长度的字符串。如在下例中，取最大长度为4字节的字符串。</span><br><span class="hljs-built_in">sscanf</span>(<span class="hljs-string">&quot;123456 &quot;</span>, <span class="hljs-string">&quot;%4s&quot;</span>, buf);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf);<br><span class="hljs-comment">//结果为：1234</span><br><br><span class="hljs-comment">//取到指定字符为止的字符串。如在下例中，取遇到空格为止字符串。</span><br><span class="hljs-built_in">sscanf</span>(<span class="hljs-string">&quot;123456 abcdedf&quot;</span>, <span class="hljs-string">&quot;%[^ ]&quot;</span>, buf);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf);<br><span class="hljs-comment">//结果为：123456</span><br><br><span class="hljs-comment">//取仅包含指定字符集的字符串。如在下例中，取仅包含1到9和小写字母的字符串。</span><br><span class="hljs-built_in">sscanf</span>(<span class="hljs-string">&quot;123456abcdedfBCDEF&quot;</span>, <span class="hljs-string">&quot;%[1-9a-z]&quot;</span>, buf);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf);<br><span class="hljs-comment">//结果为：123456abcdedf</span><br><br><span class="hljs-comment">//取到指定字符集为止的字符串。如在下例中，取遇到大写字母为止的字符串。</span><br><span class="hljs-built_in">sscanf</span>(<span class="hljs-string">&quot;123456abcdedfBCDEF&quot;</span>, <span class="hljs-string">&quot;%[^A-Z]&quot;</span>, buf);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf);<br><span class="hljs-comment">//结果为：123456abcdedf</span><br><br><span class="hljs-comment">//给定一个字符串iios/12DDWDFF@122，获取 / 和 @ 之间的字符串，先将 &quot;iios/&quot;过滤掉，再将非&#x27;@&#x27;的一串内容送到buf中</span><br><span class="hljs-built_in">sscanf</span>(<span class="hljs-string">&quot;iios/12DDWDFF@122&quot;</span>, <span class="hljs-string">&quot;%*[^/]/%[^@]&quot;</span>, buf);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf);<br><span class="hljs-comment">//结果为：12DDWDFF</span><br><br><span class="hljs-comment">//给定一个字符串&quot;hello, world&quot;，仅保留&quot;world&quot;。（注意：“，”之后有一空格）</span><br><span class="hljs-built_in">sscanf</span>(<span class="hljs-string">&quot;hello, world&quot;</span>, <span class="hljs-string">&quot;%*s%s&quot;</span>, buf);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf);<br><span class="hljs-comment">//结果为：world</span><br><br></code></pre></td></tr></table></figure><h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><p><img src="/2018/ef667962/20161218131342960.png" srcset="/img/loading.gif" lazyload></p><h2 id="Union"><a href="#Union" class="headerlink" title="Union"></a>Union</h2><h3 id="数据拆分、移位"><a href="#数据拆分、移位" class="headerlink" title="数据拆分、移位"></a>数据拆分、移位</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">union</span><br>&#123;<br>	u16 Val_u16;<br>	u8 Val_u8[<span class="hljs-number">2</span>];<br>&#125;_HL_UNION;<br></code></pre></td></tr></table></figure><h2 id="Struct"><a href="#Struct" class="headerlink" title="Struct"></a>Struct</h2><ul><li>注意节约内存，小数据全部写在前面方便对齐。</li><li>结构体内的结构体因为已经是对其了的，所以，可以建议放在最前、最后。</li></ul><h2 id="匿名-union-struct"><a href="#匿名-union-struct" class="headerlink" title="匿名 union struct"></a>匿名 union struct</h2><p>可以在<strong>结构体</strong>中声明某个联合体（或结构体）而不用指出它的名字，如此之后就可以像使用结构体成员一样直接使用其中联合体（或结构体）的成员。</p><blockquote><p>Anonymous unions are a GNU extension, not part of any standard version of the C language.</p><p><strong>Anonymous unions were added in C11, so they are now a standard part of the language. Presumably GCC’s <code>-std=c11</code> lets you use them.</strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// union 普通联合</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  <span class="hljs-type">char</span> title[<span class="hljs-number">50</span>];<br>  <span class="hljs-type">char</span> author[<span class="hljs-number">50</span>];<br>  <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>    <span class="hljs-type">float</span> dollars;<br>    <span class="hljs-type">int</span> yen;<br>  &#125; price;<br>&#125; book;<br><span class="hljs-comment">// anonymous union 匿名联合</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  <span class="hljs-type">char</span> title[<span class="hljs-number">50</span>];<br>  <span class="hljs-type">char</span> author[<span class="hljs-number">50</span>];<br>  <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>    <span class="hljs-type">float</span> dollars;<br>    <span class="hljs-type">int</span> yen;<br>  &#125;;<br>&#125; book;<br><br><span class="hljs-comment">// 在前一种定义的情况下，需要使用：</span><br>book.price.dollars;<br>book.price.yen;<br><span class="hljs-comment">// 而在后面一种定义下，我们直接使用：</span><br>book.dollars;<br>book.yen;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">person_jim_t</span>&#123;</span>  <br>    <span class="hljs-type">char</span>    *name;  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span>  <br>        <span class="hljs-type">int</span>  area_code;  <br>        <span class="hljs-type">long</span> phone_number;  <br>    &#125;; <br>&#125;<span class="hljs-type">person_jim_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">person_tim_t</span>&#123;</span><br>    <span class="hljs-type">char</span>    *name;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span>&#123;</span><br>        <span class="hljs-type">char</span> gender;<br>        <span class="hljs-type">int</span>  id;<br>    &#125;;<br>&#125;<span class="hljs-type">person_tim_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">union</span> _<span class="hljs-title">net_info_t</span>&#123;</span><br>    <span class="hljs-type">uint32_t</span>                val[<span class="hljs-number">3</span>];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>        <span class="hljs-type">uint8_t</span>             ip[<span class="hljs-number">4</span>];          <span class="hljs-comment">// int ip address</span><br>        <span class="hljs-type">uint8_t</span>             mask[<span class="hljs-number">4</span>];        <span class="hljs-comment">// </span><br>        <span class="hljs-type">uint8_t</span>             gateway[<span class="hljs-number">4</span>];     <span class="hljs-comment">// </span><br>    &#125;;<br>&#125; <span class="hljs-type">net_info_t</span>;<br></code></pre></td></tr></table></figure><h3 id="keil"><a href="#keil" class="headerlink" title="keil"></a>keil</h3><p>keil也支持匿名结构体、联合体 需要使用编译器参数<code>#pragma anon_unions</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> anon_unions</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">union</span> &#123;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> num;<br>	<span class="hljs-keyword">struct</span> &#123;<br>		<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nLow        :<span class="hljs-number">8</span>;<br>		<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nHigh         :<span class="hljs-number">8</span>;<br>	&#125;;<br>&#125;kkTypedef;<br></code></pre></td></tr></table></figure><h2 id="register"><a href="#register" class="headerlink" title="register"></a>register</h2><p>　　这个关键字<strong>请求</strong>（只是请求，最终看编译器）编译器尽可能的将变量存在CPU内部寄存器中，而不是通过内存寻址访问，以提高效率。注意是尽可能，不是绝对。你想想，一个CPU 的寄存器也就那么几个或几十个，你要是定义了很多很多register 变量，它累死也可能不能全部把这些变量放入寄存器吧。</p><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><ol><li><p>并行设备的硬件寄存器（如：状态寄存器）</p><ul><li><p>延伸 const volatile</p><ul><li><blockquote><p>两者同时修饰一个对象的典型情况，是用于驱动中访问外部设备的只读寄存器。</p><ol><li>本程序段中不能对a作修改，任何修改都是非法的，或者至少是粗心，编译器应该报错，防止这种粗心；</li><li>另一个程序段则完全有可能修改，因此编译器最好不要做太激进的优化。</li></ol></blockquote></li></ul></li></ul></li><li><p>一个中断服务子程序中会访问到的<strong>非自动变量</strong>(Non-automatic variables)</p><ul><li><strong>自动变量</strong>：是在函数内部定义和使用的变量，它是<strong>局部变量</strong>。</li><li><strong>非自动变量</strong>：有两种，一种是<strong>全局变量</strong>，一种是<strong>静态变量</strong>。</li></ul></li><li><p>多线程应用中被几个任务共享的变量</p></li></ol><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><h3 id="关于Const指针"><a href="#关于Const指针" class="headerlink" title="关于Const指针"></a>关于Const指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">int</span> *p1;		<span class="hljs-comment">//指向常量的指针 (const int) *p1，指向的值不能修改，指针本身可以修改</span><br><br><span class="hljs-type">int</span> *<span class="hljs-type">const</span> p2;    	<span class="hljs-comment">//指针是常量 int *(const p2) 不能指向别的变量，但是指向的变量可以修改		因为不能被修改所以必须要被初始化。</span><br>   <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *<span class="hljs-type">const</span> p3;<span class="hljs-comment">//不能指向别的变量，也不能修改指向变量的值</span><br><br><span class="hljs-comment">//注意   这个等同于第一个   容易产生误解尽量不要使用这个表达</span><br><span class="hljs-type">int</span> <span class="hljs-type">const</span> *p;		<span class="hljs-comment">//指向常量的指针</span><br></code></pre></td></tr></table></figure><h3 id="Const常量可以被修改"><a href="#Const常量可以被修改" class="headerlink" title="Const常量可以被修改"></a>Const常量可以被修改</h3><p>对于一个Cont常量，实际上你访问的是它的<strong>内存拷贝</strong>，你仍然可以去用指针去修改它。</p><h3 id="const-局部变量"><a href="#const-局部变量" class="headerlink" title="const 局部变量"></a>const 局部变量</h3><p>const 局部变量居然定义在stack上，用指针居然可以修改其值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>	<span class="hljs-type">const</span> <span class="hljs-type">int</span> const_val=<span class="hljs-number">66</span>;<br>	<span class="hljs-type">int</span> *p = &amp;const_val;<br>    <br>	*p = <span class="hljs-number">33</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;const_val=%d \r\n&quot;</span>, const_val );		<span class="hljs-comment">//const_val=33</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="const-volatile"><a href="#const-volatile" class="headerlink" title="const volatile"></a>const volatile</h3><p>见 volatile 相关内容</p><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id="const-指针"><a href="#const-指针" class="headerlink" title="const 指针"></a>const 指针</h3><p><a href="###%E5%85%B3%E4%BA%8EConst%E6%8C%87%E9%92%88">关于Const指针</a></p><h3 id="有x个指针的数组"><a href="#有x个指针的数组" class="headerlink" title="有x个指针的数组"></a>有x个指针的数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *p2[<span class="hljs-number">3</span>]<span class="hljs-comment">//这是有三个指针的数组</span><br></code></pre></td></tr></table></figure><h3 id="指向x个元素数组的指针"><a href="#指向x个元素数组的指针" class="headerlink" title="指向x个元素数组的指针"></a>指向x个元素数组的指针</h3><ul><li>指针执行<code>p1 = p1 + 1;</code>操作，p1中的值会增加12个字节</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> (*p1)[<span class="hljs-number">3</span>]<span class="hljs-comment">//指向x个元素数组的指针</span><br></code></pre></td></tr></table></figure><h3 id="二维、多维数组的指针"><a href="#二维、多维数组的指针" class="headerlink" title="二维、多维数组的指针"></a>二维、多维数组的指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>] =&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;,&#123;<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;&#125;<br><span class="hljs-type">int</span> (*pa)[<span class="hljs-number">2</span>] = a<br><span class="hljs-comment">//a是指向指针的指针</span><br><span class="hljs-comment">//a是一个指针，他指向的是下一维度的数组的头（指针、地址，它指向二维数组的第一个值），</span><br>*(*(a+<span class="hljs-number">0</span>)+<span class="hljs-number">0</span>) == <span class="hljs-number">1</span><br>*(*(a+<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>) == <span class="hljs-number">2</span><br>*(*(a+<span class="hljs-number">1</span>)+<span class="hljs-number">0</span>) == <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h3 id="指针参数的内存传递"><a href="#指针参数的内存传递" class="headerlink" title="指针参数的内存传递"></a>指针参数的内存传递</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a=<span class="hljs-number">10</span>, b=<span class="hljs-number">20</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">fun_p</span><span class="hljs-params">(<span class="hljs-type">int</span> *p)</span><br>&#123;<br>    p = &amp;b;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">fun_p_p</span><span class="hljs-params">(<span class="hljs-type">int</span> *p)</span><br>&#123;<br>    *p = &amp;b;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> *p_a = &amp;a;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&amp;a=%X-&amp;b=%X\r\n&quot;</span>, &amp;a, &amp;b);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;p_a=%X\r\n&quot;</span>, p_a);<br><br>    fun_p(p_a);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;p_a=%X\r\n&quot;</span>, p_a);<br><br>    fun_p_p(&amp;p_a);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;p_a=%X\r\n&quot;</span>, p_a);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译器总是要为函数的每个参数制作临时副本，<code>void fun_p(int *p)</code>函数的指针参数是<code>p</code>，编译器为其分配的副本是<code>_p</code>，编译器使<code>_p=p</code>就是两者不是同一个变量但是指向相同的地址，函数里面修改了<code>_P</code>的指向，但是并没有修改<code>p</code>的指向，所以导致函数<code>void fun_p(int *p)</code>并没有得到期待的运行结果。</p><p>而<code>void fun_p_p(int *p)</code>函数是用指向<code>p_a</code>的指针修改了<code>p_a</code>的值。</p><p><span style="color:red">修改某个变量，要用指向这个变量的指针！而修改指针要用（指向指针的指针）才行！</span></p><h3 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h3><p>申请内存后的指针，被<code>free()</code>或<code>delete()</code>之后内存被释放，但是指针还是指向的那块内存，这个指针就叫野指针。</p><h2 id="跳的转到指定地址执行程序"><a href="#跳的转到指定地址执行程序" class="headerlink" title="跳的转到指定地址执行程序"></a>跳的转到指定地址执行程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">第一种办法：<span class="hljs-keyword">goto</span><br>第二种办法：<br><span class="hljs-comment">//解释</span><br><span class="hljs-type">void</span> (*)(<span class="hljs-type">void</span>)				<span class="hljs-comment">//函数指针类型</span><br>(<span class="hljs-type">void</span> (*)(<span class="hljs-type">void</span>)) <span class="hljs-number">100</span>		<span class="hljs-comment">//将 100 强制转换为 函数指针类型</span><br><br><span class="hljs-comment">//函数定义</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>	<span class="hljs-comment">//code</span><br>&#125;<br><br><span class="hljs-comment">//函数调用</span><br>func();<br><br><span class="hljs-comment">//使用函数指针来执行</span><br><span class="hljs-type">void</span> (*pF)(<span class="hljs-type">void</span>) = func;	<span class="hljs-comment">//使用函数指针指向func函数</span><br>pF();						<span class="hljs-comment">//利用函数指针调用函数</span><br></code></pre></td></tr></table></figure><h2 id="内联函数-inline"><a href="#内联函数-inline" class="headerlink" title="内联函数 inline"></a>内联函数 inline</h2><p>详见Keil-&gt; Arm Compiler 6 User’s Guides-&gt; Inlining functions</p><table><thead><tr><th>Inlining options, keywords, or attributes</th><th>Description</th></tr></thead><tbody><tr><td><code>__inline__</code></td><td>Specify this keyword on a function definition or declaration as a hint to the compiler to favor inlining of the function. However, for each function call, the compiler still decides whether to inline the function. This is equivalent to <code>__inline</code>.</td></tr><tr><td><code>__attribute__((always_inline))</code></td><td>Specify this function attribute on a function definition or declaration to tell the compiler to always inline this function, with certain exceptions such as for recursive functions. This overrides the <code>-fno-inline-functions</code> option.</td></tr><tr><td><code>__attribute__((noinline))</code></td><td>Specify this function attribute on a function definition or declaration to tell the compiler to not inline the function. This is equivalent to <code>__declspec(noinline)</code>.</td></tr><tr><td><code>-fno-inline-functions</code></td><td>This is a compiler command-line option. Specify this option to the compiler to disable inlining. This option overrides the <code>__inline__</code> hint.</td></tr></tbody></table><p><strong>Note:</strong></p><ul><li>Arm Compiler only inlines functions within the same compilation unit, unless you use Link Time Optimization. For more information, see <a href="armclang_intro_chr1413367986635.htm"><em>Optimizing across modules with link time optimization</em></a> in the Software Development Guide.</li><li>C++ and C99 provide the <code>inline</code> language keyword. The effect of this <code>inline</code> language keyword is identical to the effect of using the <code>__inline__</code> compiler keyword. However, the effect in C99 mode is different from the effect in C++ or other C that does not adhere to the C99 standard. For more information, see <a target="_blank" rel="noopener" href="https://developer.arm.com/docs/101754/0614/armclang-reference/other-compiler-specific-features/inline-functions"><em>Inline functions</em></a> in the Arm Compiler Reference Guide.</li><li>Function inlining normally happens at higher optimization levels, such as <code>-O2</code>, except when you specify <code>__attribute__((always_inline))</code>.</li></ul><h2 id="do-while-continue"><a href="#do-while-continue" class="headerlink" title="do while continue"></a>do while continue</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 相当于一个go to 去到了contin</span><br>    <span class="hljs-comment">// ...</span><br>contin:;<br>&#125; <span class="hljs-keyword">while</span> (<span class="hljs-comment">/* ... */</span>);<br></code></pre></td></tr></table></figure><h2 id="预编译ifdef"><a href="#预编译ifdef" class="headerlink" title="预编译ifdef"></a>预编译ifdef</h2><ul><li><p>第一种</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> WIN7</span><br>     xxx<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined WIN8 </span><br>	xxx<br><span class="hljs-meta">#<span class="hljs-keyword">else</span> </span><br>	xxxx<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li><li><p>第二种</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(WIN7)</span><br>	xxx<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(WIN8) </span><br>	xxx<br><span class="hljs-meta">#<span class="hljs-keyword">else</span> </span><br>	xxxx<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure></li></ul><h2 id="宏相关"><a href="#宏相关" class="headerlink" title="宏相关"></a>宏相关</h2><ul><li><p>一般来说在宏中不要使用增量(++i)或减量(–i)运算符。假设宏里面有多个替换，结果是不可预知的。</p></li><li><p>在宏后面对宏的注释应该要用块注释，而不应使用行注释。因为有些编译器会将行注释理解成宏的一部分(这么智障的编译器嘛？？)。</p></li><li><p>define定义一个宏函数记得写 do{}while(0)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> device_init_wakeup(dev,val) \ </span><br> device_can_wakeup(dev) = !!(val);   \ <br> device_set_wakeup_enable(dev,val);<br> <br> <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>) device_init_wakeup(d, v);<br></code></pre></td></tr></table></figure><p>为什么不简单写{}</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> device_init_wakeup(dev,val) \ </span><br>&#123; device_can_wakeup(dev) = !!(val); \ <br>device_set_wakeup_enable(dev,val); &#125;<br><br><span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>) <br>    device_init_wakeup(d, v);<br><span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">continue</span>;<br></code></pre></td></tr></table></figure></li><li><p>__FILE__和__LINE__，FILE展开为当前源文件的文件名，是一个字符串，LINE展开为当前代码行的行号，是一个整数。</p></li><li><p>类似上面的 C99有__func__ 可以打印出当前函数名，但是注意这是一个变量而不是宏。</p></li><li><p>gcc 定义宏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">gcc -c -DMACHINE=<span class="hljs-number">8086</span> main.c<br></code></pre></td></tr></table></figure></li><li><p>在宏中用#将宏参量（可以是变量、函数名）转换成<strong>字符串</strong>。——创建字符串</p></li><li><p>在宏中用##将两者进行粘合变成<strong>一个标识符</strong>(变量等…)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> X_NAME(n) 	x##n</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> X_CHAR(x)	#x</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PSQR(x)		printf( <span class="hljs-string">&quot;The square of &quot;</span> #x <span class="hljs-string">&quot; is %d\n&quot;</span>,((x)*(x)) )</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PSQRx(x)	printf( <span class="hljs-string">&quot;The square of %s is %d\n&quot;</span>, #x, ((x)*(x)) )</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">X_NAME</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span> = <span class="hljs-number">5</span>;		<span class="hljs-comment">//等价于   x1 = 5;</span><br>PSQR( x1 );<br>PSQRx( x1 );<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s-%s-%d\r\n&quot;</span>, X_CHAR( X_NAME(<span class="hljs-number">1</span>) ), X_CHAR( x1 ), X_NAME(<span class="hljs-number">1</span>) );<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出：</span><br><span class="hljs-comment">The square of x1 is 25</span><br><span class="hljs-comment">The square of x1 is 25</span><br><span class="hljs-comment">X_NAME( 1 )-x1-5</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li><li><p>可变参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEBUGP(format, ...) printk(format, ## __VA_ARGS__)</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="宏展开的顺序"><a href="#宏展开的顺序" class="headerlink" title="宏展开的顺序"></a>宏展开的顺序</h3><ul><li><p>带#和带##的运算符不需要进行参数的展开！！除了带#和##运算符的参数之外，其它参数在替换之前要对实参本身做充分的展开，所以应该先把sub_z展开成26再替换到alt[x]中x的位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> sh(x) printf(<span class="hljs-string">&quot;n&quot;</span> #x <span class="hljs-string">&quot;=%d, or %d\n&quot;</span>,n##x,alt[x])</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> sub_z 26</span><br><br>sh(sub_z)<br><span class="hljs-comment">//展开成了printf(&quot;n&quot; &quot;sub_z&quot; &quot;=%d, or %d\n&quot;,nsub_z,alt[26])</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h2><h3 id="signed-int转换到unsigned-int"><a href="#signed-int转换到unsigned-int" class="headerlink" title="signed int转换到unsigned int"></a>signed int转换到unsigned int</h3><p>带符号整型转换到无符号整型,最高位(high-order bit)会丧失其作为符号位的功能。如果该带符号整数的值非负,那么转换后值不变;如果该带符号整数的值为负,那么转换后的结果通常是一个非常大的正数。</p><h2 id="uint32-t-无符号相减-定时器溢出问题"><a href="#uint32-t-无符号相减-定时器溢出问题" class="headerlink" title="uint32_t 无符号相减 定时器溢出问题"></a>uint32_t 无符号相减 定时器溢出问题</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">timer_loop</span><span class="hljs-params">()</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Timer</span>* <span class="hljs-title">target</span>;</span><br>	<span class="hljs-keyword">for</span>(target=head_handle; target; target=target-&gt;next) &#123;<br>		<span class="hljs-keyword">if</span>(_timer_ticks &gt;= target-&gt;timeout) &#123;<br>			<span class="hljs-keyword">if</span>(target-&gt;repeat == <span class="hljs-number">0</span>) &#123;<br>				timer_stop(target);<br>			&#125; <span class="hljs-keyword">else</span> &#123;<br>				target-&gt;timeout = _timer_ticks + target-&gt;repeat;<br>			&#125;<br>			target-&gt;timeout_cb();<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个uint32_t的_timer_ticks，每毫秒自加1，设备运行到49天的时候会涉及到溢出的问题。所以在timer_loop里面的判断超时的语句需要小修改下。</p><p><code>if(_timer_ticks &gt;= target-&gt;timeout)</code></p><p>修改为</p><p><code>if((int)((uint32_t)(target-&gt;timeout -_timer_ticks)) &lt;= 0)</code></p><p>完美解决uint32_t变量溢出时，超时判断有误的bug</p><p>HAL库的无符号相减，tick是++</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>((now_tick - tick_start) &lt; wait )<br>&#123;&#125;<br><br><span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure><p><strong>RT-thread 内的判断</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 最大定时长度是 RT_TICK_MAX / 2</span><br><span class="hljs-keyword">if</span> ((current_tick - t-&gt;timeout_tick) &lt; RT_TICK_MAX / <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p><strong>这里其实涉及的是无符号数相减，减出负数</strong></p><p>负数在计算机内是用其补码来存储的。</p><p>减法会被换算成两个数的加法，a-b会被换算成a加上b的补码，即a+(~b+1)。</p><p>252-250&#x3D;(b1111 1100)+(b0000 0110)&#x3D;(b0000 0010)&#x3D;2</p><p>1-250&#x3D;(b0000 0001)+(b0000 0110)&#x3D;(b0000 0111)&#x3D;7</p><p><em><strong>所以计算两值的差值就可以直接相减</strong></em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">uint8_t</span> now = <span class="hljs-number">2</span>;<br><span class="hljs-type">uint8_t</span> pre = <span class="hljs-number">250</span>;<br><span class="hljs-type">uint8_t</span> differ=<span class="hljs-number">0</span>;<br><br>differ = (<span class="hljs-type">uint8_t</span>)(now - pre);<br><span class="hljs-comment">// differ = 0x08</span><br></code></pre></td></tr></table></figure><h2 id="c编译原理"><a href="#c编译原理" class="headerlink" title="c编译原理"></a>c编译原理</h2><p><img src="/2018/ef667962/2018051223284857.png" srcset="/img/loading.gif" lazyload alt="2018051223284857"></p><p><img src="/2018/ef667962/20180513215202780.png" srcset="/img/loading.gif" lazyload alt="20180513215202780"></p><h3 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h3><ul><li>define展开</li><li>FILE LINE等展开</li><li>include包含</li><li>转化 .i 文件</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">gcc -E<br></code></pre></td></tr></table></figure><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><ul><li>优化在这进行，包括数值计算一类</li><li>编译成汇编文件</li><li>转化 .s .asm文件</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">gcc -S<br></code></pre></td></tr></table></figure><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><ul><li>汇编语言代码翻译成目标机器指令的过程</li><li>data段code段在这里产生</li><li>转化 .o .obj文件</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">gcc -c<br></code></pre></td></tr></table></figure><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><ul><li>链接成 .exe .out .axf等</li><li>动态链接、静态链接(动态库.so、静态库.a)</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">gcc<br></code></pre></td></tr></table></figure><h2 id="内存分配相关"><a href="#内存分配相关" class="headerlink" title="内存分配相关"></a>内存分配相关</h2><p><img src="/2018/ef667962/806053-20170722131756261-1095755633.png" srcset="/img/loading.gif" lazyload alt="806053-20170722131756261-1095755633"></p><h3 id="code-代码区"><a href="#code-代码区" class="headerlink" title=".code 代码区"></a>.code 代码区</h3><p>代码段（code segment&#x2F;text segment ）通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。</p><blockquote><p>STM32 在上电启动之后默认从 Flash 启动, 在STM32里面Code部分不会被搬运到RAM内</p></blockquote><h3 id="data-已初始化区"><a href="#data-已初始化区" class="headerlink" title=".data 已初始化区"></a>.data 已初始化区</h3><h3 id="bss-未初始化区"><a href="#bss-未初始化区" class="headerlink" title=".bss 未初始化区"></a>.bss 未初始化区</h3><h3 id="heap-堆区"><a href="#heap-堆区" class="headerlink" title="heap 堆区"></a>heap 堆区</h3><h3 id="stack-栈区"><a href="#stack-栈区" class="headerlink" title="stack 栈区"></a>stack 栈区</h3><p><img src="/2018/ef667962/686215-20151218231826459-500964006.png" srcset="/img/loading.gif" lazyload alt="686215-20151218231826459-500964006"></p><ul><li><strong>在C语言中，函数参数的入栈顺序是从右到左</strong></li></ul><h2 id="new-delete-malloc-free"><a href="#new-delete-malloc-free" class="headerlink" title="new delete malloc free"></a>new delete malloc free</h2><blockquote><p>free两次有时可能是极其严重的安全漏洞，将一个指针释放两次是非常危险的行为，它可能造成任意代码执行。 <a target="_blank" rel="noopener" href="https://awakened1712.github.io/hacking/hacking-whatsapp-gif-rce/">参考</a></p></blockquote><h3 id="new-x2F-delete"><a href="#new-x2F-delete" class="headerlink" title="new &#x2F; delete"></a>new &#x2F; delete</h3><ul><li>Allocate &#x2F; release memory 分配&#x2F;释放<ol><li>Memory allocated from ‘Free Store’. 这个FreeStore和Heap不一定一样 似乎取决于它的具体实现方式</li><li>Returns a fully typed pointer.</li><li><code>new</code> (standard version) never returns a <code>NULL</code> (will throw on failure).</li><li>Are called with Type-ID (compiler calculates the size). 使用 Type-ID 调用（编译器计算大小）。</li><li>Has a version explicitly to handle arrays. 有一个明确的版本来处理数组。</li><li>Reallocating (to get more space) not handled intuitively (because of copy constructor). 重新分配（以获得更多空间）没有直观地处理（因为复制构造函数）。</li><li>Whether they call <code>malloc</code> &#x2F; <code>free</code> is implementation defined. 他们是否调用<code>malloc</code>&#x2F;<code>free</code>是由实现来定义的。</li><li>Can add a new memory allocator to deal with low memory (<code>std::set_new_handler</code>).</li><li><code>operator new</code> &#x2F; <code>operator delete</code> can be overridden legally.</li><li><strong>Constructor &#x2F; destructor used to initialize &#x2F; destroy the object. 构造函数&#x2F;析构函数用于初始化&#x2F;销毁对象。</strong></li></ol></li></ul><h3 id="malloc-x2F-free"><a href="#malloc-x2F-free" class="headerlink" title="malloc &#x2F; free"></a>malloc &#x2F; free</h3><ul><li>Allocate &#x2F; release memory<ol><li>Memory allocated from ‘Heap’.</li><li>Returns a <code>void*</code>.</li><li>Returns <code>NULL</code> on failure.</li><li>Must specify the size required in bytes. 必须以字节为单位指定所需的大小。</li><li>Allocating array requires manual calculation of space. 分配数组需要手动计算空间。</li><li>Reallocating larger chunk of memory simple (no copy constructor to worry about). 重新分配更大的内存块很简单（无需担心复制构造函数）。</li><li>They will <strong>NOT</strong> call <code>new</code> &#x2F; <code>delete</code>.</li><li>No way to splice user code into the allocation sequence to help with low memory. 无法将用户代码拼接到分配序列中以帮助解决内存不足的问题。</li><li><code>malloc</code> &#x2F; <code>free</code> can <strong>NOT</strong> be overridden legally.</li></ol></li></ul><h3 id="Table-comparison-of-the-features"><a href="#Table-comparison-of-the-features" class="headerlink" title="Table comparison of the features:"></a>Table comparison of the features:</h3><table><thead><tr><th align="left">Feature</th><th align="left"><code>new</code> &#x2F; <code>delete</code></th><th align="left"><code>malloc</code> &#x2F; <code>free</code></th></tr></thead><tbody><tr><td align="left">Memory allocated from</td><td align="left">‘Free Store’</td><td align="left">‘Heap’</td></tr><tr><td align="left">Returns</td><td align="left">Fully typed pointer</td><td align="left"><code>void*</code></td></tr><tr><td align="left">On failure</td><td align="left">Throws (never returns <code>NULL</code>)</td><td align="left">Returns <code>NULL</code></td></tr><tr><td align="left">Required size</td><td align="left">Calculated by compiler</td><td align="left">Must be specified in bytes<br>必须以字节为单位指定</td></tr><tr><td align="left">Handling arrays<br>处理数组</td><td align="left">Has an explicit version</td><td align="left">Requires manual calculations</td></tr><tr><td align="left">Reallocating<br>重新分配</td><td align="left">Not handled intuitively</td><td align="left">Simple (no copy constructor)</td></tr><tr><td align="left">Call of reverse</td><td align="left">Implementation defined</td><td align="left">No</td></tr><tr><td align="left">Low memory cases</td><td align="left">Can add a new memory allocator<br>可以添加新的内存分配器</td><td align="left">Not handled by user code<br>不由用户代码处理</td></tr><tr><td align="left">Overridable</td><td align="left">Yes</td><td align="left">No</td></tr><tr><td align="left">Use of constructor &#x2F; destructor<br>构造函数&#x2F;析构函数的使用</td><td align="left">Yes</td><td align="left">No</td></tr><tr><td align="left">Type</td><td align="left">运算符</td><td align="left">函数</td></tr></tbody></table><p>Technically, memory allocated by <code>new</code> comes from the ‘Free Store’ while memory allocated by <code>malloc</code> comes from the ‘Heap’. Whether these two areas are the same is an implementation detail, which is another reason that <code>malloc</code> and <code>new</code> cannot be mixed. 从技术上讲，分配的内存<code>new</code>来自“免费存储”，而分配的内存<code>malloc</code>来自“堆”。这两个区域是否相同是一个实现细节，这是另一个<code>malloc</code>不能<code>new</code>混为一谈的原因。</p><ul><li><p>最相关的区别是<code>new</code>运算符分配内存然后调用<strong>构造函数</strong>，<code>delete</code>调用<strong>析构函数</strong>然后释放内存。</p><ul><li>严格来说，new 操作符只是分配内存。是 new 表达式调用 new 运算符，然后在分配的内存中运行构造函数。</li></ul></li><li><p><code>new</code>调用对象的ctor，<code>delete</code>调用dtor。</p><p><code>malloc</code>&amp;<code>free</code>只是分配和释放原始内存。</p></li></ul><h2 id="复合字面量（Compound-Literals）"><a href="#复合字面量（Compound-Literals）" class="headerlink" title="复合字面量（Compound Literals）"></a>复合字面量（Compound Literals）</h2><p>字面量是<strong>除了符号常量之外的常量</strong>。</p><p>如，1是int型字面量，3.14是float型字面量，’C’是char型字面量，’Yudao’是字符串字面量。</p><p>那么，数组和结构体是否也能有字面量来表示呢？</p><p>因此，C99标准委员会就新增了复合字面量(compound literals)。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><blockquote><p>( type-name ) { initializer-list }</p><p>( type-name ) { initializer-list , }</p></blockquote><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><blockquote><p>The type name shall specify an object type or an array of unknown size, but not a variable length array type.<br>type name指定了数组类型或结构体类型，数组长度不能是可变的。</p><p>No initializer shall attempt to provide a value for an object not contained within the entire unnamed object specified by the compound literal.<br>匿名”对象”的初始化必须在在复合字面量的大括号中。</p><p>If the compound literal occurs outside the body of a function, the initializer list shall consist of constant expressions.<br>如果复合字面量是文件作用域，initializer list的表达式必须是常量表达式。</p></blockquote><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>例如下面是一个普通的数组声明。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">int</span> age[<span class="hljs-number">2</span>]=[<span class="hljs-number">19</span>,<span class="hljs-number">20</span>];<br></code></pre></td></tr></table></figure><p>下面创建了一个和age数组相同的匿名数组，也有两个int类型值</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">(<span class="hljs-built_in">int</span> [<span class="hljs-number">2</span>])&#123;<span class="hljs-number">19</span>,<span class="hljs-number">20</span>&#125;; <span class="hljs-comment">//内含2个元素的复合字面量</span><br></code></pre></td></tr></table></figure><p>注意去掉申明中的数组名，留下的<code>int[2]</code>就是复合字面量的类型名。</p><p>因为复合字面量是匿名的，所以不能先创建然后再使用它，必须在创建的同时使用它。</p><p><strong>一般需要这样定义使用：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 简单用法       ***</span><br><span class="hljs-type">int</span> *pt1;<br>pt1=(<span class="hljs-type">int</span>[<span class="hljs-number">2</span>])&#123;<span class="hljs-number">19</span>,<span class="hljs-number">20</span>&#125;;<br><br><span class="hljs-comment">// 对于多维数组   ***</span><br><span class="hljs-type">int</span> (*pt2)[<span class="hljs-number">4</span>];<br><span class="hljs-comment">//申明一个指向二维数组的指针，该数组内有2个数组元素</span><br><span class="hljs-comment">//每个元素是内含4个int类型值的数组</span><br>pt2 = (<span class="hljs-type">int</span> [<span class="hljs-number">2</span>][<span class="hljs-number">4</span>]) &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,&#125;,&#123;<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,&#125;&#125;;<br><br><span class="hljs-comment">// 对于结构体     ***</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">foo</span> &#123;</span><br>  <span class="hljs-type">int</span> a; <br>  <span class="hljs-type">char</span> b[<span class="hljs-number">2</span>];<br>&#125; structure;<br>structure = ((<span class="hljs-keyword">struct</span> foo) &#123;<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;a&#x27;</span>&#125;);<br></code></pre></td></tr></table></figure><p>一些应用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> AV_FOURCC_MAX_STRING_SIZE 32</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> av_fourcc2str(fourcc) av_fourcc_make_string((char[AV_FOURCC_MAX_STRING_SIZE])&#123;0&#125;, fourcc)</span><br><br><span class="hljs-type">char</span> *<span class="hljs-title function_">av_fourcc_make_string</span><span class="hljs-params">(<span class="hljs-type">char</span> *buf, <span class="hljs-type">uint32_t</span> fourcc)</span><br><br><span class="hljs-type">uint32_t</span> type = <span class="hljs-number">1024</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, av_fourcc2str(type));<br><br><span class="hljs-comment">// 匿名构建了一块内存地址 (char[AV_FOURCC_MAX_STRING_SIZE])&#123;0&#125; </span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>	<span class="hljs-type">void</span>* data;<br>	<span class="hljs-type">int</span>   length;<br>&#125; Array;<br><span class="hljs-type">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">(Array* arr)</span> &#123; &#125;<br><br><span class="hljs-comment">// 曾经的写法</span><br><span class="hljs-type">int</span>   data[]  = &#123; <span class="hljs-number">1</span> &#125;;<br>Array arr [<span class="hljs-number">1</span>] = &#123;data, <span class="hljs-number">1</span>&#125;;<br>foo(arr);<br><br><span class="hljs-comment">// 现在的写法</span><br>foo( (Array[]) &#123; (<span class="hljs-type">int</span>[]) &#123; <span class="hljs-number">1</span> &#125;, <span class="hljs-number">1</span> &#125; );<br></code></pre></td></tr></table></figure><h1 id="STM32相关"><a href="#STM32相关" class="headerlink" title="STM32相关"></a>STM32相关</h1><h2 id="ADC-与-通道映射关系"><a href="#ADC-与-通道映射关系" class="headerlink" title="ADC 与 通道映射关系"></a>ADC 与 通道映射关系</h2><p><img src="/2018/ef667962/ADC%E9%80%9A%E9%81%93%E4%B8%8E%E5%BC%95%E8%84%9A%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB.png" srcset="/img/loading.gif" lazyload alt="ADC通道与引脚对应关系"></p><h2 id="Printf第一个字符丢失"><a href="#Printf第一个字符丢失" class="headerlink" title="Printf第一个字符丢失"></a>Printf第一个字符丢失</h2><ul><li>将发送放在等待标志位后面即可解决问题</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">&#123;<br>	<span class="hljs-comment">/* Loop until the end of transmission */</span><br>	<span class="hljs-keyword">while</span> (USART_GetFlagStatus(USART2, USART_FLAG_TC) == RESET);<br>	<br>	<span class="hljs-comment">/* Place your implementation of fputc here */</span><br>	<span class="hljs-comment">/* e.g. write a character to the USART */</span><br>	USART_SendData(USART2, (<span class="hljs-type">uint8_t</span>) ch);<br>	<br>	<span class="hljs-keyword">return</span> ch;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="通用TIM-PWM输出低电平"><a href="#通用TIM-PWM输出低电平" class="headerlink" title="通用TIM PWM输出低电平"></a>通用TIM PWM输出低电平</h2><p>调用 TIM_CCxCmd 关闭输出使能即可<strong>持续输出低电平</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">TIM_CCxCmd</span><span class="hljs-params">(TIM_TypeDef* TIMx, <span class="hljs-type">uint16_t</span> TIM_Channel, <span class="hljs-type">uint16_t</span> TIM_CCx)</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>CCxE位</th><th>OCx输出状态</th></tr></thead><tbody><tr><td>0</td><td>禁止输出(OCx&#x3D;0，OCx_EN&#x3D;0)</td></tr><tr><td>1</td><td>OCx &#x3D; OCxREF + 极性，OCx_EN&#x3D;1</td></tr></tbody></table><h2 id="杂乱笔记"><a href="#杂乱笔记" class="headerlink" title="杂乱笔记"></a>杂乱笔记</h2><ul><li><p>仿真建议使用SWD模式(使用的线少) emmm。。。。？</p></li><li><p>KEY_UP高电有效（可用于唤醒）、KEY0、KEY1低电有效</p></li><li><p><strong>编译器会默认把没有赋值的变量自动赋值为0（真的是这样吗？，局部变量呢？答复:局部变量不会被初始化,请一定注意要去手动进行初始化）</strong></p></li><li><p><strong>NTC (Negative Temperature Coefficient 负温度系数) PTC (Positive 正温度系数)</strong></p></li><li><p>RTC (实时时钟)</p></li><li><p>APB1和APB2的区别,<br>APB1操作速度限于36MHz,	上面连接的是低速外设,包括 TIM234567、WWDG、SPI2、SPI3、USART23、UART45、CAN12、PWRPower interface clock、 BKP、 DAC、I2C12、等，<strong>具体请参考7.3.8章节APB1外设使能寄存器</strong><br>APB2操作速度全速,	上面连接的是高速外设,包括 UART1 、SPI1、Timer1、ADC1、ADC2、所有普通 IO 口(PA-PE)(PA-PE)(PA-PE)(PA-PE)(PA-PE)(PA-PE) 、第二功能IO 口 、<strong>具体请参考7.3.7章节APB2外设使能寄存器</strong></p></li><li><p>原子提供的delay_ms 最大是1864ms不能超过这个值</p></li><li><p>volatile 简单地说就是防止编译器对代码进行优化。</p></li><li><p>enum 枚举类型</p></li><li><p><strong>SysTick LOAD 转载到 VAL 需要时钟周期所以计算 LOAD 时需要-1</strong></p></li><li><p><strong>PA13 PA14 PA15 PB3 PB4 上电默认是SWD+JTAG模式所以这些GPIO口不能直接使用可调用 GPIO_PinRemapConfig 函数修改</strong></p></li><li><p>DAC要将对应的IO设置成模拟输入！！！</p></li><li><p>USART1 时钟脉冲来源 PCLK2 USART2-4来源 PCLK1</p></li><li><p><strong>使用USART不需要使能AFIO （发生重映射才需要进行打开AFIO参考CSDN）</strong></p></li><li><p>0,1,2,3,4 各有自己的中断函数 5-9共用一个中断函数 10-15共用一个中断函数</p></li><li><p><strong>u8 temp <em>attribute</em>((at (地址))); &#x2F;&#x2F;需要定义为全局变量—-定义变量到指定地址</strong></p></li><li><p>容量</p><p>4表示16KB （小容量ld）<br>6表示32KB （小容量ld）<br>8表示64KB （中容量md）<br>B表示128KB （中容量md）<br>C表示256KB （大容量hd）<br>E表示512KB （大容量hd）<br>F表示768KB （超大容量xl）<br>G表示1024KB （超大容量xl）</p></li><li><p>ADC输入范围：VREF- ≤ VIN ≤ VREF+</p></li><li><p>在扫描模式下，由ADC_SQRx或者ADC_JSQRx寄存器选中的通道被转换。如果设置了EOCIE或者JEOCIE，在最后一个通道转换完毕后才会产生EOC或者JEOC中断。</p></li><li><p>ADC ADC1通道17 测得的是内部参考电压(根据数据手册中的数据，这个参照电压的典型值是1.20V，最小值是1.16V，最大值是1.24V)，!!!不是ADC的参考电压Vref+!!!</p></li><li><p>系统滴答定时器</p><p>SysTick-&gt;CTRL 类似控制及状态位寄存器<br>SysTick-&gt;LOAD 到时间自动重装的重装载寄存器<br>SysTick-&gt;VAL 当前数值寄存器<br>SysTick-&gt;CALIB 校准数值寄存器（暂时没有用到）</p></li></ul><h1 id="RTOS相关"><a href="#RTOS相关" class="headerlink" title="RTOS相关"></a>RTOS相关</h1><h2 id="进程-线程-协程"><a href="#进程-线程-协程" class="headerlink" title="进程 线程 协程"></a>进程 线程 协程</h2><p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/Survivalist/p/11527949.html">一文读懂什么是进程、线程、协程</a></p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><blockquote><p><strong>进程的概念</strong></p><p>进程 – 是现代操作系统的一个基本概念，是并发程序出现后出现的一个重要概念，它是指 程序在一个数据集合上运行的过程，是系统进行资源分配和调度运行的一个独立单位，有时 也称为活动、路径或任务。</p></blockquote><ul><li>资源分配的最小单位(拥有独立的地址空间，同一个进程内的线程共享进程地址空间)</li><li>进程是程序执行的实例</li><li><strong>我的理解是在windows里面每一个程序启动都会有一个进程的存在，这个进程会有一个虚拟的地址空间。</strong>（而在STM32一类芯片内是没有虚拟地址空间的，如果跑了RTOS，系统所调度的其实是<strong>进程的子项线程</strong>）</li></ul><blockquote><p>我们都知道计算机的核心是CPU，它承担了所有的计算任务；而操作系统是计算机的管理者，它负责任务的调度、资源的分配和管理，统领整个计算机硬件；应用程序则是具有某种功能的程序，程序是运行于操作系统之上的。</p><p>  进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。进程是一种抽象的概念，从来没有统一的标准定义。</p><p>进程一般由程序、数据集合和进程控制块三部分组成。</p><ul><li>程序用于描述进程要完成的功能，是控制进程执行的指令集；</li><li>数据集合是程序在执行时所需要的数据和工作区；</li><li>程序控制块(Program Control Block，简称PCB)，包含进程的描述信息和控制信息，是进程存在的唯一标志。</li></ul><p>进程具有的特征：</p><ul><li><strong>动态性：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的；</strong></li><li>并发性：任何进程都可以同其他进程一起并发执行；</li><li>独立性：进程是系统进行资源分配和调度的一个独立单位；</li><li>结构性：进程由程序、数据和进程控制块三部分组成。</li></ul></blockquote><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><blockquote><p><strong>线程的概念</strong></p><p>线程– <strong>是进程中的一个实体,是被系统调度和分配的基本单元</strong>。 每个程序至少包含一个线 程，那就是主线程。 线程自己只拥有很少的系统资源（如程序计数器、一组寄存器和栈）， 但它可与同属一个进程的其他线程共享所属进程所拥有的全部资源，同一进程中的多个线程 之间可以并发执行，从而更好地改善了系统资源的利用率。</p></blockquote><ul><li>程序执行的最小单位</li><li>CPU调度最小单位，一个进程并发多个线程</li></ul><blockquote><p>线程是程序执行流的最小单元，是处理器调度和分派的基本单位。一个<strong>进程</strong>可以有一个或多个<strong>线程</strong>，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。</p><p>一个标准的<strong>线程</strong>由线程ID、当前指令指针(PC)、寄存器和堆栈组成。</p><p>而<strong>进程</strong>由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成。</p><p><img src="/2018/ef667962/process.png" srcset="/img/loading.gif" lazyload alt="image"></p><p>如上图，在任务管理器的进程一栏里，有道词典和有道云笔记就是<strong>进程</strong>，而在进程下又有着多个执行不同任务的<strong>线程</strong>。</p></blockquote><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><ul><li>它是基于线程的，一个线程内有多个协程</li><li>由程序员自行管理的更加轻量的线程</li></ul><blockquote><h2 id="协程-1"><a href="#协程-1" class="headerlink" title="协程"></a>协程</h2><p>协程，英文Coroutines，是一种基于线程之上，但又比线程更加轻量级的存在，这种由程序员自己写程序来管理的轻量级线程叫做『用户空间线程』，具有对内核来说不可见的特性。</p><p>因为是自主开辟的异步任务，所以很多人也更喜欢叫它们纤程（Fiber），或者绿色线程（GreenThread）。正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。</p><p><img src="/2018/ef667962/6765e36cc4604fba897976638af03524.jpeg" srcset="/img/loading.gif" lazyload alt="image"></p><h2 id="协程的目的"><a href="#协程的目的" class="headerlink" title="协程的目的"></a>协程的目的</h2><p>在传统的J2EE系统中都是基于每个请求占用一个线程去完成完整的业务逻辑（包括事务）。所以系统的吞吐能力取决于每个线程的操作耗时。如果遇到很耗时的I&#x2F;O行为，则整个系统的吞吐立刻下降，因为这个时候线程一直处于阻塞状态，如果线程很多的时候，会存在很多线程处于空闲状态（等待该线程执行完才能执行），造成了资源应用不彻底。</p><p>最常见的例子就是JDBC（它是同步阻塞的），这也是为什么很多人都说数据库是瓶颈的原因。这里的耗时其实是让CPU一直在等待I&#x2F;O返回，说白了线程根本没有利用CPU去做运算，而是处于空转状态。而另外过多的线程，也会带来更多的ContextSwitch开销。</p><p>对于上述问题，现阶段行业里的比较流行的解决方案之一就是单线程加上异步回调。其代表派是node.js以及Java里的新秀Vert.x。</p><p>而协程的目的就是当出现长时间的I&#x2F;O操作时，通过让出目前的协程调度，执行下一个任务的方式，来消除ContextSwitch上的开销。</p><h2 id="协程的特点"><a href="#协程的特点" class="headerlink" title="协程的特点"></a>协程的特点</h2><ol><li>线程的切换由操作系统负责调度，协程由用户自己进行调度，因此减少了上下文切换，提高了效率。</li><li>线程的默认Stack大小是1M，而协程更轻量，接近1K。因此可以在相同的内存中开启更多的协程。</li><li>由于在同一个线程上，因此可以避免竞争关系而使用锁。</li><li>适用于被阻塞的，且需要大量并发的场景。但不适用于大量计算的多线程，遇到此种情况，更好实用线程去解决。</li></ol></blockquote><h3 id="进程和线程关系"><a href="#进程和线程关系" class="headerlink" title="进程和线程关系"></a>进程和线程关系</h3><ul><li>资源分配给进程，同一进程内的所有线程共享该进程的所有资源；</li><li>同一个进程的线程之间可以直接交流；两个进程想通信，必须通过一个中间代理来实现；</li><li>处理机分配给线程，即真正在处理机上运行的是线程；</li><li><strong>线程共享内存空间；进程的内存是独立的；</strong></li><li>系统开销：在创建和撤销进程的时候，系统都要分配和回收资源，导致系统的明显大于创建和撤销线程时的开销。但进程有独立的地址空间，进程崩溃后，在保护模式的下不会对其他进程造成影响，而线程只是进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有独立的地址空间，一个线程死后就等于整个进程死掉，所以多进程程序要比多线程程序健壮，但是在进程切换的时候消耗的资源较大，效率差。</li><li><strong>多线程执行效率高; 多进程耗资源，安全。</strong></li></ul><h2 id="互斥量和信号量的区别"><a href="#互斥量和信号量的区别" class="headerlink" title="互斥量和信号量的区别"></a><strong>互斥量和信号量的区别</strong></h2><p><strong>1. 互斥量用于线程的互斥，信号量用于线程的同步。</strong></p><p>这是互斥量和信号量的根本区别，也就是互斥和同步之间的区别。</p><p>互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。</p><p>同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源</p><p><strong>2. 互斥量值只能为0&#x2F;1，信号量值可以为非负整数。</strong></p><p>也就是说，一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题。信号量可以实现多个同类资源的多线程互斥和同步。当信号量为单值信号量是，也可以完成一个资源的互斥访问。</p><p><strong>3. 互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。</strong></p><h1 id="外设"><a href="#外设" class="headerlink" title="外设"></a>外设</h1><h2 id="IIC"><a href="#IIC" class="headerlink" title="IIC"></a>IIC</h2><p>IIC从机地址有7位、8位、10位不同的模式，一般来说7位比较常见。</p><p>I²C的参考设计使用一个7比特长度的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E5%9D%80%E7%A9%BA%E9%96%93">地址空间</a>但保留了16个地址，所以在一组总线最多可和112个节点通信[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-cn/I%C2%B2C#cite_note-3">a]</a>。在7位寻址过程中，从机地址在启动信号后的第一个字节开始传输，该字节的前7位为从机地址，第8位为读写位，其中0表示写，1表示读。</p><p>虽然最大的节点数目是被地址空间所限制住，但实际上也会被总线上的总<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E5%AE%B9">电容</a>所限制住，一般而言为400 pF。</p><p><img src="/2018/ef667962/I2C_data_transfer.svg" srcset="/img/loading.gif" lazyload alt="Data transfer sequence"></p><blockquote><p>参考上面的图像我们可以看到，</p><p>START：在SCL信号为H的时候，SDA由H变L是START信号。</p><p>DATA TRANSMISSION：在数据传输阶段，SCL为H阶段，SDA的电平不允许变化。</p><p>STOP：在SCL信号为H的时候，SDA由L变H是STOP信号。</p></blockquote><h3 id="通信速率"><a href="#通信速率" class="headerlink" title="通信速率"></a>通信速率</h3><p><strong>双向通信速度（模式）：</strong></p><p>100 kbit&#x2F;s：标准模式，Standard-mode (Sm)；</p><p>400 kbit&#x2F;s：快速模式，Fast-mode (Fm)；</p><p>1 Mbit&#x2F;s：快速模式+，Fast-mode Plus (Fm+)；</p><p>3.4Mbit&#x2F;s：高速模式，High-speed mode (Hs-mode)；</p><p><strong>单向通信速度（模式）：</strong></p><p>5 Mbit&#x2F;s：超快模式，UItra Fast-mode (UFm)。</p><h2 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h2><p>CKPOL (Clock Polarity) &#x3D; CPOL &#x3D; POL &#x3D; Polarity &#x3D; （时钟）极性<br>CKPHA (Clock Phase) &#x3D; CPHA &#x3D; PHA &#x3D; Phase &#x3D; （时钟）相位</p><h3 id="CPOL极性"><a href="#CPOL极性" class="headerlink" title="CPOL极性"></a>CPOL极性</h3><p>先说什么是SCLK时钟的空闲时刻，其就是当SCLK在发送8个bit比特数据之前和之后的状态，于此对应的，SCLK在发送数据的时候，就是正常的工作的时候，有效active的时刻了。其英文精简解释为：Clock Polarity &#x3D; IDLE state of SCK。</p><p>SPI的CPOL，<span style="color:#29b6f6"><strong>表示当SCLK空闲idle的时候，其电平的值是低电平0还是高电平1</strong></span>：<br>CPOL&#x3D;0，时钟空闲idle时候的电平是低电平，所以当SCLK有效的时候，就是高电平，就是所谓的active-high；<br>CPOL&#x3D;1，时钟空闲idle时候的电平是高电平，所以当SCLK有效的时候，就是低电平，就是所谓的active-low；<br><img src="/2018/ef667962/231416549884871.gif" srcset="/img/loading.gif" lazyload alt="img"></p><p>从上图中可以看出，(CPOL&#x3D;0)的SCK 波形，它有（传输）8 个脉冲，而在脉冲传输前和完成后都保持在【低电平状态】。<br>此时的状态就是时钟的空闲状态或无效状态，因为此时没有脉冲，也就不会有数据传输。同理得出，（CPOL&#x3D;）1 的图，时钟的空闲状态或无效状态时SCK 是保持【高电平的】。</p><h3 id="CPHA相位"><a href="#CPHA相位" class="headerlink" title="CPHA相位"></a>CPHA相位</h3><p>首先说明一点，capture strobe &#x3D; latch &#x3D; read &#x3D; sample，都是表示数据采样，数据有效的时刻。<br>相位，对应着数据采样是在第几个边沿（edge），是第一个边沿还是第二个边沿，0对应着第一个边沿，1对应着第二个边沿。对于：</p><p>CPHA&#x3D;0，表示第一个边沿：<br>对于CPOL&#x3D;0，idle时候的是低电平，第一个边沿就是从低变到高，所以是上升沿；<br>对于CPOL&#x3D;1，idle时候的是高电平，第一个边沿就是从高变到低，所以是下降沿；</p><p>CPHA&#x3D;1，表示第二个边沿：<br>对于CPOL&#x3D;0，idle时候的是低电平，第二个边沿就是从高变到低，所以是下降沿；<br>对于CPOL&#x3D;1，idle时候的是高电平，第一个边沿就是从低变到高，所以是上升沿；</p><p><span style="color:#29b6f6"><strong>数据是在SCK的第一个时钟边沿保持稳定【数据被采样捕获】，在下一个边沿改变【SCK 的下降沿数据改变】</strong></span></p><h1 id="嵌入式高效位算法"><a href="#嵌入式高效位算法" class="headerlink" title="嵌入式高效位算法"></a>嵌入式高效位算法</h1><p>参考资料：</p><p><a target="_blank" rel="noopener" href="http://aggregate.org/MAGIC/#Bit%20Reversal">The Aggregate Magic Algorithms</a></p><p><a target="_blank" rel="noopener" href="http://graphics.stanford.edu/~seander/bithacks.html">Bit Twiddling Hacks</a></p><p>WORDBITS: 数据宽度</p><h2 id="位逆序"><a href="#位逆序" class="headerlink" title="位逆序"></a>位逆序</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>在整数x中反转位有点痛苦，但这里有一个32位值的SWAR算法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-keyword">register</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> x)</span><br>&#123;<br>	x = (((x &amp; <span class="hljs-number">0xaaaaaaaa</span>) &gt;&gt; <span class="hljs-number">1</span>) | ((x &amp; <span class="hljs-number">0x55555555</span>) &lt;&lt; <span class="hljs-number">1</span>));<br>	x = (((x &amp; <span class="hljs-number">0xcccccccc</span>) &gt;&gt; <span class="hljs-number">2</span>) | ((x &amp; <span class="hljs-number">0x33333333</span>) &lt;&lt; <span class="hljs-number">2</span>));<br>	x = (((x &amp; <span class="hljs-number">0xf0f0f0f0</span>) &gt;&gt; <span class="hljs-number">4</span>) | ((x &amp; <span class="hljs-number">0x0f0f0f0f</span>) &lt;&lt; <span class="hljs-number">4</span>));<br>	x = (((x &amp; <span class="hljs-number">0xff00ff00</span>) &gt;&gt; <span class="hljs-number">8</span>) | ((x &amp; <span class="hljs-number">0x00ff00ff</span>) &lt;&lt; <span class="hljs-number">8</span>));<br>	<span class="hljs-keyword">return</span>((x &gt;&gt; <span class="hljs-number">16</span>) | (x &lt;&lt; <span class="hljs-number">16</span>));<br><br>&#125;<br></code></pre></td></tr></table></figure><p>也可以重写这个算法，使用4个而不是8个常量，从而节省一些指令带宽。在我的1.2GHz Athlon(雷鸟)上，这种差别太小了，无法可靠地测量。下面是另一个版本:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-keyword">register</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> x)</span><br>&#123;<br>        <span class="hljs-keyword">register</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> y = <span class="hljs-number">0x55555555</span>;<br>        x = (((x &gt;&gt; <span class="hljs-number">1</span>) &amp; y) | ((x &amp; y) &lt;&lt; <span class="hljs-number">1</span>));<br>        y = <span class="hljs-number">0x33333333</span>;<br>        x = (((x &gt;&gt; <span class="hljs-number">2</span>) &amp; y) | ((x &amp; y) &lt;&lt; <span class="hljs-number">2</span>));<br>        y = <span class="hljs-number">0x0f0f0f0f</span>;<br>        x = (((x &gt;&gt; <span class="hljs-number">4</span>) &amp; y) | ((x &amp; y) &lt;&lt; <span class="hljs-number">4</span>));<br>        y = <span class="hljs-number">0x00ff00ff</span>;<br>        x = (((x &gt;&gt; <span class="hljs-number">8</span>) &amp; y) | ((x &amp; y) &lt;&lt; <span class="hljs-number">8</span>));<br>        <span class="hljs-keyword">return</span>((x &gt;&gt; <span class="hljs-number">16</span>) | (x &lt;&lt; <span class="hljs-number">16</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8位查表"><a href="#8位查表" class="headerlink" title="8位查表"></a>8位查表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">private Byte  <span class="hljs-title function_">BitReverse</span><span class="hljs-params">(Byte bData)</span><br>&#123;<br>    Byte[] lookup = &#123; <span class="hljs-number">0</span>, <span class="hljs-number">8</span>,  <span class="hljs-number">4</span>, <span class="hljs-number">12</span>, <br>                     <span class="hljs-number">2</span>, <span class="hljs-number">10</span>, <span class="hljs-number">6</span>, <span class="hljs-number">14</span> , <br>                     <span class="hljs-number">1</span>, <span class="hljs-number">9</span>,  <span class="hljs-number">5</span>, <span class="hljs-number">13</span>,<br>                     <span class="hljs-number">3</span>, <span class="hljs-number">11</span>, <span class="hljs-number">7</span>, <span class="hljs-number">15</span> &#125;;<br>    Byte ret_val = (Byte)(((lookup[(bData &amp; <span class="hljs-number">0x0F</span>)]) &lt;&lt; <span class="hljs-number">4</span>) + lookup[((bData &amp; <span class="hljs-number">0xF0</span>) &gt;&gt; <span class="hljs-number">4</span>)]);<br>    <span class="hljs-keyword">return</span> ret_val;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="16位查表"><a href="#16位查表" class="headerlink" title="16位查表"></a>16位查表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> BitReverseTable256[] = <br>&#123;<br>  <span class="hljs-number">0x00</span>, <span class="hljs-number">0x80</span>, <span class="hljs-number">0x40</span>, <span class="hljs-number">0xC0</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0xA0</span>, <span class="hljs-number">0x60</span>, <span class="hljs-number">0xE0</span>, <span class="hljs-number">0x10</span>, <span class="hljs-number">0x90</span>, <span class="hljs-number">0x50</span>, <span class="hljs-number">0xD0</span>, <span class="hljs-number">0x30</span>, <span class="hljs-number">0xB0</span>, <span class="hljs-number">0x70</span>, <span class="hljs-number">0xF0</span>, <br>  <span class="hljs-number">0x08</span>, <span class="hljs-number">0x88</span>, <span class="hljs-number">0x48</span>, <span class="hljs-number">0xC8</span>, <span class="hljs-number">0x28</span>, <span class="hljs-number">0xA8</span>, <span class="hljs-number">0x68</span>, <span class="hljs-number">0xE8</span>, <span class="hljs-number">0x18</span>, <span class="hljs-number">0x98</span>, <span class="hljs-number">0x58</span>, <span class="hljs-number">0xD8</span>, <span class="hljs-number">0x38</span>, <span class="hljs-number">0xB8</span>, <span class="hljs-number">0x78</span>, <span class="hljs-number">0xF8</span>, <br>  <span class="hljs-number">0x04</span>, <span class="hljs-number">0x84</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0xC4</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0xA4</span>, <span class="hljs-number">0x64</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x14</span>, <span class="hljs-number">0x94</span>, <span class="hljs-number">0x54</span>, <span class="hljs-number">0xD4</span>, <span class="hljs-number">0x34</span>, <span class="hljs-number">0xB4</span>, <span class="hljs-number">0x74</span>, <span class="hljs-number">0xF4</span>, <br>  <span class="hljs-number">0x0C</span>, <span class="hljs-number">0x8C</span>, <span class="hljs-number">0x4C</span>, <span class="hljs-number">0xCC</span>, <span class="hljs-number">0x2C</span>, <span class="hljs-number">0xAC</span>, <span class="hljs-number">0x6C</span>, <span class="hljs-number">0xEC</span>, <span class="hljs-number">0x1C</span>, <span class="hljs-number">0x9C</span>, <span class="hljs-number">0x5C</span>, <span class="hljs-number">0xDC</span>, <span class="hljs-number">0x3C</span>, <span class="hljs-number">0xBC</span>, <span class="hljs-number">0x7C</span>, <span class="hljs-number">0xFC</span>, <br>  <span class="hljs-number">0x02</span>, <span class="hljs-number">0x82</span>, <span class="hljs-number">0x42</span>, <span class="hljs-number">0xC2</span>, <span class="hljs-number">0x22</span>, <span class="hljs-number">0xA2</span>, <span class="hljs-number">0x62</span>, <span class="hljs-number">0xE2</span>, <span class="hljs-number">0x12</span>, <span class="hljs-number">0x92</span>, <span class="hljs-number">0x52</span>, <span class="hljs-number">0xD2</span>, <span class="hljs-number">0x32</span>, <span class="hljs-number">0xB2</span>, <span class="hljs-number">0x72</span>, <span class="hljs-number">0xF2</span>, <br>  <span class="hljs-number">0x0A</span>, <span class="hljs-number">0x8A</span>, <span class="hljs-number">0x4A</span>, <span class="hljs-number">0xCA</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0xAA</span>, <span class="hljs-number">0x6A</span>, <span class="hljs-number">0xEA</span>, <span class="hljs-number">0x1A</span>, <span class="hljs-number">0x9A</span>, <span class="hljs-number">0x5A</span>, <span class="hljs-number">0xDA</span>, <span class="hljs-number">0x3A</span>, <span class="hljs-number">0xBA</span>, <span class="hljs-number">0x7A</span>, <span class="hljs-number">0xFA</span>,<br>  <span class="hljs-number">0x06</span>, <span class="hljs-number">0x86</span>, <span class="hljs-number">0x46</span>, <span class="hljs-number">0xC6</span>, <span class="hljs-number">0x26</span>, <span class="hljs-number">0xA6</span>, <span class="hljs-number">0x66</span>, <span class="hljs-number">0xE6</span>, <span class="hljs-number">0x16</span>, <span class="hljs-number">0x96</span>, <span class="hljs-number">0x56</span>, <span class="hljs-number">0xD6</span>, <span class="hljs-number">0x36</span>, <span class="hljs-number">0xB6</span>, <span class="hljs-number">0x76</span>, <span class="hljs-number">0xF6</span>, <br>  <span class="hljs-number">0x0E</span>, <span class="hljs-number">0x8E</span>, <span class="hljs-number">0x4E</span>, <span class="hljs-number">0xCE</span>, <span class="hljs-number">0x2E</span>, <span class="hljs-number">0xAE</span>, <span class="hljs-number">0x6E</span>, <span class="hljs-number">0xEE</span>, <span class="hljs-number">0x1E</span>, <span class="hljs-number">0x9E</span>, <span class="hljs-number">0x5E</span>, <span class="hljs-number">0xDE</span>, <span class="hljs-number">0x3E</span>, <span class="hljs-number">0xBE</span>, <span class="hljs-number">0x7E</span>, <span class="hljs-number">0xFE</span>,<br>  <span class="hljs-number">0x01</span>, <span class="hljs-number">0x81</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0xC1</span>, <span class="hljs-number">0x21</span>, <span class="hljs-number">0xA1</span>, <span class="hljs-number">0x61</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x11</span>, <span class="hljs-number">0x91</span>, <span class="hljs-number">0x51</span>, <span class="hljs-number">0xD1</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0xB1</span>, <span class="hljs-number">0x71</span>, <span class="hljs-number">0xF1</span>,<br>  <span class="hljs-number">0x09</span>, <span class="hljs-number">0x89</span>, <span class="hljs-number">0x49</span>, <span class="hljs-number">0xC9</span>, <span class="hljs-number">0x29</span>, <span class="hljs-number">0xA9</span>, <span class="hljs-number">0x69</span>, <span class="hljs-number">0xE9</span>, <span class="hljs-number">0x19</span>, <span class="hljs-number">0x99</span>, <span class="hljs-number">0x59</span>, <span class="hljs-number">0xD9</span>, <span class="hljs-number">0x39</span>, <span class="hljs-number">0xB9</span>, <span class="hljs-number">0x79</span>, <span class="hljs-number">0xF9</span>, <br>  <span class="hljs-number">0x05</span>, <span class="hljs-number">0x85</span>, <span class="hljs-number">0x45</span>, <span class="hljs-number">0xC5</span>, <span class="hljs-number">0x25</span>, <span class="hljs-number">0xA5</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0xE5</span>, <span class="hljs-number">0x15</span>, <span class="hljs-number">0x95</span>, <span class="hljs-number">0x55</span>, <span class="hljs-number">0xD5</span>, <span class="hljs-number">0x35</span>, <span class="hljs-number">0xB5</span>, <span class="hljs-number">0x75</span>, <span class="hljs-number">0xF5</span>,<br>  <span class="hljs-number">0x0D</span>, <span class="hljs-number">0x8D</span>, <span class="hljs-number">0x4D</span>, <span class="hljs-number">0xCD</span>, <span class="hljs-number">0x2D</span>, <span class="hljs-number">0xAD</span>, <span class="hljs-number">0x6D</span>, <span class="hljs-number">0xED</span>, <span class="hljs-number">0x1D</span>, <span class="hljs-number">0x9D</span>, <span class="hljs-number">0x5D</span>, <span class="hljs-number">0xDD</span>, <span class="hljs-number">0x3D</span>, <span class="hljs-number">0xBD</span>, <span class="hljs-number">0x7D</span>, <span class="hljs-number">0xFD</span>,<br>  <span class="hljs-number">0x03</span>, <span class="hljs-number">0x83</span>, <span class="hljs-number">0x43</span>, <span class="hljs-number">0xC3</span>, <span class="hljs-number">0x23</span>, <span class="hljs-number">0xA3</span>, <span class="hljs-number">0x63</span>, <span class="hljs-number">0xE3</span>, <span class="hljs-number">0x13</span>, <span class="hljs-number">0x93</span>, <span class="hljs-number">0x53</span>, <span class="hljs-number">0xD3</span>, <span class="hljs-number">0x33</span>, <span class="hljs-number">0xB3</span>, <span class="hljs-number">0x73</span>, <span class="hljs-number">0xF3</span>, <br>  <span class="hljs-number">0x0B</span>, <span class="hljs-number">0x8B</span>, <span class="hljs-number">0x4B</span>, <span class="hljs-number">0xCB</span>, <span class="hljs-number">0x2B</span>, <span class="hljs-number">0xAB</span>, <span class="hljs-number">0x6B</span>, <span class="hljs-number">0xEB</span>, <span class="hljs-number">0x1B</span>, <span class="hljs-number">0x9B</span>, <span class="hljs-number">0x5B</span>, <span class="hljs-number">0xDB</span>, <span class="hljs-number">0x3B</span>, <span class="hljs-number">0xBB</span>, <span class="hljs-number">0x7B</span>, <span class="hljs-number">0xFB</span>,<br>  <span class="hljs-number">0x07</span>, <span class="hljs-number">0x87</span>, <span class="hljs-number">0x47</span>, <span class="hljs-number">0xC7</span>, <span class="hljs-number">0x27</span>, <span class="hljs-number">0xA7</span>, <span class="hljs-number">0x67</span>, <span class="hljs-number">0xE7</span>, <span class="hljs-number">0x17</span>, <span class="hljs-number">0x97</span>, <span class="hljs-number">0x57</span>, <span class="hljs-number">0xD7</span>, <span class="hljs-number">0x37</span>, <span class="hljs-number">0xB7</span>, <span class="hljs-number">0x77</span>, <span class="hljs-number">0xF7</span>, <br>  <span class="hljs-number">0x0F</span>, <span class="hljs-number">0x8F</span>, <span class="hljs-number">0x4F</span>, <span class="hljs-number">0xCF</span>, <span class="hljs-number">0x2F</span>, <span class="hljs-number">0xAF</span>, <span class="hljs-number">0x6F</span>, <span class="hljs-number">0xEF</span>, <span class="hljs-number">0x1F</span>, <span class="hljs-number">0x9F</span>, <span class="hljs-number">0x5F</span>, <span class="hljs-number">0xDF</span>, <span class="hljs-number">0x3F</span>, <span class="hljs-number">0xBF</span>, <span class="hljs-number">0x7F</span>, <span class="hljs-number">0xFF</span><br>&#125;;<br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v; <span class="hljs-comment">// reverse 32-bit value, 8 bits at time</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> c; <span class="hljs-comment">// c will get v reversed</span><br><br><span class="hljs-comment">// Option 1:</span><br>c = (BitReverseTable256[v &amp; <span class="hljs-number">0xff</span>] &lt;&lt; <span class="hljs-number">24</span>) | <br>    (BitReverseTable256[(v &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>] &lt;&lt; <span class="hljs-number">16</span>) | <br>    (BitReverseTable256[(v &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xff</span>] &lt;&lt; <span class="hljs-number">8</span>) |<br>    (BitReverseTable256[(v &gt;&gt; <span class="hljs-number">24</span>) &amp; <span class="hljs-number">0xff</span>]);<br><br><span class="hljs-comment">// Option 2:</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> * p = (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *) &amp;v;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> * q = (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *) &amp;c;<br>q[<span class="hljs-number">3</span>] = BitReverseTable256[p[<span class="hljs-number">0</span>]]; <br>q[<span class="hljs-number">2</span>] = BitReverseTable256[p[<span class="hljs-number">1</span>]]; <br>q[<span class="hljs-number">1</span>] = BitReverseTable256[p[<span class="hljs-number">2</span>]]; <br>q[<span class="hljs-number">0</span>] = BitReverseTable256[p[<span class="hljs-number">3</span>]];<br></code></pre></td></tr></table></figure><h2 id="整数平均值"><a href="#整数平均值" class="headerlink" title="整数平均值"></a>整数平均值</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">(x+y)/<span class="hljs-number">2</span>	<span class="hljs-comment">//可能导致溢出 相加溢出</span><br>    <br>(x＆y)+((x ^ y)&gt;&gt; <span class="hljs-number">1</span>)	<span class="hljs-comment">//可以改用这种方法</span><br></code></pre></td></tr></table></figure><ul><li><p>原理：</p><p>这实际上是“众所周知”事实的扩展，对于二进制整数值<code>x</code>和<code>y</code>，<code>（x + y）</code> 等于<code>（（x＆y）+（x | y））</code>等于<code>（（x ^ y）+ 2 *（x＆y ））</code>。</p><p>给定两个整数值<code>x</code>和<code>y</code>，平均值的（底数）通常将由<code>（x + y）/ 2计算</code>；不幸的是，由于溢出，这可能会产生错误的结果。一个非常偷偷摸摸的替代方法是使用<code>（x＆y）+（（（x ^ y）/ 2）</code>。如果我们由于C没有指定是否对移位进行签名而意识到潜在的不可移植性，则可以将其简化为<code>（x＆y）+（（x ^ y）&gt;&gt; 1）</code>。无论哪种情况，好处是此代码序列都不会溢出。</p></li></ul><h2 id="整数求最大最小值"><a href="#整数求最大最小值" class="headerlink" title="整数求最大最小值"></a>整数求最大最小值</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">x-(((x-y)&gt;&gt;(WORDBITS<span class="hljs-number">-1</span>))&amp;(x-y))				<span class="hljs-comment">//Maximum</span><br>x+(((y-x)&gt;&gt;(WORDBITS<span class="hljs-number">-1</span>))&amp;(y-x))				<span class="hljs-comment">//Minimum </span><br></code></pre></td></tr></table></figure><ul><li><p>解释</p><p>WORDBITS是数据宽度（8，16，32，……）</p></li><li><p>原理</p><p>((x-y)&gt;&gt;(WORDBITS-1)) 相当于取出符号位</p><p>当x&gt;y时结果是0</p><p><span style="color:red">注意！ 当x&lt;y时结果是全1，，比如WORDBITS是8那么这个式子运算结果是0xFF</span></p><p><span style="color:red">注意！ 负数的移位似乎不太一样（当有符号整数右移时，最左边的位的值被复制到其他位）,（ 不幸的是，这种行为是特定于体系结构的）</span></p></li></ul><p>同样的可以利用这一点应用到其他算法中：<a href="#%E6%95%B4%E6%95%B0%E9%80%89%E6%8B%A9%E8%B5%8B%E5%80%BC">整数选择赋值</a></p><h2 id="整数选择赋值"><a href="#整数选择赋值" class="headerlink" title="整数选择赋值"></a>整数选择赋值</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (a&lt;b) x=c; <span class="hljs-keyword">else</span> x=d; 					<span class="hljs-comment">//都是整数</span><br><br>x=((((a-b) &gt;&gt; (WORDBITS<span class="hljs-number">-1</span>)) &amp; (c^d)) ^ d) 	<span class="hljs-comment">//优化后</span><br></code></pre></td></tr></table></figure><ul><li><p>原理</p><p>参考<a href="#%E6%95%B4%E6%95%B0%E6%B1%82%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%80%BC">整数求最大最小值</a></p></li></ul><h2 id="没有临时值，交换值两数据的值"><a href="#没有临时值，交换值两数据的值" class="headerlink" title="没有临时值，交换值两数据的值"></a>没有临时值，交换值两数据的值</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//example 1</span><br>x ^= y; <span class="hljs-comment">/* x&#x27; = (x^y) */</span><br>y ^= x;	<span class="hljs-comment">/* y&#x27; = (y^(x^y)) = x */</span><br>x ^= y; <span class="hljs-comment">/* x&#x27; = (x^y)^x = y */</span><br><br><span class="hljs-comment">//example 2</span><br>x += y; 	<span class="hljs-comment">/* x&#x27; = (x+y) */</span><br>y = x - y;	<span class="hljs-comment">/* y&#x27; = (x+y)-y = x */</span><br>x -= y;		<span class="hljs-comment">/* x&#x27; = (x+y)-x = y */</span><br></code></pre></td></tr></table></figure><ul><li><p>注意:</p><p>但是当x和y之间的大小有显著差异时，较小的大小的值可能会严重损失准确性。例如，如果x的模比y大得多，那么(x+y)&#x3D;&#x3D;x，最后得到y&#x3D;0。</p><p>这里如果变量的存储大小很小 还可能会产生溢出 计算出来的数据就会问题了</p></li></ul><h2 id="计算byte内有多少bit置1"><a href="#计算byte内有多少bit置1" class="headerlink" title="计算byte内有多少bit置1"></a>计算byte内有多少bit置1</h2><p>此为 汉明距离 问题</p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>just</p><h3 id="Bit1-Bit0数量相关"><a href="#Bit1-Bit0数量相关" class="headerlink" title="Bit1 Bit0数量相关"></a>Bit1 Bit0数量相关</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//bit 1 较少 0x1000 0000 只需要一次</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">bitcount</span> <span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (n)  &#123;<br>        count++;<br>        n &amp;= (n - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br><span class="hljs-comment">//bit 0 较少 </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">bitcount</span> <span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">8</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>);<br>    n ^= (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>) <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span> (n)<br>    &#123;<br>        count--;<br>        n &amp;= (n - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="查表"><a href="#查表" class="headerlink" title="查表"></a>查表</h3><p>8位查表 4位查表</p><h3 id="合并计数-优"><a href="#合并计数-优" class="headerlink" title="合并计数(优)"></a>合并计数(优)</h3><p>以<code>0x34520</code>为例，<code>b0011 0100 0101 0010 0000</code></p><p>第一步：每2位为一组，组内高低位相加</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tap">RAW |00110100010100100000|<br>H   |0<span class="hljs-number"> 1 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 1 </span>0<span class="hljs-number"> 0 </span>|<br>L   |<span class="hljs-number"> 0 </span>1<span class="hljs-number"> 1 </span>0<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0|<br>-------------------------|<br>H&gt;&gt;1|<span class="hljs-number"> 0 </span>1<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>1<span class="hljs-number"> 0 </span>0|<br>L   |<span class="hljs-number"> 0 </span>1<span class="hljs-number"> 1 </span>0<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0|<br><br><br>  <span class="hljs-number"> 00 </span>01<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 01 </span>01<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>+ <span class="hljs-number"> 00 </span>01<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 00 </span>00<br>= <span class="hljs-number"> 00 </span>10<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 01 </span>01<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 00 </span>00<br></code></pre></td></tr></table></figure><p>第二步：每4位为一组，组内高低位相加</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">RAW</span>  <span class="hljs-number">0010 </span><span class="hljs-number">0100 </span><span class="hljs-number">0101 </span><span class="hljs-number">0001 </span><span class="hljs-number">0000</span><br><span class="hljs-string">H</span>    <span class="hljs-number">00</span>   <span class="hljs-number">01</span>   <span class="hljs-number">01</span>   <span class="hljs-number">00</span>   <span class="hljs-number">00</span>  <br><span class="hljs-string">L</span>      <span class="hljs-number">10</span>   <span class="hljs-number">00</span>   <span class="hljs-number">01</span>   <span class="hljs-number">01</span>   <span class="hljs-number">00</span><br><span class="hljs-string">-----------------------------</span><br><span class="hljs-string">H&gt;&gt;2</span> <span class="hljs-number">0000 </span><span class="hljs-number">0001 </span><span class="hljs-number">0001 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000</span><br><span class="hljs-string">L</span>    <span class="hljs-number">0010 </span><span class="hljs-number">0000 </span><span class="hljs-number">0001 </span><span class="hljs-number">0001 </span><span class="hljs-number">0000</span><br><span class="hljs-string">-----------------------------</span><br><br><span class="hljs-attr">H:</span>   <span class="hljs-number">0000 </span><span class="hljs-number">0001 </span><span class="hljs-number">0001 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000</span><br><span class="hljs-attr">L:</span>   <span class="hljs-number">0010 </span><span class="hljs-number">0000 </span><span class="hljs-number">0001 </span><span class="hljs-number">0001 </span><span class="hljs-number">0000</span><br><span class="hljs-string">=</span>    <span class="hljs-number">0010 </span><span class="hljs-number">0001 </span><span class="hljs-number">0010 </span><span class="hljs-number">0001 </span><span class="hljs-number">0000</span> <br></code></pre></td></tr></table></figure><p>第三步：每8位为一组，组内高低位相加</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dns">RAW <span class="hljs-number">00000010</span> <span class="hljs-number">00010010</span> <span class="hljs-number">00010000</span><br>    <span class="hljs-number">0000</span>     <span class="hljs-number">0001</span>     <span class="hljs-number">0001</span>    <br>        <span class="hljs-number">0010</span>     <span class="hljs-number">0010</span>     <span class="hljs-number">0000</span><br><br>H:  <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span> <span class="hljs-number">00000001</span><br>L:  <span class="hljs-number">00000010</span> <span class="hljs-number">00000010</span> <span class="hljs-number">00000000</span><br>=   <span class="hljs-number">00000010</span> <span class="hljs-number">00000011</span> <span class="hljs-number">00000001</span><br></code></pre></td></tr></table></figure><p>第四步：每16位为一组，组内高低位相加</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">RAW 0000000000000010 0000001100000001<br><span class="hljs-code">    00000000         00000011        </span><br><span class="hljs-code">            00000010         00000001</span><br><span class="hljs-code">    </span><br>H:  0000000000000000 0000000000000011<br>L:  0000000000000010 0000000000000001<br><span class="hljs-section">=   0000000000000010 0000000000000100</span><br></code></pre></td></tr></table></figure><p>第五步：每32位为一组，组内高低位相加</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">RAW 0000000000000010 0000000000000100<br><br><span class="hljs-code">    0000000000000000 0000000000000010</span><br>+   0000000000000000 0000000000000100<br><span class="hljs-section">=   0000000000000000 0000000000000110 = 6 </span><br></code></pre></td></tr></table></figure><p>这样最后得到的00000000 00000111即7即34520二进制中1的个数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-title function_">numbits</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-type">const</span> MASK1  = <span class="hljs-number">0x55555555</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-type">const</span> MASK2  = <span class="hljs-number">0x33333333</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-type">const</span> MASK4  = <span class="hljs-number">0x0f0f0f0f</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-type">const</span> MASK8  = <span class="hljs-number">0x00ff00ff</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-type">const</span> MASK16 = <span class="hljs-number">0x0000ffff</span>;<br>    i = (i&amp;MASK1 ) + (i&gt;&gt;<span class="hljs-number">1</span> &amp;MASK1 );<br>    i = (i&amp;MASK2 ) + (i&gt;&gt;<span class="hljs-number">2</span> &amp;MASK2 );<br>    i = (i&amp;MASK4 ) + (i&gt;&gt;<span class="hljs-number">4</span> &amp;MASK4 );<br>    i = (i&amp;MASK8 ) + (i&gt;&gt;<span class="hljs-number">8</span> &amp;MASK8 );<br>    i = (i&amp;MASK16) + (i&gt;&gt;<span class="hljs-number">16</span>&amp;MASK16);<br>	<span class="hljs-keyword">return</span> i;<br>&#125;<br><br><span class="hljs-comment">// 另外一种实现</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TWO(c)       	(0x1u &lt;&lt; (c))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MASK(c)      	(((unsigned int)(-1)) / (TWO(TWO(c)) + 1u))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COUNT(x,c) 		((x) &amp; MASK(c)) + (((x) &gt;&gt; (TWO(c))) &amp; MASK(c))</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">bitcount</span> <span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> n)</span><br>&#123;<br>    n = COUNT(n, <span class="hljs-number">0</span>) ;<br>    n = COUNT(n, <span class="hljs-number">1</span>) ;<br>    n = COUNT(n, <span class="hljs-number">2</span>) ;<br>    n = COUNT(n, <span class="hljs-number">3</span>) ;<br>    n = COUNT(n, <span class="hljs-number">4</span>) ;<br>    <span class="hljs-comment">/* n = COUNT(n, 5) ;      for 64-bit integers */</span><br>    <span class="hljs-keyword">return</span> n ;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="规范性"><a href="#规范性" class="headerlink" title="规范性"></a>规范性</h1><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><ul><li>common.h作为顶层头文件，主要放置(f10x.h、通用define、通用enum、)，不得包含用户头文件以避免循环依赖。</li><li>#ifndef标识符规范，前面加两个下划线 __COMMON_H</li><li></li></ul><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><table><thead><tr><th>类型</th><th>规则</th><th>详细</th><th>例子</th></tr></thead><tbody><tr><td>全局变量</td><td>前面加 g</td><td></td><td>gRoomHmidity</td></tr><tr><td>指针</td><td>前面加 p</td><td></td><td>pHumidity</td></tr><tr><td>有符号变量</td><td>前面加i</td><td></td><td>iTemperature</td></tr><tr><td>struct函数指针</td><td>前面加f(可选的)</td><td></td><td>fGetVal</td></tr><tr><td>不允许直接访问</td><td>前面加_</td><td></td><td>_DataVal</td></tr><tr><td>enum</td><td>变量前面加 e</td><td></td><td>eFlag</td></tr><tr><td></td><td>值全大写即可</td><td></td><td>ERR_OK</td></tr><tr><td>Typedef</td><td>后面加 _t</td><td></td><td>uint32_t</td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><ul><li>不要使用八进制，误认是十进制。</li><li>Switch default无操作需要得到注释。</li><li>禁止变量未赋值就进行使用。</li><li>如果某常量与其他常量密切相关，在定义中应该明确表示出此关系。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">float</span> RAD=<span class="hljs-number">100</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">float</span> DIAM=RAD*<span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><ul><li><strong>通讯过程中使用的结构,必须注意字节序。</strong></li><li><strong>宏定义中尽量不使用return、goto、continue、break等改变程序流程的语句。</strong></li><li>避免使用危险函数sprintf &#x2F;vsprintf&#x2F;strcpy&#x2F;strcat&#x2F;gets操作字符串<ul><li>用strncpy()代替strcpy()</li><li>用strncat()代替strcat()</li><li>用snprintf()代替sprintf()</li><li>用fgets()代替gets()</li></ul></li><li></li></ul><h1 id="特殊技巧及知识总结"><a href="#特殊技巧及知识总结" class="headerlink" title="特殊技巧及知识总结"></a>特殊技巧及知识总结</h1><ul><li>字符串中可以使用\0OO(八进制)或\xHH(十六进制)来引用ASCII码中的符号。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ascii=\x35\n&quot;</span>);  <span class="hljs-comment">// &quot;ascii=5&quot;</span><br></code></pre></td></tr></table></figure><ul><li>if&#x2F;else结构中尽量把TRUE概念较高的条件放到前面可以提高效率。</li><li>尽量把最有可能FALSE的子表达式放在“&amp;&amp;”的左边，同理尽量把最有可能为TRUE的子表达式放在“||”的左边。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>( p5 &amp;&amp; p95 )		<span class="hljs-comment">//第一个不满足就不满足</span><br><span class="hljs-keyword">if</span>( p95 || p5 )		<span class="hljs-comment">//第一个满足就满足</span><br></code></pre></td></tr></table></figure><ul><li>对于多维数组来说，”先行后列”的遍历效率会更高，但可能不明显。</li><li>如果某常量与其他常量密切相关，在定义中应该明确表示出此关系。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">float</span> RAD=<span class="hljs-number">100</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">float</span> DIAM=RAD*<span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><ul><li><p>如果输入参数传递的是一个ADT&#x2F;UDT类型的参数（抽象数据类型&#x2F;用户定义数据类型），宜采用 <code>const &amp;</code>的方式来传递以提高效率。而对于int等类型的基本类型的参数没有必要改成 <code>const &amp;</code>传递。指针传递，提高效率。</p></li><li><p>虽然类型名称和<code>*</code>组合是一种指针类型，但是编译器是将<code>*</code>于后面的变量结合的，列如：</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* a,b,c;<br><span class="hljs-comment">//编译器的理解是  a是int*， b、c是int</span><br><span class="hljs-comment">//这也是为什么推荐将*粘着变量的原因</span><br><span class="hljs-type">int</span> *a,b,c;<br></code></pre></td></tr></table></figure><ul><li>多维数组中的指针</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//以下四种表达是等价的</span><br><span class="hljs-comment">// i是指行，j是指列</span><br><span class="hljs-comment">// a[i][j]里面 *(a+i) 就等价于 a[i]</span><br>a[i][j]<br>*(a[i]+j)<br>(*(a+i))[j]<br>*(*(a+i)+j)<br></code></pre></td></tr></table></figure><ul><li><span style="color:red">字符数组</span>是保存字符变量的数组，而<span style="color:red">字符串</span>是以<code>\0</code>结尾的字符数组。</li><li>malloc&#x2F;free和new&#x2F;delete，这两者的区别主要有。new&#x2F;delete是C++里的，更高级，更安全，返回的是有类型的指针，出错会抛出异常。</li><li>中断内不能使用除法<ul><li>中断内有些指令需要较多的周期才能完成，它们是除法指令，双字传送指令LDRD&#x2F;STRD以及多<br>重数据传送指令(LDM&#x2F;STM)。对于前两者，CM3将为了保证中断及时响应而取消它们的执行。也就是中断内无法完成<strong>除法指令</strong>！！！</li></ul></li><li>调试模式如果单步调试，会屏蔽各种中断，定时器，IWDG都无法进行，而且定时器仍然在计数但是不会响应中断。</li></ul><h2 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">switch</span> (tx_semaphore_get(tx_semaphore, convert_ms_to_ticks(timeout)))<br>&#123;<br>    <span class="hljs-keyword">case</span> TX_SUCCESS:<br>        result = FFW_SUCCESS;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> TX_NO_INSTANCE:<br>        result = FFW_TIMEOUT;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> TX_SEMAPHORE_ERROR:<br>        result = FFW_INVALID_ARGUMENT;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        result = FFW_FAILURE;<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-comment">// convert_ms_to_ticks 这样做会更加通用</span><br></code></pre></td></tr></table></figure><h1 id="BUG-翻车集锦"><a href="#BUG-翻车集锦" class="headerlink" title="BUG 翻车集锦"></a>BUG 翻车集锦</h1><ul><li><p>TIM捕获触发DMA传输，但是在调试模式下DMA传出来的数据有问题。</p><p>把DMA出来的的数据再复制一份，复制出来的数据是没有问题的。</p><p>分析可能是，DEBUG下CPU停了，但是DMA总线还在跑，外设可能也是还在运行的，导致看起来DMA出来的数据有问题。</p></li><li><p>ADC矫正会发生ADC转换，如果有DMA配合使用，需要注意DMA需要在ADC矫正后使能。</p></li><li><p>隐式转换 小范围会转换成大范围 有一点特殊的是 unsigned int &gt; int</p></li><li><p>运算符优先级！位运算符优先级较低</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//编译报错</span><br>(DS18B20_DQ_IN != <span class="hljs-number">0</span>)? data_temp |= <span class="hljs-number">0x80</span>:data_temp&amp;=<span class="hljs-number">0x7f</span>;<br><span class="hljs-comment">//规范写法</span><br>(DS18B20_DQ_IN!=<span class="hljs-number">0</span>)? (data_temp|=<span class="hljs-number">0x80</span>):(data_temp&amp;=<span class="hljs-number">0x7f</span>);<br></code></pre></td></tr></table></figure><ul><li>运算符优先级！！！极注意！！！ 请小心有位运算时打上括号 &lt;&lt; 比 +- 要低</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">u16 temp;<br>u8 h,l;<br>temp = (u16)(h&lt;&lt;<span class="hljs-number">8</span>) + l;<span class="hljs-comment">// 正确语法</span><br>temp = h&lt;&lt;<span class="hljs-number">8</span> + l;<span class="hljs-comment">// 错误语法！！！！！</span><br></code></pre></td></tr></table></figure><ul><li><p><code>0b110</code> 这种二进制写法似乎只有在GNU模式才被允许。</p></li><li><p>STM32的看门狗是使得RST引脚拉低，来复位的。所以要注意复位电容的选择，太大会导致软件无法复位。</p></li><li><p><code>代码段内 \ 换行后不能接 /* xxx */ 注释，注释需要些在 \ 的前面，如 /* xxx */ \ 这样才行</code></p></li><li><p>printf 内字符串问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta"># <span class="hljs-keyword">define</span> DC_LOG_ERROR    <span class="hljs-string">&quot;\x11&quot;</span></span><br><br><span class="hljs-comment">// 没有逗号 这是正常想要表达的逻辑, 前面的DC_LOG_ERROR 和 &quot;%s:%d check SID Stasrt&quot; 合并成一个表达式</span><br><span class="hljs-built_in">printf</span>(DC_LOG_ERROR  <span class="hljs-string">&quot;%s:%d check SID Stasrt&quot;</span>,__func__, __LINE__);<br><span class="hljs-comment">// 有逗号 只会识别前面一个字符串 后面的都没了</span><br><span class="hljs-built_in">printf</span>(DC_LOG_ERROR, <span class="hljs-string">&quot;%s:%d check SID Stasrt&quot;</span>,__func__, __LINE__);<br></code></pre></td></tr></table></figure></li></ul></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/embedded/" class="category-chain-item">embedded</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/embedded/" class="print-no-link">#embedded</a> <a href="/tags/note/" class="print-no-link">#note</a> <a href="/tags/stm32/" class="print-no-link">#stm32</a></div></div><div class="license-box my-3"><div class="license-title"><div>嵌入式编程杂乱笔记</div><div>https://www.oikiou.top/2018/ef667962/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Oikiou</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2018年3月11日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i> </span></a><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="NC - 非商业性使用"><i class="iconfont icon-nc"></i> </span></a><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="SA - 相同方式共享"><i class="iconfont icon-sa"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2018/125d6be2/" title="蓝桥杯 超准超声波测距"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">蓝桥杯 超准超声波测距</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2018/8d6db935/" title="CC2530"><span class="hidden-mobile">CC2530</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="twikoo"></div><script type="text/javascript">Fluid.utils.loadComments("#comments",function(){Fluid.utils.createScript("https://lib.baomitu.com/twikoo/1.6.10/twikoo.all.min.js",function(){var o=Object.assign({envId:"https://twikoo.oikiou.top/",region:"ap-shanghai",path:"window.location.pathname"},{el:"#twikoo",path:"window.location.pathname",onCommentLoaded:function(){Fluid.utils.listenDOMLoaded(function(){var o="#twikoo .tk-content img:not(.tk-owo-emotion)";Fluid.plugins.imageCaption(o),Fluid.plugins.fancyBox(o)})}});twikoo.init(o)})})</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar category-bar" style="margin-left:-1rem"><div class="category-list"><div class="category row nomargin-x"><a class="category-item list-group-item category-item-action col-10 col-md-11 col-xm-11" title="embedded" id="heading-605abe26d014c72e3df9deb267e73756" role="tab" data-toggle="collapse" href="#collapse-605abe26d014c72e3df9deb267e73756" aria-expanded="true">embedded <span class="list-group-count">(1)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse show" id="collapse-605abe26d014c72e3df9deb267e73756" role="tabpanel" aria-labelledby="heading-605abe26d014c72e3df9deb267e73756"><div class="category-post-list"><a href="/2018/ef667962/" title="嵌入式编程杂乱笔记" class="list-group-item list-group-item-action active"><span class="category-post">嵌入式编程杂乱笔记</span></a></div></div></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><span>如果你有任何反馈请联系oikiou@outlook.com</span></div><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">总访问量 <span id="busuanzi_value_site_pv"></span> 次 </span><span id="busuanzi_container_site_uv" style="display:none">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script>var relativeDate=function(){var t,e,i,n,m=document.getElementById("updated-time");m&&(e=/\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:Z|[+-]\d{2}:\d{2})/,(i=(t=m.textContent).match(e))&&(n=moment(i[0]).fromNow(),m.textContent=t.replace(e,n)),m.style.display="")};Fluid.utils.createScript("https://lib.baomitu.com/moment.js/2.29.4/moment.min.js",function(){"zh-cn".startsWith("en")?relativeDate():Fluid.utils.createScript("https://lib.baomitu.com/moment.js/2.29.4/locale/zh-cn.min.js",function(){relativeDate()})})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/custom.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>